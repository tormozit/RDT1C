//ирПортативный Перем ирПортативный Экспорт;
//ирПортативный Перем ирОбщий Экспорт;
//ирПортативный Перем ирСервер Экспорт;
//ирПортативный Перем ирКэш Экспорт;
//ирПортативный Перем ирПривилегированный Экспорт;

Перем ИмяКласса Экспорт;
Перем СсылочнаяФормаКласса Экспорт;
Перем ДопКнопкиКомандныхПанелей Экспорт;
Перем СоответствиеЭУ Экспорт;
Перем мФормаАвтодополнение Экспорт;
Перем мФормаВызовМетода Экспорт;

Перем RegExp;
Перем СлужебноеПолеТекста Экспорт;
Перем Парсер;
Перем ШиринаТабуляции;
Перем мПлатформа Экспорт;
Перем ТаблицаЛокальногоКонтекста;
Перем мНачальнаяСтрока Экспорт; // снаружи только для чтения
Перем мНачальнаяКолонка Экспорт; // снаружи только для чтения
Перем мКонечнаяСтрока Экспорт; // снаружи только для чтения
Перем мКонечнаяКолонка Экспорт; // снаружи только для чтения
Перем ТекущееНачалоСтроки;
Перем ОригинальнаяСтрока;
Перем ТекущийКонецСтроки;
Перем НачалоКонтекста;
Перем НачалоСлова;
Перем КонецКонтекста;
Перем ОригинальныйТекст;
Перем ТекстБезКомментариевИОпасныхСтрок;
Перем мТекстДляПоискаОпределения Экспорт;
Перем мПозицияТекстаДляПоискаОпределения;
Перем мРодительскийКонтекст;
Перем мКонтекст;
Перем мВызовМетода Экспорт;
Перем мЭтоСтроковыйЛитерал Экспорт;
Перем мЭтоОбъявлениеПсевдонима Экспорт;
Перем мТекущееСлово;
Перем мПредшествующийТекст Экспорт;
Перем мНомерПараметра Экспорт;
Перем мИмяМетода Экспорт;
Перем мЭтоКонструктор Экспорт;
Перем мФактическиеПараметры Экспорт;
Перем мПервыйПараметр;
Перем мРазбиратьКонтекст;
Перем МассивЗащитыОтРекурсии;
Перем мАвтоКонтекстнаяПомощь Экспорт;
Перем мРасширенноеПолучениеМетаданныхADO Экспорт;
Перем ПравилаВычисленияФункций;
Перем мПоследнийРежимВызоваСправки;
Перем мИменаОбщихТиповПоИменамКлассовCOM;
Перем мПарсер;
Перем мДиалектSQL Экспорт;
Перем мДиалектыSQL Экспорт;
Перем мПараметрыДиалектаSQL Экспорт;
Перем мПрефиксыПараметров Экспорт;
Перем мМаркерСлужебногоКомментария Экспорт;
Перем мОткрытьСправкуПоПараметру Экспорт; // снаружи только для чтения
Перем мМодульМетаданных Экспорт;
Перем мСтруктурыТиповПодсказкиУдержания;
Перем МассивКомКлассов;
Перем мКонкретныйТипКонтекста;
Перем мСтруктураТипаКонтекста;
Перем мТолькоСсылочныеИменаТипов;
Перем мСоответствиеТиповСловHTML;
Перем РазрешеноСобытиеПередПоказомАвтодополнения;
Перем АвтоматическаяПодсказкаПоВызовуМетода Экспорт;
Перем АвтоматическаяПодсказкаАвтодополненияHTML Экспорт;
Перем ПоказыватьВсеТипыВСпискеАвтодополненияHTML Экспорт;

Перем шЧисло;
Перем шЛюбой;
Перем шБуква;
Перем шСтрокаПрограммы Экспорт;
Перем шНачалоСтрокиПрограммы;
Перем шСтрокаЗапроса;
Перем шИндекс;
Перем шСкобки;
Перем шНачалоСкобок;
Перем шИмя;
Перем шИмяСкобки;
Перем шПараметрЗапроса;
Перем шПредИмя;
Перем шИЗ;
Перем шРазделитель;
Перем шВыражениеПрограммы;
Перем шВыражениеЗапроса;
Перем шВызовМетодаПрограммы;
Перем шВызовМетодаЗапроса;
Перем шПока;
Перем шЕсли;
Перем шВызватьИсключение;
Перем шНачалоТокена;  
Перем шКонецТокена;
Перем шКомментарий;
Перем шПрисваивание;
Перем шПоискОписанияТаблицы;

// Инициализирует экземпляр класса.
//
// Параметры:
//  *СтруктураЭкземляров - Структура, *Неопределено - содержит все объекты данного класса для данной формы;
//  пФорма       - Форма - владелец элементов управления;
//  пПолеТекстовогоДокумента – ПолеТекста;
//  *пКоманднаяПанель – КоманднаяПанель, *Неопределено – в конце которой будут размещены кнопки;
//  *пЛиЯзыкЗапросов - Булево, *Ложь - режим языка запросов, иначе внутренний язык;
//  *пМетодВыполнения - Строка, *"" - имя метода выполнения программного кода;
//  *пКонтекстВыполнения - Тип, Запрос, Произвольный, *Неопределено - контекст выполнения программного кода или текста запроса;
//  *пТипТекста  - Строка, *"Алгоритм" - "Алгоритм" или "Выражение".
//
Процедура ИнициализироватьНеинтерактивно(пЯзыкПрограммы = 0, пМетодВыполнения = "", пКонтекстВыполнения = Неопределено, пТипТекста = "Алгоритм",
	пКонфигурация = Неопределено, пПолеТекстовогоДокумента= Неопределено) Экспорт

	ЭтотОбъект.ЯзыкПрограммы = пЯзыкПрограммы;
	ЭтотОбъект.МетодВыполнения = пМетодВыполнения;
	ЭтотОбъект.ТипТекста = пТипТекста;
	Если пПолеТекстовогоДокумента <> Неопределено Тогда
		ЭтотОбъект.ПолеТекста = ирОбщий.ОболочкаПоляТекстаЛкс(пПолеТекстовогоДокумента);
	КонецЕсли; 
	УстановитьКонфигурациюМетаданных(пКонфигурация, пКонтекстВыполнения);
	ОчиститьТаблицуСловЛокальногоКонтекста();
	мПрефиксыПараметров = мДиалектыSQL.Скопировать(, "ПрефиксПараметра");
	мПрефиксыПараметров.Свернуть("ПрефиксПараметра");
	мПрефиксыПараметров.ВыгрузитьКолонку(0);
	
	Если ЯзыкПрограммы = 1 Тогда
		Если КонтекстВыполнения = Неопределено Тогда
			КонтекстВыполнения = Новый ПостроительЗапроса;
		КонецЕсли;
		шПредИмя = "(?:[^&#?" + шБуква + "\d\.]|^)";
	Иначе
		шПредИмя = "(?:[^" + шБуква + "\d\.]|^)";
	КонецЕсли;
	
	Если МетодВыполнения = "" Тогда
		ЭтотОбъект.МетодВыполнения = "ВыполнитьЛокально";
	КонецЕсли;
	Попытка
		ПроверитьПрограммныйКод(, "");
	Исключение
		ирОбщий.СообщитьСУчетомМодальностиЛкс(ОписаниеОшибки());
		ирОбщий.СообщитьСУчетомМодальностиЛкс("Задан неверный контекст выполнения программы. Будет использован общий контекст выполнения");
		ЭтотОбъект.КонтекстВыполнения = ЭтотОбъект;
		ЭтотОбъект.МетодВыполнения = "ВыполнитьПрограмму";
	КонецПопытки;
	
КонецПроцедуры

#Если Клиент Тогда

// Инициализирует экземпляр класса.
//
// Параметры:
//  *СтруктураЭкземляров - Структура, *Неопределено - содержит все объекты данного класса для данной формы;
//  пФорма       - Форма - владелец элементов управления;
//  пПолеТекстовогоДокумента – ПолеТекста;
//  *пКоманднаяПанель – КоманднаяПанель, *Неопределено – в конце которой будут размещены кнопки;
//  *пЛиЯзыкЗапросов - Булево, *Ложь - режим языка запросов, иначе внутренний язык;
//  *пМетодВыполнения - Строка, *"" - имя метода выполнения программного кода;
//  *пКонтекстВыполнения - Тип, Запрос, Произвольный, *Неопределено - контекст выполнения программного кода или текста запроса;
//  *пТипТекста  - Строка, *"Алгоритм" - "Алгоритм" или "Выражение".
//
Процедура Инициализировать(СтруктураЭкземляров = Неопределено, пФорма, пПолеТекстовогоДокумента, пКоманднаяПанель = Неопределено,
	пЯзыкПрограммы = 0, пМетодВыполнения = "", пКонтекстВыполнения = Неопределено, пТипТекста = "Алгоритм", пКонфигурация = Неопределено) Экспорт

	#Если Сервер И Не Сервер Тогда
		мПлатформа = Обработки.ирПлатформа.Создать();
	#КонецЕсли
	мПлатформа.ПодключитьПерехватКлавиатуры();
	СсылочнаяФормаКласса = Ложь;
	КоманднаяПанель = пКоманднаяПанель;
	УстановитьФормуВладельца(пФорма);
	ИнициализироватьНеинтерактивно(пЯзыкПрограммы, пМетодВыполнения, пКонтекстВыполнения, пТипТекста, пКонфигурация, пПолеТекстовогоДокумента);
	
	Имя = ПолеТекста.ЭлементФормы.Имя;
	Если КоманднаяПанель = Неопределено Тогда
		КоманднаяПанель = ФормаВладелец.ЭлементыФормы.Добавить(Тип("КоманднаяПанель"), "КоманднаяПанель" + Имя, Ложь);
		ПолеТекста.ЭлементФормы.КонтекстноеМеню = КоманднаяПанель;
	КонецЕсли;
	
	ФормаКласса = мПлатформа.ПолучитьМакетКомпоненты(ЭтотОбъект);
	КнопкиМакета = ФормаКласса.ЭлементыФормы["КоманднаяПанель" + Формат(ЯзыкПрограммы, "ЧН=")].Кнопки;
	ирОбщий.ДобавитьКнопкиКоманднойПанелиКомпонентыЛкс(ЭтотОбъект, КнопкиМакета, КоманднаяПанель);
	
	КнопкиМакета = ФормаКласса.ЭлементыФормы.КоманднаяПанельОбщая.Кнопки;
	ирОбщий.ДобавитьКнопкиКоманднойПанелиКомпонентыЛкс(ЭтотОбъект, КнопкиМакета, КоманднаяПанель);
	
	Попытка
		ФормаВладелец.ПодключитьОбработчикОжидания("КлсПолеТекстаПрограммыАвтоОбновитьСправку", 100);;
		ФормаВладелец.ОтключитьОбработчикОжидания("КлсПолеТекстаПрограммыАвтоОбновитьСправку");
	Исключение
		//КоманднаяПанель.Кнопки.Удалить(ирОбщий.КнопкаКоманднойПанелиЭкземпляраКомпонентыЛкс(ЭтотОбъект, "АвтоКонтекстнаяПомощь"));
		Кнопка = ирОбщий.КнопкаКоманднойПанелиЭкземпляраКомпонентыЛкс(ЭтотОбъект, "АвтоКонтекстнаяПомощь");
		Кнопка.Доступность = Ложь;
	КонецПопытки;
	
	//ФайлШаблоновТекста = ирОбщий.ВосстановитьЗначениеЛкс(ИмяКласса + ".ФайлШаблоновТекста");
	//Если Ложь
	//	Или ТипЗнч(ФайлШаблоновТекста) <> Тип("Строка")
	//	Или ФайлШаблоновТекста = ""
	//Тогда
	//	КнопкаВыполнитьШаблон = ирОбщий.КнопкаКоманднойПанелиЭкземпляраКомпонентыЛкс(ЭтотОбъект, "ВыполнитьШаблон");
	//	КнопкаВыполнитьШаблон.Доступность = Ложь;
	//	КнопкаВыполнитьШаблон.СочетаниеКлавиш = Новый СочетаниеКлавиш(Клавиша.Нет); // Чтобы освободить сочетание клавиш
	//КонецЕсли; 
	
	Если СтруктураЭкземляров <> Неопределено Тогда
		СтруктураЭкземляров.Вставить(Имя, ЭтотОбъект);
	КонецЕсли;
	
КонецПроцедуры

Процедура ИнициализироватьСсылочно(пФорма, мСвойстваФормы, пПолеТекстовогоДокумента, пКоманднаяПанель = Неопределено,
	пЯзыкПрограммы = 0, пМетодВыполнения = "", пКонтекстВыполнения = Неопределено, пТипТекста = "Алгоритм",
	пКонфигурация = Неопределено) Экспорт

	ИнициализироватьНеинтерактивно(пЯзыкПрограммы, пМетодВыполнения, пКонтекстВыполнения, пТипТекста);
	СсылочнаяФормаКласса = Истина;
	
	ПолеТекста = пПолеТекстовогоДокумента;
	КоманднаяПанель = пКоманднаяПанель;
	Имя = ПолеТекста.Имя;
	УстановитьФормуВладельца(пФорма);
	Если КоманднаяПанель = Неопределено Тогда
		КоманднаяПанель = ФормаВладелец.ЭлементыФормы.Добавить(Тип("КоманднаяПанель"), "КоманднаяПанель" + Имя, Ложь);
		ПолеТекста.КонтекстноеМеню = КоманднаяПанель;
	КонецЕсли;
	
	мСвойстваФормы.Компоненты.Добавить(ЭтотОбъект);
	ФормаКласса = Вычислить("глПолучитьФормуКомпоненты(ЭтотОбъект)");
	СоответствиеЭУ = Новый Соответствие;
	СоответствиеЭУ.Вставить(ПолеТекста, ФормаКласса.ЭлементыФормы.ПолеТекста);
	СоответствиеЭУ.Вставить(КоманднаяПанель,         ФормаКласса.ЭлементыФормы.КП_Компонента);
		
КонецПроцедуры // Инициализировать()

Процедура УстановитьФормуВладельца(пФорма) Экспорт

	ФормаВладелец = пФорма;

КонецПроцедуры // УстановитьВладельца()

// Освобождает ресурсы занятые экземпляром класса.
// Самое главное - очистить ссылки на формы и объекты БД.
//
// Параметры:
//  Нет.
//
Процедура Уничтожить() Экспорт

	Для Каждого Реквизит Из Метаданные().Реквизиты Цикл
		ЭтотОбъект[Реквизит.Имя] = Неопределено;
	КонецЦикла;
	Если мФормаВызовМетода <> Неопределено Тогда
		ЭтотОбъект.мФормаВызовМетода.ВладелецФормы = Неопределено;
	КонецЕсли; 
	ЭтотОбъект.мФормаВызовМетода = Неопределено;
	Если ЭтотОбъект.мФормаАвтодополнение <> Неопределено Тогда
		ЭтотОбъект.мФормаАвтодополнение.ВладелецФормы = Неопределено;
	КонецЕсли; 
	ЭтотОбъект.мФормаАвтодополнение = Неопределено;
	ОчиститьТаблицуСловЛокальногоКонтекста();
	СохранитьСтатистикуВыбораПодсказки();

КонецПроцедуры

Процедура СохранитьСтатистикуВыбораПодсказки() Экспорт 
	
	ирОбщий.СохранитьЗначениеЛкс("ирПлатформа.ТаблицаСтатистикиВыбора", мПлатформа.ТаблицаСтатистикиВыбора);

КонецПроцедуры

Процедура ВнешнееСобытиеОбъекта(Источник, Событие, Данные) Экспорт 
	
	Если Источник <> "KeyboardHook" Тогда
		Возврат;
	КонецЕсли; 
	Если Ложь
		Или ФормаВладелец = Неопределено 
		Или Не ирОбщий.Форма_ВводДоступенЛкс(ФормаВладелец) // Для поля HTML это затратно
	Тогда
		Возврат;
	КонецЕсли;
	ирОбщий.Форма_ВнешнееСобытиеЛкс(ФормаВладелец, Источник, Событие, Данные);
	//Формат строки данные:
	//Первые 5 символов десятичное число в котором закодированы двоичные данные
	//биты 0-7 - виртуальный код клавиши (http://msdn.microsoft.com/en-us/library/dd375731%28v=VS.85%29.aspx)
	//бит 08 - 1 = нажата расширенная клавиша
	//бит 09 - 1 = Правый alt
	//бит 10 - 1 = Левый alt
	//бит 11 - 1 = Правый ctrl
	//бит 12 - 1 = Левый ctrl
	//бит 13 - 1 = Правый shift
	//бит 14 - 1 = Левый shift
	//
	//6 символ и возможно следующие символы могут быть или не быть (максимальное количество 10)
	//Это результат интерпретации клавиши с учетом языковой раскладки. (http://msdn.microsoft.com/en-us/library/ms646320%28v=VS.85%29.aspx)
	//
	ПолученноеЧисло	= Лев(Данные,5);
	ПолученноеЧисло	= Число(ПолученноеЧисло);
	ВиртуальнаяКлавиша	= ПолученноеЧисло % 256;
	ПолученноеЧисло		= ПолученноеЧисло - ВиртуальнаяКлавиша;
	РасширеннаяКлавиша	= ПолученноеЧисло % 512;
	ПолученноеЧисло		= ПолученноеЧисло - РасширеннаяКлавиша;
	ПравыйАльт	= ПолученноеЧисло % 1024;
	ПолученноеЧисло		= ПолученноеЧисло - ПравыйАльт;
	ЛевыйАльт	= ПолученноеЧисло % 2048;
	ПолученноеЧисло		= ПолученноеЧисло - ЛевыйАльт;
	ПравыйСонтрол	= ПолученноеЧисло % 4096;
	ПолученноеЧисло		= ПолученноеЧисло - ПравыйСонтрол;
	ЛевыйСонтрол	= ПолученноеЧисло % 8192;
	ПолученноеЧисло		= ПолученноеЧисло - ЛевыйСонтрол;
	ПравыйШифт	= ПолученноеЧисло % 16384;
	ПолученноеЧисло		= ПолученноеЧисло - ПравыйШифт;
	ЛевыйШифт	= ПолученноеЧисло;
	Если СтрДлина(Данные) > 5 Тогда
		Символ = Сред(Данные,6);
	Иначе
		Символ = "";
	КонецЕсли;
	КодыКлавиш = ирКэш.КодыКлавишЛкс();
	Если ФормаВладелец.ТекущийЭлемент = ПолеТекста.ЭлементФормы Тогда
		Если Ложь
			Или Найти(Данные, КодыКлавиш["CTRL+ALT+Space"]) = 1
		Тогда
			#Если Сервер И Не Сервер Тогда
				ОткрытьАвтодополнение();
			#КонецЕсли
			ВыполнитьКоманду("ОткрытьАвтодополнение", Данные);
		КонецЕсли; 
		// Подсказка по вызову метода
		Если Ложь
			Или ЛиДоступноОткрытиеСвободнойФормы()
			Или ТипЗнч(ПолеТекста.ЭлементФормы) = Тип("ПолеТекстовогоДокумента")
		Тогда
			Если Ложь
				Или Найти(Данные, КодыКлавиш["CTRL+SHIFT+Space"]) = 1
			Тогда
				ВыполнитьКоманду("ПодсказатьПараметр");
			КонецЕсли; 
			ФормаВызовМетода = ФормаВызовМетода();
			БылаОткрыта = ФормаВызовМетода.Открыта();
			Если Истина
				И Не БылаОткрыта
				И ЛиДоступноОткрытиеСвободнойФормы()
				И (Ложь
					Или Символ = "(" 
					Или Символ = ",")
			Тогда
				Если АвтоматическаяПодсказкаПоВызовуМетода() Тогда
					ВыполнитьКоманду("ПодсказатьПараметрАвто");
				КонецЕсли;
			КонецЕсли;
			Если БылаОткрыта Тогда
				ОбновитьПодсказкуПоВызовуМетода();
			КонецЕсли; 
			Если Ложь
				Или Найти(Данные, КодыКлавиш["ALT+Up"]) = 1
				Или Найти(Данные, КодыКлавиш["ALT+Down"]) = 1
				//Или Найти(Данные, "04390") = 1 // CTRL+Up
				//Или Найти(Данные, "04392") = 1 // CTRL+Down
				Или Найти(Данные, КодыКлавиш["Esc"]) = 1 // Работает только в поле HTML документа. В остальных местах платформа делает полный перехват 
			Тогда  
				ФормаВызовМетода.ВнешнееСобытие(Источник, Событие, Данные);
			КонецЕсли;
		КонецЕсли; 
		//Сообщить(Данные);
	КонецЕсли; 

КонецПроцедуры

Процедура ОбновитьПодсказкуПоВызовуМетода()
	
	ФормаВызовМетода = ФормаВызовМетода();
	Если Не ФормаВызовМетода.Открыта() Тогда
		Возврат;
	КонецЕсли; 
	ФормаВызовМетода.ПараметрСтруктураТипаКонтекста = Неопределено;
	//Если Форма.Открыта() Тогда
		ФормаВызовМетода.ОбновитьИлиЗакрытьФорму(, Истина);
	//КонецЕсли;

КонецПроцедуры

Функция ЛиМожноЗакрытьФорму() Экспорт 
	ФормаВызовМетода = ФормаВызовМетода();
	Если ФормаВызовМетода.Открыта() Тогда
		ФормаВызовМетода.Закрыть();
		Результат = Ложь;
	Иначе
		Результат = Истина;
	КонецЕсли; 
	Возврат Результат;
КонецФункции

Функция ФормаВызовМетода() Экспорт 
	
	Если мФормаВызовМетода = Неопределено Тогда
		мФормаВызовМетода = ПолучитьФорму("ВызовМетода", ФормаВладелец);
	КонецЕсли; 
	Возврат мФормаВызовМетода;

КонецФункции
	
// Получает номер текущей строки в тексте (по конечной границе выделения).
//
// Параметры:
//  Нет.
//
// Возвращаемое значение:
//  Число.
//
Функция ПолучитьНомерТекущейСтроки(Начальной = Ложь) Экспорт

	Если ПолеТекста <> Неопределено Тогда
		ПолеТекста.ПолучитьГраницыВыделения(мНачальнаяСтрока, мНачальнаяКолонка, мКонечнаяСтрока, мКонечнаяКолонка);
		Если Начальной Тогда
			Возврат мНачальнаяСтрока;
		Иначе
			Возврат мКонечнаяСтрока;
		КонецЕсли; 
	Иначе
		Возврат Неопределено;
	КонецЕсли; 

КонецФункции // ПолучитьНомерТекущейСтроки()

// Получает текущее объектное выражение (на котором установлен курсор).
//
// Параметры:
//  Нет.
//
// Возвращаемое значение:
//  Строка - объектное выражение, в котором находится курсов.
//
Функция ТекущееОбъектноеВыражение(НомерСтроки = 0, НомерКолонки = 0, выхЕстьТочкаСправа = Ложь, КончитьОбработкуКоманды = Истина) Экспорт

	Если ирОбщий.ПроверитьПлатформаНеWindowsЛкс(,, Истина) Тогда
		Возврат Неопределено;
	КонецЕсли; 
	мПлатформа.ИнициализацияОписанияМетодовИСвойств();
	КончитьОбработкуКоманды();
	Если НомерСтроки > ПолеТекста.КоличествоСтрок() Тогда
		Возврат Неопределено;
	КонецЕсли;
	РазобратьТекущийКонтекст(, выхЕстьТочкаСправа,, НомерСтроки, НомерКолонки);
	Если КончитьОбработкуКоманды Тогда
		КончитьОбработкуКоманды();
	КонецЕсли; 
	Если мЭтоСтроковыйЛитерал Тогда
		мКонтекст = "";
	КонецЕсли; 
	Возврат мКонтекст;

КонецФункции

// Получает текущее контекст параметра. 
//
// Параметры:
//  Нет.
//
// Возвращаемое значение:
//  Структура -
//    "ОбъектноеВыражение"
//    "НомерПараметра"
//
Функция ПолучитьТекущийКонтекстПараметра() Экспорт

	КончитьОбработкуКоманды();
	РазобратьТекущийКонтекст(,, Истина);
	КончитьОбработкуКоманды();
	СтруктураРезультата = Новый Структура;
	СтруктураРезультата.Вставить("ОбъектноеВыражение", мВызовМетода);
	СтруктураРезультата.Вставить("ПервыйПараметр", мПервыйПараметр);
	СтруктураРезультата.Вставить("НомерПараметра", мНомерПараметра);
	Возврат СтруктураРезультата;

КонецФункции

// Разбирает контекст метода.
//
// Параметры:
//  Нет.
//
Функция ТекущийКонтекстМетода()

	RegExp.Global = Истина;
	мКонтекст = "";
	ОригинальныйТекст = ПолеТекста.ПолучитьТекст();
	СлужебноеПолеТекста.УстановитьТекст(ОригинальныйТекст);
	ПредшествующийТекст = "";
	СледующийТекст = "";
	МаксЧислоПредшествующихСтрок = 20; // Чтобы снизить вероятность зацикливания при вычислении рег.выражения
	Если мКонечнаяСтрока > 1 Тогда
		СлужебноеПолеТекста.УстановитьГраницыВыделения(Макс(1, мКонечнаяСтрока - МаксЧислоПредшествующихСтрок - 1), 1, мКонечнаяСтрока - 1, 333);
		ПредшествующийТекст = СлужебноеПолеТекста.ВыделенныйТекст;
	КонецЕсли; 
	
	МаксНомерСтроки = Мин(СлужебноеПолеТекста.КоличествоСтрок(), мКонечнаяСтрока + 100);
	Если Истина
		И МаксНомерСтроки > 0
		И МаксНомерСтроки <= СлужебноеПолеТекста.КоличествоСтрок() 
	Тогда
		СлужебноеПолеТекста.УстановитьГраницыВыделения(мКонечнаяСтрока + 1, 1, МаксНомерСтроки, 333);
		СледующийТекст = СлужебноеПолеТекста.ВыделенныйТекст;
	КонецЕсли;
	
	ТекстДоКурсора = ПредшествующийТекст + ТекущееНачалоСтроки; // Так почему то иногда возникало смещение на 1 символ
	ТекстПослеКурсора = ТекущийКонецСтроки + Символы.ПС + СледующийТекст;
	Если мЭтоСтроковыйЛитерал Тогда
		ТекстДоКурсора = ТекстДоКурсора + """";
		ТекстПослеКурсора = """" + ТекстПослеКурсора;
		Если ирОбщий.ЛиВнутриСтроковогоЛитералаЛкс(ТекстПослеКурсора) Тогда
			ТекстПослеКурсора = ТекстПослеКурсора + """";
		КонецЕсли; 
	КонецЕсли; 
	Если ЯзыкПрограммы = 0 Тогда
		ШаблонПараметра = "(?:" + шВыражениеПрограммы + ")?" + шРазделитель + "*";
	Иначе
		ШаблонПараметра = "(?:" + шВыражениеЗапроса   + ")?" + шРазделитель + "*";
	КонецЕсли;
	RegExp.Global = Ложь;
	RegExp.MultiLine = Ложь;
	RegExp.Pattern = "^(?:" + ШаблонПараметра + ",)*" + ШаблонПараметра + "\)";
	Результат = RegExp.НайтиВхождения(ТекстПослеКурсора);
	Если Результат.Количество() > 0 Тогда
		//КонецВыражения = Лев(ТекстПослеКурсора, Результат[0].Length);
		КонецВыражения = Результат[0].Value;
	КонецЕсли;
	
	RegExp.Global = Ложь;
	RegExp.MultiLine = Ложь;
	Если ЯзыкПрограммы = 1 Тогда
		RegExp.Pattern = шВызовМетодаЗапроса + "$";
	Иначе 
		RegExp.Pattern = шВызовМетодаПрограммы + "$";
	КонецЕсли;
	Результат = RegExp.НайтиВхождения(ТекстДоКурсора + Лев(КонецВыражения, СтрДлина(КонецВыражения) - 1) + ",");
	//Результат = RegExp.НайтиВхождения(Лев(ОригинальныйТекст, СтрДлина(ТекстДоКурсора)+ СтрДлина(КонецВыражения) - 1) + ","); // Отрезаем последний символ зачем то
	мФактическиеПараметры = Новый Массив;
	Если Результат.Количество() > 0 Тогда
		//ПоследнееВхождение = Результат[Результат.Количество() - 1];
		ПоследнееВхождение = Результат[0];
		//ДлинаТекста = СтрДлина(ОригинальныйТекст);
		//Попытка
		//	СлужебноеПолеТекста.УстановитьГраницыВыделения(ПоследнееВхождение.FirstIndex + 1, 
		//		Мин(ДлинаТекста, ПоследнееВхождение.FirstIndex + 1 + ПоследнееВхождение.Length));
		//Исключение
		//	СлужебноеПолеТекста.УстановитьГраницыВыделения(ПоследнееВхождение.FirstIndex + 1, 
		//		Мин(ДлинаТекста, ПоследнееВхождение.FirstIndex + 1 + ПоследнееВхождение.Length - 1)); // -1 надо делать из-за бага платформы (она не дает выделить последний символ в тексте)
		//КонецПопытки;
		//СлужебноеПолеТекста.ПолучитьГраницыВыделения(мНачальнаяСтрока, мНачальнаяКолонка, мКонечнаяСтрока, мКонечнаяКолонка);
		мВызовМетода = ПоследнееВхождение.SubMatches(1) + "(";
		ТекстПараметров = ПоследнееВхождение.SubMatches(5) + ПоследнееВхождение.SubMatches(14);
		мЭтоКонструктор = ЗначениеЗаполнено(ПоследнееВхождение.SubMatches(0));
		RegExp.Global = Истина;
		Если ЯзыкПрограммы = 0 Тогда
			ШаблонПараметра = "(" + шВыражениеПрограммы + ")?" ;
		Иначе
			ШаблонПараметра = "(" + шВыражениеЗапроса   + ")?";
		КонецЕсли;
		RegExp.Pattern = ШаблонПараметра + шРазделитель + "*,";
		Результат = RegExp.НайтиВхождения(ТекстПараметров);
		ЛокальнаяПозицияКурсора = СтрДлина(ТекстПараметров) + 1 - СтрДлина(КонецВыражения);
		Счетчик = 0;
		Для Каждого Вхождение Из Результат Цикл
			Счетчик = Счетчик + 1;
			ПозицияВхождения = Вхождение.FirstIndex;
			Если Истина
				И (ПозицияВхождения + 1) <= ЛокальнаяПозицияКурсора 
				И (ПозицияВхождения + Вхождение.Length + 1) >= ЛокальнаяПозицияКурсора 
			Тогда
				мНомерПараметра = Счетчик;
			КонецЕсли;
			мФактическиеПараметры.Добавить(СокрЛП(Вхождение.SubMatches(0)));
		КонецЦикла;
		Если мФактическиеПараметры.Количество() > 0 Тогда
			мПервыйПараметр = мФактическиеПараметры[0];
		КонецЕсли; 
		мИмяМетода = ирОбщий.ПервыйФрагментЛкс(ирОбщий.ПоследнийФрагментЛкс(мВызовМетода), "(");
		СтруктураРезультата = Новый Структура;
		СтруктураРезультата.Вставить("ОбъектноеВыражение", мВызовМетода);
		СтруктураРезультата.Вставить("ОригинальныйТекст", Лев(ПоследнееВхождение.Value, СтрДлина(ПоследнееВхождение.Value) - 1) + ")");
		СтруктураРезультата.Вставить("МассивПараметров", мФактическиеПараметры);
		СтруктураРезультата.Вставить("НомерПараметра", мНомерПараметра);
		СтруктураРезультата.Вставить("ЭтоКонструктор", мЭтоКонструктор);
		Возврат СтруктураРезультата;
	Иначе
		Возврат Неопределено;
	КонецЕсли;

КонецФункции

// Разбирает контекст метода.
//
// Параметры:
//  Нет.
//
Функция УстановитьТекущийКонтекстМетода(НовыйТекст) Экспорт

	#Если Сервер И Не Сервер Тогда
		ПолеТекста = Обработки.ирОболочкаПолеТекста.Создать();
	#КонецЕсли
	ПолеТекста.УстановитьГраницыВыделения(мНачальнаяСтрока, мНачальнаяКолонка, мКонечнаяСтрока, мКонечнаяКолонка);
	ВыделенныйТекст(НовыйТекст);
	ПолеТекста.УстановитьГраницыВыделения(мНачальнаяСтрока, мНачальнаяКолонка, мНачальнаяСтрока, мНачальнаяКолонка,, ФормаВладелец);

КонецФункции

// Разбирает контекст УК.
//
// Параметры:
//  Нет.
//
Функция ПолучитьТекущийКонтекстУК() Экспорт

	мПлатформа.ИнициализацияОписанияМетодовИСвойств();
	ПолеТекста.ПолучитьГраницыВыделения(мНачальнаяСтрока, мНачальнаяКолонка, мКонечнаяСтрока, мКонечнаяКолонка);
	RegExp.Global = Истина;
	ПрочитатьНачалоИКонецТекущейСтроки();
	ИмяСтруктурыПараметров = "";
	
	ОригинальныйТекст = ПолеТекста.ПолучитьТекст();
	СлужебноеПолеТекста.УстановитьТекст(ОригинальныйТекст);
	мПредшествующийТекст = "";
	СледующийТекст = "";
	Если мКонечнаяСтрока > 1 Тогда
		СлужебноеПолеТекста.УстановитьГраницыВыделения(1, 1, мКонечнаяСтрока - 1, 333);
		мПредшествующийТекст = СлужебноеПолеТекста.ВыделенныйТекст;
	КонецЕсли; 
	МаксНомерСтроки = Мин(СлужебноеПолеТекста.КоличествоСтрок(), мКонечнаяСтрока + 100);
	Если Истина
		И МаксНомерСтроки > 0
		И МаксНомерСтроки <= СлужебноеПолеТекста.КоличествоСтрок() 
	Тогда
		СлужебноеПолеТекста.УстановитьГраницыВыделения(мКонечнаяСтрока + 1, 1, МаксНомерСтроки, 333);
		СледующийТекст = СлужебноеПолеТекста.ВыделенныйТекст;
	КонецЕсли;
	ТекстДоКурсора = мПредшествующийТекст + Символы.ПС + ТекущееНачалоСтроки;
	ТекстПослеКурсора = ТекущийКонецСтроки + Символы.ПС + СледующийТекст;
	
	ШаблонУК = "(" + шИмя + ")" + шРазделитель + "*=" + шРазделитель + "*УК\((" + шИмя + ")\)";
	RegExp.Global = Ложь;
	RegExp.MultiLine = Ложь;
	RegExp.Pattern = "^" + "(" + шРазделитель + "*)" + ШаблонУК;
	Результат = RegExp.НайтиВхождения(ТекущееНачалоСтроки + ТекстПослеКурсора);
	Если Результат.Количество() > 0 Тогда
		Смещение = Результат[0].SubMatches(0);
		ИмяСтруктурыПараметров = Результат[0].SubMatches(1);
		МассивПараметров = Новый Массив;
		МассивПараметров.Добавить(Результат[0].SubMatches(2));
	Иначе
		Возврат Неопределено;
	КонецЕсли;
	
	ШаблонПараметра = шРазделитель + "*" + ИмяСтруктурыПараметров + "\.(" + шИмя + ")" + шРазделитель + "*=" 
		+ шРазделитель + "*(" + шВыражениеПрограммы + ")?" + шРазделитель + "*" + ";";
	RegExp.Pattern = "^" + "(" + шРазделитель + "*)" + ШаблонУК + ";" + "((?:" + ШаблонПараметра  + шРазделитель + "*" + ")*)";
	Результат = RegExp.НайтиВхождения(ТекущееНачалоСтроки + ТекстПослеКурсора);
	Если Результат.Количество() > 0 Тогда
		ПолныйТекстВыражения = Результат[0].Value;
	Иначе
		Возврат Неопределено;
	КонецЕсли;
	
	//RegExp.Global = Ложь;
	RegExp.MultiLine = Ложь;
	RegExp.Pattern = ШаблонУК + ";" + "((?:" + ШаблонПараметра  + шРазделитель + "*" + ")*)$";
	Результат = RegExp.НайтиВхождения(мПредшествующийТекст + ПолныйТекстВыражения);
	СтруктураПараметров = Новый Структура;
	Если Результат.Количество() > 0 Тогда
		ПоследнееВхождение = Результат[Результат.Количество() - 1];
		Попытка
			СлужебноеПолеТекста.УстановитьГраницыВыделения(ПоследнееВхождение.FirstIndex + 1, 
				ПоследнееВхождение.FirstIndex + 1 + ПоследнееВхождение.Length);
		Исключение
			СлужебноеПолеТекста.УстановитьГраницыВыделения(ПоследнееВхождение.FirstIndex + 1, 
				ПоследнееВхождение.FirstIndex + 1 + ПоследнееВхождение.Length - 1); // -1 надо делать из-за бага платформы (она не дает выделить последний символ в тексте)
		КонецПопытки;
		СлужебноеПолеТекста.ПолучитьГраницыВыделения(мНачальнаяСтрока, мНачальнаяКолонка, мКонечнаяСтрока, мКонечнаяКолонка);
		//ИмяСтруктурыПараметров = Результат[0].SubMatches(0);
		ТекстПараметров = ПоследнееВхождение.SubMatches(2);
		RegExp.Global = Истина;
		RegExp.Pattern = ШаблонПараметра;
		Результат = RegExp.НайтиВхождения(ТекстПараметров);
		//ЛокальнаяПозицияКурсора = СтрДлина(ТекстПараметров) - СтрДлина(ПолныйТекстВыражения);
		Счетчик = 0;
		Для Каждого Вхождение Из Результат Цикл
			Счетчик = Счетчик + 1;
			//Если Истина
			//	И (Вхождение.FirstIndex + 1) <= ЛокальнаяПозицияКурсора 
			//	И (Вхождение.FirstIndex + Вхождение.Length + 1) >= ЛокальнаяПозицияКурсора 
			//Тогда
			//	мНомерПараметра = Счетчик;
			//КонецЕсли;
			СтруктураПараметров.Вставить(СокрЛП(Вхождение.SubMatches(0)), СокрЛП(Вхождение.SubMatches(1)));
		КонецЦикла;
		СтруктураРезультата = Новый Структура;
		СтруктураРезультата.Вставить("ИмяСтруктурыПараметров", ИмяСтруктурыПараметров);
		СтруктураРезультата.Вставить("МассивПараметров", МассивПараметров);
		СтруктураРезультата.Вставить("ОригинальныйТекст", ПоследнееВхождение.Value);
		СтруктураРезультата.Вставить("Смещение", Смещение);
		СтруктураРезультата.Вставить("СтруктураПараметров", СтруктураПараметров);
		СтруктураРезультата.Вставить("НомерПараметра", мНомерПараметра);
		Возврат СтруктураРезультата;
	Иначе
		Возврат Неопределено;
	КонецЕсли;

КонецФункции

Процедура НачатьОбработкуКоманды()
	
	мРазбиратьКонтекст = Ложь;

КонецПроцедуры

// Вызывается в конце обработки команды.
//
// Параметры:
//  Нет.
//
Процедура КончитьОбработкуКоманды() Экспорт

	мРазбиратьКонтекст = Истина;

КонецПроцедуры

// Находит первое вхождение слова в тексте. Если слово найдено, устанавливается выделение и фокус.
//
// Параметры:
//  СтрокаПоиска			 - 	 - 
//  СловоЦеликом			 - 	 - 
//  ПолеТекста	 - 	 - 
// 
// Возвращаемое значение:
//   - Булево - была ли найдена и выделена строка
//
Функция НайтиПоказатьСловоВТексте(СтрокаПоиска, СловоЦеликом = Истина, ПолеТекста = Неопределено, УстановитьФокус = Ложь, ИскатьСНачала = Ложь) Экспорт 
	
	Если ПолеТекста = Неопределено Тогда
		ПолеТекста = ЭтотОбъект.ПолеТекста;
	КонецЕсли; 
	Результат = ирОбщий.НайтиПоказатьСтрокуВПолеТекстаЛкс(ФормаВладелец, ПолеТекста, СтрокаПоиска, СловоЦеликом, ИскатьСНачала);
	Если УстановитьФокус Тогда
		УстановитьФокус();
	КонецЕсли; 
	Возврат Результат; 
	
КонецФункции

// Вставляет в текущую позицию поля текстового документа ссылку на объект БД.
//
// Параметры:
//  ЗначенияСвойствНового – Структура – если параметр будет добавлен, то к его строке будут применены эти значения свойств;
//  <Параметр2>  – <Тип.Вид> – <описание параметра>
//                 <продолжение описания параметра>.
//
// Возвращаемое значение:
//               – <Тип.Вид> – <описание значения>
//                 <продолжение описания значения>;
//  <Значение2>  – <Тип.Вид> – <описание значения>
//                 <продолжение описания значения>.
//
Функция ВставитьСсылкуНаОбъектБД(ТабличноеПолеПараметров, ИмяКолонкиИмени = "Имя", ИмяКолонкиЗначения = "Значение", ИмяСтруктурыПараметров = "",
	ОбновитьКопиюСвойстваВНижнемРегистре = Ложь, НачальноеЗначениеВыбора = Неопределено, РазрешитьВыбор = Истина, ВставитьВТекст = Истина) Экспорт

	ТаблицаПараметров = ТабличноеПолеПараметров.Значение;
	ТекущееОбъектноеВыражение = ТекущееОбъектноеВыражение();
	
	Если Истина
		И РазрешитьВыбор
		И НачальноеЗначениеВыбора = Неопределено
		И ВставитьВТекст
	Тогда
		Если Ложь
			Или ЯзыкПрограммы = 0
			Или Лев(ТекущееОбъектноеВыражение, 1) = "&" 
		Тогда
			ИмяПараметра = ТекущееОбъектноеВыражение;
			Если ЯзыкПрограммы = 1 Тогда
				ИмяПараметра = Сред(ИмяПараметра, 2);
			Иначе
				Если Истина
					И Не ПустаяСтрока(ИмяСтруктурыПараметров)
					И Найти(НРег(ИмяПараметра), НРег(ИмяСтруктурыПараметров) + ".") = 1 
				Тогда
					ИмяПараметра = Сред(ИмяПараметра, СтрДлина(ИмяСтруктурыПараметров) + 2);
				КонецЕсли; 
			КонецЕсли; 
			СтрокаНайденногоПараметра = ТаблицаПараметров.Найти(ИмяПараметра, ИмяКолонкиИмени);
			Если СтрокаНайденногоПараметра <> Неопределено Тогда
				Ответ = Вопрос("Использовать тип и значение выделенного в тексте параметра?", РежимДиалогаВопрос.ДаНет);
				Если Ответ = КодВозвратаДиалога.Да Тогда
					ЗначениеПараметра = СтрокаНайденногоПараметра[ИмяКолонкиЗначения];
					Если ирОбщий.ЛиСсылкаНаОбъектБДЛкс(ЗначениеПараметра, Ложь) Тогда
						НачальноеЗначениеВыбора = ЗначениеПараметра;
					КонецЕсли;
				КонецЕсли;
			КонецЕсли;
		КонецЕсли; 
	КонецЕсли; 
	//Если ЗначениеЗаполнено(НачальноеЗначениеВыбора) Тогда
	Если НачальноеЗначениеВыбора <> Неопределено Тогда
		ТипСсылки = ТипЗнч(НачальноеЗначениеВыбора);
		Если Не ирОбщий.ЛиТипСсылкиБДЛкс(ТипСсылки, Ложь) Тогда
			Возврат Неопределено;
		КонецЕсли; 
	КонецЕсли;
	Если РазрешитьВыбор Тогда
		ВыделитьТекущееОбъектноеВыражение();
	КонецЕсли; 
	
	Если ТипСсылки = Неопределено И Не ЗначениеЗаполнено(ТекущееОбъектноеВыражение) Тогда
		СтруктураТипаКонтекста = ПолучитьСтруктуруТипаСправаОтРавно();
		Если СтруктураТипаКонтекста <> Неопределено Тогда
			Если ТипЗнч(СтруктураТипаКонтекста.Метаданные) = Тип("ОбъектМетаданных") Тогда
				ТипСсылки = Тип(ирОбщий.ИмяТипаИзПолногоИмениМДЛкс(СтруктураТипаКонтекста.Метаданные.ПолноеИмя()));
			КонецЕсли; 
		КонецЕсли;
	КонецЕсли;
	
	Если РазрешитьВыбор И ТипСсылки = Неопределено Тогда
		Форма = мПлатформа.ПолучитьФорму("ВыборОбъектаМетаданных", ФормаВладелец, ФормаВладелец);
		лСтруктураПараметров = Новый Структура;
		лСтруктураПараметров.Вставить("ОтображатьСсылочныеОбъекты", Истина);
		лСтруктураПараметров.Вставить("ОтображатьПеречисления", Истина);
		лСтруктураПараметров.Вставить("ОтображатьВнешниеИсточникиДанных", Истина);
		Форма.НачальноеЗначениеВыбора = лСтруктураПараметров;
		Результат = Форма.ОткрытьМодально();
		Если Результат = Неопределено Тогда
			Возврат Неопределено;
		КонецЕсли;
		ТипСсылки = Тип(ирОбщий.ИмяТипаИзПолногоИмениМДЛкс(Результат.ПолноеИмяОбъекта));
	КонецЕсли;
	
	Если НачальноеЗначениеВыбора = Неопределено Тогда
		НачальноеЗначениеВыбора = Новый (ТипСсылки);
	КонецЕсли;
	
	Если РазрешитьВыбор Тогда
		ЗначениеПараметра = ирОбщий.ВыбратьСсылкуЛкс(ТипСсылки, НачальноеЗначениеВыбора);
		УстановитьФокус();
	Иначе
		ЗначениеПараметра = НачальноеЗначениеВыбора;
	КонецЕсли; 
	Если ЗначениеПараметра = Неопределено Тогда
		Возврат Неопределено;
	КонецЕсли;
	Если ТабличноеПолеПараметров.ИзменяетДанные Тогда
		ФормаВладелец.Модифицированность = Истина;
	КонецЕсли; 
	
	СтрокаПараметра = ирОбщий.НайтиДобавитьПараметрСсылкуВТаблицуЛкс(ТаблицаПараметров, ИмяКолонкиИмени, ИмяКолонкиЗначения, ЗначениеПараметра,, ОбновитьКопиюСвойстваВНижнемРегистре);
	Если ВставитьВТекст Тогда
		ТекстВставки = СтрокаПараметра[ИмяКолонкиИмени];
		Если Ложь
			Или ЯзыкПрограммы = 1
			Или ЯзыкПрограммы = 2
		Тогда
			ТекстВставки = "&" + ТекстВставки;
		КонецЕсли;
		Если ЯзыкПрограммы = 0 Тогда
			Если Не ПустаяСтрока(ИмяСтруктурыПараметров) Тогда
				ТекстВставки = ИмяСтруктурыПараметров + "." + ТекстВставки;
			КонецЕсли; 
		КонецЕсли;
		ВыделенныйТекст(ТекстВставки);
	КонецЕсли; 
	Возврат СтрокаПараметра;

КонецФункции

// Обрабатывает нажатие на кнопки
//
// Параметры:
//  Кнопка - Кнопка.
//
// Возвращаемое значение:
//  Булево – результат проверки.
//
Функция Нажатие(Кнопка) Экспорт
	
	Перем Результат;
	Команда = ирОбщий.ПоследнийФрагментЛкс(Кнопка.Имя, "_");
	Если Команда = "АвтоКонтекстнаяПомощь" Тогда
	    УстановитьАвтоКонтекстнаяПомощь(Не Кнопка.Пометка);
	КонецЕсли;
	Результат = ВыполнитьКоманду(Команда,, Ложь);
	Возврат Результат;
	
КонецФункции

Функция ВыполнитьКоманду(Знач Команда, Знач КодКлавиши = "", ОбновитьКонтекст = Истина)
	
	Если ОбновитьКонтекст Тогда
		ФормаВладелец.КлсПолеТекстаПрограммыОбновитьКонтекст(ЭтотОбъект);
	КонецЕсли;
	КончитьОбработкуКоманды();
	Результат = Неопределено;
	Попытка
		мПлатформа.ИнициализацияОписанияМетодовИСвойств();
		ПолеТекста.ПолучитьГраницыВыделения(мНачальнаяСтрока, мНачальнаяКолонка, мКонечнаяСтрока, мКонечнаяКолонка);
		мОткрытьСправкуПоПараметру = Ложь;
		Если Команда = "ОткрытьАвтодополнение" Тогда
			ОткрытьАвтодополнение(КодКлавиши);
		ИначеЕсли Команда = "ПоискОбщегоМетода" Тогда
			ПоискОбщегоМетода();
		ИначеЕсли Команда = "ЗаменитьТабуляции" Тогда
			ЗаменитьТабуляции();
		ИначеЕсли Команда = "ВыделитьСлово" Тогда
			ВыделитьТекущееСлово();
		ИначеЕсли Команда = "СравнитьТекст" Тогда
			 ВариантСинтаксиса = Неопределено;
			Если ЯзыкПрограммы = 0 Тогда
				ВариантСинтаксиса = "ВстроенныйЯзык";
			ИначеЕсли ЯзыкПрограммы = 1 Тогда
				ВариантСинтаксиса = "ЯзыкЗапросов";
			ИначеЕсли ЯзыкПрограммы = 2 Тогда
				ВариантСинтаксиса = "ЯзыкКомпоновки";
			КонецЕсли; 
			ирОбщий.СравнитьСодержимоеЭлементаУправленияЛкс(ФормаВладелец, ПолеТекста, ВариантСинтаксиса);
		ИначеЕсли Истина
			И ЯзыкПрограммы = 1
			И Команда = "УдалитьПереносы"
		Тогда
			УдалитьПереносы();
		ИначеЕсли Команда = "КонструкторЗапросов1С" Тогда
			Результат = ВызватьКонструкторЗапросов(Ложь);
		ИначеЕсли Команда = "КонструкторЗапросовИР" Тогда
			Результат = ВызватьКонструкторЗапросов(Истина);
		ИначеЕсли Команда = "КонструкторЗапросов" Тогда
			Результат = ВызватьКонструкторЗапросов();
		ИначеЕсли Команда = "ВставитьИзБуфераОбменаВесьТекст" Тогда
			ирОбщий.УстановитьТекстСОткатомЛкс(ПолеТекста, ирОбщий.ТекстИзБуфераОбменаОСЛкс());
		ИначеЕсли Команда = "КопироватьВБуферОбменаВесьТекст" Тогда
			ирОбщий.ТекстВБуферОбменаОСЛкс(ПолеТекста.ПолучитьТекст());
		ИначеЕсли Команда = "КопироватьВБуферОбменаТекстВВидеКода" Тогда
			КопироватьВБуферОбменаТекстВВидеКода();
		ИначеЕсли Команда = "Закомментировать" Тогда
			Закомментировать();
		ИначеЕсли Команда = "Раскомментировать" Тогда
			Раскомментировать();
		ИначеЕсли Команда = "РедакторСтроковогоЛитерала" Тогда
			Результат = ОткрытьРедакторСтроковогоЛитерала();
		ИначеЕсли Команда = "ПерейтиКОпределению" Тогда
			ПерейтиКОпределению();
			Результат = мТекущееСлово;
		ИначеЕсли Команда = "Проверить" Тогда
			ПроверитьПрограммныйКод(Истина);
		ИначеЕсли Команда = "УстановитьФокус" Тогда
			УстановитьФокус();
		ИначеЕсли Команда = "Форматировать" Тогда
			ФорматироватьТекст();
		ИначеЕсли Истина
			И ЯзыкПрограммы = 0
			И Команда = "Выполнить"
		Тогда
			ВыполнитьПрограммныйКод();
		ИначеЕсли Команда = "КонтекстныйСинтаксПомощник" Тогда
			мПоследнийРежимВызоваСправки = Команда;
			ОткрытьКонтекстнуюСправку(, ФормаВладелец);
		ИначеЕсли Команда = "СинтаксПомощник" Тогда
			ОткрытьСправкуПоЯзыкуПрограммы();
		ИначеЕсли Команда = "ПодсказатьПараметр" Тогда
			мПоследнийРежимВызоваСправки = Команда;
			ОткрытьСправкуПоПараметру();
		ИначеЕсли Команда = "ПодсказатьПараметрАвто" Тогда
			#Если ТолстыйКлиентОбычноеПриложение Тогда
				Если ФормаВладелец.ТекущийЭлемент = ПолеТекста.ЭлементФормы Тогда
					ОткрытьСправкуПоПараметру(, Ложь);
				КонецЕсли; 
			#КонецЕсли
		ИначеЕсли Команда = "Настройка" Тогда
			ПолучитьФорму("ФормаНастройки", ФормаВладелец).Открыть();
		ИначеЕсли Команда = "ВыполнитьШаблон" Тогда
			ВыполнитьШаблонТекста();
		ИначеЕсли Команда = "НайтиСледующееHTML" Тогда
			НайтиСледующееHTML();
		ИначеЕсли Команда = "НайтиПредыдущееHTML" Тогда
			НайтиПредыдущееHTML();
		ИначеЕсли Команда = "ЗаменитьВхожденияHTML" Тогда
			ЗаменитьВхожденияHTML();
		ИначеЕсли Команда = "СочетанияКлавишHTML" Тогда
			СочетанияКлавишHTML();
		ИначеЕсли Команда = "КонструкторФорматнойСтроки" Тогда
			КонструкторФорматнойСтроки();
		КонецЕсли;
		
		Если Ложь
			Или Команда = "ВыделитьСлово"
			Или Команда = "Форматировать"
			Или Команда = "ВыполнитьШаблон"
			Или Команда = "ОткрытьАвтодополнение"
			Или Команда = "ПодсказатьПараметрАвто"
			Или Команда = "ЗаменитьТабуляции"
			Или Команда = "УдалитьПереносы"
			Или Команда = "ПерейтиКОпределению"
			Или Команда = "КонструкторЗапросов1С"
			Или Команда = "КонструкторЗапросовИР"
			Или Команда = "КонструкторЗапросов"
			Или Команда = "РедакторСтроковогоЛитерала"
		Тогда
			Если Результат <> Ложь Тогда 
				УстановитьГраницыВыделения();
				Если мОткрытьСправкуПоПараметру Тогда
					#Если ТолстыйКлиентОбычноеПриложение Тогда
						ОткрытьСправкуПоПараметру(, Ложь);
					#КонецЕсли
				КонецЕсли; 
			КонецЕсли;
		КонецЕсли;
	Исключение
		КончитьОбработкуКоманды();
		ВосстановитьФокусВвода();
		ВызватьИсключение;
	КонецПопытки;
	КончитьОбработкуКоманды();
	ВосстановитьФокусВвода();
	Возврат Результат;

КонецФункции

Процедура УстановитьГраницыВыделения() Экспорт 
	
	#Если Сервер И Не Сервер Тогда
		ПолеТекста = Обработки.ирОболочкаПолеТекста.Создать();
	#КонецЕсли
	//Структура = ПолеТекста.СтруктураДвумерногоВыделения();
	//Если Ложь
	//	// Экономная установка для подавления угасания мигания каретки из-за антибага платформы https://www.hostedredmine.com/issues/936432
	//	// Но баг платформы ЗаменитьСтроку() вызывает фактическое выделение всего предшествующего текста иногда без возможности получить настоящие границы выделения на 8.3.18 https://www.hostedredmine.com/issues/936821
	//	Или Структура.НачальнаяСтрока <> мНачальнаяСтрока 
	//	Или Структура.НачальнаяКолонка <> мНачальнаяКолонка 
	//	Или Структура.КонечнаяСтрока <> мКонечнаяСтрока 
	//	Или Структура.КонечнаяКолонка <> мКонечнаяКолонка 
	//Тогда
		ПолеТекста.УстановитьГраницыВыделения(мНачальнаяСтрока, мНачальнаяКолонка, мКонечнаяСтрока, мКонечнаяКолонка,, ФормаВладелец);
	//КонецЕсли; 

КонецПроцедуры

Процедура ФорматироватьТекст()
	
	ТекстЗапроса = ПолеТекста.ПолучитьТекст();
	КонструкторЗапроса = ПолучитьФорму("КонструкторЗапроса");
	КонструкторЗапроса.ВосстановитьНастройкиФормы();
	Попытка
		Если ЗагрузитьТекстВКонструктор(ТекстЗапроса, КонструкторЗапроса) Тогда 
			НовыйТекст = КонструкторЗапроса.СобратьПолныйТекст(, Истина);
			ВыделитьВесьТекст();
			ВыделенныйТекст(НовыйТекст);
		КонецЕсли;
	Исключение
		Сообщить(КраткоеПредставлениеОшибки(ИнформацияОбОшибке()));
		Возврат;
	КонецПопытки; 

КонецПроцедуры

Функция ВыделенныйТекст(Знач НовыйТекст = Неопределено) Экспорт 
	
	#Если Сервер И Не Сервер Тогда
		ПолеТекста = Обработки.ирОболочкаПолеТекста.Создать();
	#КонецЕсли
	Результат = ПолеТекста.ВыделенныйТекст(НовыйТекст);
	Если НовыйТекст <> Неопределено Тогда
		ПослеУстановкиВыделенногоМногострочногоТекста();
	КонецЕсли; 
	Возврат Результат;

КонецФункции

Процедура ДобавитьВТекстЗапросаОтборыПоСтрокеРезультата(ТекущаяСтрокаРезультата, ИменаПолей = Неопределено) Экспорт 
	ТекстЗапроса = ПолеТекста.ПолучитьТекст();
	КонструкторЗапроса = ПолучитьФорму("КонструкторЗапроса");
	КонструкторЗапроса.ВосстановитьНастройкиФормы();
	Если КонструкторЗапроса.ЗагрузитьТекстВКонструктор(ТекстЗапроса, КонструкторЗапроса) Тогда
		КонструкторЗапроса.ЗагрузитьПоследнийЗапрос();
		КонструкторЗапроса.ДобавитьОтборыПоСтрокеРезультата(ТекущаяСтрокаРезультата,, ИменаПолей);
		ВыделитьВесьТекст();
		ВыделенныйТекст(КонструкторЗапроса.СобратьПолныйТекст(, Истина));
		КонструкторЗапроса.ЗагрузитьПараметрыВОбъект();
		ПослеУстановкиВыделенногоМногострочногоТекста();
	КонецЕсли;
КонецПроцедуры

Процедура ВыделитьВесьТекст(ПолеТекста = Неопределено) Экспорт 
	
	Если ПолеТекста = Неопределено Тогда
		ПолеТекста = ЭтотОбъект.ПолеТекста;
	КонецЕсли; 
	КоличествоСтрок = ПолеТекста.КоличествоСтрок();
	#Если Сервер И Не Сервер Тогда
		ПолеТекста = Обработки.ирОболочкаПолеТекста.Создать();
	#КонецЕсли
	ПолеТекста.УстановитьГраницыВыделения(1, 1, Макс(1, КоличествоСтрок), СтрДлина(ПолеТекста.ПолучитьСтроку(КоличествоСтрок) + 1),, ФормаВладелец);

КонецПроцедуры

Процедура ПослеУстановкиВыделенногоМногострочногоТекста()
	
	Перем НачСтрока, НачКолонка, КонСтрока, КонКолонка;
	#Если Сервер И Не Сервер Тогда
		ПолеТекста = Обработки.ирОболочкаПолеТекста.Создать();
	#КонецЕсли
	Если ФормаВладелец = Неопределено Тогда
		Возврат;
	КонецЕсли; 
	Если ТипЗнч(ПолеТекста.ЭлементФормы) = Тип("ПолеТекстовогоДокумента") Тогда
		
		// Антибаг платформы https://partners.v8.1c.ru/forum/topic/1860281 , http://www.hostedredmine.com/issues/840411
		ПолеТекста.ПолучитьГраницыВыделения(НачСтрока, НачКолонка, КонСтрока, КонКолонка);
		ПолеТекста.УстановитьГраницыВыделения(1, 1, 1, 1);
		ПолеТекста.ЭлементФормы.ВыделенныйТекст = "";
		ПолеТекста.УстановитьГраницыВыделения(НачСтрока, НачКолонка, КонСтрока, КонКолонка,, ФормаВладелец);
		
		//// Антибаг платформы. 8.1.10.50
		//Если ирКэш.НомерВерсииПлатформыЛкс() < 801012 Тогда
		//	ПолеТекста.УстановитьТекст(ПолеТекста.ПолучитьТекст());
		//КонецЕсли;
		
		УстановитьПризнакМодифицированностиФормы();
	КонецЕсли; 

КонецПроцедуры

// Устанавливает фокус на связанное поле текста программы
Процедура УстановитьФокус() Экспорт 

	#Если Сервер И Не Сервер Тогда
		ПолеТекста = Обработки.ирОболочкаПолеТекста.Создать();
	#КонецЕсли
	ФормаВладелец.ТекущийЭлемент = ПолеТекста.ЭлементФормы;
	ВосстановитьФокусВвода();

КонецПроцедуры

// https://www.hostedredmine.com/issues/931798 и куча похожих
Процедура ВосстановитьФокусВвода()
	
	Если Истина
		И ФормаВладелец <> Неопределено
		И ТипЗнч(ФормаВладелец.ТекущийЭлемент) = Тип("ПолеHTMLДокумента") 
	Тогда
		// https://github.com/salexdv/bsl_console/issues/122
		//ПолеТекста.РедакторHTML().focus();
		//ПолеТекста.РедакторHTML().editor.focus();
		ирОбщий.УстановитьФокусВводаФормеЛкс();
	КонецЕсли;

КонецПроцедуры

Процедура АвтоОбновитьСправку() Экспорт 
	
	Если Ложь
		Или Не ирОбщий.Форма_ВводДоступенЛкс(ФормаВладелец) 
		Или ФормаВладелец.ТекущийЭлемент <> ПолеТекста.ЭлементФормы
	Тогда
		Возврат;
	КонецЕсли; 
	Если мПоследнийРежимВызоваСправки = Неопределено Тогда
		Возврат;
	КонецЕсли; 
	Кнопка = ирОбщий.КнопкаКоманднойПанелиЭкземпляраКомпонентыЛкс(ЭтотОбъект, мПоследнийРежимВызоваСправки); 
	Нажатие(Кнопка);
	
КонецПроцедуры

Функция ПолучитьВыделенныйИлиВесьТекст() Экспорт 

	НовыйТекстЗапроса = ВыделенныйТекст();
	Если ПустаяСтрока(НовыйТекстЗапроса) Тогда
		НовыйТекстЗапроса = ПолеТекста.ПолучитьТекст();
	КонецЕсли; 
	Возврат НовыйТекстЗапроса;

КонецФункции

// <Описание процедуры>
//
// Параметры:
//  <Параметр1>  – <Тип.Вид> – <описание параметра>
//                 <продолжение описания параметра>;
//  <Параметр2>  – <Тип.Вид> – <описание параметра>
//                 <продолжение описания параметра>.
//
Процедура КопироватьВБуферОбменаТекстВВидеКода() Экспорт

	НовыйТекстЗапроса = ПолучитьВыделенныйИлиВесьТекст();
	ЛиВыделенВесьТекст = НовыйТекстЗапроса = ПолеТекста.ПолучитьТекст();
	Если Прав(НовыйТекстЗапроса, 1) <> Символы.ПС Тогда
		НовыйТекстЗапроса = НовыйТекстЗапроса + Символы.ПС;
	КонецЕсли; 
	НовыйТекстЗапроса = ирОбщий.ПолучитьСтроковыйЛитералИзМногострочногоТекстаЛкс(НовыйТекстЗапроса);
	Если ЛиВыделенВесьТекст Тогда
		ИменованныеЗапросы = мПлатформа.СтруктураРезультатаПакетногоЗапроса(НовыйТекстЗапроса);
		НовыйТекстЗапроса = НовыйТекстЗапроса + ";" + Символы.ПС;
		Для Каждого КлючИЗначение Из ИменованныеЗапросы Цикл
			НовыйТекстЗапроса = НовыйТекстЗапроса + "Индекс_" + КлючИЗначение.Ключ + " = " + XMLСтрока(КлючИЗначение.Значение) + ";" + Символы.ПС;
		КонецЦикла;
	Иначе
		НовыйТекстЗапроса = "|" + ирОбщий.УдалитьВнешниеСкобкиВыраженияЛкс(НовыйТекстЗапроса, """", Символы.ПС + "|""");
	КонецЕсли; 
    ирОбщий.ТекстВБуферОбменаОСЛкс(НовыйТекстЗапроса);

КонецПроцедуры

Процедура Закомментировать() Экспорт

	#Если Сервер И Не Сервер Тогда
	    ПолеТекста = Новый ТекстовыйДокумент;
	#КонецЕсли
	//Для Счетчик = мНачальнаяСтрока По мКонечнаяСтрока Цикл
	//	ПолеТекста.УстановитьГраницыВыделения(Счетчик, 1, Счетчик, 1);
	//	ВыделенныйТекст("//");
	//КонецЦикла;
	//ПолеТекста.УстановитьГраницыВыделения(мНачальнаяСтрока, мНачальнаяКолонка, мКонечнаяСтрока, мКонечнаяКолонка);
	//
	ПерваяСтрока = мНачальнаяСтрока;
	ПерваяКолонка = мНачальнаяКолонка;
	ПоследняяСтрока = мКонечнаяСтрока;
	ПоследняяКолонка = мКонечнаяКолонка;
	КоличествоСтрок = Макс(ПолеТекста.КоличествоСтрок(), мКонечнаяСтрока); // Если в последней строке нет символов, то функция КоличествоСтрок() ее почему то не считает 
	ВыделенныйФрагмент = "";
	ДлинаПоследнейСтроки = 0;
	Если ПоследняяКолонка = 1 Тогда 
		ПоследняяСтрока = ПоследняяСтрока - 1;
	КонецЕсли;
	Если ПерваяСтрока >= ПоследняяСтрока И ПоследняяКолонка = 1 Тогда 
		ПоследняяКолонка = Макс(1, СтрДлина(ПолеТекста.ПолучитьСтроку(ПерваяСтрока)));
		ПоследняяСтрока = ПерваяСтрока;
	КонецЕсли;
	Для НомерСтроки = 1 По КоличествоСтрок Цикл
		Фрагмент = ПолеТекста.ПолучитьСтроку(НомерСтроки);
		Если НомерСтроки >= ПерваяСтрока И НомерСтроки <= ПоследняяСтрока Тогда
			Если НомерСтроки = ПерваяСтрока Тогда 
				ВыделенныйФрагмент = ВыделенныйФрагмент + "//" + Фрагмент;
			Иначе
				ВыделенныйФрагмент = ВыделенныйФрагмент + Символы.ПС + "//" +Фрагмент;
			КонецЕсли;
			Если НомерСтроки = ПоследняяСтрока Тогда 
				ДлинаПоследнейСтроки = СтрДлина(Фрагмент) + 3;
			КонецЕсли;
		КонецЕсли;
	КонецЦикла;
	ЗаменитьФрагментТекстаВПоле(ПолеТекста, ВыделенныйФрагмент, ДлинаПоследнейСтроки, ПерваяСтрока, ПоследняяСтрока, ПоследняяКолонка);

КонецПроцедуры

Процедура Раскомментировать() Экспорт

	#Если Сервер И Не Сервер Тогда
		ПолеТекста = Обработки.ирОболочкаПолеТекста.Создать();
	#КонецЕсли
	//Для Счетчик = мНачальнаяСтрока По мКонечнаяСтрока Цикл
	//	СтрокаТекста = СтрПолучитьСтроку(ТекстДоИзменения, Счетчик);
	//	Если Лев(СокрЛ(СтрокаТекста), 2) = "//" Тогда
	//		ПозицияМаркера = Найти(СтрокаТекста, "//");
	//		ПолеТекста.УстановитьГраницыВыделения(Счетчик, 1, Счетчик, 10000);
	//		ВыделенныйТекст(Сред(СтрокаТекста, 1, ПозицияМаркера - 1) + Сред(СтрокаТекста, ПозицияМаркера + 2));
	//	КонецЕсли; 
	//КонецЦикла;
	//ПолеТекста.УстановитьГраницыВыделения(мНачальнаяСтрока, мНачальнаяКолонка, мКонечнаяСтрока, мКонечнаяКолонка);
	//
	ПерваяСтрока = мНачальнаяСтрока;
	ПерваяКолонка = мНачальнаяКолонка;
	ПоследняяСтрока = мКонечнаяСтрока;
	ПоследняяКолонка = мКонечнаяКолонка;
	КоличествоСтрок = Макс(ПолеТекста.КоличествоСтрок(), мКонечнаяСтрока); // Если в последней строке нет символов, то функция КоличествоСтрок() ее почему то не считает 
	ВыделенныйФрагмент = "";
	ДлинаПоследнейСтроки = ПоследняяКолонка;
	Если ПоследняяКолонка = 1 Тогда 
		ПоследняяСтрока = ПоследняяСтрока - 1;
	КонецЕсли;
	Если ПерваяСтрока >= ПоследняяСтрока И ПоследняяКолонка = 1 Тогда 
		ПоследняяКолонка = СтрДлина(ПолеТекста.ПолучитьСтроку(ПерваяСтрока));
		ПоследняяСтрока = ПерваяСтрока;
	КонецЕсли;
	Для НомерСтроки = 1 По КоличествоСтрок Цикл
		Фрагмент = ПолеТекста.ПолучитьСтроку(НомерСтроки);
		Если НомерСтроки >= ПерваяСтрока И НомерСтроки <= ПоследняяСтрока Тогда
			Если Лев(СокрЛ(Фрагмент), 2) = "//" Тогда
				Позиция = Найти(Фрагмент, "//");
				Фрагмент = Лев(Фрагмент, Позиция - 1) + Сред(Фрагмент, Позиция + 2);
			КонецЕсли;
			Если НомерСтроки = ПерваяСтрока Тогда 
				ВыделенныйФрагмент = ВыделенныйФрагмент + Фрагмент;
			Иначе
				ВыделенныйФрагмент = ВыделенныйФрагмент + Символы.ПС + Фрагмент;
			КонецЕсли;
			Если НомерСтроки = ПоследняяСтрока Тогда 
				ДлинаПоследнейСтроки = СтрДлина(Фрагмент) + 3;
			КонецЕсли;
		КонецЕсли;
	КонецЦикла;
	ЗаменитьФрагментТекстаВПоле(ПолеТекста, ВыделенныйФрагмент, ДлинаПоследнейСтроки, ПерваяСтрока, ПоследняяСтрока, ПоследняяКолонка);
	
КонецПроцедуры

Процедура ЗаменитьФрагментТекстаВПоле(Знач ПолеТекста, Знач ВыделенныйФрагмент, Знач ДлинаПоследнейСтроки, Знач ПерваяСтрока, Знач ПоследняяСтрока, Знач ПоследняяКолонка)
	
	#Если Сервер И Не Сервер Тогда
		ПолеТекста = Обработки.ирОболочкаПолеТекста.Создать();
	#КонецЕсли
	Если ПоследняяКолонка = 1 Тогда 
		ПоследняяСтрока = ПоследняяСтрока + 1;
		ДлинаПоследнейСтроки = 1;
		ВыделенныйФрагмент =  ВыделенныйФрагмент + Символы.ПС;
	КонецЕсли;
	ПолеТекста.УстановитьГраницыВыделения(ПерваяСтрока, 1, ПоследняяСтрока, ДлинаПоследнейСтроки);
	ЧислоПереносовСтрокНачальное = СтрЧислоВхождений(ВыделенныйТекст(), Символы.ПС);
	Если ЧислоПереносовСтрокНачальное > ПоследняяСтрока - ПерваяСтрока Тогда
		// https://www.hostedredmine.com/issues/925662
		Для Счетчик = 1 По Мин(2, ДлинаПоследнейСтроки - 1) Цикл 
			ДлинаПоследнейСтрокиБезПереноса = ДлинаПоследнейСтроки - Счетчик;
			ПолеТекста.УстановитьГраницыВыделения(ПерваяСтрока, 1, ПоследняяСтрока, ДлинаПоследнейСтрокиБезПереноса);
			Если СтрЧислоВхождений(ВыделенныйТекст(), Символы.ПС) < ЧислоПереносовСтрокНачальное Тогда
				Прервать;
			КонецЕсли; 
		КонецЦикла;
	КонецЕсли; 
	ВыделенныйТекст(ВыделенныйФрагмент);
	ПолеТекста.УстановитьГраницыВыделения(ПерваяСтрока, 1, ПоследняяСтрока, ДлинаПоследнейСтроки,, ФормаВладелец);
	УстановитьПризнакМодифицированностиФормы();

КонецПроцедуры 

Процедура ПрочитатьНачалоИКонецТекущейСтроки() Экспорт

	СброситьРезультатРазбораПозицииВТексте();
	//ОригинальнаяСтрока = СокрП(ПолеТекста.ПолучитьСтроку(мКонечнаяСтрока));
	ОригинальнаяСтрока = ПолеТекста.ПолучитьСтроку(мКонечнаяСтрока);
	Для Счетчик = 0 По мКонечнаяКолонка - СтрДлина(ОригинальнаяСтрока) - 2 Цикл
		ОригинальнаяСтрока = ОригинальнаяСтрока + " ";
	КонецЦикла;
	ТекущееНачалоСтроки = Лев(ОригинальнаяСтрока, мКонечнаяКолонка - 1);
	ТекущийКонецСтроки = Сред(ОригинальнаяСтрока, мКонечнаяКолонка);

КонецПроцедуры

// Замена операторов внешнего перехода https://partners.v8.1c.ru/forum/t/1849050/m/1849050
Функция ЗаменитьОператорыВнешнегоПерехода(Знач Текст = Неопределено, выхТипыВнешнихПереходов, выхЗаглушкаВозврата = "", выхИмяПараметраТипаВыхода = "") Экспорт 
	
	Перем ИмяМетода;
	#Если Сервер И Не Сервер Тогда
		ПолеТекста = Обработки.ирОболочкаПолеТекста.Создать();
	#КонецЕсли
	УникальнаяСтрока = "1092383289";
	Если Не ЗначениеЗаполнено(выхЗаглушкаВозврата) Тогда
		выхЗаглушкаВозврата = "Возврат" + УникальнаяСтрока + "=0";
	КонецЕсли; 
	Если Не ЗначениеЗаполнено(выхИмяПараметраТипаВыхода) Тогда
		выхИмяПараметраТипаВыхода = "ТипВыхода";
	КонецЕсли; 
	Если Текст <> Неопределено Тогда
		ПолеТекста.УстановитьТекст(Текст);
	КонецЕсли; 
	Если выхТипыВнешнихПереходов = Неопределено Тогда
		выхТипыВнешнихПереходов = Новый Структура;
	КонецЕсли; 
	СтартоваяСтрока = 0;
	Пока Истина Цикл
		ИнформацияОбОшибке = ПолучитьИнформациюОбОшибке(, СтартоваяСтрока,,, Истина);
		Если ИнформацияОбОшибке = Неопределено Тогда
			Прервать;
		КонецЕсли; 
		#Если Сервер И Не Сервер Тогда
			ИнформацияОбОшибке = ИнформацияОбОшибке();
		#КонецЕсли
		ОписаниеОшибки = ИнформацияОбОшибке.Описание;
		Если Найти(ОписаниеОшибки, "Оператор Прервать") > 0 Тогда
			ИмяОператора = "Прервать";
		ИначеЕсли Найти(ОписаниеОшибки, "Оператор Продолжить") > 0 Тогда
			ИмяОператора = "Продолжить";
		ИначеЕсли Найти(ОписаниеОшибки, "Оператор Возврат") > 0 Тогда
			ИмяОператора = "Возврат";
		//ИначеЕсли Найти(ОписаниеОшибки, "Оператор Перейти") > 0 Тогда
		//	ИмяОператора = "Перейти"; // TODO
		Иначе
			Прервать;
		КонецЕсли; 
		КоординатыОшибки = КоординатыОшибки(ИнформацияОбОшибке, СтартоваяСтрока);
		выхТипыВнешнихПереходов.Вставить(ИмяОператора);
		
		// Выделяем вхождение имени оператора в ПолеТекста
		ПолеТекста.УстановитьГраницыВыделения(1, 1, КоординатыОшибки.НомерСтроки, КоординатыОшибки.НомерКолонки);
		ТекстовыйДокумент = Новый ТекстовыйДокумент;
		ТекстовыйДокумент.УстановитьТекст(СокрП(ВыделенныйТекст()));
		КоличествоСтрок = ТекстовыйДокумент.КоличествоСтрок();
		ДлинаПоследнейСтроки = СтрДлина(ТекстовыйДокумент.ПолучитьСтроку(КоличествоСтрок) + 1);
		ПолеТекста.УстановитьГраницыВыделения(Макс(1, КоличествоСтрок), ДлинаПоследнейСтроки - СтрДлина(ИмяОператора), Макс(1, КоличествоСтрок), ДлинаПоследнейСтроки);
		
		ВыделенныйТекст(выхИмяПараметраТипаВыхода + " = """ + ИмяОператора + """; " + выхЗаглушкаВозврата);
		Если ИмяОператора = "Возврат" Тогда
			ИнформацияОбОшибке = ПолучитьИнформациюОбОшибке(, СтартоваяСтрока,,, Истина);
			Если ИнформацияОбОшибке <> Неопределено Тогда
				#Если Сервер И Не Сервер Тогда
					ИнформацияОбОшибке = ИнформацияОбОшибке();
				#КонецЕсли
				ОписаниеОшибки = ИнформацияОбОшибке.Описание;
				КоординатыОшибкиПосле = КоординатыОшибки(ИнформацияОбОшибке, СтартоваяСтрока);
				Если КоординатыОшибкиПосле.НомерСтроки = КоординатыОшибки.НомерСтроки Тогда
					ВыделенныйТекст("=");
				КонецЕсли; 
			КонецЕсли; 
		КонецЕсли; 
	КонецЦикла;
	Текст = ПолеТекста.ПолучитьТекст();
	Возврат Текст;

КонецФункции

Функция КоординатыОшибки(Знач ИнформацияОбОшибке, Знач СтартоваяСтрока = 0) Экспорт 
	
	КоординатыОшибки = Новый Структура("НомерСтроки, НомерКолонки");
	RegExp.Pattern = "{[^\(]*\(([^\)]+)\)}";
	ТекстКоординат = RegExp.НайтиВхождения(ИнформацияОбОшибке.Описание)[0].SubMatches(0);  
	Фрагменты = ирОбщий.СтрРазделитьЛкс(ТекстКоординат, ",", Истина);
	КоординатыОшибки.НомерСтроки = Число(Фрагменты[0]) + СтартоваяСтрока;
	КоординатыОшибки.НомерКолонки = Число(Фрагменты[1]);
	Возврат КоординатыОшибки;

КонецФункции

Процедура ВыделитьТекущееСлово() Экспорт 

	#Если Сервер И Не Сервер Тогда
		ПолеТекста = Обработки.ирОболочкаПолеТекста.Создать();
	#КонецЕсли
	ТекущееОбъектноеВыражение();
	мНачальнаяКолонка = мКонечнаяКолонка - СтрДлина(НачалоКонтекста);
	Если Не ПустаяСтрока(мРодительскийКонтекст) Тогда
		мНачальнаяКолонка = мНачальнаяКолонка + СтрДлина(мРодительскийКонтекст) + 1;
	КонецЕсли;
	мКонечнаяКолонка = мКонечнаяКолонка + СтрДлина(КонецКонтекста);
	Если Прав(КонецКонтекста, 1) = "(" Тогда
		мКонечнаяКолонка = мКонечнаяКолонка - 1;
	КонецЕсли;
	ПолеТекста.УстановитьГраницыВыделения(мНачальнаяСтрока, мНачальнаяКолонка, мКонечнаяСтрока, мКонечнаяКолонка,, ФормаВладелец);

КонецПроцедуры

Процедура ВыделитьТекущееОбъектноеВыражение() Экспорт 

	#Если Сервер И Не Сервер Тогда
		ПолеТекста = Обработки.ирОболочкаПолеТекста.Создать();
	#КонецЕсли
	ТекущееОбъектноеВыражение();
	мНачальнаяКолонка = мКонечнаяКолонка - СтрДлина(НачалоКонтекста);
	мКонечнаяКолонка = мКонечнаяКолонка + СтрДлина(КонецКонтекста);
	Если Прав(КонецКонтекста, 1) = "(" Тогда
		мКонечнаяКолонка = мКонечнаяКолонка - 1;
	КонецЕсли;
	ПолеТекста.УстановитьГраницыВыделения(мНачальнаяСтрока, мНачальнаяКолонка, мКонечнаяСтрока, мКонечнаяКолонка,, ФормаВладелец);

КонецПроцедуры

// Получает путь к описанию заданного контекста.
//
// Параметры:
//  ПутьКСлову   – Строка;
//  *СтрокаОписания - СтрокаТаблицыЗначений - возвращаемая строка описания;
//  *ВключатьПутьКОписаниюТипаЗначения - Булево, *Неопределено - признак добавления в список выбора тип значения слова.
//
Функция НайтиПоказатьСправкуПоСлову(Знач ПутьКСлову, ВключатьПутьКОписаниюТипаЗначения = Ложь, выхФормаВыбора = Неопределено, РазрешитьАнализИмениТипа = Истина,
	ВладелецФормы = Неопределено) Экспорт

	#Если Сервер И Не Сервер Тогда
		мПлатформа = Обработки.ирПлатформа.Создать();
	#КонецЕсли
	МассивЗащитыОтРекурсии.Очистить();
	ТаблицаСтруктурТиповКонтекста = ОпределитьТипЗначенияКонтекста(ПутьКСлову, " " + мТекстДляПоискаОпределения, мПредшествующийТекст, РазрешитьАнализИмениТипа, мЭтоКонструктор);
	ОтносительныйПутьКОписанию = "";
	СтруктураТипаКонтекста = ТаблицаСтруктурТиповКонтекста[0];
	НайтиПоказатьСправкуПоСтруктуреТипа(ПутьКСлову, СтруктураТипаКонтекста, ВключатьПутьКОписаниюТипаЗначения, выхФормаВыбора, ВладелецФормы, ТаблицаСтруктурТиповКонтекста);

КонецФункции

Функция НайтиПоказатьСправкуПоСтруктуреТипа(Знач ПутьКСлову, Знач СтруктураТипа, ВключатьПутьКОписаниюТипаЗначения = Ложь, выхФормаВыбора = Неопределено, ВладелецФормы = Неопределено,
	Знач ТаблицаСтруктурТиповКонтекста = Неопределено)
	
	Если Истина
		И ТипЗнч(СтруктураТипа.СтрокаОписания) <> Тип("СтрокаТаблицыЗначений")
		И ТипЗнч(СтруктураТипа.Метаданные) = Тип("COMОбъект") 
	Тогда
		Если мНомерПараметра > 0 Тогда
			Возврат Неопределено;
		КонецЕсли; 
		МетаданныеСлова = СтруктураТипа.Метаданные;
		ИмяТипа = мПлатформа.ПолноеИмяТипаCOMОбъекта(МетаданныеСлова);
		Попытка
			Пустышка = МетаданныеСлова.Path_;
		Исключение
			Пустышка = Неопределено;
		КонецПопытки;
		Слово = ирОбщий.ПоследнийФрагментЛкс(ПутьКСлову, ".", Ложь);
		Если Прав(ПутьКСлову, 1) = "(" Тогда
			Слово = СтрЗаменить(Слово, "(", "");
		КонецЕсли; 
		Если Пустышка <> Неопределено Тогда
			// WMI
			ИмяКлассаWMI = МетаданныеСлова.Path_.Class;
			Если ЗначениеЗаполнено(Слово) Тогда
				ОписаниеСлова = ирОбщий.ДокументацияСвойстваWMIЛкс(ИмяКлассаWMI, Слово);
				Если ЗначениеЗаполнено(ОписаниеСлова) Тогда
					ТекстовыйДокумент = Новый ТекстовыйДокумент;
					ТекстовыйДокумент.УстановитьТекст(ОписаниеСлова);
					ТекстовыйДокумент.Показать(ИмяКласса + "." + Слово);
				КонецЕсли; 
			КонецЕсли;
		Иначе
			ЗапуститьПриложение("http://google.com/search?q=" + ирОбщий.ПервыйФрагментЛкс(ИмяТипа, " ") + "+" + Слово);
		КонецЕсли; 
	Иначе
		Если ВладелецФормы <> Неопределено И СтруктураТипа.СтрокаОписания <> Неопределено Тогда
			ТаблицаВладелец = СтруктураТипа.СтрокаОписания.Владелец();
			#Если Сервер И Не Сервер Тогда
				ТаблицаВладелец = Новый ТаблицаЗначений;
			#КонецЕсли
			Если ТаблицаВладелец.Колонки.Найти("ЛиЭкспорт") <> Неопределено  Тогда
				ФормаВызовМетода = ФормаВызовМетода();
				ФормаВызовМетода.ПараметрСтруктураТипаКонтекста = СтруктураТипа;
				БылаОткрыта = ФормаВызовМетода.Открыта();
				Если ЛиДоступноОткрытиеСвободнойФормы() Тогда 
					ОткрытьПодсказкуПоВызовуМетодаПассивно(ФормаВызовМетода);
					Если Не БылаОткрыта Тогда
						ирОбщий.Форма_АктивироватьОткрытьЛкс(ФормаВладелец);
					КонецЕсли; 
				Иначе
					ФормаВызовМетода.ОткрытьМодально();
				КонецЕсли;
				Возврат ФормаВызовМетода;
			КонецЕсли; 
		КонецЕсли; 
		Если СтруктураТипа.ТипЯзыка = "ИмяТипа" Тогда 
			ВключатьПутьКОписаниюТипаЗначения = Истина;
		КонецЕсли; 
		Слово = ирОбщий.ПоследнийФрагментЛкс(ПутьКСлову);
		// Возможные роли слова без учета вычисленного контекста
		ТаблицаСтруктурВозможныхТиповКонтекста = ирОбщий.НайтиВозможныеСтрокиОписанияСловаВСинтаксПомощникеЛкс(Слово, ЯзыкПрограммы);
		Если ТаблицаСтруктурТиповКонтекста = Неопределено Тогда
			ТаблицаСтруктурТиповКонтекста = Новый Массив;
			ТаблицаСтруктурТиповКонтекста.Добавить(СтруктураТипа);
		КонецЕсли; 
		СтруктураЦикла = Новый Соответствие;
		СтруктураЦикла.Вставить("1.Предсказанные:", ТаблицаСтруктурТиповКонтекста);
		СтруктураЦикла.Вставить("2.Возможные:", ТаблицаСтруктурВозможныхТиповКонтекста);
		#Если Сервер И Не Сервер Тогда
			мПлатформа = Обработки.ирПлатформа.Создать();
		#КонецЕсли
		Если ВладелецФормы = Неопределено Тогда
			ВладелецФормы = ФормаВладелец;
		КонецЕсли; 
		мПлатформа.ВыбратьСтрокуОписанияИзМассиваСтруктурТипов(СтруктураЦикла, ВключатьПутьКОписаниюТипаЗначения, ВладелецФормы, Слово, мНомерПараметра,, выхФормаВыбора, мФактическиеПараметры.Количество());
	КонецЕсли;
	Возврат Неопределено;

КонецФункции

// Открывает контекстную справку по текущему слову или его типу.
//
// Параметры:
//  *ПутьКСлову - Строка, *"" - используется для получения дочерних слов относительно текущего контекста.
//
Процедура ОткрытьКонтекстнуюСправку(ПутьКСлову = "", ВладелецФормы = Неопределено) Экспорт
	
	//Если ирОбщий.ПроверитьПлатформаНеWindowsЛкс(,, Истина) Тогда
	//	Возврат;
	//КонецЕсли; 
	//КончитьОбработкуКоманды();
	РазобратьТекущийКонтекст();
	РазрешитьАнализИмениТипа = Не ЗначениеЗаполнено(ПутьКСлову);
	Если РазрешитьАнализИмениТипа Тогда 
		ПутьКСлову = мТекущееСлово;
	КонецЕсли;
	Если мРодительскийКонтекст <> "" Тогда 
		ПутьКСлову = мРодительскийКонтекст + "." + ПутьКСлову;
	КонецЕсли;
	НайтиПоказатьСправкуПоСлову(ПутьКСлову,,, РазрешитьАнализИмениТипа, ВладелецФормы);
	
КонецПроцедуры 

// <Описание процедуры>
//
// Параметры:
//  <Параметр1>  – <Тип.Вид> – <описание параметра>
//                 <продолжение описания параметра>;
//  <Параметр2>  – <Тип.Вид> – <описание параметра>
//                 <продолжение описания параметра>.
//
Процедура ОткрытьСправкуПоЯзыкуПрограммы() Экспорт 

	//Если ирОбщий.ПроверитьПлатформаНеWindowsЛкс() Тогда
	//	Возврат;
	//КонецЕсли; 
	Если ЯзыкПрограммы = 0 Тогда
		Книга = "shcntx_ru";
	ИначеЕсли ЯзыкПрограммы = 1 Тогда
		Книга = "shquery_ru";
	ИначеЕсли ЯзыкПрограммы = 2 Тогда
		Книга = "dcsui_ru";
	КонецЕсли;
	ФормаСправка = ирОбщий.ПолучитьФормуЛкс("Обработка.ирСинтаксПомощник.Форма", , ФормаВладелец);
	ФормаСправка.ОткрытьАдрес("//" + Книга);

КонецПроцедуры

// Открывает контекстную справку по текущему параметру метода.
//
// Параметры:
//  *ПутьКСлову - Строка, *"" - используется для получения дочерних слов относительно текущего контекста.
//
Процедура ОткрытьСправкуПоПараметру(ПутьКСлову = "", ОткрыватьСинтаксПомощник = Истина) Экспорт
	
	//Если ирОбщий.ПроверитьПлатформаНеWindowsЛкс(,, Истина) Тогда
	//	Возврат;
	//КонецЕсли; 
	РазобратьТекущийКонтекст(,, Истина);
	Если ПутьКСлову = "" Тогда
		ПутьКСлову = мВызовМетода;
	КонецЕсли;
	// Если раскомментировать, то при вызове через мОткрытьСправкуПоПараметру не будет открываться окно 
	//Если Не ЗначениеЗаполнено(ПутьКСлову) Тогда
	//	Возврат;
	//КонецЕсли; 
	Если ОткрыватьСинтаксПомощник И ирКэш.ЛиПлатформаWindowsЛкс() Тогда
		ФормаСинтаксПомощникаДо = Неопределено;
		ФормаСинтаксПомощникаПосле = Неопределено;
		Если Не ЛиДоступноОткрытиеСвободнойФормы() Тогда 
			ФормаСинтаксПомощникаДо = ирОбщий.ПолучитьФормуЛкс("Обработка.ирСинтаксПомощник.Форма");
		КонецЕсли; 
		НайтиПоказатьСправкуПоСлову(ПутьКСлову,, ФормаСинтаксПомощникаПосле);
	КонецЕсли;
	ФормаПодсказкаПоПараметрам = ФормаВызовМетода();
	ФормаПодсказкаПоПараметрам.ПараметрСтруктураТипаКонтекста = Неопределено;
	
	Если Не ФормаПодсказкаПоПараметрам.Открыта() И ЗначениеЗаполнено(мИмяМетода) Тогда
		ФормаПодсказкаПоПараметрам.ЗапомнитьПозициюКаретки();
	КонецЕсли; 
	Если ЛиДоступноОткрытиеСвободнойФормы() Тогда 
		Если Ложь
			Или ОткрыватьСинтаксПомощник
			Или Не ФормаПодсказкаПоПараметрам.Открыта() 
		Тогда
			ОткрытьПодсказкуПоВызовуМетодаПассивно(ФормаПодсказкаПоПараметрам);
		КонецЕсли; 
	Иначе
		Если Истина
			И ФормаСинтаксПомощникаДо <> Неопределено
			И ФормаСинтаксПомощникаДо.Открыта() = ФормаСинтаксПомощникаПосле.Открыта()
		Тогда
			ФормаПодсказкаПоПараметрам.ОткрытьМодально();
		КонецЕсли; 
	КонецЕсли;
	
КонецПроцедуры

Процедура ОткрытьПодсказкуПоВызовуМетодаПассивно(Знач ФормаПодсказкаПоПараметрам)
	
	ФормаПодсказкаПоПараметрам.Открыть();
	ФормаПодсказкаПоПараметрам.Обновить(); // Нужно для ускорения срабатывания установки позиции окна и для 8.2, т.к. там форма форкус получает после завершения ПриОткрытии и только после этого сработает установка позиции окна
	//ирОбщий.УстановитьФокусВводаФормеЛкс(); Не помогает восстановить мигание каретки
	
КонецПроцедуры

Функция УдалитьКомментарии(Текст) Экспорт 
	
	RegExp.Global = Истина;
	RegExp.Multiline = Ложь;
	
	Если Ложь
		Или ЯзыкПрограммы = 1
		Или ЯзыкПрограммы = 2
	Тогда
		// Не проверено
		RegExp.Pattern = "(?:(?://[^\n]*" + ")|(" + шСтрокаЗапроса + ")|([\s\S])";
		ШаблонЗамены = "$1$2$3$4";
	ИначеЕсли ЯзыкПрограммы = 0 Тогда
		шОднострочнаяСтрокаПрограммыСКавычки = """(?:(?:"""")|[^""\n])*""?"; 
		шОднострочнаяСтрокаПрограммыСЧерты = "\n\s*\|(?:(?:"""")|[^""\n])*""?";
		RegExp.Pattern = "//[^\n]*|" + "(" + "#[^\n]*" + ")|(" + шОднострочнаяСтрокаПрограммыСКавычки + ")|(" + шОднострочнаяСтрокаПрограммыСЧерты + ")|([\s\S])";
		ШаблонЗамены = "$1$2$3$4";
	КонецЕсли;
	Результат = RegExp.Заменить(Текст, ШаблонЗамены);
	Возврат Результат;
	
КонецФункции

// Меняет RegExp!
Функция ЭтоРусскийВариантТекстаЗапроса(Текст) Экспорт 
	
	ТекстБезКомментариев = СокрЛП(ЗалитьКомментарииИСтроковыеЛитералы(Текст));
	RegExp.Pattern = "[А-ЯЁ]";
	ЭтоРусскийЯзык = RegExp.Проверить(Лев(ТекстБезКомментариев, 1));
	Возврат ЭтоРусскийЯзык;

КонецФункции

// Добавляет/заменяет/удаляет оператор ПОМЕСТИТЬ в запросе.
// Это неточный метод, основанный на regexp.
//
// Параметры:
//  ТекстЗапроса – Строка;
//  *ИмяВременнойТаблицы – Строка - если пустое, то оператор удаляется.
//
// Возвращаемое значение:
//  Строка - исправленный текст запроса.
//
Функция ИзменитьОператорПоместитьЗапроса(ТекстЗапроса, ИмяВременнойТаблицы = "") Экспорт 

	ЭтоРусскийЯзык = ЭтоРусскийВариантТекстаЗапроса(ТекстЗапроса); // Меняет RegExp!
	RegExp.Global = Истина;
	шСтрокаЗапроса = """(?:(?:"""")|[^""\n])*(?:" + шРазделитель + "*(?:(?:"""")|[^""\n])*)*(?:""|$)";
	ШаблонПОМЕСТИТЬИЗ = "(" + шСтрокаЗапроса + ")|(?:(" + шРазделитель + ")+(" + "(?:ПОМЕСТИТЬ|INTO(?:" + шРазделитель + "+TABLE)?)" + шРазделитель + "+" + шИмя + шРазделитель + "+)"
		+ "|((?:ИЗ|FROM|ГДЕ|WHERE|СГРУППИРОВАТЬ|GROUP|УПОРЯДОЧИТЬ|ORDER|ИМЕЮЩИЕ|HAVING|ОБЪЕДИНИТЬ|UNION)" + шРазделитель + "+))|(.|\r|\n)";
	RegExp.Pattern = ШаблонПОМЕСТИТЬИЗ;
	Если ЗначениеЗаполнено(ИмяВременнойТаблицы) Тогда
		Если ЭтоРусскийЯзык Тогда
			ТерминПоместить = "ПОМЕСТИТЬ";
		Иначе
			ТерминПоместить = "INTO";
		КонецЕсли; 
		Результат = RegExp.НайтиВхождения(ТекстЗапроса);
		Текст = "";
		ПредложениеДобавлено = Ложь;
		Для Каждого Match Из Результат Цикл
			Если Ложь
				Или ПредложениеДобавлено
				Или Не ирОбщий.ЛиПустаяПодгруппаRegExpЛкс(Match.SubMatches(0))
				Или Не ирОбщий.ЛиПустаяПодгруппаRegExpЛкс(Match.SubMatches(4))
			Тогда
				Текст = Текст + Match.Value;
			Иначе
				Текст = Текст + "
				|" + ТерминПоместить + "
				|	" + ИмяВременнойТаблицы;
				Если Match.SubMatches(3) <> 0 Тогда // Видимо здесь ошибка
					Текст = Текст + Символы.ПС + Match.SubMatches(3);
				КонецЕсли;
				ПредложениеДобавлено = Истина;
			КонецЕсли;
		КонецЦикла;
		Если Не ПредложениеДобавлено Тогда
			Текст = Текст + "
			|" + ТерминПоместить + "
			|	" + ИмяВременнойТаблицы;
		КонецЕсли;
	Иначе
		Текст = RegExp.Заменить(ТекстЗапроса, "$1$2$4$5");
	КонецЕсли; 
	Возврат Текст;

КонецФункции

Функция ШаблонЗапросаДопускаетВстройкуВРодительскийЗапрос(Текст) Экспорт 
	
	RegExp.Global = Ложь;
	RegExp.Pattern = шРазделитель + "*(?:ВЫБРАТЬ|SELECT)(?:" + шРазделитель + "+)\*(?:" + шРазделитель + "+)(?:ИЗ|FROM)(?:" + шРазделитель + "+(?:КАК|AS)?(?:" + шРазделитель + "+" + шИмя + "))" + шРазделитель + "*";
	Результат = RegExp.Проверить(Текст);
	Возврат Результат;

КонецФункции

Функция ПолучитьКомментарийИзТокеновЯзыкаЗапросов(Токен1, Токен2 = Неопределено, выхИмяЗапросаИзКомментария = "", выхИмяЧастиОбъединенияИзКомментария = "") Экспорт 
	
	Массив = Новый Массив();
	Если Токен1 <> Неопределено И Токен1.Name = "Comment" Тогда
		Массив.Добавить(Токен1);
	КонецЕсли; 
	Если Токен2 <> Неопределено И Токен2.Name = "Comment" Тогда
		Массив.Добавить(Токен2);
	КонецЕсли; 
	ТекстКомментария = "";
	Для Каждого Токен Из Массив Цикл
		ТекстТокена = ПолучитьТекстИзТокена(Токен);
		РазобратьКомментарий(ТекстКомментария, выхИмяЗапросаИзКомментария, выхИмяЧастиОбъединенияИзКомментария);
	КонецЦикла;
	Возврат ТекстКомментария;
	
КонецФункции

Процедура РазобратьКомментарий(ТекстКомментария, выхИмяЗапросаИзКомментария = Неопределено, выхИмяЧастиОбъединенияИзКомментария = Неопределено) Экспорт 
	
	ЧистыйКомментарий = "";
	ТекстовыйДокумент = Новый ТекстовыйДокумент;
	ТекстовыйДокумент.УстановитьТекст(ТекстКомментария);
	Для Счетчик = 1 По ТекстовыйДокумент.КоличествоСтрок() Цикл
		СтрокаТекста = ТекстовыйДокумент.ПолучитьСтроку(Счетчик);
		Если ПустаяСтрока(СтрокаТекста) Тогда
			Продолжить;
		КонецЕсли; 
		//Если Счетчик = 1 Тогда 
			Если Найти(СтрокаТекста, мПараметрыДиалектаSQL.СтрочныйКомментарий) = 1 Тогда 
				СтрокаТекста = Сред(СтрокаТекста, СтрДлина(мПараметрыДиалектаSQL.СтрочныйКомментарий) + 1);
			КонецЕсли; 
			Если Найти(СтрокаТекста, мМаркерСлужебногоКомментария) = 1 Тогда 
				Продолжить;
			КонецЕсли; 
			Если Найти(СтрокаТекста, мПлатформа.мМаркерИмениЗапросаПакета) = 1 Тогда 
				ИмяЗапросаИзКомментария = ирОбщий.СтрокаМеждуМаркерамиЛкс(СтрокаТекста, мПлатформа.мМаркерИмениЗапросаПакета, " ");
				Если ирОбщий.ЛиИмяПеременнойЛкс(ИмяЗапросаИзКомментария) Тогда
					выхИмяЗапросаИзКомментария = ИмяЗапросаИзКомментария;
				КонецЕсли; 
				// Пропускаем служебные комментарии
				Продолжить;
			КонецЕсли; 
			Если Найти(СтрокаТекста, мПлатформа.мМаркерИмениЧастиОбъединения) = 1 Тогда 
				ИмяЧастиОбъединенияИзКомментария = ирОбщий.СтрокаМеждуМаркерамиЛкс(СтрокаТекста, мПлатформа.мМаркерИмениЧастиОбъединения, " ");
				Если ирОбщий.ЛиИмяПеременнойЛкс(ИмяЧастиОбъединенияИзКомментария) Тогда
					выхИмяЧастиОбъединенияИзКомментария = ИмяЧастиОбъединенияИзКомментария;
				КонецЕсли; 
				// Пропускаем служебные комментарии
				Продолжить;
			КонецЕсли; 
		//КонецЕсли; 
		Если ЧистыйКомментарий <> "" Тогда
			ЧистыйКомментарий = ЧистыйКомментарий + Символы.ПС;
		КонецЕсли; 
		ЧистыйКомментарий = ЧистыйКомментарий + СтрокаТекста;
	КонецЦикла;
	ТекстКомментария = ЧистыйКомментарий;

КонецПроцедуры

// <Описание функции>
//
// Параметры:
//  <Параметр1>  – <Тип.Вид> – <описание параметра>
//                 <продолжение описания параметра>;
//  <Параметр2>  – <Тип.Вид> – <описание параметра>
//                 <продолжение описания параметра>.
//
// Возвращаемое значение:
//               – <Тип.Вид> – <описание значения>
//                 <продолжение описания значения>;
//  <Значение2>  – <Тип.Вид> – <описание значения>
//                 <продолжение описания значения>.
//
Процедура _РазобратьКонтекстРавенства() Экспорт

	Если Не мРазбиратьКонтекст Тогда 
		Возврат;
	КонецЕсли;
	RegExp.Global = Истина;
	ПрочитатьНачалоИКонецТекущейСтроки();
	мКонтекст = "";
	
	ОригинальныйТекст = ПолеТекста.ПолучитьТекст();
	мПредшествующийТекст = "";
	Если мКонечнаяСтрока > 1 Тогда
		СлужебноеПолеТекста.УстановитьТекст(ОригинальныйТекст);
		СлужебноеПолеТекста.УстановитьГраницыВыделения(1, 1, мКонечнаяСтрока - 1, 333);
		мПредшествующийТекст = СлужебноеПолеТекста.ВыделенныйТекст;
	КонецЕсли;
	ТекстДоКурсора = мПредшествующийТекст + ТекущееНачалоСтроки;
	Если ЯзыкПрограммы = 0 Тогда
		мТекстДляПоискаОпределения = мПредшествующийТекст;
	Иначе
		мТекстДляПоискаОпределения = ОригинальныйТекст;
	КонецЕсли;
	мТекстДляПоискаОпределения = ЗалитьКомментарииИСтроковыеЛитералы(мТекстДляПоискаОпределения);
	
	RegExp.Global = Ложь;
	Если ЯзыкПрограммы = 0 Тогда
		RegExp.Pattern = "(" + шВыражениеПрограммы + ")" + шРазделитель + "*=" + шРазделитель + "*$";
	Иначе
		RegExp.Pattern = "(" + шВыражениеЗапроса   + ")" + шРазделитель + "*=" + шРазделитель + "*$";
	КонецЕсли;
	Результат = RegExp.НайтиВхождения(ТекстДоКурсора);
	Если Результат.Количество() > 0 Тогда
		мКонтекст = Результат[0].SubMatches(0);
	КонецЕсли;
	НачатьОбработкуКоманды();

КонецПроцедуры

// Разбирает текущий контекст по составляющим.
//
// Параметры:
//  *ДеструктивныйАнализ - Булево, *Истина - текст для поиска определения оптимизировать.
//
Процедура РазобратьТекущийКонтекст(ЛиСправаОтРавенства = Ложь, выхЕстьТочкаСправа = Ложь, КакВызовМетода = Ложь, НомерСтроки = 0, НомерКолонки = 0) Экспорт 

	#Если Сервер И Не Сервер Тогда
		мПлатформа = Обработки.ирПлатформа.Создать();
	#КонецЕсли
	Если Не мРазбиратьКонтекст Тогда 
		Возврат;
	КонецЕсли;
	мПлатформа.ИнициализацияОписанияМетодовИСвойств();
	Если Не ЗначениеЗаполнено(НомерСтроки) Тогда
		ПолеТекста.ПолучитьГраницыВыделения(мНачальнаяСтрока, мНачальнаяКолонка, мКонечнаяСтрока, мКонечнаяКолонка);
	Иначе
		мНачальнаяСтрока = НомерСтроки;
		мКонечнаяСтрока = НомерСтроки;
	    мНачальнаяКолонка = НомерКолонки;
		мКонечнаяКолонка = НомерКолонки;
	КонецЕсли; 
	ПрочитатьНачалоИКонецТекущейСтроки();
	мЭтоОбъявлениеПсевдонима = Ложь;
	мЭтоСтроковыйЛитерал = ирОбщий.ЛиВнутриСтроковогоЛитералаЛкс(ТекущееНачалоСтроки);
	Если КакВызовМетода Или мЭтоСтроковыйЛитерал Тогда
		ТекущийКонтекстМетода();
	КонецЕсли; 
	
	RegExp.Global = Ложь;
	ШаблонПрефиксаПараметра = "(?:&|#|\?|@)?";
		
	// Начало контекста
	СтрокаШаблона = шПредИмя + "(";
	Если Ложь
		Или ЯзыкПрограммы = 1
		Или ЯзыкПрограммы = 2
	Тогда
		СтрокаШаблона = "(?:" + шРазделитель + "+(КАК|AS|(?:ПОМЕСТИТЬ|INTO(?:" + шРазделитель + "+TABLE)?))" + шРазделитель + "*)?" + СтрокаШаблона + ШаблонПрефиксаПараметра + "(?:" + шИмя + ")?";
	Иначе
		СтрокаШаблона = "()" + СтрокаШаблона + шИмя; 
	КонецЕсли;
	СтрокаШаблона = СтрокаШаблона + шСкобки + "?"
		//+ "((\.(" + шИмя + ")" + шСкобки + "?)|" + шИндекс + ")*\.?)";
		+ "((\.(" + шИмя + ")" + шСкобки + "?)|" + шИндекс + ")*\.?)?"; // 20.08.2020
	Если ЛиСправаОтРавенства Тогда
		СтрокаШаблона = СтрокаШаблона + шРазделитель + "*=" + шРазделитель + "*";
	КонецЕсли;
	СтрокаШаблона = СтрокаШаблона + "$";
	RegExp.Pattern = СтрокаШаблона;
	Результат = RegExp.НайтиВхождения(ТекущееНачалоСтроки);
	Если Результат.Количество() > 0 Тогда
		ПервоеВхождение = Результат[0];
		НачалоКонтекста = "" + ПервоеВхождение.SubMatches(1);
		мЭтоОбъявлениеПсевдонима = ПервоеВхождение.SubMatches(0) <> Неопределено И Найти(НачалоКонтекста, ".") = 0;
	КонецЕсли; 
	ОригинальныйТекст = ПолеТекста.ПолучитьТекст();
	
	// Конец контекста
	RegExp.Global = Ложь;
	Если Не ЛиСправаОтРавенства Тогда
		RegExp.Pattern = "([" + шБуква + "\d]*\(?)(\.)?";
		Результат = RegExp.НайтиВхождения(ТекущийКонецСтроки);
		Если Результат.Количество() > 0 Тогда
			КонецКонтекста = Результат[0].SubMatches(0);
			выхЕстьТочкаСправа = Результат[0].SubMatches(1) <> Неопределено;
		КонецЕсли;
	КонецЕсли; 
	
	Если Ложь
		Или ЯзыкПрограммы = 1
		Или ЯзыкПрограммы = 2
	Тогда
		СтрокаШаблона = ШаблонПрефиксаПараметра + "(?:" + шИмя + ")?"; 
	Иначе
		СтрокаШаблона = шИмя;
	КонецЕсли;
	СтрокаШаблона = "(?:((?:" + шИмяСкобки + "?" + "(?:(?:\." + шИмяСкобки + "?)|" + шИндекс + ")*))\.)?(" + СтрокаШаблона + ")?$";
	// Родительский контекст по позиции курсора
	RegExp.Pattern = СтрокаШаблона;
	Результат = RegExp.НайтиВхождения(НачалоКонтекста);
	Если Результат.Количество() > 0 Тогда
		ПервоеВхождение = Результат[0];
		Если ПервоеВхождение.SubMatches(0) <> Неопределено Тогда 
			мРодительскийКонтекст = ПервоеВхождение.SubMatches(0);
		КонецЕсли;
		Если ПервоеВхождение.SubMatches(4) <> Неопределено Тогда 
			НачалоСлова = ПервоеВхождение.SubMatches(4);
		КонецЕсли;
	КонецЕсли;
	мТекущееСлово = НачалоСлова + ирОбщий.ПервыйФрагментЛкс(КонецКонтекста);
	мКонтекст = НачалоКонтекста + КонецКонтекста;
	
	ТекстБезКомментариевИОпасныхСтрок = ЗалитьКомментарииИСтроковыеЛитералы(ОригинальныйТекст);
	мПозицияТекстаДляПоискаОпределения = 0;
	мПредшествующийТекст = "";
	мТекстДляПоискаОпределения = "";
	// Здесь не учтена возможность наличия комментария слева от текущей позиции
	Если мКонечнаяСтрока > 1 Тогда
		СлужебноеПолеТекста.УстановитьТекст(ОригинальныйТекст);
		СлужебноеПолеТекста.УстановитьГраницыВыделения(1, 1, мКонечнаяСтрока - 1, 333);
		мПредшествующийТекст = СлужебноеПолеТекста.ВыделенныйТекст;
		СлужебноеПолеТекста.УстановитьТекст(ТекстБезКомментариевИОпасныхСтрок);
		СлужебноеПолеТекста.УстановитьГраницыВыделения(1, 1, мКонечнаяСтрока - 1, 333);
		мТекстДляПоискаОпределения = СлужебноеПолеТекста.ВыделенныйТекст;
	КонецЕсли; 
	Если ЯзыкПрограммы = 0 Тогда
		мТекстДляПоискаОпределения = мТекстДляПоискаОпределения + Лев(ТекущееНачалоСтроки, СтрДлина(ТекущееНачалоСтроки) - СтрДлина(НачалоКонтекста));
	Иначе
		ПозицииЗапросовПакета = Новый Массив;
		ЗапросыПакета = мПлатформа.РазбитьГрубоТекстПакетногоЗапросаНаТекстыЗапросов(ОригинальныйТекст, СтрДлина(мПредшествующийТекст), ПозицииЗапросовПакета);
		#Если Сервер И Не Сервер Тогда
			ЗапросыПакета = Новый Массив;
		#КонецЕсли
		НомерПервойСтрокиЗапроса = 1;
		ЧислоСтрокВЗапросе = 0;
		Если ЗапросыПакета.Количество() > 0 Тогда
			Для ИндексЗапроса = 0 По ЗапросыПакета.ВГраница() Цикл
				ЗапросПакета = ЗапросыПакета[ИндексЗапроса];
				мТекстДляПоискаОпределения = ЗапросПакета;
				ТекстБезКомментариевИОпасныхСтрок = ЗапросПакета;
				мПозицияТекстаДляПоискаОпределения = ПозицииЗапросовПакета[ИндексЗапроса];
				ЧислоСтрокВЗапросе = СтрЧислоВхождений(ЗапросПакета, Символы.ПС);
				НомерПервойСтрокиЗапроса = НомерПервойСтрокиЗапроса + ЧислоСтрокВЗапросе;
				Если НомерПервойСтрокиЗапроса >= мНачальнаяСтрока Тогда
					Прервать;
				КонецЕсли; 
			КонецЦикла; 
		КонецЕсли; 
		НомерТекущейСтрокиВЗапросе = мКонечнаяСтрока - (НомерПервойСтрокиЗапроса - ЧислоСтрокВЗапросе - 1);
		Если НомерТекущейСтрокиВЗапросе > 1 Тогда
			СлужебноеПолеТекста.УстановитьТекст(ЗапросПакета);
			СлужебноеПолеТекста.УстановитьГраницыВыделения(1, 1, НомерТекущейСтрокиВЗапросе - 1, 333);
			мПредшествующийТекст = СлужебноеПолеТекста.ВыделенныйТекст;
			СлужебноеПолеТекста.УстановитьТекст(ОригинальныйТекст);
		Иначе
			мПредшествующийТекст = Прав(мПредшествующийТекст, 500);
		КонецЕсли; 
	КонецЕсли;
	мПредшествующийТекст = мПредшествующийТекст + Лев(ТекущееНачалоСтроки, СтрДлина(ТекущееНачалоСтроки) - СтрДлина(НачалоКонтекста));
	НачатьОбработкуКоманды();

КонецПроцедуры

// Выполняет программу на внутреннем языке.
//
// Параметры:
//  Нет.
//
// Возвращаемое значение:
//  Булево – безошибочность выполнения кода.
//
Функция ВыполнитьПрограммныйКод() Экспорт
	
	ТекстДляВыполнения = ПолеТекста.ПолучитьТекст();
	Попытка
		мПлатформа.ВыполнитьПрограммныйКодВКонтексте(КонтекстВыполнения, МетодВыполнения, ТекстДляВыполнения);
		Возврат Истина;
	Исключение
		// Баг платформы. Зависает приложение, если пытаемся установить выделение на невидимой странице.
		ФормаВладелец.ТекущийЭлемент = ПолеТекста.ЭлементФормы;
		
		ирОбщий.ПоказатьОшибкуВТекстеПрограммыЛкс(ПолеТекста,,,,, ИнформацияОбОшибке()); 
		Возврат Ложь;
	КонецПопытки;

КонецФункции // ВыполнитьПрограммныйКод()

Функция ЗаполнитьДоступныеТаблицыWQL() Экспорт

	////Если мДоступныеТаблицыПолучены Тогда
	////	Возврат Неопределено;
	////КонецЕсли; 
	////ЭтотОбъект.мДоступныеТаблицыПолучены = Истина;
	//ДоступныеТаблицы.Очистить();
	ОчиститьДоступныеНеВременныеТаблицы();
	Если Конфигурация = Неопределено Тогда
		Возврат Неопределено;
	КонецЕсли; 
	Состояние("Подготовка метаданных...");
	wbemFlagUseAmendedQualifiers = 131072; //&H20000
	КоллекцияКлассов = Конфигурация.SubclassesOf(, wbemFlagUseAmendedQualifiers);
	ВидимостьКолонкиСхема = Ложь;
	ВидимостьКолонкиОписание = Ложь;
	Индикатор = ирОбщий.ПолучитьИндикаторПроцессаЛкс(КоллекцияКлассов.Count, "Получаем метаданные");
	Для Каждого ЭлементКоллекции Из КоллекцияКлассов Цикл
		ирОбщий.ОбработатьИндикаторЛкс(Индикатор);
		СтрокаТаблицы = ДоступныеТаблицы.Добавить();
		СтрокаТаблицы.Имя = ЭлементКоллекции.Path_.Class;
		//СтрокаТаблицы.Схема = СтрокаТЗ.TABLE_SCHEMA;
		//СтрокаТаблицы.Тип = СтрокаТЗ.TABLE_TYPE;
		СтрокаТаблицы.Описание = ирОбщий.ПолучитьОписаниеЭлементаWMIЛкс(ЭлементКоллекции);
		ПолноИмя = СтрокаТаблицы.Имя;
		Если ЗначениеЗаполнено(СтрокаТаблицы.Схема) Тогда
			ПолноИмя = СтрокаТаблицы.Схема + "." + ПолноИмя;
		КонецЕсли;
		СтрокаТаблицы.ПолноеИмя = ПолноИмя;
		СтрокаТаблицы.НПолноеИмя = НРег(СтрокаТаблицы.ПолноеИмя);
		ВидимостьКолонкиСхема = ВидимостьКолонкиСхема Или ЗначениеЗаполнено(СтрокаТаблицы.Схема);
		ВидимостьКолонкиОписание = ВидимостьКолонкиСхема Или ЗначениеЗаполнено(СтрокаТаблицы.Описание);
	КонецЦикла;
	ирОбщий.ОсвободитьИндикаторПроцессаЛкс();
	Возврат Неопределено;

КонецФункции

Функция ЗаполнитьДоступныеТаблицыADO() Экспорт

	////Если мДоступныеТаблицыПолучены Тогда
	////	Возврат Неопределено;
	////КонецЕсли; 
	////мДоступныеТаблицыПолучены = Истина;
	//ДоступныеТаблицы.Очистить();
	ОчиститьДоступныеНеВременныеТаблицы();
	Если Ложь
		Или Конфигурация = Неопределено 
		Или Конфигурация.State = 0
	Тогда
		Возврат Неопределено;
	КонецЕсли; 
	Состояние("Подготовка метаданных...");
	Если Не мРасширенноеПолучениеМетаданныхADO Тогда
		Фильтры = Новый Массив();
		Фильтры.Добавить(); // TABLE_CATALOG
		Фильтры.Добавить(); // TABLE_SCHEMA
		Фильтры.Добавить(); // TABLE_NAME
		Если Не мРасширенноеПолучениеМетаданныхADO Тогда
			Фильтры.Добавить("TABLE"); // TABLE_TYPE
		КонецЕсли; 
		Фильтры = Новый COMSafeArray(Фильтры, "VT_VARIANT");
		ОписаниеТаблицRecordSet = Конфигурация.OpenSchema(20, Фильтры); //adSchemaTables // Может выполняться долго (oracle)
	Иначе
		ОписаниеТаблицRecordSet = Конфигурация.OpenSchema(20); //adSchemaTables // Может выполняться долго (oracle)
	КонецЕсли; 
	ОписаниеТаблицТЗ = ирОбщий.РезультатЗапросаADOВТаблицуЗначенийОбщийЛкс(ОписаниеТаблицRecordSet);
	Если ирКэш.РежимОтладкиЛкс() Тогда 
		// Пассивный оригинал расположенного ниже однострочного кода. Выполняйте изменения синхронно в обоих вариантах.
		Для Каждого СтрокаТЗ Из ОписаниеТаблицТЗ Цикл
			ТипТаблицы = СтрокаТЗ.TABLE_TYPE;
			Если Истина
				И Не ирОбщий.СтрокиРавныЛкс(ТипТаблицы, "table")
				И Не ирОбщий.СтрокиРавныЛкс(ТипТаблицы, "view")
			Тогда
				Продолжить;
			КонецЕсли; 
			СтрокаТаблицы = ДоступныеТаблицы.Добавить();
			СтрокаТаблицы.Имя = СтрокаТЗ.TABLE_NAME;
			СтрокаТаблицы.Схема = СтрокаТЗ.TABLE_SCHEMA;
			СтрокаТаблицы.Тип = ТипТаблицы;
			СтрокаТаблицы.Описание = СтрокаТЗ.DESCRIPTION;
			ПолноеИмяДоступнойТаблицы = ПолноеИмяДоступнойТаблицы(СтрокаТаблицы.Имя, СтрокаТаблицы.Схема);
			СтрокаТаблицы.ПолноеИмя = ПолноеИмяДоступнойТаблицы;
			СтрокаТаблицы.НПолноеИмя = НРег(ПолноеИмяДоступнойТаблицы);
		КонецЦикла;
	Иначе
		// Однострочный код использован для ускорения. Выше расположен оригинал. Выполняйте изменения синхронно в обоих вариантах. Преобразовано консолью кода из подсистемы "Инструменты разработчика" (http://devtool1c.ucoz.ru)
		Для Каждого СтрокаТЗ Из ОписаниеТаблицТЗ Цикл  		ТипТаблицы = СтрокаТЗ.TABLE_TYPE;  		Если Истина  			И Не ирОбщий.СтрокиРавныЛкс(ТипТаблицы, "table")  			И Не ирОбщий.СтрокиРавныЛкс(ТипТаблицы, "view")  		Тогда  			Продолжить;  		КонецЕсли;  		СтрокаТаблицы = ДоступныеТаблицы.Добавить();  		СтрокаТаблицы.Имя = СтрокаТЗ.TABLE_NAME;  		СтрокаТаблицы.Схема = СтрокаТЗ.TABLE_SCHEMA;  		СтрокаТаблицы.Тип = ТипТаблицы;  		СтрокаТаблицы.Описание = СтрокаТЗ.DESCRIPTION;  		ПолноеИмяДоступнойТаблицы = ПолноеИмяДоступнойТаблицы(СтрокаТаблицы.Имя, СтрокаТаблицы.Схема);  		СтрокаТаблицы.ПолноеИмя = ПолноеИмяДоступнойТаблицы;  		СтрокаТаблицы.НПолноеИмя = НРег(ПолноеИмяДоступнойТаблицы);  	КонецЦикла;  
	КонецЕсли; 
	Возврат Неопределено;

КонецФункции

Функция ПолучитьИмяТаблицыADO(Знач ИмяИсходное)  
	
	Если Лев(ИмяИсходное, 1) <> "[" Тогда
		ИмяИсходное = "[" + ИмяИсходное + "]";  
	КонецЕсли;  
	Возврат ИмяИсходное;
	
 КонецФункции
 
Функция НайтиДобавитьДоступнуюВременнуюТаблицу(Знач ЛюбоеИмяТаблицы, ПородившийЗапрос = Неопределено, выхБылиДобавления = Ложь, ИсточникДанных1С = Неопределено) Экспорт
	
	КраткоеИмяТаблицы = КраткоеИмяВременнойТаблицы(ЛюбоеИмяТаблицы);
	ПолноеИмяТаблицы = ПолноеИмяДоступнойТаблицы(ЛюбоеИмяТаблицы);
	ПолноеИмяТаблицы = ПолноеИмяВременнойТаблицы(ПолноеИмяТаблицы, ИсточникДанных1С);
	СтрокаДоступнойТаблицы = ДоступныеТаблицы.Найти(НРег(ПолноеИмяТаблицы), "НПолноеИмя");
	Если СтрокаДоступнойТаблицы = Неопределено Тогда
		СтрокаДоступнойТаблицы = ДоступныеТаблицы.Добавить();
		СтрокаДоступнойТаблицы.Имя = КраткоеИмяТаблицы;
		СтрокаДоступнойТаблицы.ПолноеИмя = ПолноеИмяТаблицы;
		СтрокаДоступнойТаблицы.Схема = ИсточникДанных1С;
		ирОбщий.ОбновитьКопиюСвойстваВНижнемРегистреЛкс(СтрокаДоступнойТаблицы, "ПолноеИмя");
		СтрокаДоступнойТаблицы.Тип = "ВременнаяТаблица";
		СтрокаДоступнойТаблицы.ЕстьДоступ = Истина;
		выхБылиДобавления = Истина;
	КонецЕсли;
	Если ПородившийЗапрос <> Неопределено Тогда
		Для Каждого СтараяСтрока Из ДоступныеТаблицы.НайтиСтроки(Новый Структура("ПородившийЗапрос", ПородившийЗапрос)) Цикл
			Если СтараяСтрока = СтрокаДоступнойТаблицы Тогда
				Продолжить;
			КонецЕсли; 
			ДоступныеТаблицы.Удалить(СтараяСтрока);
		КонецЦикла;
		СтрокаДоступнойТаблицы.ПородившийЗапрос = ПородившийЗапрос;
	КонецЕсли; 
	Возврат СтрокаДоступнойТаблицы;
	
КонецФункции

Функция ПолноеИмяДоступнойТаблицы(Знач ИмяДоступнойТаблицы, ИмяСхемы = Неопределено) Экспорт 
	
	Если Истина
		И Найти(ИмяДоступнойТаблицы, ".") = 0 
		И мПараметрыДиалектаSQL.Диалект <> "1С" 
		И мПараметрыДиалектаSQL.Диалект <> "WQL"
	Тогда
		ИмяДоступнойТаблицы = ПолучитьИмяТаблицыADO(ИмяДоступнойТаблицы); 
		Если ИмяСхемы = Неопределено И ДоступныеТаблицы.Количество() > 0 Тогда
			ИмяСхемы = ДоступныеТаблицы[0].Схема;
		КонецЕсли;
		Если ЗначениеЗаполнено(ИмяСхемы) Тогда
			ИмяДоступнойТаблицы = ИмяСхемы + "." + ИмяДоступнойТаблицы;
		КонецЕсли; 
	КонецЕсли; 
	Возврат ИмяДоступнойТаблицы;

КонецФункции

Функция ПолноеИмяВременнойТаблицы(Знач КраткоеИмяТаблицы, Знач ИсточникДанных1С = Неопределено) Экспорт 
	
	Результат = КраткоеИмяТаблицы;
	Если Истина
		И Найти(КраткоеИмяТаблицы, ".") = 0
		И мПараметрыДиалектаSQL.Диалект = "1С"
		И ЗначениеЗаполнено(ИсточникДанных1С) 
		И ИсточникДанных1С <> "<Локальный>"
	Тогда
		Результат = "ВнешнийИсточникДанных." + ИсточникДанных1С + ".ВременнаяТаблица." + Результат;
	КонецЕсли;
	Возврат Результат;

КонецФункции

Функция КраткоеИмяВременнойТаблицы(ЛюбоеИмяТаблицы) Экспорт 
	Результат = ЛюбоеИмяТаблицы;
	Если Истина
		И мПараметрыДиалектаSQL.Диалект = "1С"
		И Найти(Результат, ".") > 0
	Тогда
		Результат = ирОбщий.ПоследнийФрагментЛкс(Результат);
	КонецЕсли;
	Возврат Результат;
КонецФункции

Процедура ОчиститьДоступныеВременныеТаблицы(ТаблицаДоступныхТаблиц = Неопределено) Экспорт

	Если ТаблицаДоступныхТаблиц = Неопределено Тогда
		ТаблицаДоступныхТаблиц = ДоступныеТаблицы;
	КонецЕсли; 
	СтрокиКУдалению = ТаблицаДоступныхТаблиц.НайтиСтроки(Новый Структура("Тип", "ВременнаяТаблица"));
	Для Каждого СтрокаКУдалению Из СтрокиКУдалению Цикл
		ТаблицаДоступныхТаблиц.Удалить(СтрокаКУдалению);;
	КонецЦикла;
	
КонецПроцедуры

Процедура ОчиститьДоступныеНеВременныеТаблицы() Экспорт

	ДоступныеВременныеТаблицы = ДоступныеТаблицы.Выгрузить(Новый Структура("Тип", "ВременнаяТаблица"));
	ДоступныеТаблицы.Очистить();
	ДоступныеТаблицы.Загрузить(ДоступныеВременныеТаблицы);
	
КонецПроцедуры

Функция ПрефиксПараметра() Экспорт
	
	Возврат мПараметрыДиалектаSQL.ПрефиксПараметра;
	
КонецФункции

// Вызывает конструктор запросов и передает ему текст из текстового поля.
//
// Параметры:
//  Нет.
//
Функция ВызватьКонструкторЗапросов(Знач ИспользуемСобственныйКонструктор = Неопределено) Экспорт

	Если ирОбщий.ПроверитьПлатформаНеWindowsЛкс(,, Истина) Тогда
		Возврат Ложь;
	КонецЕсли; 
	#Если Сервер И Не Сервер Тогда
		мПлатформа = Обработки.ирПлатформа.Создать();
	#КонецЕсли
	РежимТолькоПросмотр = Ложь
		Или ПолеТекста.ТолькоПросмотр()
		Или ФормаВладелец.ТолькоПросмотр;
	Если РежимТолькоПросмотр Тогда
		Ответ = Вопрос("Текст запроса не может быть изменен. Открыть конструктор без возможности сохранения изменений?",
			РежимДиалогаВопрос.ОКОтмена);
		Если Ответ = КодВозвратаДиалога.Отмена Тогда
			Возврат Ложь;
		КонецЕсли;
	КонецЕсли;
	Если Не ирКэш.ЛиПлатформаWindowsЛкс() Тогда
		ИспользуемСобственныйКонструктор = Ложь
	КонецЕсли; 
	ПредпочитаюСобственныйКонструкторЗапроса = Ложь;
	Если ИспользуемСобственныйКонструктор = Неопределено Тогда
		ПредпочитаюСобственныйКонструкторЗапроса = ирОбщий.ВосстановитьЗначениеЛкс(ИмяКласса + ".ПредпочитаюСобственныйКонструкторЗапроса");
		Если ПредпочитаюСобственныйКонструкторЗапроса = Неопределено Тогда
			Ответ = Вопрос("Подсистема имеет собственный конструктор запроса. Приоритет его использования задается в настройках компоненты ""Контекстная подсказка"".
			|Хотите установить приоритет его использования?", РежимДиалогаВопрос.ДаНет);
			ПредпочитаюСобственныйКонструкторЗапроса = Ответ = КодВозвратаДиалога.Да;
		КонецЕсли; 
	КонецЕсли; 
	ИспользуемСобственныйКонструктор = Ложь
		Или ИспользуемСобственныйКонструктор = Истина
		Или мДиалектSQL <> "1С"
		Или ПредпочитаюСобственныйКонструкторЗапроса;
	Если ИспользуемСобственныйКонструктор Тогда
		КонструкторЗапроса = ПолучитьФорму("КонструкторЗапроса");
		КонструкторЗапроса.Конфигурация = Конфигурация;
	Иначе
		КонструкторЗапроса = Новый КонструкторЗапроса;
	КонецЕсли; 
	//ОбрамитьСобранныйТекстСкобками = Ложь;
	Если ЯзыкПрограммы = 1 Тогда
		Если СтрДлина(СокрЛП(ВыделенныйТекст())) < 6 И Не ЭтоЧастичныйЗапрос Тогда 
			ТекстЗапроса = ПолеТекста.ПолучитьТекст();
			НачальнаяСтрокаЗапроса = 0; 
			НачальнаяКолонкаЗапроса = 0;
		Иначе
			ТекстЗапроса = ВыделенныйТекст();
			//Если Не ЗначениеЗаполнено(ТекстЗапроса) И ЭтоЧастичныйЗапрос Тогда
			//	ТекстЗапроса = "ВЫБРАТЬ 1";
			//	ОбрамитьСобранныйТекстСкобками = Истина;
			//КонецЕсли; 
			НачальнаяСтрокаЗапроса = мНачальнаяСтрока - 1; 
			НачальнаяКолонкаЗапроса = мНачальнаяКолонка - 1;
		КонецЕсли;
		КонструкторЗапроса.РежимКомпоновкиДанных = РежимКомпоновкиДанных;
		//КонструкторЗапроса.АвтодобавлениеПредставлений = Истина;
		МассивВременныхТаблиц = Новый Массив;
		Если Не ПустаяСтрока(ТекстЗапроса) Тогда
			Если Истина
				И ТипЗнч(КонтекстВыполнения) = Тип("Запрос") 
				И Не ИспользуемСобственныйКонструктор
			Тогда
				СтарыйТекстЗапроса = ТекстЗапроса;
				ИнформацияОбОшибке = ПолучитьИнформациюОбОшибке(ТекстЗапроса);
				Попытка
					ТекстЗапроса = мПлатформа.ЗамаскироватьВременныеТаблицы(КонтекстВыполнения, ТекстЗапроса, МассивВременныхТаблиц);
				Исключение
					ФормаВладелец.ТекущийЭлемент = ПолеТекста.ЭлементФормы;
					ирОбщий.ПоказатьОшибкуВТекстеПрограммыЛкс(ПолеТекста, , , Истина,, ИнформацияОбОшибке());
					Возврат Ложь;
				КонецПопытки;
				НоваяИнформацияОбОшибке = ПолучитьИнформациюОбОшибке(ТекстЗапроса);
				Если Истина
					И НоваяИнформацияОбОшибке <> Неопределено
					И ИнформацияОбОшибке = Неопределено
					И Найти(ирОбщий.ПодробноеПредставлениеОшибкиЛкс(НоваяИнформацияОбОшибке), "Ожидается псевдоним запроса") > 0 
				Тогда
					// Сюда попадаем, когда у временной таблицы нет псевдонима
					ирОбщий.СообщитьСУчетомМодальностиЛкс("В запросе присутствуют временные таблицы без псевдонимов. "
						+ "Для максимальной функциональности рекомендуется задать каждой временной таблице псевдоним",, СтатусСообщения.Внимание);
					МассивВременныхТаблиц = Новый Массив;
					ТекстЗапроса = СтарыйТекстЗапроса;
                КонецЕсли; 
			КонецЕсли;
		КонецЕсли;
	Иначе
		РазобратьТекущийКонтекст();
		ТекстПоля = ПолеТекста.ПолучитьТекст();
		RegExp.Global = Истина;
		RegExp.MultiLine = Истина;
		RegExp.Pattern = шСтрокаПрограммы;
		Результат = RegExp.НайтиВхождения(ТекстПоля);
		Успех = Ложь;
		ДлинаТекстаДо = СтрДлина(мПредшествующийТекст);
		Для Каждого Вхождение Из Результат Цикл
			Если Истина
				И (Вхождение.FirstIndex + 1) <= ДлинаТекстаДо 
				И (Вхождение.FirstIndex + Вхождение.Length + 1) >= ДлинаТекстаДо 
			Тогда
				ПолеТекста.УстановитьГраницыВыделения(Вхождение.FirstIndex + 1, Вхождение.FirstIndex + Вхождение.Length + 1);
				Успех = Истина;
				Прервать;
			КонецЕсли;
		КонецЦикла;
		ПолеТекста.ПолучитьГраницыВыделения(НачальнаяСтрокаЗапроса, НачальнаяКолонкаЗапроса, , );
		НачальнаяСтрокаЗапроса = НачальнаяСтрокаЗапроса - 1; 
		НачальнаяКолонкаЗапроса = НачальнаяСтрокаЗапроса - 1;
		Если Успех Тогда
			ТекстЗапроса = ВыделенныйТекст();
			Если Прав(ТекстЗапроса, 1) <> """" Тогда
				ТекстЗапроса = ТекстЗапроса + """";
			КонецЕсли; 
			ТекстЗапроса = Вычислить(ТекстЗапроса);
			ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "|", "");
		Иначе
			ТекстЗапроса = "";
		КонецЕсли;
	КонецЕсли;
	Если ИспользуемСобственныйКонструктор Тогда
		Парсер = мПлатформа.мПолучитьПарсер("ГрамматикаЯзыкаЗапросов");
		Если Парсер = Неопределено Тогда
			ирОбщий.СообщитьСУчетомМодальностиЛкс("Компонента анализа текста запроса не подключена");
			Возврат Ложь;
		КонецЕсли; 
	КонецЕсли; 
	Если Не ПустаяСтрока(ТекстЗапроса) Тогда
		Если ИспользуемСобственныйКонструктор Тогда
			РезультатРазбора = ЗагрузитьТекстВКонструктор(ТекстЗапроса, КонструкторЗапроса,, мДиалектSQL,, НачальнаяСтрокаЗапроса);
			Если Не РезультатРазбора Тогда
				Возврат Ложь;
			КонецЕсли; 
		Иначе
			СтруктуруРезультатаПакетногоЗапроса = мПлатформа.СтруктураРезультатаПакетногоЗапроса(ТекстЗапроса);
			Если СтруктуруРезультатаПакетногоЗапроса.Количество() > 0 Тогда
				Ответ = Вопрос("В комментариях обнаружены имена запросов. Стандартный конструктор запросов их удалит. Продолжить?", РежимДиалогаВопрос.ОКОтмена);
				Если Ответ <> КодВозвратаДиалога.ОК Тогда
					Возврат Ложь;
				КонецЕсли;
			КонецЕсли; 
			Попытка
				КонструкторЗапроса.Текст = ТекстЗапроса;
			Исключение
				ФормаВладелец.ТекущийЭлемент = ПолеТекста.ЭлементФормы;
				ирОбщий.ПоказатьОшибкуВТекстеПрограммыЛкс(ПолеТекста, НачальнаяСтрокаЗапроса, НачальнаяКолонкаЗапроса, Истина,, ИнформацияОбОшибке());
				Возврат Ложь;
			КонецПопытки;
		КонецЕсли; 
	Иначе
		Если ИспользуемСобственныйКонструктор Тогда
			//КонструкторЗапроса.УстановитьДиалектSQL(мДиалектSQL);
			КонструкторЗапроса.УстановитьДанные();
		КонецЕсли; 
	КонецЕсли;
	ирОбщий.СохранитьЗначениеЛкс(ИмяКласса + ".ПредпочитаюСобственныйКонструкторЗапроса", ПредпочитаюСобственныйКонструкторЗапроса);
	РезультатФормы = КонструкторЗапроса.ОткрытьМодально();
	Если РезультатФормы = Истина Тогда
		Если Не РежимТолькоПросмотр Тогда
			НовыйТекстЗапроса = КонструкторЗапроса.Текст;
			Если Истина
				И ТипЗнч(Конфигурация) = Тип("ОбъектМетаданныхКонфигурация")
				И ТипЗнч(КонтекстВыполнения) = Тип("Запрос") 
			Тогда
				//RegExp.Global = Истина;
				//RegExp.MultiLine = Истина;
				//RegExp.IgnoreCase = Истина;
				//// Допустим 1 уровень скобок.
				//шОдинарныеСкобки = "\([^\)\(]*?\)";
				//шИмяВременнойТаблицы = "";
				//Для Каждого ПодмененнаяВременнаяТаблица Из МассивВременныхТаблиц Цикл
				//	шИмяВременнойТаблицы = шИмяВременнойТаблицы + "|" + ПодмененнаяВременнаяТаблица;
				//КонецЦикла;
				//шИмяВременнойТаблицы = Сред(шИмяВременнойТаблицы, 2);
				//RegExp.Pattern = "\(ВЫБРАТЬ(?:" + шОдинарныеСкобки + "|[^$\(\)])*?""ВременнаяТаблица"" = ""(" + шИмяВременнойТаблицы + ")""\)";
				//НовыйТекстЗапроса = RegExp.Заменить(НовыйТекстЗапроса, "$1");
				НовыйТекстЗапроса = мПлатформа.РазмаскироватьВременныеТаблицы(НовыйТекстЗапроса, МассивВременныхТаблиц);
			КонецЕсли;
			Если ЯзыкПрограммы = 1 Тогда
				Если Не ЭтоЧастичныйЗапрос И НачальнаяСтрокаЗапроса = 0 Тогда 
					ВыделитьВесьТекст();
				КонецЕсли; 
				//Если ОбрамитьСобранныйТекстСкобками Тогда
				//	НовыйТекстЗапроса = "(" + НовыйТекстЗапроса + ")";
				//КонецЕсли; 
				Если ИспользуемСобственныйКонструктор Тогда
					ПолучитьНомерТекущейСтроки();
					ВыделенныйТекст(НовыйТекстЗапроса);
					мНачальнаяСтрока = мНачальнаяСтрока + КонструкторЗапроса.мНомерТекущейСтрокиВСобранномТексте; 
					мНачальнаяКолонка = 1;
					мКонечнаяСтрока = мНачальнаяСтрока;
					мКонечнаяКолонка = мНачальнаяКолонка;
				Иначе
					ВыделенныйТекст(НовыйТекстЗапроса);
				КонецЕсли; 
				ПослеУстановкиВыделенногоМногострочногоТекста();
			Иначе
				НовыйТекстЗапроса = ирОбщий.ПолучитьСтроковыйЛитералИзМногострочногоТекстаЛкс(НовыйТекстЗапроса);
				ЧислоСтрокЗамены = СтрЧислоСтрок(НовыйТекстЗапроса);
				ТекстовыйДокумент = Новый ТекстовыйДокумент;
				ТекстовыйДокумент.УстановитьТекст(НовыйТекстЗапроса);
				СдвинутыйТекст = ТекстовыйДокумент.ПолучитьСтроку(1);
				ЗаменаТабуляции = ирОбщий.СтрокаПовторомЛкс(" ", ШиринаТабуляции);
				ТекстНачальнойСтроки = ПолеТекста.ПолучитьСтроку(мНачальнаяСтрока);
				ДлинаНачалаСтроки = СтрДлина(ТекстНачальнойСтроки) - СтрДлина(СокрЛ(ТекстНачальнойСтроки));
				НачалоСтроки = Лев(ТекстНачальнойСтроки, ДлинаНачалаСтроки);
				ДлинаРазвернутогоНачалаСтроки = СтрДлина(СтрЗаменить(НачалоСтроки, Символы.Таб, ЗаменаТабуляции));
				ЧислоТабуляций = ДлинаРазвернутогоНачалаСтроки / ШиринаТабуляции;
				ЧислоПробелов  = ДлинаРазвернутогоНачалаСтроки % ШиринаТабуляции;
				НачалоНовойСтроки = ирОбщий.СтрокаПовторомЛкс(Символы.Таб, ЧислоТабуляций);
				НачалоНовойСтроки = НачалоНовойСтроки + ирОбщий.СтрокаПовторомЛкс(" ", ЧислоПробелов);
				Для Счетчик = 2 По ЧислоСтрокЗамены Цикл
					ТекущаяСтрокаВставки = ТекстовыйДокумент.ПолучитьСтроку(Счетчик);
					СдвинутыйТекст = СдвинутыйТекст + Символы.ПС + НачалоНовойСтроки + ТекущаяСтрокаВставки;
				КонецЦикла;
				ВыделенныйТекст(СдвинутыйТекст);
				ПослеУстановкиВыделенногоМногострочногоТекста();
			КонецЕсли;
			Возврат Истина;
		КонецЕсли;
	КонецЕсли;
	Возврат Ложь;

КонецФункции

Процедура ПоказатьТекущиеКоординаты(ПолеТекста, СтартоваяСтрокаДляОтображенияОшибок = 0)

	#Если Сервер И Не Сервер Тогда
		ПолеТекста = Обработки.ирОболочкаПолеТекста.Создать();
	#КонецЕсли
	// Антибаг платформы 8.1 . Терялся фокус
	ФормаВладелец.ТекущийЭлемент = ПолеТекста.ЭлементФормы;
	ПолеТекста.ПоказатьОшибку(мПарсер.CurrentLineNumber() + СтартоваяСтрокаДляОтображенияОшибок, мПарсер.CurrentColumnNumber());

КонецПроцедуры

Функция ПолучитьКоординатыВТекстеЗапроса(ПолеТекста, СтартоваяСтрокаДляОтображенияОшибок = 0)
	
	НомерСтроки = СтартоваяСтрокаДляОтображенияОшибок + мПарсер.CurrentLineNumber();
	Результат = "";
	Если ПолеТекста <> Неопределено Тогда
		Результат = Результат + ирОбщий.ПредставлениеИзИдентификатораЛкс(ПолеТекста.ЭлементФормы.Имя) + ": ";
	КонецЕсли; 
	Результат = Результат + "Строка " + НомерСтроки + ": {(" + НомерСтроки + "," + мПарсер.CurrentColumnNumber() + ")}: ";
	Возврат Результат;
		
КонецФункции

Функция ПолучитьСтрокуОжидаемыхТокенов()

	СтрокаОжидаемыхТокенов = "";
	Для й = 0 по мПарсер.TokenCount() - 1 Цикл
		Токен = мПарсер.Tokens(й);
		СтрокаОжидаемыхТокенов = СтрокаОжидаемыхТокенов + ", " + Токен.Text;
	КонецЦикла;
	Возврат Сред(СтрокаОжидаемыхТокенов, 3);

КонецФункции // ПолучитьСтрокуОжидаемыхТокенов()

Функция _ПолучитьГраничныйТерминалПравила(Данные, ИндексГраницы = 0, ЗахватыватьКрайниеКомментарии = Ложь) Экспорт

	КоличествоТокенов = Данные.TokenCount;
	Для Сч1 = 1 По КоличествоТокенов Цикл
		Если ИндексГраницы = 1 Тогда
			УзелКандидат = Данные.Tokens(КоличествоТокенов - Сч1);
		Иначе
			УзелКандидат = Данные.Tokens(Сч1 - 1);
		КонецЕсли; 
		Если ТипЗнч(УзелКандидат.Data) = Тип("Строка") Тогда
			Если ЗахватыватьКрайниеКомментарии И ИндексГраницы = 1 И УзелКандидат.EndNoise <> Неопределено Тогда
				Возврат УзелКандидат.EndNoise;
			ИначеЕсли ЗахватыватьКрайниеКомментарии И ИндексГраницы = 0 И УзелКандидат.BeginNoise <> Неопределено Тогда
				Возврат УзелКандидат.BeginNoise;
			Иначе
				Возврат УзелКандидат;
			КонецЕсли; 
		ИначеЕсли ТипЗнч(УзелКандидат.Data) = Тип("COMОбъект") Тогда
			Если УзелКандидат.Data.TokenCount > 0 Тогда
				УзелСнизу = _ПолучитьГраничныйТерминалПравила(УзелКандидат.Data, ИндексГраницы, ЗахватыватьКрайниеКомментарии);
				Если УзелСнизу <> Неопределено Тогда
					Возврат УзелСнизу;
				КонецЕсли; 
			КонецЕсли;
		КонецЕсли;
	КонецЦикла;
	Возврат Неопределено;

КонецФункции

Функция ПолучитьТекстИзТокена(Токен, выхНачальнаяСтрока = 0, выхНачальнаяКолонка = 0, выхКонечнаяСтрока = 0, выхКонечнаяКолонка = 0) Экспорт

	Если Токен = Неопределено Тогда
		Возврат "";
	КонецЕсли; 
	НачальныйТокен = Токен.GetBorderToken(0);
	Если НачальныйТокен = Неопределено Тогда
		Возврат "";
	КонецЕсли; 
	выхНачальнаяКолонка = НачальныйТокен.ColumnNumber;
	выхНачальнаяСтрока = НачальныйТокен.LineNumber;
	КонечныйТокен = Токен.GetBorderToken(1);
	Если КонечныйТокен = Неопределено Тогда
		Возврат "";
	КонецЕсли; 
	выхКонечнаяКолонка = КонечныйТокен.ColumnNumber + СтрДлина(КонечныйТокен.Data);
	выхКонечнаяСтрока = КонечныйТокен.LineNumber + СтрЧислоСтрок(КонечныйТокен.Data) - 1;
	СлужебноеПолеТекста.УстановитьГраницыВыделения(выхНачальнаяСтрока, выхНачальнаяКолонка, выхКонечнаяСтрока, выхКонечнаяКолонка);
	ТекстОпределения = СлужебноеПолеТекста.ВыделенныйТекст;
	ТекстОпределения = СокрЛП(ТекстОпределения);
	Возврат ТекстОпределения;

КонецФункции

Функция _ПолучитьТекстИзДанныхТокена(ДанныеТокена, выхНачальнаяСтрока = 0, выхНачальнаяКолонка = 0, выхКонечнаяСтрока = 0, выхКонечнаяКолонка = 0) Экспорт

	НачальныйТокен = _ПолучитьГраничныйТерминалПравила(ДанныеТокена, 0);
	Если НачальныйТокен = Неопределено Тогда
		Возврат "";
	КонецЕсли; 
	выхНачальнаяКолонка = НачальныйТокен.ColumnNumber;
	выхНачальнаяСтрока = НачальныйТокен.LineNumber;
	КонечныйТокен = _ПолучитьГраничныйТерминалПравила(ДанныеТокена, 1);
	Если КонечныйТокен = Неопределено Тогда
		Возврат "";
	КонецЕсли; 
	выхКонечнаяКолонка = КонечныйТокен.ColumnNumber + СтрДлина(КонечныйТокен.Data);
	выхКонечнаяСтрока = КонечныйТокен.LineNumber + СтрЧислоСтрок(КонечныйТокен.Data) - 1;
	СлужебноеПолеТекста.УстановитьГраницыВыделения(выхНачальнаяСтрока, выхНачальнаяКолонка, выхКонечнаяСтрока, выхКонечнаяКолонка);
	ТекстОпределения = СлужебноеПолеТекста.ВыделенныйТекст;
	ТекстОпределения = СокрЛП(ТекстОпределения);
	Возврат ТекстОпределения;

КонецФункции

Функция ЗагрузитьТекстВКонструктор(ТекстЗапроса = Неопределено, Знач КонструкторЗапроса = Неопределено, Знач СокращенноеДерево = Ложь, ДиалектSQL = Неопределено,
	ИменованныеПараметры = Неопределено, СтартоваяСтрокаДляОтображенияОшибок = 0) Экспорт
	
	Если ТекстЗапроса = Неопределено Тогда
		ТекстЗапроса = ПолеТекста.ПолучитьТекст();
	КонецЕсли;
	Если КонструкторЗапроса <> Неопределено Тогда
		КонструкторЗапроса.УстановитьДиалектSQL(ДиалектSQL, ИменованныеПараметры);
	КонецЕсли; 
	ТаблицаКомментариев = Неопределено;
	БылиПотери = Неопределено;
	НачальныйТокен = РазобратьТекстЗапроса(ТекстЗапроса, СокращенноеДерево,,, Истина, ТаблицаКомментариев, БылиПотери, СтартоваяСтрокаДляОтображенияОшибок);
	Если Истина
		И НачальныйТокен <> Неопределено
		И КонструкторЗапроса <> Неопределено 
	Тогда
		КонструкторЗапроса.СлужебноеПолеТекста.УстановитьТекст(ТекстЗапроса);
		Если ДиалектSQL = Неопределено Тогда
			ДиалектSQL = мДиалектSQL;
		КонецЕсли; 
		КонструкторЗапроса.ЗапросыПакета.Очистить();
		КонструкторЗапроса.УстановитьДанные(НачальныйТокен, ТаблицаКомментариев, БылиПотери,, ПолучитьНомерТекущейСтроки());
	КонецЕсли;
	Возврат НачальныйТокен <> Неопределено;
	
КонецФункции

// Возвращает начальный токен (Структура) построенной структуры запроса.
//
// Параметры:
//  ТекстЗапроса						 - 	 - 
//  СокращенноеДерево					 - 	 - 
//  ОбновлятьСостояние					 - 	 - 
//  пПолеТекста							 - ОбработкаОбъект.ирПолеТекста, Неопределено, Null - при Неопределено будет использоваться связанное поле, при Null поле не будет использоваться
//  СообщатьОПропущенныхТерминалах		 - 	 - 
//  выхТаблицаКомментариев				 - 	 - 
//  выхБылиПотери						 - 	 - 
//  СтартоваяСтрокаДляОтображенияОшибок	 - 	 - 
// 
// Возвращаемое значение:
//   - 
//
Функция РазобратьТекстЗапроса(ТекстЗапроса, СокращенноеДерево = Ложь, ОбновлятьСостояние = Истина, Знач пПолеТекста = Неопределено,
	СообщатьОПропущенныхТерминалах = Ложь, выхТаблицаКомментариев = Неопределено, выхБылиПотери = Неопределено, СтартоваяСтрокаДляОтображенияОшибок = 0) Экспорт 

	#Если Сервер И Не Сервер Тогда
	    мПлатформа = Обработки.ирПлатформа.Создать();
	#КонецЕсли
	мПарсер = мПлатформа.мПолучитьПарсер("ГрамматикаЯзыкаЗапросов");
	Если мПарсер = Неопределено Тогда
		Возврат Неопределено;
	КонецЕсли;
	Если пПолеТекста = Null Тогда
		пПолеТекста = Неопределено;
	ИначеЕсли пПолеТекста = Неопределено Тогда
		пПолеТекста = ПолеТекста;
	Иначе
		пПолеТекста = ирОбщий.ОболочкаПоляТекстаЛкс(пПолеТекста);
	КонецЕсли; 
	Если ОбновлятьСостояние Тогда
		ирОбщий.СостояниеЛкс("Синтаксический разбор...");
	КонецЕсли; 
	выхТаблицаКомментариев = Новый ТаблицаЗначений;
	выхТаблицаКомментариев.Колонки.Добавить("Позиция", Новый ОписаниеТипов("Число"));
	выхТаблицаКомментариев.Колонки.Добавить("Текст", Новый ОписаниеТипов("Строка"));
	выхТаблицаКомментариев.Колонки.Добавить("ЭтоРасширение", Новый ОписаниеТипов("Булево"));
	gpMsgTokenRead			= 1;
	gpMsgReduction			= 2;
	gpMsgAccept				= 3;
	gpMsgNotLoadedError		= 4;
	gpMsgLexicalError		= 5;
	gpMsgSyntaxError 		= 6;
	gpMsgCommentError		= 7;
	gpMsgInternalError		= 8;
	gpMsgCommentBlockRead	= 9;
	gpMsgCommentLineRead	= 10;
	мПарсер.OpenTextString(ТекстЗапроса + Символы.ПС);
	Закончили = Ложь;
	//ПоследниеТокены = Новый Массив();
	ПоследнееПравилоНеКомментарий = Неопределено;
	TrimReductions = СокращенноеДерево;
	мПарсер.TrimReductions = СокращенноеДерево; // Была Истина
	Пока Не Закончили Цикл 
		ОбработкаПрерыванияПользователя();
		Ответ = мПарсер.Parse();
		Если Истина
			И СокращенноеДерево
			И TrimReductions <> Истина 
		Тогда
			мПарсер.TrimReductions = Истина;
			TrimReductions = Истина;
		КонецЕсли; 
		Если Ложь
			Или Ответ = gpMsgLexicalError 
			Или (Истина // Хотя Builder в этом случае диагностирует лексическую ошибку, этот парсер почему то бесконечно выдает статус 7
				И Ответ = 7 
				И мПарсер.CurrentReduction = Неопределено)
		Тогда
			мПарсер.PopInputToken();
			Закончили = Истина;
			КоординатыВТекстеЗапроса = ПолучитьКоординатыВТекстеЗапроса(пПолеТекста, СтартоваяСтрокаДляОтображенияОшибок);
			ирОбщий.СообщитьСУчетомМодальностиЛкс(КоординатыВТекстеЗапроса + "Лексическая ошибка!",, СтатусСообщения.Важное);
			Если пПолеТекста <> Неопределено Тогда
				ПоказатьТекущиеКоординаты(пПолеТекста, СтартоваяСтрокаДляОтображенияОшибок);
			КонецЕсли; 
		ИначеЕсли Ответ = gpMsgSyntaxError Тогда
			ТекущийТокен = мПарсер.CurrentToken();
			Если Истина
				И ТекущийТокен.Kind = 1 
				И (Ложь
					Или ТекущийТокен.Name = "MultiCommentLine"
					//Или ТекущийТокен.Name = "ExtensionBlock"
					Или ТекущийТокен.Name = "CommentBlock")
			Тогда
				Если СообщатьОПропущенныхТерминалах Тогда
					КоординатыВТекстеЗапроса = ПолучитьКоординатыВТекстеЗапроса(пПолеТекста, СтартоваяСтрокаДляОтображенияОшибок);
					ирОбщий.СообщитьСУчетомМодальностиЛкс(КоординатыВТекстеЗапроса + "Проигнорирован комментарий """ 
						+ СокрЛП(ТекущийТокен.Data) + """"
						//+ ", ожидается: " + ПолучитьСтрокуОжидаемыхТокенов()
						, , СтатусСообщения.Внимание);
				КонецЕсли; 
				мПарсер.PopInputToken();
			Иначе
				КоординатыВТекстеЗапроса = ПолучитьКоординатыВТекстеЗапроса(пПолеТекста, СтартоваяСтрокаДляОтображенияОшибок);
				ТекстОшибки = КоординатыВТекстеЗапроса + "Синтаксическая ошибка """ 
					+ ТекущийТокен.Data + """"
					+ ", ожидается: " + ПолучитьСтрокуОжидаемыхТокенов();
				ирОбщий.СообщитьСУчетомМодальностиЛкс(ТекстОшибки,, СтатусСообщения.Важное);
				Если пПолеТекста <> Неопределено Тогда
					ПоказатьТекущиеКоординаты(пПолеТекста, СтартоваяСтрокаДляОтображенияОшибок);
				КонецЕсли; 
				Закончили = Истина;
			КонецЕсли; 
		ИначеЕсли Ответ = gpMsgReduction Тогда
			Если СокращенноеДерево Тогда
				//ИмяПравила = мПарсер.CurrentReduction.ParentRule.RuleNonterminal.Name;
				ИмяПравила = мПарсер.CurrentRuleName();
				Если Ложь // Есть сомнения, что это работает как задумано
					Или ИмяПравила = "Table" 
					Или ИмяПравила = "TableName"
				Тогда
					мПарсер.TrimReductions = Ложь;
					TrimReductions = Ложь;
				КонецЕсли; 
			КонецЕсли; 
		ИначеЕсли Ответ = gpMsgAccept Тогда
			Закончили = Истина;
		ИначеЕсли Ответ = gpMsgCommentError Тогда
		ИначеЕсли Ответ = gpMsgTokenRead Тогда
			Если мПарсер.IsCurrentTokenComment() Тогда
				// Храним 2 последних токена
				ТекущийТокен = мПарсер.CurrentToken();
				ПрочитатьКомментарий(выхТаблицаКомментариев, ТекущийТокен, пПолеТекста, СообщатьОПропущенныхТерминалах, СтартоваяСтрокаДляОтображенияОшибок);
			КонецЕсли; 
		ИначеЕсли Ответ = gpMsgInternalError Тогда
			Закончили = Истина;
		ИначеЕсли Ответ = gpMsgNotLoadedError Тогда
			Закончили = Истина;
		КонецЕсли;
	КонецЦикла;
	Если ОбновлятьСостояние Тогда
		ирОбщий.СостояниеЛкс("");
	КонецЕсли; 
	Если Ответ = gpMsgAccept Тогда
		НачальныйТокен = Новый Структура("Data, LineNumber, ColumnNumber, Name, Kind", мПарсер.CurrentReduction, 0, 0, "", 0);
		Возврат НачальныйТокен;
	Иначе
		Возврат Неопределено;
	КонецЕсли; 

КонецФункции

Процедура ПрочитатьКомментарий(Знач выхТаблицаКомментариев, Знач ТекущийТокен, Знач пПолеТекста, Знач СообщатьОПропущенныхТерминалах, Знач СтартоваяСтрокаДляОтображенияОшибок)
	
	ТекстКомментария = СокрЛП(ТекущийТокен.Data);
	МаркерХАРАКТЕРИСТИКИ = "ХАРАКТЕРИСТИКИ";
	ЭтоРасширение = Ложь;
	Если Лев(ТекстКомментария, 1) = "{" Тогда
		ТекстКомментария = Сред(ТекстКомментария, 2, СтрДлина(ТекстКомментария) - 2);
		ЭтоРасширение = мПараметрыДиалектаSQL.Это1С;
	ИначеЕсли Лев(ТекстКомментария, 2) = "//" Тогда
		ТекстКомментария = Сред(ТекстКомментария, 3);
	ИначеЕсли Лев(ТекстКомментария, 2) = "/*" Тогда
		ТекстКомментария = Сред(ТекстКомментария, 3, СтрДлина(ТекстКомментария) - 4);
	КонецЕсли; 
	Если ЭтоРасширение И Лев(ТекстКомментария, СтрДлина(МаркерХАРАКТЕРИСТИКИ)) = МаркерХАРАКТЕРИСТИКИ Тогда
		выхБылиПотери = Истина;
		Если СообщатьОПропущенныхТерминалах Тогда
			КоординатыВТекстеЗапроса = ПолучитьКоординатыВТекстеЗапроса(пПолеТекста, СтартоваяСтрокаДляОтображенияОшибок);
			ирОбщий.СообщитьСУчетомМодальностиЛкс(КоординатыВТекстеЗапроса + "Проигнорирован комментарий """ 
			+ СокрЛП(ТекущийТокен.Data) + """"
			//+ ", ожидается: " + ПолучитьСтрокуОжидаемыхТокенов()
			, , СтатусСообщения.Внимание);
		КонецЕсли; 
	ИначеЕсли ЗначениеЗаполнено(ТекстКомментария) Тогда 
		СтрокаРасширения = выхТаблицаКомментариев.Добавить();
		СтрокаРасширения.ЭтоРасширение = ЭтоРасширение;
		СтрокаРасширения.Позиция = ПолучитьОтносительнуюПозициюТокена(ТекущийТокен);
		СтрокаРасширения.Текст = ТекстКомментария; // Убираем крайние фигурные скобки
	КонецЕсли;

КонецПроцедуры

Функция ПолучитьОтносительнуюПозициюТокена(Токен) Экспорт 
	
	Результат = Токен.LineNumber * 1000 + Токен.ColumnNumber;
	Возврат Результат;
	
КонецФункции

// Вызывает конструктор запросов и передает ему текст из текстового поля.
//
// Параметры:
//  Нет.
//
Функция ОткрытьРедакторСтроковогоЛитерала()

	Если ирОбщий.ПроверитьПлатформаНеWindowsЛкс(,, Истина) Тогда
		Возврат Ложь;
	КонецЕсли; 
	РежимТолькоПросмотр = Ложь
		Или ПолеТекста.ТолькоПросмотр()
		Или ФормаВладелец.ТолькоПросмотр;
	Если РежимТолькоПросмотр Тогда
		Ответ = Вопрос("Текст не может быть изменен. Открыть редактор без возможности сохранения измений?",
			РежимДиалогаВопрос.ОКОтмена);
		Если Ответ = КодВозвратаДиалога.Отмена Тогда
			Возврат Ложь;
		КонецЕсли;
	КонецЕсли;
	ТекстСтроковогоЛитерала = ВыделитьТекстТекущегоСтроковогоЛитерала();
	ФормаРедактора = мПлатформа.ПолучитьФорму("Текст", , Новый УникальныйИдентификатор);
	ФормаРедактора.НачальноеЗначениеВыбора = ТекстСтроковогоЛитерала;
	Если ФормаРедактора.ОткрытьМодально() <> Неопределено Тогда
		Если Не РежимТолькоПросмотр Тогда
			НовыйТекстЗапроса = ФормаРедактора.Текст;
			НовыйТекстЗапроса = ирОбщий.ПолучитьСтроковыйЛитералИзМногострочногоТекстаЛкс(НовыйТекстЗапроса);
			ЧислоСтрокЗамены = СтрЧислоСтрок(НовыйТекстЗапроса);
			ТекстовыйДокумент = Новый ТекстовыйДокумент;
			ТекстовыйДокумент.УстановитьТекст(НовыйТекстЗапроса);
			СдвинутыйТекст = ТекстовыйДокумент.ПолучитьСтроку(1);
			ЗаменаТабуляции = ирОбщий.СтрокаПовторомЛкс(" ", ШиринаТабуляции);
			ТекстНачальнойСтроки = ПолеТекста.ПолучитьСтроку(мНачальнаяСтрока);
			ДлинаНачалаСтроки = СтрДлина(ТекстНачальнойСтроки) - СтрДлина(СокрЛ(ТекстНачальнойСтроки));
			НачалоСтроки = Лев(ТекстНачальнойСтроки, ДлинаНачалаСтроки);
			ДлинаРазвернутогоНачалаСтроки = СтрДлина(СтрЗаменить(НачалоСтроки, Символы.Таб, ЗаменаТабуляции));
			ЧислоТабуляций = ДлинаРазвернутогоНачалаСтроки / ШиринаТабуляции;
			ЧислоПробелов  = ДлинаРазвернутогоНачалаСтроки % ШиринаТабуляции;
			НачалоНовойСтроки = ирОбщий.СтрокаПовторомЛкс(Символы.Таб, ЧислоТабуляций);
			НачалоНовойСтроки = НачалоНовойСтроки + ирОбщий.СтрокаПовторомЛкс(" ", ЧислоПробелов);
			Для Счетчик = 2 По ЧислоСтрокЗамены Цикл
				ТекущаяСтрокаВставки = ТекстовыйДокумент.ПолучитьСтроку(Счетчик);
				СдвинутыйТекст = СдвинутыйТекст + Символы.ПС + НачалоНовойСтроки + ТекущаяСтрокаВставки;
			КонецЦикла;
			ВыделенныйТекст(СдвинутыйТекст);
			ПослеУстановкиВыделенногоМногострочногоТекста();
			Возврат Истина;
		КонецЕсли;
	КонецЕсли;
	Возврат Ложь;

КонецФункции

Функция ВыделитьТекстТекущегоСтроковогоЛитерала() Экспорт 
	
	#Если Сервер И Не Сервер Тогда
		ПолеТекста = Обработки.ирОболочкаПолеТекста.Создать();
	#КонецЕсли
	РазобратьТекущийКонтекст();
	ТекстПоля = ПолеТекста.ПолучитьТекст();
	RegExp.Global = Истина;
	RegExp.MultiLine = Истина;
	RegExp.IgnoreCase = Истина;
	RegExp.Pattern = шСтрокаПрограммы;
	Результат = RegExp.НайтиВхождения(ТекстПоля);
	Успех = Ложь;
	ДлинаТекстаДо = СтрДлина(мПредшествующийТекст) + 1; // +1 добавлено для срабатывания на однострочном литерале
	Для Каждого Match Из Результат Цикл
		Если Истина
			И (Match.FirstIndex + 1) <= ДлинаТекстаДо 
			И (Match.FirstIndex + Match.Length + 1) >= ДлинаТекстаДо 
		Тогда
			ПолеТекста.УстановитьГраницыВыделения(Match.FirstIndex + 1, Match.FirstIndex + Match.Length + 1,, ФормаВладелец);
			Успех = Истина;
			Прервать;
		КонецЕсли;
	КонецЦикла;
	НачальнаяСтрокаЗапроса = 0;
	НачальнаяКолонкаЗапроса = 0;
	ПолеТекста.ПолучитьГраницыВыделения(НачальнаяСтрокаЗапроса, НачальнаяКолонкаЗапроса, , );
	НачальнаяСтрокаЗапроса = НачальнаяСтрокаЗапроса - 1; 
	НачальнаяКолонкаЗапроса = НачальнаяСтрокаЗапроса - 1;
	Если Успех Тогда
		ТекстСтроковогоЛитерала = ВыделенныйТекст();
		Если Ложь
			Или Прав(ТекстСтроковогоЛитерала, 1) <> """" 
			Или СтрДлина(ТекстСтроковогоЛитерала) = 1
		Тогда
			ТекстСтроковогоЛитерала = ТекстСтроковогоЛитерала + """";
		КонецЕсли; 
		ТекстСтроковогоЛитерала = Вычислить(ТекстСтроковогоЛитерала);
		////ТекстСтроковогоЛитерала = СтрЗаменить(ТекстСтроковогоЛитерала, "|", "");
		//RegExp.Pattern = "(\s*)\|((.|"""")*(\n|\r|""))";
		//ТекстСтроковогоЛитерала = RegExp.Заменить(ТекстСтроковогоЛитерала, "$1 $2");
	Иначе
		ТекстСтроковогоЛитерала = Неопределено;
	КонецЕсли;
	Возврат ТекстСтроковогоЛитерала;

КонецФункции

// Осуществляет переход к определению контекста.
//
// Параметры:
//  Нет.
//
Процедура ПерейтиКОпределению(НомерСтроки = 0, НомерКолонки = 0, ТолькоТипы = Ложь) Экспорт 
	
	#Если Сервер И Не Сервер Тогда
		ПолеТекста = Обработки.ирОболочкаПолеТекста.Создать();
	#КонецЕсли
	Если ирОбщий.ПроверитьПлатформаНеWindowsЛкс(,, Истина) Тогда
		Возврат;
	КонецЕсли; 
	РазобратьТекущийКонтекст(,,, НомерСтроки, НомерКолонки);
	Если ПустаяСтрока(мКонтекст) Тогда
		Возврат;
	КонецЕсли;
	ПоследнееВхождение = Неопределено;
	ПоследнееОпределение = Неопределено;
	НайтиОпределениеСлова(мКонтекст, ПоследнееОпределение, ПоследнееВхождение);
	Если ПоследнееВхождение <> Неопределено Тогда
		НачальнаяПозицияОпределения = мПозицияТекстаДляПоискаОпределения + ПоследнееВхождение.FirstIndex + Найти(ПоследнееВхождение.Value, ПоследнееОпределение);
		КонечнаяПозицияОпределения = НачальнаяПозицияОпределения + СтрДлина(ПоследнееОпределение);
		СлужебноеПолеТекста.УстановитьГраницыВыделения(НачальнаяПозицияОпределения, КонечнаяПозицияОпределения);
		СлужебноеПолеТекста.ПолучитьГраницыВыделения(мНачальнаяСтрока, мНачальнаяКолонка, мКонечнаяСтрока, мКонечнаяКолонка); // Там текст без комментариев и опасных строковых литералов
		ПолеТекста.УстановитьГраницыВыделения(мНачальнаяСтрока, мНачальнаяКолонка, мКонечнаяСтрока, мКонечнаяКолонка,, ФормаВладелец);
	ИначеЕсли ЯзыкПрограммы = 0 Тогда 
		ТаблицаСлов.Найти(НРег(мКонтекст), "НСлово");
		ТаблицаСтруктурТипов = ОпределитьТипЗначенияКонтекста(мКонтекст, " " + мТекстДляПоискаОпределения, мПредшествующийТекст, Истина);
		// TODO Сделать диалог выбора варианта
		Для Каждого СтруктураТипа Из ТаблицаСтруктурТипов Цикл
			Если ОткрытьОпределениеСтруктурыТипа(СтруктураТипа) Тогда 
				Прервать;
			КонецЕсли; 
		КонецЦикла;
	ИначеЕсли ЯзыкПрограммы = 1 Тогда 
		ОписаниеТаблицыБД = ирОбщий.ОписаниеТаблицыБДЛкс(мКонтекст);
		Если ОписаниеТаблицыБД <> Неопределено Тогда
			ирОбщий.ОткрытьОбъектМетаданныхЛкс(ОписаниеТаблицыБД.ПолноеИмяМД);
		КонецЕсли; 
	КонецЕсли;

КонецПроцедуры

Функция ОткрытьОпределениеСтруктурыТипа(Знач СтруктураТипа)
	
	Если СтруктураТипа.СтрокаОписания <> Неопределено Тогда 
		ТаблицаВладелец = СтруктураТипа.СтрокаОписания.Владелец();
		#Если Сервер И Не Сервер Тогда
			ТаблицаВладелец = Новый ТаблицаЗначений;
		#КонецЕсли
		Если ТаблицаВладелец.Колонки.Найти("ЛиЭкспорт") <> Неопределено  Тогда
			// Экспортный метод модуля
			СтрокаСозданияРодителя = ТаблицаВладелец.Колонки.Имя.Заголовок;
			Если ЗначениеЗаполнено(СтрокаСозданияРодителя) Тогда
				Ответ = Вопрос("Перейти к определению метода через открытие вспомогательной внешней обработки в открытом конфигураторе?", РежимДиалогаВопрос.ОКОтмена);
				Если Ответ = КодВозвратаДиалога.ОК Тогда
					ирОбщий.ПерейтиКОпределениюМетодаВКонфигуратореЛкс(СтрокаСозданияРодителя + "." + ирОбщий.СтрокаБезКонцаЛкс(мТекущееСлово, 1));
				КонецЕсли;
				Возврат Истина;
			КонецЕсли; 
		ИначеЕсли Истина
			И ТаблицаВладелец.Колонки.Найти("Значение") <> Неопределено 
			И ирОбщий.ЛиСсылкаНаОбъектБДЛкс(СтруктураТипа.СтрокаОписания.Значение)
			И ЗначениеЗаполнено(СтруктураТипа.СтрокаОписания.Значение) 
		Тогда
			//ирОбщий.ОткрытьСсылкуВРедактореОбъектаБДЛкс(СтруктураТипа.СтрокаОписания.Значение);
			ОткрытьЗначение(СтруктураТипа.СтрокаОписания.Значение);
			Возврат Истина;
		ИначеЕсли Истина
			И ТаблицаВладелец.Колонки.Найти("ТипЗначения") <> Неопределено 
			И СтруктураТипа.СтрокаОписания.ТипЗначения = "Картинка"
			И ТипЗнч(СтруктураТипа.Метаданные) = Тип("ОбъектМетаданных")
		Тогда
			ирОбщий.ОткрытьЗначениеЛкс(БиблиотекаКартинок[СтруктураТипа.Метаданные.Имя]);
			Возврат Истина;
		КонецЕсли; 
	КонецЕсли; 
	Если ТипЗнч(СтруктураТипа.Метаданные) = Тип("ОбъектМетаданных") Тогда
		ПолноеИмяМД = СтруктураТипа.Метаданные.ПолноеИмя();
		ирОбщий.ОткрытьОбъектМетаданныхЛкс(СтруктураТипа.Метаданные);
		Возврат Истина;
	КонецЕсли; 
	НайтиПоказатьСправкуПоСтруктуреТипа(мКонтекст, СтруктураТипа);
	Возврат Ложь;

КонецФункции

// Ищем в мТекстДляПоискаОпределения
Функция НайтиОпределениеСлова(Слово, ПоследнееОпределение = Неопределено, ПоследнееВхождение = Неопределено) Экспорт 
	
	ПоследнееОпределение = Неопределено;
	Если ЯзыкПрограммы = 1 Тогда
		RegExp.Global = Ложь;
		RegExp.Pattern = СтрЗаменить(шПоискОписанияТаблицы, "#Идентификатор#", ирОбщий.ПреобразоватьТекстДляРегулярныхВыраженийЛкс(Слово));
		РезультатТекста = RegExp.НайтиВхождения(мТекстДляПоискаОпределения);
		Если РезультатТекста.Количество() > 0 Тогда
			ПоследнееВхождение = РезультатТекста[0];
			ПоследнееОпределение = ПоследнееВхождение.SubMatches(3);
			лНачальнаяСтрока = 0;
			лНачальнаяКолонка = 0;
			лКонечнаяСтрока = 0;
			лКонечнаяКолонка = 0;
			СлужебноеПолеТекста.УстановитьГраницыВыделения(мПозицияТекстаДляПоискаОпределения + ПоследнееВхождение.FirstIndex + 1, 
				мПозицияТекстаДляПоискаОпределения + ПоследнееВхождение.FirstIndex + 1 + СтрДлина(ПоследнееОпределение));
			СлужебноеПолеТекста.ПолучитьГраницыВыделения(лНачальнаяСтрока, лНачальнаяКолонка, лКонечнаяСтрока, лКонечнаяКолонка);
			Если Истина
				И лНачальнаяСтрока = мНачальнаяСтрока И лНачальнаяКолонка <= мНачальнаяКолонка 
				И лКонечнаяСтрока = мКонечнаяСтрока И лКонечнаяКолонка >= мКонечнаяКолонка
			Тогда
				RegExp.Global = Ложь;
				ШаблонСозданияТаблицы = "(?:" + шРазделитель + ")+" + "(?:ПОМЕСТИТЬ|INTO(?:" + шРазделитель + "+TABLE)?)" + шРазделитель + "+(#Идентификатор#)" + шРазделитель;
				RegExp.Pattern = СтрЗаменить(ШаблонСозданияТаблицы, "#Идентификатор#", ирОбщий.ПреобразоватьТекстДляРегулярныхВыраженийЛкс(Слово));
				РезультатТекста = RegExp.НайтиВхождения(ТекстБезКомментариевИОпасныхСтрок);
				Если РезультатТекста.Количество() > 0 Тогда
					ПоследнееОпределение = РезультатТекста[0].SubMatches(0);
					ПоследнееВхождение = ирОбщий.СоздатьОбъектПоПолномуИмениМетаданныхЛкс("Обработка.ирОболочкаРегВхождение");
					ЗаполнитьЗначенияСвойств(ПоследнееВхождение, РезультатТекста[0],, "SubMatches"); // Создаем неполноценный объект ради изменения свойства FirstIndex
					ПоследнееВхождение.FirstIndex = ПоследнееВхождение.FirstIndex - мПозицияТекстаДляПоискаОпределения;
				КонецЕсли; 
			КонецЕсли; 
		Иначе
			МаркерЗначение = "ЗНАЧЕНИЕ(";
			Если Прав(мПредшествующийТекст, СтрДлина(МаркерЗначение)) = МаркерЗначение Тогда
				RegExp.Global = Ложь;
				RegExp.Pattern = шИмя;
				Если RegExp.Проверить(Слово) Тогда 
					Попытка
						ПредопределенноеЗначение = ПредопределенноеЗначение(Слово);
					Исключение
						ПредопределенноеЗначение = Неопределено;
					КонецПопытки; 
					Если ПредопределенноеЗначение <> Неопределено Тогда
						ОткрытьЗначение(ПредопределенноеЗначение);
					КонецЕсли; 
				КонецЕсли; 
			КонецЕсли; 
		КонецЕсли;
	Иначе
		RegExp.Global = Истина;
		//шПрисваивание = "(" + шРазделитель + "*=" + шРазделитель + "*((Новый|New)" + шРазделитель + "+(" + шИмя + ")|(" + шИмяСкобки + "?" + шИндекс 
		//	+ "?(\." + шИмяСкобки + "?" + шИндекс + "?)*)" + "|(" + шЧисло + ")|(" + шСтрокаПрограммы + ")))";
		ШаблонКоллекции = "(" + шРазделитель + "+Из" + шРазделитель + "+(" + шИмяСкобки + "?" + шИндекс + "?" + "(\." + шИмяСкобки + "?" + шИндекс + "?)*))";
		RegExp.Pattern = шПредИмя + ирОбщий.ПреобразоватьТекстДляРегулярныхВыраженийЛкс(Слово) + "(" + шПрисваивание + "|" + ШаблонКоллекции + ")";
		РезультатТекста = RegExp.НайтиВхождения(мТекстДляПоискаОпределения);
		Если РезультатТекста.Количество() > 0 Тогда
			ПоследнееВхождение = РезультатТекста[РезультатТекста.Количество() - 1];
			ПоследнееОпределение = ПоследнееВхождение.SubMatches(0);
			//Если ПоследнееВхождение.SubMatches(1) <> Неопределено Тогда
			//	// Это присвоение
			//	ПоследнееОпределение = ПоследнееВхождение.SubMatches(1);
			//Иначе
			//	// Это обход коллекции
			//	ПоследнееОпределение = ПоследнееВхождение.SubMatches(20);
			//КонецЕсли;
		КонецЕсли;
	КонецЕсли;
	Возврат ПоследнееОпределение;

КонецФункции

// <Описание процедуры>
//
// Параметры:
//  <Параметр1>  – <Тип.Вид> – <описание параметра>
//                 <продолжение описания параметра>;
//  <Параметр2>  – <Тип.Вид> – <описание параметра>
//                 <продолжение описания параметра>.
//
Процедура ДобавитьТипЭлементаКоллекцииВТаблицуСтруктурТипов(СтруктураТипаКоллекции, СтруктураТипаЭлементаКоллекции, ТаблицаСтруктурТипов)

	БазовыеТипы = мПлатформа.ПолучитьТипыЭлементовКоллекции(СтруктураТипаКоллекции);
	Если БазовыеТипы.Количество() > 0 Тогда
		Для Каждого БазовыйТип Из БазовыеТипы Цикл
			СтруктураКлюча = Новый Структура("БазовыйТип, ЯзыкПрограммы", БазовыйТип, ЯзыкПрограммы);
			НайденныеСтроки = мПлатформа.ТаблицаОбщихТипов.НайтиСтроки(СтруктураКлюча);
			Если НайденныеСтроки.Количество() > 0 Тогда
				СтруктураТипаЭлементаКоллекции.СтрокаОписания = НайденныеСтроки[0];
				СтруктураТипаЭлементаКоллекции.ИмяОбщегоТипа  = НайденныеСтроки[0].Слово;
				Если ТипЗнч(СтруктураТипаКоллекции.Метаданные) <> Тип("КоллекцияОбъектовМетаданных") Тогда
					СтруктураТипаЭлементаКоллекции.Метаданные = СтруктураТипаКоллекции.Метаданные;
				КонецЕсли; 
			Иначе
				СтруктураТипаЭлементаКоллекции.ИмяОбщегоТипа = БазовыйТип;
			КонецЕсли;
			мПлатформа.ДобавитьВТаблицуСтруктурТипов(ТаблицаСтруктурТипов, СтруктураТипаЭлементаКоллекции);
		КонецЦикла;
	Иначе
		мПлатформа.ДобавитьВТаблицуСтруктурТипов(ТаблицаСтруктурТипов, СтруктураТипаЭлементаКоллекции);
	КонецЕсли;

КонецПроцедуры // ДобавитьТипЭлементаКоллекцииВТаблицуСтруктурТипов()

// Вычисляет массив структур типа дочернего контекста.
//
// Параметры:
//  МассивРодительскихСтрутурТипа – Массив – родительских структур типа;
//  ТекущееСлово – Строка – дочернеее слово;
//  ТипСлова     - Строка - тип слова;
//  *ТекущийИндекс - Строка, *Неопределено - выражение в квадратных скобках;
//  *ТекущиеАргументы – Строка, *"" – аргументы метода;
//  *ПредшествующийТекст – Строка, *"" – текст для поиска определения таблицы в режиме языка запросов.
//
// Возвращаемое значение:
//  МассивСтрутурТипа - Массив – дочерних структур типа.
//
Функция ОпределитьТипДочернегоКонтекста(МассивРодительскихСтрутурТипа, ТекущееСлово, ТипСлова, ТекущийИндекс = Неопределено, ТекущиеАргументы = "", ПредшествующийТекст = "",
	ПолныйАнализ = Истина)

	#Если Сервер И Не Сервер Тогда
		мПлатформа = Обработки.ирПлатформа.Создать();
	#КонецЕсли
	ТаблицаСвойствТипа = мПлатформа.НоваяТаблицаСвойствТипа(); // Ускорение
	ТаблицаСтруктурТипов = мПлатформа.НоваяТаблицаСтруктурТипа();
	СчетчикТипов = 0;
	Для Каждого РодительскаяСтрутураТипа Из МассивРодительскихСтрутурТипа Цикл
		СчетчикТипов = СчетчикТипов + 1;
		Если Истина
			И Не ПолныйАнализ
			И СчетчикТипов > 50
		Тогда 
			Прервать;
		КонецЕсли; 
		Если РодительскаяСтрутураТипа.ИмяОбщегоТипа <> "Неизвестный контекст" Тогда
			МетаданныеРодителя = РодительскаяСтрутураТипа.Метаданные;
			Если Не ЗначениеЗаполнено(ТекущийИндекс) Тогда
				
				// Ищем правило вычисления
				Если ТипСлова = "Метод" Тогда
					КлючСтроки = Новый Структура;
					КлючСтроки.Вставить("ТипКонтекста", РодительскаяСтрутураТипа.ИмяОбщегоТипа);
					КлючСтроки.Вставить("НСлово", НРег(ТекущееСлово));
					НайденныеСтроки = ПравилаВычисленияФункций.НайтиСтроки(КлючСтроки);
					Если НайденныеСтроки.Количество() > 0 Тогда
						RegExp.Global = Истина;
						Если ЯзыкПрограммы = 0 Тогда
							RegExp.Pattern = "(" + шВыражениеПрограммы + ")?" + шРазделитель + "*,";
						Иначе
							RegExp.Pattern = "(" + шВыражениеЗапроса   + ")?" + шРазделитель + "*,";
						КонецЕсли;
						Результат = RegExp.НайтиВхождения(Нрег(Сред(ТекущиеАргументы, 2, СтрДлина(ТекущиеАргументы) - 2) + ","));
						МассивПараметров = Новый Массив;
						Для Каждого Вхождение Из Результат Цикл
							МассивПараметров.Добавить(СокрЛП(Вхождение.SubMatches(0)));
						КонецЦикла;
						//Попытка
							лТаблицаСтруктурТипов = Вычислить(НайденныеСтроки[0].Правило + "(ТаблицаЛокальногоКонтекста, МассивПараметров)");
							ирОбщий.ЗагрузитьВТаблицуЗначенийЛкс(лТаблицаСтруктурТипов, ТаблицаСтруктурТипов); 
							Продолжить;
						//Исключение КонецПопытки;
					КонецЕсли;
				КонецЕсли;
				
				// Ищем предопределенное слово
				Если Истина
					И РодительскаяСтрутураТипа.ИмяОбщегоТипа = "Локальный"
					//И (Ложь
					//	Или ЯзыкПрограммы = 0
					//	Или ЯзыкПрограммы = 2)
				Тогда
					СтруктураКлюча = Новый Структура("НСлово", Нрег(ТекущееСлово));
					Если ТипСлова <> Неопределено Тогда
						СтруктураКлюча.Вставить("ТипСлова", ТипСлова);
					КонецЕсли;
					НайденныеСтроки = ТаблицаЛокальногоКонтекста.НайтиСтроки(СтруктураКлюча);
					Если НайденныеСтроки.Количество() > 0 Тогда
						ирОбщий.ЗагрузитьВТаблицуЗначенийЛкс(НайденныеСтроки[0].ТаблицаСтруктурТипов, ТаблицаСтруктурТипов); 
						Продолжить;
					КонецЕсли;
				КонецЕсли;
				Если ЯзыкПрограммы = 1 Тогда
					ВиртуальнаяТаблица = Новый Структура("Выражение, НомерСтроки");
					ВиртуальнаяТаблица.Выражение = "." + ТекущееСлово;
					Если ЗначениеЗаполнено(ТекущиеАргументы) Тогда
						ВиртуальнаяТаблица.Выражение = ВиртуальнаяТаблица.Выражение + "." + ТекущиеАргументы;
					КонецЕсли;
					ВиртуальнаяТаблица.НомерСтроки = СтрЧислоСтрок(ПредшествующийТекст);
				Иначе
					ВиртуальнаяТаблица = Неопределено;
				КонецЕсли;
				ТаблицаСвойствТипа.Очистить();
				мПлатформа.СвойстваТипаПредопределенные(РодительскаяСтрутураТипа, ТекущееСлово, ТипСлова, ВиртуальнаяТаблица, ЯзыкПрограммы, Конфигурация,,, ТаблицаСвойствТипа);
				Если ТаблицаСвойствТипа.Количество() > 0 Тогда
					МаксКоличествоВариантов = 5;
					КоличествоВариантов = 0;
					Для Каждого СтрокаСлова Из ТаблицаСвойствТипа Цикл
						ирОбщий.ЗагрузитьВТаблицуЗначенийЛкс(СтрокаСлова.ТаблицаСтруктурТипов, ТаблицаСтруктурТипов); 
						КоличествоВариантов = КоличествоВариантов + 1;
						Если КоличествоВариантов >= МаксКоличествоВариантов Тогда
							Прервать;
						КонецЕсли; 
					КонецЦикла;
					Если Истина
						И РодительскаяСтрутураТипа.ИмяОбщегоТипа = "БлокировкаДанных" 
						И ТипСлова = "Метод" 
						И ТекущееСлово = "Добавить" 
					Тогда
						ТаблицаСтруктурТипов.ЗаполнитьЗначения(ирОбщий.СтрокаМеждуМаркерамиЛкс(ТекущиеАргументы, """", """"), "Метаданные");
					КонецЕсли; 
					Продолжить;
				ИначеЕсли Истина
					И ЗначениеЗаполнено(РодительскаяСтрутураТипа.ТипЯзыка) 
					И РодительскаяСтрутураТипа.ИмяОбщегоТипа = "Строка" 
				Тогда 
					ЗаполнитьЗначенияСвойств(ТаблицаСтруктурТипов.Добавить(), РодительскаяСтрутураТипа); 
					Продолжить;
				КонецЕсли;
			Иначе
				//Попытка
				//	Пустышка = Новый Структура(ТекущееСлово);
				//Исключение 
				//	Пустышка = Неопределено;
				//КонецПопытки; 
				//Если Ложь
				//	Или Пустышка = Неопределено
				//	Или НРег(ТекущийИндекс) <> НРег("""" + ТекущееСлово + """") // Противный случай отработается внутри СвойстваТипаМетаданные
				//Тогда
				//	// Это - произвольный элемент коллекции
				//	ДобавитьТипЭлементаКоллекцииВТаблицуСтруктурТипов(РодительскаяСтрутураТипа, СтруктураТипа, ТаблицаСтруктурТипов);
				//	Продолжить;
				//КонецЕсли;
			КонецЕсли;
			
			ТаблицаСвойствТипа.Очистить();
			мПлатформа.СвойстваТипаМетаданные(РодительскаяСтрутураТипа,
				ТекущееСлово, ТипСлова, ВиртуальнаяТаблица, ЯзыкПрограммы, ТекущийИндекс,,, ЛиСерверныйКонтекст, мМодульМетаданных, ТаблицаСвойствТипа);
			Если ТаблицаСвойствТипа.Количество() > 0 Тогда
				Для Каждого СтрокаСлова Из ТаблицаСвойствТипа Цикл
					Если СтрокаСлова.ТаблицаСтруктурТипов <> Неопределено Тогда
						ирОбщий.ЗагрузитьВТаблицуЗначенийЛкс(СтрокаСлова.ТаблицаСтруктурТипов, ТаблицаСтруктурТипов); 
					КонецЕсли; 
				КонецЦикла;
				Продолжить;
			КонецЕсли;
		КонецЕсли;
	КонецЦикла;
	Возврат ТаблицаСтруктурТипов;

КонецФункции

// Определяет тип значения слова в режиме внутреннего языка.
//
// Параметры:
//  ТекстДляПоискаОпределения – Строка - где ищем определение;
//  Контекст     – Строка - последовательность идентификаторов через "." без круглых и квадратных скобок.
//
// Возвращаемое значение:
//  Структура – "ИмяОбщегоТипа", "ПерсональныйТип".
//
Функция ОпределитьТипЗначенияКонтекста(Знач Контекст = "", Знач ТекстДляПоискаОпределения = "", Знач ПредшествующийТекст = "", Знач РазрешитьАнализИмениТипа = Ложь,
	Знач ЭтоВызовКонструктора = Ложь, ПолныйАнализ = Истина) Экспорт
	
	#Если Сервер И Не Сервер Тогда
		мПлатформа = Обработки.ирПлатформа.Создать();
	#КонецЕсли
	ТаблицаСтруктурТипов = мПлатформа.НоваяТаблицаСтруктурТипа();
	СтруктураТипа = мПлатформа.НоваяСтруктураТипа();
	//Если ЗначениеЗаполнено(Конфигурация) Тогда
		СтруктураТипа.Метаданные = Конфигурация;
	//Иначе
	//	СтруктураТипа.Метаданные = мПлатформа.мМетаданные;
	//КонецЕсли; 
	
	Если РазрешитьАнализИмениТипа Тогда
		Если ЯзыкПрограммы = 1 Тогда
			мТолькоСсылочныеИменаТипов = Истина;
			RegExp.Global = Истина;
			RegExp.Pattern = шПредИмя + "(?:ССЫЛКА|REFS)" + шРазделитель + "+$";
			Результат = RegExp.НайтиВхождения(ПредшествующийТекст);
			Если Результат.Количество() > 0 Тогда
				СтруктураТипа.ТипЯзыка = "ИмяТипа";
			КонецЕсли;
			RegExp.Pattern = шПредИмя + "(?:ВЫРАЗИТЬ|CAST)" + шРазделитель + "*\(" + шВыражениеЗапроса + шРазделитель + "+(?:КАК|AS)" + шРазделитель + "+$";
			Результат = RegExp.НайтиВхождения(ПредшествующийТекст);
			Если Результат.Количество() > 0 Тогда
				СтруктураТипа.ТипЯзыка = "ИмяТипа";
				мТолькоСсылочныеИменаТипов = Ложь;
			КонецЕсли;
			RegExp.Pattern = шПредИмя + "(?:ТИП|TYPE)" + шРазделитель + "*\(" + шРазделитель + "*$";
			Результат = RegExp.НайтиВхождения(ПредшествующийТекст);
			Если Результат.Количество() > 0 Тогда
				СтруктураТипа.ТипЯзыка = "ИмяТипа";
				мТолькоСсылочныеИменаТипов = Ложь;
			КонецЕсли;
			RegExp.Pattern = шПредИмя + "(?:ЗНАЧЕНИЕ|VALUE)" + шРазделитель + "*\(" + шРазделитель + "*$";
			Результат = RegExp.НайтиВхождения(ПредшествующийТекст);
			Если Результат.Количество() > 0 Тогда
				СтруктураТипа.ТипЯзыка = "ЗначениеВЗапросе";
			КонецЕсли;
		Иначе
			RegExp.Global = Истина;
			RegExp.Pattern = шПредИмя + "(?:Новый|New)" + шРазделитель + "+$";
			Результат = RegExp.НайтиВхождения(ПредшествующийТекст);
			Если Результат.Количество() > 0 Тогда
				СтруктураТипа.Вставить("Конструктор", Истина);
				СтруктураТипа.ТипЯзыка = "ИмяТипа";
			КонецЕсли;
			RegExp.Pattern = шПредИмя + "(?:Новый|New)" + шРазделитель + "*\(" + шРазделитель + "*""$";
			Результат = RegExp.НайтиВхождения(ПредшествующийТекст);
			Если Результат.Количество() > 0 Тогда
				// Активная следующая строка блокирует недокументированные возможности.
				//СтруктураТипа.Вставить("Конструктор", Истина);
				СтруктураТипа.ТипЯзыка = "ИмяТипа";
			КонецЕсли;
			RegExp.Pattern = шПредИмя + "Тип" + шРазделитель + "*\(" + шРазделитель + "*""$";
			Результат = RegExp.НайтиВхождения(ПредшествующийТекст);
			Если Результат.Количество() > 0 Тогда
				СтруктураТипа.ТипЯзыка = "ИмяТипа";
			КонецЕсли;
			RegExp.Pattern = шПредИмя + "(?:Новый|New)" + шРазделитель + "*ОписаниеТипов\(" + шРазделитель + "*""[^""]*$";
			Результат = RegExp.НайтиВхождения(ПредшествующийТекст);
			Если Результат.Количество() > 0 Тогда
				СтруктураТипа.ТипЯзыка = "ИмяТипа";
			КонецЕсли;
		КонецЕсли;
		Если Ложь
			Или СтруктураТипа.ТипЯзыка = "ИмяТипа"
			Или СтруктураТипа.ТипЯзыка = "ЗначениеВЗапросе"
		Тогда
			СтруктураТипа.ИмяОбщегоТипа = "";
		Иначе
			Если мЭтоСтроковыйЛитерал Тогда
				Результат = ОпределитьТипЗначенияКонтекста(мВызовМетода, ТекстДляПоискаОпределения, ПредшествующийТекст,,, ПолныйАнализ);
				Возврат Результат;
			КонецЕсли; 
		КонецЕсли;
	КонецЕсли; 
	Если Ложь
		Или Контекст = Неопределено
		Или Контекст = ""
	Тогда
		Если СтруктураТипа.ИмяОбщегоТипа = "Неизвестный контекст" Тогда
			СтруктураТипа.ИмяОбщегоТипа = "Локальный";
		КонецЕсли;
	Иначе
		RegExp.Global = Ложь;
		RegExp.Pattern = "(((\.(" + шИмя + "|\?|)" + шСкобки + "?)|" + шИндекс + ")*)" +
			              "((\.(" + шИмя + "|\?|)" + шНачалоСкобок + "?)|" + шИндекс + ")$";
		Результат = RegExp.НайтиВхождения("." + Контекст);
		Если Результат.Количество() > 0 Тогда 
			МассивРодительскихСтрутурТипа = Новый Массив;
			РодительскийКонтекст = Сред(Результат[0].SubMatches(0), 2);
			ТекущееСлово = Результат[0].SubMatches(8);
			ТекущийИндекс = Результат[0].SubMatches(10);
			ТекущиеАргументы = Результат[0].SubMatches(9);
			ТипСлова = "Свойство";
			Если Не ирОбщий.ЛиПустаяПодгруппаRegExpЛкс(ТекущийИндекс) Тогда
				ТекущееСлово = Сред(ТекущийИндекс, 2, СтрДлина(ТекущийИндекс) - 2);
			КонецЕсли;
			Если ЯзыкПрограммы = 1 Тогда
				ТипСлова = Неопределено;
				Если РодительскийКонтекст = "" Тогда
					Если ЗначениеЗаполнено(ТекущееСлово) Тогда
						RegExp.Global = Ложь;
						RegExp.Pattern = СтрЗаменить(шПоискОписанияТаблицы, "#Идентификатор#", ирОбщий.ПреобразоватьТекстДляРегулярныхВыраженийЛкс(ТекущееСлово));
						РезультатТекста = RegExp.НайтиВхождения(ТекстДляПоискаОпределения);
						Если РезультатТекста.Количество() > 0 Тогда
							ПоследнееВхождение = РезультатТекста[0];
							СледРекурсии = МассивЗащитыОтРекурсии.Найти(ПоследнееВхождение.FirstIndex);
							Если СледРекурсии = Неопределено Тогда
								МассивЗащитыОтРекурсии.Добавить(ПоследнееВхождение.FirstIndex);
								ПрисвоенныйКонтекст = ПоследнееВхождение.SubMatches(3);
								Если ПрисвоенныйКонтекст <> Контекст Тогда
									МассивСтруктурПрисвоенныхТипов = ОпределитьТипЗначенияКонтекста(ПрисвоенныйКонтекст, ТекстДляПоискаОпределения,
										Лев(ТекстДляПоискаОпределения, ПоследнееВхождение.FirstIndex - 1), РазрешитьАнализИмениТипа,, ПолныйАнализ);
									ирОбщий.ЗагрузитьВТаблицуЗначенийЛкс(МассивСтруктурПрисвоенныхТипов, ТаблицаСтруктурТипов); 
								КонецЕсли; 
							КонецЕсли;
						КонецЕсли;
					ИначеЕсли ЗначениеЗаполнено(ТекущиеАргументы) Тогда
						ТекущееСлово = ирОбщий.УдалитьВнешниеСкобкиВыраженияЛкс(ТекущиеАргументы);
						Если ирОбщий.СтрНачинаетсяСЛкс(ТекущееСлово, "Выразить(") Тогда
							ТекущиеАргументы = ирОбщий.СтрокаМеждуМаркерамиЛкс(ТекущееСлово, "(", ")", Ложь, Истина);
							ТекущееСлово = "ВЫРАЗИТЬ";
							RegExp.Pattern = шРазделитель + "(?:КАК|AS)" + шРазделитель + "+(" + шИмя + "(?:\." + шИмя + ")*)";
							Результат = RegExp.НайтиВхождения(ТекущиеАргументы);
							Если Результат.Количество() > 0 Тогда
								ИмяТипаВыражения = Результат[Результат.Количество() - 1].Submatches(0);
								Если Найти(ИмяТипаВыражения, ".") > 0 Тогда
									ИмяТипаВыражения = ирОбщий.ИмяТипаИзПолногоИмениМДЛкс(ИмяТипаВыражения);
								КонецЕсли; 
								СтруктураТипа = мПлатформа.СтруктураТипаИзКонкретногоТипа(Тип(ИмяТипаВыражения));
								СтруктураТипа.ИмяОбщегоТипа = СтрЗаменить(СтруктураТипа.ИмяОбщегоТипа, ирОбщий.ПеревестиСтроку("Ссылка") + ".", ".");
								ЗаполнитьЗначенияСвойств(ТаблицаСтруктурТипов.Добавить(), СтруктураТипа); 
							КонецЕсли; 
						КонецЕсли; 
					КонецЕсли; 
				КонецЕсли;
			Иначе
				ТипСлова = "Свойство";
				Если Истина
					И Не ирОбщий.ЛиПустаяПодгруппаRegExpЛкс(ТекущиеАргументы) 
					И Не СтруктураТипа.ТипЯзыка = "ИмяТипа"
				Тогда
					// Это метод или функция
					Если ЭтоВызовКонструктора Тогда
						ТипСлова = "Конструктор";
					Иначе
						ТипСлова = "Метод";
					КонецЕсли; 
				КонецЕсли;
				RegExp.Global = Истина;
				ШаблонКоллекции = "(" + шРазделитель + "+Из" + шРазделитель + "+(" + шИмяСкобки + "?" + шИндекс + "?" + "(\." + шИмяСкобки + "?" + шИндекс + "?)*))";
				RegExp.Pattern = шПредИмя + ирОбщий.ПреобразоватьТекстДляРегулярныхВыраженийЛкс(Контекст) 
					+ "(" + шПрисваивание + "|" + ШаблонКоллекции + ")";
				РезультатТекста = RegExp.НайтиВхождения(ТекстДляПоискаОпределения);
				Если РезультатТекста.Количество() > 0 Тогда
					СтруктураТипа = мПлатформа.НоваяСтруктураТипа();
					ПоследнееВхождение = РезультатТекста[РезультатТекста.Количество() - 1];
					Если Не ирОбщий.ЛиПустаяПодгруппаRegExpЛкс(ПоследнееВхождение.SubMatches(1)) Тогда
						// Это присвоение
						ПрисвоенныйКонтекст = ПоследнееВхождение.SubMatches(2);
						СловоНовый = НРег(ПоследнееВхождение.SubMatches(3));
						Если СловоНовый = Нрег("Новый") Или СловоНовый = Нрег("New") Тогда
							//СтруктураТипа = мПлатформа.НоваяСтруктураТипа();
							
							//Если ПоследнееВхождение.SubMatches(4) <> Неопределено Тогда 
							//	Попытка
							//		ТипНового = Тип(ПоследнееВхождение.SubMatches(4));
							//		СтруктураТипа = мПлатформа.СтруктураТипаИзКонкретногоТипа(ТипНового, ЯзыкПрограммы);
							//	Исключение
							//		СтруктураТипа.ИмяОбщегоТипа = ПоследнееВхождение.SubMatches(4);
							//	КонецПопытки;
							//КонецЕсли;
							//Если ПоследнееВхождение.SubMatches(5) <> Неопределено Тогда
							//	Если ТипНового = Тип("COMОбъект") Тогда
							//		СтруктураТипа.ИмяОбщегоТипа = СтруктураТипа.ИмяОбщегоТипа + "." + ПоследнееВхождение.SubMatches(5);
							//	Иначе
							//		СтруктураТипа.ИмяОбщегоТипа = ПоследнееВхождение.SubMatches(5);
							//	КонецЕсли;
							//КонецЕсли;
							
							Если Не ирОбщий.ЛиПустаяПодгруппаRegExpЛкс(ПоследнееВхождение.SubMatches(4)) Тогда 
								ИмяТипа = ПоследнееВхождение.SubMatches(4);
							ИначеЕсли Не ирОбщий.ЛиПустаяПодгруппаRegExpЛкс(ПоследнееВхождение.SubMatches(5)) Тогда 
								ИмяТипа = ПоследнееВхождение.SubMatches(5);
							Иначе
								ИмяТипа = Неопределено;
							КонецЕсли;
							Если ЗначениеЗаполнено(ИмяТипа) Тогда
								Попытка
									ТипНового = Тип(ИмяТипа);
								Исключение
									ТипНового = Неопределено;
									СтруктураТипа.ИмяОбщегоТипа = ИмяТипа;
								КонецПопытки;
								Если Истина
									И ТипНового = Тип("COMОбъект")
									И Не ирОбщий.ЛиПустаяПодгруппаRegExpЛкс(ПоследнееВхождение.SubMatches(5)) 
								Тогда
									ПолноеИмяОсновногоКлассаCOM = ПоследнееВхождение.SubMatches(5);
									СтруктураКОМТипа = мИменаОбщихТиповПоИменамКлассовCOM[ПолноеИмяОсновногоКлассаCOM];
									Если СтруктураКОМТипа = Неопределено Тогда
										СтруктураКОМТипа = Новый Структура;
										МетаданныеСлова = мПлатформа.ПолучитьОбразецCOMОбъекта(ПолноеИмяОсновногоКлассаCOM); // При этом может открыться форма Automation-сервера например RegexBuddy так делает
										Если МетаданныеСлова = Неопределено Тогда
											ИмяОсновногоКлассаCOM = ирОбщий.ПоследнийФрагментЛкс(ПолноеИмяОсновногоКлассаCOM);
											ИмяОбщегоТипа = ИмяОсновногоКлассаCOM + " {" + ПолноеИмяОсновногоКлассаCOM + "}";
										Иначе
											ИмяОбщегоТипа = мПлатформа.ПолноеИмяТипаCOMОбъекта(МетаданныеСлова);
											Если ирОбщий.СтрокиРавныЛкс(ИмяОбщегоТипа, "COMОбъект") Тогда
												ИмяОсновногоКлассаCOM = ирОбщий.ПоследнийФрагментЛкс(ПолноеИмяОсновногоКлассаCOM);
												ИмяОбщегоТипа = ИмяОсновногоКлассаCOM + " {" + ПолноеИмяОсновногоКлассаCOM + "}";
											КонецЕсли; 
											СтруктураКОМТипа.Вставить("Метаданные", МетаданныеСлова);
										КонецЕсли; 
										СтруктураКОМТипа.Вставить("ИмяОбщегоТипа", ИмяОбщегоТипа); 
										мИменаОбщихТиповПоИменамКлассовCOM[ПолноеИмяОсновногоКлассаCOM] = СтруктураКОМТипа;
									КонецЕсли; 
									ЗаполнитьЗначенияСвойств(СтруктураТипа, СтруктураКОМТипа); 
								ИначеЕсли ТипНового <> Неопределено Тогда
									СтруктураТипа = мПлатформа.СтруктураТипаИзКонкретногоТипа(ТипНового, ЯзыкПрограммы);
								КонецЕсли;
							КонецЕсли; 
							мПлатформа.ДобавитьВТаблицуСтруктурТипов(ТаблицаСтруктурТипов, СтруктураТипа);
						ИначеЕсли Не ирОбщий.ЛиПустаяПодгруппаRegExpЛкс(ПоследнееВхождение.SubMatches(6)) Тогда 
							ТаблицаСтруктурТипов = ОпределитьТипЗначенияКонтекста(ПрисвоенныйКонтекст, Лев(ТекстДляПоискаОпределения, ПоследнееВхождение.FirstIndex - 1),
								Лев(ТекстДляПоискаОпределения, ПоследнееВхождение.FirstIndex - 1), РазрешитьАнализИмениТипа,, ПолныйАнализ);
							Для Каждого СтруктураТипа Из ТаблицаСтруктурТипов Цикл
								СтруктураКлюча = Новый Структура("Слово, ЯзыкПрограммы", СтруктураТипа.ИмяОбщегоТипа, ЯзыкПрограммы);
								СтруктураТипа.СтрокаОписания = Неопределено;
								
								// Было закомментировано
								//НайденныеСтроки = мПлатформа.ТаблицаОбщихТипов.НайтиСтроки(СтруктураКлюча);
								//Если НайденныеСтроки.Количество() > 0 Тогда
								//	СтруктураТипа.СтрокаОписания = НайденныеСтроки[0];
								//КонецЕсли;
							КонецЦикла;
						Иначе
							// **** TODO Сделать определение примитивного типа
							СтруктураТипа.ИмяОбщегоТипа = "Примитивный";
							мПлатформа.ДобавитьВТаблицуСтруктурТипов(ТаблицаСтруктурТипов, СтруктураТипа);
						КонецЕсли;
					Иначе
						// Это обход коллекции
						ПрисвоенныйКонтекст = ПоследнееВхождение.SubMatches(15);
						// **** Раньше текст для поиска определения передавался неизменным. Тестовый режим
						ТаблицаСтруктурТиповКоллекции = ОпределитьТипЗначенияКонтекста(ПрисвоенныйКонтекст, Лев(ТекстДляПоискаОпределения, ПоследнееВхождение.FirstIndex - 1),
							Лев(ТекстДляПоискаОпределения, ПоследнееВхождение.FirstIndex - 1),,, ПолныйАнализ);
								
						//// Структура типов коллекции всегда имеет ровно один элемент
						//СтруктураКлюча = Новый Структура("Слово, ЯзыкПрограммы", СтруктураТипаКоллекции.ИмяОбщегоТипа, ЯзыкПрограммы);
						//НайденныеСтроки = мПлатформа.ТаблицаОбщихТипов.НайтиСтроки(СтруктураКлюча);
						//Если НайденныеСтроки.Количество() > 0 Тогда
						//	БазовыеТипы = ирОбщий.СтрРазделитьЛкс(НайденныеСтроки[0].ТипЭлементаКоллекции, ",", Истина);
						//	Для Каждого БазовыйТип Из БазовыеТипы Цикл
						//		СтруктураКлюча = Новый Структура("БазовыйТип, ЯзыкПрограммы", БазовыйТип, ЯзыкПрограммы);
						//		НайденныеСтроки = мПлатформа.ТаблицаОбщихТипов.НайтиСтроки(СтруктураКлюча);
						//		Если НайденныеСтроки.Количество() > 0 Тогда
						//			СтруктураТипа.СтрокаОписания = НайденныеСтроки[0];
						//			СтруктураТипа.ИмяОбщегоТипа  = НайденныеСтроки[0].Слово;
						//			СтруктураТипа.Метаданные = СтруктураТипаКоллекции.Метаданные;
						//		КонецЕсли;
						//		мПлатформа.ДобавитьВТаблицуСтруктурТипов(ТаблицаСтруктурТипов, СтруктураТипа);
						//	КонецЦикла;
						//Иначе
						//	мПлатформа.ДобавитьВТаблицуСтруктурТипов(ТаблицаСтруктурТипов, СтруктураТипа);
						//КонецЕсли;
						ДобавитьТипЭлементаКоллекцииВТаблицуСтруктурТипов(ТаблицаСтруктурТиповКоллекции[0], СтруктураТипа, ТаблицаСтруктурТипов);
					КонецЕсли;
					Если Не ирОбщий.ЛиПустаяПодгруппаRegExpЛкс(ТекущийИндекс) Тогда
						МассивРодительскихСтрутурТипа = ТаблицаСтруктурТипов;
						ТаблицаСтруктурТипов = мПлатформа.НоваяТаблицаСтруктурТипа();
					КонецЕсли;
				КонецЕсли;
			КонецЕсли;
			Если МассивРодительскихСтрутурТипа.Количество() = 0 Тогда
				МассивРодительскихСтрутурТипа = ОпределитьТипЗначенияКонтекста(РодительскийКонтекст, ТекстДляПоискаОпределения, ПредшествующийТекст, РазрешитьАнализИмениТипа,, ПолныйАнализ);
			КонецЕсли;
			МассивДочернихСтруктурТипа = ОпределитьТипДочернегоКонтекста(МассивРодительскихСтрутурТипа, ТекущееСлово, ТипСлова, ТекущийИндекс, ТекущиеАргументы, ПредшествующийТекст, ПолныйАнализ);
			ирОбщий.ЗагрузитьВТаблицуЗначенийЛкс(МассивДочернихСтруктурТипа, ТаблицаСтруктурТипов); 
			Если ТипСлова = "Свойство" И Не СтруктураТипа.Конструктор Тогда
				ТекстДляЗаполненияМетаданных = ТекстДляПоискаОпределения;
				Для Каждого СтруктураТипаЦикл Из ТаблицаСтруктурТипов Цикл
					Если Ложь
						Или СтруктураТипаЦикл.ИмяОбщегоТипа = "Структура"
						Или СтруктураТипаЦикл.ИмяОбщегоТипа = "ФиксированнаяСтруктура"
					Тогда
						RegExp.Global = Ложь;
						ШаблонКонструкторСоСвойствами = Контекст + "\s*=\s*Новый\s+Структура\s*\(\s*""((?:" + шИмя + "\s*,\s*)*" + шИмя + ")""";
						RegExp.Pattern = ШаблонКонструкторСоСвойствами;
						РезультатСвойств = RegExp.НайтиВхождения(ТекстДляЗаполненияМетаданных);
						Если РезультатСвойств.Количество() > 0 Тогда
							СтруктураТипаЦикл.Метаданные = Новый Структура(РезультатСвойств[0].SubMatches(0));
						ИначеЕсли Истина
							И ТипЗнч(СтруктураТипаЦикл.Метаданные) <> Тип("Структура") 
							И ТипЗнч(СтруктураТипаЦикл.Метаданные) <> Тип("ФиксированнаяСтруктура") 
						Тогда
							СтруктураТипаЦикл.Метаданные = Новый Структура;
						КонецЕсли;
						ШаблонУстановкаТекста = Контекст + "\s*\.\s*Вставить\s*\(\s*""(" + шИмя + ")""";
						RegExp.Pattern = ШаблонУстановкаТекста;
						RegExp.Global = Истина;
						РезультатСвойств = RegExp.НайтиВхождения(ТекстДляЗаполненияМетаданных);
						Для Каждого ВхождениеСвойства Из РезультатСвойств Цикл
							СтруктураТипаЦикл.Метаданные.Вставить(ВхождениеСвойства.SubMatches(0));
						КонецЦикла;
					ИначеЕсли Ложь
						Или СтруктураТипаЦикл.ИмяОбщегоТипа = "ТаблицаЗначений"
						Или СтруктураТипаЦикл.ИмяОбщегоТипа = "ДеревоЗначений"
					Тогда
						RegExp.Global = Ложь;
						Если Истина
							И ТипЗнч(СтруктураТипаЦикл.Метаданные) <> Тип("ДеревоЗначений") 
							И ТипЗнч(СтруктураТипаЦикл.Метаданные) <> Тип("ТаблицаЗначений")
						Тогда
							СтруктураТипаЦикл.Метаданные = Новый ТаблицаЗначений;
						КонецЕсли;
						ШаблонУстановкаТекста = Контекст + "\s*\.\s*Колонки\s*.\s*Добавить\s*\(\s*""(" + шИмя + ")""";
						RegExp.Pattern = ШаблонУстановкаТекста;
						RegExp.Global = Истина;
						РезультатСвойств = RegExp.НайтиВхождения(ТекстДляЗаполненияМетаданных);
						Колонки = СтруктураТипаЦикл.Метаданные.Колонки;
						Для Каждого ВхождениеСвойства Из РезультатСвойств Цикл
							ИмяКолонки = ВхождениеСвойства.SubMatches(0);
							Попытка
								Колонки.Добавить(ИмяКолонки);
							Исключение
								Пустышка = 0;
							КонецПопытки; 
						КонецЦикла;
					ИначеЕсли Ложь
						Или СтруктураТипаЦикл.ИмяОбщегоТипа = "Запрос"
						Или СтруктураТипаЦикл.ИмяОбщегоТипа = "ПостроительЗапроса"
						Или СтруктураТипаЦикл.ИмяОбщегоТипа = "ПостроительОтчета"
					Тогда
						RegExp.Global = Ложь;
						ШаблонУстановкаТекста = Контекст + "\s*\.\s*Текст\s*=\s*(" + шСтрокаПрограммы + ")";
						RegExp.Pattern = ШаблонУстановкаТекста;
						RegExp.Global = Истина;
						РезультатСвойств = RegExp.НайтиВхождения(ТекстДляЗаполненияМетаданных);
						Для Каждого ВхождениеСвойства Из РезультатСвойств Цикл
							ПрисвоенноеЗначение = ВхождениеСвойства.SubMatches(0);
							Если Лев(ПрисвоенноеЗначение, 1) = """" Тогда
								Попытка
									ТекстЗапроса = Вычислить(ПрисвоенноеЗначение);
									Прервать;
								Исключение
									ТекстЗапроса = "";
								КонецПопытки;
							КонецЕсли;
						КонецЦикла;
						Если ЗначениеЗаполнено(ТекстЗапроса) Тогда
							ПостроительЗапроса = Новый ПостроительЗапроса;
							Попытка
								ПостроительЗапроса.Текст = ТекстЗапроса;
								ПостроительЗапроса.ЗаполнитьНастройки();
							Исключение
								ПостроительЗапроса = Неопределено;
							КонецПопытки; 
							Если ПостроительЗапроса <> Неопределено Тогда
								СтруктураТипаЦикл.Метаданные = ПостроительЗапроса;
							КонецЕсли; 
						КонецЕсли; 
					КонецЕсли; 
				КонецЦикла;
			КонецЕсли; 
			Если Истина 
				И ЯзыкПрограммы = 1
				И РодительскийКонтекст = ""
				И СтруктураТипа.ИмяОбщегоТипа = "Неизвестный контекст"
				И ТипЗнч(КонтекстВыполнения) = Тип("Запрос")
			Тогда
				ВременныйЗапрос = Новый Запрос;
				ВременныйЗапрос.МенеджерВременныхТаблиц = КонтекстВыполнения.МенеджерВременныхТаблиц;
				ВременныйЗапрос.Текст = "ВЫБРАТЬ * ИЗ " + ТекущееСлово + " ГДЕ ЛОЖЬ";
				Попытка
					// Активное вычисление!
					СтруктураТипа.Метаданные = ВременныйЗапрос.Выполнить();
					СтруктураТипа.ИмяОбщегоТипа = "ВременнаяТаблица";
					СтруктураТипа.ВиртуальнаяТаблица.Выражение = ТекущееСлово; // Используем не по назначению
				Исключение
				КонецПопытки;
			КонецЕсли;
		КонецЕсли; 
	КонецЕсли;
	Если ТаблицаСтруктурТипов.Количество() = 0 Тогда
		мПлатформа.ДобавитьВТаблицуСтруктурТипов(ТаблицаСтруктурТипов, СтруктураТипа);
	КонецЕсли;
	Возврат ТаблицаСтруктурТипов;

КонецФункции

Процедура ОбновитьКонтекстВыраженияЗапросаПоНастройкеКомпоновкиЛкс(НастройкаКомпоновки) Экспорт 
	
	#Если Сервер И Не Сервер Тогда
		НастройкаКомпоновки = Новый НастройкиКомпоновкиДанных;
	#КонецЕсли
	ОчиститьТаблицуСловЛокальногоКонтекста();
	Для Каждого ДоступноеПоле Из НастройкаКомпоновки.ДоступныеПоляОтбора.Элементы Цикл
		НрегПервыйФрагмент = ирОбщий.ПервыйФрагментЛкс(НРег(ДоступноеПоле.Поле));
		Если НрегПервыйФрагмент = НРег("ПараметрыДанных") Тогда
			Для Каждого ДоступныйПараметр Из ДоступноеПоле.Элементы Цикл
				ИмяСвойства = мПараметрыДиалектаSQL.ПрефиксПараметра + ирОбщий.ПоследнийФрагментЛкс(ДоступныйПараметр.Поле);
				ДобавитьСловоЛокальногоКонтекста(ИмяСвойства, "Свойство", , ДоступныйПараметр,,,, "СтрокаТаблицы"); // Виртуальный тип
			КонецЦикла; 
		Иначе
			ДобавитьСловоЛокальногоКонтекста("" + ДоступноеПоле.Поле, "Свойство",, ДоступноеПоле,,,, "СтрокаТаблицы"); // Виртуальный тип
		КонецЕсли; 
	КонецЦикла;

КонецПроцедуры

Процедура УстановитьПризнакМодифицированностиФормы()

	Если ПолеТекста.ЭлементФормы.ИзменяетДанные Тогда
		ФормаВладелец.Модифицированность = Истина;
	КонецЕсли; 

КонецПроцедуры

Функция ПолучитьСтруктуруТипаСправаОтРавно() Экспорт 
	
	КончитьОбработкуКоманды();
	ТаблицаСтруктурТипов = ТаблицаСтруктурТиповТекущегоВыражения(Истина);
	КончитьОбработкуКоманды();
	СписокТиповКонтекста = Новый СписокЗначений;
	МассивДляПроверкиДублей = Новый Массив;
	Для Каждого СтруктураТипаКонтекста Из ТаблицаСтруктурТипов Цикл
		ИмяОбщегоТипа = СтруктураТипаКонтекста.ИмяОбщегоТипа;
		Если Ложь
			Или Не мПлатформа.ЭтоАгрегатныйОбщийТип(ИмяОбщегоТипа, ЯзыкПрограммы) 
			Или ТипЗнч(СтруктураТипаКонтекста.Метаданные) <> Тип("ОбъектМетаданных")
			Или (Истина
				И ЯзыкПрограммы = 0
				И Найти(ИмяОбщегоТипа, "Ссылка.") = 0)
		Тогда 
			Продолжить;
		КонецЕсли;
		ПредставлениеКонкретногоТипа = "";
		ПредставлениеКонкретногоТипа = ПредставлениеКонкретногоТипа + мПлатформа.ИмяТипаИзСтруктурыТипа(СтруктураТипаКонтекста);
		Если МассивДляПроверкиДублей.Найти(ПредставлениеКонкретногоТипа) = Неопределено Тогда
			СписокТиповКонтекста.Добавить(СтруктураТипаКонтекста, ПредставлениеКонкретногоТипа);
			МассивДляПроверкиДублей.Добавить(ПредставлениеКонкретногоТипа);
		КонецЕсли;
	КонецЦикла;
	Если СписокТиповКонтекста.Количество() > 0 Тогда
		Ответ = Вопрос("Хотите использовать предсказанные равенством метаданные?", РежимДиалогаВопрос.ДаНет);
		Если Ответ = КодВозвратаДиалога.Нет Тогда
			Возврат Неопределено;
		КонецЕсли;
	КонецЕсли; 
	Если СписокТиповКонтекста.Количество() = 1 Тогда 
		ВыбраннаяСтруктураТипа = СписокТиповКонтекста[0].Значение;
		КонкретныйТип = СписокТиповКонтекста[0].Представление;
	ИначеЕсли СписокТиповКонтекста.Количество() > 1 Тогда
		СписокТиповКонтекста.СортироватьПоПредставлению();
		ВыбранныйТип = СписокТиповКонтекста.ВыбратьЭлемент("Выберите тип контекста");
		Если ВыбранныйТип <> Неопределено Тогда
			ВыбраннаяСтруктураТипа = ВыбранныйТип.Значение;
			КонкретныйТип = ВыбранныйТип.Представление;
		КонецЕсли;
	КонецЕсли;
	//Если ВыбраннаяСтруктураТипа <> Неопределено Тогда
	//	СтруктураТипаКонтекста = мПлатформа.НоваяСтруктураТипа();
	//	ЗаполнитьЗначенияСвойств(СтруктураТипаКонтекста, ВыбраннаяСтруктураТипа);
	//КонецЕсли;
	Возврат ВыбраннаяСтруктураТипа;

КонецФункции//ПолучитьСтруктуруТипаСправоОтРавно

Функция ТаблицаСтруктурТиповТекущегоВыражения(ЛиСправаОтРавенства = Ложь, БезКонструкторов = Ложь, ПолныйАнализ = Истина) Экспорт

	РазобратьТекущийКонтекст(ЛиСправаОтРавенства);
	лКонтекст = ?(ЛиСправаОтРавенства, мКонтекст, мРодительскийКонтекст);
	МассивЗащитыОтРекурсии.Очистить();
	Попытка
		ТаблицаСтруктурТиповКонтекста = ОпределитьТипЗначенияКонтекста(лКонтекст, " " + мТекстДляПоискаОпределения, мПредшествующийТекст, Истина,, ПолныйАнализ);
	Исключение
		Ошибка = ИнформацияОбОшибке();
		Если Ошибка.Описание = "ОшибкаВычисленияВиртуальнойТаблицы" Тогда 
			Возврат Новый ТаблицаЗначений;
		КонецЕсли;
		ВызватьИсключение;
	КонецПопытки;
	Если БезКонструкторов Тогда
		Для Каждого СтрокаТаблицы Из ТаблицаСтруктурТиповКонтекста.НайтиСтроки(Новый Структура("Конструктор", Истина)) Цикл
			ТаблицаСтруктурТиповКонтекста.Удалить(СтрокаТаблицы);
		КонецЦикла;
	КонецЕсли; 
    Возврат ТаблицаСтруктурТиповКонтекста;
	
КонецФункции

Функция ПодготовитьИмяПараметраМетода(ИмяПараметра) Экспорт 
	
	//ирОбщий.ДекодироватьТекстИзXMLЛкс(СтрокаПараметра.Параметр);
	ИмяПараметра = СтрЗаменить(ИмяПараметра, "&gt;", "");
	ИмяПараметра = СтрЗаменить(ИмяПараметра, "&lt;", "");
	Возврат ИмяПараметра;

КонецФункции

// Вызывает контекстную подсказку в текстовом поле.
//
// Параметры:
//  Нет.
//
Процедура ОткрытьАвтодополнение(КодКлавиши = "")
	
	Если ирОбщий.ПроверитьПлатформаНеWindowsЛкс(,, Истина) Тогда 
		Возврат;
	КонецЕсли; 
	#Если Сервер И Не Сервер Тогда
		мПлатформа = Обработки.ирПлатформа.Создать();
	#КонецЕсли
	Если Ложь
		Или ПолеТекста.ТолькоПросмотр()
		Или ФормаВладелец.ТолькоПросмотр
	Тогда
		Возврат;
	КонецЕсли;
	Если Истина
		//И Найти(КодКлавиши, "04128") = 1 // CTRL+SPACE
		И КодКлавиши = "" // Вызов из обработчика нажатия кнопки
		И ТипЗнч(ПолеТекста.ЭлементФормы) = Тип("ПолеHTMLДокумента")
		И ирКэш.НомерВерсииПлатформыЛкс() <= 803016
	Тогда
		// https://github.com/salexdv/bsl_console/issues/124
		ПолеТекста.РедакторHTML().triggerSuggestions();
		Возврат;
	КонецЕсли; 
	
	//Если Истина
	//	И ЯзыкПрограммы = 1
	//	И Не мДоступныеТаблицыПолучены 
	//Тогда
	//	Если ирОбщий.СтрокиРавныЛкс(мДиалектSQL, "1С") Тогда
	//	ИначеЕсли ирОбщий.СтрокиРавныЛкс(мДиалектSQL, "WQL") Тогда
	//	Иначе
	//		ЗаполнитьДоступныеТаблицыADO();
	//		Для Каждого СтрокаДоступнойТаблицы Из ДоступныеТаблицы Цикл
	//			ДобавитьСловоЛокальногоКонтекста(СтрокаДоступнойТаблицы.Имя,,,, Истина,,, "ВременнаяТаблица");
	//		КонецЦикла; 
	//	КонецЕсли; 
	//КонецЕсли; 
	КонкретныйТип = Неопределено;
	СтруктураТипаКонтекста = Неопределено;
	ТаблицаСтруктурТиповКонтекста = Неопределено;
	Пока Истина Цикл
		Успешно = ЗаполнитьТаблицуСлов(ТаблицаСтруктурТиповКонтекста, КонкретныйТип, СтруктураТипаКонтекста);
		Если Не Успешно Тогда
			Возврат;
		КонецЕсли;
		Если Истина
			И ТаблицаСлов.Количество() = 0
			И Не ирОбщий.ВосстановитьЗначениеЛкс(ИмяКласса + ".ЛиОткрыватьПустойСписок") = Истина
		Тогда
			Возврат;
		КонецЕсли;
		ТаблицаСлов.Сортировать("НСлово, ТипСлова, Определение, ТипЗначения, Частота");
		КлючПоискаСтатистики = Новый Структура("ЯзыкПрограммы, ТипКонтекста", ЯзыкПрограммы, КонкретныйТип);
		НайденныеСтроки = мПлатформа.ТаблицаСтатистикиВыбора.НайтиСтроки(КлючПоискаСтатистики);
		ТаблицаСловТЗ = ТаблицаСлов.Выгрузить(, "НСлово, Рейтинг");
		ТаблицаСловТЗ.Индексы.Добавить("НСлово");
		Для Каждого СтрокаРейтинга Из НайденныеСтроки Цикл
			СтрокаСлова = ТаблицаСловТЗ.Найти(НРег(СтрокаРейтинга.Слово), "НСлово");
			Если СтрокаСлова <> Неопределено Тогда
				СтрокаСлова.Рейтинг = СтрокаРейтинга.Рейтинг;
			КонецЕсли;
		КонецЦикла;
		ТаблицаСлов.ЗагрузитьКолонку(ТаблицаСловТЗ.ВыгрузитьКолонку("Рейтинг"), "Рейтинг");
		Если мФормаАвтодополнение = Неопределено Тогда
			Если Ложь
				Или Не ирКэш.ЛиПлатформаWindowsЛкс()
				Или ирОбщий.ЛиПерехватКлавиатурногоВводаЛкс() 
			Тогда
				ИмяФормы = "Автодополнение";
			Иначе
				ИмяФормы = "АвтодополнениеCOM";
			КонецЕсли; 
			мФормаАвтодополнение = ПолучитьФорму(ИмяФормы, ФормаВладелец);
			мФормаАвтодополнение.КлючСохраненияПоложенияОкна = ЯзыкПрограммы;
		КонецЕсли; 
		Попытка
			мФормаАвтодополнение.СтруктураТипаКонтекста = СтруктураТипаКонтекста;
		Исключение
			ВызватьИсключение "Экземпляр формы автодополнения контекстной подсказки сломан ошибкой платформы. Переоткройте форму чтобы восстановить ее работу";
		КонецПопытки;
		Если ЗначениеЗаполнено(СтруктураТипаКонтекста.ТипЯзыка) Тогда
			мФормаАвтодополнение.Контекст = СтруктураТипаКонтекста.ТипЯзыка;
		Иначе
			мФормаАвтодополнение.Контекст = мРодительскийКонтекст;
		КонецЕсли; 
		мФормаАвтодополнение.ТекущееСлово = НачалоСлова;
		мФормаАвтодополнение.ЗапомнитьПозициюКаретки();
		ФормаВладелец.Активизировать(); 
		//ирОбщий.Форма_АктивироватьОткрытьЛкс(ФормаВладелец); // https://www.hostedredmine.com/issues/911214
		ПараметрЗакрытияПодсказки = мФормаАвтодополнение.ОткрытьМодально();
		Если ПараметрЗакрытияПодсказки = Неопределено Тогда
			Возврат;
		КонецЕсли; 
		СтрокаРезультата = мФормаАвтодополнение.СтрокаСловаРезультата;
		Если СтрокаРезультата = Неопределено Тогда
			Возврат;
		КонецЕсли;
		ВставитьВыбранноеСловоАвтодополнения(СтрокаРезультата, КонкретныйТип, СтруктураТипаКонтекста, ТаблицаСтруктурТиповКонтекста, ПараметрЗакрытияПодсказки);
	КонецЦикла;

КонецПроцедуры

Функция ЗаполнитьТаблицуСлов(ТаблицаСтруктурТиповКонтекста = Неопределено, выхКонкретныйТип = Неопределено, выхСтруктураТипаКонтекста = Неопределено, РазрешитьОткрытиеОкон = Истина) Экспорт
	
	ВычислятьТипы = ПоказыватьВсеТипыВСпискеАвтодополненияHTML();
	RegExp.Global = Истина;
	ТаблицаСтатистикиВыбора = мПлатформа.ТаблицаСтатистикиВыбора;
	#Если Сервер И Не Сервер Тогда
		ТаблицаСтатистикиВыбора = Новый ТаблицаЗначений;
		мПлатформа = Обработки.ирПлатформа.Создать();
	#КонецЕсли
	Если ТаблицаСтруктурТиповКонтекста = Неопределено Тогда
		ТаблицаСтруктурТиповКонтекста = ТаблицаСтруктурТиповТекущегоВыражения();
	КонецЕсли; 
	Если ТаблицаСтруктурТиповКонтекста.Количество() = 0 Тогда
		Возврат Ложь;
	КонецЕсли; 
	ТаблицаСлов.Очистить();
	Если мЭтоСтроковыйЛитерал Тогда
		ВыбраннаяСтруктураТипа = ТаблицаСтруктурТиповКонтекста[0];
	Иначе
		СписокТиповКонтекста = Новый СписокЗначений;
		СоответствиеСтруктурТипов = Новый Соответствие;
		МассивДляПроверкиДублей = Новый Массив;
		Для Каждого СтруктураТипаКонтекста Из ТаблицаСтруктурТиповКонтекста Цикл
			ИмяОбщегоТипа = СтруктураТипаКонтекста.ИмяОбщегоТипа;
			Если Истина
				И Не ЗначениеЗаполнено(СтруктураТипаКонтекста.ТипЯзыка) 
				И Не мПлатформа.ЭтоАгрегатныйОбщийТип(ИмяОбщегоТипа, ЯзыкПрограммы) 
			Тогда 
				Продолжить;
			КонецЕсли;
			ПредставлениеКонкретногоТипа = "";
			//Если СтруктураТипаКонтекста.СтрокаОписания <> Неопределено Тогда
			//	// Наверное логичнее было бы из ОпределитьТипЗначенияКонтекста ее получать
			//	РодительскаяСтруктураТипа = мПлатформа.НоваяСтруктураТипа();
			//	Если СтруктураТипаКонтекста.СтрокаОписания.Владелец().Колонки.Найти("ТипКонтекста") <> Неопределено Тогда
			//		ЗаполнитьЗначенияСвойств(РодительскаяСтруктураТипа, СтруктураТипаКонтекста);
			//		РодительскаяСтруктураТипа.ИмяОбщегоТипа = СтруктураТипаКонтекста.СтрокаОписания.ТипКонтекста;
			//	КонецЕсли;
			//	ПредставлениеКонкретногоТипа = ПредставлениеКонкретногоТипа 
			//		+ мПлатформа.ИмяТипаИзСтруктурыТипа(РодительскаяСтруктураТипа) + " / ";
			//КонецЕсли;
			ПредставлениеКонкретногоТипа = ПредставлениеКонкретногоТипа + мПлатформа.ИмяТипаИзСтруктурыТипа(СтруктураТипаКонтекста);
			Если МассивДляПроверкиДублей.Найти(ПредставлениеКонкретногоТипа) = Неопределено Тогда
				СписокТиповКонтекста.Добавить(ПредставлениеКонкретногоТипа, ПредставлениеКонкретногоТипа);
				МассивДляПроверкиДублей.Добавить(ПредставлениеКонкретногоТипа);
			КонецЕсли;
			МассивСтруктурТипа = СоответствиеСтруктурТипов[ПредставлениеКонкретногоТипа];
			Если МассивСтруктурТипа = Неопределено Тогда
				МассивСтруктурТипа = Новый Массив;
			КонецЕсли; 
			МассивСтруктурТипа.Добавить(СтруктураТипаКонтекста);
			СоответствиеСтруктурТипов[ПредставлениеКонкретногоТипа] = МассивСтруктурТипа;
		КонецЦикла;
		Если СписокТиповКонтекста.Количество() = 0 Тогда 
			ВыбраннаяСтруктураТипа = ТаблицаСтруктурТиповКонтекста[0];
			выхКонкретныйТип = мПлатформа.ИмяТипаИзСтруктурыТипа(СтруктураТипаКонтекста);
		Иначе
			ВыбраннаяСтруктураТипа = Неопределено;
			Если СписокТиповКонтекста.Количество() > 1 Тогда
				Если Не РазрешитьОткрытиеОкон Тогда
					Возврат Ложь;
				КонецЕсли; 
				СписокТиповКонтекста.СортироватьПоПредставлению();
				НачальныйВыбор = Неопределено;
				КлючПоискаСтатистики = Новый Структура("ЯзыкПрограммы, ТипКонтекста", ЯзыкПрограммы, "<Выбор типа>");
				ВыбранныеРанееТипы = ТаблицаСтатистикиВыбора.Скопировать(КлючПоискаСтатистики);
				ВыбранныеРанееТипы.Сортировать("Рейтинг Убыв");
				Для Каждого СтрокаТипа Из ВыбранныеРанееТипы Цикл
					Для Каждого ЭлементСписка Из СписокТиповКонтекста Цикл
						Если СтрокаТипа.Слово = ЭлементСписка.Представление Тогда
							НачальныйВыбор = ЭлементСписка;
							Прервать;
						КонецЕсли; 
					КонецЦикла;
					Если НачальныйВыбор <> Неопределено Тогда
						Прервать;
					КонецЕсли; 
				КонецЦикла;
				ВыбранныйЭлементСписка = СписокТиповКонтекста.ВыбратьЭлемент("Выберите тип контекста", НачальныйВыбор);
				Если ВыбранныйЭлементСписка = Неопределено Тогда
					Возврат Ложь;
				КонецЕсли;
				выхКонкретныйТип = ВыбранныйЭлементСписка.Представление;
				// Обновим статистику выбора
				КлючПоискаСтатистики.Вставить("Слово", выхКонкретныйТип);
				НайденныеСтроки = ТаблицаСтатистикиВыбора.НайтиСтроки(КлючПоискаСтатистики);
				Если НайденныеСтроки.Количество() > 0 Тогда
					СтрокаСтатистикиВыбора = НайденныеСтроки[0];
				Иначе
					СтрокаСтатистикиВыбора = ТаблицаСтатистикиВыбора.Добавить();
					ЗаполнитьЗначенияСвойств(СтрокаСтатистикиВыбора, КлючПоискаСтатистики);
				КонецЕсли;
				СтрокаСтатистикиВыбора.Рейтинг = СтрокаСтатистикиВыбора.Рейтинг + 1;
			Иначе 
				ВыбранныйЭлементСписка = СписокТиповКонтекста[0];
				выхКонкретныйТип = ВыбранныйЭлементСписка.Представление;
			КонецЕсли;
			МассивСтруктурТипа = СоответствиеСтруктурТипов[выхКонкретныйТип];
			Для Каждого СтруктураТипа Из МассивСтруктурТипа Цикл
				Если Ложь
					Или ВыбраннаяСтруктураТипа = Неопределено 
					Или ТипЗнч(ВыбраннаяСтруктураТипа.Метаданные) = Тип("ОбъектМетаданныхКонфигурация")
				Тогда
					ВыбраннаяСтруктураТипа = СтруктураТипа;
				КонецЕсли; 
			КонецЦикла;
		КонецЕсли; 
	КонецЕсли; 
	выхСтруктураТипаКонтекста = мПлатформа.НоваяСтруктураТипа();
	Если ВыбраннаяСтруктураТипа.ТипЯзыка <> "ИмяТипа" И мЭтоСтроковыйЛитерал Тогда 
		// Находимся внутри строкового литерала на позиции параметра
		КоллекцияЭлементовМД = Новый Массив;
		Если Истина
			И ВыбраннаяСтруктураТипа.СтрокаОписания <> Неопределено 
			И ВыбраннаяСтруктураТипа.СтрокаОписания.Владелец().Колонки.Найти("ЛиЭкспорт") = Неопределено
		Тогда 
			ИмяПараметра = "";
			Отбор = Новый Структура;
			Отбор.Вставить("ТипКонтекста", ВыбраннаяСтруктураТипа.СтрокаОписания.ТипКонтекста);
			Отбор.Вставить("Слово", мИмяМетода);
			Отбор.Вставить("ЯзыкПрограммы", ЯзыкПрограммы);
			СтрокиПараметров = мПлатформа.ТаблицаПараметров.Скопировать(Отбор);
			СтрокиПараметров = СтрокиПараметров.НайтиСтроки(Новый Структура("Номер", мНомерПараметра));
			Для Каждого СтрокаПараметра Из СтрокиПараметров Цикл
				Если Найти(СтрокаПараметра.ТипЗначения, "Строка") > 0 Тогда
					ИмяПараметра = ПодготовитьИмяПараметраМетода(СтрокаПараметра.Параметр);
					Прервать;
				КонецЕсли; 
			КонецЦикла;
			
			// Имена свойств
			Если Ложь
				Или ТипЗнч(ВыбраннаяСтруктураТипа.Метаданные) = Тип("ТаблицаЗначений")
				Или ТипЗнч(ВыбраннаяСтруктураТипа.Метаданные) = Тип("ДеревоЗначений")
				Или ТипЗнч(ВыбраннаяСтруктураТипа.Метаданные) = Тип("РезультатЗапроса") 
			Тогда
				КоллекцияЭлементовМД = ВыбраннаяСтруктураТипа.Метаданные.Колонки;
			ИначеЕсли ТипЗнч(ВыбраннаяСтруктураТипа.Метаданные) = Тип("ОбъектМетаданных") Тогда 
				Если ИмяПараметра = "Макет" Тогда
					КоллекцияЭлементовМД = ВыбраннаяСтруктураТипа.Метаданные.Макеты;
				ИначеЕсли ИмяПараметра = "Форма" Тогда
					КоллекцияЭлементовМД = ВыбраннаяСтруктураТипа.Метаданные.Формы;
				Иначе
					ИмяТаблицыБД = ирКэш.ИмяТаблицыИзМетаданныхЛкс(ВыбраннаяСтруктураТипа.Метаданные.ПолноеИмя());
					Если ЗначениеЗаполнено(ИмяТаблицыБД) Тогда
						КоллекцияЭлементовМД = ирОбщий.ПоляТаблицыБДЛкс(ИмяТаблицыБД);
					КонецЕсли; 
				КонецЕсли; 
			ИначеЕсли ИмяПараметра = "ИмяПользователяИБ" Тогда 
				ПользователиИБ = ПользователиИнформационнойБазы.ПолучитьПользователей();
				Для Каждого Пользователь Из ПользователиИБ Цикл
					КоллекцияЭлементовМД.Добавить(Пользователь.Имя);
				КонецЦикла;
			ИначеЕсли ИмяПараметра = "Роль" Тогда 
				КоллекцияЭлементовМД = Метаданные.Роли;
			ИначеЕсли ИмяПараметра = "ИмяПользователяИБ" Тогда 
				ПользователиИБ = ПользователиИнформационнойБазы.ПолучитьПользователей();
				Для Каждого Пользователь Из ПользователиИБ Цикл
					КоллекцияЭлементовМД.Добавить(Пользователь.Имя);
				КонецЦикла;
			ИначеЕсли ИмяПараметра = "ОбщийМакет" Тогда 
				КоллекцияЭлементовМД = Метаданные.ОбщиеМакеты;
			ИначеЕсли Истина
				И ВыбраннаяСтруктураТипа.СтрокаОписания.Слово = "ПолучитьОбщуюФорму" 
				И ИмяПараметра = "Форма"
			Тогда
				КоллекцияЭлементовМД = Метаданные.ОбщиеФормы;
			ИначеЕсли Истина
				И ВыбраннаяСтруктураТипа.СтрокаОписания.Слово = "НайтиПредопределенное" 
				И ВыбраннаяСтруктураТипа.СтрокаОписания.ТипКонтекста = "МенеджерРегламентныхЗаданий" 
				И ИмяПараметра = "Метаданные"
			Тогда
				КоллекцияЭлементовМД = Метаданные.РегламентныеЗадания;
			ИначеЕсли Истина
				И ВыбраннаяСтруктураТипа.СтрокаОписания.Слово = "ПравоДоступа" 
				И ИмяПараметра = "Право"
			Тогда
				КоллекцияЭлементовМД = ирОбщий.ТаблицаЗначенийИзТабличногоДокументаЛкс(мПлатформа.ПолучитьМакет("ВидыПравДоступа"));
			ИначеЕсли Истина
				И (Ложь
					Или ВыбраннаяСтруктураТипа.СтрокаОписания.Слово = "ПолучитьФункциональнуюОпцию" 
					Или ВыбраннаяСтруктураТипа.СтрокаОписания.Слово = "ПолучитьФункциональнуюОпциюИнтерфейса"
					Или ВыбраннаяСтруктураТипа.СтрокаОписания.Слово = "ПолучитьФункциональнуюОпциюФормы")
				И ИмяПараметра = "Имя"
			Тогда
				КоллекцияЭлементовМД = Метаданные.ФункциональныеОпции;
			ИначеЕсли Истина
				И ТипЗнч(ВыбраннаяСтруктураТипа.Метаданные) = Тип("ПостроительЗапроса")
				И (Ложь
					Или ИмяПараметра = "ПутьКДанным"
					Или ИмяПараметра = "Описание")
			Тогда
				ИмяПараметра = "ПутьКДанным";
				ПостроительЗапроса = ВыбраннаяСтруктураТипа.Метаданные;
				#Если Сервер И Не Сервер Тогда
					ПостроительЗапроса = Новый ПостроительЗапроса;
				#КонецЕсли
				КоллекцияЭлементовМД = ПостроительЗапроса.ДоступныеПоля;
			КонецЕсли; 
			
			//Если Ложь
			//	// ФоновыеЗадания.Выполнить("")
			//	Или (Истина
			//		И ВыбраннаяСтруктураТипа.СтрокаОписания.Слово = "Выполнить" 
			//		И ВыбраннаяСтруктураТипа.СтрокаОписания.ТипКонтекста = "МенеджерФоновыхЗаданий" 
			//		И ИмяПараметра = "ИмяМетода")
			//	// БлокировкаДанных.Добавить("")
			//	Или (Истина
			//		И ВыбраннаяСтруктураТипа.СтрокаОписания.Слово = "Добавить" 
			//		И ВыбраннаяСтруктураТипа.СтрокаОписания.ТипКонтекста = "БлокировкаДанных" 
			//		И ИмяПараметра = "ПространствоБлокировки")
			//	Или (Истина
			//		И ВыбраннаяСтруктураТипа.СтрокаОписания.Слово = "УстановитьЗначение" 
			//		И ВыбраннаяСтруктураТипа.СтрокаОписания.ТипКонтекста = "ЭлементБлокировкиДанных" 
			//		И ИмяПараметра = "ПолеПространстваБлокировок")
			//Тогда
				ВыбраннаяСтруктураТипа.ТипЯзыка = ИмяПараметра;
				выхСтруктураТипаКонтекста.ТипЯзыка = ИмяПараметра;
			//КонецЕсли;
		КонецЕсли; 
		Если ВыбраннаяСтруктураТипа.ТипЯзыка = "ИмяМетода" Тогда
			Если ЗначениеЗаполнено(мРодительскийКонтекст) Тогда
				выхСтруктураТипаКонтекста.ИмяОбщегоТипа = "ОбщийМодуль";
				выхСтруктураТипаКонтекста.Метаданные = Метаданные.ОбщиеМодули.Найти(мРодительскийКонтекст);
				ВнутренняяТаблицаСлов = мПлатформа.СвойстваТипаМетаданные(выхСтруктураТипаКонтекста,, "Метод",,,,,, Истина);
				ВнутренняяТаблицаСлов.Колонки.Добавить("Определение");
				ВнутренняяТаблицаСлов.ЗаполнитьЗначения("Метаданные", "Определение");
				ЗагрузитьВТаблицуСловИзВнутреннейТаблицыСлов(ВнутренняяТаблицаСлов, ТаблицаСлов);
			Иначе
				КоллекцияЭлементовМД = Новый Массив;
				Для Каждого КлючИЗначение Из ирКэш.ДоступныеОбщиеМодулиЛкс(Истина) Цикл
					КоллекцияЭлементовМД.Добавить(КлючИЗначение.Значение);
				КонецЦикла;
			КонецЕсли; 
		ИначеЕсли ВыбраннаяСтруктураТипа.ТипЯзыка = "ИмяПредопределенногоЗначения" Тогда
			КоллекцияЭлементовМД = Новый Массив;
			Если ЗначениеЗаполнено(мРодительскийКонтекст) Тогда
				ТаблицаТиповМетаОбъектов = ирКэш.ТипыМетаОбъектов(Ложь);
				КорневойТип = ирОбщий.ПервыйФрагментЛкс(мРодительскийКонтекст);
				КоллекцияЭлементовМД.Добавить("ПустаяСсылка");
				Если Найти(мРодительскийКонтекст, ".") > 0 Тогда
					ОбъектМД = Метаданные.НайтиПоПолномуИмени(мРодительскийКонтекст);
					Если ирОбщий.ЛиКорневойТипПеречисленияЛкс(КорневойТип) Тогда
						#Если Сервер И Не Сервер Тогда
							ОбъектМД = Метаданные.Перечисления.ABCКлассификация;
						#КонецЕсли
						Для Каждого ЗначениеПеречисления Из ОбъектМД.ЗначенияПеречисления Цикл
							КоллекцияЭлементовМД.Добавить(ЗначениеПеречисления.Имя);
						КонецЦикла;
					Иначе
						#Если Сервер И Не Сервер Тогда
							ОбъектМД = Метаданные.Справочники.Валюты;
						#КонецЕсли
						Если Истина
							И ирКэш.НомерВерсииПлатформыЛкс() > 803004 
							И ирОбщий.ЛиКорневойТипОбъектаСПредопределеннымЛкс(КорневойТип) 
						Тогда
							Для Каждого ИмяЭлемента Из ОбъектМД.ПолучитьИменаПредопределенных() Цикл
								КоллекцияЭлементовМД.Добавить(ИмяЭлемента);
							КонецЦикла;
						КонецЕсли; 
					КонецЕсли; 
				Иначе
					МножественноеИмяМД = ирОбщий.МножественноеИмяМДЛкс(КорневойТип);
					Если МножественноеИмяМД <> Неопределено Тогда
						Для Каждого МетаОбъект Из Метаданные[МножественноеИмяМД] Цикл
							КоллекцияЭлементовМД.Добавить(МетаОбъект);
						КонецЦикла;
					КонецЕсли; 
				КонецЕсли; 
			Иначе
				Для Каждого СтрокаТипаМетаОбъекта Из ирКэш.ТипыМетаОбъектов(Ложь, Ложь, Ложь) Цикл
					Если Ложь
						Или ирОбщий.ЛиКорневойТипПеречисленияЛкс(СтрокаТипаМетаОбъекта.Единственное)
						Или ирОбщий.ЛиКорневойТипОбъектаСПредопределеннымЛкс(СтрокаТипаМетаОбъекта.Единственное) 
					Тогда
						КоллекцияЭлементовМД.Добавить(СтрокаТипаМетаОбъекта.Единственное);
					КонецЕсли; 
				КонецЦикла;
			КонецЕсли;  
		ИначеЕсли Ложь
			Или ВыбраннаяСтруктураТипа.ТипЯзыка = "Местоположение" 
			Или ВыбраннаяСтруктураТипа.ТипЯзыка = "ИмяФормы" 
		Тогда
			Если ВыбраннаяСтруктураТипа.ТипЯзыка = "Местоположение" Тогда
				ИмяДочернегоТипаМД = "Макет";
				ИмКорневогоТипаМД = "ОбщийМакет";
			Иначе
				ИмяДочернегоТипаМД = "Форма";
				ИмКорневогоТипаМД = "ОбщаяФорма";
			КонецЕсли; 
			КоллекцияЭлементовМД = Новый Массив;
			Если ЗначениеЗаполнено(мРодительскийКонтекст) Тогда
				Если ирОбщий.СтрокиРавныЛкс(ИмКорневогоТипаМД, ирОбщий.ПервыйФрагментЛкс(мРодительскийКонтекст)) Тогда
					Если СтрЧислоВхождений(мРодительскийКонтекст, ".") = 0 Тогда
						Для Каждого МетаМакет Из Метаданные[ирОбщий.МножественноеИмяМДЛкс(ИмКорневогоТипаМД)] Цикл
							КоллекцияЭлементовМД.Добавить(МетаМакет.Имя);
						КонецЦикла;
					КонецЕсли; 
				Иначе
					Если СтрЧислоВхождений(мРодительскийКонтекст, ".") = 0 Тогда
						КорневойТип = ирОбщий.ПервыйФрагментЛкс(мРодительскийКонтекст);
						МножественноеИмяМД = ирОбщий.МножественноеИмяМДЛкс(КорневойТип);
						Если МножественноеИмяМД <> Неопределено Тогда
							Попытка
								КоллекцияМД = Метаданные[МножественноеИмяМД];
							Исключение
								КоллекцияМД = Новый Массив;
							КонецПопытки;
							Для Каждого МетаОбъект Из КоллекцияМД Цикл
								КоллекцияЭлементовМД.Добавить(МетаОбъект);
							КонецЦикла;
						КонецЕсли; 
					ИначеЕсли СтрЧислоВхождений(мРодительскийКонтекст, ".") = 1 Тогда
						КоллекцияЭлементовМД.Добавить(ИмяДочернегоТипаМД);
					ИначеЕсли СтрЧислоВхождений(мРодительскийКонтекст, ".") = 2 Тогда
						ОбъектМД = Метаданные.НайтиПоПолномуИмени(ирОбщий.СтрокаБезПоследнегоФрагментаЛкс(мРодительскийКонтекст, "."));
						#Если Сервер И Не Сервер Тогда
							ОбъектМД = Метаданные.Справочники.Валюты;
						#КонецЕсли
						Для Каждого МетаМакет Из ОбъектМД[ирОбщий.МножественноеИмяМДЛкс(ИмяДочернегоТипаМД)] Цикл
							КоллекцияЭлементовМД.Добавить(МетаМакет.Имя);
						КонецЦикла;
					КонецЕсли; 
				КонецЕсли; 
			Иначе
				Для Каждого СтрокаТипаМетаОбъекта Из ирКэш.ТипыМетаОбъектов(Истина, Ложь) Цикл
					НадоДобавить = ирОбщий.СтрокиРавныЛкс(ИмКорневогоТипаМД, СтрокаТипаМетаОбъекта.Единственное);
					Если Не НадоДобавить Тогда
						ОтборСвойств = Новый Структура("ТипКонтекста, ЯзыкПрограммы, ТипЯзыка, НСлово, ТипСлова", 
							"ОбъектМетаданных: " + СтрокаТипаМетаОбъекта.Единственное, 0, "", НРег(ирОбщий.МножественноеИмяМДЛкс(ИмяДочернегоТипаМД)), "Свойство");
						НадоДобавить = мПлатформа.ТаблицаКонтекстов.НайтиСтроки(ОтборСвойств).Количество() > 0;
					КонецЕсли; 
					Если НадоДобавить Тогда 
						КоллекцияЭлементовМД.Добавить(СтрокаТипаМетаОбъекта.Единственное);
					КонецЕсли; 
				КонецЦикла;
			КонецЕсли;  
		ИначеЕсли ВыбраннаяСтруктураТипа.ТипЯзыка = "ПространствоБлокировки" Тогда
			КоллекцияЭлементовМД = Новый Массив;
			Если ЗначениеЗаполнено(мРодительскийКонтекст) Тогда
				КорневойТип = ирОбщий.ПервыйФрагментЛкс(мРодительскийКонтекст);
				ЭтоТаблицаВнешнейБД = ирОбщий.ЛиКорневойТипВнешнегоИсточникаДанныхЛкс(КорневойТип);
				Если Истина
					И ЭтоТаблицаВнешнейБД
					И СтрЧислоВхождений(мРодительскийКонтекст, ".") = 1 
				Тогда
					КоллекцияЭлементовМД.Добавить("Таблица");
				ИначеЕсли Истина
					И ЭтоТаблицаВнешнейБД
					И СтрЧислоВхождений(мРодительскийКонтекст, ".") = 2 
				Тогда
					Для Каждого МетаОбъект Из ирКэш.ОбъектМДПоПолномуИмениЛкс(ирОбщий.СтрокаБезПоследнегоФрагментаЛкс(мРодительскийКонтекст)).Таблицы Цикл
						КоллекцияЭлементовМД.Добавить(МетаОбъект.Имя);
					КонецЦикла; 
				ИначеЕсли Найти(мРодительскийКонтекст, ".") > 0 Тогда
					Если ирОбщий.ЛиКорневойТипРегистраБДЛкс(КорневойТип) Тогда
						КоллекцияЭлементовМД.Добавить("НаборЗаписей");
					КонецЕсли; 
					Если ирОбщий.ЛиКорневойТипПоследовательностиЛкс(КорневойТип) Тогда
						КоллекцияЭлементовМД.Добавить("Записи");
					КонецЕсли; 
				Иначе
					МножественноеИмяМД = ирОбщий.МножественноеИмяМДЛкс(КорневойТип);
					Если МножественноеИмяМД <> Неопределено Тогда
						Для Каждого МетаОбъект Из Метаданные[МножественноеИмяМД] Цикл
							КоллекцияЭлементовМД.Добавить(МетаОбъект);
						КонецЦикла;
					КонецЕсли; 
				КонецЕсли; 
			Иначе
				Для Каждого СтрокаТипаМетаОбъекта Из ирКэш.ТипыМетаОбъектов(Ложь, Ложь, Ложь) Цикл
					КоллекцияЭлементовМД.Добавить(СтрокаТипаМетаОбъекта.Единственное);
				КонецЦикла;
			КонецЕсли;  
		ИначеЕсли ВыбраннаяСтруктураТипа.ТипЯзыка = "ПолеПространстваБлокировок" Тогда
			ПространствоБлокировки = ВыбраннаяСтруктураТипа.Метаданные;
			КорневойТип = ирОбщий.ПервыйФрагментЛкс(ПространствоБлокировки);
			ОбъектМД = ирОбщий.ПолучитьМетаданныеЛкс(ПространствоБлокировки);
			ЭтоТаблицаВнешнейБД = ирОбщий.ЛиКорневойТипВнешнегоИсточникаДанныхЛкс(КорневойТип);
			Если ирОбщий.ЛиМетаданныеСсылочногоОбъектаЛкс(ОбъектМД) Тогда
				КоллекцияЭлементовМД.Добавить("Ссылка");
				Если ОбъектМД <> Неопределено Тогда
					#Если Сервер И Не Сервер Тогда
						ОбъектМД = Метаданные.Справочники.Пользователи;
					#КонецЕсли
					Для Каждого ПолеБлокировки Из ОбъектМД.ПоляБлокировкиДанных Цикл
						КоллекцияЭлементовМД.Добавить(ПолеБлокировки.Имя);
					КонецЦикла;
				КонецЕсли; 
			Иначе
				Если ОбъектМД <> Неопределено Тогда
					#Если Сервер И Не Сервер Тогда
						ОбъектМД = Метаданные.РегистрыСведений.КурсыВалют;
					#КонецЕсли
					Если Найти(ПространствоБлокировки, "." + "НаборЗаписей") > 0 Тогда
						СтруктураКлюча = ирОбщий.СтруктураКлючаТаблицыБДЛкс(ирКэш.ИмяТаблицыИзМетаданныхЛкс(ОбъектМД.ПолноеИмя()), Ложь);
					Иначе
						СтруктураКлюча = Новый Структура;
						Если ирОбщий.ЛиКорневойТипРегистраСведенийЛкс(КорневойТип) Тогда
							Если ОбъектМД.ПериодичностьРегистраСведений <> Метаданные.СвойстваОбъектов.ПериодичностьРегистраСведений.Непериодический Тогда
								СтруктураКлюча.Вставить(ирОбщий.ПеревестиСтроку("Период"));
							КонецЕсли; 
							Если ОбъектМД.РежимЗаписи = Метаданные.СвойстваОбъектов.РежимЗаписиРегистра.ПодчинениеРегистратору Тогда
								СтруктураКлюча.Вставить(ирОбщий.ПеревестиСтроку("Регистратор"));
							КонецЕсли; 
						КонецЕсли; 
						Если ирОбщий.ЛиКорневойТипРегистраРасчетаЛкс(КорневойТип) Тогда
							СтруктураКлюча.Вставить(ирОбщий.ПеревестиСтроку("ПериодРегистрации"));
							СтруктураКлюча.Вставить(ирОбщий.ПеревестиСтроку("ПериодДействия"));
						КонецЕсли; 
						Если ЭтоТаблицаВнешнейБД Тогда
							Для Каждого ПолеКлюча Из ОбъектМД.ПоляКлюча Цикл
								СтруктураКлюча.Вставить(ПолеКлюча.Имя);
							КонецЦикла;
						Иначе
							Для Каждого Измерение Из ОбъектМД.Измерения Цикл
								СтруктураКлюча.Вставить(Измерение.Имя);
							КонецЦикла;
						КонецЕсли; 
					КонецЕсли; 
					Для Каждого КлючИЗначение Из СтруктураКлюча Цикл
						КоллекцияЭлементовМД.Добавить(КлючИЗначение.Ключ);
					КонецЦикла;
				КонецЕсли; 
			КонецЕсли; 
		ИначеЕсли Истина
			И ирОбщий.СтрокиРавныЛкс(мИмяМетода, "COMОбъект") 
			И мНомерПараметра = 1 
			И ВыбраннаяСтруктураТипа.ИмяОбщегоТипа = "Неизвестный контекст"
		Тогда
			Если МассивКОМКлассов = Неопределено Тогда
				Компьютер = "localhost";
				МассивКОМКлассов = Новый Массив;
				КаталогПриложений = Новый COMОбъект("COMAdmin.COMAdminCatalog");
				КаталогПриложений.Connect(Компьютер);
				Компоненты = КаталогПриложений.GetCollection("InprocServers");
				Компоненты.Populate();
				ДобавитьCOMКлассыВСписокСлов(МассивКомКлассов, Компоненты);
				Компоненты = КаталогПриложений.GetCollection("WOWLegacyServers");
				Компоненты.Populate();
				ДобавитьCOMКлассыВСписокСлов(МассивКомКлассов, Компоненты);
				Компоненты = КаталогПриложений.GetCollection("LegacyServers");
				Компоненты.Populate();
				ДобавитьCOMКлассыВСписокСлов(МассивКомКлассов, Компоненты);
			КонецЕсли; 
			КоллекцияЭлементовМД = МассивКОМКлассов;
		КонецЕсли; 
		выхСтруктураТипаКонтекста.ИмяОбщегоТипа = "Строка";
		Для Каждого ЭлементКоллекцииМД Из КоллекцияЭлементовМД Цикл
			СтрокаСлова = ТаблицаСлов.Добавить();
			Если ТипЗнч(ЭлементКоллекцииМД) = Тип("Строка") Тогда
				СтрокаСлова.Слово = ЭлементКоллекцииМД;
			Иначе
				СтрокаСлова.Слово = ЭлементКоллекцииМД.Имя;
			КонецЕсли; 
			СтрокаСлова.ТипСлова = "Свойство";
			СтрокаСлова.Определение = "Метаданные";
			СтрокаСлова.ТипЗначения = "Строка";
		КонецЦикла;
	Иначе
		Если Истина
			И ЯзыкПрограммы = 1 
			И ВыбраннаяСтруктураТипа.ТипЯзыка = "ИмяТипа"
			И Не мТолькоСсылочныеИменаТипов
			И Найти(мКонтекст, ".") = 0
		Тогда
			ИменаФиксированныхТипов = Новый Массив;
			ИменаФиксированныхТипов.Добавить("БУЛЕВО");
			ИменаФиксированныхТипов.Добавить("ДАТА");
			ИменаФиксированныхТипов.Добавить("СТРОКА");
			ИменаФиксированныхТипов.Добавить("ЧИСЛО");
			Для Каждого ЭлементКоллекцииМД Из ИменаФиксированныхТипов Цикл
				СтрокаСлова = ТаблицаСлов.Добавить();
				СтрокаСлова.Слово = ЭлементКоллекцииМД;
				СтрокаСлова.ТипСлова = "Свойство";
				СтрокаСлова.Определение = "Предопределенный";
				СтрокаСлова.ТипЗначения = "Тип";
			КонецЦикла;
		КонецЕсли; 
		Если ЯзыкПрограммы = 1 И Найти(мКонтекст, ".") = 0 Тогда
			Для Каждого ОписаниеТаблицы Из ДоступныеТаблицы.НайтиСтроки(Новый Структура("Тип, Схема", "ВременнаяТаблица", "")) Цикл
				СтрокаСлова = ТаблицаСлов.Добавить();
				СтрокаСлова.Слово = ОписаниеТаблицы.Имя;
				СтрокаСлова.ТипСлова = "Свойство";
				СтрокаСлова.Определение = "Локальный";
				СтрокаСлова.ТипЗначения = ОписаниеТаблицы.Тип;
			КонецЦикла;
		КонецЕсли; 
		ЗаполнитьЗначенияСвойств(выхСтруктураТипаКонтекста, ВыбраннаяСтруктураТипа);
	КонецЕсли; 
	ТаблицаСтруктурТиповКонтекста.Очистить();
	Попытка
		ВыгрузкаТаблицыСлов = мПлатформа.ПолучитьТаблицуСловСтруктурыТипа(выхСтруктураТипаКонтекста, ЯзыкПрограммы, Конфигурация, ВнешниеФункцииКомпоновкиДанных, ВычислятьТипы,,,
			ЛиСерверныйКонтекст);
		СловаДляУточненияТипа = ВыгрузкаТаблицыСлов.НайтиСтроки(Новый Структура("МожноУточнитьТип", Истина));
		//Если ВычислятьТипы Или СловаДляУточненияТипа.Количество() < 100 Тогда
			Для Каждого ВнутренняяСтрокаСлова Из СловаДляУточненияТипа Цикл
				ОбновитьТипЗначенияИзТаблицыСтруктурТипов(ВнутренняяСтрокаСлова, ВнутренняяСтрокаСлова.ТаблицаСтруктурТипов, Ложь);
			КонецЦикла;
		//КонецЕсли; 
		#Если Сервер И Не Сервер Тогда
			ВыгрузкаТаблицыСлов = Новый ТаблицаЗначений;
		#КонецЕсли
		Если Ложь
			Или выхСтруктураТипаКонтекста.ИмяОбщегоТипа = "Локальный"
			Или выхСтруктураТипаКонтекста.ИмяОбщегоТипа = "ВнешнийИсточникДанных.<Имя внешнего источника>.ВременнаяТаблица"
		Тогда
			ВыгрузкаТаблицыСлов.Индексы.Добавить("Слово, ТипСлова");
			Если выхСтруктураТипаКонтекста.ИмяОбщегоТипа = "Локальный" Тогда
				// Добавим слова из таблицы локального контекста
				Для Каждого СтрокаСлова Из ТаблицаЛокальногоКонтекста Цикл
					НоваяСтрока = мПлатформа.ДобавитьВТаблицуСлов(ВыгрузкаТаблицыСлов, СтрокаСлова.Слово, СтрокаСлова.ТипСлова);
					Если Не ЗначениеЗаполнено(НоваяСтрока.Определение) Тогда
						НоваяСтрока.Определение = "Локальный";
					КонецЕсли;
					//Если ЗаполнятьТипы Тогда // Если откладывать вычисление типа, то потом через метод УточнитьТипЗначенияВСтрокеТаблицыСлов он не вычислится
						НоваяСтрока.ТипЗначения = мПлатформа.ПредставлениеМассиваСтруктурТипов(СтрокаСлова.ТаблицаСтруктурТипов);
					//КонецЕсли; 
				КонецЦикла;
			КонецЕсли;
			Если выхСтруктураТипаКонтекста.ИмяОбщегоТипа = "ВнешнийИсточникДанных.<Имя внешнего источника>.ВременнаяТаблица" Тогда
				Для Каждого СтрокаВременнойТаблицы Из ДоступныеТаблицы.НайтиСтроки(Новый Структура("Тип", "ВременнаяТаблица")) Цикл
					НоваяСтрока = мПлатформа.ДобавитьВТаблицуСлов(ВыгрузкаТаблицыСлов, СтрокаВременнойТаблицы.Имя, "Свойство",, "ВременнаяТаблица");
					НоваяСтрока.Определение = "Локальный";
				КонецЦикла;
			КонецЕсли;
		КонецЕсли; 
		ирОбщий.ЗагрузитьВТаблицуЗначенийЛкс(ВыгрузкаТаблицыСлов, ТаблицаСлов);
	Исключение
		Ошибка = ИнформацияОбОшибке();
		Если Ошибка.Описание = "ОшибкаВычисленияВиртуальнойТаблицы" Тогда 
			Возврат Ложь;
		КонецЕсли;
		ВызватьИсключение;
	КонецПопытки;
	СтруктураКлюча = Новый Структура("ТипКонтекста, ЯзыкПрограммы, ТипЯзыка",
		выхСтруктураТипаКонтекста.ИмяОбщегоТипа, ЯзыкПрограммы, выхСтруктураТипаКонтекста.ТипЯзыка);
	ДобавлятьЛокальныйКонтекст = Ложь
		Или выхСтруктураТипаКонтекста.ИмяОбщегоТипа = "Неизвестный контекст"
		Или выхСтруктураТипаКонтекста.ИмяОбщегоТипа = "Локальный"
		Или мПлатформа.ТаблицаШаблоновКонтекстов.НайтиСтроки(СтруктураКлюча).Количество() > 0;
	Если РазрешитьОткрытиеОкон Или ВычислятьТипы Или ДобавлятьЛокальныйКонтекст Тогда
		Для Каждого СтрокаСлова Из ТаблицаСлов Цикл
			СтрокаСлова.НСлово = НРег(СтрокаСлова.Слово);
		КонецЦикла;
		Если ДобавлятьЛокальныйКонтекст Тогда
			ЗаполнитьЛокальныеСвойстваИМетодыПоТексту(Ложь, выхСтруктураТипаКонтекста.ИмяОбщегоТипа = "Локальный", Истина, Ложь);
		КонецЕсли;
		Если Прав(мТекущееСлово, 1) = "(" Тогда 
			ЧистоеТекущееСлово = Лев(мТекущееСлово, СтрДлина(мТекущееСлово) - 1);
			ТипТекущегоСлова = "Метод";
		Иначе
			ЧистоеТекущееСлово = мТекущееСлово;
			ТипТекущегоСлова = "Свойство";
		КонецЕсли;
		КлючПоиска = Новый Структура("НСлово, Определение, ТипСлова", НРег(ЧистоеТекущееСлово), "Статистический", ТипТекущегоСлова);
		НайденныеСтроки = ТаблицаСлов.НайтиСтроки(КлючПоиска);
		Если НайденныеСтроки.Количество() > 0 Тогда
			НайденнаяСтрока = НайденныеСтроки[0];
			НайденнаяСтрока.Частота = НайденнаяСтрока.Частота - 1;
			Если НайденнаяСтрока.Частота = 0 Тогда
				ТаблицаСлов.Удалить(НайденнаяСтрока);
			КонецЕсли;
		КонецЕсли;
		ТаблицаСлов.Свернуть("НСлово, Слово, ТипСлова, Определение, ТипЗначения", "Частота");
	КонецЕсли; 
	Возврат Истина;
КонецФункции

Процедура ВставитьВыбранноеСловоАвтодополнения(СтрокаРезультата, КонкретныйТип, СтруктураТипаКонтекста, ТаблицаСтруктурТиповКонтекста = Неопределено, ПараметрЗакрытияПодсказки = Истина) Экспорт 

	#Если Сервер И Не Сервер Тогда
		ПолеТекста = Обработки.ирОболочкаПолеТекста.Создать();
	#КонецЕсли
	ТаблицаСтатистикиВыбора = мПлатформа.ТаблицаСтатистикиВыбора;
	Если Найти(НРег(СтрокаРезультата.Слово), НРег(НачалоСлова + КонецКонтекста)) = 1 Тогда
		НеобрабатываемыйКонецСтроки = Сред(ТекущийКонецСтроки, СтрДлина(КонецКонтекста) + 1);
	Иначе
		НеобрабатываемыйКонецСтроки = ТекущийКонецСтроки;
		RegExp.Pattern = "[" + шБуква + "\d]";
		Если RegExp.Проверить(Лев(НеобрабатываемыйКонецСтроки, 1)) Тогда
			НеобрабатываемыйКонецСтроки = " " + НеобрабатываемыйКонецСтроки;
		КонецЕсли; 
	КонецЕсли;
	СтрокаНачала = "";
	Если Не мЭтоСтроковыйЛитерал И СтрокаРезультата.ТипСлова = "Метод" Тогда
		Если Лев(КонецКонтекста, 1) = "(" Тогда 
			НеобрабатываемыйКонецСтроки = Сред(НеобрабатываемыйКонецСтроки, 2);
		КонецЕсли;
		СтрокаОкончания = "()";
		Если Истина
			И ПараметрЗакрытияПодсказки = Истина 
			И Прав(мТекущееСлово, 1) = "(" 
		Тогда 
			СтрокаОкончания = "(";
		Иначе
			Если Истина
				И ЯзыкПрограммы = 0 
				И Лев(НеобрабатываемыйКонецСтроки, 1) <> ";"
				И СтрокаРезультата.ТипЗначения = ""
				И СтрокаРезультата.Определение <> "Статистический"
			Тогда
				СтрокаОкончания = СтрокаОкончания + ";"
			КонецЕсли;
		КонецЕсли;
		СмещениеКурсораВОкончании = СтрДлина(СтрокаОкончания);
		Если ПараметрЗакрытияПодсказки = Истина Тогда
			ТаблицаМетодовМодуля = мПлатформа.СвойстваТипаМетаданные(СтруктураТипаКонтекста, СтрокаРезультата.Слово, "Метод");
			Если ТаблицаМетодовМодуля.Количество() > 0 Тогда
				СтрокаОписания = ТаблицаМетодовМодуля[0].ТаблицаСтруктурТипов[0].СтрокаОписания;
				Если Ложь
					Или (Истина
						И ТипЗнч(СтрокаОписания) = Тип("COMОбъект") 
						И СтрокаОписания.Parameters.Count > 0)
					Или (Истина
						И ТипЗнч(СтрокаОписания) = Тип("СтрокаТаблицыЗначений")
						И СтрокаОписания.Параметры <> Неопределено)
				Тогда
					СмещениеКурсораВОкончании = 1;
				КонецЕсли; 
			Иначе
				МассивОбщихТипов = мПлатформа.ТаблицаОбщихТиповИзСтруктурыТипа(СтруктураТипаКонтекста);
				КлючПоискаПараметров = Новый Структура("ТипКонтекста, Слово, ЯзыкПрограммы");
				КлючПоискаПараметров.Слово = СтрокаРезультата.Слово;
				КлючПоискаПараметров.ЯзыкПрограммы = ЯзыкПрограммы;
				СмещениеКурсораВОкончании = 2;
				Для Каждого СтрокаОбщегоТипа Из МассивОбщихТипов Цикл
					ОбщийТип = СтрокаОбщегоТипа.ИмяОбщегоТипа;
					КлючПоискаПараметров.ТипКонтекста = ОбщийТип;
					НайденныеСтроки = мПлатформа.ТаблицаПараметров.НайтиСтроки(КлючПоискаПараметров);
					Если НайденныеСтроки.Количество() > 0 Тогда 
						СмещениеКурсораВОкончании = 1;
						Прервать;
					КонецЕсли;
				КонецЦикла;
			КонецЕсли; 
		КонецЕсли;
	ИначеЕсли Истина
		И ПараметрЗакрытияПодсказки = "."
		И ЯзыкПрограммы <> 0
		И СтрокаРезультата.ТипСлова = "Свойство"
		И Найти(СтрокаРезультата.Слово, мПараметрыДиалектаSQL.ПрефиксПараметра) = 1
	Тогда 
		СтрокаНачала = "(";
		СтрокаОкончания = ")";
		СмещениеКурсораВОкончании = 1;
	Иначе
		СтрокаОкончания = "";
		СмещениеКурсораВОкончании = 0;
	КонецЕсли;
	
	// Обновим статистику выбора
	Если Истина
		И СтрокаРезультата.Определение <> "Локальный" 
		И СтрокаРезультата.Определение <> "Статистический" 
	Тогда
		КлючПоиска = Новый Структура("ЯзыкПрограммы, ТипКонтекста, Слово", ЯзыкПрограммы, КонкретныйТип, СтрокаРезультата.Слово);
		НайденныеСтроки = ТаблицаСтатистикиВыбора.НайтиСтроки(КлючПоиска);
		Если НайденныеСтроки.Количество() > 0 Тогда
			СтрокаСтатистикиВыбора = НайденныеСтроки[0];
		Иначе
			СтрокаСтатистикиВыбора = ТаблицаСтатистикиВыбора.Добавить();
			ЗаполнитьЗначенияСвойств(СтрокаСтатистикиВыбора, КлючПоиска);
		КонецЕсли;
		СтрокаСтатистикиВыбора.Рейтинг = СтрокаСтатистикиВыбора.Рейтинг + 1;
	КонецЕсли; 
	
	СтрокаДобавка = СтрокаНачала + СтрокаРезультата.Слово + СтрокаОкончания;
	Если мРодительскийКонтекст <> "" Тогда 
		СтрокаДобавка = мРодительскийКонтекст + "." + СтрокаДобавка;
	КонецЕсли;
	мРодительскийКонтекст = СтрокаДобавка;
	Если Истина
		И ПараметрЗакрытияПодсказки <> Истина
	Тогда
		СтрокаДобавка = СтрокаДобавка + ПараметрЗакрытияПодсказки;
		мТекущееСлово = СтрокаРезультата.Слово;
		Если ПараметрЗакрытияПодсказки = "." Тогда
			Если СтрокаРезультата.Определение = "Статистический" Тогда 
				ТаблицаСтруктурТиповКонтекста = ОпределитьТипЗначенияКонтекста(мРодительскийКонтекст, " " + мТекстДляПоискаОпределения, мПредшествующийТекст, Истина);
			Иначе
				ТаблицаСтруктурТиповКонтекста = ОпределитьТипДочернегоКонтекста(ирОбщий.БыстрыйМассивЛкс(СтруктураТипаКонтекста), мТекущееСлово, СтрокаРезультата.ТипСлова);
			КонецЕсли;
		КонецЕсли;
	КонецЕсли;
	ТекущееНачалоСтроки = Лев(ТекущееНачалоСтроки, мКонечнаяКолонка - 1 - СтрДлина(НачалоКонтекста)) + СтрокаДобавка;
	ТекущаяСтрока = ТекущееНачалоСтроки + НеобрабатываемыйКонецСтроки;
	Если ОригинальныйТекст = "" Тогда
		ВыделенныйТекст("" + ТекущаяСтрока);
	Иначе
		Если ПолеТекста.КоличествоСтрок() < мКонечнаяСтрока Тогда
			ПолеТекста.ДобавитьСтроку(ТекущаяСтрока);
		Иначе
			ПолеТекста.ЗаменитьСтроку(мКонечнаяСтрока, ТекущаяСтрока); // Баг платформы. Вызывает выделение всего предшествующего текста на 8.3.18
		КонецЕсли; 
	КонецЕсли; 
	УстановитьПризнакМодифицированностиФормы();
	Если АвтоматическаяПодсказкаПоВызовуМетода() Тогда
		мОткрытьСправкуПоПараметру = СмещениеКурсораВОкончании = 1;
	КонецЕсли; 
	мКонечнаяКолонка = мКонечнаяКолонка + СтрДлина(СтрокаДобавка) - СтрДлина(НачалоКонтекста) - СтрДлина(СтрокаОкончания) + СмещениеКурсораВОкончании;
	мНачальнаяКолонка = мКонечнаяКолонка;
	НачалоКонтекста = мРодительскийКонтекст + ".";
	НачалоСлова = "";
	УстановитьГраницыВыделения();
КонецПроцедуры

Функция АвтоматическаяПодсказкаПоВызовуМетода(Обновить = Ложь) Экспорт 
	Если АвтоматическаяПодсказкаПоВызовуМетода = Неопределено Или Обновить Тогда
		АвтоматическаяПодсказкаПоВызовуМетода = ирОбщий.ВосстановитьЗначениеЛкс(ИмяКласса + ".АвтоматическаяПодсказкаПоВызовуМетода") <> Ложь;
	КонецЕсли; 
	Возврат АвтоматическаяПодсказкаПоВызовуМетода;
КонецФункции

Функция АвтоматическаяПодсказкаАвтодополненияHTML(Обновить = Ложь) Экспорт
	Если АвтоматическаяПодсказкаАвтодополненияHTML = Неопределено Или Обновить Тогда
		АвтоматическаяПодсказкаАвтодополненияHTML = ирОбщий.ВосстановитьЗначениеЛкс(ИмяКласса + ".АвтоматическаяПодсказкаАвтодополненияHTML") <> Ложь;
	КонецЕсли; 
	Возврат АвтоматическаяПодсказкаАвтодополненияHTML;
КонецФункции

Функция ПоказыватьВсеТипыВСпискеАвтодополненияHTML(Обновить = Ложь) Экспорт 
	Если ПоказыватьВсеТипыВСпискеАвтодополненияHTML = Неопределено Или Обновить Тогда
		ПоказыватьВсеТипыВСпискеАвтодополненияHTML = ирОбщий.ВосстановитьЗначениеЛкс(ИмяКласса + ".ПоказыватьВсеТипыВСпискеАвтодополненияHTML") = Истина;
	КонецЕсли;
	Возврат ПоказыватьВсеТипыВСпискеАвтодополненияHTML;
КонецФункции

Процедура ДобавитьCOMКлассыВСписокСлов(Знач КоллекцияКолонок, Знач Компоненты)
	
	Для Каждого Класс Из Компоненты Цикл
		Если Не ЗначениеЗаполнено(Класс.Name) Тогда
			Продолжить;
		КонецЕсли;
		ИмяКласса = Класс.Name;
		КоллекцияКолонок.Добавить(ИмяКласса);
	КонецЦикла;

КонецПроцедуры

Процедура ЗагрузитьВТаблицуСловИзВнутреннейТаблицыСлов(Знач ВнутренняяТаблицаСлов, Знач ВыгрузкаТаблицыСлов)
	
	Для Каждого ВнутренняяСтрокаСлова Из ВнутренняяТаблицаСлов Цикл
		НоваяСтрока = ВыгрузкаТаблицыСлов.Добавить();
		ЗаполнитьЗначенияСвойств(НоваяСтрока, ВнутренняяСтрокаСлова);
		ТаблицаСтруктурТипов = ВнутренняяСтрокаСлова.ТаблицаСтруктурТипов;
		Если ТаблицаСтруктурТипов <> Неопределено Тогда
			ОбновитьТипЗначенияИзТаблицыСтруктурТипов(НоваяСтрока, ТаблицаСтруктурТипов);
		КонецЕсли; 
	КонецЦикла;

КонецПроцедуры

Процедура ОбновитьТипЗначенияИзТаблицыСтруктурТипов(Знач НоваяСтрока, Знач ТаблицаСтруктурТипов, ЗаменитьСуществующий = Истина) Экспорт 
	
	#Если Сервер И Не Сервер Тогда
		мПлатформа = Обработки.ирПлатформа.Создать();
	#КонецЕсли
	Если Лев(НоваяСтрока.ТипЗначения, 2) = "??" Тогда
		НовыйТипЗначения = мПлатформа.ПредставлениеМассиваСтруктурТипов(ТаблицаСтруктурТипов);
		Если Истина
			И ЗначениеЗаполнено(НовыйТипЗначения) 
			И Найти(НРег(НоваяСтрока.ТипЗначения), НРег(НовыйТипЗначения)) > 0 
			И НовыйТипЗначения <> "??"
		Тогда
			НовыйТипЗначения = "";
		КонецЕсли; 
		НоваяСтрока.ТипЗначения = СтрЗаменить(НоваяСтрока.ТипЗначения, "??", НовыйТипЗначения);
		Если Не ЗначениеЗаполнено(НоваяСтрока.ТипЗначения) Тогда
			НоваяСтрока.ТипЗначения = "?";
		ИначеЕсли Лев(НоваяСтрока.ТипЗначения, 1) = "," Тогда 
			НоваяСтрока.ТипЗначения = СокрЛ(Сред(НоваяСтрока.ТипЗначения, 2));
		КонецЕсли; 
	ИначеЕсли Ложь
		Или ЗаменитьСуществующий
		Или Не ЗначениеЗаполнено(НоваяСтрока.ТипЗначения) 
		Или Найти(НоваяСтрока.ТипЗначения, "<") > 0
	Тогда 
		НовыйТипЗначения = мПлатформа.ПредставлениеМассиваСтруктурТипов(ТаблицаСтруктурТипов);
		НоваяСтрока.ТипЗначения = НовыйТипЗначения;
	КонецЕсли;

КонецПроцедуры

Функция УточнитьТипЗначенияВСтрокеТаблицыСлов(Знач СтруктураТипаКонтекста, Знач ТекущаяСтрока, Знач ВернутьСтруктуруТипа = Ложь) Экспорт 
	#Если Сервер И Не Сервер Тогда
		ТекущаяСтрока = ТаблицаСлов.Добавить();
	#КонецЕсли
	НужноУточнитьТип = Ложь
		Или Лев(ТекущаяСтрока.ТипЗначения, 2) = "??" 
		Или Найти(ТекущаяСтрока.ТипЗначения, "<") > 0;
	Если НужноУточнитьТип Или ВернутьСтруктуруТипа Тогда
		#Если Сервер И Не Сервер Тогда
			мПлатформа = Обработки.ирПлатформа.Создать();
		#КонецЕсли
		ОписанияСлов = мПлатформа.ПолучитьТаблицуСловСтруктурыТипа(СтруктураТипаКонтекста, ЯзыкПрограммы, Конфигурация,, Истина,, ТекущаяСтрока.ТипСлова, ЛиСерверныйКонтекст, ТекущаяСтрока.Слово,
			мМодульМетаданных, Истина);
		Если ОписанияСлов.Количество() > 0 Тогда
			Если НужноУточнитьТип Тогда
				ОбновитьТипЗначенияИзТаблицыСтруктурТипов(ТекущаяСтрока, ОписанияСлов[0].ТаблицаСтруктурТипов, ТекущаяСтрока.Определение <> "Метаданные");
			КонецЕсли;
			Возврат ОписанияСлов[0].ТаблицаСтруктурТипов;
		КонецЕсли; 
	КонецЕсли;
	Возврат Неопределено;

КонецФункции

Процедура ПоискОбщегоМетода()
	
	ФормаВыбора = ПолучитьФорму("ОбщиеМетоды");
	ФормаВыбора.Открыть();
	
КонецПроцедуры

// Заменяет все символы табуляции в строке после первого печатного символа эквивалентным количеством пробелов.
//
// Параметры:
//  Строка       - Строка;
//
// Возвращаемое значение:
//  Строка.
//
Функция ЗаменитьТабуляцииВСтроке(Знач Строка, ЛиТекущая = Ложь)
	
	Табы = "";
	А = 1; НачалоСтроки = Истина;   
	Пока А <= СтрДлина(Строка) Цикл
		Если Сред(Строка, А, 1) <> Символы.Таб И НачалоСтроки Тогда
			// Найдем начало строки без табов 
			Табы = Лев(Строка, А-1);
			Строка = Прав(Строка, СтрДлина(Строка) - А + 1);
			НачалоСтроки = Ложь;
		ИначеЕсли Сред(Строка, А, 1) = Символы.Таб И НЕ НачалоСтроки Тогда
			// Удалим табы из строки 
			Строка = Лев(Строка, А - 1) + Лев("    ", 4 - СтрДлина(Лев(Строка, А - 1)) % 4) 
				+ Прав(Строка, СтрДлина(Строка) - А);
			Если Истина
				И ЛиТекущая
				И мКонечнаяКолонка > А
			Тогда
				мКонечнаяКолонка = мКонечнаяКолонка + 3 - СтрДлина(Лев(Строка, А - 1)) % 4;
			КонецЕсли;
		КонецЕсли;
		А = А + 1;
	КонецЦикла;
	
	Возврат Табы + Строка;
    
КонецФункции

// Заменяет все символы табуляции в каждой строке текста после первого печатного символа эквивалентным
// количеством пробелов.
//
// Параметры:
//  Нет.
//
Процедура ЗаменитьТабуляции()

	Если Ложь
		Или ПолеТекста.ТолькоПросмотр()
		Или ФормаВладелец.ТолькоПросмотр
	Тогда
		Возврат;
	КонецЕсли;
	КоличествоСтрок = ПолеТекста.КоличествоСтрок();
	Для А = 1 По КоличествоСтрок Цикл
	    Строка = ЗаменитьТабуляцииВСтроке(ПолеТекста.ПолучитьСтроку(А), (А = мКонечнаяСтрока));
	    ПолеТекста.ЗаменитьСтроку(А, Строка);
	КонецЦикла;
	УстановитьПризнакМодифицированностиФормы();
	мНачальнаяКолонка = мКонечнаяКолонка;

КонецПроцедуры // ЗаменитьТабуляции()

Процедура УстановитьАвтоКонтекстнаяПомощь(НовыйРежим)

	Кнопка = ирОбщий.КнопкаКоманднойПанелиЭкземпляраКомпонентыЛкс(ЭтотОбъект, "АвтоКонтекстнаяПомощь");
	Если Кнопка = Неопределено Тогда
		// Это сделано временно для работы в ссылочном режиме
		Возврат;
	КонецЕсли; 
	мАвтоКонтекстнаяПомощь = НовыйРежим;
	Если мАвтоКонтекстнаяПомощь Тогда
		ФормаВладелец.ПодключитьОбработчикОжидания("КлсПолеТекстаПрограммыАвтоОбновитьСправку", 1);
	Иначе
		ФормаВладелец.ОтключитьОбработчикОжидания("КлсПолеТекстаПрограммыАвтоОбновитьСправку");
	КонецЕсли; 
	Кнопка.Пометка = мАвтоКонтекстнаяПомощь;

КонецПроцедуры

// Удаляет все символы переноса строки из текста.
//
// Параметры:
//  Нет.
//
Процедура УдалитьПереносы()

	Если Ложь
		Или ПолеТекста.ТолькоПросмотр()
		Или ФормаВладелец.ТолькоПросмотр
	Тогда
		Возврат;
	КонецЕсли;
	Текст = ПолеТекста.ПолучитьТекст();
	Текст = СокрЛП(Текст);
	Если Истина
		И Лев(Текст, 1) = """"
		И Лев(Текст, 2) <> """"""
	Тогда
		Текст = Сред(Текст, 2);
	КонецЕсли; 
	Если Истина
		И Прав(Текст, 1) = """"
		И Прав(Текст, 2) <> """"""
	Тогда
		Текст = Лев(Текст, СтрДлина(Текст) - 1);
	КонецЕсли; 
	Если Истина
		И Прав(Текст, 2) = """;"
		И Прав(Текст, 3) <> """"";"
	Тогда
		Текст = Лев(Текст, СтрДлина(Текст) - 2);
	КонецЕсли; 
	Текст = СтрЗаменить(Текст, "|", "");
	Текст = СтрЗаменить(Текст, """""", """");
	ПолеТекста.УстановитьТекст(Текст);
	УстановитьПризнакМодифицированностиФормы();
	
КонецПроцедуры // УдалитьПереносы()

// Добавляет слово локального контекста.
//
// Параметры:
//  Слово        – Строка;
//  ТипСлова     – Строка - "Метод", "Свойство";
//  *ТипЗначения - ОписаниеТипов, *Неопределено;
//  *Метаданные  - Произвольный, *Неопределено - используется, если ТипЗначения задан;
//  *Глобальное  - Булево, *Ложь - это слово глобального контекста;
//  *ТаблицаСтруктурТипа - ТаблицаЗначений, *Неопределено;
//
Процедура ДобавитьСловоЛокальногоКонтекста(Слово, ТипСлова = "Свойство", ТипЗначения = Неопределено,
	пМетаданные = Неопределено, Глобальное = Ложь, Значение = Неопределено, ТаблицаСтруктурТипов = Неопределено, ИмяОбщегоТипа = "") Экспорт

	КлючСтроки = Новый Структура;
	КлючСтроки.Вставить("нСлово", Нрег(Слово));
	КлючСтроки.Вставить("ТипСлова", ТипСлова);
	НайденныеСтроки = ТаблицаЛокальногоКонтекста.НайтиСтроки(КлючСтроки);
	Если НайденныеСтроки.Количество() = 0 Тогда
		НоваяСтрока = ТаблицаЛокальногоКонтекста.Добавить();
	Иначе
		НоваяСтрока = НайденныеСтроки[0];
	КонецЕсли;
	НоваяСтрока.ТаблицаСтруктурТипов = ТаблицаСтруктурТипов;
	Если НоваяСтрока.ТаблицаСтруктурТипов = Неопределено Тогда
		НоваяСтрока.ТаблицаСтруктурТипов = мПлатформа.НоваяТаблицаСтруктурТипа();
	КонецЕсли; 
	Если ЗначениеЗаполнено(ИмяОбщегоТипа) Тогда
		СтруктураТипа = НоваяСтрока.ТаблицаСтруктурТипов.Добавить();
		СтруктураТипа.ИмяОбщегоТипа = ИмяОбщегоТипа;
		СтруктураТипа.Метаданные = пМетаданные;
	КонецЕсли; 
	ЗаполнитьЗначенияСвойств(НоваяСтрока, КлючСтроки);
	//Если ТипЗначения = Неопределено Тогда
	НоваяСтрока.Значение = Значение;
	НоваяСтрока.Слово = Слово;
	НоваяСтрока.Глобальное = Глобальное;
	Если Значение <> Неопределено Тогда
		СтруктураТипа = мПлатформа.СтруктураТипаИзЗначения(Значение, ЯзыкПрограммы,
			Новый Структура("СтрокаОписания, Метаданные", НоваяСтрока, пМетаданные)); // Циклическая ссылка СтрокаОписания
		ЗаполнитьЗначенияСвойств(НоваяСтрока.ТаблицаСтруктурТипов.Добавить(), СтруктураТипа);
	КонецЕсли; 
	Если ТипЗначения <> Неопределено Тогда
		Для Каждого Тип Из ТипЗначения.Типы() Цикл
			СтруктураТипа = мПлатформа.СтруктураТипаИзКонкретногоТипа(Тип, ЯзыкПрограммы,
				Новый Структура("СтрокаОписания, Метаданные", НоваяСтрока, пМетаданные)); // Циклическая ссылка СтрокаОписания
			ЗаполнитьЗначенияСвойств(НоваяСтрока.ТаблицаСтруктурТипов.Добавить(), СтруктураТипа);
		КонецЦикла;
	КонецЕсли;
	Если Значение <> Неопределено Тогда
		Если ТипЗначения = Неопределено Тогда
			ТипЗначения = Новый ОписаниеТипов;
		КонецЕсли; 
		ТипЗначения = Новый ОписаниеТипов(ТипЗначения, ирОбщий.БыстрыйМассивЛкс(ТипЗнч(Значение)));
	КонецЕсли; 
	НоваяСтрока.ТипЗначения = ТипЗначения;

КонецПроцедуры

// Добавляет правило вычисления типа значения функции.
// При вызове правила вычисляется "Правило(<СтрокаАргументов>)", а оно должно вернуть ТаблицаСтруктурТипов.
//
// Параметры:
//  Слово        – Строка;
//  ТипСлова     – Строка - "Метод", "Свойство";
//  *ТипЗначения - ОписаниеТипов, *Неопределено;
//  *Метаданные  - Произвольный, *Неопределено;
//  *Глобальное  - Булево, *Ложь - это слово глобального контекста.
//
Процедура ДобавитьПравилоВычисленияФункции(Слово, Правило, ТипКонтекста = "Локальный") Экспорт
	
	КлючСтроки = Новый Структура;
	КлючСтроки.Вставить("НСлово", Нрег(Слово));
	КлючСтроки.Вставить("ТипКонтекста", ТипКонтекста);
	НайденныеСтроки = ПравилаВычисленияФункций.НайтиСтроки(КлючСтроки);
	Если НайденныеСтроки.Количество() = 0 Тогда
		НоваяСтрока = ПравилаВычисленияФункций.Добавить();
	Иначе
		НоваяСтрока = НайденныеСтроки[0];
	КонецЕсли;
	ЗаполнитьЗначенияСвойств(НоваяСтрока, КлючСтроки);
	НоваяСтрока.Правило = Правило;
	НоваяСтрока.Слово = Слово;

КонецПроцедуры

// Добавляет переменную локального контекста.
//
// Параметры:
//  ИмяПеременной – Строка;
//  ДопустимыеТипы – Строка, ТаблицаЗначений;
//
Процедура ДобавитьПеременнуюЛокальногоКонтекста(ИмяПеременной, ДопустимыеТипы) Экспорт

	КлючСтроки = Новый Структура;
	КлючСтроки.Вставить("нСлово", НРег(ИмяПеременной));
	КлючСтроки.Вставить("ТипСлова", "Свойство");
	НайденныеСтроки = ТаблицаЛокальногоКонтекста.НайтиСтроки(КлючСтроки);
	Если НайденныеСтроки.Количество() = 0 Тогда
		НоваяСтрока = ТаблицаЛокальногоКонтекста.Добавить();
		НоваяСтрока.ТаблицаСтруктурТипов = мПлатформа.НоваяТаблицаСтруктурТипа();
	Иначе
		НоваяСтрока = НайденныеСтроки[0];
	КонецЕсли;
	ЗаполнитьЗначенияСвойств(НоваяСтрока, КлючСтроки);
	НоваяСтрока.Слово = ИмяПеременной;
	
	Если ТипЗнч(ДопустимыеТипы) = Тип("Строка") Тогда 
		МассивСериализованныхТипов = ирОбщий.СтрРазделитьЛкс(ДопустимыеТипы, ";");
		//ТаблицаСтруктурТипов = мПлатформа.НоваяТаблицаСтруктурТипа();
		ТаблицаСтруктурТипов = НоваяСтрока.ТаблицаСтруктурТипов;
		Для Каждого СериализованныйТип Из МассивСериализованныхТипов Цикл
			СтруктураТипа = мПлатформа.СтруктураТипаИзСтрокиВнутр(СериализованныйТип);
			СтруктураТипа.Вставить("СтрокаОписания", НоваяСтрока); // Циклическая ссылка СтрокаОписания
			мПлатформа.ДобавитьВТаблицуСтруктурТипов(ТаблицаСтруктурТипов, СтруктураТипа);
		КонецЦикла;
		НоваяСтрока.ТаблицаСтруктурТипов = ТаблицаСтруктурТипов;
	Иначе
		НоваяСтрока.ТаблицаСтруктурТипов = ДопустимыеТипы;
	КонецЕсли;

КонецПроцедуры

// Удаляет слово локального контекста.
//
// Параметры:
//  Слово        – Строка;
//  ТипСлова     – Строка.
//
Процедура УдалитьСловоЛокальногоКонтекста(Слово, ТипСлова) Экспорт

	КлючСтроки = Новый Структура;
	КлючСтроки.Вставить("нСлово", НРег(Слово));
	КлючСтроки.Вставить("ТипСлова", ТипСлова);
	СтрокиСлова = ТаблицаЛокальногоКонтекста.НайтиСтроки(КлючСтроки);
	Если СтрокиСлова.Количество() > 0 Тогда
		ТаблицаЛокальногоКонтекста.Удалить(СтрокиСлова[0]);
	КонецЕсли;

КонецПроцедуры

// Устанавливает доступность действий, изменяющих данные.
//
// Параметры:
//  НовыйТолькоПросмотр – Булево.
//
Процедура УстановитьТолькоПросмотр(НовыйТолькоПросмотр) Экспорт 

	ФормаКласса = ПолучитьФорму("ФормаМакет");
	МассивКоллекцийКнопок = Новый Массив;
	МассивКоллекцийКнопок.Добавить(ФормаКласса.ЭлементыФормы["КоманднаяПанель" + Формат(ЯзыкПрограммы, "ЧН=")].Кнопки);
	МассивКоллекцийКнопок.Добавить(ФормаКласса.ЭлементыФормы.КоманднаяПанельОбщая.Кнопки);
	Для Каждого КнопкиМакета Из МассивКоллекцийКнопок Цикл
		Для Каждого КнопкаМакета Из КнопкиМакета Цикл
			Если КнопкаМакета.ТипКнопки <> ТипКнопкиКоманднойПанели.Действие Тогда 
				Продолжить;
			КонецЕсли;
			КонечноеИмя = ирОбщий.СформироватьИмяЭлементаУправленияЭкземпляраЛкс(ЭтотОбъект, КнопкаМакета.Имя);
			Кнопка = КоманднаяПанель.Кнопки.Найти(КонечноеИмя);
			Если Кнопка.ИзменяетДанные Тогда 
				Кнопка.Доступность = Не НовыйТолькоПросмотр;
			КонецЕсли;
		КонецЦикла;
	КонецЦикла;
	
КонецПроцедуры // УстановитьТолькоПросмотр()

Процедура ОформитьЯчейкуТипаЗначения(ОформлениеСтроки, ДанныеСтроки) Экспорт 
	
	Если Истина
		И ОформлениеСтроки.Ячейки.ТипЗначения.Видимость 
		И ЗначениеЗаполнено(ДанныеСтроки.ТипЗначения) 
		И Найти(ДанныеСтроки.ТипЗначения, ",") = 0
	Тогда
		Попытка
			ОписаниеТипов = Новый ОписаниеТипов(ДанныеСтроки.ТипЗначения);
		Исключение
			ОписаниеТипов = Неопределено;
		КонецПопытки; 
		Если ОписаниеТипов <> Неопределено Тогда
			Типы = ОписаниеТипов.Типы();
			Если Типы.Количество() > 0 Тогда
				КартинкаТипа = ирОбщий.КартинкаТипаЛкс(Типы[0]);
				Если КартинкаТипа <> Неопределено Тогда
					ОформлениеСтроки.Ячейки.ТипЗначения.УстановитьКартинку(КартинкаТипа);
				КонецЕсли; 
			КонецЕсли; 
		КонецЕсли; 
	КонецЕсли;

КонецПроцедуры

// Выполняет шаблон текста.
//
// Параметры:
//  Нет.
//
Процедура ВыполнитьШаблонТекста()

	Если ПолеТекста.ТолькоПросмотр() Тогда
		Возврат;
	КонецЕсли; 
	ПрочитатьНачалоИКонецТекущейСтроки();
	НадежноУстановитьФокус = Ложь;
	ПоследняяПозицияКурсора = 0;
	ТаблицаШаблоновТекста = мПлатформа.ПолучитьТаблицуШаблоновТекста(ИмяКласса);
	КонечныйТекстЗамены = " ";
	Если Ложь
		Или ТаблицаШаблоновТекста = Неопределено 
		Или ТаблицаШаблоновТекста.Количество() = 0
	Тогда
		//
	Иначе
		RegExp.Global = Ложь; 
		СтрокаРазделителейШаблоновТекста = ";.,:()[]";
		RegExp.Pattern = "([^\s" + ирОбщий.ПреобразоватьТекстДляРегулярныхВыраженийЛкс(СтрокаРазделителейШаблоновТекста) + "]*)$";
		Результат = RegExp.НайтиВхождения(ТекущееНачалоСтроки);
		Если Результат.Количество() > 0 Тогда
			НачалоКонтекста = Результат[0].SubMatches(0);
			Если ЗначениеЗаполнено(НачалоКонтекста) Тогда
				//СтрокаШаблона = ТаблицаШаблоновТекста.Найти(НРег(НачалоКонтекста), "ШаблонБезКвадратныхСкобок");
				СтрокаШаблона = Неопределено;
				Для каждого ТекСтрокаШаблона Из ТаблицаШаблоновТекста Цикл
					Если ТекСтрокаШаблона.Шаблон = НРег(НачалоКонтекста) Тогда
						СтрокаШаблона = ТекСтрокаШаблона;
						Прервать;
					КонецЕсли;
					МинимальнаяДлинаСовпадения = Найти(ТекСтрокаШаблона.Шаблон, "[");
					Если МинимальнаяДлинаСовпадения > 0 Тогда
						Если СтрДлина(НачалоКонтекста) < МинимальнаяДлинаСовпадения - 1 Тогда
							Продолжить;
						КонецЕсли; 
						ШаблонБезСкобок = СтрЗаменить(ТекСтрокаШаблона.Шаблон, "[", "");
						ШаблонБезСкобок = СтрЗаменить(ШаблонБезСкобок, "]", "");
						Если Найти(ШаблонБезСкобок, НРег(НачалоКонтекста)) = 1 Тогда
							СтрокаШаблона = ТекСтрокаШаблона;
							Прервать;
						КонецЕсли;
					КонецЕсли; 
				КонецЦикла;
				Если СтрокаШаблона = Неопределено Тогда
					НачалоКонтекста = "";
				Иначе
					RegExp.Global = Истина;
					RegExp.MultiLine = Истина;
					RegExp.Pattern = "(<\?\s*(""[^""\^]*"")?(?:.|\r|\n)*?>)|(.|\r|\n)";
					Результат = RegExp.НайтиВхождения(СтрокаШаблона.Замена);
					КонечныйТекстЗамены = "";
					КешПараметров = Новый ТаблицаЗначений;
					КешПараметров.Колонки.Добавить("ИмяПараметра");
					КешПараметров.Колонки.Добавить("ЗначениеПараметра");
					Для Каждого Match Из Результат Цикл
						УправляющаяКонструкция = Match.SubMatches(0);
						Если ирОбщий.ЛиПустаяПодгруппаRegExpЛкс(УправляющаяКонструкция) Тогда
							КонечныйТекстЗамены = КонечныйТекстЗамены + Match.SubMatches(2);
						Иначе
							ИмяПараметраШаблона = Match.SubMatches(1);
							Если Не ирОбщий.ЛиПустаяПодгруппаRegExpЛкс(ИмяПараметраШаблона) Тогда
								ИмяПараметраШаблона = Сред(ИмяПараметраШаблона, 2, СтрДлина(ИмяПараметраШаблона) - 2);
								ВведеннаяСтрока = "";
								Если ИмяПараметраШаблона <> "" Тогда
									СтрокаКэша = КешПараметров.Найти(ИмяПараметраШаблона, "ИмяПараметра");
									Если СтрокаКэша <> Неопределено Тогда
										ВведеннаяСтрока = СтрокаКэша.ЗначениеПараметра;
									Иначе
										СтрокаКэша = КешПараметров.Добавить();
										СтрокаКэша.ИмяПараметра = ИмяПараметраШаблона;
										НадежноУстановитьФокус = Истина;
										ВвестиЗначение(ВведеннаяСтрока, ИмяПараметраШаблона, Тип("Строка"));
										СтрокаКэша.ЗначениеПараметра = ВведеннаяСтрока;
									КонецЕсли;
								КонецЕсли; 
								КонечныйТекстЗамены = КонечныйТекстЗамены + ВведеннаяСтрока;
							Иначе
								ПоследняяПозицияКурсора = СтрДлина(КонечныйТекстЗамены) + 1;
							КонецЕсли;
						КонецЕсли;
					КонецЦикла;
					ЗаменаТабуляции = ирОбщий.СтрокаПовторомЛкс(" ", ШиринаТабуляции);
				КонецЕсли; 
			КонецЕсли; 
		КонецЕсли; 
	КонецЕсли;
	Если КонечныйТекстЗамены <> Неопределено Тогда
		КонечныйТекстЗаменыТД = Новый ТекстовыйДокумент;
		КонечныйТекстЗаменыТД.УстановитьТекст(КонечныйТекстЗамены);
		лКонечнаяСтрока = 0;
		лКонечнаяКолонка = 0;
		Если ПоследняяПозицияКурсора > 0 Тогда
			СлужебноеПолеТекста.УстановитьТекст(КонечныйТекстЗамены);
			Если ПоследняяПозицияКурсора <= СтрДлина(КонечныйТекстЗамены) Тогда
				СлужебноеПолеТекста.УстановитьГраницыВыделения(ПоследняяПозицияКурсора, ПоследняяПозицияКурсора);
				СлужебноеПолеТекста.ПолучитьГраницыВыделения(лКонечнаяСтрока, лКонечнаяКолонка, лКонечнаяСтрока, лКонечнаяКолонка);
			Иначе
				лКонечнаяСтрока = КонечныйТекстЗаменыТД.КоличествоСтрок();
				лКонечнаяКолонка = СтрДлина(КонечныйТекстЗаменыТД.ПолучитьСтроку(КонечныйТекстЗаменыТД.КоличествоСтрок())) + 1;
			КонецЕсли;
		КонецЕсли;
		ЧислоСтрокЗамены = КонечныйТекстЗаменыТД.КоличествоСтрок();
		СтрокаДобавка = КонечныйТекстЗаменыТД.ПолучитьСтроку(1);
		ДлинаНачалаСтроки = мКонечнаяКолонка - СтрДлина(НачалоКонтекста) - 1;
		НачалоСтроки = Лев(ТекущееНачалоСтроки, ДлинаНачалаСтроки);
		ТекущееНачалоСтроки = НачалоСтроки + СтрокаДобавка;
		ТекущаяСтрока = ТекущееНачалоСтроки;
		Если ЧислоСтрокЗамены = 1 Тогда
			ТекущаяСтрока = ТекущаяСтрока + ТекущийКонецСтроки;
		КонецЕсли;
		ПолеТекста.ЗаменитьСтроку(мКонечнаяСтрока, "" + ТекущаяСтрока);
		ДлинаРазвернутогоНачалаСтроки = СтрДлина(СтрЗаменить(НачалоСтроки, Символы.Таб, ЗаменаТабуляции));
		ЧислоТабуляций = ДлинаРазвернутогоНачалаСтроки / ШиринаТабуляции;
		ЧислоПробелов = ДлинаРазвернутогоНачалаСтроки % ШиринаТабуляции;
		НачалоНовойСтроки = ирОбщий.СтрокаПовторомЛкс(Символы.Таб, ЧислоТабуляций);
		НачалоНовойСтроки = НачалоНовойСтроки + ирОбщий.СтрокаПовторомЛкс(" ", ЧислоПробелов);
		Для Счетчик = 2 По ЧислоСтрокЗамены - 1 Цикл
			ТекущаяСтрокаВставки = КонечныйТекстЗаменыТД.ПолучитьСтроку(Счетчик);
			ПолеТекста.ВставитьСтроку(мКонечнаяСтрока + Счетчик - 1, НачалоНовойСтроки + ТекущаяСтрокаВставки);
		КонецЦикла;
		Если ЧислоСтрокЗамены > 1 Тогда
			ТекущаяСтрокаВставки = КонечныйТекстЗаменыТД.ПолучитьСтроку(ЧислоСтрокЗамены);
			ПолеТекста.ВставитьСтроку(мКонечнаяСтрока + ЧислоСтрокЗамены - 1, НачалоНовойСтроки + ТекущаяСтрокаВставки + ТекущийКонецСтроки);
		КонецЕсли;
		Если лКонечнаяСтрока > 0 Тогда
			Если лКонечнаяСтрока = 1 Тогда
				лКонечнаяКолонка = лКонечнаяКолонка + СтрДлина(НачалоСтроки);
			Иначе
				лКонечнаяКолонка = лКонечнаяКолонка + СтрДлина(НачалоНовойСтроки);
			КонецЕсли;
			лКонечнаяСтрока = лКонечнаяСтрока + мКонечнаяСтрока - 1;
			мКонечнаяКолонка = лКонечнаяКолонка;
			мКонечнаяСтрока = лКонечнаяСтрока;
		Иначе
			Если ЧислоСтрокЗамены > 0 Тогда
				мКонечнаяСтрока = мКонечнаяСтрока + ЧислоСтрокЗамены - 1;
			КонецЕсли; 
			Если ЧислоСтрокЗамены > 1 Тогда
				мКонечнаяКолонка = СтрДлина(НачалоСтроки + ТекущаяСтрокаВставки) + 1;
			Иначе
				мКонечнаяКолонка = мКонечнаяКолонка + СтрДлина(КонечныйТекстЗамены) - СтрДлина(НачалоКонтекста);
			КонецЕсли;
		КонецЕсли;
		мНачальнаяСтрока = мКонечнаяСтрока;
		мНачальнаяКолонка = мКонечнаяКолонка;
	КонецЕсли;
	УстановитьФокус();

КонецПроцедуры

Процедура ОкружитьВыделенныеСтроки(Знач НачалоОкружения, Знач КонецОкружения) Экспорт 
	
	#Если Сервер И Не Сервер Тогда
		ПолеТекста = Обработки.ирОболочкаПолеТекста.Создать();
	#КонецЕсли
	НомерНачальнойСтроки = ПолучитьНомерТекущейСтроки(Истина);
	ВыделенныйТекст = ПолеТекста.ВыделенныйТекст();
	СмещениеПервойСтроки = Лев(ВыделенныйТекст, СтрДлина(ВыделенныйТекст) - СтрДлина(СокрЛ(ВыделенныйТекст)));
	ирОбщий.ПолеТекстаУстановитьВставитьТекстИПереносСтрокиЛкс(ПолеТекста,
	"" + СмещениеПервойСтроки + НачалоОкружения + "
	|" + Символы.Таб + ирОбщий.ДобавитьМногострочнуюСтрокуВТекстЛкс("", ВыделенныйТекст, Символы.Таб) + "
	|" + СмещениеПервойСтроки + КонецОкружения);
	НомерНачальнойКолонки = СтрДлина(СмещениеПервойСтроки) + 1;
	ПолеТекста.УстановитьГраницыВыделения(НомерНачальнойСтроки, НомерНачальнойКолонки, НомерНачальнойСтроки, НомерНачальнойКолонки,, ФормаВладелец);

КонецПроцедуры

///////////////////
// Редактор HTML

Процедура РедакторHTML_Инициировать(ПолеHTML) Экспорт 
	
	#Если Сервер И Не Сервер Тогда
		мПлатформа = Обработки.ирПлатформа.Создать();
	#КонецЕсли
	ФормаКласса = мПлатформа.ПолучитьМакетКомпоненты(ЭтотОбъект);
	КнопкиМакета = ФормаКласса.ЭлементыФормы.КПРедакторHTML.Кнопки.КонтекстноеМеню.Кнопки;
	КонтекстноеМеню = ПолеHTML.КонтекстноеМеню;
	Если КонтекстноеМеню = Неопределено Тогда
		КонтекстноеМеню = ФормаВладелец.ЭлементыФормы.Добавить(Тип("КоманднаяПанель"), "КонтекстноеМеню" + ПолеHTML.Имя, Ложь);
		КонтекстноеМеню.ИсточникДействий = ПолеHTML;
		ПолеHTML.КонтекстноеМеню = КонтекстноеМеню;
	КонецЕсли;
	ирОбщий.ДобавитьКнопкиКоманднойПанелиКомпонентыЛкс(ЭтотОбъект, КнопкиМакета, КонтекстноеМеню,,, Истина);
	
	ПолеТекстаHTML = ирОбщий.ОболочкаПоляТекстаЛкс(ПолеHTML);
	#Если Сервер И Не Сервер Тогда
		ПолеТекстаHTML = Обработки.ирОболочкаПолеТекста.Создать();
	#КонецЕсли
	ПолеТекстаHTML.Инициировать();
	РедакторHTML = ПолеHTML.Документ.defaultView;
	Инфо = Новый СистемнаяИнформация();
	РедакторHTML.minimap(Ложь);
	РедакторHTML.init(Инфо.ВерсияПриложения);
	Если ЯзыкПрограммы = 1 Тогда
		РедакторHTML.switchQueryMode();
	ИначеЕсли ЯзыкПрограммы = 2 Тогда
		РедакторHTML.switchDCSMode();
	КонецЕсли; 
	РедакторHTML.setOption("disableContextQueryConstructor", Истина);
	РедакторHTML.setOption("disableNativeSuggestions", Истина); // События не перестают вызываться
	РедакторHTML.setOption("disableNativeSignatures", Истина); // События не перестают вызываться
	РедакторHTML.setOption("disableNativeHovers", Истина); // События не перестают вызываться
	РедакторHTML.setOption("skipInsertSuggestionAcceptor", Истина); // Отключаем вставку точки при выборе слова из списка https://github.com/salexdv/bsl_console/issues/120#issuecomment-844372676
	РедакторHTML.setOption("skipAcceptionSelectedSuggestion", Истина); // Отключаем стандартную обработку вставки активного пункта подсказки. Практически 'СтандартнаяОбработка = Ложь'
	РедакторHTML.setOption("renderQueryDelimiters", Истина); // Разделители запросов пакета https://github.com/salexdv/bsl_console/issues/218
	РедакторHTML.enableBeforeSignatureEvent(Истина);
	РедакторHTML.enableBeforeShowSuggestEvent(Истина);
	РедакторHTML.enableSelectSuggestEvent(Истина);
	РедакторHTML.enableModificationEvent(Истина);
	РедакторHTML.enableBeforeHoverEvent(Истина);
	РедакторHTML.disableKeyBinding(2082); // CTRL(2048)+D(34) - CTRL+D
	РедакторHTML.disableKeyBinding(2118); // CTRL(2048)+D(70) - F12
	РедакторHTML.setActiveSuggestionAcceptors("."); // По нажатию точки выполняется вставка активного слова и ввод точки // Много нежелательных срабатываний
	
КонецПроцедуры

Функция ДобавитьПодсказкуПоЗначениюВыражения(Знач ЗначениеВыражения = Неопределено, Знач ОбъектноеВыражение, Знач ПодсказкаМассив, СтруктураТипа = Неопределено) Экспорт 
	
	#Если Сервер И Не Сервер Тогда
		ПодсказкаМассив = Новый Массив;
	#КонецЕсли
	ЕстьОписаниеТипа = Ложь;
	Если СтруктураТипа = Неопределено Тогда
		СтруктураТипа = мПлатформа.СтруктураТипаИзЗначения(ЗначениеВыражения);
	КонецЕсли;
	ИмяТипаЗначения = мПлатформа.ИмяТипаИзСтруктурыТипа(СтруктураТипа);
	ИмяОбщегоТипа = СтруктураТипа.ИмяОбщегоТипа;
	СтрокаОбщегоТипа = мПлатформа.ТаблицаОбщихТипов.Найти(НРег(ИмяОбщегоТипа), "НСлово");
	Если СтрокаОбщегоТипа <> Неопределено Тогда
		ЕстьОписаниеТипа = ЗначениеЗаполнено(СтрокаОбщегоТипа.ПутьКОписанию);
	КонецЕсли;
	Если ИмяТипаЗначения = "Строка" Тогда
		ПодсказкаЗначения = "Знач: """ + ЗначениеВыражения + """";
	Иначе
		Если ТипЗнч(ЗначениеВыражения) = Тип("Строка") Тогда
			ПодсказкаЗначения = ЗначениеВыражения;
		Иначе
			ПодсказкаЗначения = ирОбщий.РасширенноеПредставлениеЗначенияЛкс(ЗначениеВыражения,, Ложь, Истина);
		КонецЕсли; 
		Если Ложь
			Или ТипЗнч(ЗначениеВыражения) = Тип("Неопределено") 
			Или ТипЗнч(ЗначениеВыражения) = Тип("Null")
		Тогда
			ПодсказкаЗначения = "Знач: " + ПодсказкаЗначения;
		Иначе
			ПодсказкаЗначения = "[Знач](" + ОбъектноеВыражение + "): " + ПодсказкаЗначения;
		КонецЕсли; 
		Если ПодсказкаЗначения = ИмяТипаЗначения Тогда
			ПодсказкаЗначения = "";
		Иначе
			ПодсказкаЗначения = ПодсказкаЗначения + " ";
		КонецЕсли; 
		Если ЕстьОписаниеТипа Тогда
			ИмяСсылкиТипа = "_Тип" + XMLСтрока(мСтруктурыТиповПодсказкиУдержания.Количество());
			ПодсказкаЗначения = ПодсказкаЗначения + "[[" + ИмяТипаЗначения + "]](" + ИмяСсылкиТипа + ")";
			мСтруктурыТиповПодсказкиУдержания.Вставить(ИмяСсылкиТипа, СтруктураТипа);
		Иначе
			ПодсказкаЗначения = ПодсказкаЗначения + "[" + ИмяТипаЗначения + "]";
		КонецЕсли; 
	КонецЕсли; 
	ПодсказкаМассив.Добавить(ПодсказкаЗначения);
	Возврат ИмяТипаЗначения;

КонецФункции

Функция ДобавитьПодсказкуПоДопустимымТипам(Знач ИмяТипаЗначения, Знач ПодсказкаМассив, Знач ОбъектноеВыражение) Экспорт 
	
	ТаблицаСтруктурТипов = ТаблицаСтруктурТиповТекущегоВыражения(Истина, Истина, Ложь);
	Если Истина
		И ЯзыкПрограммы = 1 
		И ТаблицаСтруктурТипов[0].ИмяОбщегоТипа = "ВременнаяТаблица"
	Тогда
		ВременныйЗапрос = Новый Запрос;
		ВременныйЗапрос.МенеджерВременныхТаблиц = КонтекстВыполнения.МенеджерВременныхТаблиц;
		ИмяВременнойТаблицы = ТаблицаСтруктурТипов[0].ВиртуальнаяТаблица.Выражение;
		ВременныйЗапрос.Текст = "ВЫБРАТЬ КОЛИЧЕСТВО(*) ИЗ " + ИмяВременнойТаблицы;
		КоличествоСтрокВТаблице = ВременныйЗапрос.Выполнить().Выгрузить()[0][0];
		ДобавитьПодсказкуПоЗначениюВыражения(ИмяВременнойТаблицы + "(" + КоличествоСтрокВТаблице + ")", ОбъектноеВыражение, ПодсказкаМассив, ТаблицаСтруктурТипов[0]);
	КонецЕсли; 
	ПредставлениеДопустимыхТипов = мПлатформа.ПредставлениеМассиваСтруктурТипов(ТаблицаСтруктурТипов, Истина);
	Если Истина
		И ПредставлениеДопустимыхТипов <> "?"
		И ПредставлениеДопустимыхТипов <> "ОбщийМодуль"
		И ПредставлениеДопустимыхТипов <> "ВременнаяТаблица"
		И ЗначениеЗаполнено(ПредставлениеДопустимыхТипов)
		И ПредставлениеДопустимыхТипов <> ИмяТипаЗначения
	Тогда
		ИмяСсылкиТипа = "_Тип" + XMLСтрока(мСтруктурыТиповПодсказкиУдержания.Количество());
		мСтруктурыТиповПодсказкиУдержания.Вставить(ИмяСсылкиТипа, ТаблицаСтруктурТипов);
		ПредставлениеДопустимыхТипов = "[Допустимые типы](" + ИмяСсылкиТипа + "): " + ПредставлениеДопустимыхТипов;
		ПодсказкаМассив.Добавить(ПредставлениеДопустимыхТипов);
	КонецЕсли;
	Если ПредставлениеДопустимыхТипов <> "ОбщийМодуль" Тогда
		ПодсказкаМассив.Добавить("[Определение](" + XMLСтрока(мКонечнаяСтрока) + "," + XMLСтрока(мКонечнаяКолонка) + ")");
	КонецЕсли; 
	Возврат ПредставлениеДопустимыхТипов;

КонецФункции

Процедура ОткрытьОписаниеТипаПоГиперссылке(Знач ИмяОбщегоТипа) Экспорт 
	
	Если Истина
		И ирОбщий.СтрНачинаетсяСЛкс(ИмяОбщегоТипа, "_Тип")
		И мСтруктурыТиповПодсказкиУдержания.Свойство(ИмяОбщегоТипа) 
	Тогда 
		СтруктураТипа = мСтруктурыТиповПодсказкиУдержания[ИмяОбщегоТипа];
		Если ТипЗнч(СтруктураТипа) = Тип("ТаблицаЗначений") Тогда
			ТаблицаДляПользователя = мПлатформа.ТаблицаСтруктурТиповДляПользователя(СтруктураТипа, Ложь);
			СписокВыбора = Новый СписокЗначений;
			Для Каждого СтрокаТаблицы Из ТаблицаДляПользователя Цикл
				Если ирОбщий.СтрокиРавныЛкс(СтрокаТаблицы.Имя, "null") Тогда
					Продолжить;
				КонецЕсли; 
				СписокВыбора.Добавить(СтрокаТаблицы.СтруктураТипа, СтрокаТаблицы.Имя);
			КонецЦикла;
			СписокВыбора = ирОбщий.СвернутьСписокЗначенийПоПредставлениюЛкс(СписокВыбора);
			Если СписокВыбора.Количество() = 1 Тогда
				СтруктураТипа = СписокВыбора[0];
			Иначе
				СтруктураТипа = СписокВыбора.ВыбратьЭлемент("Выберите тип значения"); 
				Если СтруктураТипа = Неопределено Тогда
					Возврат;
				КонецЕсли; 
			КонецЕсли; 
			СтруктураТипа = СтруктураТипа.Значение;
		КонецЕсли; 
		ОткрытьОпределениеСтруктурыТипа(СтруктураТипа);
	Иначе
		ирОбщий.ОткрытьОписаниеТипаПоИмениТипаЛкс(ИмяОбщегоТипа);
	КонецЕсли; 

КонецПроцедуры

// антибаг редактора https://github.com/salexdv/bsl_console/issues/78#issuecomment-836447865
Функция ЧистоеСловоСпискаПодсказкиHTML(ВыбранноеСлово) Экспорт 
	
	Возврат ирОбщий.СтрокаМеждуМаркерамиЛкс(ВыбранноеСлово, "Элемент ", ",", Истина);

КонецФункции

Процедура РедакторHTML_ПередПоказомПодсказкиУдержания(Знач Событие, Знач ФункцияВычислитьВыражение) Экспорт 
	
	#Если Сервер И Не Сервер Тогда
		ПолеТекста = Обработки.ирОболочкаПолеТекста.Создать();
	#КонецЕсли
	НомерКолонки23 = Событие.params.column;
	НомерСтроки23 = Событие.params.line; 
	ТекущееСлово = Событие.params.word;
	мСтруктурыТиповПодсказкиУдержания = Новый Структура;
	Если ТекущееСлово = Неопределено Тогда 
		Возврат;
	КонецЕсли; 
	КончитьОбработкуКоманды();
	ОбъектноеВыражение = ТекущееОбъектноеВыражение(НомерСтроки23, НомерКолонки23,, Ложь);
	ПодсказкаМассив = Новый Массив;
	Если Истина
		И (Ложь
			Или Найти(ОбъектноеВыражение, "(") = 0 
			Или ирОбщий.СтрКончаетсяНаЛкс(ОбъектноеВыражение, "(") 
			Или ирОбщий.СтрНачинаетсяСЛкс(ОбъектноеВыражение, "("))
		И (Ложь
			Или ирОбщий.ЛиИмяПеременнойЛкс(Лев(ОбъектноеВыражение, 1)) 
			Или Лев(ОбъектноеВыражение, 1) = мПараметрыДиалектаSQL.ПрефиксПараметра
			Или Лев(ОбъектноеВыражение, 1) = "(")
	Тогда
		ФормаВладелец.КлсПолеТекстаПрограммыОбновитьКонтекст(ЭтотОбъект);
		ИмяТипаЗначения = "";
		Если Ложь
			Или (ЯзыкПрограммы > 0 И Лев(ОбъектноеВыражение, 1) = мПараметрыДиалектаSQL.ПрефиксПараметра)
			Или (ЯзыкПрограммы = 0 И Не ирОбщий.СтрКончаетсяНаЛкс(ОбъектноеВыражение, "("))
		Тогда
			УспехЗначения = Истина;
			ЗначениеВыражения = Вычислить("ФормаВладелец." + ФункцияВычислитьВыражение + "(ОбъектноеВыражение, УспехЗначения)");
			Если УспехЗначения Тогда
				ИмяТипаЗначения = ДобавитьПодсказкуПоЗначениюВыражения(ЗначениеВыражения, ОбъектноеВыражение, ПодсказкаМассив);
			КонецЕсли; 
		КонецЕсли; 
		ПредставлениеДопустимыхТипов = ДобавитьПодсказкуПоДопустимымТипам(ИмяТипаЗначения, ПодсказкаМассив, ОбъектноеВыражение);
	КонецЕсли; 
	КончитьОбработкуКоманды();
	СтруктураПодсказки = Новый Соответствие;
	СтруктураПодсказки.Вставить(ТекущееСлово.word, ПодсказкаМассив);
	РедакторHTML = ПолеТекста.РедакторHTML();
	РедакторHTML.setCustomHovers(ирОбщий.ОбъектВСтрокуJSONЛкс(СтруктураПодсказки));

КонецПроцедуры

Процедура РедакторHTML_ПередПоказомСигнатуры(НомерПараметра, ИмяМетодаОтРедактора, НомерСигнатуры, Триггер) Экспорт 
	
	Если РазрешеноСобытиеПередПоказомАвтодополнения = Ложь Или НомерСигнатуры > 0 Тогда
		// https://github.com/salexdv/bsl_console/issues/182
		РазрешеноСобытиеПередПоказомАвтодополнения = Истина;
		Возврат;
	КонецЕсли; 
	Если Триггер <> Неопределено И Не АвтоматическаяПодсказкаПоВызовуМетода() Тогда
		Возврат;
	КонецЕсли;
	#Если Сервер И Не Сервер Тогда
		ПолеТекста = Обработки.ирОболочкаПолеТекста.Создать();
	#КонецЕсли
	РедакторHTML = ПолеТекста.РедакторHTML();
	//РедакторHTML.hideSignatureList();
	Если Не ЛиДоступноОткрытиеСвободнойФормы() Тогда 
		КончитьОбработкуКоманды();
		ФормаВладелец.КлсПолеТекстаПрограммыОбновитьКонтекст(ЭтотОбъект);
		СтруктураПодсказки = СтруктураПодсказкиМетода(, Триггер <> Неопределено);
		Если СтруктураПодсказки.Количество() = 0 Тогда
			Возврат;
		КонецЕсли;
		ВариантыСинтаксиса = Новый Соответствие;
		ВариантыСинтаксиса.Вставить(ирОбщий.ПоследнийФрагментЛкс(ИмяМетодаОтРедактора, " "), СтруктураПодсказки);
		РедакторHTML.setCustomSignatures(ирОбщий.ОбъектВСтрокуJSONЛкс(ВариантыСинтаксиса));
		РедакторHTML.enableBeforeShowSuggestEvent(Ложь);
		РазрешеноСобытиеПередПоказомАвтодополнения = Ложь;
		РедакторHTML.triggerSigHelp();
		РедакторHTML.enableBeforeShowSuggestEvent(Истина);
		//ИмяМетодаОтРедактора = ФормаВызовМетода.ИмяМетода;
		//НомерПараметра = мНомерПараметра - 1;
	КонецЕсли;

КонецПроцедуры

Функция СтруктураПодсказкиМетода(Знач ПараметрСтруктураТипаКонтекста = Неопределено, Знач ТолькоПолезноеОписание = Истина, Знач ДляСпискаАвтодополнения = Ложь)
	
	СтруктураПодсказки = Новый Массив;
	ФормаВызовМетода = ФормаВызовМетода();
	ФормаВызовМетода.ПараметрСтруктураТипаКонтекста = ПараметрСтруктураТипаКонтекста;
	ФормаВызовМетода.ОбновитьИлиЗакрытьФорму(, Истина);
	Если Не ФормаВызовМетода.ЕстьПолезнаяИнформация И ТолькоПолезноеОписание Тогда
		Возврат СтруктураПодсказки;
	КонецЕсли; 
	Для ИндексВарианта = 0 По ФормаВызовМетода.ВариантыСинтаксиса.Количество() - 1 Цикл
		Если Истина
			И ФормаВызовМетода.ВариантыСинтаксиса.Количество() > 1 
		Тогда
			ФормаВызовМетода.УстановитьВариантСинтаксисаПоИндексу(ИндексВарианта);
		КонецЕсли; 
		ПодсказкаСлова = Новый Структура();
		ПараметрыМетода = Новый Массив;
		КраткиеОписанияПараметров = Новый Массив;
		Для Каждого СтрокаПараметра Из ФормаВызовМетода.ТаблицаПараметров Цикл
			ЛиНеОбязательный = ФормаВызовМетода.ЛиНеОбязательныйПараметр(СтрокаПараметра);
			СтруктураПараметра = Новый Структура();
			КраткоеПредставлениеПараметра = "" 
			//+ ?(СтрокаПараметра.Знач = "Знач", "`", СтрокаПараметра.Знач) 
			+ СтрокаПараметра.Имя 
			+ ?(ЛиНеОбязательный, "?", "");
			// Мало пользы, лишние неудобства при поиске нужного параметра. Поэтому пока отключено
			//Если ЗначениеЗаполнено(СтрЗаменить(СтрокаПараметра.ТипЗначения, "?", "")) Тогда
			//	КраткоеПредставлениеПараметра = КраткоеПредставлениеПараметра + " [" + ирОбщий.ПредставлениеЗначенияСОграничениемДлиныЛкс(СокрЛП(СтрокаПараметра.ТипЗначения), 20) + "]";
			//КонецЕсли; 
			КраткиеОписанияПараметров.Добавить(КраткоеПредставлениеПараметра);
			СтруктураПараметра.Вставить("label", КраткоеПредставлениеПараметра);
			ОписаниеПараметра = 
			"Обяз.: " + ?(Не ЛиНеОбязательный, "Да", "Нет, " + СтрокаПараметра.Значение) + ";  Возвр.: " + ?(Не ЗначениеЗаполнено(СтрокаПараметра.Знач), "?", ?(СтрокаПараметра.Знач = "Знач", "Нет", "Да")) + "
			|Тип: " + ирОбщий.ПредставлениеЗначенияСОграничениемДлиныЛкс(СокрЛП(СтрокаПараметра.ТипЗначения), 200) + ".";
			Если ЗначениеЗаполнено(СтрокаПараметра.Описание) Тогда
				ОписаниеПараметра = ОписаниеПараметра + "
				|> " + СтрокаПараметра.Описание;
			КонецЕсли; 
			СтруктураПараметра.Вставить("documentation", ОписаниеПараметра);
			ПараметрыМетода.Добавить(СтруктураПараметра);
		КонецЦикла;
		ПредставлениеМетода = "";
		Если Не ДляСпискаАвтодополнения Тогда
			ПредставлениеМетода = ПредставлениеМетода + ирОбщий.ПредставлениеЗначенияСОграничениемДлиныЛкс(ФормаВызовМетода.ИмяМетода, 13);
		КонецЕсли; 
		ПредставлениеМетода = ПредставлениеМетода + "(" + ирОбщий.СтрСоединитьЛкс(КраткиеОписанияПараметров, ", ") + ")";
		Если ЗначениеЗаполнено(ФормаВызовМетода.ТипЗначенияМетода) Тогда
			Если Не ДляСпискаАвтодополнения Тогда
				ПредставлениеМетода = ПредставлениеМетода + " [" + ирОбщий.ПредставлениеЗначенияСОграничениемДлиныЛкс(СокрЛП(ФормаВызовМетода.ТипЗначенияМетода), 15) + "]";
			КонецЕсли; 
		КонецЕсли; 
		ПодсказкаСлова.Вставить("label", ПредставлениеМетода);
		ПодсказкаСлова.Вставить("parameters", ПараметрыМетода);
		ОписаниеМетода = "";
		Если ЗначениеЗаполнено(ФормаВызовМетода.ТекущийВариант) Тогда
			ОписаниеМетода = ОписаниеМетода + "Вариант: " + ФормаВызовМетода.ТекущийВариант + "." + Символы.ПС;
		КонецЕсли;
		ОписаниеМетода = ОписаниеМетода + ФормаВызовМетода.ОписаниеМетода;
		ПодсказкаСлова.Вставить("documentation", ОписаниеМетода);
		СтруктураПодсказки.Добавить(ПодсказкаСлова);
	КонецЦикла;
	Возврат СтруктураПодсказки;

КонецФункции

Процедура РедакторHTML_ПередПоказомАвтодополнения(Триггер, ПоследнееВыражение, ПоследнееСлово)  Экспорт 
	
	#Если Сервер И Не Сервер Тогда
		ПолеТекста = Обработки.ирОболочкаПолеТекста.Создать();
	#КонецЕсли
	РедакторHTML = ПолеТекста.РедакторHTML();
	//РедакторHTML.hideSuggestionsList();
	Последние2Символа = Прав(ПоследнееВыражение, 2);
	ПрефиксПараметра = мПараметрыДиалектаSQL.ПрефиксПараметра;
	//Сообщить(Триггер);
	Если Ложь
		Или Триггер = "space"
		Или (Истина
			И АвтоматическаяПодсказкаАвтодополненияHTML()
			И (Ложь
				Или Триггер = Неопределено // ввод буквы или после выбора слова списка вводом "."
				Или Триггер = "." И Последние2Символа <> ".."
				Или ЯзыкПрограммы <> 0 И Триггер = ПрефиксПараметра И Последние2Символа <> (ПрефиксПараметра + ПрефиксПараметра)
				Или ЯзыкПрограммы = 0 И Триггер = """" И Последние2Символа <> """"""
				Или ирОбщий.ЛиИмяПеременнойЛкс(Триггер) // Иначе слишком часто вызывается затратное обновление списка слов локального контекста
				Или ЯзыкПрограммы = 0 И ирОбщий.СтрокиРавныЛкс(ПоследнееСлово, "новый")
				Или ЯзыкПрограммы = 0 И ирОбщий.СтрокиРавныЛкс(ПоследнееСлово, "new")))
	Тогда 
		Если Триггер = "backspace" Тогда
			РедакторHTML.enableBeforeShowSuggestEvent(Ложь);
			РедакторHTML.showPreviousCustomSuggestions();
			РедакторHTML.enableBeforeShowSuggestEvent(Истина);
		Иначе
			ФормаВызовМетода = ФормаВызовМетода();
			Если ФормаВызовМетода.Открыта() Тогда
				ФормаВызовМетода.Закрыть();
			КонецЕсли; 
			КончитьОбработкуКоманды();
			ФормаВладелец.КлсПолеТекстаПрограммыОбновитьКонтекст(ЭтотОбъект);
			РазобратьТекущийКонтекст();
			Если ЯзыкПрограммы = 0 И Триггер = """" Тогда
				ПоказатьСписок = мЭтоСтроковыйЛитерал;
			ИначеЕсли Истина
				И Триггер <> "space"
				И ЯзыкПрограммы = 1 
				И мЭтоОбъявлениеПсевдонима 
			Тогда
				ПоказатьСписок = Ложь;
			Иначе
				ПоказатьСписок = Не (мКонтекст = "" И Триггер = ".");
			КонецЕсли; 
			Если ПоказатьСписок Тогда
				РедакторHTML.enableSuggestActivationEvent(Истина, Истина);  // Второй параметр включает отображение типов для всех слов списка автодополнения https://github.com/salexdv/bsl_console/issues/119
				УспехЗаполнения = ЗаполнитьТаблицуСлов(, мКонкретныйТипКонтекста, мСтруктураТипаКонтекста, Триггер = "space");
				Если Истина
					И УспехЗаполнения
					И (Ложь
						Или Триггер = "space"
						Или ТаблицаСлов.Количество() > 0)
				Тогда
					СтруктураПодсказки = Новый Массив;
					КодыТиповСлов = Новый Структура;
					СоответствиеТипаСлова();
					Для Каждого СтрокаСоответствия Из мСоответствиеТиповСловHTML Цикл
						Если Не ЗначениеЗаполнено(СтрокаСоответствия.Имя) Тогда
							Продолжить;
						КонецЕсли; 
						КодыТиповСлов.Вставить(СтрокаСоответствия.Имя, СоответствиеТипаСлова(СтрокаСоответствия.Имя).Код);
					КонецЦикла; 
					Для Каждого СтрокаСлова Из ТаблицаСлов Цикл
						ПодсказкаСлова = Новый Структура();
						ПодсказкаСлова.Вставить("name", СтрокаСлова.Слово);
						//ТекстВставки = СтрокаСлова.Слово;
						//ПодсказкаСлова.Вставить("text", ТекстВставки); // Закомментировал, т.к. пользы от этого нет, а вред есть https://github.com/salexdv/bsl_console/issues/171
						ПодсказкаСлова.Вставить("kind", КодыТиповСлов[СтрокаСлова.ТипСлова]);
						ПодсказкаСлова.Вставить("detail", СтрокаСлова.ТипЗначения);
						ПодсказкаСлова.Вставить("documentation", "_"); // Нужно чтобы окно детального описания открывалось
						СтруктураПодсказки.Добавить(ПодсказкаСлова);
					КонецЦикла;
					СтрокаСпискаАвтодополненияHTML = ирОбщий.ОбъектВСтрокуJSONЛкс(СтруктураПодсказки);
					Если СтрокаСпискаАвтодополненияHTML <> Неопределено Тогда
						РедакторHTML.setOption("showSnippetsOnCustomSuggestions", мСтруктураТипаКонтекста.ИмяОбщегоТипа = "Локальный"); // Штатные сниппеты https://github.com/salexdv/bsl_console/issues/200
						РедакторHTML.enableBeforeShowSuggestEvent(Ложь);
						РедакторHTML.showCustomSuggestions(СтрокаСпискаАвтодополненияHTML);
						РедакторHTML.enableBeforeShowSuggestEvent(Истина);
					КонецЕсли; 
				КонецЕсли;
			КонецЕсли;
		КонецЕсли; 
	КонецЕсли; 

КонецПроцедуры

Функция СоответствиеТипаСлова(Знач ВстроенныйТипСлова = "", Знач ИмяКлюча = "Имя")
	
	Если мСоответствиеТиповСловHTML = Неопределено Тогда
		мСоответствиеТиповСловHTML = ирОбщий.ТаблицаЗначенийИзТабличногоДокументаЛкс(ПолучитьМакет("ТипыСловHTML"));
		#Если Сервер И Не Сервер Тогда
			мСоответствиеТиповСловHTML = Новый ТаблицаЗначений;
		#КонецЕсли
		мСоответствиеТиповСловHTML.Колонки.Добавить("НКод");
		мСоответствиеТиповСловHTML.Индексы.Добавить("Имя");
		мСоответствиеТиповСловHTML.Индексы.Добавить("НКод");
		Для Каждого СтрокаТЗ Из мСоответствиеТиповСловHTML Цикл
			СтрокаТЗ.НКод = НРег(СтрокаТЗ.Код);
		КонецЦикла;
	КонецЕсли;
	НайденнаяСтрока = мСоответствиеТиповСловHTML.Найти(ВстроенныйТипСлова, ИмяКлюча);
	//Если НайденнаяСтрока = Неопределено Тогда
	//	НайденнаяСтрока = мСоответствиеТиповСловHTML[0];
	//КонецЕсли;
	Возврат НайденнаяСтрока;

КонецФункции

Процедура РедакторHTML_ПриВыбореСтрокиАвтодополнения(Триггер, ПоследнееВыражение, ВыбранноеСлово, ТипСловаHTML, ТекстВставки, ПоследнееСлово)  Экспорт 
	
	Если ирОбщий.СтрНачинаетсяСЛкс(Триггер, "force-") Тогда
		ПараметрЗакрытия = Прав(Триггер, 1);
		Если Найти(ПоследнееВыражение, ".") > 0 Тогда
			ВыделенныйТекст(ПараметрЗакрытия);
			Возврат;
		КонецЕсли; 
	Иначе
		ПараметрЗакрытия = Истина;
	КонецЕсли; 
	#Если Сервер И Не Сервер Тогда
		ПолеТекста = Обработки.ирОболочкаПолеТекста.Создать();
	#КонецЕсли
	РедакторHTML = ПолеТекста.РедакторHTML();
	РедакторHTML.hideSuggestionsList();
	КончитьОбработкуКоманды();
	РазобратьТекущийКонтекст();
	ОтборСлов = Новый Структура("Слово", ЧистоеСловоСпискаПодсказкиHTML(ВыбранноеСлово));
	ТипСлова = ТипСловаИзТипаСловаHTML(ТипСловаHTML);
	Если ТипСлова = "Шаблон" Тогда
		мНачальнаяКолонка = мНачальнаяКолонка - СтрДлина(ПоследнееСлово);
		УстановитьГраницыВыделения();
		РедакторHTML.insertSnippet(ТекстВставки);
		Возврат;
	КонецЕсли; 
	Если ЗначениеЗаполнено(ТипСлова)  Тогда
		ОтборСлов.Вставить("ТипСлова", ТипСлова);
	КонецЕсли; 
	НайденныеСтроки = ТаблицаСлов.НайтиСтроки(ОтборСлов);
	Если НайденныеСтроки.Количество() = 0 Тогда
		Возврат;
	КонецЕсли; 
	СтрокаТаблицыСлов = НайденныеСтроки[0];
	ВставитьВыбранноеСловоАвтодополнения(СтрокаТаблицыСлов, мКонкретныйТипКонтекста, мСтруктураТипаКонтекста,, ПараметрЗакрытия);
	Если ПараметрЗакрытия = "." Тогда
		РедакторHTML.triggerSuggestions();
	КонецЕсли; 
	Если мОткрытьСправкуПоПараметру = Истина Тогда
		Если ЛиДоступноОткрытиеСвободнойФормы() Тогда 
			ОткрытьСправкуПоПараметру(, Ложь); 
		Иначе
			РедакторHTML.triggerSigHelp();
		КонецЕсли;
	КонецЕсли; 

КонецПроцедуры

Функция ТипСловаИзТипаСловаHTML(Знач ТипСловаHTML)
	
	Перем ТипСлова;
	
	ТипСлова = СоответствиеТипаСлова(ирОбщий.ПоследнийФрагментЛкс(ТипСловаHTML, "-"), "НКод").Имя;
	Возврат ТипСлова;

КонецФункции

Функция ЛиДоступноОткрытиеСвободнойФормы()
	
	Возврат Не (ирКэш.ЛиСеансТолстогоКлиентаУПЛкс() Или ФормаВладелец.МодальныйРежим);

КонецФункции

Процедура РедакторHTML_ОбработатьСобытие(Событие) Экспорт 
	//Сообщить("Отладка. " + Событие.event);
	Если Событие.event = "EVENT_BEFORE_SIGNATURE" Тогда
		РедакторHTML_ПередПоказомСигнатуры(Событие.params.activeParameter, Событие.params.word, Событие.params.activeSignature, Событие.params.triggerCharacter);
	ИначеЕсли Событие.event = "EVENT_ON_SELECT_SUGGEST_ROW" Тогда
		РедакторHTML_ПриВыбореСтрокиАвтодополнения(Событие.params.trigger, Событие.params.last_expression, Событие.params.selected, Событие.params.kind, Событие.params.insert_text, Событие.params.last_word);
	ИначеЕсли Ложь
		Или Событие.event = "EVENT_ON_ACTIVATE_SUGGEST_ROW"
		Или Событие.event = "EVENT_ON_DETAIL_SUGGEST_ROW"
	Тогда
		РедакторHTML_ПриАктивацииСтрокиАвтодополнения(Событие.params.trigger, Событие.params.focused, Событие.params.row_id, Событие.params.sideDetailIsOpened, Событие.params.kind);
	ИначеЕсли Событие.event = "EVENT_BEFORE_SHOW_SUGGEST" Тогда
		РедакторHTML_ПередПоказомАвтодополнения(Событие.params.trigger, Событие.params.last_expression, Событие.params.last_word);
	КонецЕсли; 
КонецПроцедуры

Процедура РедакторHTML_ПриАктивацииСтрокиАвтодополнения(Триггер, ТекущееСлово, НомерСлова, ЛиОтдельноеОписаниеАктивно, ТипСловаHTML) Экспорт 
	
	// Показывать надо обязательно каждый раз, т.к. редактор забывает предыдущие уточнения типа
	#Если Сервер И Не Сервер Тогда
		ПолеТекста = Обработки.ирОболочкаПолеТекста.Создать();
	#КонецЕсли
	ТипСлова = ТипСловаИзТипаСловаHTML(ТипСловаHTML);
	Если ТипСлова = "Шаблон" Тогда
		Возврат;
	КонецЕсли; 
	РедакторHTML = ПолеТекста.РедакторHTML();
	СтрокаТаблицыСлов = ТаблицаСлов.Найти(ЧистоеСловоСпискаПодсказкиHTML(ТекущееСлово), "Слово");
	Если СтрокаТаблицыСлов <> Неопределено Тогда
		ТаблицаСтруктурТипов = УточнитьТипЗначенияВСтрокеТаблицыСлов(мСтруктураТипаКонтекста, СтрокаТаблицыСлов, ЛиОтдельноеОписаниеАктивно);
		СтруктураОписания = Новый Массив;
		Если мСтруктураТипаКонтекста.Конструктор Тогда
			ДетальноеОписаниеДляСписка = "";
		Иначе
			ДетальноеОписаниеДляСписка = СтрокаТаблицыСлов.ТипЗначения;
			Если ЗначениеЗаполнено(ДетальноеОписаниеДляСписка) Тогда
				СтруктураОписания.Добавить("> Тип: " + ДетальноеОписаниеДляСписка);
			КонецЕсли; 
		КонецЕсли; 
		Если ЛиОтдельноеОписаниеАктивно И ТаблицаСтруктурТипов <> Неопределено Тогда 
			Если Ложь
				Или мСтруктураТипаКонтекста.Конструктор
				Или СтрокаТаблицыСлов.ТипСлова = "Метод" 
			Тогда
				Если мСтруктураТипаКонтекста.Конструктор Тогда
					СтруктураТипа = мПлатформа.НоваяСтруктураТипа();
					СтруктураТипа.ИмяОбщегоТипа = "Глобальный";
					ТаблицаСтруктурТипов = мПлатформа.СвойстваТипаПредопределенные(СтруктураТипа, СтрокаТаблицыСлов.Слово, "Конструктор",, ЯзыкПрограммы, Конфигурация)[0].ТаблицаСтруктурТипов;
				КонецЕсли; 
				//ПараметрыМетода = мПлатформа.ТаблицаПараметровМетода(ТаблицаСтруктурТипов[0]);
				СтруктураПодсказкиМетода = СтруктураПодсказкиМетода(ТаблицаСтруктурТипов[0], Триггер <> Неопределено, Истина);
				Если СтруктураПодсказкиМетода.Количество() > 0 Тогда
					СтруктураОписания.Вставить(0, "> Параметры: " + СтруктураПодсказкиМетода[0].label);
					Если СтруктураПодсказкиМетода.Количество() > 1 Тогда
						СтруктураОписания.Вставить(0, "> Варианты: " + СтруктураПодсказкиМетода.Количество());
					КонецЕсли; 
					ОписаниеСлова = СтруктураПодсказкиМетода[0].documentation;
					Если ЗначениеЗаполнено(ОписаниеСлова) Тогда
						СтруктураОписания.Добавить("> Описание: " + ОписаниеСлова);
					КонецЕсли; 
				КонецЕсли; 
			КонецЕсли; 
		КонецЕсли; 
		СтруктураОписания.Добавить("> Определение: " + СтрокаТаблицыСлов.Определение);
		ДетальноеОписаниеОтдельное = ирОбщий.СтрСоединитьЛкс(СтруктураОписания, Символы.ПС);
		Если Триггер = "hover" Тогда
			РедакторHTML.setSuggestItemDetailById(НомерСлова, ДетальноеОписаниеДляСписка, ДетальноеОписаниеОтдельное);
		Иначе
			МаксВысотаТочек = 800;
			РедакторHTML.setActiveSuggestDetail(ДетальноеОписаниеДляСписка, ДетальноеОписаниеОтдельное, МаксВысотаТочек);
		КонецЕсли; 
	КонецЕсли; 

КонецПроцедуры

Процедура РедакторHTML_ОтключитьСочетанияПереключенияСигнатуры() Экспорт 
	
	#Если Сервер И Не Сервер Тогда
		ПолеТекста = Обработки.ирОболочкаПолеТекста.Создать();
	#КонецЕсли
	РедакторHTML = ПолеТекста.РедакторHTML();
	// https://github.com/salexdv/bsl_console/issues/130
	// Коды клавиш https://microsoft.github.io/monaco-editor/api/enums/monaco.keycode.html
	РедакторHTML.disableKeyBinding(512+16); // ALT(512)+ArrowUp(16)
	РедакторHTML.disableKeyBinding(512+18); // ALT(512)+ArrowDown(18)
	
КонецПроцедуры

Процедура РедакторHTML_ВключитьСочетанияПереключенияСигнатуры() Экспорт 
	
	#Если Сервер И Не Сервер Тогда
		ПолеТекста = Обработки.ирОболочкаПолеТекста.Создать();
	#КонецЕсли
	РедакторHTML = ПолеТекста.РедакторHTML();
	// https://github.com/salexdv/bsl_console/issues/130
	РедакторHTML.enableKeyBinding(528); // ALT(512)+ArrowUp(16)
	РедакторHTML.enableKeyBinding(530); // ALT(512)+ArrowDown(18)
	
КонецПроцедуры

Процедура РедакторHTML_ОбработатьКликНаГиперссылке(Событие, ФункцияПерейтиКОпределению, ФункцияВычислитьВыражение) Экспорт 
	#Если Сервер И Не Сервер Тогда
		ПолеТекста = Обработки.ирОболочкаПолеТекста.Создать();
	#КонецЕсли
	Если ПолеТекста.ОбработатьКликНаГиперссылке(Событие) Тогда 
		Возврат;
	КонецЕсли; 
	РедакторHTML = ПолеТекста.РедакторHTML();
	РедакторHTML.hideHoverList();
	ЗаголовокГиперссылки = Событие.params.label;
	ЗначениеГиперссылки = Событие.params.href;
	Если ЗаголовокГиперссылки = "Определение" Тогда
		Координаты = ирОбщий.СтрРазделитьЛкс(ЗначениеГиперссылки, ",");
		НомерСтроки = Число(Координаты[0]);
		НомерКолонки = Число(Координаты[1]);
		Если Не Вычислить("ФормаВладелец." + ФункцияПерейтиКОпределению + "(НомерСтроки, НомерКолонки)") Тогда 
			ПерейтиКОпределению(НомерСтроки, НомерКолонки);
		КонецЕсли; 
	ИначеЕсли ЗаголовокГиперссылки = "Знач" Тогда
		УспехВычисления = Истина;
		ЗначениеВыражения = Вычислить("ФормаВладелец." + ФункцияВычислитьВыражение + "(ЗначениеГиперссылки, УспехВычисления)");
		Если УспехВычисления Тогда
			ирОбщий.ОткрытьЗначениеЛкс(ЗначениеВыражения);
		КонецЕсли; 
	ИначеЕсли Ложь
		Или Лев(ЗаголовокГиперссылки, 1) = "["
		Или ЗаголовокГиперссылки = "Допустимые типы" 
	Тогда
		ОткрытьОписаниеТипаПоГиперссылке(ЗначениеГиперссылки);
	Иначе
		ОткрытьКонтекстнуюСправку(ЗначениеГиперссылки);
	КонецЕсли;
КонецПроцедуры

Процедура КомандаРедактораHTML(Команда)
	#Если Сервер И Не Сервер Тогда
		ПолеТекста = Обработки.ирОболочкаПолеТекста.Создать();
	#КонецЕсли
	РедакторHTML = ПолеТекста.РедакторHTML();
	РедакторHTML.editor.trigger("", Команда);
КонецПроцедуры

Процедура ЗаменитьВхожденияHTML()
	КомандаРедактораHTML("editor.action.changeAll");
КонецПроцедуры

Процедура СочетанияКлавишHTML()
	ирОбщий.ОткрытьТекстЛкс(ПолучитьМакет("СочетанияКлавишHTML").ПолучитьТекст(), "Сочетания клавиш HTML редактора", "Обычный", Истина, "СочетанияКлавишHTML");
КонецПроцедуры

Процедура ОткрытьКонструкторФорматнойСтроки(ФорматнаяСтрока)
	
	Конструктор = Новый КонструкторФорматнойСтроки();
	Попытка
		Конструктор.Текст = ФорматнаяСтрока;
	Исключение
		Инфо = ИнформацияОбОшибке();
		ирОбщий.СообщитьЛкс("Ошибка в тексте форматной строки:" + Символы.ПС + Инфо.Причина.Описание);
		Возврат;
	КонецПопытки;
	Если Конструктор.ОткрытьМодально() Тогда
		Результат = Конструктор.Текст;
		Результат = СтрЗаменить(Результат, "'", "");
		Результат = """" + Результат + """";
		ВыделенныйТекст(Результат);
	КонецЕсли; 
	
КонецПроцедуры

Процедура КонструкторФорматнойСтроки()
	
	ФорматнаяСтрока = СтрЗаменить(СтрЗаменить(ВыделитьТекстТекущегоСтроковогоЛитерала(), "|", ""), """", "");
	ОткрытьКонструкторФорматнойСтроки(ФорматнаяСтрока);
	
КонецПроцедуры

Процедура НайтиСледующееHTML()
	
	#Если Сервер И Не Сервер Тогда
		ПолеТекста = Обработки.ирОболочкаПолеТекста.Создать();
	#КонецЕсли
	РедакторHTML = ПолеТекста.РедакторHTML();
	РедакторHTML.nextMatch();

КонецПроцедуры

Процедура НайтиПредыдущееHTML()
	
	#Если Сервер И Не Сервер Тогда
		ПолеТекста = Обработки.ирОболочкаПолеТекста.Создать();
	#КонецЕсли
	РедакторHTML = ПолеТекста.РедакторHTML();
	РедакторHTML.previousMatch();
	
КонецПроцедуры

Процедура РедакторHTML_Перерисовать() Экспорт 
	#Если Сервер И Не Сервер Тогда
		ПолеТекста = Обработки.ирОболочкаПолеТекста.Создать();
	#КонецЕсли
	//ПолеТекста.Перерисовать();
	//ОбновитьПодсказкуПоВызовуМетода();
КонецПроцедуры

Процедура ПанельРедактораКодаПриСменеСтраницы(Знач ПанельРедактора, Знач Поле1, Знач Поле2, Знач ИсходныйТекст) Экспорт 
	
	#Если Сервер И Не Сервер Тогда
		Поле1 = Обработки.ирОболочкаПолеТекста.Создать();
		Поле2 = Обработки.ирОболочкаПолеТекста.Создать();
	#КонецЕсли
	ТекущаяСтраница = ПанельРедактора.ТекущаяСтраница;
	Если ТекущаяСтраница = ПанельРедактора.Страницы.РедакторHTML Тогда
		ЭтотОбъект.ПолеТекста = Поле2;
		ПолеТекста.ЗагрузитьСостояниеИзПоляТекстаЛкс(Поле1, ИсходныйТекст);
	Иначе
		ЭтотОбъект.ПолеТекста = Поле1;
		ПолеТекста.ЗагрузитьСостояниеИзПоляТекстаЛкс(Поле2, ИсходныйТекст);
	КонецЕсли;

КонецПроцедуры

#КонецЕсли

Процедура УстановитьКонфигурациюМетаданных(пКонфигурация = Неопределено, пКонтекстВыполнения = Неопределено, Знач ДиалектSQL = Неопределено, РасширенноеПолучениеМетаданныхADO = Ложь) Экспорт

	//Если ЯзыкПрограммы = 1 Тогда
		Если ДиалектSQL = Неопределено Тогда
			Если пКонфигурация <> Неопределено Тогда
				ЭтотОбъект.Конфигурация = пКонфигурация;
			Иначе
				ЭтотОбъект.Конфигурация = мПлатформа.мМетаданные;
			КонецЕсли; 
			Если ТипЗнч(Конфигурация) = Тип("ОбъектМетаданныхКонфигурация") Тогда
				ЭтотОбъект.мДиалектSQL = "1С";
			Иначе
				ЭтотОбъект.мДиалектSQL = "MSSQL";
				Попытка
					Пустышка = Конфигурация.Provider;
				Исключение
					Пустышка = Неопределено;
				КонецПопытки;
				Если Пустышка <> Неопределено Тогда
					// Это ADODB.Connection
					Если Конфигурация.State = 1 Тогда
						ДиалектSQL = Конфигурация.Properties("DBMS Name").Value;
					Иначе
						// Не меняем мДиалектSQL!
					КонецЕсли; 
				Иначе
					ДиалектSQL = "WQL";
				КонецЕсли; 
			КонецЕсли; 
		Иначе
			Если ирОбщий.СтрокиРавныЛкс(ДиалектSQL, "1С") Тогда
				ЭтотОбъект.Конфигурация = мПлатформа.мМетаданные;
			Иначе
				ЭтотОбъект.Конфигурация = пКонфигурация;
			КонецЕсли; 
		КонецЕсли;
		Если мДиалектыSQL = Неопределено Тогда
			Если мПлатформа.мДиалектыSQL = Неопределено Тогда
				мПлатформа.мДиалектыSQL = ирОбщий.ТаблицаЗначенийИзТабличногоДокументаЛкс(ПолучитьМакет("ДиалектыSQL"),,, Ложь, Истина);
			КонецЕсли; 
			ЭтотОбъект.мДиалектыSQL = мПлатформа.мДиалектыSQL;
		КонецЕсли; 
		Если мДиалектыSQL.Найти(ДиалектSQL, "Диалект") <> Неопределено Тогда 
			ЭтотОбъект.мДиалектSQL = ДиалектSQL;
		КонецЕсли; 
		ЭтотОбъект.мПараметрыДиалектаSQL = мДиалектыSQL.Найти(мДиалектSQL, "Диалект");
		ЭтотОбъект.мРасширенноеПолучениеМетаданныхADO = РасширенноеПолучениеМетаданныхADO = Истина;
	//Иначе
	//	Если пКонфигурация <> Неопределено Тогда
	//		ЭтотОбъект.Конфигурация = пКонфигурация;
	//	Иначе
	//		ЭтотОбъект.Конфигурация = мПлатформа.мМетаданные;
	//	КонецЕсли; 
	//КонецЕсли;
	
	//Если ирОбщий.СтрокиРавныЛкс(мДиалектSQL, "1С") Тогда
	//	мДоступныеТаблицыПолучены = Истина;
	//ИначеЕсли ирОбщий.СтрокиРавныЛкс(мДиалектSQL, "WQL") Тогда
	//	//ЗаполнитьДоступныеТаблицыWQL(); // Слишком долго
	//	мДоступныеТаблицыПолучены = Истина;
	//Иначе
	//	мДоступныеТаблицыПолучены = Ложь;
	//КонецЕсли; 
	ЭтотОбъект.КонтекстВыполнения = пКонтекстВыполнения;

КонецПроцедуры

// Очишает таблицу слов локального контекста.
//
// Параметры:
//  Нет.
//
Процедура ОчиститьТаблицуСловЛокальногоКонтекста() Экспорт

	Для Каждого СтрокаЛокальногоКонтекста Из ТаблицаЛокальногоКонтекста Цикл
		// Разрываем циклические ссылки в СтрокаОписания
		СтрокаЛокальногоКонтекста.ТаблицаСтруктурТипов = Неопределено;
	КонецЦикла;
	ТаблицаЛокальногоКонтекста.Очистить();

КонецПроцедуры

// <Описание функции>
//
// Параметры:
//  <Параметр1>  – <Тип.Вид> – <описание параметра>
//                 <продолжение описания параметра>;
//  <Параметр2>  – <Тип.Вид> – <описание параметра>
//                 <продолжение описания параметра>.
//
// Возвращаемое значение:
//               – <Тип.Вид> – <описание значения>
//                 <продолжение описания значения>;
//  <Значение2>  – <Тип.Вид> – <описание значения>
//                 <продолжение описания значения>.
//
Функция ПолучитьИнформациюОбОшибке(ТекстДляПроверки = Неопределено, СтартоваяСтрока = 0, СтартоваяКолонка = 0, Контекст = "", СамаяВложеннаяПричина = Ложь) Экспорт

	#Если Сервер И Не Сервер Тогда
		мПлатформа = Обработки.ирПлатформа.Создать();
	#КонецЕсли
	ТекстИнициализации = "";
	Если ЯзыкПрограммы = 0 Тогда
		Для Каждого ЛокальноеСлово Из ТаблицаЛокальногоКонтекста Цикл
			Если Истина
				И ТипТекста = "Алгоритм"
				И ЛокальноеСлово.ТипСлова = "Свойство" 
			Тогда
				ТекстИнициализации = ЛокальноеСлово.Слово + " = 0; " + ТекстИнициализации;
			КонецЕсли;
		КонецЦикла;
		Для Каждого СтрокаПараметра Из Параметры Цикл
			Если ТипТекста = "Алгоритм" 
				И СтрокаПараметра.Вход // Добавил 14.09.2019
			Тогда
				ТекстИнициализации = СтрокаПараметра.Имя + " = 0; " + ТекстИнициализации;
			КонецЕсли;
		КонецЦикла;
	КонецЕсли; 

	Если ТекстДляПроверки = Неопределено Тогда
		ТекстДляПроверки = ПолеТекста.ПолучитьТекст();
	КонецЕсли; 
	
	СтартоваяСтрока = 0;
	СтартоваяКолонка = 0;
	Если ЯзыкПрограммы = 1 Тогда
		ТекстЗапроса = ТекстДляПроверки;
		Если ТекстЗапроса <> "" Тогда
			Если ТипТекста = "Выражение" Тогда
				лКонтекстВыполнения = КонтекстВыполнения;
				лМетодВыполнения = МетодВыполнения;
				Попытка
					ИнформацияОбОшибке = мПлатформа.ВыполнитьПрограммныйКодВКонтексте(лКонтекстВыполнения, лМетодВыполнения, ТекстЗапроса, Истина);
				Исключение
					ИнформацияОбОшибке = ИнформацияОбОшибке();
				КонецПопытки;
				СтартоваяСтрока = -1;
			Иначе
				Если мДиалектSQL <> "1С" Тогда
					РезультатРазбора = Ложь;
					#Если Клиент Тогда
					РезультатРазбора = ЗагрузитьТекстВКонструктор(ТекстЗапроса);
					#КонецЕсли
					Если Не РезультатРазбора Тогда
						ИнформацияОбОшибке = 1;
					КонецЕсли; 
				Иначе
					Если ТипЗнч(КонтекстВыполнения) = Тип("Запрос") Тогда
						ПроверочныйЗапрос = Новый Запрос;
						ПроверочныйЗапрос.МенеджерВременныхТаблиц = КонтекстВыполнения.МенеджерВременныхТаблиц;
						ПроверочныйЗапрос.Текст = ТекстЗапроса;
						Попытка
							ПроверочныйЗапрос.НайтиПараметры();
						Исключение
							ИнформацияОбОшибке = ИнформацияОбОшибке();
						КонецПопытки;
					Иначе
						КонструкторЗапроса = Новый КонструкторЗапроса;
						КонструкторЗапроса.РежимКомпоновкиДанных = РежимКомпоновкиДанных;
						Попытка
							КонструкторЗапроса.Текст = ТекстЗапроса;
						Исключение
							ИнформацияОбОшибке = ИнформацияОбОшибке();
						КонецПопытки;
					КонецЕсли; 
				КонецЕсли;
			КонецЕсли; 
		КонецЕсли;
	ИначеЕсли ЯзыкПрограммы = 0 Тогда 
		ТекстДляВыполнения = ТекстИнициализации;
		Если ТипТекста = "Выражение" Тогда
			Если ТекстДляПроверки = "" Тогда
				ТекстДляПроверки = 0;
			КонецЕсли;
			ТекстДляВыполнения = ТекстДляВыполнения + "?(Истина, 0, " + Символы.ПС + ТекстДляПроверки + Символы.ПС + ")";
		Иначе
			//ТекстДляВыполнения = ТекстДляВыполнения + "Если Ложь Тогда " + Символы.ПС + ТекстДляПроверки + Символы.ПС + " КонецЕсли"; // Заменено 06.12.2011
			ТекстДляВыполнения = "Если Ложь Тогда " + ТекстДляВыполнения + Символы.ПС + ТекстДляПроверки + Символы.ПС + " КонецЕсли";
		КонецЕсли;
		Если Нрег(Контекст) = Нрег("Сервер") Тогда
			лКонтекстВыполнения = ирСервер;
			лМетодВыполнения = "ВыполнитьАлгоритм";
		Иначе
			лКонтекстВыполнения = КонтекстВыполнения;
			лМетодВыполнения = МетодВыполнения;
		КонецЕсли; 
		Попытка
			ИнформацияОбОшибке = мПлатформа.ВыполнитьПрограммныйКодВКонтексте(лКонтекстВыполнения, лМетодВыполнения, ТекстДляВыполнения, Истина);
		Исключение
			ИнформацияОбОшибке = ИнформацияОбОшибке();
		КонецПопытки;
		СтартоваяСтрока = - 1;
	ИначеЕсли ЯзыкПрограммы = 2 Тогда
		лКонтекстВыполнения = КонтекстВыполнения;
		лМетодВыполнения = МетодВыполнения;
		Попытка
			ИнформацияОбОшибке = мПлатформа.ВыполнитьПрограммныйКодВКонтексте(лКонтекстВыполнения, лМетодВыполнения, ТекстДляПроверки, Истина);
		Исключение
			ИнформацияОбОшибке = ИнформацияОбОшибке();
		КонецПопытки;
	КонецЕсли;
	Если СамаяВложеннаяПричина И ИнформацияОбОшибке <> Неопределено Тогда
		#Если Сервер И Не Сервер Тогда
			ИнформацияОбОшибке = ИнформацияОбОшибке();
		#КонецЕсли
		Пока ИнформацияОбОшибке.Причина <> Неопределено Цикл
			ИнформацияОбОшибке = ИнформацияОбОшибке.Причина;
		КонецЦикла;
	КонецЕсли; 
	Возврат ИнформацияОбОшибке;

КонецФункции

// Выполняет проверку синтаксиса программного кода или текста запроса.
//
// Параметры:
//  *СообщатьОбУспешнойПроверке - Булево, *Ложь;
//  *ТекстДляПроверки - Строка, *Неопределено - проверяемый текст (используется весь текст или этот).
//
// Возвращаемое значение:
//  Булево – результат проверки.
//
Функция ПроверитьПрограммныйКод(СообщатьОбУспешнойПроверке = Ложь, ТекстДляПроверки = Неопределено, Контекст = "") Экспорт
	
	СтартоваяСтрока = 0;
	СтартоваяКолонка = 0;
	ИнформацияОбОшибке = ПолучитьИнформациюОбОшибке(ТекстДляПроверки, СтартоваяСтрока, СтартоваяКолонка, Контекст);
	Если ЗначениеЗаполнено(Контекст) Тогда
		ПредставлениеКонтекста = " (Проверка " + Контекст + ")";
	КонецЕсли; 
	Если ИнформацияОбОшибке <> Неопределено Тогда
		Если ТипЗнч(ИнформацияОбОшибке) = Тип("ИнформацияОбОшибке") Тогда
			Если ФормаВладелец <> Неопределено Тогда
				ФормаВладелец.ТекущийЭлемент = ПолеТекста.ЭлементФормы;
			КонецЕсли; 
			ирОбщий.ПоказатьОшибкуВТекстеПрограммыЛкс(ПолеТекста, СтартоваяСтрока, СтартоваяКолонка, ЯзыкПрограммы, , ИнформацияОбОшибке, , ПредставлениеКонтекста);
		Иначе
			// Ошибка обработана и отображена ранее
		КонецЕсли; 
	Иначе
		Если СообщатьОбУспешнойПроверке Тогда
			ирОбщий.СообщитьСУчетомМодальностиЛкс(ирОбщий.ПредставлениеИзИдентификатораЛкс(ПолеТекста.ЭлементФормы.Имя) 
				+ ПредставлениеКонтекста + ": Синтаксических ошибок не обнаружено!");
		КонецЕсли;
	КонецЕсли;
	Возврат ИнформацияОбОшибке = Неопределено;
	
КонецФункции

Процедура СброситьРезультатРазбораПозицииВТексте()
	
	мНомерПараметра = 0;
	НачалоКонтекста = "";
	НачалоСлова = "";
	КонецКонтекста = "";
	выхЕстьТочкаСправа = Ложь;
	мРодительскийКонтекст = "";
	мКонтекст = "";
	мЭтоСтроковыйЛитерал = Ложь;
	мЭтоОбъявлениеПсевдонима = Ложь;
	мЭтоКонструктор = Ложь;
	мАргументы = "";
	мПервыйПараметр = "";
	мФактическиеПараметры = Новый Массив;

КонецПроцедуры

// Заменяет все печатаемые символы, кроме идентификаторов в кавычках, внутри комментариев и строковых литералов на заданный символ.
//
// Параметры:
//  Текст        – Строка;
//  СимволЗамена – Строка.
//
// Возвращаемое значение:
//   Строка.
//
Функция ЗалитьКомментарииИСтроковыеЛитералы(Знач Текст, СимволЗамена = " ", ЗалитьСтроковыеЛитералы = Ложь) Экспорт 

	RegExp.Global = Истина;
	RegExp.Multiline = Ложь;
	
	//// Старый вариант - 
	//Если Ложь
	//	Или ЯзыкПрограммы = 1
	//	Или ЯзыкПрограммы = 2
	//Тогда
	//	RegExp.Pattern = "(""" + шИмя+ "(?:\." + шИмя + ")*"")|(" + "//(:)?[^\n]*(?:\n|$)" + ")|(" + шСтрокаЗапроса + ")|(.|\n|\r)";
	//ИначеЕсли ЯзыкПрограммы = 0 Тогда
	//	RegExp.Pattern = "(""" + шИмя+ "(?:\." + шИмя + ")*"")|(" + "//(:)?[^\n]*(?:\n|$)" + ")|(" + шСтрокаПрограммы + ")|(.|\n|\r)";
	//КонецЕсли;
	//Результат = RegExp.НайтиВхождения(Текст);
	//RegExp.Pattern = "(\S)";
	//ЗалитыйТекст = "";
	//Для Каждого Match Из Результат Цикл
	//	НайденныйТекст = Неопределено;
	//	ТекстДляЗаливки = Неопределено;
	//	Если Match.SubMatches(1) <> Неопределено Тогда
	//		Если Истина
	//			И ЯзыкПрограммы = 0
	//			И Match.SubMatches(2) <> Неопределено
	//		Тогда
	//			НовыйТекстСтроки = Сред(Match.SubMatches(1), СтрДлина("//:") + 1) + Символы.ПС;
	//		Иначе
	//			ТекстДляЗаливки = Match.SubMatches(1);
	//		КонецЕсли;
	//	ИначеЕсли Match.SubMatches(3) <> Неопределено Тогда
	//		ТекстДляЗаливки = Match.SubMatches(3);
	//	ИначеЕсли Match.SubMatches(0) <> Неопределено Тогда 
	//		НовыйТекстСтроки = Match.SubMatches(0);
	//	ИначеЕсли Match.SubMatches(4) <> Неопределено Тогда 
	//		НовыйТекстСтроки = Match.SubMatches(4);
	//	КонецЕсли;
	//	Если ТекстДляЗаливки <> Неопределено Тогда
	//		ЗалитыйТекст = ЗалитыйТекст + RegExp.Заменить(ТекстДляЗаливки, СимволЗамена);
	//	Иначе
	//		ЗалитыйТекст = ЗалитыйТекст + НовыйТекстСтроки;
	//	КонецЕсли;
	//КонецЦикла;
	
	// Новый вариант. Значительно быстрее старого.
	// Количество символов в тексте меняется, но позиции строк сохраняются
	Если Ложь
		Или ЯзыкПрограммы = 1
		Или ЯзыкПрограммы = 2
	Тогда
		////RegExp.Pattern = "(""" + шИмя+ "(?:\." + шИмя + ")*"")|(" + "//(:)?[^\n]*" + ")|(" + шСтрокаЗапроса   + ")|(.|\n|\r)";
		//RegExp.Pattern = "(""" + шИмя+ "(?:\." + шИмя + ")*"")|(?:" + "//:([^\n]*)" + ")|(?:" + "//[^\n]*" + ")|(" + шСтрокаЗапроса + ")|(.|\n|\r)";
		RegExp.Pattern = "(""" + шИмя+ "(?:\." + шИмя + ")*"")|(?:" + "//:([^\n]*)" + ")|(?:" + "//[^\n]*" + ")|(" + шСтрокаЗапроса + ")|([\s\S])";
		ШаблонЗамены = "$1$2$3$4";
	ИначеЕсли ЯзыкПрограммы = 0 Тогда
		//RegExp.Pattern = "(""" + шИмя+ "(?:\." + шИмя + ")*"")|(" + "//(:)?[^\n]*" + ")|(" + шСтрокаПрограммы + ")|(.|\n|\r)";
		шОднострочнаяСтрокаПрограммыСКавычки = """(?:(?:"""")|[^""\n])*""?"; 
		шОднострочнаяСтрокаПрограммыСЧерты = "(?:(\n)\s*\|(?:(?:"""")|[^""\n])*""?)";
		//	+ шОднострочнаяСтрокаПрограммыСКавычки + "|" + шОднострочнаяСтрокаПрограммыСЧерты + "|(.|\n|\r)";
		RegExp.Pattern = "(""" + шИмя + "(?:\.[" + шБуква + "\d]+)*"")" // имена ProgId от COM объектов бывают "Forms.TextBox.1"
			+ "|(""(?:" + шИмя + "\s*,\s*)*" + шИмя + """)" // создание структуры
			+ "|" + "//:([^\n]*)" + "|" + "//[^\n]*|" + "(?:" + "#[^\n]*" + ")|" + "(?:" + "~" + шИмя + ")|";  // Присвоение типа выражению в комментарии
		ШаблонЗамены = "$1$2$3$4";
		Если ЗалитьСтроковыеЛитералы Тогда
			RegExp.Pattern = RegExp.Pattern + шОднострочнаяСтрокаПрограммыСКавычки + "|" + шОднострочнаяСтрокаПрограммыСЧерты + "";
			ШаблонЗамены = ШаблонЗамены + "$5";
		Иначе
			// http://www.hostedredmine.com/issues/885452
		КонецЕсли; 
		RegExp.Pattern = RegExp.Pattern + "|([\s\S])";
	КонецЕсли;
	ЗалитыйТекст = RegExp.Заменить(Текст, ШаблонЗамены);
	
	Если СтрДлина(ОригинальныйТекст) < 10000 Тогда // Долго на больших текстах!
		// Заливаем условия, чтобы проверка равенства в них не считалась присвоением
		// В будущем можно отказаться от этого блока и собирать все возможные типы, а потом давать юзеру выбирать.
		Если ЯзыкПрограммы = 0 Тогда
			RegExp.Pattern = "(" + шЕсли + ")|(" + шПока + ")";
			ЗалитыйТекстОригинал = ЗалитыйТекст;
			Результат = RegExp.НайтиВхождения(ЗалитыйТекстОригинал);
			ЗалитыйТекст = Новый ЗаписьXML;
			ЗалитыйТекст.УстановитьСтроку("");
			ТекущаяПозицияВОригинале = 1;
			Для Каждого Match Из Результат Цикл
				НайденныйТекст = Неопределено;
				НачалоТокена = "";
				КонецТокена = "";
				Если Match.SubMatches(0) <> Неопределено Тогда
					НайденныйТекст = Match.SubMatches(0);
					НачалоТокена = Match.SubMatches(1);
					КонецТокена = Match.SubMatches(3);
				ИначеЕсли Match.SubMatches(4) <> Неопределено Тогда
					НайденныйТекст = Match.SubMatches(4);
					НачалоТокена = Match.SubMatches(5);
					КонецТокена = Match.SubMatches(7);
				КонецЕсли;
				ЗалитыйТекст.ЗаписатьБезОбработки(Сред(ЗалитыйТекстОригинал, ТекущаяПозицияВОригинале, Match.FirstIndex + 1 - ТекущаяПозицияВОригинале));
				ЗалитыйТекст.ЗаписатьБезОбработки(НачалоТокена + RegExp.Заменить(Сред(НайденныйТекст, 1 + СтрДлина(НачалоТокена), СтрДлина(НайденныйТекст) - СтрДлина(НачалоТокена) - СтрДлина(КонецТокена)), СимволЗамена)
					+ КонецТокена);
				ТекущаяПозицияВОригинале = Match.FirstIndex + 1 + СтрДлина(Match.Value); 
			КонецЦикла;
			ЗалитыйТекст.ЗаписатьБезОбработки(Сред(ЗалитыйТекстОригинал, ТекущаяПозицияВОригинале));
			ЗалитыйТекст = ЗалитыйТекст.Закрыть();
		КонецЕсли; 
	КонецЕсли; 
	Возврат ЗалитыйТекст;

КонецФункции

Процедура ЗаполнитьЛокальныеСвойстваИМетодыПоТексту(ОчиститьТаблицуСлов = Истина, ВключатьКонструкции = Истина,
	УчитыватьРодительскийКонтекст = Ложь, ОбновитьТекстДляАнализа = Истина, ВключатьГлобальныйКонтекст = Ложь, Знач ТекстДляАнализа = "") Экспорт 

	#Если Сервер И Не Сервер Тогда
		мПлатформа = Обработки.ирПлатформа.Создать();
	#КонецЕсли
	Если ирОбщий.ПроверитьПлатформаНеWindowsЛкс(, "Заполнение параметров", Истина) Тогда
		Возврат;
	КонецЕсли; 
	Если Не ЗначениеЗаполнено(ТекстДляАнализа) Тогда
		Если ОбновитьТекстДляАнализа Тогда
			ТекстДляАнализа = ПолеТекста.ПолучитьТекст();
		КонецЕсли; 
	КонецЕсли; 
	Если ЗначениеЗаполнено(ТекстДляАнализа) Или ОбновитьТекстДляАнализа Тогда
		ТекстБезКомментариевИОпасныхСтрок = ЗалитьКомментарииИСтроковыеЛитералы(ТекстДляАнализа,, Истина);
	КонецЕсли; 
	Если ОчиститьТаблицуСлов Тогда
		ТаблицаСлов.Очистить();
	КонецЕсли;
	
	Если ВключатьКонструкции Тогда
		Если ЯзыкПрограммы = 0 Тогда
			СписокСловЯзыка = мПлатформа.ПолучитьСписокКлючевыхСловВстроенногоЯзыка();
		ИначеЕсли ЯзыкПрограммы = 1 Тогда
			ВключаяРусские = ТипЗнч(Конфигурация) = Тип("ОбъектМетаданныхКонфигурация");
			СписокСловЯзыка = мПлатформа.ПолучитьСписокКлючевыхСловЯзыкаЗапросов(РежимКомпоновкиДанных, ВключаяРусские, Истина);
		ИначеЕсли ЯзыкПрограммы = 2 Тогда
			//СписокСловЯзыка = мПлатформа.ПолучитьСписокКлючевыхСловЯзыкаЗапросов();
			СписокСловЯзыка = Новый СписокЗначений;
			СписокСловЯзыка.Добавить("РАЗЛИЧНЫЕ"); // Криво https://www.hostedredmine.com/issues/931487
		КонецЕсли;
		Для Каждого ЭлементСписка Из СписокСловЯзыка Цикл
			НоваяСтрока = ТаблицаСлов.Добавить();
			НоваяСтрока.Слово = ЭлементСписка.Значение;
			НоваяСтрока.НСлово = НРег(НоваяСтрока.Слово);
			НоваяСтрока.ТипСлова = "Конструкция";
			НоваяСтрока.Определение = "Предопределенный";
		КонецЦикла;
	КонецЕсли;
	Если ВключатьГлобальныйКонтекст Тогда
		СтруктураТипа = мПлатформа.НоваяСтруктураТипа();
		СтруктураТипа.ИмяОбщегоТипа = "Глобальный";
		СтруктураТипа.Метаданные = Метаданные;
		ТаблицаГлобальногоКонтекста = мПлатформа.ПолучитьТаблицуСловСтруктурыТипа(СтруктураТипа);
		Для Каждого СтрокаСлова Из ТаблицаГлобальногоКонтекста Цикл
			НоваяСтрока = ТаблицаСлов.Добавить();
			ЗаполнитьЗначенияСвойств(НоваяСтрока, СтрокаСлова); 
			НоваяСтрока.НСлово = НРег(НоваяСтрока.Слово);
			//НоваяСтрока.Слово = ЭлементСписка.Значение;
			//НоваяСтрока.ТипСлова = "Конструкция";
			//НоваяСтрока.Определение = "Предопределенный";
		КонецЦикла;
	КонецЕсли;
	
	//Поиск использованных свойств и методов данного контекста.
	Если Ложь
		Или Не УчитыватьРодительскийКонтекст
		Или мРодительскийКонтекст = ""
	Тогда
		Шаблон = "(?:(" + шИмя + ")\()"
			+ "|(?:(" + шПараметрЗапроса + ")"
				+ "|(" + шИмя + ")(?=(?:\.(?:" + шИмя + ")?)+|[^\(?:\." + шБуква + "\d]|$))"
			+ "|(?:[" + шБуква + "\d\.]+)"; // Эта часть нужна чтобы не находить дочерние свойства и методы
		КоличествоПодгрупп = 3;
	Иначе
		Шаблон = "(?:" + ирОбщий.ПреобразоватьТекстДляРегулярныхВыраженийЛкс(мРодительскийКонтекст) + "\.(" + шИмя + ")\()"
			+ "|(?:" + ирОбщий.ПреобразоватьТекстДляРегулярныхВыраженийЛкс(мРодительскийКонтекст) + "\.(" + шИмя + ")(?=[^\(?:" + шБуква + "\d]|$))"
			+ "|(?:[" + шБуква + "\d\.]+)";
		КоличествоПодгрупп = 2;
	КонецЕсли;
	RegExp.Global = Истина;
	ТаблицаСловТЗ = ТаблицаСлов.Выгрузить(, "НСлово, ТипСлова, Частота");
	ТаблицаСловТЗ.Индексы.Добавить("НСлово");
	RegExp.Pattern = "(?:" + шСтрокаПрограммы + "|" + шКомментарий + "|(?:Новый|New)\s+" + шИмя + "|" + Шаблон + ")";
	Результат = RegExp.НайтиВхождения(" " + ТекстБезКомментариевИОпасныхСтрок);
	Для Каждого Match Из Результат Цикл
		Подгруппа1 = Match.SubMatches(0);
		Подгруппа2 = Match.SubMatches(1);
		Если КоличествоПодгрупп = 3 Тогда
			Подгруппа3 = Match.SubMatches(2);
		Иначе
			Подгруппа3 = Неопределено;
		КонецЕсли; 
		Если Подгруппа1 <> Неопределено Тогда
			Слово = Подгруппа1;
			ТипСлова = "Метод";
		ИначеЕсли Подгруппа2 <> Неопределено Тогда
			Слово = Подгруппа2;
			ТипСлова = "Свойство";
		ИначеЕсли Подгруппа3 <> Неопределено Тогда 
			Слово = Подгруппа3;
			ТипСлова = "Свойство";
		Иначе 
			Продолжить;
		КонецЕсли;
		СтруктураКлюча = Новый Структура("НСлово", НРег(Слово));
		НайденныеСтроки = ТаблицаСловТЗ.НайтиСтроки(СтруктураКлюча);
		НоваяСтрока = Неопределено;
		Для Каждого НайденнаяСтрока Из НайденныеСтроки Цикл
			Если Ложь
				Или ЯзыкПрограммы = 1
				Или (Истина
					И ТипСлова = "Метод" 
					И НайденнаяСтрока.ТипСлова = "Метод")
				Или (Истина
					И ТипСлова <> "Метод" 
					И НайденнаяСтрока.ТипСлова <> "Метод")
			Тогда
				НоваяСтрока = НайденнаяСтрока;
				Прервать;
			КонецЕсли;
		КонецЦикла;
		Если НоваяСтрока = Неопределено Тогда 
			НоваяСтрока = ТаблицаСлов.Добавить();
			НоваяСтрока.Определение = "Статистический";
			НоваяСтрока.Слово = Слово;
			НоваяСтрока.НСлово = НРег(НоваяСтрока.Слово);
			НоваяСтрока.ТипСлова = ТипСлова;
		КонецЕсли;
		НоваяСтрока.Частота = НоваяСтрока.Частота + 1;
	КонецЦикла;
	ТаблицаСлов.ЗагрузитьКолонку(ТаблицаСловТЗ.ВыгрузитьКолонку("Частота"), "Частота");

КонецПроцедуры

//ирПортативный лФайл = Новый Файл(ИспользуемоеИмяФайла);
//ирПортативный ПолноеИмяФайлаБазовогоМодуля = Лев(лФайл.Путь, СтрДлина(лФайл.Путь) - СтрДлина("Модули\")) + "ирПортативный.epf";
//ирПортативный #Если Клиент Тогда
//ирПортативный 	Контейнер = Новый Структура();
//ирПортативный 	Оповестить("ирПолучитьБазовуюФорму", Контейнер);
//ирПортативный 	Если Не Контейнер.Свойство("ирПортативный", ирПортативный) Тогда
//ирПортативный 		ирПортативный = ВнешниеОбработки.ПолучитьФорму(ПолноеИмяФайлаБазовогоМодуля);
//ирПортативный 		ирПортативный.Открыть();
//ирПортативный 	КонецЕсли; 
//ирПортативный #Иначе
//ирПортативный 	ирПортативный = ВнешниеОбработки.Создать(ПолноеИмяФайлаБазовогоМодуля, Ложь); // Это будет второй экземпляр объекта
//ирПортативный #КонецЕсли
//ирПортативный ирОбщий = ирПортативный.ПолучитьОбщийМодульЛкс("ирОбщий");
//ирПортативный ирКэш = ирПортативный.ПолучитьОбщийМодульЛкс("ирКэш");
//ирПортативный ирСервер = ирПортативный.ПолучитьОбщийМодульЛкс("ирСервер");
//ирПортативный ирПривилегированный = ирПортативный.ПолучитьОбщийМодульЛкс("ирПривилегированный");

мПлатформа = ирКэш.Получить();
#Если Сервер И Не Сервер Тогда
	мПлатформа = Обработки.ирПлатформа.Создать();
#КонецЕсли
#Если Клиент Тогда
	СлужебноеПолеТекста = мПлатформа.СлужебноеПолеТекста;
#КонецЕсли 
ТаблицаЛокальногоКонтекста = Новый ТаблицаЗначений;
ТаблицаЛокальногоКонтекста.Колонки.Добавить("Слово");
ТаблицаЛокальногоКонтекста.Колонки.Добавить("нСлово");
ТаблицаЛокальногоКонтекста.Колонки.Добавить("Глобальное", Новый ОписаниеТипов("Булево"));
ТаблицаЛокальногоКонтекста.Колонки.Добавить("ТипСлова");
ТаблицаЛокальногоКонтекста.Колонки.Добавить("ТипЗначения");
ТаблицаЛокальногоКонтекста.Колонки.Добавить("Метаданные");
ТаблицаЛокальногоКонтекста.Колонки.Добавить("ТаблицаСтруктурТипов");
ТаблицаЛокальногоКонтекста.Колонки.Добавить("Значение");
ТаблицаЛокальногоКонтекста.Индексы.Добавить("Слово, ТипСлова");

ПравилаВычисленияФункций = Новый ТаблицаЗначений;
ПравилаВычисленияФункций.Колонки.Добавить("Слово");
ПравилаВычисленияФункций.Колонки.Добавить("нСлово");
ПравилаВычисленияФункций.Колонки.Добавить("ТипКонтекста");
ПравилаВычисленияФункций.Колонки.Добавить("Правило");
ПравилаВычисленияФункций.Индексы.Добавить("Слово, ТипКонтекста");

МассивЗащитыОтРекурсии = Новый Массив;
мРазбиратьКонтекст = Истина;
мРасширенноеПолучениеМетаданныхADO = Ложь;
//мДоступныеТаблицыПолучены = Ложь;
мАвтоКонтекстнаяПомощь = Ложь;
мИменаОбщихТиповПоИменамКлассовCOM = Новый Соответствие;
мСтруктурыТиповПодсказкиУдержания = Новый Структура;

ШиринаТабуляции = 4;

RegExp = ирОбщий.НовыйВычислительРегВыражений();
RegExp.IgnoreCase = Истина;
RegExp.MultiLine = Ложь;

шЛюбой       = мПлатформа.шЛюбой;
шБуква       = мПлатформа.шБуква;
шИмя         = мПлатформа.шИмя;
шЧисло       = мПлатформа.шЧисло;
шИндекс      = мПлатформа.шИндекс;
шСкобки      = мПлатформа.шСкобки;
шРазделитель = мПлатформа.шРазделитель;
шКомментарий = мПлатформа.шКомментарий;

шНачалоЧисла = "\d+(?:\.)?\d*";
шНачалоСкобок = "(\((?:[^\)\(]*?(?:(?:\([^\)]*?\)[^\)\(]*?)*)*\))?)";
шИмяСкобки = "(?:" + шИмя + "|\?|)" + шСкобки;

// Шаблоны программы

шДирективаПрепроцессора = "#[^\n]*\n";
шСтрокаПрограммы       = """(?:(?:"""")|[^""\n])*(?:" + шРазделитель + "*\|(?:(?:"""")|[^""\n])*)*(?:""|$)";
шНачалоСтрокиПрограммы = """(?:(?:"""")|[^""\n])*(?:" + шРазделитель + "*\|(?:(?:"""")|[^""\n])*)*(?:""|$)?";
шОператорПрограммы = "(?:(?:=|>|<|<>|<=|>=|\*|\/|\+|\-)|" + шРазделитель + "(?:И|ИЛИ|НЕ)" + шРазделитель + ")+";

шФрагментСтрокиПрограммы = "(?:""|\|)(?:(?:"""")|[^""\n$])*(?:""|\n|$)";
шНачалоТокена = "([" + шБуква + "\d]" + шРазделитель + "+|(?:\]|\)|" + шФрагментСтрокиПрограммы + "|;|^)" + шРазделитель + "*)";
шКонецТокена = "(" + шРазделитель + "+[" + шБуква + "\d]|" + шРазделитель + "*(?:\[|\(|" + шФрагментСтрокиПрограммы + "|;|$))";
шЕсли = шНачалоТокена + "(?:Если|ИначеЕсли)"  
	+ шКонецТокена + "(?:" + шФрагментСтрокиПрограммы + "|\." + шРазделитель + "*Тогда|\r|\n|.)*?" + "[^" + шБуква + "\d\.]"
	+ "Тогда" + шКонецТокена;
шПока = шНачалоТокена + "Пока" 
	+ шКонецТокена + "(?:" + шФрагментСтрокиПрограммы + "|\r|\n|.)*?" + "[^" + шБуква + "\d\.]"
	+ "Цикл" + шКонецТокена;
шВызватьИсключение = шНачалоТокена + "ВызватьИсключение" 
	+ шКонецТокена + "(?:" + шФрагментСтрокиПрограммы + "|\." + шРазделитель + "*;|\r|\n|.)*?;";

шОписаниеФункции = "Функция" + шРазделитель + "*(" + шИмя + ")" + шРазделитель + "*\(([^\)]*)\)(" + шРазделитель + "*Экспорт)?"
	+ "((?:(?:" + шСтрокаПрограммы + "|\." + шРазделитель + "*КонецФункции|\r|\n|.)*?))"
	+ "[^" + шБуква + "\d\.""]КонецФункции[^" + шБуква + "\d\.""]";

шОписаниеПроцедуры = "Процедура" + шРазделитель + "*(" + шИмя + ")" + шРазделитель + "*\(([^\)]*)\)(" + шРазделитель + "*Экспорт)?"
	+ "((?:(?:" + шСтрокаПрограммы + "|\." + шРазделитель + "*КонецПроцедуры|\r|\n|.)*?))"
	+ "[^" + шБуква + "\d\.""]КонецПроцедуры[^" + шБуква + "\d\.""]";
	
шОписаниеПеременной = "Перем" + шРазделитель + "*(" + шИмя + ")(" + шРазделитель + "+Экспорт)?" + шРазделитель + "*;";

шМодуль = "^((?:" + шОписаниеПеременной + "|" + шРазделитель + "|" + шДирективаПрепроцессора + ")*)"
	+ "((?:" + шОписаниеФункции + "|" + шОписаниеПроцедуры + "|" + шДирективаПрепроцессора + "|" + шРазделитель + ")*)((?:\r|\n|.)*)$";

//шВыражениеПрограммы       = "(?:" + шРазделитель + "*(?:(?:" + шИмяСкобки + "?" + "(?:(?:\.(?:" + шИмя + ")" + шСкобки + "?)|" + шИндекс + ")*)|"
//	+ шЧисло + "|" + шСтрокаПрограммы + ")" + шРазделитель + "*" + шОператорПрограммы + ")*" 
//	+ шРазделитель + "*(?:(?:" + шИмяСкобки + "?" + "(?:(?:\.(?:" + шИмя + ")" + шСкобки + "?)|" + шИндекс + ")*)|"
//	+ шЧисло + "|" + шСтрокаПрограммы + ")";
//шВыражениеПрограммы       = "(?:" + шРазделитель + "*" + шОператорПрограммы + шРазделитель + "*"
//	+ "(?:(?:" + шИмяСкобки + "?" + "(?:(?:\.(?:" + шИмя + ")" + шСкобки + "?)|" + шИндекс + ")*)|"
//	+ шЧисло + "|" + шСтрокаПрограммы + ")*)*";
//шВыражениеПрограммы       = "(?:" + шРазделитель + "*"
//	+ "(?:новый)" + "(?:" + шРазделитель + "(?:" + шИмя + "))?" + шРазделитель + "*" + "(?:\(""(?:" + шИмя+ "(?:\." + шИмя + ")*))?|(?:"
//	+ "(?:*" + шОператорПрограммы + шИмяСкобки + "?" + "(?:(?:\.(?:" + шИмя + ")" + шСкобки + "?)|" + шИндекс + ")*)|"
//	+ шЧисло + "|" + шСтрокаПрограммы + ")" + шРазделитель + ")*" 
//	+ шРазделитель + "*(?:(?:" + шИмяСкобки + "?" + "(?:(?:\.(?:" + шИмя + ")" + шСкобки + "?)|" + шИндекс + ")*)|"
//	+ шЧисло + "|" + шСтрокаПрограммы + ")";

шВыражениеПрограммы1 = "(?:(?:новый|New)" + "(?:" + шРазделитель + "(?:" + шИмя + "))?" + шРазделитель + "*" + "(?:\(""(?:" + шИмя+ "(?:\." + шИмя + ")*)""\))?"
	+ "|(?:(?:не|not)" + шРазделитель + "+)?(?:(?:(?:новый|New)" + шРазделитель + ")?" + шИмяСкобки + "?" + "(?:(?:\.(?:" + шИмя + ")" + шСкобки + "?)|" + шИндекс + ")*)|"
	+ шЧисло + "|" + шСтрокаПрограммы + ")";
шВыражениеПрограммы = шРазделитель + "*" + шВыражениеПрограммы1 + "(?:" + шРазделитель + "*" + шОператорПрограммы + шРазделитель + "*"
	+ шВыражениеПрограммы1 + ")*";
	
шНачалоВыраженияПрограммы = "(?:" + шРазделитель + "*(?:(?:" 
	+ шИмяСкобки + "?" + "(?:(?:\.(?:" + шИмя + ")" + шСкобки + "?)|" + шИндекс + ")*)|"
	+ шЧисло + "|" + шСтрокаПрограммы + ")" + шРазделитель + "*" + шОператорПрограммы + ")*" 
	+ шРазделитель + "*(?:(?:" + шИмяСкобки + "?" + "(?:(?:\.(?:" + шИмя + ")" + шСкобки + "?)|" + шИндекс + ")*)|"
	+ шНачалоЧисла + "|" + шНачалоСтрокиПрограммы + ")?";

шВызовМетодаПрограммы = "(?:" + шПредИмя + "(Новый|New)\s+)?(" + шИмяСкобки + "?" + "(?:(?:\.(?:" + шИмя + ")" + шСкобки + "?)|" + шИндекс + ")*?)"
	+ "\(((?:(?:" + шВыражениеПрограммы + ")?" + шРазделитель + "*,)*)" + "(" + шНачалоВыраженияПрограммы + ")?" + шРазделитель + "*";

шПрисваивание = "(" + шРазделитель + "*=" + шРазделитель + "*((новый|New)" // Изменение для поддержки ProgID типа Forms.TextBox.1
	+ "(?:" + шРазделитель + "+(" + шИмя + "))?" + шРазделитель + "*(?:\(""(" + шИмя+ "(?:\.[" + шБуква + "\d]+)*)"")?|"
	+ "(" + шИмяСкобки + "?" + шИндекс + "?(?:\." + шИмяСкобки + "?" + шИндекс + "?)*)" + "|"
	+ "(" + шЧисло + ")|(" + шСтрокаПрограммы + ")))";

// Шаблоны запроса
шПараметрЗапроса = "(?:&|\?|@)[" + шБуква + "][" + шБуква + "\d]*";
шСтрокаЗапроса       = """(?:(?:"""")|[^""\n])*(?:""|\n|$)";
шНачалоСтрокиЗапроса = """(?:(?:"""")|[^""\n])*(?:""|\n|$)?";
шОператорЗапроса = "(?:(?:=|>|<|<>|<=|>=|\*|\/|\+|\-)|" + шРазделитель 
	+ "(?:И|AND|ИЛИ|OR|НЕ|NOT|МЕЖДУ|BETWEEN|ПОДОБНО|LIKE|ССЫЛКА|REFS|(?:ЕСТЬ|IS)" + шРазделитель + "+NULL|В|IN"
	+ "|В" + шРазделитель + "+ИЕРАРХИИ|IN" + шРазделитель + "+HIERARCHY)" + шРазделитель + ")+";
ШаблонВыбора = "(?:ВЫБОР|CASE)" + шЛюбой + "+?(?:КОГДА|WHEN)" + шЛюбой + "+?(?:ТОГДА|THEN)" + шЛюбой + "+?(?:ИНАЧЕ|ELSE)" + шЛюбой + "+?(?:КОНЕЦ|END)";
ШаблонНачалаВыбора = "(?:ВЫБОР|CASE)" + шЛюбой + "+?(?:КОНЕЦ|END)?";
шИмяЗапроса = "(?:" + шИмя + "|\[[^\]]+\])";
ШаблонТаблицы = "(" + шИмяЗапроса + "\.)*" + шИмяЗапроса + шСкобки + "?";
ШаблонСоединения = шРазделитель + "+((ПРАВОЕ|RIGHT|ЛЕВОЕ|LEFT|ВНУТРЕННЕЕ|INNER|ПОЛНОЕ|FULL|ВНЕШНЕЕ|OUTER)" + шРазделитель + "+)?(?:СОЕДИНЕНИЕ|JOIN)" 
	+ шРазделитель + "+";
	
ШаблонОписанияТаблицы = "(" + шСкобки + "|" + ШаблонТаблицы + "|&" + шИмя + ")" + шРазделитель
	+ "+(?:КАК|AS)" + шРазделитель + "+" + шИмяЗапроса;
	
шВыражениеЗапроса = "(?:" + шРазделитель + "*(?:" + шСкобки + "|(?:&|\?|@)" + шИмя + "|" + шЧисло + "|" + шСтрокаЗапроса + "|" + ШаблонВыбора
	+ "|" + шИмяСкобки + "?" + "(?:\." + шИмяСкобки + "?" + ")*)" + шРазделитель + "*" + шОператорЗапроса + ")*"
	+ шРазделитель + "*" + "(?:" + шСкобки + "|(?:&|\?|@)" + шИмя + "|" + шЧисло + "|" + шСтрокаЗапроса + "|" + ШаблонВыбора
	+ "|" + шИмяСкобки + "?" + "(?:\." + шИмяСкобки + "?" + ")*)";
	
шНачалоВыраженияЗапроса = "(?:" + шРазделитель + "*(?:" + шСкобки + "|(?:&|\?|@)" + шИмя + "|" + шЧисло + "|" + шСтрокаЗапроса + "|" + ШаблонВыбора
	+ "|" + шИмяЗапроса + шСкобки + "?" + "(?:\." + шИмяЗапроса + шСкобки + "?" + ")*)" + шРазделитель + "*" + шОператорЗапроса + ")*"
	+ шРазделитель + "*" + "(?:" + шСкобки + "|(?:&|\?|@)" + шИмя + "|" + шЧисло + "|" + шНачалоСтрокиЗапроса + "|" + ШаблонНачалаВыбора
	+ "|" + шИмяЗапроса + шСкобки + "?" + "(?:\." + шИмяЗапроса + шСкобки + "?" + ")*)?";
	
шВызовМетодаЗапроса = "()?(" + шИмяЗапроса + шСкобки + "?" + "(?:(?:\.(?:" + шИмяЗапроса + ")" + шСкобки + "?)|" + шИндекс + ")*)"
	+ "\(((?:(?:" + шВыражениеЗапроса + ")?" + шРазделитель + "*,)*)" + "(" + шНачалоВыраженияЗапроса + ")?" + шРазделитель + "*";
	
ШаблонОписанияПоля = шВыражениеЗапроса + шРазделитель + "+КАК" + шРазделитель + "+" + шИмяЗапроса;
ШаблонВЫБРАТЬ = "(?:ВЫБРАТЬ|SELECT)(" + шРазделитель + "+(?:РАЗРЕШЕННЫЕ|ALLOWED))?(" + ШаблонОписанияПоля + ",)*" + ШаблонОписанияПоля;
шИЗ = "(?:ИЗ|FROM)" + шРазделитель + "+" + ШаблонОписанияТаблицы + "(" + ШаблонСоединения + ШаблонОписанияТаблицы 
	+ шРазделитель + "+(?:ПО|ON)" + шРазделитель + "+" + шВыражениеЗапроса + "|" + шРазделитель + "*," 
	+ шРазделитель + "*" + ШаблонОписанияТаблицы + ")*";
шПоискОписанияТаблицы = "(" + ШаблонСоединения + ")?(" + шСкобки + "|" + ШаблонТаблицы + "|&" + шИмя 
	+ ")" + шРазделитель + "+(?:КАК|AS)" + шРазделитель + "+" + "#Идентификатор#(" + шРазделитель 
	+ "+(?:ПО|ON)" + шРазделитель + "+" + шВыражениеЗапроса + "|" + шРазделитель + "|,|\)|$)";
	
// К нему привязаны имена методов-трансляторов событий
ИмяКласса = "ПолеТекстаПрограммы";
мМаркерСлужебногоКомментария = "{: ";
СброситьРезультатРазбораПозицииВТексте();

