//ирПортативный Перем ирПортативный Экспорт;
//ирПортативный Перем ирОбщий Экспорт;
//ирПортативный Перем ирСервер Экспорт;
//ирПортативный Перем ирКэш Экспорт;
//ирПортативный Перем ирКлиент Экспорт;

Перем ИмяКласса Экспорт; 
Перем СсылочнаяФормаКласса Экспорт;
Перем ДопКнопкиКомандныхПанелей Экспорт;
Перем СоответствиеЭУ Экспорт;
Перем мФормаАвтодополнение Экспорт; 
Перем мФормаВызовМетода Экспорт; 
Перем мФормаВызовМетодаСкрытая Экспорт; 
Перем мФормаКласса; // см. Обработка.ирКлсПолеТекстаПрограммы.Форма.ФормаМакет
Перем мКодКлавишиОткрытияАвтодополнения;

Перем мРегВыражение Экспорт;
Перем мСлужебнаяФорма Экспорт; 
Перем СлужебноеПолеТекстаДолгое Экспорт;
Перем мПолеТекстаВременное Экспорт;
Перем мПарсер;
Перем мШиринаТабуляции Экспорт;
Перем мПлатформа Экспорт;
Перем мНачальнаяСтрока Экспорт; // снаружи только для чтения
Перем мНачальнаяКолонка Экспорт; // снаружи только для чтения
Перем мКонечнаяСтрока Экспорт; // снаружи только для чтения
Перем мКонечнаяКолонка Экспорт; // снаружи только для чтения
Перем мТекущаяСтрокаНачало Экспорт;
//Перем ОригинальнаяСтрока;
Перем мТекущаяСтрокаКонец;
Перем мНачалоКонтекста;
Перем мНачалоСлова;
Перем мКонецКонтекста; 
Перем мОригинальныйТекст Экспорт;
Перем мСтарыйОригинальныйТекст Экспорт;
Перем мТекстБезКомментариевИОпасныхСтрок Экспорт;
Перем мТекстБезТекстовыхЛитералов Экспорт;
Перем мТекстДляПоискаОпределения Экспорт; // Строка - во встроенном языке содержит полные строки до строки с кареткой
Перем мТекстБлока Экспорт;
Перем мПозицияТекстаДляПоискаОпределения Экспорт;
Перем мНачальнаяПозиция0ВложенногоТекста Экспорт;
Перем мРодительскийКонтекст Экспорт;
Перем мКонтекст Экспорт;  // Содержит текст родительского контекста и полное слово в текущем контексте (в нем находится каретка). Для отладки сделан экспортным
Перем мВызовМетода Экспорт;
Перем мЭтоТекстовыйЛитерал Экспорт;
Перем мЭтоОбъявлениеПсевдонима Экспорт;
Перем мТаблицаСловЛитерала; // см. мПлатформа.НоваяТаблицаСлов() 
Перем мТекущееСлово;
Перем мПозицияВТексте Экспорт;
Перем мПозицияВБлоке Экспорт;
Перем мПредшествующийТекст Экспорт;
Перем мКэшОжидаемогоТипа; // см. КэшОжидаемогоТипа
Перем мНомерПараметра Экспорт;
Перем мИмяМетодаВызова Экспорт;
Перем мЭтоКонструктор Экспорт;
Перем мФактическиеПараметры Экспорт; // Массив, 
Перем мПервыйФактическийПараметр;
Перем мРазбиратьКонтекст Экспорт;
Перем мРекурсивныйПуть Экспорт; // см. ИнициироватьРекурсивныйПуть, Неопределено
Перем мАвтоКонтекстнаяПомощь Экспорт;
Перем мРасширенноеПолучениеМетаданныхADO Экспорт;
Перем мПоследнийРежимВызоваСправки;
Перем мИменаОбщихТиповПоИменамКлассовCOM Экспорт;
Перем мДиалектSQL Экспорт;
Перем мДиалектыSQL Экспорт;
Перем мПараметрыДиалектаSQL Экспорт; 
Перем мПрефиксыПараметров Экспорт;
Перем мАнглийский1С Экспорт;
Перем мМаркерСлужебногоКомментария Экспорт;
Перем мМаркерПорядкаОтладки Экспорт;
Перем мОткрытьСправкуПоПараметру Экспорт; // снаружи только для чтения
Перем мМодульМетаданных Экспорт;  // см. мПлатформа.ПодготовитьМодульМетаданных()
Перем мИмяМодуля Экспорт;
Перем мСтруктурыТиповПодсказкиУдержания Экспорт;
Перем ИменаВсехКомКлассов;
Перем мКонкретныйТипКонтекста;
Перем мСтруктураТипаКонтекста Экспорт; // см. мПлатформа.НоваяСтруктураТипа()
Перем мТаблицаТиповКонтекста Экспорт; // см. мПлатформа.НоваяТаблицаТипов()
Перем мАгрегатныеТипыКонтекста Экспорт; // СписокЗначений
Перем мЭтоЛокальныйКонтекстТаблицыСлов Экспорт;
Перем мТолькоСсылочныеИменаТипов;
Перем мСоответствиеТиповСловHTML;
Перем РазрешеноСобытиеПередПоказомАвтодополнения;
Перем АвтоматическаяПодсказкаПоВызовуМетода Экспорт;
Перем АвтоматическаяПодсказкаАвтодополненияHTML Экспорт;
Перем АвтовставкаКвадратнойСкобки Экспорт;
Перем АвтовставкаДвойнойКавычки Экспорт;
Перем ПоказыватьВсеТипыВСпискеАвтодополненияHTML Экспорт;
Перем ПредпочитатьHTMLРедакторКода Экспорт;
Перем мЭтоАвтоВызов Экспорт;
Перем мМаксСловНаходитьВТекстеМетода Экспорт;
Перем мДоступныеПоляТаблиц Экспорт;  
Перем мМетодМодуля Экспорт; // см. мПлатформа.НоваяТаблицаМетодовМодуля()[0], Неопределено
Перем мНомерПервойСтрокиТелаМетода Экспорт;
Перем мНомерПоследнейСтрокиТелаМетода Экспорт;
Перем мИсторияПереходов;
Перем мФлагиКомпиляции Экспорт; // см. мПлатформа.НовыеФлагиКомпиляции()
Перем мКорневаяТаблицаТипов Экспорт;
Перем мОбъектИзКонфигуратора;
Перем мЯзыкПрограммы Экспорт; // - Может меняться на вложенный язык в РазобратьТекущийКонтекст()
Перем мПакетЗапросов Экспорт; // см. НовыйПакетЗапросов()
Перем мИндексЗапросаПакета Экспорт; 
Перем мМенеджерВременныхТаблиц Экспорт; // см. НовыйМенеджерВременныхТаблиц()
Перем мНаборыСлов Экспорт; // Соответствие, Неопределено
Перем мЗаменяемыйДиапазон Экспорт;
Перем мЗамещающийФрагмент Экспорт;
Перем мСтрокаЛучшегоСлова; // Неопределено, ОбработкаТабличнаяЧастьСтрока.ирКлсПолеТекстаПрограммы.ТаблицаСлов
Перем мИмяОжидаемогоТипа;
Перем мФлагиПодавленияОшибок; // Структура
Перем мКэшМетаданныхФайлов; // - монообъект
Перем мЭтоФрагментМетода Экспорт;

Перем шЧисло Экспорт;
Перем шЛюбой Экспорт;
Перем шБуква Экспорт;
Перем шЛитералПрограммы Экспорт;
Перем шНачалоЛитералаПрограммы Экспорт;
Перем шЛитералВЗапросе Экспорт;
Перем шИндекс Экспорт;
Перем шСкобки Экспорт;
Перем шСкобкиЛенивые Экспорт;
Перем шИмя Экспорт;
Перем шИмяСкобки Экспорт;
Перем шИмяСТочками Экспорт;
Перем шПараметрЗапроса Экспорт;
Перем шПредИмяПрямое Экспорт;
Перем шПостИмяСвойства Экспорт;
Перем шПредИнструкция Экспорт;
Перем шРазделитель Экспорт;
Перем шНазначениеТипаПриПрисвоении Экспорт;
Перем шВыражениеПрограммы Экспорт;
Перем шВыражениеЗапроса Экспорт;
Перем шВызовМетодаПрограммы Экспорт;
Перем шВызовМетодаЗапроса Экспорт;
Перем шИЗ Экспорт;
Перем шОписаниеТаблицы Экспорт;
Перем шОписаниеТаблицыСЗахватом Экспорт;
Перем шПока Экспорт;
Перем шЕсли Экспорт;
Перем шВызватьИсключение Экспорт;
Перем шНачалоТокена Экспорт;  
Перем шКонецТокена Экспорт;
Перем шКомментарий;
Перем шПрисвоение Экспорт;
Перем шПростоеВыражениеПрограммы Экспорт;
Перем шПоискОписанияТаблицы Экспорт;
Перем шСимволыПрефиксаПараметра Экспорт;
Перем шПрефиксПараметраНеобяз Экспорт;
Перем шПроверяемоеВыражение Экспорт;
Перем шОбъектноеВыражение Экспорт;
Перем шНачалоДок Экспорт;
Перем шОбходКоллекции Экспорт;

// Инициализирует экземпляр класса.
//
// Параметры:
//  *СтруктураЭкземляров - Структура, *Неопределено - содержит все объекты данного класса для данной формы;
//  пФорма       - Форма - владелец элементов управления;
//  пПолеТекстовогоДокумента - ПолеТекста;
//  *пКоманднаяПанель - КоманднаяПанель, *Неопределено - в конце которой будут размещены кнопки;
//  *пЛиЯзыкЗапросов - Булево, *Ложь - режим языка запросов, иначе внутренний язык;
//  *пМетодВыполнения - Строка, *"" - имя метода выполнения программного кода;
//  *пКонтекстВыполнения - Тип, Запрос, Произвольный, *Неопределено - контекст выполнения программного кода или текста запроса;
//  *пТипТекста  - Строка, *"Алгоритм" - "Алгоритм" или "Выражение".
//
Процедура ИнициироватьНеинтерактивно(пЯзыкПрограммы = 0, пМетодВыполнения = "", пКонтекстВыполнения = Неопределено, пТипТекста = "Алгоритм", пКонфигурация = Неопределено,
	Знач пПолеТекстовогоДокумента = Неопределено) Экспорт
	
	// Тут инициируем только экспортные переменные
	мПлатформа = ирКэш.Получить(); 
	#Если Клиент Тогда
		мПолеТекстаВременное = мПлатформа.СлужебноеПолеТекста;
	#КонецЕсли 
	мРасширенноеПолучениеМетаданныхADO = Ложь;
	мАвтоКонтекстнаяПомощь = Ложь;
	мРазбиратьКонтекст = Истина;
	мШиринаТабуляции = 4;
	мМаксСловНаходитьВТекстеМетода = 2000;
	мИменаОбщихТиповПоИменамКлассовCOM = Новый Соответствие;
	мСтруктурыТиповПодсказкиУдержания = Новый Структура;
	мДоступныеПоляТаблиц = Новый Соответствие;
	мРегВыражение = ирОбщий.НовоеРегВыражениеЛкс();
	мРегВыражение.IgnoreCase = Истина;
	мРегВыражение.MultiLine = Ложь;

	шЛюбой = мПлатформа.шЛюбой;
	шБуква = мПлатформа.шБуква;
	шИмя         = мПлатформа.шИмя;
	шЧисло       = мПлатформа.шЧисло;
	шИндекс      = мПлатформа.шИндекс;
	шСкобки      = мПлатформа.шСкобки;
	шРазделитель = мПлатформа.шРазделитель;
	шКомментарий = мПлатформа.шКомментарий;
	шЛитералПрограммы = мПлатформа.шЛитералПрограммы;
	шЛитералВЗапросе = мПлатформа.шЛитералВЗапросе;
	
	шЛитералПростой = мПлатформа.шЛитералПростой;
	шНачалоДок = "//[!:]"; 
	шНачалоЧисла = "\d+(?:\.)?\d*";
	// зависает на некорректном выражении ФорматДок.УстановитьФорматированнуюСтроку(Вычислить(Новый ФорматированнаяСтрока("" "", , ИсходныйЦвет)"));
	// Но видит на уровень глубже чем шСкобки, который 
	шМеждуСкобок = "[^\(\);""]";
	шСимволыПрефиксаПараметра = "&@~\?"; 

	// Если добавляем любой символ в конце, то вызывает бесконечный откат на тесте ("<?xml version=""1.0"" encoding=""UTF-8"" lns=""http://v8.1c.ru/8.2/roles"" xmlns:xs=""я"">")
	шСкобкиЛенивые = "(\((?:" + шМеждуСкобок + "*?(?:(?:(?:" + шЛитералПростой + "|\((?:" + "[^\);""]" + "|" + шЛитералПростой + ")*?\))" + шМеждуСкобок + "*?)*)*\))?)"; // МультиМетка82355611

	шИмяСкобки        = "(?:" + шИмя + "|\?|(?=\())" + шСкобки;
	шИмяСкобкиЛенивые = "(?:" + шИмя + "|\?|(?=\())" + шСкобкиЛенивые;
	шИмяСТочками = шИмя + "(?:\." + шИмя + ")*";
	шПредИмяПрямое = "(?:^|[^\d\." + шБуква + шСимволыПрефиксаПараметра + "])";
	шПостИмяСвойства = "(?=$|[^\d" + шБуква + "\(])";
	//шПредИнструкция = "(?:" + мПлатформа.шПустоеНачалоСтроки + "(?:" + шНачалоДок + "\s*)?|;\s*|Иначе\s+|Тогда\s+|Цикл\s+)"; // Редко полезно, а скорость снижает
	шПредИнструкция = "(?:" + мПлатформа.шПустоеНачалоСтроки + "(?:" + шНачалоДок + "\s*)?|;\s*)";

	// Шаблоны программы 

	шПрефиксПараметраНеобяз = "[" + шСимволыПрефиксаПараметра + "]?";
	шНачалоЛитералаПрограммы = шЛитералПрограммы + "?"; // опасно!
	шОператорПрограммы = "(?:(?:=|>|<|<>|<=|>=|\*|\/|\+|\-)|" + шРазделитель + "(?:И|ИЛИ|НЕ|AND|OR|NOT)" + шРазделитель + ")+";
	шНазначениеТипаПриПрисвоении = "(?:(?:[ \t]*;)?[ \t]*//([^\n]+))?";

	шФрагментЛитералаПрограммы = "(?:""|\|)(?:(?:"""")|[^""\n$])*(?:""|\n|$)";
	шНачалоТокена = "([" + шБуква + "\d]" + шРазделитель + "+|(?:\]|\)|" + шФрагментЛитералаПрограммы + "|;|^)" + шРазделитель + "*)";
	шКонецТокена = "(?=" + шРазделитель + "+[" + шБуква + "\d]|" + шРазделитель + "*(?:\[|\(|" + шФрагментЛитералаПрограммы + "|;|$))";
	шЕсли = шНачалоТокена + "(?:Если|ИначеЕсли|If|ElseIf)"  
		+ шКонецТокена + "(?:" + шФрагментЛитералаПрограммы + "|\." + шРазделитель + "*Тогда|\r|\n|.)*?" + "[^" + шБуква + "\d\.]"
		+ "(?:Тогда|Then)" + шКонецТокена;
	шПока = шНачалоТокена + "Пока" 
		+ шКонецТокена + "(?:" + шФрагментЛитералаПрограммы + "|\r|\n|.)*?" + "[^" + шБуква + "\d\.]"
		+ "Цикл" + шКонецТокена;
	шВызватьИсключение = шНачалоТокена + "ВызватьИсключение" 
		+ шКонецТокена + "(?:" + шФрагментЛитералаПрограммы + "|\." + шРазделитель + "*;|\r|\n|.)*?;";
	шОбъектноеВыражение = шИмяСкобки + "?" + "(?:(?:\.(?:" + шИмя + ")" + шСкобки + "?)|" + шИндекс + ")*";
	шПроверяемоеВыражение = "(([+=]\s*)?" + шЛитералПрограммы + "(?:\s*[+=;])?)|" + шКомментарий + "|(" + шПредИмяПрямое + ")(" + шИмяСкобки + "?" + шИндекс + "*(?:\." + шИмяСкобки + "?" + шИндекс + "*)+)";
	шОбходКоллекции = "(" + шРазделитель + "+Из" + шРазделитель + "+(" + шИмяСкобки + "?" + шИндекс + "*" + "(\." + шИмяСкобки + "?" + шИндекс + "*)*))\s*(?:Цикл|Do)?";

	// Не захватывает
	шВыражениеПрограммы1 = "(?:(?:новый|New)" + "(?:" + шРазделитель + "+(?:" + шИмя + "))?" + шРазделитель + "*" + "(?:\(""(?:" + шИмя+ "(?:\." + шИмя + ")*)""\))?"
		+ "|(?:(?:не|not)" + шРазделитель + "+)?(?:(?:(?:новый|New)" + шРазделитель + "+)?" + шОбъектноеВыражение + ")"
		+ "|" + шЧисло  
		+ "|" + шЛитералПрограммы + ")";
	шВыражениеПрограммы = шРазделитель + "*" + шВыражениеПрограммы1 + "(?:" + шРазделитель + "*" + шОператорПрограммы + шРазделитель + "*"
		+ шВыражениеПрограммы1 + ")*";
		
	шНачалоВыраженияПрограммы = "(?:" + шРазделитель + "*(?:(?:" 
		+ шОбъектноеВыражение + ")|"
		+ шЧисло + "|" + шЛитералПрограммы + ")" + шРазделитель + "*" + шОператорПрограммы + ")*" 
		+ шРазделитель + "*(?:(?:" + шОбъектноеВыражение + ")|"
		+ шНачалоЧисла + "|" + шНачалоЛитералаПрограммы + ")?";

	шВызовМетодаПрограммы = "()?"
		//+ "(" + мПлатформа.шПустоеНачалоСтроки + "(?!//)[^\n]*?" + ")" // Если раскомментировать, то очень долго разбирается текст - ВыделенныйТекст(СловоЯзыкаЗапросовВФорме("SELECT") + " " + ТекстВыбор + " " + СловоЯзыкаЗапросовВФорме("FROM") + " " + 1);
		+ "(?:" + шПредИмяПрямое + "(Новый|New)\s+)?(" + шОбъектноеВыражение + "?)"
		+ "\(((?:(?:" + шВыражениеПрограммы + ")?" + шРазделитель + "*,)*)" + "(" + шНачалоВыраженияПрограммы + ")?" + шРазделитель + "*";

	// Если брать шПрисвоенноеВыражениеПрограммы, то зависало в ВозможныеТекстовыеЗначенияВыраженияИзТекущегоМетода на тексте: Фу(1, новый Структура("П1, П2, П3", 1, 1, 1), 1)
	//шПростоеВыражениеПрограммы = "(?:(?:(?:(?:новый|New)\s+)?" + шИмяСкобки + "?" + шИндекс + "?(?:\." + шИмяСкобки + "?" + шИндекс + "?)*)"
	шПростоеВыражениеПрограммы = "(?:(?:(?:(?:новый|New)\s+)?" + шИмяСкобкиЛенивые + "?" + шИндекс + "*(?:\." + шИмяСкобкиЛенивые + "?" + шИндекс + "*)*)"
		+ "|(?:" + шЧисло + ")"
		+ "|(?:" + шЛитералПрограммы + ")"
		+ ")";

	шПрисвоенноеВыражениеПрограммы = "((новый|New)(?=[\s\(])" // Изменение для поддержки ProgID типа Forms.TextBox.1
		+ "(?:" + шРазделитель + "+(" + шИмя + "))?" + шРазделитель + "*(?:\(\s*(?:(" + шЛитералПрограммы + "|" + шИмяСТочками + шСкобки + "?)|[^\(\)]+)*?(?:\(|\)|$))?"
		//+ "|(" + шИмяСкобки + "?" + шИндекс + "?(?:\." + шИмяСкобки + "?" + шИндекс + "?)*)"
		+ "|(" + шИмяСкобкиЛенивые + "?" + шИндекс + "*(?:\." + шИмяСкобкиЛенивые + "?" + шИндекс + "*)*)(?:\s*[-/*%=<>])?" // Заменил на ленивые скобки, т.к. вложенность их может быть иногда большой и тогда надо хотя бы часть параметров захватить
		+ "|(" + шЧисло + ")"
		+ "|(" + шЛитералПрограммы + ")(?:\s*[+=<>])?"
		+ "|" // Пустая строка нужна чтобы посчитать количество присвоений
		+ ")";

	шПрисвоение = "(" + шРазделитель + "*=" + шРазделитель + "*(?:(?:Ждать|Await)" + шРазделитель + "+)?" + шПрисвоенноеВыражениеПрограммы + ")";

	// Шаблоны запроса
	шПараметрЗапроса = "[" + шСимволыПрефиксаПараметра + "][" + шБуква + "][" + шБуква + "\d]*";
	шНачалоЛитералаВЗапросе = шЛитералВЗапросе + "?"; // Опасно
	шОператорЗапроса = "(?:(?:=|>|<|<>|<=|>=|\*|\/|\+|\-)|" + шРазделитель 
		+ "(?:И|AND|ИЛИ|OR|НЕ|NOT|МЕЖДУ|BETWEEN|ПОДОБНО|LIKE|ССЫЛКА|REFS|(?:ЕСТЬ|IS)" + шРазделитель + "+NULL|В|IN"
		+ "|В" + шРазделитель + "+ИЕРАРХИИ|IN" + шРазделитель + "+HIERARCHY)" + шРазделитель + ")+";
	ШаблонВыбора = "(?:ВЫБОР|CASE)" + шЛюбой + "+?(?:КОГДА|WHEN)" + шЛюбой + "+?(?:ТОГДА|THEN)" + шЛюбой + "+?(?:ИНАЧЕ|ELSE)" + шЛюбой + "+?(?:КОНЕЦ|END)";
	ШаблонНачалаВыбора = "(?:ВЫБОР|CASE)" + шЛюбой + "+?(?:КОНЕЦ|END)?";
	шИмяЗапроса = "(?:" + шИмя + "|\[[^\]]+\])";
	шТаблицаЗапроса = "(" + шИмяЗапроса + "\.)*" + шИмяЗапроса + шСкобки + "?";
	ШаблонСоединения = шРазделитель + "+((ПРАВОЕ|RIGHT|ЛЕВОЕ|LEFT|ВНУТРЕННЕЕ|INNER|ПОЛНОЕ|FULL|ВНЕШНЕЕ|OUTER)" + шРазделитель + "+)?(?:СОЕДИНЕНИЕ|JOIN)" 
		+ шРазделитель + "+";
		
	шОписаниеТаблицы          = "(" + шСкобки + "|" + шТаблицаЗапроса + "|&" + шИмя + ")" + шРазделитель + "+(?:КАК|AS)" + шРазделитель + "+" + шИмяЗапроса;
	шОписаниеТаблицыСЗахватом = "(" + шСкобки + "|" + шТаблицаЗапроса + "|&" + шИмя + ")" + шРазделитель + "+(?:КАК|AS)" + шРазделитель + "+(" + шИмяЗапроса + ")";
		
	шВыражениеЗапроса = 
		"(?:" + шРазделитель + "*(?:" + шСкобки + "|(?:&|\?|@)" + шИмя + "|" + шЧисло + "|" + шЛитералВЗапросе + "|" + ШаблонВыбора
		//+ "|" + шИмяСкобки + "?" + "(?:\." + шИмяСкобки + "?" + ")*)" + шРазделитель + "*" + шОператорЗапроса + ")*"
		+ "|" + шИмяСкобки + "?" + "(?:\." + шИмяСкобки + "?" + ")*)" + шРазделитель + "*" + шОператорЗапроса + ")*?" // Сделал захват ленивым, чтобы избежать катастрофического шагания назад
		      + шРазделитель + "*(?:" + шСкобки + "|(?:&|\?|@)" + шИмя + "|" + шЧисло + "|" + шЛитералВЗапросе + "|" + ШаблонВыбора
		+ "|" + шИмяСкобки + "?" + "(?:\." + шИмяСкобки + "?" + ")*)(?:" + шРазделитель + "\{[^\}]*\})?";
		
	шНачалоВыраженияЗапроса = 
		"(?:" + шРазделитель + "*(?:" + шСкобки + "|(?:&|\?|@)" + шИмя + "|" + шЧисло + "|" + шЛитералВЗапросе + "|" + ШаблонВыбора
		+ "|" + шИмяЗапроса + шСкобки + "?" + "(?:\." + шИмяЗапроса + шСкобки + "?" + ")*)" + шРазделитель + "*" + шОператорЗапроса + ")*?" // Сделал захват ленивым, чтобы избежать катастрофического шагания назад
		      + шРазделитель + "*(?:" + шСкобки + "|(?:&|\?|@)" + шИмя + "|" + шЧисло + "|" + шНачалоЛитералаВЗапросе + "|" + ШаблонНачалаВыбора
		+ "|" + шИмяЗапроса + шСкобки + "?" + "(?:\." + шИмяЗапроса + шСкобки + "?" + ")*)?";
		
	шВызовМетодаЗапроса = "()?()?(" + шИмяЗапроса + шСкобки + "?" + "(?:(?:\.(?:" + шИмяЗапроса + ")" + шСкобки + "?)|" + шИндекс + ")*)"
		+ "\(((?:(?:" + шВыражениеЗапроса + ")?" + шРазделитель + "*,)*)" + "(" + шНачалоВыраженияЗапроса + ")?" + шРазделитель + "*";
		
	ШаблонОписанияПоля = шВыражениеЗапроса + шРазделитель + "+КАК" + шРазделитель + "+" + шИмяЗапроса;
	ШаблонВЫБРАТЬ = "(?:ВЫБРАТЬ|SELECT)(" + шРазделитель + "+(?:РАЗРЕШЕННЫЕ|ALLOWED))?(" + ШаблонОписанияПоля + ",)*" + ШаблонОписанияПоля;
	шИЗ = "(?:ИЗ|FROM)" + шРазделитель + "+" + шОписаниеТаблицы + "(" + ШаблонСоединения + шОписаниеТаблицы 
		+ шРазделитель + "+(?:ПО|ON)" + шРазделитель + "+" + шВыражениеЗапроса + "|" + шРазделитель + "*," 
		+ шРазделитель + "*" + шОписаниеТаблицы + ")*";
	шПоискОписанияТаблицы = "(" + ШаблонСоединения + ")?(" + шСкобки + "|" + шТаблицаЗапроса + "|&" + шИмя 
		+ ")" + шРазделитель + "+(?:КАК|AS)" + шРазделитель + "+" + "#Идентификатор#(" + шРазделитель 
		+ "+(?:ПО|ON)" + шРазделитель + "+" + шВыражениеЗапроса + "|" + шРазделитель + "|,|;|\)|$)";
		
	// К нему привязаны имена методов-трансляторов событий
	ИмяКласса = "ПолеТекстаПрограммы";
	мМаркерСлужебногоКомментария = "{: ";
	мМаркерПорядкаОтладки = "ПорядокОтладки ";
	мЭтоАвтоВызов = Ложь;
	мЭтоФрагментМетода = Ложь;
	//мОткрытьСправкуПоПараметру = Ложь;
	СброситьРезультатРазбораПозицииВТексте();    

	мАнглийский1С = Метаданные.ВариантВстроенногоЯзыка = Метаданные.СвойстваОбъектов.ВариантВстроенногоЯзыка.Английский; 
	мКэшМетаданныхФайлов = Новый Соответствие; 

	Если мСлужебнаяФорма = Неопределено Тогда 
		СоздатьСлужебноеПоле();
	КонецЕсли; 
	
	ЭтотОбъект.ЯзыкПрограммы = пЯзыкПрограммы;
	мЯзыкПрограммы = пЯзыкПрограммы;
	ЭтотОбъект.МетодВыполнения = пМетодВыполнения;
	ЭтотОбъект.ТипТекста = пТипТекста;
	#Если Не Клиент Тогда
		ЭтотОбъект.ПолеТекста = Новый ТекстовыйДокумент;
	#Иначе
		Если пПолеТекстовогоДокумента = Неопределено Тогда 
			пПолеТекстовогоДокумента = мПлатформа.НовоеСлужебноеПолеТекста(мСлужебнаяФорма, "1");
		КонецЕсли;
		ЭтотОбъект.ПолеТекста = ирКлиент.ОболочкаПоляТекстаЛкс(пПолеТекстовогоДокумента);
	#КонецЕсли                 
	УстановитьКонфигурациюМетаданных(пКонфигурация, пКонтекстВыполнения);
	мПрефиксыПараметров = мДиалектыSQL.Скопировать(, "ПрефиксПараметра");
	мПрефиксыПараметров.Свернуть("ПрефиксПараметра");
	мПрефиксыПараметров.ВыгрузитьКолонку(0); 
	
	Если ЯзыкПрограммы = 1 Тогда
		Если КонтекстВыполнения = Неопределено Тогда
			КонтекстВыполнения = Новый Запрос;
		КонецЕсли;  
	Иначе
		Если МетодВыполнения = "" Тогда
			ЭтотОбъект.МетодВыполнения = "ВыполнитьЛокально";
		КонецЕсли;
		Если КонтекстВыполнения <> Неопределено Тогда
			Попытка
				ПроверитьПрограммныйКод(, "");
			Исключение
				ирОбщий.СообщитьСУчетомМодальностиЛкс(ОписаниеОшибки());
				ирОбщий.СообщитьСУчетомМодальностиЛкс("Задан неверный контекст выполнения программы. Будет использован общий контекст выполнения");
				ЭтотОбъект.КонтекстВыполнения = ЭтотОбъект;
				ЭтотОбъект.МетодВыполнения = "ВыполнитьПрограмму";
			КонецПопытки;
		КонецЕсли;
	КонецЕсли;
	
КонецПроцедуры

Процедура СоздатьСлужебноеПоле() Экспорт
	мСлужебнаяФорма = мПлатформа.ПолучитьФорму("Служебная");
	СлужебноеПолеТекстаДолгое = мПлатформа.НовоеСлужебноеПолеТекста(мСлужебнаяФорма);
КонецПроцедуры

Процедура ПроверитьИнициировать() Экспорт 
	Если Не ЗначениеЗаполнено(ТипТекста) Тогда
		ИнициироватьНеинтерактивно();
	КонецЕсли;
КонецПроцедуры

#Если Клиент Тогда

// Инициализирует экземпляр класса.
//
// Параметры:
//  *СтруктураЭкземляров - Структура, *Неопределено - содержит все объекты данного класса для данной формы;
//  пФорма       - Форма - владелец элементов управления;
//  пПолеТекстовогоДокумента - ПолеТекста;
//  *пКоманднаяПанель - КоманднаяПанель, *Неопределено - в конце которой будут размещены кнопки;
//  *пЛиЯзыкЗапросов - Булево, *Ложь - режим языка запросов, иначе внутренний язык;
//  *пМетодВыполнения - Строка, *"" - имя метода выполнения программного кода;
//  *пКонтекстВыполнения - Тип, Запрос, Произвольный, *Неопределено - контекст выполнения программного кода или текста запроса;
//  *пТипТекста  - Строка, *"Алгоритм" - "Алгоритм" или "Выражение".
//
Процедура Инициализировать(СтруктураЭкземляров = Неопределено, пФорма, пПолеТекстовогоДокумента, пКоманднаяПанель = Неопределено, пЯзыкПрограммы = 0, пМетодВыполнения = "",
	пКонтекстВыполнения = Неопределено, пТипТекста = "Алгоритм", пКонфигурация = Неопределено, НеДобавлятьКнопкиЕслиСуществуют = Ложь, Знач пЭтоЧастиныйЗапрос = Ложь) Экспорт

	Если мПлатформа = Неопределено Тогда
		ИнициироватьНеинтерактивно(пЯзыкПрограммы, пМетодВыполнения, пКонтекстВыполнения, пТипТекста, пКонфигурация, пПолеТекстовогоДокумента);
	Иначе
		ЭтотОбъект.ПолеТекста = ирКлиент.ОболочкаПоляТекстаЛкс(пПолеТекстовогоДокумента);
		мФормаАвтодополнение = Неопределено;
		мФормаВызовМетода = Неопределено;
	КонецЕсли;
	#Если Сервер И Не Сервер Тогда
		мПлатформа = Обработки.ирПлатформа.Создать();
	#КонецЕсли
	мПлатформа.ПодключитьПерехватКлавиатуры();
	СсылочнаяФормаКласса = Ложь;
	КоманднаяПанель = пКоманднаяПанель;
	УстановитьФормуВладельца(пФорма); 
	ЭтотОбъект.ЭтоЧастичныйЗапрос = пЭтоЧастиныйЗапрос;
	
	Имя = ПолеТекста.ЭлементФормы.Имя;
	Если КоманднаяПанель = Неопределено Тогда
		КоманднаяПанель = ФормаВладелец.ЭлементыФормы.Добавить(Тип("КоманднаяПанель"), "КоманднаяПанель" + Имя, Ложь);
		ПолеТекста.ЭлементФормы.КонтекстноеМеню = КоманднаяПанель;
	КонецЕсли;
	
	мФормаКласса = мПлатформа.ПолучитьМакетКомпоненты(ЭтотОбъект); 
	КПМакета = мФормаКласса.ЭлементыФормы["КоманднаяПанель" + Формат(ЯзыкПрограммы, "ЧН=")]; // КоманднаяПанель
	КнопкиМакета = КПМакета.Кнопки;
	Если ЯзыкПрограммы = 1 Тогда
		КнопкаИсследоватьСхемуЗапроса = КнопкиМакета.Найти("ИсследоватьСхемуЗапроса");
		КнопкаФорматировать = КнопкиМакета.Найти("Форматировать");
		КнопкаВставитьИзБуфераОбменаВесьТекст = КнопкиМакета.Найти("ВставитьИзБуфераОбменаВесьТекст");
		КнопкаКопироватьВБуферОбменаВесьТекст = КнопкиМакета.Найти("КопироватьВБуферОбменаВесьТекст");
		КнопкиМакета = ирОбщий.МассивИзКоллекцииЛкс(КнопкиМакета);
		Если Не ирКэш.ДоступноСхемаЗапросаЛкс() Или ЭтоЧастичныйЗапрос Тогда
			КнопкиМакета.Удалить(КнопкиМакета.Найти(КнопкаИсследоватьСхемуЗапроса));
		КонецЕсли;
		Если ЭтоЧастичныйЗапрос Тогда
			КнопкиМакета.Удалить(КнопкиМакета.Найти(КнопкаФорматировать));
			КнопкиМакета.Удалить(КнопкиМакета.Найти(КнопкаВставитьИзБуфераОбменаВесьТекст));
			КнопкиМакета.Удалить(КнопкиМакета.Найти(КнопкаКопироватьВБуферОбменаВесьТекст));
		КонецЕсли;
	КонецЕсли;
	ирКлиент.ДобавитьКнопкиКоманднойПанелиКомпонентыЛкс(ЭтотОбъект, КнопкиМакета, КоманднаяПанель,,, НеДобавлятьКнопкиЕслиСуществуют);
	
	КнопкиМакета = мФормаКласса.ЭлементыФормы.КоманднаяПанельОбщая.Кнопки;
	Если ирКлиент.ЛиПерехватКлавиатурногоВводаЛкс() Тогда
		КнопкаВыполнитьШаблон = КнопкиМакета.ПодменюПолеПрограммы.Кнопки.Найти("ВыполнитьШаблон");
		ирОбщий.ОбновитьТекстПослеМаркераЛкс(КнопкаВыполнитьШаблон.Текст,, "Shift+Space");
		КнопкаВыполнитьШаблон.СочетаниеКлавиш = Новый СочетаниеКлавиш(Клавиша.Нет);
	КонецЕсли;
	Если пКоманднаяПанель = Неопределено Тогда
		КнопкаУстановитьФокус = КнопкиМакета.Найти("УстановитьФокус");
		КнопкиМакета = ирОбщий.МассивИзКоллекцииЛкс(КнопкиМакета);
		КнопкиМакета.Удалить(КнопкиМакета.Найти(КнопкаУстановитьФокус));
	КонецЕсли;
	ирКлиент.ДобавитьКнопкиКоманднойПанелиКомпонентыЛкс(ЭтотОбъект, КнопкиМакета, КоманднаяПанель,,, НеДобавлятьКнопкиЕслиСуществуют);
	
	Попытка
		ФормаВладелец.ПодключитьОбработчикОжидания("КлсПолеТекстаПрограммыАвтоОбновитьСправку", 100);;
		ФормаВладелец.ОтключитьОбработчикОжидания("КлсПолеТекстаПрограммыАвтоОбновитьСправку");
	Исключение
		//КоманднаяПанель.Кнопки.Удалить(ирКлиент.КнопкаКоманднойПанелиЭкземпляраКомпонентыЛкс(ЭтотОбъект, "АвтоКонтекстнаяПомощь"));
		Кнопка = ирКлиент.КнопкаКоманднойПанелиЭкземпляраКомпонентыЛкс(ЭтотОбъект, "АвтоКонтекстнаяПомощь");
		Кнопка.Доступность = Ложь;
	КонецПопытки;
	
	//ФайлШаблоновТекста = ирОбщий.ВосстановитьЗначениеЛкс(ИмяКласса + ".ФайлШаблоновТекста");
	//Если Ложь
	//	Или ТипЗнч(ФайлШаблоновТекста) <> Тип("Строка")
	//	Или ФайлШаблоновТекста = ""
	//Тогда
	//	КнопкаВыполнитьШаблон = ирКлиент.КнопкаКоманднойПанелиЭкземпляраКомпонентыЛкс(ЭтотОбъект, "ВыполнитьШаблон");
	//	КнопкаВыполнитьШаблон.Доступность = Ложь;
	//	КнопкаВыполнитьШаблон.СочетаниеКлавиш = Новый СочетаниеКлавиш(Клавиша.Нет); // Чтобы освободить сочетание клавиш
	//КонецЕсли; 
	
	Если СтруктураЭкземляров <> Неопределено Тогда
		СтруктураЭкземляров.Вставить(Имя, ЭтотОбъект);
	КонецЕсли;
	
КонецПроцедуры

Процедура УстановитьФормуВладельца(пФорма) Экспорт

	ФормаВладелец = пФорма;

КонецПроцедуры

// Освобождает ресурсы занятые экземпляром класса.
// Самое главное - очистить ссылки на формы и объекты БД.
//
// Параметры:
//  Нет.
//
Процедура Уничтожить() Экспорт

	Для Каждого Реквизит Из Метаданные().Реквизиты Цикл
		ЭтотОбъект[Реквизит.Имя] = Неопределено;
	КонецЦикла;
	Если мФормаВызовМетода <> Неопределено Тогда
		ЭтотОбъект.мФормаВызовМетода.ВладелецФормы = Неопределено;
	КонецЕсли; 
	ЭтотОбъект.мФормаВызовМетода = Неопределено;
	ЭтотОбъект.мФормаВызовМетодаСкрытая = Неопределено;
	Если ЭтотОбъект.мФормаАвтодополнение <> Неопределено Тогда
		ЭтотОбъект.мФормаАвтодополнение.ВладелецФормы = Неопределено;
	КонецЕсли; 
	ЭтотОбъект.мФормаАвтодополнение = Неопределено;
	ОчиститьТаблицуСловЛокальногоКонтекста();
	СохранитьСтатистикуВыбораПодсказки(Истина);

КонецПроцедуры

Процедура СохранитьСтатистикуВыбораПодсказки(Знач Принудительно = Ложь) Экспорт 
	Если мПлатформа.ТаблицаСтатистикиВыбора = Неопределено Тогда
		Возврат;
	КонецЕсли;
	Если Ложь
		Или Принудительно
		Или ЛиСохранитьСтатистикуВыбора() 
	Тогда
		ирОбщий.СохранитьЗначениеЛкс("ирПлатформа.ТаблицаСтатистикиВыбора", мПлатформа.ТаблицаСтатистикиВыбора);
		мПлатформа.ДатаПоследнегоСохраненияСтатистикиВыбора = ТекущаяДата();
	КонецЕсли;
КонецПроцедуры

Функция ЛиСохранитьСтатистикуВыбора() Экспорт
	Результат = ТекущаяДата() - мПлатформа.ДатаПоследнегоСохраненияСтатистикиВыбора > 600;
	Возврат Результат;
КонецФункции

Процедура ВнешнееСобытиеОбъекта(Источник, Событие, Данные) Экспорт 
	
	Если Источник <> "KeyboardHook" Тогда
		Возврат;
	КонецЕсли; 
	Если Ложь
		Или ФормаВладелец = Неопределено 
		Или Не ирКлиент.Форма_ВводДоступенЛкс(ФормаВладелец) // Для поля HTML это затратно
	Тогда
		Возврат;
	КонецЕсли;
	ирКлиент.Форма_ВнешнееСобытиеЛкс(ФормаВладелец, Источник, Событие, Данные);
	//Формат строки данные:
	//Первые 5 символов десятичное число в котором закодированы двоичные данные
	//биты 0-7 - виртуальный код клавиши (http://msdn.microsoft.com/en-us/library/dd375731%28v=VS.85%29.aspx)
	//бит 08 - 1 = нажата расширенная клавиша
	//бит 09 - 1 = Правый alt
	//бит 10 - 1 = Левый alt
	//бит 11 - 1 = Правый ctrl
	//бит 12 - 1 = Левый ctrl
	//бит 13 - 1 = Правый shift
	//бит 14 - 1 = Левый shift
	//
	//6 символ и возможно следующие символы могут быть или не быть (максимальное количество 10)
	//Это результат интерпретации клавиши с учетом языковой раскладки. (http://msdn.microsoft.com/en-us/library/ms646320%28v=VS.85%29.aspx)
	//
	ПолученноеЧисло	= Лев(Данные,5);
	ПолученноеЧисло	= Число(ПолученноеЧисло);
	ВиртуальнаяКлавиша	= ПолученноеЧисло % 256;
	ПолученноеЧисло		= ПолученноеЧисло - ВиртуальнаяКлавиша;
	РасширеннаяКлавиша	= ПолученноеЧисло % 512;
	ПолученноеЧисло		= ПолученноеЧисло - РасширеннаяКлавиша;
	ПравыйАльт	= ПолученноеЧисло % 1024;
	ПолученноеЧисло		= ПолученноеЧисло - ПравыйАльт;
	ЛевыйАльт	= ПолученноеЧисло % 2048;
	ПолученноеЧисло		= ПолученноеЧисло - ЛевыйАльт;
	ПравыйСонтрол	= ПолученноеЧисло % 4096;
	ПолученноеЧисло		= ПолученноеЧисло - ПравыйСонтрол;
	ЛевыйСонтрол	= ПолученноеЧисло % 8192;
	ПолученноеЧисло		= ПолученноеЧисло - ЛевыйСонтрол;
	ПравыйШифт	= ПолученноеЧисло % 16384;
	ПолученноеЧисло		= ПолученноеЧисло - ПравыйШифт;
	ЛевыйШифт	= ПолученноеЧисло;
	Если СтрДлина(Данные) > 5 Тогда
		Символ = Сред(Данные, 6);
	Иначе
		Символ = "";
	КонецЕсли;
	КодыКлавиш = ирКэш.КодыКлавишЛкс();
	Если ФормаВладелец.ТекущийЭлемент = ПолеТекста.ЭлементФормы Тогда
		Если Ложь
			Или Найти(Данные, КодыКлавиш["CTRL+ALT+Space"]) = 1
		Тогда
			#Если Сервер И Не Сервер Тогда
				ОткрытьАвтодополнение();
			#КонецЕсли
			ВыполнитьКоманду("ОткрытьАвтодополнение", Данные);
		ИначеЕсли Найти(Данные, КодыКлавиш["ALT+F2"]) = 1 Тогда
			// Антибаг платформы 8.3.19+ не обновляются пометки закладок
			ирКлиент.ОткрытьИЗакрытьПустуюФормуЛкс();
		ИначеЕсли Найти(Данные, КодыКлавиш["CTRL+[-]"]) = 1 Тогда
			#Если Сервер И Не Сервер Тогда
				ВернутьсяИзПерехода();
			#КонецЕсли
			ВыполнитьКоманду("ВернутьсяИзПерехода", Данные);
		ИначеЕсли Ложь
			Или Найти(Данные, КодыКлавиш["CTRL"]) = 1 // Мультиметка00452941 Так будет много лишних точек
			Или Найти(Данные, КодыКлавиш["CTRL+ALT+P"]) = 1 
			Или Найти(Данные, КодыКлавиш["CTRL+F3"]) = 1
			Или Найти(Данные, КодыКлавиш["CTRL+F"]) = 1
			Или Найти(Данные, КодыКлавиш["CTRL+G"]) = 1
			Или Найти(Данные, КодыКлавиш["F3"]) = 1
		Тогда 
			// Запоминание срабатывает после системной обработки сочетания!
			ЗапомнитьИсточникПерехода();
		ИначеЕсли Ложь
			Или Найти(Данные, КодыКлавиш["CTRL+C"]) = 1
			Или Найти(Данные, КодыКлавиш["CTRL+V"]) = 1 
		Тогда 
			// Мультиметка00452941 Удаляем избыточные точки истории
			УдалитьПоследнийПереходИзИстории();
		ИначеЕсли Найти(Данные, КодыКлавиш["SHIFT+Space"]) = 1 Тогда 
			ВыполнитьШаблонТекста();
		ИначеЕсли Ложь
			Или Найти(Данные, КодыКлавиш["CTRL+["]) = 1
			Или Найти(Данные, КодыКлавиш["CTRL+]"]) = 1 
		Тогда 
			// Мультиметка00452941 Удаляем избыточные точки истории
			ПерейтиКГраницеКонструкции();
		КонецЕсли; 
		Если Ложь
			Или ЛиДоступноОткрытиеСвободнойФормы()
			Или ТипЗнч(ПолеТекста.ЭлементФормы) = Тип("ПолеТекстовогоДокумента")
		Тогда
			// Подсказка по вызову метода
			ФормаВызовМетода = ФормаВызовМетода();
			БылаОткрыта = ФормаВызовМетода.Открыта();
			Если Ложь
				Или Найти(Данные, КодыКлавиш["CTRL+SHIFT+Space"]) = 1
			Тогда
				ВыполнитьКоманду("ПодсказатьПараметр");
			Иначе
				Если Истина
					И Не БылаОткрыта
					И ЛиДоступноОткрытиеСвободнойФормы()
					И (Ложь
						Или Символ = "(" 
						Или Символ = ",")
					И АвтоматическаяПодсказкаПоВызовуМетода()
				Тогда
					ВыполнитьКоманду("ПодсказатьПараметрАвто");
				КонецЕсли;
				Если БылаОткрыта Тогда
					ОбновитьПодсказкуПоВызовуМетода();
				КонецЕсли; 
				Если Ложь
					Или Найти(Данные, КодыКлавиш["ALT+Up"]) = 1
					Или Найти(Данные, КодыКлавиш["ALT+Down"]) = 1
					//Или Найти(Данные, КодыКлавиш["CTRL+Up"]) = 1
					//Или Найти(Данные, КодыКлавиш["CTRL+Down"]) = 1
					Или Найти(Данные, КодыКлавиш["Esc"]) = 1 // Работает только в поле HTML документа. В остальных местах платформа делает полный перехват 
				Тогда  
					ФормаВызовМетода.ВнешнееСобытие(Источник, Событие, Данные);      
				КонецЕсли; 
				ПриНажатииКлавишиАвтодополнение(Источник, Событие, Данные, Символ);
			КонецЕсли; 
			//_РежимОтладки = Ложь;  
			//Если _РежимОтладки Тогда // ирОбщий.Пр(_РежимОтладки,1,1)
			//	Сообщить(Данные); 
			//КонецЕсли;
		КонецЕсли; 
	КонецЕсли;

КонецПроцедуры

Процедура ПриНажатииКлавишиАвтодополнение(Источник, Событие, Данные, Символ) Экспорт
	Если ТипЗнч(ПолеТекста.ЭлементФормы) <> Тип("ПолеТекстовогоДокумента") Тогда 
		Возврат;
	КонецЕсли;  
	КодыКлавиш = ирКэш.КодыКлавишЛкс();
	ФормаАвтодополнение = ФормаАвтодополнение();
	БылаОткрыта = ФормаАвтодополнение.Открыта();
	Если БылаОткрыта Тогда
		Если Ложь
			Или Найти(Данные, КодыКлавиш["Enter"]) = 1
			Или Найти(Данные, КодыКлавиш["Up"]) = 1
			Или Найти(Данные, КодыКлавиш["Down"]) = 1
			Или Найти(Данные, КодыКлавиш["PgUp"]) = 1
			Или Найти(Данные, КодыКлавиш["PgDown"]) = 1
			Или Найти(Данные, КодыКлавиш["CTRL+F1"]) = 1
		Тогда
			Если ПолеТекста.ФиксированноеВыделениеДвумерное = Неопределено Тогда 
				ВыделениеДвумерное = ПолеТекста.ВыделениеДвумерное();
				ВыделениеДвумерное.НачальнаяКолонка = мНачальнаяКолонка;
				ВыделениеДвумерное.НачальнаяСтрока = мНачальнаяСтрока;
				ВыделениеДвумерное.КонечнаяКолонка = мКонечнаяКолонка;
				ВыделениеДвумерное.КонечнаяСтрока = мКонечнаяСтрока;
				ПолеТекста.ФиксированноеВыделениеДвумерное = ВыделениеДвумерное;
			КонецЕсли;
			ТекущаяСтрока = ФормаАвтодополнение.ЭлементыФормы.ТаблицаСлов.ТекущаяСтрока; 
			Если Истина
				И Найти(Данные, КодыКлавиш["Enter"]) = 1
				И ТекущаяСтрока <> Неопределено
				И ТекущаяСтрока.Слово = мКонтекст
				И (Ложь
					Или мКонтекст = "Тогда"
					Или мКонтекст = "Иначе"
					Или мКонтекст = "Цикл"
					Или мКонтекст = "Попытка"
					Или мКонтекст = "Исключение"
					Или мКонтекст = "КонецПроцедуры"
					Или мКонтекст = "КонецФункции")
			Тогда
				ФормаАвтодополнение.Закрыть();
			Иначе 
				ПолеТекста.УстановитьВыделениеДвумерное(ПолеТекста.ФиксированноеВыделениеДвумерное);
				// Подстраховка
				ПараметрыОбработчика = Новый Структура("ПолеТекста, Текст", ПолеТекста, ПолеТекста.ПолучитьТекст());
				ирКлиент.ПодключитьОбработчикОжиданияСПараметрамиЛкс("ирКлиент.АктивироватьЭлементФормыОтложенноЛкс", ПараметрыОбработчика,,, Ложь);
				Если Найти(Данные, КодыКлавиш["Enter"]) = 1 Тогда
					// Отменим вставленный перенос строки
					ВыделениеДвумерное = ПолеТекста.ВыделениеДвумерное();
					НоваяСтрока = ПолеТекста.ПолучитьСтроку(мКонечнаяСтрока + 1);
					ПолеТекста.УдалитьСтроку(мКонечнаяСтрока + 1);
					ПолеТекста.ЗаменитьСтроку(мКонечнаяСтрока, ПолеТекста.ПолучитьСтроку(мКонечнаяСтрока) + Сред(НоваяСтрока, ВыделениеДвумерное.НачальнаяКолонка));
				КонецЕсли;
				ФормаАвтодополнение.ВнешнееСобытие(Источник, Событие, Данные);
			КонецЕсли;
			Возврат;
		КонецЕсли;
	КонецЕсли;
	ПолеТекста.ФиксированноеВыделениеДвумерное = Неопределено;
	СтарыйКонтекст = мРодительскийКонтекст;
	Если Ложь
		//Или Найти(Данные, КодыКлавиш["CTRL+Space"]) = 1 
		Или Найти(Данные, КодыКлавиш["Tab"]) = 1
		Или Найти(Данные, КодыКлавиш["Space"]) = 1
		Или Найти(Данные, КодыКлавиш["Enter"]) = 1
	Тогда
		// Чтобы закрылась форма
		СтарыйКонтекст = Null;
	КонецЕсли;
	ПолучитьГраницыВыделения();
	ПрочитатьНачалоИКонецТекущейСтроки();   
	ЛиВнутриКомментария = ЛиВнутриКомментария();
	НачалоСтрокиДоСимвола = ирОбщий.СтрокаБезКонцаЛкс(мТекущаяСтрокаНачало);
	ПоследнийПечатныйСлева = Прав(СокрП(НачалоСтрокиДоСимвола), 1);
	ПервыйПечатныйСправа = Лев(СокрЛ(мТекущаяСтрокаКонец), 1);
	
	//Автовставки
	Если Истина
		И ЯзыкПрограммы = 0
		И Не ЛиВнутриКомментария
		И Найти(Данные, КодыКлавиш["Enter"]) = 1 
		И ирОбщий.ЛиВнутриТекстовогоЛитералаЛкс(ПолеТекста.ПолучитьСтроку(мКонечнаяСтрока - 1))
		И Лев(СокрЛ(ПолеТекста.ПолучитьСтроку(мКонечнаяСтрока)), 1) <> "|"
	Тогда
		ПолеТекста.ВыделенныйТекст("|");
	КонецЕсли; 
	Если Истина
		И мЯзыкПрограммы = 0
		И Не ЛиВнутриКомментария
		И Найти(Данные, КодыКлавиш["Enter"]) = 1 
		И мКонечнаяСтрока > 1
		И ирОбщий.СтрНачинаетсяСЛкс(СокрЛ(ПолеТекста.ПолучитьСтроку(мКонечнаяСтрока - 1)), "//", Истина)
		И Не ирОбщий.СтрНачинаетсяСЛкс(СокрЛ(ПолеТекста.ПолучитьСтроку(мКонечнаяСтрока)), "//", Истина)
		И мКонечнаяСтрока < ПолеТекста.КоличествоСтрок()
	Тогда
		СледующаяСтрока = НРег(СокрЛ(ПолеТекста.ПолучитьСтроку(мКонечнаяСтрока + 1)));
		Если Ложь
			Или ирОбщий.СтрНачинаетсяСЛкс(СледующаяСтрока, "//", Истина)
			Или ирОбщий.СтрНачинаетсяСЛкс(СледующаяСтрока, "&", Истина)
			Или ирОбщий.СтрНачинаетсяСЛкс(СледующаяСтрока, "Асинх")
			Или ирОбщий.СтрНачинаетсяСЛкс(СледующаяСтрока, "Процедура")
			Или ирОбщий.СтрНачинаетсяСЛкс(СледующаяСтрока, "Функция")
		Тогда
			ПолеТекста.ВыделенныйТекст("// ");
		КонецЕсли;
	КонецЕсли; 
	Если Истина
		И АвтовставкаДвойнойКавычки()
		И Символ = """"
		И мЯзыкПрограммы = 0
		И Не ЛиВнутриКомментария
		И Не ирОбщий.ЛиВнутриТекстовогоЛитералаЛкс(НачалоСтрокиДоСимвола)
		И Лев(СокрЛ(ПолеТекста.ПолучитьСтроку(мКонечнаяСтрока)), 1) <> "|"
		И (Ложь
			Или ПоследнийПечатныйСлева = ""
			Или ПоследнийПечатныйСлева = "("
			Или ПоследнийПечатныйСлева = "["
			Или ПоследнийПечатныйСлева = "="
			Или ПоследнийПечатныйСлева = "+"
			Или ПоследнийПечатныйСлева = ",")
		И (Ложь
			Или ПервыйПечатныйСправа = ""
			Или ПервыйПечатныйСправа = ")"
			Или ПервыйПечатныйСправа = "]"
			Или ПервыйПечатныйСправа = "+"
			Или ПервыйПечатныйСправа = ","
			Или ПервыйПечатныйСправа = ";")
	Тогда
		ПолеТекста.ВыделенныйТекст(Символ);
		УстановитьГраницыВыделения();
	КонецЕсли;
	Если Истина
		И АвтовставкаКвадратнойСкобки()
		И Символ = "["
		И мЯзыкПрограммы = 0
		И Не ЛиВнутриКомментария
		И Не ирОбщий.ЛиВнутриТекстовогоЛитералаЛкс(НачалоСтрокиДоСимвола)
		И Лев(СокрЛ(ПолеТекста.ПолучитьСтроку(мКонечнаяСтрока)), 1) <> "|"
		И (Ложь
			Или ирОбщий.ЛиБукваЛкс(ПоследнийПечатныйСлева)
			Или ПоследнийПечатныйСлева = ")")
		И (Ложь
			Или ПервыйПечатныйСправа = "" 
			Или ПервыйПечатныйСправа = ","
			Или ПервыйПечатныйСправа = "."
			Или ПервыйПечатныйСправа = ";")
		И Найти(мТекущаяСтрокаКонец, "]") = 0
	Тогда
		ПолеТекста.ВыделенныйТекст("]");
		УстановитьГраницыВыделения();
	КонецЕсли;
	
	ОбязательноОткрыть = Найти(Данные, КодыКлавиш["CTRL+Space"]) = 1;
	Если Истина
		И ЛиДоступноОткрытиеСвободнойФормы()
		И (Ложь
			Или ОбязательноОткрыть
			Или АвтоматическаяПодсказкаАвтодополненияHTML())
	Тогда 
		Если ЗначениеЗаполнено(мВызовМетода) Тогда
			мСтарыйОригинальныйТекст = ""; // Чтобы гарантировать разбор контекста при следующем вызове РазобратьТекущийКонтекст()
		КонецЕсли;
		РазобратьКонтекстСтроки();
		Если Истина
			И ФормаАвтодополнение.Открыта()
			И (Ложь
				Или СтарыйКонтекст <> мРодительскийКонтекст 
				Или Символ = """")
			//И Найти(Данные, КодыКлавиш["CTRL+Space"]) = 0
		Тогда
			ФормаАвтодополнение.Закрыть(); // Чтобы пересчитался родительский контекст
		КонецЕсли;
		Последние2Символа = Прав(мТекущаяСтрокаНачало, 2);
		Последние2Символа = СтрЗаменить(Последние2Символа, ";", ""); // Иначе будет открываться после ввода пробела после ";"
		Последние2СимволаНеРавны = Лев(Последние2Символа, 1) <> Прав(Последние2Символа, 1);
		Если Ложь
			Или ОбязательноОткрыть
			Или (Истина
				И Не БылаОткрыта 
				//И Не (ЯзыкПрограммы = 1 И мЭтоОбъявлениеПсевдонима)
				И (Ложь
					Или ирОбщий.СтрНачинаетсяСЛкс(Данные, "00") // Без модификаторов
					Или ирОбщий.СтрНачинаетсяСЛкс(Данные, "16") // Зажат шифт, (alt+shift+f=17478А), но сюда попадают и нажатия с CTRL
					)
				И Не ЛиВнутриКомментария
				//И ирОбщий.НайтиРегВыражениеЛкс(Символ, "[" + шБуква + "]").Количество() > 0 
				И ирОбщий.ЛиБукваЛкс(Символ))
			//Или ирОбщий.СтрКончаетсяНаЛкс(мТекущаяСтрокаНачало, "см. ") И ЛиВнутриКомментария И ЯзыкПрограммы = 0 // Только этого условия недостаточно
			Или Символ = "_"
			Или Символ = "&" И Последние2СимволаНеРавны И ЯзыкПрограммы = 1
			Или Символ = "~" И Последние2СимволаНеРавны И ЯзыкПрограммы = 0
			Или Символ = "#" И Последние2СимволаНеРавны И ЯзыкПрограммы = 0
			Или Символ = "." И Последние2СимволаНеРавны 
			Или Символ = "=" И Последние2СимволаНеРавны 
			Или Символ = " " И Последние2СимволаНеРавны
			
			// Автооткрытие в местах ожидания закрывающих программных скобок
			//Или (Истина
			//	И Найти(Данные, КодыКлавиш["Esc"]) <> 1 
			//	И ПустаяСтрока(мТекущаяСтрокаНачало) 
			//	И ПустаяСтрока(мТекущаяСтрокаКонец))
			
			// Вредно, т.к. мешает читать формальные параметры метода
			//Или Символ = "(" И Последние2СимволаНеРавны
			//Или Символ = ","
			
			//Или (Истина
			//	И Символ = " " 
			//	//И мЯзыкПрограммы = 1 // пока не рассчитан
			//	И (Ложь
			//		Или ирОбщий.СтрКончаетсяНаЛкс(СокрП(мТекущаяСтрокаНачало), " КАК")
			//		))
			Или Символ = """" И Последние2СимволаНеРавны И ирОбщий.ЛиВнутриТекстовогоЛитералаЛкс(мТекущаяСтрокаНачало) И ЯзыкПрограммы = 0
		Тогда
			//ВыполнитьКоманду("ОткрытьАвтодополнение", Данные, Ложь);
			мКодКлавишиОткрытияАвтодополнения = Данные;
			ирКлиент.ПодключитьОбработчикОжиданияОповещенияЛкс(ирКлиент.ОписаниеОповещенияЛкс("ОткрытьАвтодополнениеПассивно", ЭтотОбъект), ОбязательноОткрыть);
			СтарыйКонтекст = мРодительскийКонтекст;
		КонецЕсли;
	КонецЕсли;
	Если Ложь
		Или ОбязательноОткрыть
		Или Найти(Данные, КодыКлавиш["CTRL"]) = 1
		Или Найти(Данные, КодыКлавиш["Up"]) = 1
		Или Найти(Данные, КодыКлавиш["Down"]) = 1
		Или Найти(Данные, КодыКлавиш["PgUp"]) = 1
		Или Найти(Данные, КодыКлавиш["PgDown"]) = 1
	Тогда
		//  
	ИначеЕсли ФормаАвтодополнение.Открыта() Тогда  
		Если мКодКлавишиОткрытияАвтодополнения = Неопределено Тогда
			РазобратьКонтекстСтроки();
		КонецЕсли;
		//ПредпоследнееСлово = ""; // TODO
		//ПоказатьСписок = МожноПоказатьСписокСлов(Символ, мТекущаяСтрокаНачало, ПредпоследнееСлово);
		Если Ложь
			Или СтарыйКонтекст <> мРодительскийКонтекст 
			Или Прав(мКонтекст, 1) = ")"
			Или (Истина
				И Не ЗначениеЗаполнено(мКонтекст) 
				И Не мЭтоТекстовыйЛитерал 
				И Не ирОбщий.СтрКончаетсяНаЛкс(СокрП(мТекущаяСтрокаНачало), "=")
				И Не ирОбщий.ЛиВнутриПрепроцессораЛкс(мТекущаяСтрокаНачало))
		Тогда
			ФормаАвтодополнение.Закрыть();
			Возврат;
		КонецЕсли;
		ОбновитьФормуАвтодополнения(Данные);
	КонецЕсли; 
КонецПроцедуры

//.
// Параметры:
//    Данные - ?  -  
//    КодыКлавиш - Соответствие - 
//    ФормаАвтодополнение - Форма[Обработка.ирКлсПолеТекстаПрограммы.Форма.АвтодополнениеCOM] - 
Процедура ОбновитьФормуАвтодополнения(Данные = "") Экспорт
	ФормаАвтодополнение = ФормаАвтодополнение();
	ФормаАвтодополнение.НачальноеЗначениеВыбора = мСтрокаЛучшегоСлова;
	ФормаАвтодополнение.ОжидаемыйТип = мИмяОжидаемогоТипа;
	КодыКлавиш = ирКэш.КодыКлавишЛкс();
	Если Найти(Данные, КодыКлавиш["CTRL+Space"]) = 1 Тогда
		ФормаАвтодополнение.ДействияФормыПереключитьОтборИСортировку();
	ИначеЕсли ФормаАвтодополнение.ТекущееСлово <> мНачалоСлова Тогда
		ФормаАвтодополнение.ТекущееСлово = мНачалоСлова;
		ФормаАвтодополнение.ПриИзмененииОтбора();
	КонецЕсли;
КонецПроцедуры

Процедура ОткрытьАвтодополнениеПассивно() Экспорт
	Если Не ФормаАвтодополнение().Открыта() Тогда
		ВыполнитьКоманду("ОткрытьАвтодополнение", мКодКлавишиОткрытияАвтодополнения, Ложь);
		мКодКлавишиОткрытияАвтодополнения = Неопределено;
	КонецЕсли;
	Если ФормаАвтодополнение().Открыта() Тогда
		ОбновитьФормуАвтодополнения(мКодКлавишиОткрытияАвтодополнения);
	КонецЕсли;
КонецПроцедуры

Функция ЛиВнутриКомментария() Экспорт
	Возврат ирОбщий.ЛиВнутриКомментарияЛкс(мТекущаяСтрокаНачало);
КонецФункции

Процедура ОбновитьПодсказкуПоВызовуМетода() Экспорт
	
	ФормаВызовМетода = ФормаВызовМетода(Истина);
	Если Не ФормаВызовМетода.Открыта() Или Не ФормаВызовМетода.Автообновление Тогда
		Возврат;
	КонецЕсли; 
	//Если Форма.Открыта() Тогда
		ФормаВызовМетода.ОбновитьИлиЗакрытьФорму(, Истина);
	//КонецЕсли;

КонецПроцедуры

Функция ЛиМожноЗакрытьФорму() Экспорт 
	Результат = Истина;
	ФормаВызовМетода = ФормаВызовМетода();
	Если ФормаВызовМетода.Открыта() Тогда
		ФормаВызовМетода.Закрыть();
		Результат = Ложь;
	КонецЕсли; 
	ФормаАвтодополнение = ФормаАвтодополнение();
	Если ФормаАвтодополнение.Открыта() Тогда
		ФормаАвтодополнение.Закрыть();
		Результат = Ложь;
	КонецЕсли; 
	Возврат Результат;
КонецФункции

Функция ФормаВызовМетода(Знач ОчиститьПараметры = Ложь) Экспорт 

	Если мФормаВызовМетода = Неопределено Тогда
		мФормаВызовМетода = ПолучитьФорму("ВызовМетода", ФормаВладелец);
	КонецЕсли;
	Если ОчиститьПараметры Тогда
		мФормаВызовМетода.ПараметрПостояннаяСтруктураТипа = Неопределено; 
	КонецЕсли;
	Возврат мФормаВызовМетода;

КонецФункции 

// Процедура - Открыть прикрепленную форму вызова метода
//
// Параметры:
//  СтруктураТипаКонтекста	 - 
//  ЭтаФорма				 - Форма - 
//
Процедура ОткрытьПрикрепленнуюФормуВызоваМетода(Знач СтруктураТипаКонтекста, Знач ЭтаФорма = Неопределено) Экспорт 
	
	ТаблицаВладелец = СтруктураТипаКонтекста.СтрокаОписания.Владелец();
	#Если Сервер И Не Сервер Тогда
		ТаблицаВладелец = Новый ТаблицаЗначений;
	#КонецЕсли  
	Если Истина
		И ЭтаФорма <> Неопределено
		И Не ЭтаФорма.ВводДоступен()
		И ирКэш.ЛиСеансТолстогоКлиентаУПЛкс()
	Тогда
		// Иначе нажатия клавиш могу прийти в другое окно
		Возврат;
	КонецЕсли;
	ФормаВызовМетода = ПолучитьФорму("ВызовМетода", ЭтаФорма, "Прикрепленное");    
	Если Не ФормаВызовМетода.Открыта() Тогда
		ФормаВызовМетода.СоединяемоеОкно = Истина;
		ФормаВызовМетода.КлючСохраненияПоложенияОкна = ФормаВызовМетода.КлючУникальности;
		ФормаВызовМетода.СостояниеОкна = ВариантСостоянияОкна.Прикрепленное;
		ФормаВызовМетода.ПоложениеПрикрепленногоОкна = ВариантПрикрепленияОкна.Низ;
	КонецЕсли; 
	ФормаВызовМетода.ПараметрПостояннаяСтруктураТипа = СтруктураТипаКонтекста;
	Если ФормаВызовМетода.Открыта() Тогда
		ФормаВызовМетода.ОбновитьИлиЗакрытьФорму(); 
	Иначе
		ФормаВызовМетода.Открыть();
	КонецЕсли;

КонецПроцедуры
	
// Получает номер текущей строки в тексте (по конечной границе выделения).
//
// Параметры:
//  Нет.
//
// Возвращаемое значение:
//  Число.
//
Функция ПолучитьНомерТекущейСтроки(Начальной = Ложь) Экспорт

	Если ПолеТекста <> Неопределено Тогда
		ПолеТекста.ПолучитьГраницыВыделения(мНачальнаяСтрока, мНачальнаяКолонка, мКонечнаяСтрока, мКонечнаяКолонка);
		Если Начальной Тогда
			Возврат мНачальнаяСтрока;
		Иначе
			Возврат мКонечнаяСтрока;
		КонецЕсли; 
	Иначе
		Возврат Неопределено;
	КонецЕсли; 

КонецФункции // ПолучитьНомерТекущейСтроки()

// Получает текущее объектное выражение (на котором установлен курсор).
//
// Параметры:
//  Нет.
//
// Возвращаемое значение:
//  Строка - объектное выражение, в котором находится курсов.
//
Функция ТекущееОбъектноеВыражение(НомерСтроки = 0, НомерКолонки = 0, выхЕстьТочкаСправа = Ложь, КончитьОбработкуКоманды = Истина, Знач ЭтоПродолжениеОбработки = Ложь) Экспорт

	Если ирОбщий.ПроверитьПлатформаНеWindowsЛкс(,, Истина) Тогда
		Возврат Неопределено;
	КонецЕсли; 
	Если ЭтоПродолжениеОбработки Тогда
		ПродолжитьОбработкуКоманды();
	Иначе
		КончитьОбработкуКоманды();
	КонецЕсли;
	Если НомерСтроки > ПолеТекста.КоличествоСтрок() Тогда
		Возврат Неопределено;
	КонецЕсли;
	РазобратьТекущийКонтекст(, выхЕстьТочкаСправа,, НомерСтроки, НомерКолонки, Истина);
	Если КончитьОбработкуКоманды Тогда
		КончитьОбработкуКоманды();
	КонецЕсли; 
	Если мЭтоТекстовыйЛитерал Тогда
		мКонтекст = "";
	КонецЕсли; 
	Возврат мКонтекст;

КонецФункции

// Получает текущее контекст параметра. 
//
// Параметры:
//  Нет.
//
// Возвращаемое значение:
//  Структура -
//    "ОбъектноеВыражение"
//    "НомерПараметра"
//
Функция ПолучитьТекущийКонтекстПараметра() Экспорт

	КончитьОбработкуКоманды();
	РазобратьТекущийКонтекст(,, Истина,,, Истина);
	КончитьОбработкуКоманды();
	СтруктураРезультата = Новый Структура;
	СтруктураРезультата.Вставить("ОбъектноеВыражение", мВызовМетода);
	СтруктураРезультата.Вставить("ПервыйПараметр", мПервыйФактическийПараметр);
	СтруктураРезультата.Вставить("НомерПараметра", мНомерПараметра);
	Возврат СтруктураРезультата;

КонецФункции

// Разбирает вызов метода и выделяет в тексте заданный параметр. Учитывает границы текущего метода!
//
// Параметры:
//  НомерПараметраДляВыделения	 - Число - если заполнено, то в поле текста добавляются недостающие запятые в вызове метода до нужного параметра и он выделяется 
// 
// Возвращаемое значение:
//   - 
//
Функция ТекущийВызовМетода(Знач НомерПараметраДляВыделения = 0, выхТекстИзменен = Ложь, Знач ИскатьВыражениеПриемник = Ложь) Экспорт 

	мРегВыражение.Global = Истина;
	мВызовМетода = "";
	мКонтекст = "";
	//мОригинальныйТекст = ПолеТекста.ПолучитьТекст();
	//СлужебноеПолеТекстаДолгое.УстановитьТекст(мОригинальныйТекст);  
	ПредшествующийТекст = "";
	СледующийТекст = "";
	НачальнаяПозиция = 1;
	МаксЧислоПредшествующихСтрок = 15; // Чтобы снизить вероятность зацикливания при вычислении рег.выражения
	Если мКонечнаяСтрока > 1 Тогда
		НомерПервойСтроки = Макс(1, мКонечнаяСтрока - МаксЧислоПредшествующихСтрок - 1);
		Если мНомерПервойСтрокиТелаМетода <> Неопределено И мМетодМодуля <> Неопределено Тогда
			НомерПервойСтроки = Макс(мНомерПервойСтрокиТелаМетода, НомерПервойСтроки);
			Если мНомерПервойСтрокиТелаМетода > мКонечнаяСтрока Тогда
				Если мНомерПервойСтрокиТелаМетода - 10 < мКонечнаяСтрока Тогда
					НомерПервойСтроки = мКонечнаяСтрока;
				Иначе
					ВызватьИсключение "Внутренняя ошибка"; // Сюда приводит нас опасная техника подмены и восстановления текущего контекста в ЗаполнитьТаблицуВозможныхЗначенийЛитерала()
				КонецЕсли;
			КонецЕсли;
		КонецЕсли;
		СлужебноеПолеТекстаДолгое.УстановитьГраницыВыделения(НомерПервойСтроки, 1, мКонечнаяСтрока - 1, 333);
		ПредшествующийТекст = СлужебноеПолеТекстаДолгое.ВыделенныйТекст;
		Если НомерПараметраДляВыделения > 0 Тогда
			СлужебноеПолеТекстаДолгое.УстановитьГраницыВыделения(1, 1, НомерПервойСтроки, 1);
			НачальнаяПозиция = 1 + СтрДлина(СлужебноеПолеТекстаДолгое.ВыделенныйТекст);
		КонецЕсли;
	КонецЕсли;
	Если ЯзыкПрограммы = 0 Тогда
		мРегВыражение.Pattern = мПлатформа.шПустоеНачалоСтроки + "(?!\|)[^\n]*;";
		Вхождения = мРегВыражение.НайтиВхождения(ПредшествующийТекст);
		Для Индекс = 1 - Вхождения.Количество() По 0 Цикл // Обратный обход
			Вхождение = Вхождения[-Индекс];
			Если Не ирОбщий.ЛиВнутриТекстовогоЛитералаЛкс(Вхождение.Value) Тогда
				ПредшествующийТекст = Сред(ПредшествующийТекст, Вхождение.FirstIndex + Вхождение.Length + 1);
				НачальнаяПозиция = НачальнаяПозиция + Вхождение.FirstIndex + Вхождение.Length;
				Прервать;
			КонецЕсли;
		КонецЦикла;
	КонецЕсли;
	
	МаксЧислоСтрокАнализировать = 30; 
	МаксНомерСтроки = Мин(СлужебноеПолеТекстаДолгое.КоличествоСтрок(), мКонечнаяСтрока + МаксЧислоСтрокАнализировать);
	Если Истина
		И МаксНомерСтроки > 0
		И МаксНомерСтроки <= СлужебноеПолеТекстаДолгое.КоличествоСтрок() 
	Тогда
		СлужебноеПолеТекстаДолгое.УстановитьГраницыВыделения(мКонечнаяСтрока + 1, 1, МаксНомерСтроки, 333);
		СледующийТекст = СлужебноеПолеТекстаДолгое.ВыделенныйТекст;
	КонецЕсли;
	
	ТекстДоКурсора = ПредшествующийТекст + мТекущаяСтрокаНачало; // Так почему то иногда возникало смещение на 1 символ
	//ТекстДоКурсора = ЗалитьКомментарииИСтроковыеЛитералы(ТекстДоКурсора); Нельзя, т.к. нужна позиция результата
	ТекстПослеКурсора = мТекущаяСтрокаКонец + Символы.ПС + СледующийТекст;
	ТекстПослеКурсора = ЗалитьКомментарииИСтроковыеЛитералы(ТекстПослеКурсора); // Защита от больших откатов https://www.hostedredmine.com/issues/967498
	Если мЭтоТекстовыйЛитерал Тогда
		//ТекстДоКурсора = ТекстДоКурсора + """";
		ТекстПослеКурсора = """" + ТекстПослеКурсора;
		Если ирОбщий.ЛиВнутриТекстовогоЛитералаЛкс(ТекстПослеКурсора) Тогда
			ТекстПослеКурсора = ТекстПослеКурсора + """";
		КонецЕсли;
	ИначеЕсли Прав(ТекстДоКурсора, 1) = "." Тогда
		ТекстДоКурсора = ТекстДоКурсора + "ф";
	КонецЕсли; 
	Если мЯзыкПрограммы = 0 Тогда
		ШаблонПараметра = "(?:" + шВыражениеПрограммы + ")?" + шРазделитель + "*";
	Иначе
		ШаблонПараметра = "(?:" + шВыражениеЗапроса   + ")?" + шРазделитель + "*";
	КонецЕсли;
	мРегВыражение.Global = Ложь;
	мРегВыражение.MultiLine = Ложь;
	мРегВыражение.Pattern = "^(?:" + ШаблонПараметра + ",)*" + ШаблонПараметра + "\)";
	Результат = мРегВыражение.НайтиВхождения(ТекстПослеКурсора);
	Если Результат.Количество() > 0 Тогда
		//КонецВыражения = Лев(ТекстПослеКурсора, Результат[0].Length);
		КонецВыражения = Результат[0].Value;
		Если мЭтоТекстовыйЛитерал Тогда
			КонецВыражения = Сред(КонецВыражения, 2);
		КонецЕсли;
	КонецЕсли;  
	
	мРегВыражение.Global = Ложь;
	мРегВыражение.MultiLine = Ложь;
	Если мЯзыкПрограммы = 1 Тогда
		ШаблонПоиска = шВызовМетодаЗапроса + "$";
	Иначе 
		ШаблонПоиска = шВызовМетодаПрограммы + "$";
	КонецЕсли;
	НачальныйИндекс = 0;
	Если ИскатьВыражениеПриемник Тогда
		ШаблонПоиска = "(?:(" + шИмяСТочками + ")\s*=\s*)?" + ШаблонПоиска;
		НачальныйИндекс = 1;
	КонецЕсли;
	ТекстГдеИскать = ТекстДоКурсора + ирОбщий.СтрокаБезКонцаЛкс(КонецВыражения) + ","; // Добавляем запятую
	мРегВыражение.Pattern = ШаблонПоиска;
	Результат = мРегВыражение.НайтиВхождения(ТекстГдеИскать);
	мФактическиеПараметры = Новый Массив;
	Если Результат.Количество() = 0 Тогда
		Возврат Неопределено;
	КонецЕсли;
	ПоследнееВхождение = Результат[0];
	мВызовМетода = ПоследнееВхождение.SubMatches(НачальныйИндекс + 2) + "(";
	ТекстПараметров = ПоследнееВхождение.SubMatches(НачальныйИндекс + 6) + ПоследнееВхождение.SubMatches(НачальныйИндекс + 15);
	НачальнаяПозиция = НачальнаяПозиция + ПоследнееВхождение.FirstIndex + Найти(ПоследнееВхождение.Value, "(");
	мЭтоКонструктор = ЗначениеЗаполнено(ПоследнееВхождение.SubMatches(НачальныйИндекс + 1));
	мРегВыражение.Global = Истина;
	Если ИскатьВыражениеПриемник Тогда
		ВыражениеПриемник = ПоследнееВхождение.SubMatches(0);
	КонецЕсли;
	Если мЯзыкПрограммы = 0 Тогда
		ШаблонПараметра = "(" + шВыражениеПрограммы + ")?" ;
	Иначе
		ШаблонПараметра = "(" + шВыражениеЗапроса   + ")?";
	КонецЕсли;
	мРегВыражение.Pattern = ШаблонПараметра + шРазделитель + "*,";
	Результат = мРегВыражение.НайтиВхождения(ТекстПараметров + ""","); // Добавляем кавычку на случай незакрытого строкового литерала
	ЛокальнаяПозицияКурсора = СтрДлина(ТекстПараметров) + 1 - СтрДлина(КонецВыражения);
	Счетчик = 0;
	Для Каждого Вхождение Из Результат Цикл
		Счетчик = Счетчик + 1;
		ПозицияВхождения = Вхождение.FirstIndex;
		Если Истина
			И (ПозицияВхождения + 1) <= ЛокальнаяПозицияКурсора 
			И (ПозицияВхождения + Вхождение.Length + 1) >= ЛокальнаяПозицияКурсора 
		Тогда
			мНомерПараметра = Счетчик;
		КонецЕсли;
		ТекстПараметра = СокрЛП(Вхождение.SubMatches(0));
		Если Истина
			И Счетчик = Результат.ВГраница()
			И Лев(ТекстПараметра, 1) <> """" 
			И Прав(ТекстПараметра, 1) = """" 
		Тогда
			ТекстПараметра = ирОбщий.СтрокаБезКонцаЛкс(ТекстПараметра);
		КонецЕсли;
		ТекстПараметра = СокрЛП(ТекстПараметра);
		Если Истина
			И Счетчик > 1 
			И Счетчик = Результат.Количество()
			И ТекстПараметра = ""
		Тогда
			Продолжить;
		КонецЕсли; 
		Если мЯзыкПрограммы > 0 Тогда
			ТекстПараметра = СокрЛП(ирОбщий.ПервыйФрагментЛкс(ТекстПараметра, "{"));
		КонецЕсли;
		мФактическиеПараметры.Добавить(ТекстПараметра);
		Если НомерПараметраДляВыделения = Счетчик Тогда
			ПолеТекста.УстановитьГраницыВыделения(НачальнаяПозиция + Вхождение.FirstIndex, НачальнаяПозиция + Вхождение.FirstIndex + СтрДлина(Вхождение.Value) - 1);
			мНомерПараметра = НомерПараметраДляВыделения;    
			ЛокальнаяПозицияКурсора = 0;
			Если ФормаВладелец <> Неопределено Тогда
				ФормаВладелец.Активизировать();
			КонецЕсли;
		КонецЕсли;
	КонецЦикла;
	Если мФактическиеПараметры.Количество() > 0 Тогда
		мПервыйФактическийПараметр = мФактическиеПараметры[0];
	КонецЕсли; 
	Если НомерПараметраДляВыделения > 0 Тогда
		ЧислоЗапятыхДобавить = НомерПараметраДляВыделения - мФактическиеПараметры.Количество();
		Если ЧислоЗапятыхДобавить > 0 Тогда
			ПолеТекста.УстановитьГраницыВыделения(НачальнаяПозиция + СтрДлина(ТекстПараметров) - 1, НачальнаяПозиция + СтрДлина(ТекстПараметров) - 1);
			ТекстЗапятых = ирОбщий.СтрокаПовторомЛкс(",", ЧислоЗапятыхДобавить);
			ПолеТекста.ВыделенныйТекст(ТекстЗапятых);
			УстановитьПризнакМодифицированностиФормы();
			выхТекстИзменен = Истина;
		КонецЕсли;
	КонецЕсли;
	мИмяМетодаВызова = ирОбщий.ПервыйФрагментЛкс(ирОбщий.ПоследнийФрагментЛкс(мВызовМетода), "(");
	СтруктураРезультата = Новый Структура;
	СтруктураРезультата.Вставить("ОбъектноеВыражение", мВызовМетода);
	СтруктураРезультата.Вставить("ОригинальныйТекст", Лев(ПоследнееВхождение.Value, СтрДлина(ПоследнееВхождение.Value) - 1) + ")");
	СтруктураРезультата.Вставить("МассивПараметров", мФактическиеПараметры);
	СтруктураРезультата.Вставить("НомерПараметра", мНомерПараметра);
	СтруктураРезультата.Вставить("ЭтоКонструктор", мЭтоКонструктор);
	СтруктураРезультата.Вставить("ВыражениеПриемник", ВыражениеПриемник);
	Возврат СтруктураРезультата;

КонецФункции

// Разбирает контекст метода.
//
// Параметры:
//  Нет.
//
Функция УстановитьТекущийКонтекстМетода(НовыйТекст) Экспорт

	#Если Сервер И Не Сервер Тогда
		ПолеТекста = Обработки.ирОболочкаПолеТекста.Создать();
	#КонецЕсли
	ПолеТекста.УстановитьГраницыВыделения(мНачальнаяСтрока, мНачальнаяКолонка, мКонечнаяСтрока, мКонечнаяКолонка);
	ВыделенныйТекст(НовыйТекст);
	ПолеТекста.УстановитьГраницыВыделения(мНачальнаяСтрока, мНачальнаяКолонка, мНачальнаяСтрока, мНачальнаяКолонка,, ФормаВладелец);

КонецФункции

// Разбирает контекст УК.
//
// Параметры:
//  Нет.
//
Функция ПолучитьТекущийКонтекстУК() Экспорт

	мПлатформа.ИнициацияОписанияМетодовИСвойств();
	ПолеТекста.ПолучитьГраницыВыделения(мНачальнаяСтрока, мНачальнаяКолонка, мКонечнаяСтрока, мКонечнаяКолонка);
	мРегВыражение.Global = Истина;
	ПрочитатьНачалоИКонецТекущейСтроки();
	РазобратьКонтекстСтроки();
	ИмяСтруктурыПараметров = "";
	
	мОригинальныйТекст = ПолеТекста.ПолучитьТекст();
	//СлужебноеПолеТекстаДолгое.УстановитьТекст(мОригинальныйТекст);
	мПредшествующийТекст = "";
	СледующийТекст = "";
	Если мКонечнаяСтрока > 1 Тогда
		СлужебноеПолеТекстаДолгое.УстановитьГраницыВыделения(1, 1, мКонечнаяСтрока - 1, 333);
		мПредшествующийТекст = СлужебноеПолеТекстаДолгое.ВыделенныйТекст;
	КонецЕсли; 
	МаксНомерСтроки = Мин(СлужебноеПолеТекстаДолгое.КоличествоСтрок(), мКонечнаяСтрока + 100);
	Если Истина
		И МаксНомерСтроки > 0
		И МаксНомерСтроки <= СлужебноеПолеТекстаДолгое.КоличествоСтрок() 
	Тогда
		СлужебноеПолеТекстаДолгое.УстановитьГраницыВыделения(мКонечнаяСтрока + 1, 1, МаксНомерСтроки, 333);
		СледующийТекст = СлужебноеПолеТекстаДолгое.ВыделенныйТекст;
	КонецЕсли;
	ТекстДоКурсора = мПредшествующийТекст + Символы.ПС + мТекущаяСтрокаНачало;
	ТекстПослеКурсора = мТекущаяСтрокаКонец + Символы.ПС + СледующийТекст;
	
	ШаблонУК = "(" + шИмя + ")" + шРазделитель + "*=" + шРазделитель + "*УК\((" + шИмя + ")\)";
	мРегВыражение.Global = Ложь;
	мРегВыражение.MultiLine = Ложь;
	мРегВыражение.Pattern = "^" + "(" + шРазделитель + "*)" + ШаблонУК;
	Результат = мРегВыражение.НайтиВхождения(мТекущаяСтрокаНачало + ТекстПослеКурсора);
	Если Результат.Количество() > 0 Тогда
		Смещение = Результат[0].SubMatches(0);
		ИмяСтруктурыПараметров = Результат[0].SubMatches(1);
		МассивПараметров = Новый Массив;
		МассивПараметров.Добавить(Результат[0].SubMatches(2));
	Иначе
		Возврат Неопределено;
	КонецЕсли;
	
	ШаблонПараметра = шРазделитель + "*" + ИмяСтруктурыПараметров + "\.(" + шИмя + ")" + шРазделитель + "*=" 
		+ шРазделитель + "*(" + шВыражениеПрограммы + ")?" + шРазделитель + "*" + ";";
	мРегВыражение.Pattern = "^" + "(" + шРазделитель + "*)" + ШаблонУК + ";" + "((?:" + ШаблонПараметра  + шРазделитель + "*" + ")*)";
	Результат = мРегВыражение.НайтиВхождения(мТекущаяСтрокаНачало + ТекстПослеКурсора);
	Если Результат.Количество() > 0 Тогда
		ПолныйТекстВыражения = Результат[0].Value;
	Иначе
		Возврат Неопределено;
	КонецЕсли;
	
	//мРегВыражение.Global = Ложь;
	мРегВыражение.MultiLine = Ложь;
	мРегВыражение.Pattern = ШаблонУК + ";" + "((?:" + ШаблонПараметра  + шРазделитель + "*" + ")*)$";
	Результат = мРегВыражение.НайтиВхождения(мПредшествующийТекст + ПолныйТекстВыражения);
	СтруктураПараметров = Новый Структура;
	Если Результат.Количество() > 0 Тогда
		ПоследнееВхождение = Результат[Результат.Количество() - 1];
		Попытка
			СлужебноеПолеТекстаДолгое.УстановитьГраницыВыделения(ПоследнееВхождение.FirstIndex + 1, 
				ПоследнееВхождение.FirstIndex + 1 + ПоследнееВхождение.Length);
		Исключение
			СлужебноеПолеТекстаДолгое.УстановитьГраницыВыделения(ПоследнееВхождение.FirstIndex + 1, 
				ПоследнееВхождение.FirstIndex + 1 + ПоследнееВхождение.Length - 1); // -1 надо делать из-за бага платформы (она не дает выделить последний символ в тексте)
		КонецПопытки;
		СлужебноеПолеТекстаДолгое.ПолучитьГраницыВыделения(мНачальнаяСтрока, мНачальнаяКолонка, мКонечнаяСтрока, мКонечнаяКолонка);
		//ИмяСтруктурыПараметров = Результат[0].SubMatches(0);
		ТекстПараметров = ПоследнееВхождение.SubMatches(2);
		мРегВыражение.Global = Истина;
		мРегВыражение.Pattern = ШаблонПараметра;
		Результат = мРегВыражение.НайтиВхождения(ТекстПараметров);
		//ЛокальнаяПозицияКурсора = СтрДлина(ТекстПараметров) - СтрДлина(ПолныйТекстВыражения);
		Счетчик = 0;
		Для Каждого Вхождение Из Результат Цикл
			Счетчик = Счетчик + 1;
			//Если Истина
			//	И (Вхождение.FirstIndex + 1) <= ЛокальнаяПозицияКурсора 
			//	И (Вхождение.FirstIndex + Вхождение.Length + 1) >= ЛокальнаяПозицияКурсора 
			//Тогда
			//	мНомерПараметра = Счетчик;
			//КонецЕсли;
			СтруктураПараметров.Вставить(СокрЛП(Вхождение.SubMatches(0)), СокрЛП(Вхождение.SubMatches(1)));
		КонецЦикла;
		СтруктураРезультата = Новый Структура;
		СтруктураРезультата.Вставить("ИмяСтруктурыПараметров", ИмяСтруктурыПараметров);
		СтруктураРезультата.Вставить("МассивПараметров", МассивПараметров);
		СтруктураРезультата.Вставить("ОригинальныйТекст", ПоследнееВхождение.Value);
		СтруктураРезультата.Вставить("Смещение", Смещение);
		СтруктураРезультата.Вставить("СтруктураПараметров", СтруктураПараметров);
		СтруктураРезультата.Вставить("НомерПараметра", мНомерПараметра);
		Возврат СтруктураРезультата;
	Иначе
		Возврат Неопределено;
	КонецЕсли;

КонецФункции

// Находит первое вхождение слова в тексте. Если слово найдено, устанавливается выделение и фокус.
//
// Параметры:
//  СтрокаПоиска	 - 	 - 
//  СловоЦеликом	 - Булево, Строка - если "Переменная", то заменяется на стандартный шаблон см. ШаблонШаблонаПоискаСлова 
//  ПолеТекста	 - 	 - 
// 
// Возвращаемое значение:
//   - Булево - была ли найдена и выделена строка
//
Функция НайтиПоказатьСловоВТексте(СтрокаПоиска, Знач СловоЦеликомИлиШаблон = Истина, ПолеТекста = Неопределено, УстановитьФокус = Ложь, ИскатьСНачала = Ложь, Знач ИскатьСНачалаЕслиНеНайдено = Ложь,
	Знач НачалоОбласти = Неопределено, Знач КонецОбласти = Неопределено) Экспорт 
	
	Если ПолеТекста = Неопределено Тогда
		ПолеТекста = ЭтотОбъект.ПолеТекста;
	КонецЕсли;
	Если СловоЦеликомИлиШаблон = "Переменная" Тогда
		СловоЦеликомИлиШаблон = ШаблонШаблонаПоискаСлова();
	КонецЕсли;
	Если УстановитьФокус Тогда
		ЗапомнитьИсточникПерехода();
	КонецЕсли;
	Результат = ирКлиент.НайтиПоказатьФрагментВПолеТекстаЛкс(ФормаВладелец, ПолеТекста, СтрокаПоиска, СловоЦеликомИлиШаблон, ИскатьСНачала,,, НачалоОбласти, КонецОбласти, ИскатьСНачалаЕслиНеНайдено);
	Если УстановитьФокус Тогда
		УстановитьФокус();
	КонецЕсли; 
	Возврат Результат; 
	
КонецФункции

Функция ШаблонШаблонаПоискаСлова(Знач ЛиМетод = Ложь, Знач МожноЧерезЭтотОбъект = Ложь) Экспорт 
	
	Шаблон = "#Слово#";
	Если МожноЧерезЭтотОбъект Тогда
		Шаблон = ШаблонПоискаСловаЧерезЭтотОбъект(Шаблон);
	КонецЕсли;
	Шаблон = шЛитералПрограммы + "|(?:Новый|New)\s*#Слово#|(^|[^_a-zа-яё0-9"".])(" + Шаблон + ")\s*";
	Если ЛиМетод Тогда
		Возврат Шаблон + "\(";
	Иначе
		Возврат Шаблон + "($|[^_a-zа-яё0-9\(])";
	КонецЕсли;

КонецФункции

// Вставляет в текущую позицию поля текстового документа ссылку на объект БД.
//
// Параметры:
//  ЗначенияСвойствНового - Структура - если параметр будет добавлен, то к его строке будут применены эти значения свойств;
//  <Параметр2>  - <Тип.Вид> - <описание параметра>
//                 <продолжение описания параметра>.
//
// Возвращаемое значение:
//               - <Тип.Вид> - <описание значения>
//                 <продолжение описания значения>;
//  <Значение2>  - <Тип.Вид> - <описание значения>
//                 <продолжение описания значения>.
//
Функция ВставитьСсылкуНаОбъектБД(ТабличноеПолеПараметров, ИмяКолонкиИмени = "Имя", ИмяКолонкиЗначения = "Значение", ИмяСтруктурыПараметров = "",
	ОбновитьКопиюСвойстваВНижнемРегистре = Ложь, НачальноеЗначениеВыбора = Неопределено, РазрешитьВыбор = Истина, ВставитьВТекст = Истина) Экспорт

	ТаблицаПараметров = ТабличноеПолеПараметров.Значение;
	ТекущееОбъектноеВыражение = ТекущееОбъектноеВыражение();
	
	Если Истина
		И РазрешитьВыбор
		И НачальноеЗначениеВыбора = Неопределено
		И ВставитьВТекст
	Тогда
		Если Ложь
			Или ЯзыкПрограммы = 0
			Или Лев(ТекущееОбъектноеВыражение, 1) = "&" 
		Тогда
			ИмяПараметра = ТекущееОбъектноеВыражение;
			Если ЯзыкПрограммы = 1 Тогда
				ИмяПараметра = Сред(ИмяПараметра, 2);
			Иначе
				Если Истина
					И Не ПустаяСтрока(ИмяСтруктурыПараметров)
					И Найти(НРег(ИмяПараметра), НРег(ИмяСтруктурыПараметров) + ".") = 1 
				Тогда
					ИмяПараметра = Сред(ИмяПараметра, СтрДлина(ИмяСтруктурыПараметров) + 2);
				КонецЕсли; 
			КонецЕсли; 
			СтрокаНайденногоПараметра = ТаблицаПараметров.Найти(ИмяПараметра, ИмяКолонкиИмени);
			Если СтрокаНайденногоПараметра <> Неопределено Тогда
				Ответ = Вопрос("Использовать тип и значение выделенного в тексте параметра?", РежимДиалогаВопрос.ДаНет);
				Если Ответ = КодВозвратаДиалога.Да Тогда
					ЗначениеПараметра = СтрокаНайденногоПараметра[ИмяКолонкиЗначения];
					Если ирОбщий.ЛиСсылкаНаОбъектБДЛкс(ЗначениеПараметра, Ложь) Тогда
						НачальноеЗначениеВыбора = ЗначениеПараметра;
					КонецЕсли;
				КонецЕсли;
			КонецЕсли;
		КонецЕсли; 
	КонецЕсли; 
	//Если ЗначениеЗаполнено(НачальноеЗначениеВыбора) Тогда
	Если НачальноеЗначениеВыбора <> Неопределено Тогда
		ТипСсылки = ТипЗнч(НачальноеЗначениеВыбора);
		Если Не ирОбщий.ЛиТипСсылкиБДЛкс(ТипСсылки, Ложь) Тогда
			Возврат Неопределено;
		КонецЕсли; 
	КонецЕсли;
	Если РазрешитьВыбор Тогда
		ВыделитьТекущееОбъектноеВыражение();
	КонецЕсли; 
	
	Если ТипСсылки = Неопределено И Не ЗначениеЗаполнено(ТекущееОбъектноеВыражение) Тогда
		СтруктураТипаКонтекста = ПолучитьСтруктуруТипаСправаОтРавно();
		Если СтруктураТипаКонтекста <> Неопределено Тогда
			Если ТипЗнч(СтруктураТипаКонтекста.Метаданные) = Тип("ОбъектМетаданных") Тогда
				ТипСсылки = Тип(ирОбщий.ИмяТипаИзПолногоИмениМДЛкс(СтруктураТипаКонтекста.Метаданные.ПолноеИмя()));
			КонецЕсли; 
		КонецЕсли;
	КонецЕсли;
	
	Если РазрешитьВыбор И ТипСсылки = Неопределено Тогда
		ПараметрыВыбораМетаданных = Новый Структура;
		ПараметрыВыбораМетаданных.Вставить("ОтображатьСсылочныеОбъекты", Истина);
		ПараметрыВыбораМетаданных.Вставить("ОтображатьПеречисления", Истина);
		ПараметрыВыбораМетаданных.Вставить("ОтображатьВнешниеИсточникиДанных", Истина);
		ФормаВыбора = ирКлиент.ПолучитьФормуВыбораОбъектаМетаданныхСтруктуройЛкс(ФормаВладелец,,, ПараметрыВыбораМетаданных);
		Результат = ФормаВыбора.ОткрытьМодально();
		Если Результат = Неопределено Тогда
			Возврат Неопределено;
		КонецЕсли;
		ТипСсылки = Тип(ирОбщий.ИмяТипаИзПолногоИмениМДЛкс(Результат.ПолноеИмяОбъекта));
	КонецЕсли;
	
	Если НачальноеЗначениеВыбора = Неопределено Тогда
		НачальноеЗначениеВыбора = Новый (ТипСсылки);
	КонецЕсли;
	
	Если РазрешитьВыбор Тогда
		ЗначениеПараметра = ирКлиент.ВыбратьСсылкуЛкс(ТипСсылки, НачальноеЗначениеВыбора);
		УстановитьФокус();
	Иначе
		ЗначениеПараметра = НачальноеЗначениеВыбора;
	КонецЕсли; 
	Если ЗначениеПараметра = Неопределено Тогда
		Возврат Неопределено;
	КонецЕсли;
	Если ТабличноеПолеПараметров.ИзменяетДанные Тогда
		ФормаВладелец.Модифицированность = Истина;
	КонецЕсли; 
	
	СтрокаПараметра = ирОбщий.НайтиДобавитьПараметрСсылкуВТаблицуЛкс(ТаблицаПараметров, ИмяКолонкиИмени, ИмяКолонкиЗначения, ЗначениеПараметра,, ОбновитьКопиюСвойстваВНижнемРегистре);
	Если ВставитьВТекст Тогда
		ТекстВставки = СтрокаПараметра[ИмяКолонкиИмени];
		Если Ложь
			Или ЯзыкПрограммы = 1
			Или ЯзыкПрограммы = 2
		Тогда
			ТекстВставки = "&" + ТекстВставки;
		КонецЕсли;
		Если ЯзыкПрограммы = 0 Тогда
			Если Не ПустаяСтрока(ИмяСтруктурыПараметров) Тогда
				ТекстВставки = ИмяСтруктурыПараметров + "." + ТекстВставки;
			КонецЕсли; 
		КонецЕсли;
		ВыделенныйТекст(ТекстВставки);
	КонецЕсли; 
	Возврат СтрокаПараметра;

КонецФункции

// Вызывается из адаптера.
// Возвращаемое значение:
//  Булево - Истина, если объявление найдено
Функция ОбъявитьТипВыражения() Экспорт
	Выражение = ТекущееОбъектноеВыражение();
	Если Найти(Выражение, "(") Тогда
		Выражение = ирОбщий.ПервыйФрагментЛкс(Выражение);
	КонецЕсли; 
	Если мМетодМодуля <> Неопределено И мПозицияВТексте < мМетодМодуля.ПозицияОпределения Тогда
		Возврат Ложь;
	КонецЕсли;
	ВхождениеВыражения = Неопределено; // ОбработкаОбъект.ирОболочкаРегВхождение
	ЛиВЗаголовкеМетода = ЛиВЗаголовкеМетода();
	Переменная = ирОбщий.ПервыйФрагментЛкс(Выражение);
	Если Найти(Выражение, "(") = 0 Тогда
		НайтиОпределениеСлова(Выражение,, ВхождениеВыражения); // TODO учесть назначение типа через условие
	ИначеЕсли Не ЛиВЗаголовкеМетода Тогда
		Возврат Ложь;
	КонецЕсли;
	СтрокаПараметра = СтрокаПараметраМетодаМодуля(Переменная);
	НомерСтроки = Неопределено;
	мЗаменяемыйДиапазон = Неопределено;
	мЗамещающийФрагмент = Неопределено;
	Если ВхождениеВыражения <> Неопределено Тогда
		НомерСтроки = НомерСтрокиИзПозиции(мПозицияТекстаДляПоискаОпределения + ВхождениеВыражения.FirstIndex + ВхождениеВыражения.Length + 1);
		РазобратьТекущийКонтекст(,,, НомерСтроки, 1);
		ПозицияВСтроке = Найти(мТекущаяСтрокаКонец, " // ");
		Если ЗначениеЗаполнено(ПозицияВСтроке) Тогда
			ПозицияВСтроке = ПозицияВСтроке + 4;
			УстановитьГраницыВыделения(НомерСтроки, ПозицияВСтроке, НомерСтроки, ПозицияВСтроке);
		Иначе
			ПозицияВСтроке = СтрДлина(ПолеТекста.ПолучитьСтроку(НомерСтроки));
			УстановитьГраницыВыделения(НомерСтроки, 1, НомерСтроки, ПозицияВСтроке);
			мЗаменяемыйДиапазон = ПолеТекста.ВыделениеОдномерное(); 
			мЗаменяемыйДиапазон.Конец = мЗаменяемыйДиапазон.Конец + 1;
			мЗаменяемыйДиапазон.Вставить("НомерСтроки", НомерСтроки); 
			УстановитьГраницыВыделения(НомерСтроки, ПозицияВСтроке, НомерСтроки, ПозицияВСтроке);
			СтрокаОпределения = мТекущаяСтрокаКонец + " // ";
			ПолеТекста.ЗаменитьСтроку(НомерСтроки, СтрокаОпределения); 
			ПозицияВСтроке = СтрДлина(СтрокаОпределения) + 1;
			УстановитьГраницыВыделения(НомерСтроки, ПозицияВСтроке, НомерСтроки, ПозицияВСтроке);
			мЗамещающийФрагмент = ПолеТекста.ПолучитьСтроку(НомерСтроки);
		КонецЕсли;
	ИначеЕсли Ложь
		Или ЛиВЗаголовкеМетода
		Или СтрокаПараметра <> Неопределено 
	Тогда
		Если СтрокаПараметра <> Неопределено Тогда
			ИмяПараметра = СтрокаПараметра.Имя;
		КонецЕсли;
		мЗаменяемыйДиапазон = НовыйЗаменяемыйДиапазон();
		мЗаменяемыйДиапазон.Начало = мМетодМодуля.ПозицияСОписанием;
		мЗаменяемыйДиапазон.Конец = мМетодМодуля.ПозицияОпределения - 1;
		Если Не ОткрытьКонструкторМетода(,, Истина) Тогда
			мЗаменяемыйДиапазон = Неопределено;
		КонецЕсли; 
		ПерейтиКОпределениюЛокальногоМетода(мМетодМодуля, ИмяПараметра, -1, 6, Истина);
		РазобратьТекущийКонтекст(); 
		мЗамещающийФрагмент = Сред(мОригинальныйТекст, мМетодМодуля.ПозицияСОписанием, мМетодМодуля.ПозицияОпределения - мМетодМодуля.ПозицияСОписанием - 1);
	Иначе
		НомерСтрокиРодителя = 0;
		Если Переменная <> Выражение Тогда
			ВхождениеОпределенияРодителя = Неопределено; // ОбработкаОбъект.ирОболочкаРегВхождение
			НайтиОпределениеСлова(Переменная,, ВхождениеОпределенияРодителя);
			Если ВхождениеОпределенияРодителя <> Неопределено Тогда
				НомерСтрокиРодителя = 1 + НомерСтрокиИзПозиции(мПозицияТекстаДляПоискаОпределения + ВхождениеОпределенияРодителя.FirstIndex + ВхождениеОпределенияРодителя.Length + 1);
			КонецЕсли;
		КонецЕсли;
		ВхождениеВыражения = ирОбщий.СтрНайтиСловоЛкс(мТекстБлока, Выражение);
		Если ВхождениеВыражения <> Неопределено Тогда // всегда истина
			НомерСтроки = НомерСтрокиИзПозиции(мПозицияТекстаДляПоискаОпределения + ВхождениеВыражения.ПозицияВхождения + ирОбщий.СтрНайтиЛкс(ВхождениеВыражения.ТекстВхождения, Выражение,,,, Ложь));
			НомерСтроки = Макс(НомерСтроки, НомерСтрокиРодителя);
			НепечатноеНачалоСтроки = ирОбщий.НепечатноеНачалоСтрокиЛкс(ПолеТекста.ПолучитьСтроку(НомерСтроки));
			СтрокаОпределения = НепечатноеНачалоСтроки + "//! " + Выражение + " = 0 // ";
			УстановитьГраницыВыделения(НомерСтроки, 1, НомерСтроки, 1);
			мЗаменяемыйДиапазон = ПолеТекста.ВыделениеОдномерное();
			мЗаменяемыйДиапазон.Вставить("НомерСтроки", НомерСтроки); 
			ПолеТекста.ВставитьСтроку(НомерСтроки, СтрокаОпределения); 
			ПозицияВСтроке = СтрДлина(СтрокаОпределения) + 1;
			УстановитьГраницыВыделения(НомерСтроки, ПозицияВСтроке, НомерСтроки, ПозицияВСтроке);
			мЗамещающийФрагмент = ПолеТекста.ПолучитьСтроку(НомерСтроки) + Символы.ПС;
		КонецЕсли; 
	КонецЕсли;
	Возврат Истина;
КонецФункции

// Обрабатывает нажатие на кнопки
//
// Параметры:
//  Кнопка - Кнопка.
//
// Возвращаемое значение:
//  Булево - результат проверки.
//
Функция Нажатие(Кнопка, ОбновитьКонтекст = Ложь) Экспорт
	
	Перем Результат;
	Команда = ирОбщий.ПоследнийФрагментЛкс(Кнопка.Имя, "_");
	Если Команда = "АвтоКонтекстнаяПомощь" Тогда
	    УстановитьАвтоКонтекстнаяПомощь(Не Кнопка.Пометка);
	КонецЕсли;
	Результат = ВыполнитьКоманду(Команда, , ОбновитьКонтекст);
	Возврат Результат;
	
КонецФункции

Функция ВыполнитьКоманду(Знач Команда, Знач КодКлавиши = "", ОбновитьКонтекст = Истина)
	
	Если ОбновитьКонтекст Тогда
		КончитьОбработкуКоманды();
		ФормаВладелец.КлсПолеТекстаПрограммыОбновитьКонтекст(ЭтотОбъект);
	КонецЕсли;
	Результат = Неопределено;
	КнопкиМакета0 = мФормаКласса.ЭлементыФормы.КоманднаяПанель0.Кнопки; // Встроенный язык  
	КнопкиМакета1 = мФормаКласса.ЭлементыФормы.КоманднаяПанель1.Кнопки; // Язык запросов
	КнопкиМакета2 = мФормаКласса.ЭлементыФормы.КоманднаяПанель2.Кнопки;
	КнопкиМакетаОбщие = мФормаКласса.ЭлементыФормы.КоманднаяПанельОбщая.Кнопки;
	мПлатформа.ПроверитьОбновитьКэш();
	Попытка
		мПлатформа.ИнициацияОписанияМетодовИСвойств();
		ПолучитьГраницыВыделения();
		мОткрытьСправкуПоПараметру = Ложь;
		Если Команда = КнопкиМакетаОбщие.ПодменюПолеПрограммы.Кнопки.ОткрытьАвтодополнение.Имя Тогда
			ОткрытьАвтодополнение(КодКлавиши, Не ЗначениеЗаполнено(КодКлавиши));
		ИначеЕсли Команда = КнопкиМакета0.СписокМетодов.Имя Тогда
			ОткрытьСписокМетодов();
		//ИначеЕсли Команда = КнопкиМакета0.СсылкиНаСлово.Имя Тогда
		//	ОткрытьПоискВызововСлова();
		ИначеЕсли Команда = КнопкиМакета0.НайтиВМодулях.Имя Тогда
			ОткрытьПоискВМодулях();
		ИначеЕсли Команда = КнопкиМакета0.ДеревоВызовов.Имя Тогда
			ОткрытьДеревоВызовов();
		ИначеЕсли Команда = КнопкиМакета1.ДеревоСвязейПоля.Имя Тогда
			ОткрытьДеревоСвязейПоля();
		ИначеЕсли Команда = КнопкиМакетаОбщие.ПодменюПолеПрограммы.Кнопки.ЗаменитьТабуляции.Имя Тогда
			ЗаменитьТабуляции();
		ИначеЕсли Команда = КнопкиМакетаОбщие.ПодменюПолеПрограммы.Кнопки.ВыделитьСлово.Имя Тогда
			// В платформе есть аналогичная системная команда, но для HTML редактора нужна.
			ВыделитьТекущееСлово();
		ИначеЕсли Команда = КнопкиМакета0.ПереименоватьСлово.Имя Тогда
			Если мЯзыкПрограммы = 0 Тогда
				ПереименоватьСлово();
			КонецЕсли;
		ИначеЕсли Команда = КнопкиМакета0.СписокМетодов.Имя Тогда
			//
		ИначеЕсли Команда = КнопкиМакета0.КонструкторМетода.Имя Тогда
			ОткрытьКонструкторМетода();
		ИначеЕсли Команда = КнопкиМакетаОбщие.СравнитьТекст.Имя Тогда
			ЗапомнитьДляСравнения();
		ИначеЕсли Команда = КнопкиМакета1.УдалитьПереносы.Имя Тогда
			УдалитьПереносы();
		ИначеЕсли Команда = КнопкиМакета1.КонструкторЗапросов1С.Имя Тогда
			Результат = ВызватьКонструкторЗапросов(Ложь);
		ИначеЕсли Команда = КнопкиМакета1.КонструкторЗапросовИР.Имя Тогда
			Результат = ВызватьКонструкторЗапросов(Истина);
		ИначеЕсли Команда = КнопкиМакета0.КонструкторЗапросов.Имя Тогда
			Результат = ВызватьКонструкторЗапросов();
		ИначеЕсли Команда = КнопкиМакета1.КонсольЗапросов.Имя Тогда
			Результат = РедактироватьВКонсолиЗапросов();
		ИначеЕсли Команда = КнопкиМакета0.КонсольКода.Имя Тогда
			Результат = РедактироватьВКонсолиКода();
		ИначеЕсли Команда = КнопкиМакета1.ВставитьИзБуфераОбменаВесьТекст.Имя Тогда
			ирКлиент.УстановитьТекстСОткатомЛкс(ПолеТекста, ирКлиент.ТекстИзБуфераОбменаОСЛкс());
		ИначеЕсли Команда = КнопкиМакета1.КопироватьВБуферОбменаВесьТекст.Имя Тогда
			ирКлиент.ТекстВБуферОбменаОСЛкс(ПолеТекста.ПолучитьТекст(), ?(ЯзыкПрограммы = 0, "ВстроенныйЯзык", "ЯзыкЗапросов"));
		ИначеЕсли Команда = КнопкиМакета1.КопироватьВБуферОбменаТекстВВидеКода.Имя Тогда
			КопироватьВБуферОбменаТекстВВидеКода(); 
		ИначеЕсли Команда = КнопкиМакета1.Закомментировать.Имя Тогда
			Закомментировать();
		ИначеЕсли Команда = КнопкиМакета1.Раскомментировать.Имя Тогда
			Раскомментировать();
		ИначеЕсли Команда = КнопкиМакета0.РедакторСтроковогоЛитерала.Имя Тогда
			Результат = ОткрытьРедакторСтроковогоЛитерала();
		ИначеЕсли Команда = КнопкиМакета1.ИсследоватьСхемуЗапроса.Имя Тогда
			Если ПроверитьПрограммныйКод() Тогда 
				СхемаЗапроса = Вычислить("Новый схемаЗапроса");
				#Если Сервер И Не Сервер Тогда
					СхемаЗапроса = Новый СхемаЗапроса;
				#КонецЕсли
				Если ирКэш.НомерВерсииПлатформыЛкс() >= 803014 Тогда
					СхемаЗапроса.РежимКомпоновкиДанных = РежимКомпоновкиДанных;
				КонецЕсли;
				СхемаЗапроса.УстановитьТекстЗапроса(ПолеТекста.ПолучитьТекст());
				ирОбщий.ИсследоватьЛкс(СхемаЗапроса);
			КонецЕсли;
		ИначеЕсли Команда = КнопкиМакетаОбщие.ПерейтиКОпределению.Имя Тогда
			ПерейтиКОпределению();
			Результат = мТекущееСлово;
		ИначеЕсли Команда = КнопкиМакета0.ПерейтиВНачалоРодителя.Имя Тогда
			ПерейтиВНачалоРодителя();
		ИначеЕсли Команда = КнопкиМакетаОбщие.Проверить.Имя Тогда
			ПроверитьПрограммныйКод(Истина);
		ИначеЕсли Команда = КнопкиМакетаОбщие.УстановитьФокус.Имя Тогда
			УстановитьФокус();
		ИначеЕсли ЯзыкПрограммы = 1 И Команда = КнопкиМакета1.Форматировать.Имя Тогда
			ФорматироватьТекстЯзыкаЗапросов();
		ИначеЕсли ЯзыкПрограммы = 0 И Команда = КнопкиМакета0.Форматировать.Имя Тогда
			ФорматироватьТекстВстроенногоЯзыка();
		ИначеЕсли Команда = КнопкиМакета0.ОбъявитьТип.Имя Тогда
			ОбъявитьТипВыражения();
		ИначеЕсли Команда = КнопкиМакета0.Выполнить.Имя Тогда
			ВыполнитьПрограммныйКод();
		ИначеЕсли Команда = КнопкиМакетаОбщие.КонтекстныйСинтаксПомощник.Имя Тогда
			мПоследнийРежимВызоваСправки = Команда;
			ОткрытьКонтекстнуюСправку(, ФормаВладелец);
		//ИначеЕсли Команда = КнопкиМакетаОбщие.СинтаксПомощник.Имя Тогда
		//	_ОткрытьСправкуПоЯзыкуПрограммы();
		ИначеЕсли Команда = КнопкиМакетаОбщие.ПодсказатьПараметр.Имя Тогда
			мПоследнийРежимВызоваСправки = Команда;
			ОткрытьСправкуПоПараметру();
		ИначеЕсли Команда = КнопкиМакетаОбщие.ВернутьсяИзПерехода.Имя Тогда
			ВернутьсяИзПерехода();
		ИначеЕсли Команда = КнопкиМакета0.КонструкторОписанияТипов.Имя Тогда
			КонструкторОписанияТипов();
		ИначеЕсли Команда = КнопкиМакетаОбщие.ПодменюПолеПрограммы.Кнопки.Настройка.Имя Тогда
			ПолучитьФорму("ФормаНастройки", ФормаВладелец).Открыть(); 
			
		// Бескнопочные команды
		ИначеЕсли Команда = "ПодсказатьПараметрАвто" Тогда 
			Если ФормаВладелец.ТекущийЭлемент = ПолеТекста.ЭлементФормы Тогда
				ОткрытьСправкуПоПараметру(, Ложь);
			КонецЕсли; 
		ИначеЕсли Команда = КнопкиМакетаОбщие.ПодменюПолеПрограммы.Кнопки.ВыполнитьШаблон.Имя Тогда
			ВыполнитьШаблонТекста();
		ИначеЕсли Команда = "НайтиСледующееHTML" Тогда
			НайтиСледующееHTML();
		ИначеЕсли Команда = "НайтиПредыдущееHTML" Тогда
			НайтиПредыдущееHTML();
		ИначеЕсли Команда = "ЗаменитьВхожденияHTML" Тогда
			ЗаменитьВхожденияHTML();
		ИначеЕсли Команда = "СочетанияКлавишHTML" Тогда
			СочетанияКлавишHTML();
		ИначеЕсли Команда = "КонструкторФорматнойСтроки" Тогда
			КонструкторФорматнойСтроки();
		КонецЕсли;
		
		Если Ложь
			Или Команда = "ВыделитьСлово"
			Или Команда = "Форматировать"
			Или Команда = "ВыполнитьШаблон"
			Или Команда = "ОткрытьАвтодополнение"
			Или Команда = "ПодсказатьПараметрАвто"
			Или Команда = "ЗаменитьТабуляции"
			Или Команда = "УдалитьПереносы"
			Или Команда = "ПерейтиКОпределению"
			Или Команда = "КонструкторЗапросов1С"
			Или Команда = "КонструкторЗапросовИР"
			Или Команда = "КонструкторЗапросов"
			Или Команда = "РедакторСтроковогоЛитерала"
		Тогда
			Если Результат <> Ложь Тогда 
				ВосстановитьГраницыВыделенияПослеКоманды();
			КонецЕсли;
		КонецЕсли;
	Исключение
		КончитьОбработкуКоманды();
		ВосстановитьФокусВвода();
		ВызватьИсключение;
	КонецПопытки;
	КончитьОбработкуКоманды();
	ВосстановитьФокусВвода();
	Возврат Результат;

КонецФункции

Функция ЗапомнитьДляСравнения(Знач РазрешитьВопросы = Истина, Знач Текст = "") Экспорт
	ВариантСинтаксисаСравнителя = Неопределено;
	Если ЯзыкПрограммы = 0 Тогда
		ВариантСинтаксисаСравнителя = "ВстроенныйЯзык";
	ИначеЕсли ЯзыкПрограммы = 1 Тогда
		ВариантСинтаксисаСравнителя = "ЯзыкЗапросов";
	ИначеЕсли ЯзыкПрограммы = 2 Тогда
		ВариантСинтаксисаСравнителя = "ЯзыкКомпоновки";
	КонецЕсли; 
	ЗаголовокЭлементаФормы = "";
	Если ЗначениеЗаполнено(мИмяМодуля) И мИмяМодуля <> мПлатформа.ИмяДинамическогоМодуля() Тогда
		ЗаголовокЭлементаФормы = мИмяМодуля;
	КонецЕсли;
	Возврат ирКлиент.ЗапомнитьСодержимоеЭлементаФормыДляСравненияЛкс(ФормаВладелец, ПолеТекста, ВариантСинтаксисаСравнителя, РазрешитьВопросы, Текст, ЗаголовокЭлементаФормы);
КонецФункции

Процедура ВосстановитьГраницыВыделенияПослеКоманды()
	
	УстановитьГраницыВыделения();
	Если мОткрытьСправкуПоПараметру И ЛиДоступноОткрытиеСвободнойФормы() Тогда
		// Антибаг 8.3.19+ https://www.hostedredmine.com/issues/956304
		//ОткрытьСправкуПоПараметру(, Ложь);
		ФормаПодсказкаПоПараметрам = ФормаВызовМетода();
		ФормаПодсказкаПоПараметрам.ПодключитьОбработчикОжидания("ОткрытьОтложенно", 0.1, Истина); 
		
	КонецЕсли;

КонецПроцедуры  

Процедура ПолучитьГраницыВыделения() Экспорт
	ПолеТекста.ПолучитьГраницыВыделения(мНачальнаяСтрока, мНачальнаяКолонка, мКонечнаяСтрока, мКонечнаяКолонка);
КонецПроцедуры

Процедура УстановитьГраницыВыделения(Знач НачальнаяСтрокаИлиПозиция = Неопределено, Знач НачальнаяКолонкаИлиКонечнаяПозиция = Неопределено, Знач КонечнаяСтрока = Неопределено, Знач КонечнаяКолонка = Неопределено,
	Знач ОшибкаПриВыходеЗаКонец = Истина) Экспорт 
	
	#Если Сервер И Не Сервер Тогда
		ПолеТекста = Обработки.ирОболочкаПолеТекста.Создать();
	#КонецЕсли
	Если НачальнаяСтрокаИлиПозиция = Неопределено Тогда
		НачальнаяСтрокаИлиПозиция = мНачальнаяСтрока;
		НачальнаяКолонкаИлиКонечнаяПозиция = мНачальнаяКолонка;
		КонечнаяСтрока = мКонечнаяСтрока;
		КонечнаяКолонка = мКонечнаяКолонка;
	КонецЕсли;
	//Структура = ПолеТекста.ВыделениеДвумерное();
	//Если Ложь
	//	// Экономная установка для подавления угасания мигания каретки из-за антибага платформы https://www.hostedredmine.com/issues/936432
	//	// Но баг платформы ЗаменитьСтроку() вызывает фактическое выделение всего предшествующего текста иногда без возможности получить настоящие границы выделения на 8.3.18 https://www.hostedredmine.com/issues/936821
	//	Или Структура.НачальнаяСтрока <> мНачальнаяСтрока 
	//	Или Структура.НачальнаяКолонка <> мНачальнаяКолонка 
	//	Или Структура.КонечнаяСтрока <> мКонечнаяСтрока 
	//	Или Структура.КонечнаяКолонка <> мКонечнаяКолонка 
	//Тогда
		ПолеТекста.УстановитьГраницыВыделения(НачальнаяСтрокаИлиПозиция, НачальнаяКолонкаИлиКонечнаяПозиция, КонечнаяСтрока, КонечнаяКолонка,, ФормаВладелец, ОшибкаПриВыходеЗаКонец);
	//КонецЕсли; 

КонецПроцедуры

Функция ФорматироватьТекстЯзыкаЗапросов() Экспорт
	
	ВыделениеДвумерное = ПолеТекста.ВыделениеДвумерное();
	ВыделенныйТекст = ВыделенныйТекст();
	ТолькоВыделенныйТекст = СтрДлина(ВыделенныйТекст) > 10;
	Если ТолькоВыделенныйТекст Тогда
		ТекстЗапроса = ВыделенныйТекст;
	Иначе
		ТекстЗапроса = ПолеТекста.ПолучитьТекст();
	КонецЕсли;
	КонструкторЗапроса = ПолучитьФорму("КонструкторЗапроса");
	КонструкторЗапроса.ВосстановитьНастройкиФормы();
	Результат = Ложь;
	Попытка
		Если ЗагрузитьТекстВКонструктор(ТекстЗапроса, КонструкторЗапроса) Тогда 
			НовыйТекст = КонструкторЗапроса.СобратьПолныйТекст(, Истина); 
			Если Не ТолькоВыделенныйТекст Тогда
				ВыделитьВесьТекст();
			КонецЕсли;
			мЗаменяемыйДиапазон = ПолеТекста.ВыделениеОдномерное();
			ЗаменитьВыделенныйТекстЗапросаСоСнятиемВыделения(НовыйТекст);
			мЗамещающийФрагмент = НовыйТекст;
			Результат = Истина;
		КонецЕсли;
		ПолеТекста.УстановитьВыделениеДвумерное(ВыделениеДвумерное);
		ПолучитьГраницыВыделения();
	Исключение
		ИнформацияОбОшибке = ИнформацияОбОшибке();
		ирОбщий.СообщитьЛкс(КраткоеПредставлениеОшибки(ИнформацияОбОшибке));
	КонецПопытки; 
	Возврат Результат;

КонецФункции

Функция ФорматироватьТекстВстроенногоЯзыка(Знач МожноВесьТекст = Истина, Знач БазовыйУровень = Неопределено) Экспорт 
	
	ВыделенныйТекст = ВыделенныйТекст();
	НачальнаяСтрока = мНачальнаяСтрока;
	КонечнаяСтрока = мКонечнаяСтрока;
	Если ПустаяСтрока(ВыделенныйТекст) Тогда
		Если Не МожноВесьТекст Тогда
			Возврат Ложь;
		КонецЕсли;
		ВыделитьВесьТекст();
		НачальнаяСтрока = 1;
		КонечнаяСтрока = ПолеТекста.КоличествоСтрок() + 1;
	КонецЕсли; 
	УстановитьГраницыВыделения(НачальнаяСтрока, 1, КонечнаяСтрока + ?(мКонечнаяКолонка = 1, 0, 1), 1); // Выделяем полные строки
	Если ФормаВладелец = Неопределено Тогда
		мЗаменяемыйДиапазон = ПолеТекста.ВыделениеОдномерное();
	КонецЕсли;
	ВыделенныйТекст = ВыделенныйТекст();
	НовыйТекст = СтроитьДеревоПрограммныхСкобок(ВыделенныйТекст, НачальнаяСтрока,,, БазовыйУровень);
	//НовыйТекст = ирОбщий.СтрокаБезКонцаЛкс(НовыйТекст);
	ПолеТекста.ВставитьТекст(НовыйТекст, Ложь); 
	Если ФормаВладелец = Неопределено Тогда
		мЗамещающийФрагмент = НовыйТекст;
		Если мНачальнаяСтрока <> Неопределено Тогда
			УстановитьГраницыВыделения();
		КонецЕсли;
	КонецЕсли;
	Возврат Истина;

КонецФункции

// .
// Параметры:
//  ВыделенныйТекст			 - Строка - 
//  НачальнаяСтрока			 - Число - 
//  ПозицияДляСбораРодителей - Число - начиная с 1
//  выхРодителиПозиции		 - см. РодителиПозицииВТексте() - 
//  БазовыйУровень			 - Число - 
// 
// Возвращаемое значение:
//  Строка - 
//
Функция СтроитьДеревоПрограммныхСкобок(Знач ВыделенныйТекст = "", Знач НачальнаяСтрока = 1, Знач ПозицияДляСбораРодителей = 0, выхРодителиПозиции = Неопределено, Знач БазовыйУровень = Неопределено,
	Знач ТолькоПервый = Ложь) Экспорт
	
	Если Не ЗначениеЗаполнено(ВыделенныйТекст) Тогда
		ВыделенныйТекст = ОпределениеМетодаБезОписания();
	КонецЕсли;
	ЧислоПробеловВТабуляции = 4;
	ТекстДокумент = Новый ТекстовыйДокумент;
	ТекстДокумент.УстановитьТекст(ВыделенныйТекст);
	ГруппыКлючевыхСлов = Новый Массив;
	// * - означает любая строка
	ГруппыКлючевыхСлов.Добавить("#?(Если|ИначеЕсли|Для|Пока)*(Тогда|Цикл),#?Иначе,#?(КонецЕсли|КонецЦикла)");
	СтроитьКарту = ПозицияДляСбораРодителей > 0;
	Если ТолькоПервый Или Не СтроитьКарту Тогда 
		ГруппыКлючевыхСлов.Добавить("(?:Процедура|Функция|Попытка|#Область)*,Исключение,(?:КонецПроцедуры|КонецФункции|КонецПопытки|#КонецОбласти)");
		//ГруппыКлючевыхСлов.Добавить("(?:Процедура|Функция|Попытка)*\),Исключение,(?:КонецПроцедуры|КонецФункции|КонецПопытки)");
	КонецЕсли;
	Если СтроитьКарту Тогда
		ОткрытыеСкобки = Новый СписокЗначений;  
		ПредУровеньСтроки = 0;
		ПредУровеньВыражения = 0;
		ПредСтрока = Неопределено;
		ПредСловоНайдено = Истина;
		Если ТипЗнч(выхРодителиПозиции) <> Тип("ТаблицаЗначений") Тогда
			выхРодителиПозиции = РодителиПозицииВТексте();
		КонецЕсли;
	КонецЕсли;    
	УровеньИнструкции = 0;
	УровеньВыражения = 0;
	УровеньНачалаУсловия = 0; 
	ПозицияНачалаСтроки = 0;
	ВхожденияКэш = ирКэш.ВычислительРегВыраженийЛкс().НоваяТаблицаВхождений();
	ПерваяСтрока = ПолеТекста.ПолучитьСтроку(Макс(1, НачальнаяСтрока - 1));
	СмещениеПервойСтроки = ирОбщий.НепечатноеНачалоСтрокиЛкс(ПерваяСтрока);
	СмещениеПервойСтроки = СтрЗаменить(СмещениеПервойСтроки, Символы.Таб, ирОбщий.СтрокаПовторомЛкс(" ", ЧислоПробеловВТабуляции));
	Если БазовыйУровень = Неопределено Тогда
		БазовыйУровень = Цел(СтрДлина(СмещениеПервойСтроки) / ЧислоПробеловВТабуляции);
	КонецЕсли;
	Если НачальнаяСтрока > 1 Тогда
		ТекстДокумент.ВставитьСтроку(1, ПерваяСтрока);
	КонецЕсли;
	СжиматьВнутренниеПустотыВСтроке = ЛиСжиматьВнутренниеПустотыВСтроке();
	СжиматьПустыеСтроки = ЛиСжиматьПустыеСтроки();
	РегВыражениеКэш = Неопределено;
	УровеньКомментированногоБлока = Неопределено;
	Для СчетчикСтроки = 1 По ТекстДокумент.КоличествоСтрок() Цикл
		СтрокаТекста = ТекстДокумент.ПолучитьСтроку(СчетчикСтроки);
		Если Истина
			И Лев(СокрЛ(СтрокаТекста), 1) = "~" 
			И Прав(СокрП(СтрокаТекста), 1) = ":"
		Тогда 
			// Метка
			ТекстДокумент.ЗаменитьСтроку(СчетчикСтроки, СокрЛ(СтрокаТекста));
			Продолжить;
		КонецЕсли;
		СтрокаБезКраев = СокрЛП(СтрокаТекста);
		СтрокаТекстаДоКомментария = ЗалитьКомментарииИСтроковыеЛитералы(СтрокаБезКраев,, Истина,, Истина, Ложь);
		СтрокаБезКраевИЛитералов = СокрЛП(СтрокаТекстаДоКомментария);
		Если Истина
			И СчетчикСтроки > 1
			И СжиматьПустыеСтроки 
			И Не ЗначениеЗаполнено(СтрокаБезКраев) 
		Тогда
			Если СчетчикСтроки = ТекстДокумент.КоличествоСтрок() Тогда
				СледСтрока = "";
			Иначе
				СледСтрока = СокрЛ(ТекстДокумент.ПолучитьСтроку(СчетчикСтроки + 1));
			КонецЕсли;
			МожноУдалить = Истина;
			Если ПустаяСтрока(ПредСтрока) Тогда
				//
			ИначеЕсли Истина
				И (Ложь
					Или ирОбщий.СтрНачинаетсяСЛкс(СледСтрока, "//") 
					Или ирОбщий.СтрНачинаетсяСЛкс(СледСтрока, "#") 
					Или ирОбщий.СтрНачинаетсяСЛкс(ПредСтрока, "#") 
					Или ирОбщий.СтрНачинаетсяСЛкс(СледСтрока, "&"))
				И Не ирОбщий.СтрНачинаетсяСЛкс(ПредСтрока, "Процедура ")
				И Не ирОбщий.СтрНачинаетсяСЛкс(ПредСтрока, "Функция ")
			Тогда
				МожноУдалить = Ложь;
				УровеньКомментированногоБлока = УровеньИнструкции;
			ИначеЕсли Ложь
				Или (Истина
					И УровеньКомментированногоБлока = УровеньИнструкции
					И Не ирОбщий.СтрНачинаетсяСЛкс(СледСтрока, "Иначе") 
					И Не ирОбщий.СтрНачинаетсяСЛкс(СледСтрока, "Конец")) 
				Или ирОбщий.СтрНачинаетсяСЛкс(СледСтрока, "Процедура ")
				Или ирОбщий.СтрНачинаетсяСЛкс(СледСтрока, "Функция ")
				Или ирОбщий.СтрНачинаетсяСЛкс(ПредСтрока, "КонецПроцедуры") 
				Или ирОбщий.СтрНачинаетсяСЛкс(ПредСтрока, "КонецФункции") 
			Тогда
				МожноУдалить = Ложь;
				УровеньКомментированногоБлока = Неопределено;
			Иначе
				УровеньКомментированногоБлока = Неопределено;
			КонецЕсли;
			Если МожноУдалить Тогда
				ТекстДокумент.УдалитьСтроку(СчетчикСтроки);
				Если мКонечнаяСтрока >= СчетчикСтроки Тогда
					мКонечнаяСтрока = мКонечнаяСтрока - 1;
				КонецЕсли;
				Если ТекстДокумент.КоличествоСтрок() < СчетчикСтроки Тогда
					Прервать;
				КонецЕсли;
				СчетчикСтроки = СчетчикСтроки - 1;
				Продолжить;
			КонецЕсли;
		КонецЕсли;
		Если Истина
			И СжиматьВнутренниеПустотыВСтроке 
			И Лев(СтрокаБезКраев, 1) <> "|" 
			И Не ирОбщий.СтрНачинаетсяСЛкс(СтрокаБезКраев, "//")
		Тогда
			Фрагменты = ирОбщий.СтрРазделитьЛкс(СтрокаБезКраев, """",,,,, Истина);
			Фрагменты[0] = ирОбщий.ЗаменитьРегВыражениеЛкс(Фрагменты[0], "[ \f\t\v]+", " ", Ложь,,,, РегВыражениеКэш);
			СтрокаБезКраев = ирОбщий.СтрСоединитьЛкс(Фрагменты, """");
		КонецЕсли;
		СмещениеУровня = 0;
		СмещениеСледующегоУровня = Неопределено;
		СловоНайдено = НайтиКлючевыеСловаФорматирования(СтрокаТекстаДоКомментария, ГруппыКлючевыхСлов, УровеньИнструкции, УровеньВыражения, УровеньНачалаУсловия, СмещениеСледующегоУровня, ВхожденияКэш,
			РегВыражениеКэш, ПредСтрока);
		УровеньИнструкции = Макс(-БазовыйУровень, УровеньИнструкции);
		Если СчетчикСтроки > 1 Тогда
			Если Не СловоНайдено Тогда
				Если Истина // В конце сигнатуры
					И УровеньВыражения = 1
					И Лев(СтрокаБезКраевИЛитералов, 1) = ")" 
				Тогда
					СмещениеУровня = УровеньВыражения - 2;
				Иначе
					СмещениеУровня = УровеньВыражения;
				КонецЕсли;
			КонецЕсли; 
			УровеньСтроки = БазовыйУровень + УровеньИнструкции + СмещениеУровня;
			ТекстДокумент.ЗаменитьСтроку(СчетчикСтроки, ирОбщий.СтрокаПовторомЛкс(Символы.Таб, УровеньСтроки) + СтрокаБезКраев);
			Если СтроитьКарту Тогда
				//Если ПредУровеньВыражения = 0 Тогда
				Если УровеньСтроки > ПредУровеньСтроки Тогда
					ОткрытыеСкобки.Добавить(ПозицияНачалаСтроки - СтрДлина(ПредСтрока) - 1, ПредСтрока);
				ИначеЕсли Истина
					И УровеньСтроки < ПредУровеньСтроки 
					И ОткрытыеСкобки.Количество() > 0 // 0 в заголовке метода 
				Тогда
					Если ПредУровеньВыражения - УровеньВыражения > 1 Тогда //
						ОткрытыеСкобки.Удалить(ОткрытыеСкобки.Количество() - 1);
						ПредУровеньВыражения = 0;
					КонецЕсли;
					Если ОткрытыеСкобки.Количество() Тогда
						ОписаниеОбласти = ОткрытыеСкобки[ОткрытыеСкобки.Количество() - 1];
						ПозицияНачала = ОписаниеОбласти.Значение;
						ПозицияКонца = ПозицияНачалаСтроки; 
						//ПозицияКонца = ПозицияКонца + СтрДлина(СтрокаТекста);  
						Если Истина
							И ПозицияНачала + СтрДлина(ОписаниеОбласти.Значение) < ПозицияДляСбораРодителей
							И ПозицияКонца > ПозицияДляСбораРодителей 
							И ПредУровеньВыражения = 0
						Тогда
							Родитель = выхРодителиПозиции.Добавить();
							Родитель.Область = ОписаниеОбласти.Представление;
							Родитель.ПозицияНачала = ПозицияНачала;
							Родитель.ПозицияКонца = ПозицияКонца + 1;
							Если ТолькоПервый Тогда
								Прервать;
							КонецЕсли;
						КонецЕсли;
						ОткрытыеСкобки.Удалить(ОткрытыеСкобки.Количество() - 1);
					КонецЕсли;
				КонецЕсли;
				//КонецЕсли;
				ПредУровеньСтроки = УровеньСтроки;
				ПредУровеньВыражения = УровеньВыражения;
			КонецЕсли;
		Иначе
			Если СловоНайдено Тогда
				УровеньИнструкции = 0;
			КонецЕсли;
			Если НачальнаяСтрока = 1 Тогда
				ТекстДокумент.ЗаменитьСтроку(СчетчикСтроки, ирОбщий.СтрокаПовторомЛкс(Символы.Таб, БазовыйУровень) + СтрокаБезКраев);
			КонецЕсли;
		КонецЕсли;
		УровеньИнструкции = УровеньИнструкции + СмещениеСледующегоУровня;
		ПозицияНачалаСтроки = ПозицияНачалаСтроки + СтрДлина(СтрокаТекста + Символы.ПС);
		ПредСтрока = СтрокаТекста;
		Если ПустаяСтрока(СтрокаТекстаДоКомментария) Тогда
			Продолжить;
		КонецЕсли;
		Если Ложь
			Или Лев(СтрокаБезКраевИЛитералов, 1) = "&" 
			Или Прав(СтрокаБезКраевИЛитералов, 1) = ";" 
		Тогда 
			НовыйУровеньВыражения = 0;
		Иначе
			НовыйУровеньВыражения = УровеньВыражения;
			Если НовыйУровеньВыражения = 0 И Не СловоНайдено Тогда
				НовыйУровеньВыражения = 1;
			КонецЕсли;
			НовыйУровеньВыражения = НовыйУровеньВыражения + СтрЧислоВхождений(СтрокаБезКраевИЛитералов, "(") - СтрЧислоВхождений(СтрокаБезКраевИЛитералов, ")");
		КонецЕсли;
		УровеньВыражения = НовыйУровеньВыражения;
	КонецЦикла;
	Если НачальнаяСтрока > 1 Тогда
		ТекстДокумент.УдалитьСтроку(1);
	КонецЕсли;
	НовыйТекст = ТекстДокумент.ПолучитьТекст();
	Если мНачальнаяСтрока <> Неопределено Тогда
		мНачальнаяСтрока = Мин(мКонечнаяСтрока, мНачальнаяСтрока);
	КонецЕсли;
	Возврат НовыйТекст;
КонецФункции

//.
// Возвращаемое значение:
//    ТаблицаЗначений, Неопределено - 
Функция РодителиПозицииВТексте() Экспорт
	выхРодителиПозиции = Новый ТаблицаЗначений;
	выхРодителиПозиции.Колонки.Добавить("Область");
	выхРодителиПозиции.Колонки.Добавить("ПозицияНачала"); // Начиная с 0. Начало последней строки шапки области
	выхРодителиПозиции.Колонки.Добавить("ПозицияКонца"); // Начиная с 0
	Возврат выхРодителиПозиции;
КонецФункции

//.
// Параметры:
//    СтрокаТекстаДоКомментария - Строка, Неопределено - 
//    ГруппыКлючевыхСлов - Массив из Строка - 
//    УровеньНачалаУсловия - Число - 
//    ВхожденияКэш - ТаблицаЗначений - 
//    СмещениеСледующегоУровня - Число - 
// Возвращаемое значение:
//    Булево - 
Функция НайтиКлючевыеСловаФорматирования(Знач СтрокаТекстаДоКомментария, Знач ГруппыКлючевыхСлов, УровеньИнструкции = 0, УровеньВыражения = 0,  УровеньНачалаУсловия = 0, 
	СмещениеСледующегоУровня = Неопределено, ВхожденияКэш = Неопределено, РегВыражениеКэш = Неопределено, Знач ПредСтрока = "") Экспорт
	
	СмещениеСледующегоУровня = 0; 
	СловоНайдено = Ложь;
	НайденоНадежно = Ложь;
	Для Каждого ГруппаКлючевыхСлов Из ГруппыКлючевыхСлов Цикл
		СловаГруппы = ирОбщий.СтрРазделитьЛкс(ГруппаКлючевыхСлов, ",", Истина);
		ШаблонКонцаКонструкции = СловаГруппы[СловаГруппы.ВГраница()];
		Если ирОбщий.НайтиРегВыражениеЛкс(СтрокаТекстаДоКомментария, мПлатформа.шПустоеНачалоСтроки + ШаблонКонцаКонструкции + "(?=//|\s*;|\s*$)",,,,,,, РегВыражениеКэш,, ВхожденияКэш).Количество() > 0 Тогда
			//Если УровеньИнструкции > 0 Тогда
				УровеньИнструкции = УровеньИнструкции - 1;
			//КонецЕсли;
			СловоНайдено = Истина;
		Иначе 
			Для ИндексСлова = 0 По СловаГруппы.ВГраница() - 1 Цикл
				Слово = СловаГруппы[ИндексСлова];
				Если Найти(Слово, "*") = 0 Тогда
					Если ирОбщий.НайтиРегВыражениеЛкс(СтрокаТекстаДоКомментария, мПлатформа.шПустоеНачалоСтроки + Слово + "(?=//|\s*$)",,,,,,, РегВыражениеКэш,, ВхожденияКэш).Количество() > 0 Тогда
						УровеньИнструкции = УровеньИнструкции - 1;
						СловоНайдено = Истина; 
						СмещениеСледующегоУровня = 1;
						УровеньВыражения = 0;
					КонецЕсли;
				Иначе 
					ФрагментыСлова = ирОбщий.СтрРазделитьЛкс(Слово, "*");
					Если ЗначениеЗаполнено(ФрагментыСлова[1]) И ирОбщий.НайтиРегВыражениеЛкс(СтрокаТекстаДоКомментария, мПлатформа.шПустоеНачалоСтроки + ФрагментыСлова[1] + "(?=//|\s*$)",,,,,,, РегВыражениеКэш,, ВхожденияКэш).Количество() > 0 Тогда
						// Конец условия на отдельной строке
						УровеньИнструкции = УровеньНачалаУсловия;
						СловоНайдено = Истина; 
						СмещениеСледующегоУровня = 1;
						УровеньВыражения = 0;
					Иначе
						ЧислоНачалУсловия = ирОбщий.НайтиРегВыражениеЛкс(СтрокаТекстаДоКомментария, мПлатформа.шПустоеНачалоСтроки + ФрагментыСлова[0] + "(?=//|\s|$)",,,,,,, РегВыражениеКэш,, ВхожденияКэш).Количество();
						ПервоеСлово = "";
						Если Истина
							И ЧислоНачалУсловия > 0
							И ВхожденияКэш[0].Группы.Количество() > 0
						Тогда
							ПервоеСлово = ВхожденияКэш[0].Группы[0];
						КонецЕсли;
						НужноИскатьКонецКонструкции = Ложь;
						//Если ФрагментыСлова[1] = "\)" Тогда
						Если ЗначениеЗаполнено(ФрагментыСлова[1]) Тогда
							Вхождения = ирОбщий.НайтиРегВыражениеЛкс(СтрокаТекстаДоКомментария, шПредИмяПрямое + ФрагментыСлова[1] + "(?=//|\s|$)([^\n]*)",,,,,,, РегВыражениеКэш,, ВхожденияКэш);
							ЧислоКонцовУсловия = Вхождения.Количество();
							Если ЧислоКонцовУсловия > 0 Тогда
								КонецСтроки = Вхождения[Вхождения.Количество()-1].Группы[0];
								НужноИскатьКонецКонструкции = ЗначениеЗаполнено(КонецСтроки) И Не ирОбщий.СтрНачинаетсяСЛкс(СокрЛ(КонецСтроки), "//");
							КонецЕсли;
						Иначе
							ЧислоКонцовУсловия = ЧислоНачалУсловия;
						КонецЕсли;
						Если ИндексСлова > 0 Или ПервоеСлово = "ИначеЕсли" Тогда
							УровеньИнструкции = УровеньИнструкции - 1;
						КонецЕсли;
						Если ЧислоНачалУсловия > ЧислоКонцовУсловия Тогда
							УровеньВыражения = 1;
							СловоНайдено = Истина;
							УровеньНачалаУсловия = УровеньИнструкции;
						КонецЕсли;
						Если ЧислоКонцовУсловия > 0 Тогда
							УровеньВыражения = 0;
							СловоНайдено = Истина;
							НайденоНадежно = ЧислоНачалУсловия >= ЧислоКонцовУсловия;
							Если Ложь
								Или (Истина
									И Не НужноИскатьКонецКонструкции 
									И Лев(СтрокаТекстаДоКомментария, 1) <> "#")
								Или (Истина
									И (Ложь
										Или УровеньИнструкции > 0 
										Или Лев(СтрокаТекстаДоКомментария, 1) <> "#"
										Или ЗначениеЗаполнено(ПредСтрока))
									И ирОбщий.НайтиРегВыражениеЛкс(СтрокаТекстаДоКомментария, шПредИмяПрямое + ШаблонКонцаКонструкции + "(?=//|\s*;|\s*$)",,,,,,, РегВыражениеКэш,, ВхожденияКэш).Количество() = 0)
							Тогда
								СмещениеСледующегоУровня = 1;
							КонецЕсли;
						КонецЕсли;
					КонецЕсли;
				КонецЕсли;
				Если СловоНайдено И НайденоНадежно Тогда
					Прервать;
				КонецЕсли;
			КонецЦикла;
		КонецЕсли;
		Если СловоНайдено И НайденоНадежно Тогда
			Прервать;
		КонецЕсли;
	КонецЦикла;
	Возврат СловоНайдено;
КонецФункции

Функция ВыделенныйТекст(Знач НовыйТекст = Неопределено) Экспорт 
	
	#Если Сервер И Не Сервер Тогда
		ПолеТекста = Обработки.ирОболочкаПолеТекста.Создать();
	#КонецЕсли
	Результат = ПолеТекста.ВыделенныйТекст(НовыйТекст);
	Если НовыйТекст <> Неопределено Тогда
		ПослеУстановкиВыделенногоМногострочногоТекста();
	КонецЕсли; 
	Возврат Результат;

КонецФункции

Процедура ДобавитьВТекстЗапросаОтборыПоСтрокеРезультата(ТекущаяСтрокаРезультата, ИменаПолей = Неопределено) Экспорт 
	ТекстЗапроса = ПолеТекста.ПолучитьТекст();
	КонструкторЗапроса = ПолучитьФорму("КонструкторЗапроса");
	КонструкторЗапроса.ВосстановитьНастройкиФормы();
	Если КонструкторЗапроса.ЗагрузитьТекстВКонструктор(ТекстЗапроса, КонструкторЗапроса) Тогда
		КонструкторЗапроса.ЗагрузитьПоследнийЗапрос();
		КонструкторЗапроса.ДобавитьОтборыПоСтрокеРезультата(ТекущаяСтрокаРезультата,, ИменаПолей);
		ВыделитьВесьТекст();
		ВыделенныйТекст(КонструкторЗапроса.СобратьПолныйТекст(, Истина));
		КонструкторЗапроса.ЗагрузитьПараметрыВОбъект();
		ПослеУстановкиВыделенногоМногострочногоТекста();
	КонецЕсли;
КонецПроцедуры

Процедура ВыделитьВесьТекст(ПолеТекста = Неопределено) Экспорт 
	
	Если ПолеТекста = Неопределено Тогда
		ПолеТекста = ЭтотОбъект.ПолеТекста;
	КонецЕсли; 
	КоличествоСтрок = ПолеТекста.КоличествоСтрок();
	#Если Сервер И Не Сервер Тогда
		ПолеТекста = Обработки.ирОболочкаПолеТекста.Создать();
	#КонецЕсли
	ПолеТекста.УстановитьГраницыВыделения(1, 1, Макс(1, КоличествоСтрок), СтрДлина(ПолеТекста.ПолучитьСтроку(КоличествоСтрок) + 1),, ФормаВладелец);

КонецПроцедуры

Процедура ПослеУстановкиВыделенногоМногострочногоТекста()
	
	Перем НачСтрока, НачКолонка, КонСтрока, КонКолонка;
	#Если Сервер И Не Сервер Тогда
		ПолеТекста = Обработки.ирОболочкаПолеТекста.Создать();
	#КонецЕсли
	Если ФормаВладелец = Неопределено Тогда
		Возврат;
	КонецЕсли; 
	Если ТипЗнч(ПолеТекста.ЭлементФормы) = Тип("ПолеТекстовогоДокумента") Тогда
		
		// Антибаг платформы https://partners.v8.1c.ru/forum/topic/1860281 , http://www.hostedredmine.com/issues/840411
		ПолеТекста.ПолучитьГраницыВыделения(НачСтрока, НачКолонка, КонСтрока, КонКолонка);
		ПолеТекста.УстановитьГраницыВыделения(1, 1, 1, 1);
		ПолеТекста.ЭлементФормы.ВыделенныйТекст = "";
		ПолеТекста.УстановитьГраницыВыделения(НачСтрока, НачКолонка, КонСтрока, КонКолонка,, ФормаВладелец);
		
		УстановитьПризнакМодифицированностиФормы();
	КонецЕсли; 

КонецПроцедуры

// Устанавливает фокус на связанное поле программы
Процедура УстановитьФокус(Знач Мягко = Ложь) Экспорт 

	#Если Сервер И Не Сервер Тогда
		ПолеТекста = Обработки.ирОболочкаПолеТекста.Создать();
	#КонецЕсли
	Если ФормаВладелец = Неопределено Тогда
		Возврат;
	КонецЕсли;
	ирОбщий.ПрисвоитьЕслиНеРавноЛкс(ФормаВладелец.ТекущийЭлемент, ПолеТекста.ЭлементФормы); // Условно меняем для ускорения
	Если Не Мягко Тогда
		ВосстановитьФокусВвода();
	КонецЕсли;

КонецПроцедуры

// https://www.hostedredmine.com/issues/931798 и куча похожих
Процедура ВосстановитьФокусВвода()
	
	Возврат; // Модальный режим больше не используем
	
	Если Истина
		И ФормаВладелец <> Неопределено
		И ТипЗнч(ФормаВладелец.ТекущийЭлемент) = Тип("ПолеHTMLДокумента") 
	Тогда
		// https://github.com/salexdv/bsl_console/issues/122
		//ПолеТекста.РедакторHTML().focus();
		//ПолеТекста.РедакторHTML().editor.focus();
		ирКлиент.УстановитьФокусВводаФормеЛкс();
	КонецЕсли;

КонецПроцедуры

Процедура АвтоОбновитьСправку() Экспорт 
	
	Если Ложь
		Или Не ирКлиент.Форма_ВводДоступенЛкс(ФормаВладелец) 
		Или ФормаВладелец.ТекущийЭлемент <> ПолеТекста.ЭлементФормы
	Тогда
		Возврат;
	КонецЕсли; 
	Если мПоследнийРежимВызоваСправки = Неопределено Тогда
		Возврат;
	КонецЕсли; 
	мЭтоАвтоВызов = Истина;
	Кнопка = ирКлиент.КнопкаКоманднойПанелиЭкземпляраКомпонентыЛкс(ЭтотОбъект, мПоследнийРежимВызоваСправки); 
	Нажатие(Кнопка);
	ФормаВладелец.Активизировать();
	мЭтоАвтоВызов = Ложь;
	
КонецПроцедуры

Функция ПолучитьВыделенныйИлиВесьТекст() Экспорт 

	НовыйТекстЗапроса = ВыделенныйТекст();
	Если ПустаяСтрока(НовыйТекстЗапроса) Тогда
		НовыйТекстЗапроса = ПолеТекста.ПолучитьТекст();
	КонецЕсли; 
	Возврат НовыйТекстЗапроса;

КонецФункции

Процедура КопироватьВБуферОбменаТекстВВидеКода() Экспорт

	Текст = ПолучитьВыделенныйИлиВесьТекст();
	ЛиВыделенВесьТекст = Текст = ПолеТекста.ПолучитьТекст();
	Если Прав(Текст, 1) <> Символы.ПС Тогда
		Текст = Текст + Символы.ПС;
	КонецЕсли; 
	Текст = ирОбщий.ТекстВВыражениеВстроенногоЯзыкаЛкс(Текст);
	Если ЛиВыделенВесьТекст Тогда
		ИменованныеЗапросы = мПлатформа.СтруктураРезультатаПакетногоЗапроса(Текст);
		Текст = Текст + ";" + Символы.ПС;
		Для Каждого КлючИЗначение Из ИменованныеЗапросы Цикл
			Текст = Текст + "Индекс_" + КлючИЗначение.Ключ + " = " + XMLСтрока(КлючИЗначение.Значение) + ";" + Символы.ПС;
		КонецЦикла;
	Иначе
		Текст = "|" + ирОбщий.УдалитьВнешниеСкобкиВыраженияЛкс(Текст, """", Символы.ПС + "|""");
	КонецЕсли; 
	ирКлиент.ТекстВБуферОбменаОСЛкс(Текст);

КонецПроцедуры

Процедура Закомментировать(Знач Префикс = "") Экспорт

	#Если Сервер И Не Сервер Тогда
	    ПолеТекста = Новый ТекстовыйДокумент;
	#КонецЕсли
	ПолучитьГраницыВыделения();
	ПерваяСтрока = мНачальнаяСтрока;
	ПерваяКолонка = мНачальнаяКолонка;
	ПоследняяСтрока = мКонечнаяСтрока;
	ПоследняяКолонка = мКонечнаяКолонка;
	КоличествоСтрок = ирОбщий.СтрЧислоСтрокЛкс(ПолеТекста.ПолучитьТекст());  
	ВыделенныйФрагмент = "";
	ДлинаПоследнейСтроки = 0;
	Если ПоследняяКолонка = 1 Тогда 
		ПоследняяСтрока = ПоследняяСтрока - 1;
	КонецЕсли;
	Если ПерваяСтрока >= ПоследняяСтрока И ПоследняяКолонка = 1 Тогда 
		ПоследняяКолонка = Макс(1, СтрДлина(ПолеТекста.ПолучитьСтроку(ПерваяСтрока)));
		ПоследняяСтрока = ПерваяСтрока;
	КонецЕсли;
	Маркер = "//" + Префикс;
	Для НомерСтроки = 1 По КоличествоСтрок Цикл
		Фрагмент = ПолеТекста.ПолучитьСтроку(НомерСтроки);
		Если НомерСтроки >= ПерваяСтрока И НомерСтроки <= ПоследняяСтрока Тогда
			Если НомерСтроки = ПерваяСтрока Тогда 
				ВыделенныйФрагмент = ВыделенныйФрагмент + Маркер + Фрагмент;
			Иначе
				ВыделенныйФрагмент = ВыделенныйФрагмент + Символы.ПС + Маркер + Фрагмент;
			КонецЕсли;
			Если НомерСтроки = ПоследняяСтрока Тогда 
				ДлинаПоследнейСтроки = СтрДлина(Фрагмент) + 3;
			КонецЕсли;
		КонецЕсли;
	КонецЦикла;
	ЗаменитьФрагментТекстаВПоле(ПолеТекста, ВыделенныйФрагмент, ДлинаПоследнейСтроки, ПерваяСтрока, ПоследняяСтрока, ПоследняяКолонка);

КонецПроцедуры  

Процедура Раскомментировать(Знач Префикс = "") Экспорт

	#Если Сервер И Не Сервер Тогда
		ПолеТекста = Обработки.ирОболочкаПолеТекста.Создать();
	#КонецЕсли
	ПолучитьГраницыВыделения();
	ПерваяСтрока = мНачальнаяСтрока;
	ПерваяКолонка = мНачальнаяКолонка;
	ПоследняяСтрока = мКонечнаяСтрока;
	ПоследняяКолонка = мКонечнаяКолонка;
	КоличествоСтрок = ирОбщий.СтрЧислоСтрокЛкс(ПолеТекста.ПолучитьТекст());  
	ВыделенныйФрагмент = "";
	ДлинаПоследнейСтроки = ПоследняяКолонка;
	Если ПоследняяКолонка = 1 Тогда 
		ПоследняяСтрока = ПоследняяСтрока - 1;
	КонецЕсли;
	Если ПерваяСтрока >= ПоследняяСтрока И ПоследняяКолонка = 1 Тогда 
		ПоследняяКолонка = СтрДлина(ПолеТекста.ПолучитьСтроку(ПерваяСтрока));
		ПоследняяСтрока = ПерваяСтрока;
	КонецЕсли;
	Маркер = "//" + Префикс;
	Для НомерСтроки = 1 По КоличествоСтрок Цикл
		Фрагмент = ПолеТекста.ПолучитьСтроку(НомерСтроки);
		Если НомерСтроки >= ПерваяСтрока И НомерСтроки <= ПоследняяСтрока Тогда
			Если ирОбщий.СтрНачинаетсяСЛкс(СокрЛ(Фрагмент), Маркер) Тогда
				Позиция = Найти(Фрагмент, Маркер);
				Фрагмент = Лев(Фрагмент, Позиция - 1) + Сред(Фрагмент, Позиция + СтрДлина(Маркер));
			КонецЕсли;
			Если НомерСтроки = ПерваяСтрока Тогда 
				ВыделенныйФрагмент = ВыделенныйФрагмент + Фрагмент;
			Иначе
				ВыделенныйФрагмент = ВыделенныйФрагмент + Символы.ПС + Фрагмент;
			КонецЕсли;
			Если НомерСтроки = ПоследняяСтрока Тогда 
				ДлинаПоследнейСтроки = СтрДлина(Фрагмент) + 3;
			КонецЕсли;
		КонецЕсли;
	КонецЦикла;
	ЗаменитьФрагментТекстаВПоле(ПолеТекста, ВыделенныйФрагмент, ДлинаПоследнейСтроки, ПерваяСтрока, ПоследняяСтрока, ПоследняяКолонка);
	
КонецПроцедуры

Процедура УдалитьЛевыеТабуляции(ЧислоШагов = 1) Экспорт

	#Если Сервер И Не Сервер Тогда
		ПолеТекста = Обработки.ирОболочкаПолеТекста.Создать();
	#КонецЕсли
	КоличествоСтрок = ирОбщий.СтрЧислоСтрокЛкс(ПолеТекста.ПолучитьТекст());  
	ПерваяСтрока = 1;
	ПерваяКолонка = 1;
	ПоследняяСтрока = КоличествоСтрок;
	ПоследняяКолонка = 50;
	ВыделенныйФрагмент = "";
	ДлинаПоследнейСтроки = ПоследняяКолонка;
	Если ПоследняяКолонка = 1 Тогда 
		ПоследняяСтрока = ПоследняяСтрока - 1;
	КонецЕсли;
	Если ПерваяСтрока >= ПоследняяСтрока И ПоследняяКолонка = 1 Тогда 
		ПоследняяКолонка = СтрДлина(ПолеТекста.ПолучитьСтроку(ПерваяСтрока));
		ПоследняяСтрока = ПерваяСтрока;
	КонецЕсли;
	Маркер = Символы.Таб;
	УдаляемыйФрагмент = "";
	Для Счетчик = 1 По ЧислоШагов Цикл
		УдаляемыйФрагмент = УдаляемыйФрагмент + Маркер;
	КонецЦикла;
	Для НомерСтроки = 1 По КоличествоСтрок Цикл
		Фрагмент = ПолеТекста.ПолучитьСтроку(НомерСтроки);
		Если НомерСтроки >= ПерваяСтрока И НомерСтроки <= ПоследняяСтрока Тогда
			Если ирОбщий.СтрНачинаетсяСЛкс(Фрагмент, УдаляемыйФрагмент) Тогда
				Фрагмент = Сред(Фрагмент, СтрДлина(УдаляемыйФрагмент) + 1);
			КонецЕсли;
			Если НомерСтроки = ПерваяСтрока Тогда 
				ВыделенныйФрагмент = ВыделенныйФрагмент + Фрагмент;
			Иначе
				ВыделенныйФрагмент = ВыделенныйФрагмент + Символы.ПС + Фрагмент;
			КонецЕсли;
			Если НомерСтроки = ПоследняяСтрока Тогда 
				ДлинаПоследнейСтроки = СтрДлина(Фрагмент) + СтрДлина(УдаляемыйФрагмент) + 1;
			КонецЕсли;
		КонецЕсли;
	КонецЦикла;
	ЗаменитьФрагментТекстаВПоле(ПолеТекста, ВыделенныйФрагмент, ДлинаПоследнейСтроки, ПерваяСтрока, ПоследняяСтрока, ПоследняяКолонка);

КонецПроцедуры

Процедура ЗаменитьФрагментТекстаВПоле(Знач ПолеТекста, Знач ВыделенныйФрагмент, Знач ДлинаПоследнейСтроки, Знач ПерваяСтрока, Знач ПоследняяСтрока, Знач ПоследняяКолонка)
	
	#Если Сервер И Не Сервер Тогда
		ПолеТекста = Обработки.ирОболочкаПолеТекста.Создать();
	#КонецЕсли
	Если ПоследняяКолонка = 1 Тогда 
		ПоследняяСтрока = ПоследняяСтрока + 1;
		ДлинаПоследнейСтроки = 1;
		ВыделенныйФрагмент =  ВыделенныйФрагмент + Символы.ПС;
	КонецЕсли;
	ПолеТекста.УстановитьГраницыВыделения(ПерваяСтрока, 1, ПоследняяСтрока, ДлинаПоследнейСтроки);
	ЧислоПереносовСтрокНачальное = СтрЧислоСтрок(ВыделенныйТекст() + "й") - 1;
	Если ЧислоПереносовСтрокНачальное > ПоследняяСтрока - ПерваяСтрока Тогда
		// https://www.hostedredmine.com/issues/925662
		Для Счетчик = 1 По Мин(2, ДлинаПоследнейСтроки - 1) Цикл 
			ДлинаПоследнейСтрокиБезПереноса = ДлинаПоследнейСтроки - Счетчик;
			ПолеТекста.УстановитьГраницыВыделения(ПерваяСтрока, 1, ПоследняяСтрока, ДлинаПоследнейСтрокиБезПереноса);
			Если СтрЧислоСтрок(ВыделенныйТекст() + "й") - 1 < ЧислоПереносовСтрокНачальное Тогда
				Прервать;
			КонецЕсли; 
		КонецЦикла;
	КонецЕсли; 
	ВыделенныйТекст(ВыделенныйФрагмент);
	ПолеТекста.УстановитьГраницыВыделения(ПерваяСтрока, 1, ПоследняяСтрока, ДлинаПоследнейСтроки,, ФормаВладелец);
	УстановитьПризнакМодифицированностиФормы();

КонецПроцедуры 

Процедура ПрочитатьНачалоИКонецТекущейСтроки(Знач ОригинальнаяСтрока = "", Знач НомерПозиции = 0) Экспорт
	СброситьРезультатРазбораПозицииВТексте();   
	Если Не ЗначениеЗаполнено(ОригинальнаяСтрока) Тогда
		//ОригинальнаяСтрока = СокрП(ПолеТекста.ПолучитьСтроку(мКонечнаяСтрока));
		ОригинальнаяСтрока = ПолеТекста.ПолучитьСтроку(мКонечнаяСтрока);
	КонецЕсли;
	Если НомерПозиции = 0 Тогда
		НомерПозиции = мКонечнаяКолонка;
	КонецЕсли;
	Для Счетчик = 0 По НомерПозиции - СтрДлина(ОригинальнаяСтрока) - 2 Цикл
		ОригинальнаяСтрока = ОригинальнаяСтрока + " ";
	КонецЦикла;
	мТекущаяСтрокаНачало = Лев(ОригинальнаяСтрока, НомерПозиции - 1);
	мТекущаяСтрокаКонец = Сред(ОригинальнаяСтрока, НомерПозиции);
	мЭтоТекстовыйЛитерал = ирОбщий.ЛиВнутриТекстовогоЛитералаЛкс(мТекущаяСтрокаНачало);
КонецПроцедуры

Процедура РазобратьКонтекстСтроки(Знач ВзятьЛевоеОтРавенства = Ложь, выхЕстьТочкаСправа = Ложь, Знач КакВызовМетода = Ложь) Экспорт
	мВызовМетода = "";
	Если Ложь
		Или КакВызовМетода = Истина
		Или Истина
			И КакВызовМетода = Неопределено 
			И мЭтоТекстовыйЛитерал 
	Тогда
		ТекущийВызовМетода();
	КонецЕсли; 
	мЭтоОбъявлениеПсевдонима = Ложь;
	мРегВыражение.Global = Ложь;
		
	// Начало контекста 
	СтрокаШаблона = шПредИмяПрямое + "(";
	Если Ложь
		Или мЯзыкПрограммы = 1
		Или мЯзыкПрограммы = 2
	Тогда
		СтрокаШаблона = "(?:" + шРазделитель + "+(КАК|AS|(?:ПОМЕСТИТЬ|INTO(?:" + шРазделитель + "+TABLE)?))" + шРазделитель + "*)?" + СтрокаШаблона + шПрефиксПараметраНеобяз + "(?:" + шИмя + ")?";
	Иначе
		СтрокаШаблона = "()" + СтрокаШаблона + шПрефиксПараметраНеобяз + "(?:" + шИмя + ")?"; 
	КонецЕсли;
	СтрокаШаблона = СтрокаШаблона + шСкобки + "?" + "((\.(" + шИмя + ")" + шСкобки + "?)|" + шИндекс + ")*\.?)?"; 
	Если ВзятьЛевоеОтРавенства Тогда
		СтрокаШаблона = СтрокаШаблона + "(" + шРазделитель + "*(?==|<>)[=<> \t]*(?=[=<> \t])(?:" + шРазделитель + "*Новый(?=[ \t]))?" + СтрокаШаблона + ")";  // Такой сложный прием нужен для для обработки беспробельной операции, например "А=Б"
	КонецЕсли;
	СтрокаШаблона = СтрокаШаблона + "$";
	мРегВыражение.Pattern = СтрокаШаблона;
	Результат = мРегВыражение.НайтиВхождения(мТекущаяСтрокаНачало);
	Если Результат.Количество() > 0 Тогда
		ПервоеВхождение = Результат[0];
		Если ВзятьЛевоеОтРавенства Тогда
			мПозицияВТексте = мПозицияВТексте - СтрДлина(ПервоеВхождение.SubMatches(8)); // Опасно
		КонецЕсли;
		мНачалоКонтекста = "" + ПервоеВхождение.SubMatches(1);
		мЭтоОбъявлениеПсевдонима = ЗначениеЗаполнено(ПервоеВхождение.SubMatches(0)) И Найти(мНачалоКонтекста, ".") = 0;
	КонецЕсли;
	
	// Конец контекста
	мРегВыражение.Global = Ложь;
	Если Не ВзятьЛевоеОтРавенства Тогда
		мРегВыражение.Pattern = "([" + шБуква + "\d]*\(?)(\.)?";
		Результат = мРегВыражение.НайтиВхождения(мТекущаяСтрокаКонец);
		Если Результат.Количество() > 0 Тогда
			мКонецКонтекста = Результат[0].SubMatches(0);
			выхЕстьТочкаСправа = Результат[0].SubMatches(1) <> Неопределено;
		КонецЕсли;
	КонецЕсли; 

	СтрокаШаблона = шПрефиксПараметраНеобяз + "(?:" + шИмя + ")?"; 
	СтрокаШаблона = "(?:((?:" + шИмяСкобки + "?" + "(?:(?:\." + шИмяСкобки + "?)|" + шИндекс + ")*))\.)?(" + СтрокаШаблона + ")?$";
	// Родительский контекст по позиции курсора
	мРегВыражение.Pattern = СтрокаШаблона;
	Результат = мРегВыражение.НайтиВхождения(мНачалоКонтекста);
	Если Результат.Количество() > 0 Тогда
		ПервоеВхождение = Результат[0];
		Если ПервоеВхождение.SubMatches(0) <> Неопределено Тогда 
			мРодительскийКонтекст = ПервоеВхождение.SubMatches(0);
		КонецЕсли;
		Если ПервоеВхождение.SubMatches(4) <> Неопределено Тогда 
			мНачалоСлова = ПервоеВхождение.SubMatches(4);
		КонецЕсли;
	КонецЕсли;
	мТекущееСлово = мНачалоСлова + ирОбщий.ПервыйФрагментЛкс(мКонецКонтекста);
	мКонтекст = мНачалоКонтекста + мКонецКонтекста;
КонецПроцедуры

// Замена операторов внешнего перехода https://partners.v8.1c.ru/forum/t/1849050/m/1849050
Функция ЗаменитьОператорыВнешнегоПерехода(Знач Текст = Неопределено, выхТипыВнешнихПереходов, выхЗаглушкаВозврата = "", выхИмяПараметраТипаВыхода = "") Экспорт 
	
	Перем ИмяМетода;
	#Если Сервер И Не Сервер Тогда
		ПолеТекста = Обработки.ирОболочкаПолеТекста.Создать();
	#КонецЕсли
	УникальнаяСтрока = "1092383289";
	Если Не ЗначениеЗаполнено(выхЗаглушкаВозврата) Тогда
		//выхЗаглушкаВозврата = "Возврат" + УникальнаяСтрока + "=0"; // Вызывает ошибку платформы на "Возврат Не ..." https://www.hostedredmine.com/issues/989028
		выхЗаглушкаВозврата = "Возврат" + УникальнаяСтрока + "=";
	КонецЕсли; 
	Если Не ЗначениеЗаполнено(выхИмяПараметраТипаВыхода) Тогда
		выхИмяПараметраТипаВыхода = "ТипВыхода";
	КонецЕсли; 
	Если Текст <> Неопределено Тогда
		ПолеТекста.УстановитьТекст(Текст);
	КонецЕсли; 
	Если выхТипыВнешнихПереходов = Неопределено Тогда
		выхТипыВнешнихПереходов = Новый Структура;
	КонецЕсли; 
	СтартоваяСтрока = 0;
	Пока Истина Цикл
		ИнформацияОбОшибке = ПроверитьТекстИВернутьОшибку(, СтартоваяСтрока,,, Истина);
		Если ИнформацияОбОшибке = Неопределено Тогда
			Прервать;
		КонецЕсли; 
		// Мультиметка41982035
		ДобавкаЗаглушки = "7";
		ОписаниеОшибки = ИнформацияОбОшибке.Описание;
		Если Найти(ОписаниеОшибки, "Оператор Прервать") > 0 Тогда
			ИмяОператора = "Прервать";
		ИначеЕсли Найти(ОписаниеОшибки, "Оператор Продолжить") > 0 Тогда
			ИмяОператора = "Продолжить";
		ИначеЕсли Найти(ОписаниеОшибки, "Оператор Возврат") > 0 Тогда
			ИмяОператора = "Возврат";
			ДобавкаЗаглушки = "";
		//ИначеЕсли Найти(ОписаниеОшибки, "Оператор Перейти") > 0 Тогда
		//	ИмяОператора = "Перейти"; // TODO
		Иначе
			Прервать;
		КонецЕсли; 
		КоординатыОшибки = КоординатыОшибки(ИнформацияОбОшибке, СтартоваяСтрока);
		выхТипыВнешнихПереходов.Вставить(ИмяОператора);
		
		// Выделяем вхождение имени оператора в ПолеТекста
		ПолеТекста.УстановитьГраницыВыделения(1, 1, КоординатыОшибки.НомерСтроки, КоординатыОшибки.НомерКолонки);
		ТекстовыйДокумент = Новый ТекстовыйДокумент;
		ТекстовыйДокумент.УстановитьТекст(СокрП(ВыделенныйТекст()));
		КоличествоСтрок = ТекстовыйДокумент.КоличествоСтрок();
		ДлинаПоследнейСтроки = СтрДлина(ТекстовыйДокумент.ПолучитьСтроку(КоличествоСтрок) + 1);
		ПолеТекста.УстановитьГраницыВыделения(Макс(1, КоличествоСтрок), ДлинаПоследнейСтроки - СтрДлина(ИмяОператора), Макс(1, КоличествоСтрок), ДлинаПоследнейСтроки);
		
		ВыделенныйТекст(выхИмяПараметраТипаВыхода + " = """ + ИмяОператора + """; " + выхЗаглушкаВозврата + ДобавкаЗаглушки);
		Если ИмяОператора = "Возврат" Тогда 
			// Мультиметка41982035
			ДобавкаЗаглушки = " ";
			ИнформацияОбОшибке = ПроверитьТекстИВернутьОшибку(, СтартоваяСтрока,,, Истина);
			Если ИнформацияОбОшибке <> Неопределено Тогда
				ОписаниеОшибки = ИнформацияОбОшибке.Описание;
				КоординатыОшибкиПосле = КоординатыОшибки(ИнформацияОбОшибке, СтартоваяСтрока);
				Если Истина
					И Найти(ОписаниеОшибки, "Ожидается выражение") > 0
					И КоординатыОшибкиПосле.НомерСтроки = КоординатыОшибки.НомерСтроки 
				Тогда
					ДобавкаЗаглушки = "7";
				КонецЕсли; 
			КонецЕсли;
			ВыделенныйТекст(ДобавкаЗаглушки);
		КонецЕсли; 
	КонецЦикла;
	Текст = ПолеТекста.ПолучитьТекст();
	Возврат Текст;

КонецФункции

Функция КоординатыОшибки(Знач ИнформацияОбОшибке, Знач СтартоваяСтрока = 0) Экспорт 
	
	КоординатыОшибки = Новый Структура("НомерСтроки, НомерКолонки");
	мРегВыражение.Pattern = "{[^\(]*\(([^\)]+)\)}";
	ТекстКоординат = мРегВыражение.НайтиВхождения(ИнформацияОбОшибке.Описание)[0].SubMatches(0);  
	Фрагменты = ирОбщий.СтрРазделитьЛкс(ТекстКоординат, ",", Истина);
	КоординатыОшибки.НомерСтроки = Число(Фрагменты[0]) + СтартоваяСтрока;
	КоординатыОшибки.НомерКолонки = Число(Фрагменты[1]);
	Возврат КоординатыОшибки;

КонецФункции

Процедура ВыделитьТекущееСлово() Экспорт 

	#Если Сервер И Не Сервер Тогда
		ПолеТекста = Обработки.ирОболочкаПолеТекста.Создать();
	#КонецЕсли
	ТекущееОбъектноеВыражение();
	мНачальнаяКолонка = мКонечнаяКолонка - СтрДлина(мНачалоКонтекста);
	Если Не ПустаяСтрока(мРодительскийКонтекст) Тогда
		мНачальнаяКолонка = мНачальнаяКолонка + СтрДлина(мРодительскийКонтекст) + 1;
	КонецЕсли;
	мКонечнаяКолонка = мКонечнаяКолонка + СтрДлина(мКонецКонтекста);
	Если Прав(мКонецКонтекста, 1) = "(" Тогда
		мКонечнаяКолонка = мКонечнаяКолонка - 1;
	КонецЕсли;
	ПолеТекста.УстановитьГраницыВыделения(мНачальнаяСтрока, мНачальнаяКолонка, мКонечнаяСтрока, мКонечнаяКолонка,, ФормаВладелец);

КонецПроцедуры  

// вызывается из адаптера
Функция ПереименоватьСлово(Знач РазрешитьОткрыватьОкна = Истина) Экспорт 

	Форма = ПолучитьФорму("ПереименоватьСлово");
	Форма.РазрешитьОткрыватьОкна = РазрешитьОткрыватьОкна;
	РезультатФормы = Форма.ОткрытьМодально();
	Возврат РезультатФормы;

КонецФункции     

// вызывается из адаптера
Функция УказатьВызывающийМодуль(ИмяМодуля) Экспорт 

	Если Ложь
		Или мМетодМодуля.ВызывающиеМодули = Неопределено
		Или мМетодМодуля.ВызывающиеМодули.Найти(ИмяМодуля) = Неопределено 
	Тогда
		мЗаменяемыйДиапазон = НовыйЗаменяемыйДиапазон();
		мЗаменяемыйДиапазон.Начало = мМетодМодуля.ПозицияСОписанием;
		мЗаменяемыйДиапазон.Конец = мМетодМодуля.ПозицияСОписанием + мМетодМодуля.ДлинаСОписанием - мМетодМодуля.ДлинаОпределения; 
		КомментарийМетода = Сред(мОригинальныйТекст, мЗаменяемыйДиапазон.Начало, мЗаменяемыйДиапазон.Конец - мЗаменяемыйДиапазон.Начало);
		ЗаголовокРазделаВызывающиеМодули = мПлатформа.ЗаголовокРазделаВызывающиеМодули();
		ПозицияРаздела = Найти(КомментарийМетода, ЗаголовокРазделаВызывающиеМодули);
		Если ПозицияРаздела = 0 Тогда
			КомментарийМетода = КомментарийМетода + 
			"// " + ЗаголовокРазделаВызывающиеМодули + "
			|//		" + ИмяМодуля + "
			|";
		Иначе
			КомментарийМетода = СтрЗаменить(КомментарийМетода, ЗаголовокРазделаВызывающиеМодули, ЗаголовокРазделаВызывающиеМодули + "
			|//		" + ИмяМодуля);
		КонецЕсли;
		мЗамещающийФрагмент = КомментарийМетода;
		ПолеТекста.УстановитьГраницыВыделения(мЗаменяемыйДиапазон.Начало, мЗаменяемыйДиапазон.Конец);
		ПолеТекста.ВыделенныйТекст(мЗамещающийФрагмент);
	КонецЕсли;
	ПерейтиКОпределениюЛокальногоМетода(мМетодМодуля, ИмяМодуля,,, Истина);
	Результат = новый Структура("ВесьМодульИзменен", Ложь);
	Возврат Результат;

КонецФункции

//.
// Возвращаемое значение:
//    Структура - 
Функция НовыйЗаменяемыйДиапазон() Экспорт
	Результат = Новый Структура("Начало, Конец");
	//Результат.Вставить("НомерСтроки", мНомерПервойСтрокиТелаМетода);
	Возврат Результат;
КонецФункции

// .
// Параметры:
//  Параметры			 - см. Обработка.ирКонсольКода.Форма.Форма.Параметры -
//  ИмяВременногоМодуля	 - 
// 
// Возвращаемое значение:
//  Булево - применить ли изменения
//
Функция ОткрытьКонструкторМетода(Знач Параметры = Неопределено, Знач ИмяВременногоМодуля = "", Знач ДляОбъявленияТипа = Ложь) Экспорт 
	Перем НачСтрока, НачКолонка, КонСтрока, КонКолонка;

	Если ирОбщий.ПроверитьПлатформаНеWindowsЛкс(,, Истина) Тогда 
		Возврат Ложь;
	КонецЕсли; 
	#Если Сервер И Не Сервер Тогда
		мПлатформа = Обработки.ирПлатформа.Создать();
		ПолеТекста = Обработки.ирОболочкаПолеТекста.Создать();
	#КонецЕсли
	мПлатформа.ИнициацияОписанияМетодовИСвойств();
	КончитьОбработкуКоманды();
	РазобратьТекущийКонтекст();  
	Если мМетодМодуля <> Неопределено И Не ЗначениеЗаполнено(ВыделенныйТекст()) Тогда 
		ЧислоМетодовДобавить = 0;
		ФормаНовогоМетода = ПолучитьФорму("КонструкторМетода", ФормаВладелец);
		ФормаНовогоМетода.РежимВыбора = Истина;
		Если ДляОбъявленияТипа Тогда
			ФормаНовогоМетода.ЗагрузитьТекущийМетод();
			ФормаНовогоМетода.ОбновлениеОтображения(Ложь);
			ФормаНовогоМетода.ПолноеОпределение = Символы.ПС + ФормаНовогоМетода.ЭлементыФормы.ПолеНачала.ПолучитьТекст();
			ДиапазонИзменен = Сред(мОригинальныйТекст, мМетодМодуля.ПозицияСОписанием, мМетодМодуля.ПозицияТела + 1 - мМетодМодуля.ПозицияСОписанием) <> ФормаНовогоМетода.ПолноеОпределение;
			ПолеТекста.УстановитьГраницыВыделения(мМетодМодуля.ПозицияСОписанием, мМетодМодуля.ПозицияТела + 1);
			Если ДиапазонИзменен Тогда
				ВыделенныйТекст(ФормаНовогоМетода.ПолноеОпределение);
			КонецЕсли;
			Возврат ДиапазонИзменен;
		Иначе
			РезультатФормы = ФормаНовогоМетода.ОткрытьМодально();
			Если РезультатФормы = Неопределено Тогда
				Возврат Ложь;
			КонецЕсли ;
			Если Ложь
				Или ФормаВладелец <> Неопределено И ФормаВладелец.ТолькоПросмотр 
				Или ПолеТекста.ТолькоПросмотр() 
			Тогда
				ирКлиент.ОткрытьТекстЛкс(ФормаНовогоМетода.ПолноеОпределение, "Метод " + ФормаНовогоМетода.Имя, "ВстроенныйЯзык");
				ирОбщий.СообщитьЛкс("Поле текста недоступно для изменения.");
				Возврат Ложь;
			КонецЕсли;
			ПолеТекста.УстановитьГраницыВыделения(мМетодМодуля.ПозицияСОписанием, мМетодМодуля.ПозицияСОписанием + мМетодМодуля.ДлинаСОписанием);
			ФормаНовогоМетода.ПолноеОпределение = Символы.ПС + ФормаНовогоМетода.ПолноеОпределение;
			ВыделенныйТекст(ФормаНовогоМетода.ПолноеОпределение);
			ПолеТекста.УстановитьГраницыВыделения(мМетодМодуля.ПозицияОпределения, мМетодМодуля.ПозицияОпределения);
		КонецЕсли;
	Иначе
		ЧислоМетодовДобавить = 1;
		АнализаторКода = ирОбщий.НовыйАнализаторКодаЛкс(0);
		#Если Сервер И Не Сервер Тогда
			АнализаторКода = Обработки.ирКлсПолеТекстаПрограммы.Создать();
			ПараметрыВходаАлгоритма = Новый Структура;
		#КонецЕсли
		АнализаторКода.мФлагиКомпиляции = мФлагиКомпиляции;
		АнализаторКода.ЭтоМодуль = Истина;
		НомераПервойСтрокиТела = 1;
		АнализаторКода.УстановитьТекст(ТелоМетода(мМетодМодуля, НомераПервойСтрокиТела, Ложь));
		//НевидимоеПолеТекста.мМодульМетаданных = мМодульМетаданных;
		СмещениеНомеровСтрок = НомераПервойСтрокиТела - 1;
		Если Не ЗначениеЗаполнено(ВыделенныйТекст()) Тогда
			УстановитьГраницыВыделения(мНомерПервойСтрокиТелаМетода, 1, мНомерПоследнейСтрокиТелаМетода + 1, 1);
		КонецЕсли;
		Если Параметры = Неопределено Тогда
			Параметры = ЭтотОбъект.Параметры;
		КонецЕсли;
		ПолеТекста.ПолучитьГраницыВыделения(НачСтрока, НачКолонка, КонСтрока, КонКолонка);
		Если КонСтрока - СмещениеНомеровСтрок < 1 Или НачСтрока - СмещениеНомеровСтрок < 1 Тогда
			Возврат Ложь;
		КонецЕсли;
		АнализаторКода.ПолеТекста.УстановитьГраницыВыделения(НачСтрока - СмещениеНомеровСтрок, НачКолонка, КонСтрока - СмещениеНомеровСтрок, КонКолонка);
		ТекстНовогоМетода = АнализаторКода.ПолеТекста.ВыделенныйТекст();
		Если Не ЗначениеЗаполнено(ТекстНовогоМетода) Тогда
			Возврат Ложь;
		КонецЕсли;
		ОчиститьСообщения();
		ТекстСмещения = ирОбщий.ПервыеНепечатныеСимволыПервойНепустойСтрокиЛкс(ТекстНовогоМетода);
		//ФормаВладелец.Модифицированность = Истина;
		АнализаторКода.ПолеТекста.УстановитьГраницыВыделения(1, 1, НачСтрока - СмещениеНомеровСтрок, НачКолонка);
		ТекстДо = АнализаторКода.ПолеТекста.ВыделенныйТекст();
		АнализаторКода.ПолеТекста.УстановитьГраницыВыделения(КонСтрока - СмещениеНомеровСтрок, КонКолонка, Макс(1, АнализаторКода.ПолеТекста.КоличествоСтрок()), 300);
		ТекстПосле = АнализаторКода.ПолеТекста.ВыделенныйТекст();
		АнализаторКода.ПолеТекста.УстановитьГраницыВыделения(НачСтрока - СмещениеНомеровСтрок, НачКолонка, КонСтрока - СмещениеНомеровСтрок, КонКолонка);
		ФормаНовогоМетода = АнализаторКода.ПолучитьФорму("КонструкторМетода", ФормаВладелец);
		ЛиКорректныйФрагмент = Истина; 
		ЗаглушкаВозврата = "";
		ИмяПараметраТипаВыхода = "";
		ИмяПеременнойЗаглушки = "Пустышка845234571";
		Разделитель = Символы.ПС + "//Разделитель" + "87г9234" + Символы.ПС;
		ТекстДоИПосле = АнализаторКода.ЗаменитьОператорыВнешнегоПерехода(ТекстДо + Разделитель + ТекстПосле, , ЗаглушкаВозврата, ИмяПараметраТипаВыхода);
		Фрагменты = ирОбщий.СтрРазделитьЛкс(ТекстДоИПосле, Разделитель);
		ТекстДо = Фрагменты[0];
		ТекстПосле = Фрагменты[1];
		ПараметрыМетодаМодуля = мПлатформа.ПараметрыМетодаМодуля(мМетодМодуля);
		Если ПараметрыМетодаМодуля <> Неопределено Тогда
			ВыходныеПараметрыМатеринскогоМетода = ирОбщий.ВыгрузитьСвойствоЛкс(ПараметрыМетодаМодуля,, Новый Структура("Знач", Ложь));
			ТекстПосле = ТекстПосле + Символы.ПС + ирОбщий.СтрСоединитьЛкс(ВыходныеПараметрыМатеринскогоМетода, "",,, ";_=%1 ");
			ВходныеПараметрыМатеринскогоМетода = ирОбщий.ВыгрузитьСвойствоЛкс(ПараметрыМетодаМодуля);
			ТекстДо = ирОбщий.СтрСоединитьЛкс(ВходныеПараметрыМатеринскогоМетода, "",,, "; %1=0 ;") + Символы.ПС + ТекстДо;
		КонецЕсли;
		
		СтруктураПараметровКода = Новый Структура; 
		МетаОбщиеМодули = Метаданные.ОбщиеМодули;
		ТипыВнешнихПереходов = Новый Структура;
		ТекстНовогоМетода = АнализаторКода.ЗаменитьОператорыВнешнегоПерехода(ТекстНовогоМетода, ТипыВнешнихПереходов, ЗаглушкаВозврата, ИмяПараметраТипаВыхода);
		Если ТипыВнешнихПереходов.Количество() > 0 Тогда
			СтрокаПараметра = ФормаНовогоМетода.ТаблицаПараметров.Добавить();
			СтрокаПараметра.Имя = ИмяПараметраТипаВыхода;
			ирОбщий.ОбновитьКопиюСвойстваВНижнемРегистреЛкс(СтрокаПараметра);
			СтрокаПараметра.Вход = Ложь; 
			СтрокаПараметра.Выход = Истина;
			СтрокаПараметра.ТипЗначения = "Строка";
			СтрокаПараметра.Комментарий = "Служебный параметр для перехода после вызова метода";
		КонецЕсли;
		
		ПараметрыИзАлгоритма(ТекстДо + ТекстНовогоМетода + ТекстПосле, АнализаторКода, ЛиКорректныйФрагмент,, Истина);
		Если Не ЛиКорректныйФрагмент Тогда
			Возврат "Ошибка";
		КонецЕсли; 
		
		// Добавим переменные, которые не определены в выделенном фрагменте текста, как входные параметры
		ПараметрыВходаАлгоритма = ПараметрыИзАлгоритма(ТекстНовогоМетода, АнализаторКода, ЛиКорректныйФрагмент,,, Ложь);
		ЗаглушкаТекстаМетода = "";  
		ПоследнийСимволДо = Прав(СокрП(ТекстДо), 1); // Для ускорения
		ЭтоВыражение = Ложь
			Или Не ЛиКорректныйФрагмент 
			Или мНомерПараметра > 0 
			Или ПоследнийСимволДо = "="
			Или ПоследнийСимволДо = "+";
		Если Не ЭтоВыражение Тогда
			ТекстПроверкиВыражения = ТекстДо + Символы.ПС + "Если 1=1 Тогда" + Символы.ПС + ТекстНовогоМетода + Символы.ПС + "КонецЕсли;" + Символы.ПС + ТекстПосле;
			ПараметрыИзАлгоритма(ТекстПроверкиВыражения, АнализаторКода, ЛиКорректныйФрагмент);
		КонецЕсли; 
		Если Не ЛиКорректныйФрагмент Тогда
			// Выделено выражение
			ЭтоВыражение = Истина;
			ЗаглушкаТекстаМетода = "0";
			ПараметрыВходаАлгоритма = ПараметрыИзАлгоритма("ми7ва7в9вц3ая = " + ТекстНовогоМетода, АнализаторКода, ЛиКорректныйФрагмент);
			Если Не ЛиКорректныйФрагмент Тогда
				ПараметрыИзАлгоритма(ТекстНовогоМетода, АнализаторКода,,, Истина, Истина); // Показываем место ошибки
				ирОбщий.СообщитьЛкс("Выделенный фрагмент не является набором целых инструкций или выражением");
				Возврат "Ошибка";
			КонецЕсли; 
		КонецЕсли; 
		АнализаторКода.УстановитьТекст(ТекстДо);
		ФормаНовогоМетода.ТекстСмещения = ТекстСмещения;
		Для Каждого КлючИЗначение Из ПараметрыВходаАлгоритма Цикл
			СтрокаПараметра = ФормаНовогоМетода.ТаблицаПараметров.Добавить();
			СтрокаПараметра.Имя = КлючИЗначение.Ключ;
			ирОбщий.ОбновитьКопиюСвойстваВНижнемРегистреЛкс(СтрокаПараметра);
			СтрокаПараметра.Вход = Истина; 
			СтрокаПараметра.ВходОбязательно = Истина; 
			Если ЛиПервоеПрисвоениеСамозависимо(ТекстПосле, СтрокаПараметра.Имя) Тогда
				СтрокаПараметра.Выход = Истина;
			КонецЕсли;

			// TODO сделать более универсальное экранирование конструктора "Новый <ИмяПеременной>"
			Пока АнализаторКода.НайтиПоказатьСловоВТексте("Новый " + КлючИЗначение.Ключ) Цикл
				АнализаторКода.ПолеТекста.ВыделенныйТекст(ИмяПеременнойЗаглушки);
			КонецЦикла;
			Пока АнализаторКода.НайтиПоказатьСловоВТексте(КлючИЗначение.Ключ) Цикл
				АнализаторКода.ПолеТекста.ВыделенныйТекст(ИмяПеременнойЗаглушки);
			КонецЦикла;
		КонецЦикла;
		ТекстДоПереименованный = АнализаторКода.ПолеТекста.ПолучитьТекст();
		
		// Добавим внутренние переменные, чтобы пользователь мог включить их передачу на выход
		АнализаторКода.ЗаполнитьЛокальныеСвойстваИМетодыПоТексту(,,,, Истина, ТекстНовогоМетода,, Истина);
		ЛокальныеПеременныеНовогоМетода = АнализаторКода.ТаблицаСлов.Выгрузить(Новый Структура("ТипСлова, Определение", "Свойство", "Статистический"));
		АнализаторКода.ЗаполнитьЛокальныеСвойстваИМетодыПоТексту(,,,, Истина, ТекстДо,, Истина);
		ЛокальныеПеременныеДо = АнализаторКода.ТаблицаСлов.Выгрузить(Новый Структура("ТипСлова, Определение", "Свойство", "Статистический"));
		АнализаторКода.ЗаполнитьЛокальныеСвойстваИМетодыПоТексту(,,,, Истина, ТекстПосле,, Истина);
		ЛокальныеПеременныеПосле = АнализаторКода.ТаблицаСлов.Выгрузить(Новый Структура("ТипСлова, Определение", "Свойство", "Статистический"));
		Для Каждого СтрокаПеременной Из ЛокальныеПеременныеНовогоМетода Цикл
			Если Ложь
				Или мФлагиКомпиляции.Сервер И МетаОбщиеМодули.Найти(СтрокаПеременной.НСлово) <> Неопределено
				Или ирОбщий.СтрокиРавныЛкс(СтрокаПеременной.НСлово, ирОбщий.ПервыйФрагментЛкс(ЗаглушкаВозврата, "="))
				Или ирОбщий.СтрокиРавныЛкс(СтрокаПеременной.НСлово, ИмяПараметраТипаВыхода)
			Тогда
				Продолжить; 
			КонецЕсли; 
			СтрокаПараметра = ФормаНовогоМетода.ТаблицаПараметров.Найти(СтрокаПеременной.НСлово, "НИмя");
			Если СтрокаПараметра = Неопределено Тогда
				СтрокаПараметра = ФормаНовогоМетода.ТаблицаПараметров.Добавить();
				СтрокаПараметра.Имя = СтрокаПеременной.Слово;
				ирОбщий.ОбновитьКопиюСвойстваВНижнемРегистреЛкс(СтрокаПараметра);
				Если ЛокальныеПеременныеДо.Найти(СтрокаПеременной.НСлово, "НСлово") <> Неопределено Тогда 
					СтрокаПараметра.Вход = Истина;
					Если ЛиПервоеПрисвоениеСамозависимо(ТекстНовогоМетода, СтрокаПеременной.Слово) Тогда
						СтрокаПараметра.ВходОбязательно = Истина;
					КонецЕсли;
				КонецЕсли;
			КонецЕсли;
			СтрокаПараметра.Выход = ЛокальныеПеременныеПосле.Найти(СтрокаПеременной.НСлово, "НСлово") <> Неопределено;
		КонецЦикла;
		
		// Добавим переменные, которые не определены начиная с первой выделеной строки и до конца текста, как свозные параметры
		ПараметрыСквозныеАлгоритма = ПараметрыИзАлгоритма(ТекстДоПереименованный + ТекстНовогоМетода + ТекстПосле, АнализаторКода, ЛиКорректныйФрагмент, ИмяПеременнойЗаглушки); 
		Если Не ЛиКорректныйФрагмент Тогда
			Возврат "Ошибка";
		КонецЕсли;  
		#Если Сервер И Не Сервер Тогда
			ПараметрыСквозныеАлгоритма = Новый Структура;
		#КонецЕсли
		Для Каждого КлючИЗначение Из ПараметрыСквозныеАлгоритма Цикл
			СтрокаПараметра = ФормаНовогоМетода.ТаблицаПараметров.Найти(НРег(КлючИЗначение.Ключ), "НИмя");
			Если СтрокаПараметра = Неопределено Тогда
				СтрокаПараметра = ФормаНовогоМетода.ТаблицаПараметров.Добавить();
				СтрокаПараметра.Имя = КлючИЗначение.Ключ;
				ирОбщий.ОбновитьКопиюСвойстваВНижнемРегистреЛкс(СтрокаПараметра);
			КонецЕсли; 
			СтрокаПараметра.Вход = Истина;
			//СтрокаПараметра.Выход = Истина;
		КонецЦикла;
		
		// Добавим переменные, которые не определены в следующем тексте, как параметры выхода
		ПараметрыВыходаАлгоритма = ПараметрыИзАлгоритма(ТекстДоПереименованный + ЗаглушкаТекстаМетода + ТекстПосле, АнализаторКода,, ИмяПеременнойЗаглушки);
		#Если Сервер И Не Сервер Тогда
			ПараметрыВыходаАлгоритма = Новый Структура;
		#КонецЕсли

		ПараметрыЗаполнения = мПлатформа.НовыеПараметрыЗаполненияСлов("Свойство", БазовоеРасширениеКонфигурации(),,,,,, мФлагиКомпиляции,,,,, Истина);
		ТаблицаЛокальногоКонтекста = мПлатформа.ТаблицаСловИзСтруктурыТипа(СтруктураТипаМодуля(), ПараметрыЗаполнения);

		ирОбщий.ОбновитьКопиюКолонкиВНижнемРегистреЛкс(ТаблицаЛокальногоКонтекста, "Слово"); 
		//! ТаблицаЛокальногоКонтекста.Колонки.Добавить("НСлово")
		ИмяРезультатаВыражения = ирОбщий.АвтоУникальноеИмяВКоллекцииЛкс(ТаблицаЛокальногоКонтекста, "Результат", "Слово");
		Если ЭтоВыражение Тогда
			ПараметрыВыходаАлгоритма.Вставить(ИмяРезультатаВыражения);
		КонецЕсли; 
		Для Каждого КлючИЗначение Из ПараметрыВыходаАлгоритма Цикл
			СтрокаПараметра = ФормаНовогоМетода.ТаблицаПараметров.Найти(НРег(КлючИЗначение.Ключ), "НИмя");
			Если СтрокаПараметра = Неопределено Тогда
				СтрокаПараметра = ФормаНовогоМетода.ТаблицаПараметров.Добавить();
				СтрокаПараметра.Имя = КлючИЗначение.Ключ;
				ирОбщий.ОбновитьКопиюСвойстваВНижнемРегистреЛкс(СтрокаПараметра);
			КонецЕсли; 
			СтрокаПараметра.Выход = Истина;
			СтрокаПараметра.ВыходОбязательно = Истина;
		КонецЦикла; 

		// Удалим переменные, которые не определены в оригнальном тексте
		ПараметрыВыходаЛожные = ПараметрыИзАлгоритма(ТекстДо + ТекстНовогоМетода + ТекстПосле, АнализаторКода,,,, Ложь);
		#Если Сервер И Не Сервер Тогда
			ПараметрыВыходаЛожные = Новый Структура;
		#КонецЕсли
		Для Каждого КлючИЗначение Из ПараметрыВыходаЛожные Цикл
			Если ЛокальныеПеременныеНовогоМетода.Найти(НРег(КлючИЗначение.Ключ), "НСлово") <> Неопределено Тогда
				Продолжить;
			КонецЕсли; 
			СтрокаПараметра = ФормаНовогоМетода.ТаблицаПараметров.Найти(НРег(КлючИЗначение.Ключ), "НИмя");
			Если СтрокаПараметра <> Неопределено Тогда
				ФормаНовогоМетода.ТаблицаПараметров.Удалить(СтрокаПараметра);
			КонецЕсли; 
		КонецЦикла;
		
		Для Каждого СтрокаПараметра Из ФормаНовогоМетода.ТаблицаПараметров Цикл
			СтрокаПараметра.Обязательный = СтрокаПараметра.Вход; 
			СтрокаПараметра.Позиция = 200;
			
			// Параметры исходного метода
			ПараметрМетода = Неопределено;
			//ПараметрыМетодаМодуля = мПлатформа.ПараметрыМетодаМодуля(мМетодМодуля);
			Если ПараметрыМетодаМодуля <> Неопределено Тогда
				ПараметрМетода = ПараметрыМетодаМодуля.Найти(НРег(СтрокаПараметра.Имя), "НИмя");
				Если ПараметрМетода <> Неопределено Тогда
					СтрокаПараметра.Комментарий = ИзвлечьОписаниеПараметра(ПараметрМетода.Описание);
					СтрокаПараметра.Позиция = ПараметрыМетодаМодуля.Индекс(ПараметрМетода);
					СтрокаПараметра.ТипЗначения = ПараметрМетода.ТипЗначения;
					Если ЗначениеЗаполнено(ПараметрМетода.Значение) Тогда
						СтрокаПараметра.Значение = Вычислить(ПараметрМетода.Значение);
					КонецЕсли;
				КонецЕсли;
			КонецЕсли;
			//Если Не СтрокаПараметра.Вход Тогда 
				Вхождения = ирОбщий.НайтиРегВыражениеЛкс(ТекстПосле, шПредИмяПрямое + СтрокаПараметра.Имя + "[^" + шБуква + "\d](из\s+)?",, Ложь);
				Если Вхождения.Количество() > 0 И ЗначениеЗаполнено(Вхождения[0].Группы[0]) Тогда
					// Первое использование после является созданием итератора
					СтрокаПараметра.Выход = Ложь;
				КонецЕсли;
			//КонецЕсли;
			
			Если ПараметрМетода = Неопределено Тогда
				СтрокаПараметра.СвойствоМодуля = ТаблицаЛокальногоКонтекста.Найти(НРег(СтрокаПараметра.НИмя), "НСлово") <> Неопределено; 
				Если СтрокаПараметра.СвойствоМодуля Тогда
					СтрокаПараметра.Вход = Ложь;
					СтрокаПараметра.Выход = Ложь;
					СтрокаПараметра.ВыходОбязательно = Ложь;
				КонецЕсли;
				// Динамический локальный контекст (например консоль кода)
				СтрокаЭтогоАлгоритмаПараметры = Параметры.Найти(НРег(СтрокаПараметра.Имя), "НИмя");
				Если Истина
					И СтрокаЭтогоАлгоритмаПараметры <> Неопределено 
					И (Ложь
						Или мМетодМодуля = Неопределено
						Или СтрокаЭтогоАлгоритмаПараметры.Модуль)
				Тогда
					СтрокаПараметра.Комментарий = СтрокаЭтогоАлгоритмаПараметры.Комментарий;
					СтрокаПараметра.Позиция = СтрокаЭтогоАлгоритмаПараметры.Позиция + 100;
					СтрокаПараметра.ТипЗначения = СтрокаЭтогоАлгоритмаПараметры.ИмяТипаЗначения;
					СтрокаПараметра.СвойствоМодуля = СтрокаЭтогоАлгоритмаПараметры.Модуль;
					ТипЗначения = ТипЗнч(СтрокаЭтогоАлгоритмаПараметры.Значение);
					Если Ложь
						Или ТипЗначения = Тип("Строка") И СтрДлина(СтрокаЭтогоАлгоритмаПараметры.Значение) < 100
						Или ТипЗначения = Тип("Число")
						Или ТипЗначения = Тип("Булево")
						Или ТипЗначения = Тип("Неопределено")
						Или ТипЗначения = Тип("Null")
					Тогда
						СтрокаПараметра.Значение = СтрокаЭтогоАлгоритмаПараметры.Значение;
					КонецЕсли; 
					Если СтрокаПараметра.Значение <> Неопределено Тогда
						СтрокаПараметра.Обязательный = Ложь;
					КонецЕсли; 
				КонецЕсли;
			КонецЕсли;    
			
			Если Истина
				И Не ЗначениеЗаполнено(СтрокаПараметра.ТипЗначения) 
				И (Ложь
					Или СтрокаПараметра.Вход
					Или СтрокаПараметра.Выход
					Или ФормаНовогоМетода.ТаблицаПараметров.Количество() < 10)
			Тогда
				// Очень долго при большом числе параметров
				ТаблицаТипов = ВычислитьТипЗначенияВыражения(СтрокаПараметра.Имя, ТекстДо + ТекстНовогоМетода);
				СтрокаПараметра.ТипЗначения = мПлатформа.ПредставлениеМассиваСтруктурТипов(ТаблицаТипов,,, Ложь);
			КонецЕсли; 
		КонецЦикла;
		//ЗаменаЗаглушки = Символы.ПС + ТекстСмещения + "Возврат";
		Если ЭтоВыражение Тогда
			ТекстНовогоМетода = Символы.Таб + ИмяРезультатаВыражения + " = " + ТекстНовогоМетода + "
			|;";   
		ИначеЕсли СтрЧислоСтрок(СокрЛП(ТекстНовогоМетода)) = 1 Тогда 
			Присвоения = ирОбщий.НайтиРегВыражениеЛкс(ТекстНовогоМетода, "^\s*(" + шИмя + ")\s*=");
			Если Присвоения.Количество() > 0 Тогда
				ИмяНовогоМетода = Присвоения[0].Группы[0];
			КонецЕсли;
		КонецЕсли; 
		ЗаменаЗаглушкиВозврата = "Возврат";
		// Мультиметка41982035
		ТекстНовогоМетода = СтрЗаменить(ТекстНовогоМетода, ЗаглушкаВозврата + " ", ЗаменаЗаглушкиВозврата);
		ЗаменаЗаглушкиВозврата = ЗаменаЗаглушкиВозврата + " Неопределено";
		ТекстНовогоМетода = СтрЗаменить(ТекстНовогоМетода, ЗаглушкаВозврата + "7", ЗаменаЗаглушкиВозврата);
		Если мМетодМодуля <> Неопределено Тогда
			Если Не ЗначениеЗаполнено(ИмяНовогоМетода) Тогда
				ИмяНовогоМетода = ирОбщий.АвтоУникальноеИмяВКоллекцииЛкс(мМодульМетаданных.Методы, мМетодМодуля.Имя);
			КонецЕсли;
			ФормаНовогоМетода.ЛиАсинх = мМетодМодуля.ЛиАсинх;
			ФормаНовогоМетода.ДирективаКомлиляции = Сред(мМетодМодуля.Аннотация, 2);
		КонецЕсли;
		Если Не ЗначениеЗаполнено(ИмяНовогоМетода) Тогда
			ИмяНовогоМетода = ИмяВременногоМодуля;
		КонецЕсли;
		ФормаНовогоМетода.Имя = ИмяНовогоМетода;
		ФормаНовогоМетода.РежимВыбора = Истина;
		ФормаНовогоМетода.ТекстДо = ТекстДо;
		ФормаНовогоМетода.ТекстТела = ТекстНовогоМетода;
		ФормаНовогоМетода.ТекстПосле = ТекстПосле;
		ФормаНовогоМетода.ЭтоВыражение = ЭтоВыражение;
		ФормаНовогоМетода.ИмяПараметраТипаВыхода = ИмяПараметраТипаВыхода;
		ФормаНовогоМетода.ТипыВнешнихПереходов = ТипыВнешнихПереходов;
		ФормаНовогоМетода.мМодульМетаданных = мМодульМетаданных;
		РезультатФормы = ФормаНовогоМетода.ОткрытьМодально();
		Если РезультатФормы = Неопределено Тогда
			Возврат Ложь;
		КонецЕсли;
		Если Ложь 
			Или ФормаВладелец <> Неопределено И ФормаВладелец.ТолькоПросмотр 
			Или ПолеТекста.ТолькоПросмотр() 
		Тогда
			ирКлиент.ОткрытьТекстЛкс(ФормаНовогоМетода.ПолноеОпределение, "Метод " + ФормаНовогоМетода.Имя, "ВстроенныйЯзык");
			ирОбщий.СообщитьЛкс("Поле текста недоступно для изменения.");
			Возврат Ложь;
		КонецЕсли;
		СтруктураВыделения = ПолеТекста.ВыделениеДвумерное();
		Если мМетодМодуля <> Неопределено Тогда
			ПолеТекста.ВставитьСтроку(мНомерПоследнейСтрокиТелаМетода + 2, Символы.ПС + ФормаНовогоМетода.ПолноеОпределение); 
		КонецЕсли;
		ПолеТекста.УстановитьВыделениеДвумерное(СтруктураВыделения);
		ПолучитьГраницыВыделения();
		ВыделенныйТекст(ФормаНовогоМетода.ТекстВызова);
		Если мМетодМодуля = Неопределено Тогда
			ПолеТекста.ВставитьСтроку(?(мНомерПервойСтрокиТелаМетода = Неопределено, 1, мНомерПервойСтрокиТелаМетода), ФормаНовогоМетода.ПолноеОпределение + Символы.ПС); 
		КонецЕсли;
	КонецЕсли;
	
	Если ФормаВладелец = Неопределено Тогда
		СформироватьЗамещаемыйФрагментИзМетода();
		СформироватьЗамещающийФрагментИзМетодов(ЧислоМетодовДобавить);
		//ПолеТекста.УстановитьГраницыВыделения(ПозицияНачала, ПозицияКонца);
		Возврат ФормаНовогоМетода.ПолноеОпределение;
	КонецЕсли;
	Возврат Истина;

КонецФункции

//.
// Параметры:
//   Параметры -  - 
//   ИмяВременногоМодуля -  - 
//   ДляОбъявленияТипа -  - 
// Возвращаемое значение:
//   Булево - применить ли изменения
Функция ОткрытьКонструкторИзВызоваМетода(Знач Параметры = Неопределено, Знач ИмяВременногоМодуля = "", Знач ДляОбъявленияТипа = Ложь) Экспорт 
	Перем НачСтрока, НачКолонка, КонСтрока, КонКолонка;

	Если ирОбщий.ПроверитьПлатформаНеWindowsЛкс(,, Истина) Тогда 
		Возврат Ложь;
	КонецЕсли; 
	#Если Сервер И Не Сервер Тогда
		мПлатформа = Обработки.ирПлатформа.Создать();
		ПолеТекста = Обработки.ирОболочкаПолеТекста.Создать();
	#КонецЕсли
	мПлатформа.ИнициацияОписанияМетодовИСвойств();
	КончитьОбработкуКоманды();
	РазобратьТекущийКонтекст();  
	ФормаНовогоМетода = ПолучитьФорму("КонструкторМетода", ФормаВладелец);
	АнализаторКода = КопияКомпоненты();
	АнализаторКода.СоздатьСлужебноеПоле();
	ПозицияПослеСкобки = ПолеТекста.ВыделениеОдномерное().Конец + СтрДлина(мКонецКонтекста);
	АнализаторКода.УстановитьГраницыВыделения(ПозицияПослеСкобки, ПозицияПослеСкобки);
	АнализаторКода.РазобратьТекущийКонтекст(,, Истина,,,, ПозицияПослеСкобки);
	Для Каждого ВыражениеПараметра Из АнализаторКода.мФактическиеПараметры Цикл
		Если ПустаяСтрока(ВыражениеПараметра) И АнализаторКода.мФактическиеПараметры.Количество() = 1 Тогда
			Прервать;
		КонецЕсли;
		СтрокаПараметра = ФормаНовогоМетода.ТаблицаПараметров.Добавить();
		СтрокаПараметра.Имя = ирОбщий.ИдентификаторИзПредставленияЛкс(ирОбщий.ПоследнийФрагментЛкс(ВыражениеПараметра));
		ирОбщий.ОбновитьКопиюСвойстваВНижнемРегистреЛкс(СтрокаПараметра);
		СтрокаПараметра.Вход = Истина;
		Если ЗначениеЗаполнено(ВыражениеПараметра) Тогда
			ТаблицаТипов = ВычислитьТипЗначенияВыражения(ВыражениеПараметра);
			СтрокаПараметра.ТипЗначения = мПлатформа.ПредставлениеМассиваСтруктурТипов(ТаблицаТипов,,, Ложь);
		КонецЕсли;
	КонецЦикла;
	ИмяНовогоМетода = ирОбщий.СтрокаБезКонцаЛкс(мКонтекст);
	Если мМетодМодуля <> Неопределено Тогда
		ФормаНовогоМетода.ДирективаКомлиляции = Сред(мМетодМодуля.Аннотация, 2);
	КонецЕсли;
	ФормаНовогоМетода.Имя = ИмяНовогоМетода;
	ФормаНовогоМетода.РежимВыбора = Истина;
	ЗаполнитьТаблицуСлов(, Ложь,,, Ложь); // - Нужно для РассчитатьОжидаемыйТипВыражения
	ОжидаемыйТип = РассчитатьОжидаемыйТипВыражения(, Истина);   
	ТелоМетода = Новый Массив;
	Если ЛиВнутриВыражения(СтруктураТипаМодуля()) Тогда
		СтрокаПараметра = ФормаНовогоМетода.ТаблицаПараметров.Добавить();
		СтрокаПараметра.Имя = "Результат";
		ирОбщий.ОбновитьКопиюСвойстваВНижнемРегистреЛкс(СтрокаПараметра);
		СтрокаПараметра.ЭтоРезультат = Истина;
		Если ОжидаемыйТип <> Неопределено Тогда
			СтрокаПараметра.ТипЗначения = мПлатформа.ПредставлениеМассиваСтруктурТипов(ОжидаемыйТип.ТаблицаОжидаемыхТипов,,, Ложь);
		КонецЕсли;
		ТелоМетода.Добавить("Результат = Неопределено;");
	КонецЕсли;
	ТелоМетода.Добавить("ВызватьИсключение ""Не реализован"";"); // - тело должно быть непустым, чтобы не включался режим конструктора текущего метода
	ФормаНовогоМетода.ТекстТела = ирОбщий.СтрСоединитьЛкс(ТелоМетода, Символы.ПС); 
	ФормаНовогоМетода.мМодульМетаданных = мМодульМетаданных;
	РезультатФормы = ФормаНовогоМетода.ОткрытьМодально();
	Если РезультатФормы = Неопределено Тогда
		Возврат Ложь;
	КонецЕсли;
	Если Ложь 
		Или ФормаВладелец <> Неопределено И ФормаВладелец.ТолькоПросмотр 
		Или ПолеТекста.ТолькоПросмотр() 
	Тогда
		ирКлиент.ОткрытьТекстЛкс(ФормаНовогоМетода.ПолноеОпределение, "Метод " + ФормаНовогоМетода.Имя, "ВстроенныйЯзык");
		ирОбщий.СообщитьЛкс("Поле текста недоступно для изменения.");
		Возврат Ложь;
	КонецЕсли;
	СтруктураВыделения = ПолеТекста.ВыделениеДвумерное();
	Если мМетодМодуля <> Неопределено Тогда
		ПолеТекста.ВставитьСтроку(мНомерПоследнейСтрокиТелаМетода + 2, Символы.ПС + ФормаНовогоМетода.ПолноеОпределение); 
	КонецЕсли;
	ПолеТекста.УстановитьВыделениеДвумерное(СтруктураВыделения);
	ПолучитьГраницыВыделения();
	Если мМетодМодуля = Неопределено Тогда
		ПолеТекста.ВставитьСтроку(?(мНомерПервойСтрокиТелаМетода = Неопределено, 1, мНомерПервойСтрокиТелаМетода), ФормаНовогоМетода.ПолноеОпределение + Символы.ПС); 
	КонецЕсли;
	Если ФормаВладелец = Неопределено Тогда
		СформироватьЗамещаемыйФрагментИзМетода();
		СформироватьЗамещающийФрагментИзМетодов(1);
		//ПолеТекста.УстановитьГраницыВыделения(ПозицияНачала, ПозицияКонца);
		Возврат ФормаНовогоМетода.ПолноеОпределение;
	КонецЕсли;
	Возврат Истина;

КонецФункции

Функция ИзвлечьОписаниеПараметра(Знач ОписаниеПараметра) Экспорт
	Возврат ирОбщий.ЗаменитьРегВыражениеЛкс(ОписаниеПараметра, "(^\s*-\s*)", "", Ложь);
КонецФункции

Процедура СформироватьЗамещаемыйФрагментИзМетода() Экспорт
	мЗаменяемыйДиапазон = НовыйЗаменяемыйДиапазон();
	Если мМетодМодуля <> Неопределено Тогда
		мЗаменяемыйДиапазон.Начало = мМетодМодуля.ПозицияСОписанием;
		мЗаменяемыйДиапазон.Конец = мМетодМодуля.ПозицияСОписанием + мМетодМодуля.ДлинаСОписанием;
	Иначе 
		мЗаменяемыйДиапазон.Начало = мМодульМетаданных.ПозицияПрограммы;
		мЗаменяемыйДиапазон.Конец = СтрДлина(мОригинальныйТекст); 
	КонецЕсли;
КонецПроцедуры

// Начинает с текущего метода
Процедура СформироватьЗамещающийФрагментИзМетодов(Знач ЧислоМетодовДобавить = 1) Экспорт
	Если мМетодМодуля <> Неопределено Тогда
		ИндексМетода = мМодульМетаданных.Методы.Индекс(мМетодМодуля);
	Иначе 
		ИндексМетода = Неопределено;
	КонецЕсли;
	РазобратьТекущийКонтекст();
	мЗамещающийФрагмент = Неопределено;
	Если ИндексМетода <> Неопределено Тогда
		Начало = мМодульМетаданных.Методы[ИндексМетода].ПозицияСОписанием;  
		СтрокаМетода = мМодульМетаданных.Методы[ИндексМетода + ЧислоМетодовДобавить];
		Конец = СтрокаМетода.ПозицияОпределения + СтрокаМетода.ДлинаОпределения;
		мЗамещающийФрагмент = Сред(мОригинальныйТекст, Начало, Конец - Начало);
	ИначеЕсли мМодульМетаданных.Методы.Количество() > 0 Тогда
		мЗамещающийФрагмент = Символы.ПС + Сред(мОригинальныйТекст, мМодульМетаданных.Методы[мМодульМетаданных.Методы.Количество() - 1].ПозицияСОписанием);
	КонецЕсли;
КонецПроцедуры

// Проверка на самозависимое присвоение, например Ф = Ф + 1
// Параметры:
//    ТекстПрограммы - Строка - 
//    Переменная - Строка - 
// Возвращаемое значение:
//    Число - 
Функция ЛиПервоеПрисвоениеСамозависимо(Знач ТекстПрограммы, Знач Переменная) Экспорт
	ПервоеПрисвоение = ирОбщий.НайтиРегВыражениеЛкс(ТекстПрограммы, шПредИмяПрямое + Переменная + "\s*(?==)(?:(" + шПредИмяПрямое + Переменная + "[^\("+ мПлатформа.шБукваЦифра +"])|[^;])*?" + шКонецИнструкции(),, Ложь);
	Результат = ПервоеПрисвоение.Количество() > 0 И ЗначениеЗаполнено(ПервоеПрисвоение[0].Группы[0]);
	Возврат Результат;
КонецФункции

//.
// Возвращаемое значение:
//     - 
Функция шКонецИнструкции() Экспорт
	Возврат "(?:;|$|(?:" + мПлатформа.шПустоеНачалоСтроки + "(?:Иначе|ИначеЕсли|КонецЕсли|КонецЦикла|Исключение|КонецПопытки|КонецФункции|КонецПроцедуры)))";
КонецФункции

Функция СтруктураТипаМодуля() Экспорт
	СтруктураТипаМодуля = мМодульМетаданных.СтруктураТипа;
	Если СтруктураТипаМодуля = Неопределено Тогда
		СтруктураТипаМодуля = мПлатформа.СтруктураТипаИзКонкретногоТипа(Тип("ОбщийМодуль"));
	КонецЕсли;
	Возврат СтруктураТипаМодуля;
КонецФункции

Функция ЗаменитьВозвратыНаПерейтиВТекстеМетода(Знач Текст = Неопределено, Знач ИмяПеременнойРезультата = "Результат", Знач ДобавлятьПереносыСтрок = Ложь, Знач ИмяМетки = "Конец", Знач ВставитьМетку = Ложь) Экспорт
	
	Если Текст = Неопределено Тогда
		Текст = ПолеТекста.ПолучитьТекст();
	КонецЕсли;
	РегВыражение = мРегВыражение;
	РегВыражение.Global = Истина;
	РегВыражение.MultiLine = Ложь;
	
	// Шаблон тут можно улучшить
	РегВыражение.Pattern = "((?:^|\n|\r)(?:\t| )*(?:" + шНачалоДок + "\s*)?)Возврат(?=[\t\n\r\( ])(\s*(?:" + шЛитералПрограммы + "|[^\n\r;])+)($|\n|\r|;)";
	Если ДобавлятьПереносыСтрок Тогда
		Разделитель = Символы.ПС + "$1";
	Иначе
		Разделитель = " ";
	КонецЕсли;
	ЗаменитьНа = "$1" + ИмяПеременнойРезультата + "=$2";
	Если ИмяМетки <> Неопределено Тогда
		ЗаменитьНа = ЗаменитьНа + ";" + Разделитель + "Перейти ~" + ИмяМетки;
	КонецЕсли;
	ЗаменитьНа = ЗаменитьНа + "$3";
	Текст = РегВыражение.Заменить(Текст, ЗаменитьНа);
	Если ИмяМетки <> Неопределено Тогда
		РегВыражение.Pattern = "((?:^|\n|\r)(?:\t| )*)Возврат(?:\t| )*($|\n|\r|;)";
		Текст = РегВыражение.Заменить(Текст, "$1Перейти ~" + ИмяМетки + "$2");
	КонецЕсли;
	Если ВставитьМетку Тогда
		Текст = Текст + "
		|;
		|~" + ИмяМетки + ":";
	КонецЕсли;
	Возврат Текст;
	
КонецФункции

Функция ПараметрыИзАлгоритма(Знач ТекстДляПроверки, Знач НевидимоеПолеПрограммы, выхКорректныйФрагмент = Истина, Знач ИгнорироватьПеременную = "", Знач ПоказыватьСтрокуОшибки = Ложь, Знач ВыводитьОшибку = Истина) Экспорт 
	
	#Если Сервер И Не Сервер Тогда
		НевидимоеПолеПрограммы = Обработки.ирКлсПолеТекстаПрограммы.Создать();
		мПлатформа = Обработки.ирПлатформа.Создать();
	#КонецЕсли
	СтруктураПараметровКода = Новый Структура;
	МетаОбщиеМодули = Метаданные.ОбщиеМодули;
	мСмещениеНомеровСтрок = 0; 
	ТекстДляПроверки = ЗаменитьВозвратыНаПерейтиВТекстеМетода(ТекстДляПроверки,,, "КонецСлужебный", Истина);
	ТекстДляПроверки = мПлатформа.ЗамаскироватьДирективыПрепроцессора(ТекстДляПроверки, Ложь);
	ТекстДляПроверки = УдалитьЖдатьВТекстеМетода(ТекстДляПроверки); 
	НевидимоеПолеПрограммы.УстановитьТекст(ТекстДляПроверки);
	Пока Истина Цикл
		ИнформацияОбОшибке = НевидимоеПолеПрограммы.ПроверитьТекстИВернутьОшибку(, мСмещениеНомеровСтрок, , , Истина);
		НеопределенныйМетод = мПлатформа.ИмяНеопределенногоМетодаИзИнформацииОбОшибке(ИнформацияОбОшибке);
		Если НеопределенныйМетод <> Неопределено Тогда
			КоординатыОшибки = НевидимоеПолеПрограммы.КоординатыОшибки(ИнформацияОбОшибке, мСмещениеНомеровСтрок);
			НачальнаяКолонка = КоординатыОшибки.НомерКолонки;
			НевидимоеПолеПрограммы.ПолеТекста.УстановитьГраницыВыделения(КоординатыОшибки.НомерСтроки, НачальнаяКолонка, КоординатыОшибки.НомерСтроки, НачальнаяКолонка);
			НевидимоеПолеПрограммы.ПолеТекста.ВыделенныйТекст("ирОбщий.");
			Продолжить;
		КонецЕсли; 
		НеопределеннаяПеременная = мПлатформа.ИмяНеопределеннойПеременнойИзИнформацииОбОшибке(ИнформацияОбОшибке);
		Если Не ЗначениеЗаполнено(НеопределеннаяПеременная) Тогда
			выхКорректныйФрагмент = ИнформацияОбОшибке = Неопределено;
			Если Не выхКорректныйФрагмент И ВыводитьОшибку Тогда
				// Сообщим ошибку
				Если ПоказыватьСтрокуОшибки Тогда 
					//Если ФормаВладелец <> Неопределено Тогда
					//	ФормаВладелец.ТекущийЭлемент = ПолеТекста.ЭлементФормы;
					//	ПолеТекстаВременное = ПолеТекста;
					//Иначе
						ФормаТекста = ирКлиент.ОткрытьТекстЛкс(ТекстДляПроверки,, "ВстроенныйЯзык");
						ПолеТекстаВременное = ФормаТекста.ЭлементыФормы.ВстроенныйЯзык;
					//КонецЕсли;
					ирКлиент.ПоказатьОшибкуВТекстеПрограммыЛкс(ПолеТекстаВременное, мСмещениеНомеровСтрок,,,, ИнформацияОбОшибке);
				Иначе
					НевидимоеПолеПрограммы.ПроверитьПрограммныйКод();
				КонецЕсли; 
			КонецЕсли; 
			Прервать;
		КонецЕсли;
		Если мФлагиКомпиляции.Сервер И МетаОбщиеМодули.Найти(НеопределеннаяПеременная) <> Неопределено Тогда
			//
		Иначе
			Если Ложь
				Или Не ЗначениеЗаполнено(ИгнорироватьПеременную) 
				Или Не ирОбщий.СтрокиРавныЛкс(ИгнорироватьПеременную, НеопределеннаяПеременная) 
			Тогда
				СтруктураПараметровКода.Вставить(НеопределеннаяПеременная);
			КонецЕсли; 
		КонецЕсли; 
		НевидимоеПолеПрограммы.ПолеТекста.ВставитьСтроку(1, НеопределеннаяПеременная + "=0;");
		мСмещениеНомеровСтрок = мСмещениеНомеровСтрок + 1;
	КонецЦикла;
	Возврат СтруктураПараметровКода;

КонецФункции

Функция УдалитьЖдатьВТекстеМетода(Знач Текст, выхЕстьВхождения = Ложь) Экспорт
	
	мРегВыражение.Global = Истина;
	мРегВыражение.MultiLine = Ложь;
	мРегВыражение.Pattern = "((?:^|\n)[^\n\|\""]*)(Ждать)($|\s)";
	НовыйТекст = мРегВыражение.Заменить(Текст, "$1$3");
	выхЕстьВхождения = НовыйТекст <> Текст;
	Возврат НовыйТекст;
	
КонецФункции

Процедура ВыделитьТекущееОбъектноеВыражение() Экспорт 

	#Если Сервер И Не Сервер Тогда
		ПолеТекста = Обработки.ирОболочкаПолеТекста.Создать();
	#КонецЕсли
	ТекущееОбъектноеВыражение();
	мНачальнаяКолонка = мКонечнаяКолонка - СтрДлина(мНачалоКонтекста);
	мКонечнаяКолонка = мКонечнаяКолонка + СтрДлина(мКонецКонтекста);
	Если Прав(мКонецКонтекста, 1) = "(" Тогда
		мКонечнаяКолонка = мКонечнаяКолонка - 1;
	КонецЕсли;
	ПолеТекста.УстановитьГраницыВыделения(мНачальнаяСтрока, мНачальнаяКолонка, мКонечнаяСтрока, мКонечнаяКолонка,, ФормаВладелец);

КонецПроцедуры

// Получает путь к описанию заданного контекста.
//
// Параметры:
//  ПутьКСлову   - Строка;
//  *СтрокаОписания - СтрокаТаблицыЗначений - возвращаемая строка описания;
//  *ВключатьПутьКОписаниюТипаЗначения - Булево, *Неопределено - признак добавления в список выбора тип значения слова.
//
Функция НайтиПоказатьСправкуПоСлову(Знач ПутьКСлову, ВключатьПутьКОписаниюТипаЗначения = Ложь, выхФормаВыбора = Неопределено, РазрешитьАнализИмениТипа = Истина,
	ВладелецФормы = Неопределено) Экспорт

	#Если Сервер И Не Сервер Тогда
		мПлатформа = Обработки.ирПлатформа.Создать();
	#КонецЕсли
	ТаблицаТиповКонтекста = ВычислитьТипЗначенияВыражения(ПутьКСлову, " " + мТекстДляПоискаОпределения, мПредшествующийТекст, РазрешитьАнализИмениТипа, мЭтоКонструктор);
	Если ТаблицаТиповКонтекста.Количество() = 0 Тогда
		Возврат Неопределено;
	КонецЕсли;
	СтруктураТипаКонтекста = ТаблицаТиповКонтекста[0];
	Результат = НайтиПоказатьСправкуПоСтруктуреТипа(ПутьКСлову, СтруктураТипаКонтекста, ВключатьПутьКОписаниюТипаЗначения, выхФормаВыбора, ВладелецФормы, ТаблицаТиповКонтекста);
	Возврат Результат;

КонецФункции

Функция НайтиПоказатьСправкуПоСтруктуреТипа(Знач ПутьКСлову, Знач СтруктураТипа, ВключатьПутьКОписаниюТипаЗначения = Ложь, выхФормаВыбора = Неопределено, ВладелецФормы = Неопределено,
	Знач ТаблицаТиповКонтекста = Неопределено, Знач НомерПараметра = Неопределено) Экспорт 
	
	Если НомерПараметра = Неопределено Тогда
		НомерПараметра = мНомерПараметра;
	КонецЕсли;
	Если Истина
		И ТипЗнч(СтруктураТипа.СтрокаОписания) <> Тип("СтрокаТаблицыЗначений")
		И ТипЗнч(СтруктураТипа.Метаданные) = Тип("COMОбъект") 
	Тогда
		Если НомерПараметра > 0 Тогда
			Возврат Неопределено;
		КонецЕсли; 
		МетаданныеСлова = СтруктураТипа.Метаданные;
		ИмяТипа = мПлатформа.ПолноеИмяТипаCOMОбъекта(МетаданныеСлова);
		Попытка
			Пустышка = МетаданныеСлова.Path_;
		Исключение
			Пустышка = Неопределено;
		КонецПопытки;
		Слово = ирОбщий.ПоследнийФрагментЛкс(ПутьКСлову, ".", Ложь);
		Если Прав(ПутьКСлову, 1) = "(" Тогда
			Слово = СтрЗаменить(Слово, "(", "");
		КонецЕсли; 
		Если Пустышка <> Неопределено Тогда
			// WMI
			ИмяКлассаWMI = МетаданныеСлова.Path_.Class;
			Если ЗначениеЗаполнено(Слово) Тогда
				ОписаниеСлова = ирОбщий.ДокументацияСвойстваWMIЛкс(ИмяКлассаWMI, Слово);
				Если ЗначениеЗаполнено(ОписаниеСлова) Тогда
					ТекстовыйДокумент = Новый ТекстовыйДокумент;
					ТекстовыйДокумент.УстановитьТекст(ОписаниеСлова);
					ТекстовыйДокумент.Показать(ИмяКласса + "." + Слово);
					Возврат Истина;
				КонецЕсли; 
			КонецЕсли;
		Иначе
			ЗапуститьПриложение("http://google.com/search?q=" + ирОбщий.ПервыйФрагментЛкс(ИмяТипа, " ") + "+" + Слово);
			Возврат Истина;
		КонецЕсли; 
	Иначе
		Если Истина
			И ВладелецФормы <> Неопределено 
			И ТипЗнч(СтруктураТипа.СтрокаОписания) = Тип("СтрокаТаблицыЗначений")
		Тогда
			ТаблицаВладелец = СтруктураТипа.СтрокаОписания.Владелец();
			#Если Сервер И Не Сервер Тогда
				ТаблицаВладелец = Новый ТаблицаЗначений;
			#КонецЕсли
			Если ТаблицаВладелец.Колонки.Найти("ТелоБезВозвратов") <> Неопределено Тогда
				ФормаВызовМетода = ФормаВызовМетода();
				ФормаВызовМетода.ПараметрПостояннаяСтруктураТипа = СтруктураТипа;
				БылаОткрыта = ФормаВызовМетода.Открыта();
				ОткрытьПодсказкуПоВызовуМетодаПассивно(ФормаВызовМетода, Ложь);
				ФормаВызовМетода.Автообновление = Ложь;
				Если Не БылаОткрыта Тогда
					ирКлиент.Форма_АктивироватьОткрытьЛкс(ФормаВладелец);
				КонецЕсли; 
				Возврат ФормаВызовМетода;
			КонецЕсли; 
		КонецЕсли; 
		Если СтруктураТипа.ТипЯзыка = "ИмяТипа" Тогда 
			ВключатьПутьКОписаниюТипаЗначения = Истина;
		КонецЕсли; 
		Слово = ирОбщий.ПоследнийФрагментЛкс(ПутьКСлову);
		// Возможные роли слова без учета вычисленного контекста
		ТаблицаСтруктурВозможныхТиповКонтекста = ирКлиент.НайтиВозможныеСтрокиОписанияСловаВСинтаксПомощникеЛкс(Слово, ЯзыкПрограммы);
		Если ТаблицаТиповКонтекста = Неопределено Тогда
			ТаблицаТиповКонтекста = Новый Массив;
			ТаблицаТиповКонтекста.Добавить(СтруктураТипа);
		КонецЕсли; 
		СтруктураЦикла = Новый Соответствие;
		СтруктураЦикла.Вставить("1.Предсказанные:", ТаблицаТиповКонтекста);
		СтруктураЦикла.Вставить("2.Возможные:", ТаблицаСтруктурВозможныхТиповКонтекста);
		#Если Сервер И Не Сервер Тогда
			мПлатформа = Обработки.ирПлатформа.Создать();
		#КонецЕсли
		Если ВладелецФормы = Неопределено Тогда
			ВладелецФормы = ФормаВладелец;
		КонецЕсли; 
		мПлатформа.ВыбратьСтрокуОписанияИзМассиваСтруктурТипов(СтруктураЦикла, ВключатьПутьКОписаниюТипаЗначения, ВладелецФормы, Слово, НомерПараметра,, выхФормаВыбора, мФактическиеПараметры.Количество());
		Возврат выхФормаВыбора;
	КонецЕсли;
	Возврат Неопределено;

КонецФункции

// Открывает контекстную справку по текущему слову или его типу.
//
// Параметры:
//  *ПутьКСлову - Строка, *"" - используется для получения дочерних слов относительно текущего контекста.
//
Функция ОткрытьКонтекстнуюСправку(ПутьКСлову = "", ВладелецФормы = Неопределено) Экспорт
	
	//Если ирОбщий.ПроверитьПлатформаНеWindowsЛкс(,, Истина) Тогда
	//	Возврат;
	//КонецЕсли; 
	//КончитьОбработкуКоманды();
	РазобратьТекущийКонтекст(,,,,, Истина);
	РазрешитьАнализИмениТипа = Не ЗначениеЗаполнено(ПутьКСлову);
	Если РазрешитьАнализИмениТипа Тогда 
		ПутьКСлову = мТекущееСлово;
	КонецЕсли;
	Если Найти(ПутьКСлову, ".") > 0 Тогда
		ЧистоеСлово = ирОбщий.ПоследнийФрагментЛкс(ПутьКСлову);
	ИначеЕсли мРодительскийКонтекст <> ""  Тогда
		ЧистоеСлово = ПутьКСлову;
		ПутьКСлову = мРодительскийКонтекст + "." + ПутьКСлову;
	Иначе 
		ЧистоеСлово = ПутьКСлову;
	КонецЕсли;
	Если Ложь
		Или мЭтоТекстовыйЛитерал
		Или НайтиПоказатьСправкуПоСлову(ПутьКСлову,,, РазрешитьАнализИмениТипа, ВладелецФормы) = Неопределено 
	Тогда 
		Если ЗначениеЗаполнено(ЧистоеСлово) Тогда
			НайтиПоказатьСправкуПоСтруктуреТипа(ЧистоеСлово, мПлатформа.НоваяСтруктураТипа(),,, ВладелецФормы);
		КонецЕсли;
	КонецЕсли;
	
КонецФункции 

// вызывается из адаптера
Функция ПолноеИмяТипаИзСокращенного(Знач ИмяКраткое) Экспорт
	СтрокаТипа = мПлатформа.ТаблицаСокращенияИменТипов.Найти(ИмяКраткое, "ИмяКраткое");
	Если СтрокаТипа <> Неопределено Тогда
		Результат = СтрокаТипа.ИмяПолное;
	Иначе
		Результат = ИмяКраткое;
	КонецЕсли;
	Возврат Результат;
КонецФункции

Процедура _ОткрытьСправкуПоЯзыкуПрограммы() Экспорт 

	//Если ирОбщий.ПроверитьПлатформаНеWindowsЛкс() Тогда
	//	Возврат;
	//КонецЕсли; 
	Если ЯзыкПрограммы = 0 Тогда
		Книга = "shcntx_ru";
	ИначеЕсли ЯзыкПрограммы = 1 Тогда
		Книга = "shquery_ru";
	ИначеЕсли ЯзыкПрограммы = 2 Тогда
		Книга = "dcsui_ru";
	КонецЕсли;
	ФормаСправка = ирКлиент.ПолучитьФормуЛкс("Обработка.ирСинтаксПомощник.Форма", , ФормаВладелец);
	ФормаСправка.ТекущаяСтраницаУстановлена = Истина;
	ФормаСправка.ОткрытьАдрес("//" + Книга);

КонецПроцедуры

// Открывает контекстную справку по текущему параметру метода.
//
// Параметры:
//  *ПутьКСлову - Строка, *"" - используется для получения дочерних слов относительно текущего контекста.
//
Процедура ОткрытьСправкуПоПараметру(ПутьКСлову = "", ОткрыватьСинтаксПомощник = Истина) Экспорт
	
	//Если ирОбщий.ПроверитьПлатформаНеWindowsЛкс(,, Истина) Тогда
	//	Возврат;
	//КонецЕсли; 
	РазобратьТекущийКонтекст(,, Истина,,, Истина);
	Если ПутьКСлову = "" Тогда
		ПутьКСлову = мВызовМетода;
	КонецЕсли;
	// Если раскомментировать, то при вызове через мОткрытьСправкуПоПараметру не будет открываться окно 
	//Если Не ЗначениеЗаполнено(ПутьКСлову) Тогда
	//	Возврат;
	//КонецЕсли; 
	Если ОткрыватьСинтаксПомощник И ирКэш.ЛиПлатформаWindowsЛкс() Тогда
		ФормаСинтаксПомощникаДо = Неопределено;
		ФормаСинтаксПомощникаПосле = Неопределено;
		Если Не ЛиДоступноОткрытиеСвободнойФормы() Тогда 
			ФормаСинтаксПомощникаДо = ирКлиент.ПолучитьФормуЛкс("Обработка.ирСинтаксПомощник.Форма");
		КонецЕсли; 
		НайтиПоказатьСправкуПоСлову(ПутьКСлову,, ФормаСинтаксПомощникаПосле);
	КонецЕсли;
	ФормаПодсказкаПоПараметрам = ФормаВызовМетода(Истина);
	Если Истина
		И ФормаВладелец <> Неопределено
		И Не ФормаПодсказкаПоПараметрам.Открыта() 
		И ЗначениеЗаполнено(мИмяМетодаВызова) 
	Тогда
		ФормаПодсказкаПоПараметрам.ЗапомнитьПозициюКаретки();
	КонецЕсли; 
	Если Ложь
		Или ОткрыватьСинтаксПомощник
		Или Не ФормаПодсказкаПоПараметрам.Открыта() 
	Тогда 
		ОткрытьПодсказкуПоВызовуМетодаПассивно(ФормаПодсказкаПоПараметрам);
	КонецЕсли; 
	
КонецПроцедуры

Процедура ОткрытьПодсказкуПоВызовуМетодаПассивно(Знач ФормаПодсказкаПоПараметрам, Знач Автообновление = Истина)
	
	БылаОткрыта = ФормаПодсказкаПоПараметрам.Открыта();
	ФормаПодсказкаПоПараметрам.Автообновление = Автообновление;
	ОткрытьФормуПассивно(ФормаПодсказкаПоПараметрам);
	Если Истина
		И Не БылаОткрыта
		И ФормаПодсказкаПоПараметрам.Автообновление <> Автообновление 
	Тогда
		// УП
		ФормаПодсказкаПоПараметрам.Автообновление = Автообновление;
	КонецЕсли;
	ФормаПодсказкаПоПараметрам.Обновить(); // Нужно для ускорения срабатывания установки позиции окна и для 8.2, т.к. там форма форкус получает после завершения ПриОткрытии и только после этого сработает установка позиции окна
	//ирКлиент.УстановитьФокусВводаФормеЛкс(); Не помогает восстановить мигание каретки
	
КонецПроцедуры

Функция УдалитьКомментарии(Текст) Экспорт 
	
	мРегВыражение.Global = Истина;
	мРегВыражение.Multiline = Ложь;
	
	Если Ложь
		Или ЯзыкПрограммы = 1
		Или ЯзыкПрограммы = 2
	Тогда
		// Не проверено
		мРегВыражение.Pattern = "(?:(?://[^\n]*" + ")|(" + шЛитералВЗапросе + ")|([\s\S])";
		ШаблонЗамены = "$1$2$3$4";
	ИначеЕсли ЯзыкПрограммы = 0 Тогда
		шОднострочнаяСтрокаПрограммыСКавычки = """(?:(?:"""")|[^""\n])*""?"; 
		шОднострочнаяСтрокаПрограммыСЧерты = "\n\s*\|(?:(?:"""")|[^""\n])*""?";
		мРегВыражение.Pattern = "//[^\n]*|" + "(" + "#[^\n]*" + ")|(" + шОднострочнаяСтрокаПрограммыСКавычки + ")|(" + шОднострочнаяСтрокаПрограммыСЧерты + ")|([\s\S])";
		ШаблонЗамены = "$1$2$3$4";
	КонецЕсли;
	Результат = мРегВыражение.Заменить(Текст, ШаблонЗамены);
	Возврат Результат;
	
КонецФункции

// Меняет мРегВыражение!
Функция ЭтоРусскийВариантТекстаЗапроса(Текст) Экспорт 
	
	ТекстБезКомментариев = СокрЛП(ЗалитьКомментарииИСтроковыеЛитералы(Текст));
	мРегВыражение.Pattern = "[А-ЯЁ]";
	ЭтоРусскийЯзык = мРегВыражение.Проверить(Лев(ТекстБезКомментариев, 1));
	Возврат ЭтоРусскийЯзык;

КонецФункции

// Добавляет/заменяет/удаляет оператор ПОМЕСТИТЬ в запросе.
// Это неточный метод, основанный на мРегВыражение.
//
// Параметры:
//  ТекстЗапроса - Строка;
//  *ИмяВременнойТаблицы - Строка - если пустое, то оператор удаляется.
//
// Возвращаемое значение:
//  Строка - исправленный текст запроса.
//
Функция ИзменитьОператорПоместитьЗапроса(ТекстЗапроса, ИмяВременнойТаблицы = "") Экспорт 

	ЭтоРусскийЯзык = ЭтоРусскийВариантТекстаЗапроса(ТекстЗапроса); // Меняет мРегВыражение!
	мРегВыражение.Global = Истина;
	ШаблонПОМЕСТИТЬИЗ = "(" + шЛитералВЗапросе + ")|(?:(" + шРазделитель + ")+(" + "(?:ПОМЕСТИТЬ|INTO(?:" + шРазделитель + "+TABLE)?)" + шРазделитель + "+" + шИмя + шРазделитель + "+)"
		+ "|((?:ИЗ|FROM|ГДЕ|WHERE|СГРУППИРОВАТЬ|GROUP|УПОРЯДОЧИТЬ|ORDER|ИМЕЮЩИЕ|HAVING|ОБЪЕДИНИТЬ|UNION)" + шРазделитель + "+))|(.|\r|\n)";
	мРегВыражение.Pattern = ШаблонПОМЕСТИТЬИЗ;
	Если ЗначениеЗаполнено(ИмяВременнойТаблицы) Тогда
		Если ЭтоРусскийЯзык Тогда
			ТерминПоместить = "ПОМЕСТИТЬ";
		Иначе
			ТерминПоместить = "INTO";
		КонецЕсли; 
		Результат = мРегВыражение.НайтиВхождения(ТекстЗапроса);
		Текст = "";
		ПредложениеДобавлено = Ложь;
		Для Каждого Match Из Результат Цикл
			Если Ложь
				Или ПредложениеДобавлено
				Или Match.SubMatches(0) <> Неопределено
				Или Match.SubMatches(4) <> Неопределено
			Тогда
				Текст = Текст + Match.Value;
			Иначе
				Текст = Текст + "
				|" + ТерминПоместить + "
				|	" + ИмяВременнойТаблицы;
				Если Match.SubMatches(3) <> 0 Тогда // Видимо здесь ошибка
					Текст = Текст + Символы.ПС + Match.SubMatches(3);
				КонецЕсли;
				ПредложениеДобавлено = Истина;
			КонецЕсли;
		КонецЦикла;
		Если Не ПредложениеДобавлено Тогда
			Текст = Текст + "
			|" + ТерминПоместить + "
			|	" + ИмяВременнойТаблицы;
		КонецЕсли;
	Иначе
		Текст = мРегВыражение.Заменить(ТекстЗапроса, "$1$2$4$5");
	КонецЕсли; 
	Возврат Текст;

КонецФункции

Функция ШаблонЗапросаДопускаетВстройкуВРодительскийЗапрос(Текст) Экспорт 
	
	мРегВыражение.Global = Ложь;
	мРегВыражение.Pattern = шРазделитель + "*(?:ВЫБРАТЬ|SELECT)(?:" + шРазделитель + "+)\*(?:" + шРазделитель + "+)(?:ИЗ|FROM)(?:" + шРазделитель + "+(?:КАК|AS)?(?:" + шРазделитель + "+" + шИмя + "))" + шРазделитель + "*";
	Результат = мРегВыражение.Проверить(Текст);
	Возврат Результат;

КонецФункции

Функция ПолучитьКомментарийИзТокеновЯзыкаЗапросов(Токен1, Токен2 = Неопределено, выхИмяЗапросаИзКомментария = "", выхИмяЧастиОбъединенияИзКомментария = "") Экспорт 
	
	Массив = Новый Массив();
	Если Токен1 <> Неопределено И Токен1.Name = "Comment" Тогда
		Массив.Добавить(Токен1);
	КонецЕсли; 
	Если Токен2 <> Неопределено И Токен2.Name = "Comment" Тогда
		Массив.Добавить(Токен2);
	КонецЕсли; 
	ТекстКомментария = "";
	Для Каждого Токен Из Массив Цикл
		ТекстТокена = ПолучитьТекстИзТокена(Токен);
		РазобратьКомментарий(ТекстКомментария, выхИмяЗапросаИзКомментария, выхИмяЧастиОбъединенияИзКомментария);
	КонецЦикла;
	Возврат ТекстКомментария;
	
КонецФункции

Процедура РазобратьКомментарий(ТекстКомментария, выхИмяЗапросаИзКомментария = Неопределено, выхИмяЧастиОбъединенияИзКомментария = Неопределено, выхПорядокОтладки = Неопределено) Экспорт 
	
	ЧистыйКомментарий = "";
	ТекстовыйДокумент = Новый ТекстовыйДокумент;
	ТекстовыйДокумент.УстановитьТекст(ТекстКомментария);
	Для Счетчик = 1 По ТекстовыйДокумент.КоличествоСтрок() Цикл
		СтрокаТекста = ТекстовыйДокумент.ПолучитьСтроку(Счетчик);
		Если ПустаяСтрока(СтрокаТекста) Тогда
			Продолжить;
		КонецЕсли; 
		//Если Счетчик = 1 Тогда 
			Если Найти(СтрокаТекста, мПараметрыДиалектаSQL.СтрочныйКомментарий) = 1 Тогда 
				СтрокаТекста = Сред(СтрокаТекста, СтрДлина(мПараметрыДиалектаSQL.СтрочныйКомментарий) + 1);
			КонецЕсли; 
			Если Найти(СтрокаТекста, мМаркерСлужебногоКомментария) = 1 Тогда 
				Продолжить;
			КонецЕсли; 
			Если Найти(СтрокаТекста, мПлатформа.мМаркерИмениЗапросаПакета) = 1 Тогда 
				ИмяЗапросаИзКомментария = ирОбщий.ТекстМеждуМаркерамиЛкс(СтрокаТекста, мПлатформа.мМаркерИмениЗапросаПакета, " ");
				Если ирОбщий.ЛиИмяПеременнойЛкс(ИмяЗапросаИзКомментария) Тогда
					выхИмяЗапросаИзКомментария = ИмяЗапросаИзКомментария;
				КонецЕсли; 
				// Пропускаем служебные комментарии
				Продолжить;
			КонецЕсли; 
			Если Найти(СтрокаТекста, мПлатформа.мМаркерИмениЧастиОбъединения) = 1 Тогда 
				ИмяЧастиОбъединенияИзКомментария = ирОбщий.ТекстМеждуМаркерамиЛкс(СтрокаТекста, мПлатформа.мМаркерИмениЧастиОбъединения, " ");
				Если ирОбщий.ЛиИмяПеременнойЛкс(ИмяЧастиОбъединенияИзКомментария) Тогда
					выхИмяЧастиОбъединенияИзКомментария = ИмяЧастиОбъединенияИзКомментария;
				КонецЕсли; 
				// Пропускаем служебные комментарии
				Продолжить;
			КонецЕсли; 
			СтрокаТекста = СокрЛ(СтрокаТекста);
			Если ирОбщий.СтрНачинаетсяСЛкс(СтрокаТекста, мМаркерПорядкаОтладки) = 1 Тогда 
				выхПорядокОтладки = Сред(СтрокаТекста, СтрДлина(мМаркерПорядкаОтладки) + 1);
				// Пропускаем служебные комментарии
				Продолжить;
			КонецЕсли; 
		//КонецЕсли; 
		Если ЧистыйКомментарий <> "" Тогда
			ЧистыйКомментарий = ЧистыйКомментарий + Символы.ПС;
		КонецЕсли; 
		ЧистыйКомментарий = ЧистыйКомментарий + СтрокаТекста;
	КонецЦикла;
	ТекстКомментария = ЧистыйКомментарий;

КонецПроцедуры

// Разбирает текущий контекст по составляющим.
//
// Параметры:
//  ВзятьЛевоеОтРавенства			 - Булево	 - 
//  выхЕстьТочкаСправа				 - Булево	 - 
//  КакВызовМетода					 - Булево, Неопределено	 - если равен Неопределено, то трактуется как Истина в случае если внутри строкового литерала
//  НомерСтроки						 - Число				 - если не передано, то считывается из ПолеТекста
//  НомерКолонки					 - Число				 - если не передано, то считывается из ПолеТекста
//  ПереходитьВоВложенныйКонтекст	 - Булево				 - переключаться в контекст вложенного текста строкового литерала (например языка запросов)
//  ПозицияВТексте					 - Число				 - передается для ускорения, т.е. дополнительно к переданным или установленным НомерСтроки/мКонечнаяСтроки И НомерКолонки/мКонечнаяКолонка
//  ТребоватьРазборКонтекстаЗапроса	 - Булево - включает режим обязательного разбора контекста запроса вместо обычного режима, в котором решение о разборе принимается очень быстро
//
Процедура РазобратьТекущийКонтекст(Знач ВзятьЛевоеОтРавенства = Ложь, выхЕстьТочкаСправа = Ложь, Знач КакВызовМетода = Неопределено, Знач НомерСтроки = 0, Знач НомерКолонки = 0,
	Знач ПереходитьВоВложенныйКонтекст = Ложь, Знач ПозицияВТексте = 0, Знач ТребоватьРазборКонтекстаЗапроса = Ложь) Экспорт 

	#Если Сервер И Не Сервер Тогда
		мПлатформа = Обработки.ирПлатформа.Создать();
	#КонецЕсли
	мОригинальныйТекст = ПолеТекста.ПолучитьТекст();
	ОригинальныйТекстИзменен = мСтарыйОригинальныйТекст <> мОригинальныйТекст;
	Если Истина 
		И Не мРазбиратьКонтекст 
		И Не ОригинальныйТекстИзменен
		И Не ТребоватьРазборКонтекстаЗапроса
		И (Ложь
			Или ПозицияВТексте = 0 
			Или мПозицияВТексте = ПозицияВТексте)
		И (Ложь
			Или НомерКолонки = 0
			Или НомерКолонки = мНачальнаяКолонка)
		И (Ложь
			Или НомерСтроки = 0
			Или НомерСтроки = мНачальнаяСтрока)
	Тогда 
		Возврат;
	КонецЕсли;
	мПлатформа.ИнициацияОписанияМетодовИСвойств();
	Если Не ЗначениеЗаполнено(НомерСтроки) Тогда
		//Если ЗначениеЗаполнено(ПозицияВТексте) Тогда
		//	ПолеТекста.УстановитьГраницыВыделения(ПозицияВТексте, ПозицияВТексте); // Нельзя так делать, т.к. потеряем выделение в тексте литерала при вызове из РазобратьКонтекстЗапросаВТекстовомЛитерале
		//КонецЕсли;
		ПолучитьГраницыВыделения();
	Иначе
		мНачальнаяСтрока = НомерСтроки;
		мКонечнаяСтрока = НомерСтроки;
	    мНачальнаяКолонка = НомерКолонки;
		мКонечнаяКолонка = НомерКолонки;
	КонецЕсли; 
	Если ОригинальныйТекстИзменен Тогда
		СлужебноеПолеТекстаДолгое.УстановитьТекст(мОригинальныйТекст);
	КонецЕсли;   
	Если ЗначениеЗаполнено(ПозицияВТексте) Тогда
		мПозицияВТексте = ПозицияВТексте;
	Иначе 
		СлужебноеПолеТекстаДолгое.УстановитьГраницыВыделения(1, 1, мКонечнаяСтрока, мКонечнаяКолонка);
		мПозицияВТексте = СтрДлина(СлужебноеПолеТекстаДолгое.ВыделенныйТекст) + 1; // Долго 5мс TODO написать свой расчет позиции
	КонецЕсли;
	мПозицияТекстаДляПоискаОпределения = 0; // В режиме встроенного языка - начиная с 1. В режиме языка запросов - начинается с 0.
	мПредшествующийТекст = "";
	мТекстДляПоискаОпределения = "";  
	мТекстБлока = "";
	мТекстБезТекстовыхЛитералов = "";
	мПакетЗапросов = НовыйПакетЗапросов();
	Если Истина
		И ЯзыкПрограммы = 1
		И ТипЗнч(КонтекстВыполнения) = Тип("Запрос")
	Тогда
		Для Каждого КлючИЗначение Из КонтекстВыполнения.Параметры Цикл
			мПакетЗапросов.Параметры.Вставить(КлючИЗначение.Ключ, мПлатформа.ТаблицаТиповИзЗначения(КлючИЗначение.Значение));
		КонецЦикла;
	КонецЕсли;
	мИндексЗапросаПакета = Неопределено;
	мНомерПервойСтрокиТелаМетода = 1;
	мНомерПоследнейСтрокиТелаМетода = Неопределено;
	ТекстПакетаЗапросов = мОригинальныйТекст;
	мЯзыкПрограммы = ЯзыкПрограммы;
	мНачальнаяПозиция0ВложенногоТекста = 0;
	НомерПервойСтрокиБлока = 1;
	ПрочитатьНачалоИКонецТекущейСтроки();
	ЧислоСтрокВБлоке = 0; 
	Если ЯзыкПрограммы = 0 И ОригинальныйТекстИзменен Тогда 
		ОбновитьМодульМетаданных(мОригинальныйТекст); 
	КонецЕсли;
	мМетодМодуля = Неопределено;
	Если ЯзыкПрограммы = 0 Тогда
		мМетодМодуля = мМодульМетаданных.ТекущийМетод; // Для ускорения поиска нового текущего метода берем сначала старый     
		Если мМетодМодуля <> Неопределено Тогда 
			Если мМодульМетаданных.Методы.Индекс(мМетодМодуля) = -1 Тогда
				мМетодМодуля = Неопределено;
			КонецЕсли;
		КонецЕсли;
		ЗагрузитьМетодМодуляПоПозиции(мПозицияВТексте, Истина); // устанавливает мМетодМодуля
	КонецЕсли;
	Если Истина
		И ПереходитьВоВложенныйКонтекст 
		И (Ложь
			Или ТребоватьРазборКонтекстаЗапроса
			Или ирОбщий.ЛиВнутриНепервойСтрокиТекстовогоЛитералаЛкс(мТекущаяСтрокаНачало) // Первую строку литерала игнорируем для ускорения
			Или Найти(мТекущаяСтрокаНачало, ".Текст = ""ВЫБРАТЬ") > 0 И мЭтоТекстовыйЛитерал)
	Тогда
		ВыражениеЛитерала = "";
		ТекстЛитерала = ВыделитьТекстовыйЛитерал(СлужебноеПолеТекстаДолгое, мНачальнаяПозиция0ВложенногоТекста,, Ложь, ВыражениеЛитерала);
		Если ТребоватьРазборКонтекстаЗапроса Или ирОбщий.ЛиТекстЯзыкаЗапросовЛкс(ТекстЛитерала) Тогда
			СлужебноеПолеТекстаДолгое.ПолучитьГраницыВыделения(НомерПервойСтрокиБлока, 0, 0, 0);
			РазобратьКонтекстЗапросаВТекстовомЛитерале(ВыражениеЛитерала, ТекстЛитерала);
		КонецЕсли;
	КонецЕсли;
	Если мЯзыкПрограммы = 0 Тогда
		ЧислоСтрокВБлоке = ирОбщий.СтрЧислоСтрокЛкс(мТекстБлока);
		мНомерПервойСтрокиТелаМетода = СтрЧислоСтрок(Лев(мОригинальныйТекст, мПозицияТекстаДляПоискаОпределения) + "й"); // Мультиметка882366123
		мНомерПоследнейСтрокиТелаМетода = мНомерПервойСтрокиТелаМетода + ЧислоСтрокВБлоке - 1;
		НомерТекущейСтрокиВБлоке = мКонечнаяСтрока - мНомерПервойСтрокиТелаМетода + 1;
	Иначе
		ЧислоСтрокВБлоке = ЗагрузитьЗапросПакетаМодуляПоПозиции(ТекстПакетаЗапросов, НомерПервойСтрокиБлока);
		НомерТекущейСтрокиВБлоке = мКонечнаяСтрока - (НомерПервойСтрокиБлока - ЧислоСтрокВБлоке) +  1;
	КонецЕсли; 
	РазобратьКонтекстСтроки(ВзятьЛевоеОтРавенства, выхЕстьТочкаСправа, КакВызовМетода);
	мТекстДляПоискаОпределения = мТекстБлока;
	Если НомерТекущейСтрокиВБлоке > 1 Тогда
		мПолеТекстаВременное.УстановитьТекст(мТекстБлока);                              
		мПолеТекстаВременное.УстановитьГраницыВыделения(1, 1, НомерТекущейСтрокиВБлоке - 1, 333);
		мПредшествующийТекст = мПолеТекстаВременное.ВыделенныйТекст;
	Иначе 
		мПредшествующийТекст = "";
	КонецЕсли;
	Если мЯзыкПрограммы = 0 Тогда
		мТекстДляПоискаОпределения = мПредшествующийТекст;
	КонецЕсли;

	мПозицияВБлоке = мПозицияВТексте - мПозицияТекстаДляПоискаОпределения - 1;
	//мПредшествующийТекст = мПредшествующийТекст + Лев(мТекущаяСтрокаНачало, СтрДлина(мТекущаяСтрокаНачало) - СтрДлина(мНачалоКонтекста));
	мПредшествующийТекст = Лев(мТекстБлока, мПозицияВБлоке - СтрДлина(мНачалоКонтекста)); // мПозицияВТексте учитывает ВзятьЛевоеОтРавенства, поэтому опираемся на нее
	мПредшествующийТекст = Прав(мПредшествующийТекст, 500); // Обрезка для ускорения
	мСтарыйОригинальныйТекст = мОригинальныйТекст;
	Если мМодульМетаданных <> Неопределено Тогда
		мМодульМетаданных.ТекущийМетод = мМетодМодуля; 
	КонецЕсли;
	ПродолжитьОбработкуКоманды();

КонецПроцедуры

// .
//
// Параметры:
//  ТекстПакетаЗапросов		 - Строка - в случае вложенного контекста передается выражение литерала
//  НомерПервойСтрокиБлока	 - Число, Неопределено	 - если передано, то ищется позиция по мНачальнаяСтрока
//  Позиция0ВЛитерале			 - Число, Неопределено	 - если передано, то ищется по этой позиции
// 
// Возвращаемое значение:
//   Число, Неопределено - если передано НомерПервойСтрокиБлока, то число строк в блоке
//
Функция ЗагрузитьЗапросПакетаМодуляПоПозиции(Знач ТекстПакетаЗапросов = "", НомерПервойСтрокиБлока = Неопределено, Позиция0ВЛитерале = Неопределено) Экспорт
	ИскатьЗапросПакета = Истина;
	Если мПакетЗапросов.ТекстыЗапросов = Неопределено Тогда
		мПакетЗапросов.Позиции0Запросов = Новый Массив;
		мПакетЗапросов.ТекстыЗапросов = мПлатформа.РазбитьГрубоТекстПакетногоЗапросаНаЗапросы(ТекстПакетаЗапросов, мПозицияВТексте - мНачальнаяПозиция0ВложенногоТекста, мПакетЗапросов.Позиции0Запросов);
	КонецЕсли;
	Если Позиция0ВЛитерале <> Неопределено И мИндексЗапросаПакета <> Неопределено Тогда
		мТекстБлока = мПакетЗапросов.ТекстыЗапросов[мИндексЗапросаПакета];
		мПозицияТекстаДляПоискаОпределения = мПакетЗапросов.Позиции0Запросов[мИндексЗапросаПакета];
		Если Истина
			И мПозицияТекстаДляПоискаОпределения < Позиция0ВЛитерале 
			И мПозицияТекстаДляПоискаОпределения + СтрДлина(мТекстБлока) >= Позиция0ВЛитерале 
		Тогда
			ИскатьЗапросПакета = Ложь;
		КонецЕсли; 
	КонецЕсли;
	Если ИскатьЗапросПакета Тогда
		Для мИндексЗапросаПакета = 0 По мПакетЗапросов.ТекстыЗапросов.ВГраница() Цикл
			мТекстБлока = мПакетЗапросов.ТекстыЗапросов[мИндексЗапросаПакета];
			мПозицияТекстаДляПоискаОпределения = мПакетЗапросов.Позиции0Запросов[мИндексЗапросаПакета];
			Если НомерПервойСтрокиБлока <> Неопределено Тогда
				ЧислоСтрокВБлоке = ирОбщий.СтрЧислоСтрокЛкс(мТекстБлока) - 1;
				НомерПервойСтрокиБлока = НомерПервойСтрокиБлока + ЧислоСтрокВБлоке;
				Если НомерПервойСтрокиБлока >= мНачальнаяСтрока Тогда
					Прервать;
				КонецЕсли;  
			Иначе 
				Если мПозицияТекстаДляПоискаОпределения + СтрДлина(мТекстБлока) >= Позиция0ВЛитерале Тогда
					Прервать;
				КонецЕсли; 
			КонецЕсли;
		КонецЦикла;
	КонецЕсли;
	мПозицияТекстаДляПоискаОпределения = мНачальнаяПозиция0ВложенногоТекста + мПозицияТекстаДляПоискаОпределения; // Теперь это позиция в модуле
	Возврат ЧислоСтрокВБлоке;
КонецФункции

// .
//
// Параметры:
//  ВыражениеЛитерала			 - Строка - например, "Выбрать1"
//  ТекстЛитерала				 - Строка - например, ВЫбрать 1
//  БратьЧастьДоТекущейПозиции	 - Булево - 
//
Процедура РазобратьКонтекстЗапросаВТекстовомЛитерале(Знач ВыражениеЛитерала, Знач ТекстЛитерала, Знач БратьЧастьДоТекущейПозиции = Истина) Экспорт
	мЭтоТекстовыйЛитерал = Ложь;
	мЯзыкПрограммы = 1;
	мМенеджерВременныхТаблиц = Неопределено;
	НачальнаяПозицияПредТекста = мНачальнаяПозиция0ВложенногоТекста - 100;
	ТекстДоЛитерала = Сред(мОригинальныйТекст, НачальнаяПозицияПредТекста, Мин(0, НачальнаяПозицияПредТекста) + 100); // не более 100 символов перед литералом
	КопияАнализатора = КопияКомпоненты();
	КопияАнализатора.мСтарыйОригинальныйТекст = мОригинальныйТекст; // Чтобы в динамическом модуле не возникала ошибка обращения к мМетодМодуля при вводе пробела после слова
	КопияАнализатора.РазобратьТекущийКонтекст(,,,,, Ложь, мНачальнаяПозиция0ВложенногоТекста); 
	мРегВыражение.Global = Ложь;
	мРегВыражение.Pattern = шПредИмяПрямое + "(" + шИмяСТочками + ")\.Текст\s*=\s*$";
	Вхождения = мРегВыражение.НайтиВхождения(ТекстДоЛитерала);
	Если Вхождения.Количество() > 0 Тогда
		ПеременнаяЗапроса = Вхождения[0].Submatches(0);
		ПозицияКонцаПрисвоения = КопияАнализатора.мПозицияВБлоке + СтрДлина(ВыражениеЛитерала) + 2;
		ОстатокТекстаБлока = Сред(мТекстБлока, ПозицияКонцаПрисвоения);
		ПозицияВыполнить = ирОбщий.НайтиРегВыражениеЛкс(ОстатокТекстаБлока, шПредИмяПрямое + ПеременнаяЗапроса + "\.Выполнить",, Ложь);
		Если ПозицияВыполнить.Количество() > 0 Тогда
			ПозицияВыполнить = ПозицияКонцаПрисвоения + ПозицияВыполнить[0].ПозицияВхождения;
		Иначе             
			//ПозицияВыполнить = КопияАнализатора.мПозицияВБлоке + 1;
			ПозицияВыполнить = 0;
		КонецЕсли;
		// Меняет границы выделения в нашем СлужебноеПолеТекстаДолгое! TODO избавиться от повторного извлечения текста запроса
		ТаблицаТиповЗапроса = КопияАнализатора.ВычислитьТипЗначенияВыражения(ПеременнаяЗапроса,,,,,,,,,,, ПозицияВыполнить); 
		Если Истина
			И ТаблицаТиповЗапроса.Количество() > 0
			И ТипЗнч(ТаблицаТиповЗапроса[0].ДержательМетаданных) = Тип("Структура") 
		Тогда
			мМенеджерВременныхТаблиц = ТаблицаТиповЗапроса[0].ДержательМетаданных;
			мПакетЗапросов.Параметры = ТаблицаТиповЗапроса[0].Метаданные.Параметры;
		КонецЕсли;
	КонецЕсли;
	Если мМенеджерВременныхТаблиц = Неопределено Тогда
		мМенеджерВременныхТаблиц = НовыйМенеджерВременныхТаблиц();
	КонецЕсли;
	Если мМенеджерВременныхТаблиц.ПакетыЗапросов.Количество() = 0 Тогда
		мМенеджерВременныхТаблиц.ПакетыЗапросов.Добавить(мПакетЗапросов);
	КонецЕсли;
	мИндексЗапросаПакета = 0;
	мПакетЗапросов.КоординатыТекста = КопияАнализатора.НовыеКоординатыВыражения(ВыражениеЛитерала, мНачальнаяПозиция0ВложенногоТекста - КопияАнализатора.мПозицияТекстаДляПоискаОпределения);
	мПакетЗапросов.Позиции0Запросов = Новый Массив;
	Если БратьЧастьДоТекущейПозиции Тогда
		ПозицияКурсора = мПозицияВТексте - мНачальнаяПозиция0ВложенногоТекста;
	Иначе 
		ПозицияКурсора = Неопределено;
	КонецЕсли;
	мПакетЗапросов.ТекстыЗапросов = мПлатформа.РазбитьГрубоТекстПакетногоЗапросаНаЗапросы(ВыражениеЛитерала, ПозицияКурсора, мПакетЗапросов.Позиции0Запросов);
КонецПроцедуры

// Функция - Новый пакет запросов
//
// Параметры:
//  Текст			 - 	 - 
//  КоординатыТекста - см. НовыеКоординатыВыражения - 
// 
// Возвращаемое значение:
//   - 
Функция НовыйПакетЗапросов(Знач Текст = Неопределено, Знач КоординатыТекста = Неопределено) Экспорт
	Результат = Новый Структура("Тип, ТекстыЗапросов, Структура, Позиции0Запросов, Параметры");
	Результат.Вставить("Тип", "ПакетЗапросов");
	Результат.Вставить("Текст", Текст);
	Результат.Вставить("КоординатыТекста", КоординатыТекста);
	Результат.Вставить("Параметры", Новый Структура);
	//!Результат.Вставить("ТекстыЗапросов", Новый Массив);
	//!Результат.Вставить("Позиции0Запросов", Новый Массив); // Начиная с 0
	//!Результат.Вставить("Структура", Новый СписокЗначений);
	Возврат Результат;
КонецФункции

// Функция - Загрузить метод модуля по позиции
//
// Параметры:
//  ПозицияВТексте	 - Число - начиная с 1
// 
// Возвращаемое значение:
//   Булево - загружен ли другой метод
//
Функция ЗагрузитьМетодМодуляПоПозиции(Знач ПозицияВТексте1, Знач ПерезагрузитьТекущий = Ложь) Экспорт 
	
	НовыйМетодМодуля = Неопределено; 
	Если Истина
		И мЯзыкПрограммы = 0
		И мМетодМодуля <> Неопределено
		И мМетодМодуля.ПозицияСОписанием <= ПозицияВТексте1 
		И мМетодМодуля.ПозицияСОписанием + мМетодМодуля.ДлинаСОписанием >= ПозицияВТексте1
	Тогда
		// Не вышли за пределы текущего метода   
		Если ПерезагрузитьТекущий Тогда
			НовыйМетодМодуля = мМетодМодуля;
			мМетодМодуля = Неопределено;
		Иначе 
			Возврат Ложь;
		КонецЕсли;
	КонецЕсли;
	Если НовыйМетодМодуля = Неопределено Тогда
		_РежимОтладки = Ложь;
		Если _РежимОтладки Тогда // Можно менять на Истина в точке останова, например условием ирОбщий.Пр(_РежимОтладки, 1, 1)
			// Пассивный оригинал расположенного ниже однострочного кода. Выполняйте изменения синхронно в обоих вариантах.
			Для Каждого СтрокаМетода Из мМодульМетаданных.Методы Цикл
				Если Истина 
					И СтрокаМетода.ПозицияСОписанием <> 0
					И СтрокаМетода.ПозицияСОписанием <= ПозицияВТексте1 
					И СтрокаМетода.ПозицияСОписанием + СтрокаМетода.ДлинаСОписанием >= ПозицияВТексте1       
				Тогда
					НовыйМетодМодуля = СтрокаМетода;
					Прервать;
				КонецЕсли;  
			КонецЦикла;         
		Иначе
			// Однострочный код использован для ускорения при разрешенной отладке. Выше расположен оригинал. Выполняйте изменения синхронно в обоих вариантах. Преобразовано консолью кода из подсистемы "Инструменты разработчика"
			Для Каждого СтрокаМетода Из мМодульМетаданных.Методы Цикл  				Если Истина  					И СтрокаМетода.ПозицияСОписанием <> 0  					И СтрокаМетода.ПозицияСОписанием <= ПозицияВТексте1  					И СтрокаМетода.ПозицияСОписанием + СтрокаМетода.ДлинаСОписанием >= ПозицияВТексте1  				Тогда  					НовыйМетодМодуля = СтрокаМетода;  					Прервать;  				КонецЕсли;  			КонецЦикла;  
		КонецЕсли;
	КонецЕсли;
	Результат = ЗагрузитьМетодМодуля(НовыйМетодМодуля);
	Возврат Результат;

КонецФункции

Функция ЗагрузитьМетодМодуля(Знач НовыйМетодМодуля, Знач БезВозвратов = Истина) Экспорт 
	мТекстБлока = ТелоМетода(НовыйМетодМодуля,, БезВозвратов); // Переустанавливаем текст блока всегда на случай, если вызвано после подмены возвратов в теле
	Если НовыйМетодМодуля = мМетодМодуля И НовыйМетодМодуля <> Неопределено Тогда
		Возврат Ложь;
	КонецЕсли;  
	мМетодМодуля = НовыйМетодМодуля;
	Если мМетодМодуля <> Неопределено Тогда
		мФлагиКомпиляции = ирОбщий.СкопироватьКоллекциюЛкс(мМодульМетаданных.ФлагиКомпиляции);
		мФлагиКомпиляции.Сервер                      = мМетодМодуля.Сервер И мФлагиКомпиляции.Сервер;  
		мФлагиКомпиляции.КлиентУправляемоеПриложение = мМетодМодуля.Клиент И мФлагиКомпиляции.КлиентУправляемоеПриложение;
		мФлагиКомпиляции.КлиентОбычноеПриложение     = мМетодМодуля.Клиент И мФлагиКомпиляции.КлиентОбычноеПриложение;  
		мФлагиКомпиляции.БезКонтекста = мМетодМодуля.БезКонтекста;  
		мПозицияТекстаДляПоискаОпределения = мМетодМодуля.ПозицияТела;        
	Иначе
		мПозицияТекстаДляПоискаОпределения = мМодульМетаданных.ПозицияПрограммы - 1; // -1, чтобы проверки литералов работали 
	КонецЕсли;
	мПозицияВБлоке = 0;
	мНомерПервойСтрокиТелаМетода = Неопределено;
	Возврат Истина;
КонецФункции

// Перед вызовом нужно разобрать контекст
//
// Параметры:
//  МетодМодуля				 - 	 - если Неопределено, то возвращает программу модуля
//  выхНомерПервойСтрокиТела - 	 - 
//  БезВозвратов			 - 	 - 
//  _выхНачальнаяПозиция	 - 	 - 
// 
// Возвращаемое значение:
//   - 
//
Функция ТелоМетода(МетодМодуля, выхНомерПервойСтрокиТела = 1, Знач БезВозвратов = Истина, _выхНачальнаяПозиция = 0) Экспорт 
	выхНомерПервойСтрокиТела = мНомерПервойСтрокиТелаМетода;
	Если МетодМодуля <> Неопределено Тогда  
		выхНачальнаяПозиция = МетодМодуля.ПозицияТела; 
		Если выхНачальнаяПозиция = 0 Тогда
			Результат = "";
		ИначеЕсли Истина
			И БезВозвратов 
			И (Ложь
				Или МетодМодуля.ТелоБезВозвратов <> Неопределено
				Или МетодМодуля.ТипЗначения <> Неопределено)
		Тогда
			Результат = МетодМодуля.ТелоБезВозвратов;
			Если Результат = Неопределено Тогда
				ИмяПеременной = ИмяПеременнойВозвращаемогоЗначения();
				Результат = Сред(мОригинальныйТекст, выхНачальнаяПозиция + 1, МетодМодуля.ДлинаТела); // Мультиметка38422941
				Результат = ЗаменитьВозвратыНаПерейтиВТекстеМетода(Результат, ИмяПеременной,, Неопределено); // Замена без смещения позиций!
				МетодМодуля.ТелоБезВозвратов = Результат;
			КонецЕсли;
		Иначе 
			Результат = Сред(мОригинальныйТекст, выхНачальнаяПозиция + 1, МетодМодуля.ДлинаТела); // Мультиметка38422941
		КонецЕсли;
	ИначеЕсли мМодульМетаданных <> Неопределено Тогда 
		выхНачальнаяПозиция = мМодульМетаданных.ПозицияПрограммы;
		Если Сред(Результат, выхНачальнаяПозиция, 1) = Символы.ПС Тогда
			// Мультиметка882366123 +1 нужно для случая, когда программа начинается с пустой строки - тогда мНомерПервойСтрокиТелаМетода будет на 1 больше
			выхНачальнаяПозиция = выхНачальнаяПозиция + 1;
		КонецЕсли;
		Результат = Сред(мОригинальныйТекст, выхНачальнаяПозиция);
	Иначе
		Результат = мОригинальныйТекст;
	КонецЕсли; 
	Возврат Результат;
КонецФункции  

// Сначала нужно разобрать контекст
Функция ОпределениеАктивногоМетодаСОписанием(СмещениеНомераМетода = 0) Экспорт 
	Если мМетодМодуля <> Неопределено Тогда
		Если СмещениеНомераМетода = 0 Тогда
			Результат = ТекстМетодаСОписанием(мМетодМодуля);
		Иначе
			СледующийМетодМодуля = мМодульМетаданных.Методы[мМодульМетаданных.Методы.Индекс(мМетодМодуля) + СмещениеНомераМетода];
			Результат = ТекстМетодаСОписанием(СледующийМетодМодуля);
		КонецЕсли;
	Иначе
		Результат = ТелоМетода(Неопределено);
	КонецЕсли; 
	Возврат Результат;
КонецФункции

Функция ТекстМетодаСОписанием(МетодМодуля) Экспорт
	Результат = Сред(мОригинальныйТекст, МетодМодуля.ПозицияСОписанием, МетодМодуля.ДлинаСОписанием);
	Возврат Результат;
КонецФункции   

// Функция - Текст описания метода
// Параметры:
//  МетодМодуля - см. мПлатформа.НоваяТаблицаМетодовМодуля()[0] - 
Функция ТекстОписанияМетода(МетодМодуля) Экспорт
	Результат = Сред(мОригинальныйТекст, МетодМодуля.ПозицияСОписанием, МетодМодуля.ДлинаСОписанием - МетодМодуля.ДлинаОпределения);
	Возврат Результат;
КонецФункции   

// Сначала нужно разобрать контекст
Функция ОпределениеМетодаБезОписания(МетодМодуля = Неопределено) Экспорт 
	Если МетодМодуля = Неопределено Тогда
		МетодМодуля = мМетодМодуля;
	КонецЕсли;
	Если мМетодМодуля <> Неопределено Тогда
		Результат = Сред(мОригинальныйТекст, мМетодМодуля.ПозицияОпределения, мМетодМодуля.ДлинаОпределения);
		Результат = ирОбщий.ЗаменитьРегВыражениеЛкс(Результат, "^\n*", "", Ложь);
		Возврат Результат;
	Иначе
		Возврат мОригинальныйТекст;
	КонецЕсли; 
КонецФункции

// Выполняет программу на внутреннем языке.
//
// Параметры:
//  Нет.
//
// Возвращаемое значение:
//  Булево - безошибочность выполнения кода.
//
Функция ВыполнитьПрограммныйКод(Знач ЛиСинтаксическийКонтроль = Ложь, выхИнформацияОбОшибке = Неопределено, Знач ТекстДляВыполнения = "") Экспорт
	
	#Если Сервер И Не Сервер Тогда
		мПлатформа = Обработки.ирПлатформа.Создать();
	#КонецЕсли
	Если Не ЗначениеЗаполнено(ТекстДляВыполнения) Тогда
		ТекстДляВыполнения = ПолеТекста.ПолучитьТекст();
	КонецЕсли;
	Попытка
		мПлатформа.ВыполнитьПрограммныйКодВКонтексте(КонтекстВыполнения, МетодВыполнения, ТекстДляВыполнения, ЛиСинтаксическийКонтроль);
		Возврат Истина;
	Исключение
		выхИнформацияОбОшибке = ИнформацияОбОшибке();
		Если Не ЛиСинтаксическийКонтроль Тогда
			// Баг платформы. Зависает приложение, если пытаемся установить выделение на невидимой странице.
			ФормаВладелец.ТекущийЭлемент = ПолеТекста.ЭлементФормы;
			
			ирКлиент.ПоказатьОшибкуВТекстеПрограммыЛкс(ПолеТекста,,,,, выхИнформацияОбОшибке); 
		КонецЕсли;
		Возврат Ложь;
	КонецПопытки;

КонецФункции

Функция ЗаполнитьДоступныеТаблицыWQL() Экспорт

	ОчиститьДоступныеНеВременныеТаблицы();
	Если Конфигурация = Неопределено Тогда
		Возврат Неопределено;
	КонецЕсли; 
	Состояние("Подготовка метаданных...");
	wbemFlagUseAmendedQualifiers = 131072; //&H20000
	КоллекцияКлассов = Конфигурация.SubclassesOf(, wbemFlagUseAmendedQualifiers);
	ВидимостьКолонкиСхема = Ложь;
	ВидимостьКолонкиОписание = Ложь;
	Индикатор = ирОбщий.ПолучитьИндикаторПроцессаЛкс(КоллекцияКлассов.Count, "Получаем метаданные");
	Для Каждого ЭлементКоллекции Из КоллекцияКлассов Цикл
		ирОбщий.ОбработатьИндикаторЛкс(Индикатор);
		СтрокаТаблицы = ДоступныеТаблицы.Добавить();
		СтрокаТаблицы.Имя = ЭлементКоллекции.Path_.Class;
		//СтрокаТаблицы.Схема = СтрокаТЗ.TABLE_SCHEMA;
		//СтрокаТаблицы.Тип = СтрокаТЗ.TABLE_TYPE;
		СтрокаТаблицы.Описание = ирОбщий.ПолучитьОписаниеЭлементаWMIЛкс(ЭлементКоллекции);
		ПолноИмя = СтрокаТаблицы.Имя;
		Если ЗначениеЗаполнено(СтрокаТаблицы.Схема) Тогда
			ПолноИмя = СтрокаТаблицы.Схема + "." + ПолноИмя;
		КонецЕсли;
		СтрокаТаблицы.ПолноеИмя = ПолноИмя;
		СтрокаТаблицы.НПолноеИмя = НРег(СтрокаТаблицы.ПолноеИмя);
		ВидимостьКолонкиСхема = ВидимостьКолонкиСхема Или ЗначениеЗаполнено(СтрокаТаблицы.Схема);
		ВидимостьКолонкиОписание = ВидимостьКолонкиСхема Или ЗначениеЗаполнено(СтрокаТаблицы.Описание);
	КонецЦикла;
	ирОбщий.ОсвободитьИндикаторПроцессаЛкс();
	Возврат Неопределено;

КонецФункции

Функция ЗаполнитьДоступныеТаблицыADO(Знач ИмяТаблицыФильтр = "") Экспорт

	Если ПустаяСтрока(ИмяТаблицыФильтр) Тогда
		ОчиститьДоступныеНеВременныеТаблицы();
	КонецЕсли;
	Если Ложь
		Или Конфигурация = Неопределено 
		Или Конфигурация.State = 0
	Тогда
		Возврат Неопределено;
	КонецЕсли; 
	Если Не ПустаяСтрока(ИмяТаблицыФильтр) Тогда
		Состояние("Подготовка метаданных ADO...");
	КонецЕсли;
	Если Не мРасширенноеПолучениеМетаданныхADO Тогда
		Фильтры = Новый Массив();
		Фильтры.Добавить(); // TABLE_CATALOG
		Фильтры.Добавить(); // TABLE_SCHEMA
		// TABLE_NAME
		Если ЗначениеЗаполнено(ИмяТаблицыФильтр) Тогда
			Фильтры.Добавить(ИмяТаблицыФильтр);
		Иначе
			Фильтры.Добавить(); 
		КонецЕсли;
		Фильтры.Добавить("TABLE"); // TABLE_TYPE
		Фильтры = Новый COMSafeArray(Фильтры, "VT_VARIANT");
		ОписаниеТаблицRecordSet = Конфигурация.OpenSchema(20, Фильтры); //adSchemaTables // Может выполняться долго (oracle)
	Иначе
		ОписаниеТаблицRecordSet = Конфигурация.OpenSchema(20); //adSchemaTables // Может выполняться долго (oracle)
	КонецЕсли; 
	ОписаниеТаблицТЗ = ирОбщий.РезультатЗапросаADOВТаблицуЗначенийОбщийЛкс(ОписаниеТаблицRecordSet);
	//! ОписаниеТаблицТЗ.Колонки.Добавить("TABLE_TYPE");
	//! ОписаниеТаблицТЗ.Колонки.Добавить("DESCRIPTION");
	//! ОписаниеТаблицТЗ.Колонки.Добавить("TABLE_SCHEMA");
	//! ОписаниеТаблицТЗ.Колонки.Добавить("TABLE_NAME");
	Если ирКэш.РежимОтладкиЛкс() Тогда 
		// Пассивный оригинал расположенного ниже однострочного кода. Выполняйте изменения синхронно в обоих вариантах.
		Для Каждого СтрокаТЗ Из ОписаниеТаблицТЗ Цикл
			ТипТаблицы = СтрокаТЗ.TABLE_TYPE;
			Если Истина
				И Не ирОбщий.СтрокиРавныЛкс(ТипТаблицы, "table")
				И Не ирОбщий.СтрокиРавныЛкс(ТипТаблицы, "view")
			Тогда
				Продолжить;
			КонецЕсли; 
			СтрокаТаблицы = ДоступныеТаблицы.Добавить();
			СтрокаТаблицы.Имя = СтрокаТЗ.TABLE_NAME;
			СтрокаТаблицы.Схема = СтрокаТЗ.TABLE_SCHEMA;
			СтрокаТаблицы.Тип = ТипТаблицы;
			СтрокаТаблицы.Описание = СтрокаТЗ.DESCRIPTION;
			ПолноеИмяДоступнойТаблицы = ПолноеИмяДоступнойТаблицы(СтрокаТаблицы.Имя, СтрокаТаблицы.Схема);
			СтрокаТаблицы.ПолноеИмя = ПолноеИмяДоступнойТаблицы;
			СтрокаТаблицы.НПолноеИмя = НРег(ПолноеИмяДоступнойТаблицы);
		КонецЦикла;
	Иначе
		// Однострочный код использован для ускорения. Выше расположен оригинал. Выполняйте изменения синхронно в обоих вариантах. Преобразовано консолью кода из подсистемы "Инструменты разработчика" (http://devtool1c.ucoz.ru)
		Для Каждого СтрокаТЗ Из ОписаниеТаблицТЗ Цикл  		ТипТаблицы = СтрокаТЗ.TABLE_TYPE;  		Если Истина  			И Не ирОбщий.СтрокиРавныЛкс(ТипТаблицы, "table")  			И Не ирОбщий.СтрокиРавныЛкс(ТипТаблицы, "view")  		Тогда  			Продолжить;  		КонецЕсли;  		СтрокаТаблицы = ДоступныеТаблицы.Добавить();  		СтрокаТаблицы.Имя = СтрокаТЗ.TABLE_NAME;  		СтрокаТаблицы.Схема = СтрокаТЗ.TABLE_SCHEMA;  		СтрокаТаблицы.Тип = ТипТаблицы;  		СтрокаТаблицы.Описание = СтрокаТЗ.DESCRIPTION;  		ПолноеИмяДоступнойТаблицы = ПолноеИмяДоступнойТаблицы(СтрокаТаблицы.Имя, СтрокаТаблицы.Схема);  		СтрокаТаблицы.ПолноеИмя = ПолноеИмяДоступнойТаблицы;  		СтрокаТаблицы.НПолноеИмя = НРег(ПолноеИмяДоступнойТаблицы);  	КонецЦикла;  
	КонецЕсли; 
	Возврат Неопределено;

КонецФункции

Функция ПолучитьИмяТаблицыADO(Знач ИмяИсходное)  
	
	Если Лев(ИмяИсходное, 1) <> "[" Тогда
		ИмяИсходное = "[" + ИмяИсходное + "]";  
	КонецЕсли;  
	Возврат ИмяИсходное;
	
 КонецФункции

Процедура ОбновитьВычисляемыеДоступныеВременныеТаблицы() Экспорт 
	ОчиститьДоступныеВременныеТаблицы(); 
	Если мМенеджерВременныхТаблиц <> Неопределено Тогда
		Для Каждого ПакетЗапросов Из мМенеджерВременныхТаблиц.ПакетыЗапросов Цикл // см. НовыйПакетЗапросов()
			ПодготовитьПакетЗапросов(ПакетЗапросов);
			Для Каждого ЭлементСписка Из ПакетЗапросов.Структура Цикл
				Если ЗначениеЗаполнено(ЭлементСписка.Представление) Тогда
					НайтиДобавитьДоступнуюВременнуюТаблицу(ЭлементСписка.Представление);
				КонецЕсли;
			КонецЦикла;
			Для Каждого КлючИЗначение Из ПакетЗапросов.Параметры Цикл
				ЗначениеПараметра = мПлатформа.ПодготовитьЗначениеПараметраЗапроса(КлючИЗначение.Значение);
				Если ТипЗнч(ЗначениеПараметра) = Тип("ТаблицаЗначений") Тогда
					НайтиДобавитьДоступнуюВременнуюТаблицу("&" + КлючИЗначение.Ключ);
				КонецЕсли;
				Если ТипЗнч(КонтекстВыполнения) = Тип("Запрос") Тогда   
					КонтекстВыполнения.Параметры.Вставить(КлючИЗначение.Ключ, ЗначениеПараметра);
				КонецЕсли;
			КонецЦикла;
		КонецЦикла;
	КонецЕсли;
КонецПроцедуры
 
Функция НайтиДобавитьДоступнуюВременнуюТаблицу(Знач ЛюбоеИмяТаблицы, ПородившийЗапрос = Неопределено, выхБылиДобавления = Ложь, ИсточникДанных1С = Неопределено) Экспорт
	
	ПолноеИмяТаблицы = ПолноеИмяДоступнойТаблицы(ЛюбоеИмяТаблицы);
	КраткоеИмяТаблицы = КраткоеИмяВременнойТаблицы(ЛюбоеИмяТаблицы);
	Если Лев(ЛюбоеИмяТаблицы, 1) = "&" Тогда
		Тип = "Параметр";
		КраткоеИмяТаблицы = Сред(КраткоеИмяТаблицы, 2);
	Иначе
		Тип = "ВременнаяТаблица";
	КонецЕсли;
	ПолноеИмяТаблицы = ПолноеИмяВременнойТаблицы(ПолноеИмяТаблицы, ИсточникДанных1С);
	СтрокаДоступнойТаблицы = ДоступныеТаблицы.Найти(НРег(ПолноеИмяТаблицы), "НПолноеИмя");
	Если СтрокаДоступнойТаблицы = Неопределено Тогда
		СтрокаДоступнойТаблицы = ДоступныеТаблицы.Добавить();
		СтрокаДоступнойТаблицы.Имя = КраткоеИмяТаблицы;
		СтрокаДоступнойТаблицы.ПолноеИмя = ПолноеИмяТаблицы;
		СтрокаДоступнойТаблицы.Схема = ИсточникДанных1С;
		ирОбщий.ОбновитьКопиюСвойстваВНижнемРегистреЛкс(СтрокаДоступнойТаблицы, "ПолноеИмя");
		СтрокаДоступнойТаблицы.Тип = Тип;
		СтрокаДоступнойТаблицы.ЕстьДоступ = Истина;
		выхБылиДобавления = Истина;
	КонецЕсли;
	Если ПородившийЗапрос <> Неопределено Тогда
		Для Каждого СтараяСтрока Из ДоступныеТаблицы.НайтиСтроки(Новый Структура("ПородившийЗапрос", ПородившийЗапрос)) Цикл
			Если СтараяСтрока = СтрокаДоступнойТаблицы Тогда
				Продолжить;
			КонецЕсли; 
			ДоступныеТаблицы.Удалить(СтараяСтрока);
		КонецЦикла;
		СтрокаДоступнойТаблицы.ПородившийЗапрос = ПородившийЗапрос;
	КонецЕсли; 
	Возврат СтрокаДоступнойТаблицы;
	
КонецФункции

Функция ПолноеИмяДоступнойТаблицы(Знач ИмяДоступнойТаблицы, ИмяСхемы = Неопределено) Экспорт 
	
	Если Истина
		И Найти(ИмяДоступнойТаблицы, ".") = 0 
		И мПараметрыДиалектаSQL.Диалект <> "1С" 
		И мПараметрыДиалектаSQL.Диалект <> "WQL"
	Тогда
		ИмяДоступнойТаблицы = ПолучитьИмяТаблицыADO(ИмяДоступнойТаблицы); 
		Если ИмяСхемы = Неопределено И ДоступныеТаблицы.Количество() > 0 Тогда
			ИмяСхемы = ДоступныеТаблицы[0].Схема;
		КонецЕсли;
		Если ЗначениеЗаполнено(ИмяСхемы) Тогда
			ИмяДоступнойТаблицы = ИмяСхемы + "." + ИмяДоступнойТаблицы;
		КонецЕсли; 
	КонецЕсли; 
	Возврат ИмяДоступнойТаблицы;

КонецФункции

Функция ДоступнаяТаблицаПоЛюбомуИмени(Знач ПолноеИмя) Экспорт 

	Если ПустаяСтрока(ПолноеИмя) Тогда
		Возврат Неопределено;
	КонецЕсли;
	ПолноеИмяДоступнойТаблицы = ПолноеИмяДоступнойТаблицы(ПолноеИмя);
	СтрокаДоступнойТаблицы = ДоступныеТаблицы.Найти(НРег(ПолноеИмяДоступнойТаблицы), "НПолноеИмя");
	Если Истина
		И СтрокаДоступнойТаблицы = Неопределено 
		И Не мПараметрыДиалектаSQL.Это1С
	Тогда
		ЗаполнитьДоступныеТаблицыADO(ПолноеИмяДоступнойТаблицы);
		СтрокаДоступнойТаблицы = ДоступныеТаблицы.Найти(НРег(ПолноеИмяДоступнойТаблицы), "НПолноеИмя");
	КонецЕсли;
	Возврат СтрокаДоступнойТаблицы;

КонецФункции

//.
// Параметры:
//   СтрокаДоступнойТаблицы - ОбработкаТабличнаяЧастьСтрока.ирКлсПолеТекстаПрограммы.ДоступныеТаблицы - 
Функция ОсновнойПсевдонимТаблицыБД(Знач СтрокаДоступнойТаблицы, Знач Английский1С = Ложь) Экспорт
	Если мПараметрыДиалектаSQL.Это1С И Не Английский1С Тогда
		Суффикс = "Т";
	Иначе
		Суффикс = "T";
	КонецЕсли;
	БазовоеИмя = Лев(ирОбщий.ИдентификаторИзПредставленияЛкс(СтрокаДоступнойТаблицы.Имя), 50) + Суффикс;
	Возврат БазовоеИмя;
КонецФункции

Функция ЭтоПараметрПериодичность1С(Знач СтрокаПараметраТаблицы, Знач ДиалектSQL = "") Экспорт
	Если ДиалектSQL = "" Тогда
		ДиалектSQL = мДиалектSQL;
	КонецЕсли;
	Результат = Истина
		И Найти(НРег(СтрокаПараметраТаблицы.Имя), "периодичность") = 1
		И ирОбщий.СтрокиРавныЛкс(ДиалектSQL, "1С");
	Возврат Результат;
КонецФункции

Функция ПоляДоступнойТаблицы(Знач СтрокаДоступнойТаблицы, Знач ПараметрыТаблицы = Неопределено, Знач ДиалектSQL = "", Знач ПородившийЗапрос = Неопределено) Экспорт 
	
	Если ДиалектSQL = "" Тогда
		ДиалектSQL = мДиалектSQL;
	КонецЕсли;
	ПолноеИмяТаблицы = СтрокаДоступнойТаблицы.ПолноеИмя;
	ИспользоватьКэширование = Истина
		И СтрокаДоступнойТаблицы.Тип <> "ВременнаяТаблица"
		И СтрокаДоступнойТаблицы.Тип <> "Параметр"
		И ТипЗнч(Конфигурация) <> Тип("Неопределено");
	Если ИспользоватьКэширование Тогда 
		ТаблицаПолей = мДоступныеПоляТаблиц[ПолноеИмяТаблицы];
		Если ТаблицаПолей <> Неопределено Тогда
			Возврат ТаблицаПолей;
		КонецЕсли; 
	КонецЕсли; 
	ТаблицаПолей = Новый ТаблицаЗначений;
	ТаблицаПолей.Колонки.Добавить("Имя", Новый ОписаниеТипов("Строка"));
	ТаблицаПолей.Колонки.Добавить("ТипЗначения", Новый ОписаниеТипов("ОписаниеТипов"));
	ТаблицаПолей.Колонки.Добавить("Метаданные");
	Если СтрокаДоступнойТаблицы.Тип = "ВременнаяТаблица" Тогда
		КолонкиРезультата = Новый Массив();
		Если ПородившийЗапрос <> Неопределено Тогда
			//КолонкиРезультата = ПородившийЗапрос.ЧастиОбъединения[0].ВыбранныеПоля;
			КолонкиРезультата = ПородившийЗапрос.ПоляОбъединения;
		ИначеЕсли мМенеджерВременныхТаблиц <> Неопределено Тогда
			Построитель = НайтиЗапросВременнойТаблицы(ПолноеИмяТаблицы, мМенеджерВременныхТаблиц);
			Если Построитель <> Неопределено Тогда
				КолонкиРезультата = мПлатформа.ПустаяТаблицаЗначенийИзПостроителя(Построитель).Колонки;
			КонецЕсли;
		Иначе
			ТекстЗапроса = "SELECT * FROM " + ПолноеИмяТаблицы + " WHERE 1=0";
			Если ТипЗнч(КонтекстВыполнения) = Тип("Запрос") Тогда
				ВременныйЗапрос = Новый Запрос;
				ВременныйЗапрос.МенеджерВременныхТаблиц = КонтекстВыполнения.МенеджерВременныхТаблиц;
				ВременныйЗапрос.Текст = ТекстЗапроса;
				РезультатВременногоЗапроса = Неопределено;
				Попытка
					РезультатВременногоЗапроса = ВременныйЗапрос.Выполнить();
				Исключение
				КонецПопытки;
				Если РезультатВременногоЗапроса <> Неопределено Тогда
					КолонкиРезультата = РезультатВременногоЗапроса.Выгрузить();
					КолонкиРезультата = ирОбщий.ТаблицаСКолонкамиБезТипаNullЛкс(КолонкиРезультата, Ложь);
					КолонкиРезультата = КолонкиРезультата.Колонки;
				КонецЕсли;
			ИначеЕсли ирОбщий.СтрокиРавныЛкс(ДиалектSQL, "WQL") Тогда
				//
			Иначе // ADO
				Попытка
					РезультатВременногоЗапроса = Конфигурация.Execute(ТекстЗапроса);
				Исключение  
					ОписаниеОшибки = ОписаниеОшибки();
				КонецПопытки;
				Если РезультатВременногоЗапроса <> Неопределено Тогда
					РезультатТаблица = Новый ТаблицаЗначений;
					ирОбщий.ПолучитьКолонкиRecordsetADOЛкс(РезультатТаблица, РезультатВременногоЗапроса, Истина);
					КолонкиРезультата = РезультатТаблица.Колонки;
				КонецЕсли; 
			КонецЕсли; 
		КонецЕсли; 
		Для Каждого ВыбранноеПоле Из КолонкиРезультата Цикл
			Если ВыбранноеПоле.Имя = "" Тогда
				ВызватьИсключение "Не определены имена полей таблицы """ + ПолноеИмяТаблицы + """";
			КонецЕсли; 
			СтрокаПоля = ТаблицаПолей.Добавить();
			СтрокаПоля.Имя = ВыбранноеПоле.Имя;
			СтрокаПоля.ТипЗначения = ВыбранноеПоле.ТипЗначения;
		КонецЦикла;
	ИначеЕсли СтрокаДоступнойТаблицы.Тип = "Параметр" Тогда
		КолонкиРезультата = Новый Массив();
		ТаблицаПараметр = Неопределено;
		Если Истина
			И ТипЗнч(КонтекстВыполнения) = Тип("Запрос")
			//! КонтекстВыполнения = Новый Запрос;
			И КонтекстВыполнения.Параметры.Свойство(СтрокаДоступнойТаблицы.Имя, ТаблицаПараметр) 
		Тогда 
			Попытка
				КолонкиРезультата = ТаблицаПараметр.Колонки;
			Исключение
				// TODO Табличная часть
			КонецПопытки;
		КонецЕсли;
		Для Каждого ВыбранноеПоле Из КолонкиРезультата Цикл
			СтрокаПоля = ТаблицаПолей.Добавить();
			СтрокаПоля.Имя = ВыбранноеПоле.Имя;
			СтрокаПоля.ТипЗначения = ВыбранноеПоле.ТипЗначения;
		КонецЦикла;
	ИначеЕсли ТипЗнч(Конфигурация) = Тип("Неопределено") Тогда
		ИндексПараметраПериодичность = Неопределено;
		ОпределениеПараметраПериодичность = "";
		Если ПараметрыТаблицы <> Неопределено Тогда
			Для ИндексПараметра = 0 По ПараметрыТаблицы.Количество() - 1 Цикл
				СтрокаПараметраТаблицы = ПараметрыТаблицы[ИндексПараметра];
				Если ЭтоПараметрПериодичность1С(СтрокаПараметраТаблицы) Тогда
					ИндексПараметраПериодичность = ИндексПараметра;
					ОпределениеПараметраПериодичность = СтрокаПараметраТаблицы.Определение;
					Прервать;
				КонецЕсли; 
			КонецЦикла;
		КонецЕсли; 
		//ПоляТаблицыБД = ирОбщий.ПоляТаблицыМДЛкс(ПолноеИмяТаблицы,, ИндексПараметраПериодичность, ОпределениеПараметраПериодичность, Ложь); // Для регистра бухглатерии возвращает лишние поля
		ПоляТаблицыБД = ирКэш.ПоляТаблицыБДЛкс(ПолноеИмяТаблицы,, ИндексПараметраПериодичность, ОпределениеПараметраПериодичность);
		Если ПоляТаблицыБД <> Неопределено Тогда
			_РежимОтладки = Ложь;
			Если _РежимОтладки Тогда // Можно менять на Истина в точке останова, например условием ирОбщий.Пр(_РежимОтладки, 1, 1)
				// Пассивный оригинал расположенного ниже однострочного кода. Выполняйте изменения синхронно в обоих вариантах.
				Для Каждого ПолеТаблицыБД Из ПоляТаблицыБД Цикл
					//Если ПолеТаблицыБД.ТипЗначения.СодержитТип(Тип("ТаблицаЗначений")) Тогда
					//	Продолжить;
					//КонецЕсли;
					СтрокаПоля = ТаблицаПолей.Добавить();
					СтрокаПоля.Имя = ПолеТаблицыБД.Имя;
					СтрокаПоля.ТипЗначения = ПолеТаблицыБД.ТипЗначения;
					СтрокаПоля.Метаданные = ПолеТаблицыБД.Метаданные;
				КонецЦикла;
			Иначе
				// Однострочный код использован для ускорения при разрешенной отладке. Выше расположен оригинал. Выполняйте изменения синхронно в обоих вариантах. Преобразовано консолью кода из подсистемы "Инструменты разработчика"
				Для Каждого ПолеТаблицыБД Из ПоляТаблицыБД Цикл        				СтрокаПоля = ТаблицаПолей.Добавить();  				СтрокаПоля.Имя = ПолеТаблицыБД.Имя;  				СтрокаПоля.ТипЗначения = ПолеТаблицыБД.ТипЗначения;  				СтрокаПоля.Метаданные = ПолеТаблицыБД.Метаданные;  			КонецЦикла;  
			КонецЕсли;
			ирОбщий.ДополнитьТаблицуПолейТаблицыБДВиртуальнымиПолямиЛкс(ТаблицаПолей, СтрокаДоступнойТаблицы, Истина);
		КонецЕсли;
	Иначе
		СтрокаДоступнойТаблицы = ДоступнаяТаблицаПоЛюбомуИмени(ПолноеИмяТаблицы);
		Если ирОбщий.СтрокиРавныЛкс(ДиалектSQL, "WQL") Тогда
			wbemFlagUseAmendedQualifiers = 131072; //&H20000
			ОписаниеКласса = Конфигурация.Get(СтрокаДоступнойТаблицы.Имя, wbemFlagUseAmendedQualifiers); 
			ТаблицаКласса = Новый ТаблицаЗначений;
			МассивКоллекцийСвойств = Новый Массив();
			МассивКоллекцийСвойств.Добавить(ОписаниеКласса.Properties_);
			//Если СобиратьСистемныеСвойстваWMI Тогда
			//	МассивКоллекцийСвойств.Добавить(ОписаниеКласса.SystemProperties_);
			//КонецЕсли; 
			Для Каждого КоллекцияСвойств Из МассивКоллекцийСвойств Цикл
				Для Каждого Свойство Из КоллекцияСвойств Цикл
					ИмяТипа = ирОбщий.ИмяТипаИзКвалификаторовWMIЛкс(Свойство);
					Попытка
						ОписаниеТипов = Новый ОписаниеТипов(ИмяТипа,,,, Новый КвалификаторыСтроки(1024)); // Доделать распознавание типов
					Исключение
						ОписаниеТипов = Новый ОписаниеТипов();
					КонецПопытки;
					ПредставлениеСвойства = ирОбщий.ПолучитьОписаниеЭлементаWMIЛкс(Свойство, "DisplayName");
					ТаблицаКласса.Колонки.Добавить(, ОписаниеТипов, ПредставлениеСвойства);
					СтрокаПоля = ТаблицаПолей.Добавить();
					СтрокаПоля.Имя = Свойство.Name;
					СтрокаПоля.ТипЗначения = ОписаниеТипов;
					//СтрокаПоля.Описание = ПредставлениеСвойства;
				КонецЦикла;
			КонецЦикла;
		Иначе // ADO
			Фильтры = Новый Массив();
			Фильтры.Добавить(); //TABLE_CATALOG
			Если ЗначениеЗаполнено(СтрокаДоступнойТаблицы.Схема) Тогда //TABLE_SCHEMA
				Фильтры.Добавить(СтрокаДоступнойТаблицы.Схема);
			Иначе
				Фильтры.Добавить(Неопределено);
			КонецЕсли; 
			Фильтры.Добавить(СтрокаДоступнойТаблицы.Имя); // TABLE_NAME
			Фильтры = Новый COMSafeArray(Фильтры, "VT_VARIANT");
			Состояние("Запрашиваем поля " + ПолноеИмяТаблицы + "...");
			ОписаниеПолейRecordSet = Конфигурация.OpenSchema(4, Фильтры); //adSchemaColumns
			ADOUtils = мПлатформа.ПолучитьADOUtils();
			Если ADOUtils <> Неопределено Тогда
				ОписаниеПолейТЗ = ADOUtils.ADORecordsetToValueTable(ОписаниеПолейRecordSet); 
				Для Каждого СтрокаТЗ Из ОписаниеПолейТЗ Цикл
					СтрокаПоля = ТаблицаПолей.Добавить();
					СтрокаПоля.Имя = СтрокаТЗ.COLUMN_NAME;
					ЧисловаяРазрядность = СтрокаТЗ.NUMERIC_SCALE;
					ДлинаТипа = СтрокаТЗ.CHARACTER_MAXIMUM_LENGTH;
					ЧисловаяТочность = СтрокаТЗ.NUMERIC_PRECISION;
					НомерТипа = СтрокаТЗ.DATA_TYPE;
					FieldADO = ирОбщий.FieldADOЛкс(СтрокаПоля.Имя, НомерТипа, ДлинаТипа, ЧисловаяТочность, ЧисловаяРазрядность);
					СтрокаПоля.ТипЗначения = ирОбщий.FieldADO_ПолучитьТип1CЛкс(FieldADO, Истина);
				КонецЦикла;
			Иначе
				Пока Не ОписаниеПолейRecordSet.EOF() Цикл
					СтрокаПоля = ТаблицаПолей.Добавить();
					СтрокаПоля.Имя = ОписаниеПолейRecordSet.Fields("COLUMN_NAME").Value;
					ЧисловаяРазрядность = ОписаниеПолейRecordSet.Fields("NUMERIC_SCALE").Value; 
					ДлинаТипа = ОписаниеПолейRecordSet.Fields("CHARACTER_MAXIMUM_LENGTH").Value;
					ЧисловаяТочность = ОписаниеПолейRecordSet.Fields("NUMERIC_PRECISION").Value;
					НомерТипа = ОписаниеПолейRecordSet.Fields("DATA_TYPE").Value;
					FieldADO = ирОбщий.FieldADOЛкс(СтрокаПоля.Имя, НомерТипа, ДлинаТипа, ЧисловаяТочность, ЧисловаяРазрядность);
					СтрокаПоля.ТипЗначения = ирОбщий.FieldADO_ПолучитьТип1CЛкс(FieldADO, Истина);
					ОписаниеПолейRecordSet.MoveNext();
				КонецЦикла;
			КонецЕсли; 
		КонецЕсли; 
		Состояние();
	КонецЕсли; 
	Если ИспользоватьКэширование Тогда
		мДоступныеПоляТаблиц[ПолноеИмяТаблицы] = ТаблицаПолей;
	КонецЕсли; 
	Возврат ТаблицаПолей;
	
КонецФункции

Функция ПолноеИмяВременнойТаблицы(Знач КраткоеИмяТаблицы, Знач ИсточникДанных1С = Неопределено) Экспорт 
	
	Результат = КраткоеИмяТаблицы;
	Если Истина
		И Найти(КраткоеИмяТаблицы, ".") = 0
		И мПараметрыДиалектаSQL.Диалект = "1С"
		И ЗначениеЗаполнено(ИсточникДанных1С) 
		И ИсточникДанных1С <> "<Локальный>"
	Тогда
		Результат = "ВнешнийИсточникДанных." + ИсточникДанных1С + ".ВременнаяТаблица." + Результат;
	КонецЕсли;
	Возврат Результат;

КонецФункции

Функция КраткоеИмяВременнойТаблицы(ЛюбоеИмяТаблицы) Экспорт 
	Результат = ЛюбоеИмяТаблицы;
	Если Истина
		И мПараметрыДиалектаSQL.Диалект = "1С"
		И Найти(Результат, ".") > 0
	Тогда
		Результат = ирОбщий.ПоследнийФрагментЛкс(Результат);
	КонецЕсли;
	Возврат Результат;
КонецФункции

Процедура ОчиститьДоступныеВременныеТаблицы(ТаблицаДоступныхТаблиц = Неопределено) Экспорт

	Если ТаблицаДоступныхТаблиц = Неопределено Тогда
		ТаблицаДоступныхТаблиц = ДоступныеТаблицы;
	КонецЕсли;
	ирОбщий.УдалитьСтрокиТаблицыИлиДереваПоЗначениюЛкс(ТаблицаДоступныхТаблиц, "Тип", "ВременнаяТаблица");
	
КонецПроцедуры

Процедура ОчиститьДоступныеНеВременныеТаблицы() Экспорт

	ДоступныеВременныеТаблицы = ДоступныеТаблицы.Выгрузить(Новый Структура("Тип", "ВременнаяТаблица"));
	ДоступныеТаблицы.Очистить();
	ДоступныеТаблицы.Загрузить(ДоступныеВременныеТаблицы);
	
КонецПроцедуры

Функция ПрефиксПараметра() Экспорт
	
	Возврат мПараметрыДиалектаSQL.ПрефиксПараметра;
	
КонецФункции

// Вызывает конструктор запросов и передает ему текст из текстового поля.
//
// Параметры:
//  Нет.
//
Функция ВызватьКонструкторЗапросов(Знач ИспользуемСобственныйКонструктор = Неопределено) Экспорт

	Если ирОбщий.ПроверитьПлатформаНеWindowsЛкс(,, Истина) Тогда
		Возврат Ложь;
	КонецЕсли; 
	#Если Сервер И Не Сервер Тогда
		мПлатформа = Обработки.ирПлатформа.Создать();
	#КонецЕсли
	РежимТолькоПросмотр = Ложь
		Или ПолеТекста.ТолькоПросмотр()
		Или ФормаВладелец.ТолькоПросмотр;
	Если РежимТолькоПросмотр Тогда
		Ответ = Вопрос("Текст запроса не может быть изменен. Открыть конструктор без возможности применения изменений?",
			РежимДиалогаВопрос.ОКОтмена);
		Если Ответ = КодВозвратаДиалога.Отмена Тогда
			Возврат Ложь;
		КонецЕсли;
	КонецЕсли;
	Если Не ирКэш.ЛиПлатформаWindowsЛкс() Тогда
		ИспользуемСобственныйКонструктор = Ложь
	КонецЕсли; 
	ПредпочитаюСобственныйКонструкторЗапроса = Ложь;
	Если ИспользуемСобственныйКонструктор = Неопределено Тогда
		ПредпочитаюСобственныйКонструкторЗапроса = ирОбщий.ВосстановитьЗначениеЛкс(ИмяКласса + ".ПредпочитаюСобственныйКонструкторЗапроса");
		Если ПредпочитаюСобственныйКонструкторЗапроса = Неопределено Тогда
			Ответ = Вопрос("Подсистема имеет собственный конструктор запроса. Приоритет его использования задается в настройках компоненты ""Контекстная подсказка"".
			|Хотите установить приоритет его использования?", РежимДиалогаВопрос.ДаНет);
			ПредпочитаюСобственныйКонструкторЗапроса = Ответ = КодВозвратаДиалога.Да;
			ирОбщий.СохранитьЗначениеЛкс(ИмяКласса + ".ПредпочитаюСобственныйКонструкторЗапроса", ПредпочитаюСобственныйКонструкторЗапроса);
		КонецЕсли; 
	КонецЕсли; 
	ИспользуемСобственныйКонструктор = Ложь
		Или ИспользуемСобственныйКонструктор = Истина
		Или мДиалектSQL <> "1С"
		Или ПредпочитаюСобственныйКонструкторЗапроса;
	Если ИспользуемСобственныйКонструктор Тогда
		Если ЯзыкПрограммы = 1 Тогда
			КопияКомпоненты = ЭтотОбъект;
			Если мМенеджерВременныхТаблиц <> Неопределено Тогда
				ОбновитьВычисляемыеДоступныеВременныеТаблицы();
			КонецЕсли;
		Иначе 
			КопияКомпоненты = КопияКомпоненты(); // чтобы не испортилось содержимое СлужебноеПолеТекстаДолгое этой компоненты
			КопияКомпоненты.СоздатьСлужебноеПоле();
			КопияКомпоненты.ОбновитьВычисляемыеДоступныеВременныеТаблицы();
		КонецЕсли;
		КонструкторЗапроса = КопияКомпоненты.ПолучитьФорму("КонструкторЗапроса");
		КонструкторЗапроса.Конфигурация = Конфигурация; 
	Иначе
		КонструкторЗапроса = Новый КонструкторЗапроса;
	КонецЕсли; 
	//ОбрамитьСобранныйТекстСкобками = Ложь;
	Если ЯзыкПрограммы = 1 Тогда
		Если СтрДлина(СокрЛП(ВыделенныйТекст())) < 6 И Не ЭтоЧастичныйЗапрос Тогда 
			ТекстЗапроса = ПолеТекста.ПолучитьТекст();
			НачальнаяСтрокаЗапроса = 0; 
			НачальнаяКолонкаЗапроса = 0;
		Иначе
			ТекстЗапроса = ВыделенныйТекст();
			//Если Не ЗначениеЗаполнено(ТекстЗапроса) И ЭтоЧастичныйЗапрос Тогда
			//	ТекстЗапроса = "ВЫБРАТЬ 1";
			//	ОбрамитьСобранныйТекстСкобками = Истина;
			//КонецЕсли; 
			НачальнаяСтрокаЗапроса = мНачальнаяСтрока - 1; 
			НачальнаяКолонкаЗапроса = мНачальнаяКолонка - 1;
		КонецЕсли;
		КонструкторЗапроса.РежимКомпоновкиДанных = РежимКомпоновкиДанных;
		//КонструкторЗапроса.АвтодобавлениеПредставлений = Истина;
		МассивВременныхТаблиц = Новый Массив;
		Если Не ПустаяСтрока(ТекстЗапроса) Тогда
			Если Истина
				И ТипЗнч(КонтекстВыполнения) = Тип("Запрос") 
				И Не ИспользуемСобственныйКонструктор
			Тогда
				СтарыйТекстЗапроса = ТекстЗапроса;
				ИнформацияОбОшибке = ПроверитьТекстИВернутьОшибку(ТекстЗапроса);
				Попытка
					ТекстЗапроса = мПлатформа.ЗамаскироватьВременныеТаблицы(КонтекстВыполнения, ТекстЗапроса, МассивВременныхТаблиц);
				Исключение
					ФормаВладелец.ТекущийЭлемент = ПолеТекста.ЭлементФормы;
					ирКлиент.ПоказатьОшибкуВТекстеПрограммыЛкс(ПолеТекста, , , Истина,, ИнформацияОбОшибке());
					Возврат Ложь;
				КонецПопытки;
				НоваяИнформацияОбОшибке = ПроверитьТекстИВернутьОшибку(ТекстЗапроса);
				Если Истина
					И НоваяИнформацияОбОшибке <> Неопределено
					И ИнформацияОбОшибке = Неопределено
					И Найти(ирОбщий.ПодробноеПредставлениеОшибкиЛкс(НоваяИнформацияОбОшибке), "Ожидается псевдоним запроса") > 0 
				Тогда
					// Сюда попадаем, когда у временной таблицы нет псевдонима
					ирОбщий.СообщитьСУчетомМодальностиЛкс("В запросе присутствуют временные таблицы без псевдонимов. "
						+ "Для максимальной функциональности рекомендуется задать каждой временной таблице псевдоним",, СтатусСообщения.Внимание);
					МассивВременныхТаблиц = Новый Массив;
					ТекстЗапроса = СтарыйТекстЗапроса;
                КонецЕсли; 
			КонецЕсли;
		КонецЕсли;
	Иначе
		ТекстЗапроса = Неопределено;
		ВыделитьТекстовыйЛитерал(,,,, ТекстЗапроса);
		ПолеТекста.ПолучитьГраницыВыделения(НачальнаяСтрокаЗапроса, НачальнаяКолонкаЗапроса, , );
		НачальнаяСтрокаЗапроса = НачальнаяСтрокаЗапроса - 1;  
		НачальнаяКолонкаЗапроса = НачальнаяСтрокаЗапроса - 1;
		Если ТекстЗапроса <> Неопределено Тогда
			Если Прав(ТекстЗапроса, 1) <> """" Тогда
				ТекстЗапроса = ТекстЗапроса + """";
			КонецЕсли; 
			ТекстЗапроса = Вычислить(ТекстЗапроса);
			ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "|", "");
		Иначе
			ТекстЗапроса = "";
		КонецЕсли;
	КонецЕсли;
	Если ИспользуемСобственныйКонструктор Тогда
		Парсер = мПлатформа.мПолучитьПарсер("ГрамматикаЯзыкаЗапросов");
		Если Парсер = Неопределено Тогда
			ирОбщий.СообщитьСУчетомМодальностиЛкс("Компонента анализа текста запроса не подключена");
			Возврат Ложь;
		КонецЕсли; 
	КонецЕсли; 
	Если Не ПустаяСтрока(ТекстЗапроса) Тогда
		Если ИспользуемСобственныйКонструктор Тогда
			РезультатРазбора = ЗагрузитьТекстВКонструктор(ТекстЗапроса, КонструкторЗапроса,, мДиалектSQL,, НачальнаяСтрокаЗапроса);
			Если Не РезультатРазбора Тогда
				Возврат Ложь;
			КонецЕсли; 
		Иначе
			СтруктуруРезультатаПакетногоЗапроса = мПлатформа.СтруктураРезультатаПакетногоЗапроса(ТекстЗапроса);
			Если СтруктуруРезультатаПакетногоЗапроса.Количество() > 0 Тогда
				Ответ = Вопрос("В комментариях обнаружены имена запросов. Стандартный конструктор запросов их удалит. Продолжить?", РежимДиалогаВопрос.ОКОтмена);
				Если Ответ <> КодВозвратаДиалога.ОК Тогда
					Возврат Ложь;
				КонецЕсли;
			КонецЕсли; 
			Попытка
				КонструкторЗапроса.Текст = ТекстЗапроса;
			Исключение
				ФормаВладелец.ТекущийЭлемент = ПолеТекста.ЭлементФормы;
				ирКлиент.ПоказатьОшибкуВТекстеПрограммыЛкс(ПолеТекста, НачальнаяСтрокаЗапроса, НачальнаяКолонкаЗапроса, Истина,, ИнформацияОбОшибке());
				Возврат Ложь;
			КонецПопытки;
		КонецЕсли; 
	Иначе
		Если ИспользуемСобственныйКонструктор Тогда
			//КонструкторЗапроса.УстановитьДиалектSQL(мДиалектSQL);
			КонструкторЗапроса.УстановитьДанные();  
		КонецЕсли; 
	КонецЕсли;
	РезультатФормы = КонструкторЗапроса.ОткрытьМодально();
	Если РезультатФормы = Истина Тогда
		Если Не РежимТолькоПросмотр Тогда
			НовыйТекстЗапроса = КонструкторЗапроса.Текст;
			Если Истина
				И ТипЗнч(Конфигурация) = Тип("Неопределено")
				И ТипЗнч(КонтекстВыполнения) = Тип("Запрос") 
			Тогда
				НовыйТекстЗапроса = мПлатформа.РазмаскироватьВременныеТаблицы(НовыйТекстЗапроса, МассивВременныхТаблиц);
			КонецЕсли;
			Если ЯзыкПрограммы = 1 Тогда
				Если Не ЭтоЧастичныйЗапрос И НачальнаяСтрокаЗапроса = 0 Тогда 
					ВыделитьВесьТекст();
				КонецЕсли; 
				//Если ОбрамитьСобранныйТекстСкобками Тогда
				//	НовыйТекстЗапроса = "(" + НовыйТекстЗапроса + ")";
				//КонецЕсли; 
				Если ИспользуемСобственныйКонструктор Тогда
					ЗаменитьВыделенныйТекстЗапросаСоСнятиемВыделения(НовыйТекстЗапроса, КонструкторЗапроса.мНомерТекущейСтрокиВСобранномТексте);
				Иначе
					ВыделенныйТекст(НовыйТекстЗапроса);
				КонецЕсли; 
				ПослеУстановкиВыделенногоМногострочногоТекста();
			Иначе
				НовыйТекстЗапроса = ирОбщий.ТекстВВыражениеВстроенногоЯзыкаЛкс(НовыйТекстЗапроса);
				ЧислоСтрокЗамены = СтрЧислоСтрок(НовыйТекстЗапроса);
				ТекстовыйДокумент = Новый ТекстовыйДокумент;
				ТекстовыйДокумент.УстановитьТекст(НовыйТекстЗапроса);
				СдвинутыйТекст = ТекстовыйДокумент.ПолучитьСтроку(1);
				ЗаменаТабуляции = ирОбщий.СтрокаПовторомЛкс(" ", мШиринаТабуляции);
				ТекстНачальнойСтроки = ПолеТекста.ПолучитьСтроку(мНачальнаяСтрока);
				ДлинаНачалаСтроки = СтрДлина(ТекстНачальнойСтроки) - СтрДлина(СокрЛ(ТекстНачальнойСтроки));
				НачалоСтроки = Лев(ТекстНачальнойСтроки, ДлинаНачалаСтроки);
				ДлинаРазвернутогоНачалаСтроки = СтрДлина(СтрЗаменить(НачалоСтроки, Символы.Таб, ЗаменаТабуляции));
				ЧислоТабуляций = ДлинаРазвернутогоНачалаСтроки / мШиринаТабуляции;
				ЧислоПробелов  = ДлинаРазвернутогоНачалаСтроки % мШиринаТабуляции;
				НачалоНовойСтроки = ирОбщий.СтрокаПовторомЛкс(Символы.Таб, ЧислоТабуляций);
				НачалоНовойСтроки = НачалоНовойСтроки + ирОбщий.СтрокаПовторомЛкс(" ", ЧислоПробелов);
				Для Счетчик = 2 По ЧислоСтрокЗамены Цикл
					ТекущаяСтрокаВставки = ТекстовыйДокумент.ПолучитьСтроку(Счетчик);
					СдвинутыйТекст = СдвинутыйТекст + Символы.ПС + НачалоНовойСтроки + ТекущаяСтрокаВставки;
				КонецЦикла;
				ВыделенныйТекст(СдвинутыйТекст);
				ПослеУстановкиВыделенногоМногострочногоТекста();
			КонецЕсли;
			Возврат Истина;
		КонецЕсли;
	КонецЕсли;
	Возврат Ложь;

КонецФункции

Функция РедактироватьВКонсолиЗапросов() Экспорт

	#Если Сервер И Не Сервер Тогда
		мПлатформа = Обработки.ирПлатформа.Создать();
	#КонецЕсли
	РежимТолькоПросмотр = Ложь
		Или ПолеТекста.ТолькоПросмотр()
		Или ФормаВладелец.ТолькоПросмотр;
	Если РежимТолькоПросмотр Тогда
		Ответ = Вопрос("Текст запроса не может быть изменен. Открыть консоль без возможности применения изменений?",
			РежимДиалогаВопрос.ОКОтмена);
		Если Ответ = КодВозвратаДиалога.Отмена Тогда
			Возврат Ложь;
		КонецЕсли;
	КонецЕсли;
	Текст = ПолеТекста.ПолучитьТекст();
	ВыделениеДвумерное = ПолеТекста.ВыделениеДвумерное();
	ПараметрыДляКонсоли = Новый ТаблицаЗначений;
	ПараметрыДляКонсоли.Колонки.Добавить("ИмяПараметра");
	ПараметрыДляКонсоли.Колонки.Добавить("Значение");
	ПараметрыДляКонсоли.Колонки.Добавить("ТипЗначения");
	СсылкаСтрокиМодуля = Неопределено;
	Если Истина
		И мМенеджерВременныхТаблиц <> Неопределено
		И мМенеджерВременныхТаблиц.ПакетыЗапросов.Количество() > 0 
	Тогда
		ПакетЗапросов = мМенеджерВременныхТаблиц.ПакетыЗапросов[мМенеджерВременныхТаблиц.ПакетыЗапросов.ВГраница()];
		Для Каждого КлючИЗначение Из ПакетЗапросов.Параметры Цикл
			СтрокаПараметра = ПараметрыДляКонсоли.Добавить();
			СтрокаПараметра.ИмяПараметра = КлючИЗначение.Ключ;
			ОписаниеТипов = Неопределено; // ОписаниеТипов
			ЗначениеПараметра = мПлатформа.ПодготовитьЗначениеПараметраЗапроса(КлючИЗначение.Значение, ОписаниеТипов);
			СтрокаПараметра.ТипЗначения = ОписаниеТипов;
			СтрокаПараметра.Значение = ЗначениеПараметра;
		КонецЦикла;
		ТекстИмитаторов = ТекстИмитаторовВременныхТаблиц();
		Если ЗначениеЗаполнено(ТекстИмитаторов) Тогда
			Запрос = Новый Запрос(ТекстИмитаторов);
			Запрос.МенеджерВременныхТаблиц = Новый МенеджерВременныхТаблиц;
			Запрос.Выполнить();
			Запрос.Текст = "";
		КонецЕсли;
	КонецЕсли; 
	Если Истина
		И мПлатформа.РедактироватьЗапрос(Текст, ПараметрыДляКонсоли,,,, ВыделениеДвумерное, Запрос)
		И Не РежимТолькоПросмотр 
	Тогда
		ВыделитьВесьТекст();
		ВыделенныйТекст(Текст);
		ПолеТекста.УстановитьВыделениеДвумерное(ВыделениеДвумерное);
		ПослеУстановкиВыделенногоМногострочногоТекста();
		Возврат Истина;
	КонецЕсли;
	Возврат Ложь;

КонецФункции

Функция ТекстИмитаторовВременныхТаблиц(Знач МенеджерВременныхТаблиц = Неопределено, Знач ТекстОсновногоЗапроса = "") Экспорт
	Если МенеджерВременныхТаблиц = Неопределено Тогда
		МенеджерВременныхТаблиц = мМенеджерВременныхТаблиц;
	КонецЕсли;
	ТекстыЗапросов = Новый СписокЗначений;
	Для ИндексПакета = 2 - МенеджерВременныхТаблиц.ПакетыЗапросов.Количество() По 0 Цикл // Обратный обход с предпоследнего
		ПакетЗапросов = МенеджерВременныхТаблиц.ПакетыЗапросов[-ИндексПакета];
		ПодготовитьПакетЗапросов(ПакетЗапросов);
		Для ИндексВПакетеОбратный = 1 - ПакетЗапросов.ТекстыЗапросов.Количество() По 0 Цикл
			ИндексВПакете = ПакетЗапросов.ТекстыЗапросов.ВГраница() + ИндексВПакетеОбратный;
			ИмяВременнойТаблицы = ПакетЗапросов.Структура[ИндексВПакете].Представление;
			Если Ложь
				Или Не ЗначениеЗаполнено(ИмяВременнойТаблицы) 
				Или ТекстыЗапросов.НайтиПоЗначению(НРег(ИмяВременнойТаблицы)) <> Неопределено
			Тогда
				Продолжить;
			КонецЕсли;
			ПостроительЗапроса = мПлатформа.ПостроительПакетаЗапросовДоИндекса(ПакетЗапросов.ТекстыЗапросов, ИндексВПакете, ПакетЗапросов.Параметры, ИмяВременнойТаблицы, МенеджерВременныхТаблиц); 
			ТекстыЗапросов.Добавить(НРег(ИмяВременнойТаблицы), ирОбщий.ЗапросИмитаторКоллекцииПолейЛкс(ПостроительЗапроса.ДоступныеПоля) + Символы.ПС + "ПОМЕСТИТЬ " + ИмяВременнойТаблицы);
		КонецЦикла;
	КонецЦикла; 
	Если ЗначениеЗаполнено(ТекстОсновногоЗапроса) Тогда
		ТекстыЗапросов.Добавить(, ТекстОсновногоЗапроса);
	КонецЕсли;
	ТекстИмитаторов = ирОбщий.СтрСоединитьЛкс(ТекстыЗапросов, ";" + Символы.ПС,,,, "Представление");
	Возврат ТекстИмитаторов;
КонецФункции

Функция РедактироватьВКонсолиКода() Экспорт

	РежимТолькоПросмотр = Ложь
		Или ПолеТекста.ТолькоПросмотр()
		Или ФормаВладелец.ТолькоПросмотр;
	Если РежимТолькоПросмотр Тогда
		Ответ = Вопрос("Текст запроса не может быть изменен. Открыть консоль без возможности применения изменений?",
			РежимДиалогаВопрос.ОКОтмена);
		Если Ответ = КодВозвратаДиалога.Отмена Тогда
			Возврат Ложь;
		КонецЕсли;
	КонецЕсли;
	ФормаКонсоли = ирКлиент.ПолучитьФормуЛкс("Обработка.ирКонсольКода.Форма", , , Новый УникальныйИдентификатор);
	ФормаКонсоли.мРежимРедактора = Истина;
	ФормаКонсоли.ПараметрТекст = ПолеТекста.ПолучитьТекст();
	Если Истина
		И ФормаКонсоли.ОткрытьМодально() <> Неопределено 
		И Не РежимТолькоПросмотр 
	Тогда
		ВыделитьВесьТекст();
		ВыделенныйТекст(ФормаКонсоли.РезультатФормы.Текст);
		ПослеУстановкиВыделенногоМногострочногоТекста();
		Возврат Истина;
	КонецЕсли;
	Возврат Ложь;

КонецФункции

Процедура ЗаменитьВыделенныйТекстЗапросаСоСнятиемВыделения(Знач НовыйТекстЗапроса, Знач НомерТекущейСтрокиВСобранномТексте = 0)
	
	ПолучитьНомерТекущейСтроки();
	ВыделенныйТекст(НовыйТекстЗапроса);
	мНачальнаяСтрока = мНачальнаяСтрока + НомерТекущейСтрокиВСобранномТексте; 
	мНачальнаяКолонка = 1;
	мКонечнаяСтрока = мНачальнаяСтрока;
	мКонечнаяКолонка = мНачальнаяКолонка;

КонецПроцедуры

Процедура ПоказатьТекущиеКоординаты(ПолеТекста, СтартоваяСтрокаДляОтображенияОшибок = 0)

	#Если Сервер И Не Сервер Тогда
		ПолеТекста = Обработки.ирОболочкаПолеТекста.Создать();
	#КонецЕсли
	Если ФормаВладелец = Неопределено Тогда
		Возврат;
	КонецЕсли;
	// Антибаг платформы 8.1 . Терялся фокус
	ФормаВладелец.ТекущийЭлемент = ПолеТекста.ЭлементФормы;
	ПолеТекста.ПоказатьОшибку(мПарсер.CurrentLineNumber() + СтартоваяСтрокаДляОтображенияОшибок, мПарсер.CurrentColumnNumber(), ФормаВладелец);

КонецПроцедуры

Функция ПолучитьКоординатыВТекстеЗапроса(ПолеТекста, СтартоваяСтрокаДляОтображенияОшибок = 0)
	
	НомерСтроки = СтартоваяСтрокаДляОтображенияОшибок + мПарсер.CurrentLineNumber();
	Результат = "";
	Если ПолеТекста <> Неопределено Тогда
		Результат = Результат + ирОбщий.ПредставлениеИзИдентификатораЛкс(ПолеТекста.ЭлементФормы.Имя) + ": ";
	КонецЕсли; 
	Результат = Результат + "Строка " + НомерСтроки + ": {(" + НомерСтроки + "," + мПарсер.CurrentColumnNumber() + ")}: ";
	Возврат Результат;
		
КонецФункции

Функция ПолучитьСтрокуОжидаемыхТокенов()

	СтрокаОжидаемыхТокенов = "";
	Для й = 0 по мПарсер.TokenCount() - 1 Цикл
		Токен = мПарсер.Tokens(й);
		СтрокаОжидаемыхТокенов = СтрокаОжидаемыхТокенов + ", " + Токен.Text;
	КонецЦикла;
	Возврат Сред(СтрокаОжидаемыхТокенов, 3);

КонецФункции

Функция ПолучитьТекстИзТокена(Токен, выхНачальнаяСтрока = 0, выхНачальнаяКолонка = 0, выхКонечнаяСтрока = 0, выхКонечнаяКолонка = 0, Знач СлужебноеПолеТекста = Неопределено) Экспорт

	Если Токен = Неопределено Тогда
		Возврат "";
	КонецЕсли; 
	НачальныйТокен = Токен.GetBorderToken(0);
	Если НачальныйТокен = Неопределено Тогда
		Возврат "";
	КонецЕсли; 
	выхНачальнаяКолонка = НачальныйТокен.ColumnNumber;
	выхНачальнаяСтрока = НачальныйТокен.LineNumber;
	КонечныйТокен = Токен.GetBorderToken(1);
	Если КонечныйТокен = Неопределено Тогда
		Возврат "";
	КонецЕсли; 
	выхКонечнаяКолонка = КонечныйТокен.ColumnNumber + СтрДлина(КонечныйТокен.Data);
	выхКонечнаяСтрока = КонечныйТокен.LineNumber + СтрЧислоСтрок(КонечныйТокен.Data) - 1; 
	Если СлужебноеПолеТекста = Неопределено Тогда
		СлужебноеПолеТекста = СлужебноеПолеТекстаДолгое;
	КонецЕсли;
	СлужебноеПолеТекста.УстановитьГраницыВыделения(выхНачальнаяСтрока, выхНачальнаяКолонка, выхКонечнаяСтрока, выхКонечнаяКолонка);
	ТекстОпределения = СлужебноеПолеТекста.ВыделенныйТекст;
	ТекстОпределения = СокрЛП(ТекстОпределения);
	Возврат ТекстОпределения;

КонецФункции

Функция ЗагрузитьТекстВКонструктор(ТекстЗапроса = Неопределено, Знач КонструкторЗапроса = Неопределено, Знач СокращенноеДерево = Ложь, ДиалектSQL = Неопределено,
	ИменованныеПараметры = Неопределено, СтартоваяСтрокаДляОтображенияОшибок = 0) Экспорт
	
	Если ТекстЗапроса = Неопределено Тогда
		ТекстЗапроса = ПолеТекста.ПолучитьТекст();
	КонецЕсли;
	Если КонструкторЗапроса <> Неопределено Тогда
		КонструкторЗапроса.УстановитьДиалектSQL(ДиалектSQL, ИменованныеПараметры);
	КонецЕсли; 
	ТаблицаКомментариев = Неопределено;
	БылиПотери = Неопределено;
	НачальныйТокен = РазобратьТекстЗапроса(ТекстЗапроса, СокращенноеДерево,,, Истина, ТаблицаКомментариев, БылиПотери, СтартоваяСтрокаДляОтображенияОшибок);
	Если Истина
		И НачальныйТокен <> Неопределено
		И КонструкторЗапроса <> Неопределено 
	Тогда
		КонструкторЗапроса.СлужебноеПолеТекстаДолгое.УстановитьТекст(ТекстЗапроса);
		Если ДиалектSQL = Неопределено Тогда
			ДиалектSQL = мДиалектSQL;
		КонецЕсли; 
		КонструкторЗапроса.ЗапросыПакета.Очистить();
		КонструкторЗапроса.УстановитьДанные(НачальныйТокен, ТаблицаКомментариев, БылиПотери,, ПолучитьНомерТекущейСтроки());
	КонецЕсли;
	Возврат НачальныйТокен <> Неопределено;
	
КонецФункции

// Возвращает начальный токен (Структура) построенной структуры запроса.
//
// Параметры:
//  ТекстЗапроса						 - 	 - 
//  СокращенноеДерево					 - 	 - 
//  ОбновлятьСостояние					 - 	 - 
//  пПолеТекста							 - ОбработкаОбъект.ирПолеТекста, Неопределено, Null - при Неопределено будет использоваться связанное поле, при Null поле не будет использоваться
//  СообщатьОПропущенныхТерминалах		 - 	 - 
//  выхТаблицаКомментариев				 - 	 - 
//  выхБылиПотери						 - 	 - 
//  СтартоваяСтрокаДляОтображенияОшибок	 - 	 - 
// 
// Возвращаемое значение:
//   - 
//
Функция РазобратьТекстЗапроса(ТекстЗапроса, СокращенноеДерево = Ложь, ОбновлятьСостояние = Истина, Знач пПолеТекста = Неопределено, СообщатьОПропущенныхТерминалах = Ложь, выхТаблицаКомментариев = Неопределено,
	выхБылиПотери = Неопределено, СтартоваяСтрокаДляОтображенияОшибок = 0, Знач ПоказыватьОшибки = Истина) Экспорт 

	#Если Сервер И Не Сервер Тогда
	    мПлатформа = Обработки.ирПлатформа.Создать();
	#КонецЕсли
	мПарсер = мПлатформа.мПолучитьПарсер("ГрамматикаЯзыкаЗапросов");
	Если мПарсер = Неопределено Тогда
		Возврат Неопределено;
	КонецЕсли;
	Если пПолеТекста = Null Тогда
		пПолеТекста = Неопределено;
	ИначеЕсли пПолеТекста = Неопределено Тогда
		пПолеТекста = ПолеТекста;
	Иначе
		пПолеТекста = ирКлиент.ОболочкаПоляТекстаЛкс(пПолеТекста);
	КонецЕсли; 
	Если ОбновлятьСостояние Тогда
		ирОбщий.СостояниеЛкс("Синтаксический разбор...");
	КонецЕсли; 
	выхТаблицаКомментариев = Новый ТаблицаЗначений;
	выхТаблицаКомментариев.Колонки.Добавить("Позиция", Новый ОписаниеТипов("Число"));
	выхТаблицаКомментариев.Колонки.Добавить("Текст", Новый ОписаниеТипов("Строка"));
	выхТаблицаКомментариев.Колонки.Добавить("ЭтоРасширение", Новый ОписаниеТипов("Булево"));
	gpMsgTokenRead			= 1;
	gpMsgReduction			= 2;
	gpMsgAccept				= 3;
	gpMsgNotLoadedError		= 4;
	gpMsgLexicalError		= 5;
	gpMsgSyntaxError 		= 6;
	gpMsgCommentError		= 7;
	gpMsgInternalError		= 8;
	gpMsgCommentBlockRead	= 9;
	gpMsgCommentLineRead	= 10;
	мПарсер.OpenTextString(ТекстЗапроса + Символы.ПС);
	Закончили = Ложь;
	//ПоследниеТокены = Новый Массив();
	ПоследнееПравилоНеКомментарий = Неопределено;
	TrimReductions = СокращенноеДерево;
	мПарсер.TrimReductions = СокращенноеДерево; // Была Истина
	Пока Не Закончили Цикл 
		ОбработкаПрерыванияПользователя();
		Ответ = мПарсер.Parse();
		Если Истина
			И СокращенноеДерево
			И TrimReductions <> Истина 
		Тогда
			мПарсер.TrimReductions = Истина;
			TrimReductions = Истина;
		КонецЕсли; 
		Если Ложь
			Или Ответ = gpMsgLexicalError 
			Или (Истина // Хотя Builder в этом случае диагностирует лексическую ошибку, этот парсер почему то бесконечно выдает статус 7
				И Ответ = 7 
				И мПарсер.CurrentReduction = Неопределено)
		Тогда
			мПарсер.PopInputToken();
			Закончили = Истина;
			Если ПоказыватьОшибки Тогда
				КоординатыВТекстеЗапроса = ПолучитьКоординатыВТекстеЗапроса(пПолеТекста, СтартоваяСтрокаДляОтображенияОшибок);
				ирОбщий.СообщитьСУчетомМодальностиЛкс(КоординатыВТекстеЗапроса + "Лексическая ошибка!",, СтатусСообщения.Важное);
				Если пПолеТекста <> Неопределено Тогда
					ПоказатьТекущиеКоординаты(пПолеТекста, СтартоваяСтрокаДляОтображенияОшибок);
				КонецЕсли;
			КонецЕсли;
		ИначеЕсли Ответ = gpMsgSyntaxError Тогда
			ТекущийТокен = мПарсер.CurrentToken;
			Если Истина
				И ТекущийТокен.Kind = 1 
				И (Ложь
					Или ТекущийТокен.Name = "MultiCommentLine"
					//Или ТекущийТокен.Name = "ExtensionBlock"
					Или ТекущийТокен.Name = "CommentBlock")
			Тогда
				Если СообщатьОПропущенныхТерминалах Тогда
					КоординатыВТекстеЗапроса = ПолучитьКоординатыВТекстеЗапроса(пПолеТекста, СтартоваяСтрокаДляОтображенияОшибок);
					ирОбщий.СообщитьСУчетомМодальностиЛкс(КоординатыВТекстеЗапроса + "Проигнорирован комментарий """ 
						+ СокрЛП(ТекущийТокен.Data) + """"
						//+ ", ожидается: " + ПолучитьСтрокуОжидаемыхТокенов()
						, , СтатусСообщения.Внимание);
				КонецЕсли; 
				мПарсер.PopInputToken();
			Иначе
				Закончили = Истина;
				Если ПоказыватьОшибки Тогда
					КоординатыВТекстеЗапроса = ПолучитьКоординатыВТекстеЗапроса(пПолеТекста, СтартоваяСтрокаДляОтображенияОшибок);
					ТекстОшибки = КоординатыВТекстеЗапроса + "Синтаксическая ошибка """ 
						+ ТекущийТокен.Data + """"
						+ ", ожидается: " + ПолучитьСтрокуОжидаемыхТокенов();
					ирОбщий.СообщитьСУчетомМодальностиЛкс(ТекстОшибки,, СтатусСообщения.Важное);
					Если пПолеТекста <> Неопределено Тогда
						ПоказатьТекущиеКоординаты(пПолеТекста, СтартоваяСтрокаДляОтображенияОшибок);
					КонецЕсли;
				КонецЕсли;
			КонецЕсли; 
		ИначеЕсли Ответ = gpMsgReduction Тогда
			Если СокращенноеДерево Тогда
				//ИмяПравила = мПарсер.CurrentReduction.ParentRule.RuleNonterminal.Name;
				ИмяПравила = мПарсер.CurrentRuleName();
				Если Ложь // Есть сомнения, что это работает как задумано
					Или ИмяПравила = "Table" 
					Или ИмяПравила = "TableName"
				Тогда
					мПарсер.TrimReductions = Ложь;
					TrimReductions = Ложь;
				КонецЕсли; 
			КонецЕсли; 
		ИначеЕсли Ответ = gpMsgAccept Тогда
			Закончили = Истина;
		ИначеЕсли Ответ = gpMsgCommentError Тогда
		ИначеЕсли Ответ = gpMsgTokenRead Тогда
			Если мПарсер.IsCurrentTokenComment() Тогда
				// Храним 2 последних токена
				ТекущийТокен = мПарсер.CurrentToken;
				ПрочитатьКомментарий(выхТаблицаКомментариев, ТекущийТокен, пПолеТекста, СообщатьОПропущенныхТерминалах, СтартоваяСтрокаДляОтображенияОшибок);
			КонецЕсли; 
		ИначеЕсли Ответ = gpMsgInternalError Тогда
			Закончили = Истина;
		ИначеЕсли Ответ = gpMsgNotLoadedError Тогда
			Закончили = Истина;
		КонецЕсли;
	КонецЦикла;
	Если ОбновлятьСостояние Тогда
		ирОбщий.СостояниеЛкс("");
	КонецЕсли; 
	Если Ответ = gpMsgAccept Тогда
		НачальныйТокен = Новый Структура("Data, LineNumber, ColumnNumber, Name, Kind",, 0, 0, "", 0);
		НачальныйТокен.Data = мПарсер.CurrentReduction; // Reduction {GoldParserForNet.Parser} - Почему то TypeLib не сам видит этот тип
		Возврат НачальныйТокен;
	Иначе
		Возврат Неопределено;
	КонецЕсли; 

КонецФункции

Процедура ПрочитатьКомментарий(Знач выхТаблицаКомментариев, Знач ТекущийТокен, Знач пПолеТекста, Знач СообщатьОПропущенныхТерминалах, Знач СтартоваяСтрокаДляОтображенияОшибок)
	
	ТекстКомментария = СокрЛП(ТекущийТокен.Data);
	МаркерХАРАКТЕРИСТИКИ = "ХАРАКТЕРИСТИКИ";
	ЭтоРасширение = Ложь;
	Если Лев(ТекстКомментария, 1) = "{" Тогда
		ТекстКомментария = Сред(ТекстКомментария, 2, СтрДлина(ТекстКомментария) - 2);
		ЭтоРасширение = мПараметрыДиалектаSQL.Это1С;
	ИначеЕсли Лев(ТекстКомментария, 2) = "//" Тогда
		ТекстКомментария = Сред(ТекстКомментария, 3);
	ИначеЕсли Лев(ТекстКомментария, 2) = "/*" Тогда
		ТекстКомментария = Сред(ТекстКомментария, 3, СтрДлина(ТекстКомментария) - 4);
	КонецЕсли; 
	Если ЭтоРасширение И Лев(ТекстКомментария, СтрДлина(МаркерХАРАКТЕРИСТИКИ)) = МаркерХАРАКТЕРИСТИКИ Тогда
		выхБылиПотери = Истина;
		Если СообщатьОПропущенныхТерминалах Тогда
			КоординатыВТекстеЗапроса = ПолучитьКоординатыВТекстеЗапроса(пПолеТекста, СтартоваяСтрокаДляОтображенияОшибок);
			ирОбщий.СообщитьСУчетомМодальностиЛкс(КоординатыВТекстеЗапроса + "Проигнорирован комментарий """ 
			+ СокрЛП(ТекущийТокен.Data) + """"
			//+ ", ожидается: " + ПолучитьСтрокуОжидаемыхТокенов()
			, , СтатусСообщения.Внимание);
		КонецЕсли; 
	ИначеЕсли ЗначениеЗаполнено(ТекстКомментария) Тогда 
		СтрокаРасширения = выхТаблицаКомментариев.Добавить();
		СтрокаРасширения.ЭтоРасширение = ЭтоРасширение;
		СтрокаРасширения.Позиция = ПолучитьОтносительнуюПозициюТокена(ТекущийТокен);
		СтрокаРасширения.Текст = ТекстКомментария; // Убираем крайние фигурные скобки
	КонецЕсли;

КонецПроцедуры

Функция ПолучитьОтносительнуюПозициюТокена(Токен) Экспорт 
	
	Результат = Токен.LineNumber * 1000 + Токен.ColumnNumber;
	Возврат Результат;
	
КонецФункции

// Вызывает конструктор запросов и передает ему текст из текстового поля.
// 
// Возвращаемое значение:
//   Булево - признак изменения текста
//
Функция ОткрытьРедакторСтроковогоЛитерала() Экспорт

	Если ирОбщий.ПроверитьПлатформаНеWindowsЛкс(,, Истина) Тогда
		Возврат Ложь;
	КонецЕсли; 
	РежимТолькоПросмотр = Ложь
		Или ПолеТекста.ТолькоПросмотр()
		Или ФормаВладелец <> Неопределено И ФормаВладелец.ТолькоПросмотр;
	Если РежимТолькоПросмотр Тогда
		Ответ = Вопрос("Текст не может быть изменен. Открыть редактор без возможности сохранения измений?",
			РежимДиалогаВопрос.ОКОтмена);
		Если Ответ = КодВозвратаДиалога.Отмена Тогда
			Возврат Ложь;
		КонецЕсли;
	КонецЕсли; 
	#Если Сервер И Не Сервер Тогда
		ПолеТекста = Обработки.ирОболочкаПолеТекста.Создать();
	#КонецЕсли   
	РазобратьТекущийКонтекст(,,,,, Истина,, Истина);
	ФормаРедактора = мПлатформа.ПолучитьФорму("Текст", , Новый УникальныйИдентификатор);
	ПараметрГраницыВыделения = ПолеТекста.ВыделениеДвумерное();
	ФормаРедактора.ПараметрГраницыВыделения = ПараметрГраницыВыделения;
	ТекстСтроковогоЛитерала = ВыделитьТекстовыйЛитерал(,,,,, Ложь);
	СмещениеКолонки = Найти(ПолеТекста.ПолучитьСтроку(ПараметрГраницыВыделения.НачальнаяСтрока), "|");
	Если СмещениеКолонки > 0 Тогда
		ПараметрГраницыВыделения.НачальнаяКолонка = Макс(1, ПараметрГраницыВыделения.НачальнаяКолонка - СмещениеКолонки);
		ПараметрГраницыВыделения.КонечнаяКолонка = Макс(1, ПараметрГраницыВыделения.КонечнаяКолонка - СмещениеКолонки);
	КонецЕсли;
	ГраницыЛитерала = ПолеТекста.ВыделениеДвумерное();
	Если ФормаВладелец = Неопределено Тогда
		мЗаменяемыйДиапазон = ПолеТекста.ВыделениеОдномерное();
	КонецЕсли;
	ПараметрГраницыВыделения.НачальнаяСтрока = ПараметрГраницыВыделения.НачальнаяСтрока - ГраницыЛитерала.НачальнаяСтрока + 1;
	ПараметрГраницыВыделения.КонечнаяСтрока = ПараметрГраницыВыделения.КонечнаяСтрока - ГраницыЛитерала.НачальнаяСтрока + 1;
	ФормаРедактора.НачальноеЗначениеВыбора = ТекстСтроковогоЛитерала;
	Если ПустаяСтрока(ТекстСтроковогоЛитерала) Тогда
		ФормаРедактора.ВариантПросмотра = "ЯзыкЗапросов";
	КонецЕсли;
	ФормаРедактора.мМенеджерВременныхТаблиц = мМенеджерВременныхТаблиц;
	ТекстИзменен = Ложь;
	Если ФормаРедактора.ОткрытьМодально() <> Неопределено Тогда
		Если Не РежимТолькоПросмотр Тогда
			НовыйТекст = ФормаРедактора.Текст; 
			Если НовыйТекст = ТекстСтроковогоЛитерала Тогда
				// Для TuboConf
			Иначе
				НовыйТекст = ирОбщий.ТекстВВыражениеВстроенногоЯзыкаЛкс(НовыйТекст);
				ЗаменаТабуляции = ирОбщий.СтрокаПовторомЛкс(" ", мШиринаТабуляции);
				ТекстНачальнойСтроки = ПолеТекста.ПолучитьСтроку(мНачальнаяСтрока);
				ДлинаНачалаСтроки = СтрДлина(ТекстНачальнойСтроки) - СтрДлина(СокрЛ(ТекстНачальнойСтроки));
				НачалоСтроки = Лев(ТекстНачальнойСтроки, ДлинаНачалаСтроки);
				ДлинаРазвернутогоНачалаСтроки = СтрДлина(СтрЗаменить(НачалоСтроки, Символы.Таб, ЗаменаТабуляции));
				ЧислоТабуляций = ДлинаРазвернутогоНачалаСтроки / мШиринаТабуляции;
				ЧислоПробелов  = ДлинаРазвернутогоНачалаСтроки % мШиринаТабуляции;
				НачалоНовойСтроки = ирОбщий.СтрокаПовторомЛкс(Символы.Таб, ЧислоТабуляций);
				НачалоНовойСтроки = НачалоНовойСтроки + ирОбщий.СтрокаПовторомЛкс(" ", ЧислоПробелов);
				НовыйТекст = СтрЗаменить(НовыйТекст, Символы.ПС, Символы.ПС + НачалоНовойСтроки);
				ВыделенныйТекст(НовыйТекст);
				ГраницыВыделенияНовые = ФормаРедактора.ПараметрГраницыВыделения;
				мНачальнаяСтрока = ГраницыВыделенияНовые.НачальнаяСтрока + ГраницыЛитерала.НачальнаяСтрока - 1;
				мКонечнаяСтрока = ГраницыВыделенияНовые.КонечнаяСтрока + ГраницыЛитерала.НачальнаяСтрока - 1;
				мНачальнаяКолонка = ГраницыВыделенияНовые.НачальнаяКолонка;
				мКонечнаяКолонка = ГраницыВыделенияНовые.КонечнаяКолонка;
				ТекстИзменен = Истина;
				Если ФормаВладелец = Неопределено Тогда
					мЗамещающийФрагмент = НовыйТекст;
				КонецЕсли;
			КонецЕсли;
		КонецЕсли;
	КонецЕсли;
	УстановитьГраницыВыделения();
	Возврат ТекстИзменен;

КонецФункции

Функция ОткрытьМодульВГите() Экспорт
	ПапкаГита = ГитРепозиторий();
	Если Не ЗначениеЗаполнено(ПапкаГита) Тогда
		ирКлиент.ОткрытьНастройкиПоляТекстаПрограммыНаЗаднемПланеЛкс("Укажите ""Гит репозиторий"" в открывшейся форме настроек");
		Возврат Ложь;
	КонецЕсли;
	ЛиМножественное = Истина;
	Фрагменты = ирОбщий.СтрРазделитьЛкс(мИмяМодуля);
	ИмяФайлаМодуляВГите = "src";
	Разделитель = ирОбщий.РазделительПутиКФайлуЛкс();
	ПроверочныйФайл = Новый Файл(ПапкаГита + Разделитель + ИмяФайлаМодуляВГите + Разделитель + "Configuration.xml");
	ЭтоЕДТ = Не ПроверочныйФайл.Существует();
	ЭтоФорма = Ложь;
	Если Фрагменты.Количество() = 1 Тогда
		ИмяФайлаМодуляВГите = "Ext" + Разделитель + Фрагменты[0];
	Иначе
		Для Индекс = 0 По Фрагменты.Количество() / 2 - 1 Цикл
			ИмяРус = Фрагменты[Индекс * 2];
			ИмяАнг = ирОбщий.ПеревестиИзРусскогоВАнглийскийЛкс(ИмяРус);
			Если ЛиМножественное Тогда
				ИмяАнг = ИмяАнг + "s"; 
			КонецЕсли;
			Если ИмяАнг = Неопределено Тогда
				ИмяАнг = ИмяРус;
			КонецЕсли;
			Если Не ПустаяСтрока(ИмяФайлаМодуляВГите) Тогда
				ИмяФайлаМодуляВГите = ИмяФайлаМодуляВГите + Разделитель;
			КонецЕсли;
			ИмяФайлаМодуляВГите = ИмяФайлаМодуляВГите + ИмяАнг;
			ИмяФайлаМодуляВГите = ИмяФайлаМодуляВГите + Разделитель + Фрагменты[Индекс * 2 + 1];
			Если Истина
				И Фрагменты[Индекс * 2 + 2] = "Форма" 
				И Фрагменты[Индекс * 2 + 3] = "Модуль" 
			Тогда
				ЭтоФорма = Истина;
				Прервать;
			КонецЕсли;
		КонецЦикла; 
	КонецЕсли;
	ИмяСвойстваАнг = Фрагменты[Фрагменты.ВГраница()];
	ИмяАнг = ирОбщий.ПеревестиИзРусскогоВАнглийскийЛкс(ИмяСвойстваАнг);
	Если ИмяАнг <> Неопределено Тогда
		ИмяСвойстваАнг = ИмяАнг;                                
	КонецЕсли;
	Если Не ЭтоЕДТ Тогда
		ИмяФайлаМодуляВГите = ИмяФайлаМодуляВГите + Разделитель + "Ext";
		Если ЭтоФорма Тогда
			ИмяФайлаМодуляВГите = ИмяФайлаМодуляВГите + Разделитель + "Form";
		КонецЕсли;
	КонецЕсли;
	ИмяФайлаМодуляВГите = ПапкаГита + Разделитель + ИмяФайлаМодуляВГите + Разделитель + ИмяСвойстваАнг + ".bsl"; 
	ДопПараметры = "";
	//КопироватьФайл(мПлатформа.ФайлМодуляИзИмениМодуля(мИмяМодуля).ПолноеИмя, ИмяФайлаМодуляВГите); // Затираем файл в рабочем каталоге!
	Команда = "code -g """+ ИмяФайлаМодуляВГите +""":"+XMLСтрока(мНачальнаяСтрока) + " " + ДопПараметры;
	//ирОбщий.ЗапуститьСкрытоеПриложениеИДождатьсяЗавершенияЛкс(Команда);
	КомандаСистемы(Команда); // Так окно везде сразу берет фокус
	Возврат Истина;
КонецФункции

// По текущей позиции, которая хранится в переменной мПозицияВТексте
Функция ВыделитьТекстовыйЛитерал(Знач ПолеТекстаЛ = Неопределено, выхНачальнаяПозиция0 = 0, выхКонечнаяПозиция0 = 0, Знач РазбиратьКонтекст = Истина, выхВыражение = "",
	Знач РазрешитьПотерюКомментариев = Истина) Экспорт 
	
	#Если Сервер И Не Сервер Тогда
		ПолеТекста = Обработки.ирОболочкаПолеТекста.Создать();
	#КонецЕсли
	Если ПолеТекстаЛ = Неопределено Тогда
		ПолеТекстаЛ = ПолеТекста;
	Иначе
		ПолеТекстаЛ = ирКлиент.ОболочкаПоляТекстаЛкс(ПолеТекстаЛ);
	КонецЕсли;
	Если РазбиратьКонтекст Тогда
		РазобратьТекущийКонтекст();
	КонецЕсли;
	ТекстПоля = ПолеТекстаЛ.ПолучитьТекст();
	мРегВыражение.Global = Истина;
	мРегВыражение.MultiLine = Ложь;
	мРегВыражение.Pattern = шЛитералПрограммы;
	Результат = мРегВыражение.НайтиВхождения(ТекстПоля);
	Для Каждого Вхождение Из Результат Цикл
		ПозицияВхождения = Вхождение.FirstIndex;
		Если Истина
			И (ПозицияВхождения + 1) <= мПозицияВТексте 
			И (ПозицияВхождения + Вхождение.Length) >= мПозицияВТексте 
		Тогда
			ПолеТекстаЛ.УстановитьГраницыВыделения(ПозицияВхождения + 1, ПозицияВхождения + 1 + Вхождение.Length,, ФормаВладелец);
			ДиапазонОдномерный = ПолеТекстаЛ.ВыделениеОдномерное();
			Прервать;
		КонецЕсли;
	КонецЦикла;
	Если ДиапазонОдномерный <> Неопределено Тогда
		выхНачальнаяПозиция0 = ДиапазонОдномерный.Начало - 1;
		выхКонечнаяПозиция0 = ДиапазонОдномерный.Конец - 1;
		выхВыражение = ПолеТекстаЛ.ВыделенныйТекст();
		ТекстСтроковогоЛитерала = ирОбщий.ТекстИзВстроенногоЯзыкаЛкс(выхВыражение, РазрешитьПотерюКомментариев);
	Иначе
		ТекстСтроковогоЛитерала = Неопределено;
	КонецЕсли;
	Возврат ТекстСтроковогоЛитерала;

КонецФункции

// Осуществляет переход к определению контекста.
//
// Параметры:
//  Нет.
//
Функция ПерейтиКОпределению(НомерСтроки = 0, НомерКолонки = 0, РазрешитьДиалоги = Истина) Экспорт 
	
	#Если Сервер И Не Сервер Тогда
		ПолеТекста = Обработки.ирОболочкаПолеТекста.Создать();
	#КонецЕсли
	Если ирОбщий.ПроверитьПлатформаНеWindowsЛкс(,, Истина) Тогда
		Возврат Неопределено;
	КонецЕсли;
	мПлатформа.мРежимПереходаКОпределению = Истина;  
	Результат = Новый СписокЗначений;
	ПоследнееВхождение = Неопределено;
	ПоследнееОпределение = Неопределено;
	РазобратьТекущийКонтекст(,,, НомерСтроки, НомерКолонки, Истина);
	Если ЗначениеЗаполнено(мКонтекст) Тогда
		НайтиОпределениеСлова(мКонтекст, ПоследнееОпределение, ПоследнееВхождение);
	КонецЕсли;
	Если мЯзыкПрограммы = 0 Тогда 
		Если Истина
			И ПоследнееВхождение <> Неопределено  
			И Не ирОбщий.СтрКончаетсяНаЛкс(мКонтекст, "(")
		Тогда
			ВыделениеДвумерное = ВыделениеДвумерноеИзПозиции(мПозицияТекстаДляПоискаОпределения + ПоследнееВхождение.FirstIndex + Найти(ПоследнееВхождение.Value, ПоследнееОпределение) - 1 + 1);
			Результат.Добавить(СсылкаСтрокиМодуля(ВыделениеДвумерное.НачальнаяСтрока,, ВыделениеДвумерное.НачальнаяКолонка), "Локальный"); 
		КонецЕсли;
		Если мЭтоТекстовыйЛитерал Тогда
			ЗаполнитьТаблицуСлов(, Ложь);
			СтрокаСлова = ТаблицаСлов.Найти(мКонтекст);
			Если Истина
				И СтрокаСлова <> Неопределено
				И мТаблицаТиповКонтекста[0].СтрокаОписания <> Неопределено
				И мТаблицаТиповКонтекста[0].СтрокаОписания.ТипКонтекста = "ВременныеТаблицыЗапроса"
			Тогда
				ИмяТаблицы = СтрокаСлова.Слово;
				ПакетЗапросов = Неопределено; // см. НовыйПакетЗапросов()
				ИндексЗапроса = Неопределено;
				НайтиЗапросВременнойТаблицы(ИмяТаблицы, мТаблицаТиповКонтекста[0].Метаданные, мТаблицаТиповКонтекста[0].ДержательМетаданных, ИндексЗапроса); 
				Если ИндексЗапроса <> Неопределено Тогда
					ДобавитьПереходыИзСтруктурыТипаВСписокВыбора(мТаблицаТиповКонтекста[0], Результат,, Истина);
				КонецЕсли;
			КонецЕсли;
		КонецЕсли;
		ТаблицаТипов = Неопределено; 
		СтруктураСловаОбъекта = Неопределено;
		Если Ложь
			Или мЭтоТекстовыйЛитерал
			Или ЛиВнутриКомментария()
		Тогда
			ФрагментыИмени = ирОбщий.СтрРазделитьЛкс(мКонтекст);
			Если ФрагментыИмени.Количество() > 1 Тогда
				Если ирОбщий.ЛиКорневойТипМетаданныхЛкс(ФрагментыИмени[0]) Тогда
					ИмяТипаМетаданных = ФрагментыИмени[ФрагментыИмени.ВГраница() - 1];
					Если ирОбщий.СтрокиРавныЛкс(ИмяТипаМетаданных, "ОбщаяФорма") Тогда
						ИмяТипаМетаданных = "Форма";
					КонецЕсли;
					Результат.Добавить(мКонтекст, ИмяТипаМетаданных + " " + ФрагментыИмени[ФрагментыИмени.ВГраница()],, ирКэш.КартинкаПоИмениЛкс("ирМетаданные")); 
					//ИмяМД = мКонтекст;
					//Если Метаданные.НайтиПоПолномуИмени(ИмяМД) = Неопределено Тогда
					//	ИмяМД = ирОбщий.СтрокаБезПоследнегоФрагментаЛкс(ИмяМД);
					//КонецЕсли;
					//Если Метаданные.НайтиПоПолномуИмени(ИмяМД) <> Неопределено Тогда
					//	Если РазрешитьДиалоги Тогда
					//		ирКлиент.ОткрытьОбъектМетаданныхЛкс(ИмяМД);
					//		Возврат Истина;
					//	//Иначе
					//	//	Результат.Добавить(ИмяМД, "Метаданные " + ИмяМД,, ирКэш.КартинкаПоИмениЛкс("ирМетаданные")); 
					//	КонецЕсли;
					//КонецЕсли;
				КонецЕсли;
				ЧастиИмени = ЧастиПолногоИмениЭлементаФормы(мКонтекст);
				Если ЧастиИмени <> Неопределено Тогда
					Попытка
						Форма = ирКлиент.ПассивнаяФормаПоИмениЛкс(ЧастиИмени.ИмяФормы);
					Исключение
						Форма = Неопределено;
					КонецПопытки;
					Если Форма <> Неопределено Тогда
						СтруктураСловаОбъекта = ВычислитьСловоФормыПоПолномуИмени(мКонтекст);
					КонецЕсли; 
				КонецЕсли;
			КонецЕсли;
			Если РазрешитьДиалоги Тогда
				Если СтруктураСловаОбъекта <> Неопределено Тогда 
					Если Прав(мКонтекст, 1) = "(" Тогда
						Если СтруктураСловаОбъекта.СтрокаОписания.ПозицияТела > 0 Тогда
							ирКлиент.ОткрытьМетодМодуляПоОпределениюЛкс(СтруктураСловаОбъекта.СтрокаОписания);
						КонецЕсли;
					Иначе 
						Форма.Открыть();
						ирКлиент.НачатьОтслеживаниеФормыЛкс(Форма);
						Если ЧастиИмени.ИмяФормы <> мКонтекст Тогда 
							Если СтруктураСловаОбъекта <> Неопределено Тогда
								Попытка
									Форма.ТекущийЭлемент = Форма.Элементы[СтруктураСловаОбъекта.Метаданные.Имя];
								Исключение
								КонецПопытки;
								Попытка
									Форма.ТекущийЭлемент = Форма.ЭлементыФормы[СтруктураСловаОбъекта.Метаданные.Имя];
								Исключение
								КонецПопытки;
							КонецЕсли;
						КонецЕсли;
					КонецЕсли;
					Возврат Истина;
				КонецЕсли;
				Если Ложь
					Или Найти(мКонтекст, ".Реквизит.") > 0
					Или Найти(мКонтекст, ".Измерение.") > 0
					Или Найти(мКонтекст, ".Ресурс.") > 0
				Тогда
					ОписаниеТаблицы = ирОбщий.ОписаниеТаблицыБДЛкс(ирОбщий.ПервыеФрагментыЛкс(мКонтекст));
					Если ОписаниеТаблицы <> Неопределено Тогда
						Форма = ирКлиент.ОткрытьКолонкуБДЛкс(ирОбщий.ПервыеФрагментыЛкс(мКонтекст), ирОбщий.ПоследнийФрагментЛкс(мКонтекст));
						Если Форма <> Неопределено Тогда
							Форма.Открыть();
							Возврат Истина;
						КонецЕсли;
					КонецЕсли;
				КонецЕсли;
				КорневоеСловоБД = "БД.";
				Если ирОбщий.СтрНачинаетсяСЛкс(мКонтекст, КорневоеСловоБД) Тогда
					ИмяКолонки = Сред(мКонтекст, СтрДлина(КорневоеСловоБД) + 1);
					Форма = ирКлиент.ОткрытьКолонкуБДЛкс(ИмяКолонки);
					Если Форма <> Неопределено Тогда
						Форма.Открыть();
						Возврат Истина;
					КонецЕсли;
				КонецЕсли;
			КонецЕсли;
			Если Истина
				И СтруктураСловаОбъекта = Неопределено
				И Найти(мКонтекст, "Объект.") > 0 
			Тогда
				ТаблицаТипов = ТаблицаТиповИзТекста("см. " + мКонтекст);
				Если ТаблицаТипов.Количество() > 0 Тогда
					СтруктураСловаОбъекта = ТаблицаТипов[0];
				КонецЕсли;
			КонецЕсли;
			Если СтруктураСловаОбъекта <> Неопределено Тогда 
				ДобавитьПереходыИзСтруктурыТипаВСписокВыбора(СтруктураСловаОбъекта, Результат);
			КонецЕсли;
			ИмяМетода = ирОбщий.ПервыйФрагментЛкс(мКонтекст, "(");
			Если ирОбщий.ЛиИмяПеременнойЛкс(ИмяМетода) Тогда
				МетодМодуля = мПлатформа.СтрокаМетодаМодуляПоИмени(мМодульМетаданных, ИмяМетода);
				Если МетодМодуля <> Неопределено И МетодМодуля.ПозицияТела <> 0 Тогда
					ДобавитьПереходНаСловоМодуляВСписокВыбора(МетодМодуля, Результат);
				КонецЕсли;
			КонецЕсли;
			Если Истина
				И (Ложь
					Или Найти(мКонтекст, "(") = 0 
					Или мЭтоТекстовыйЛитерал)
				И СтрЧислоВхождений(мКонтекст, ".") > 0 
			Тогда 
				Если Истина
					И мМодульМетаданных <> Неопределено 
					И ирОбщий.СтрНачинаетсяСЛкс(мИмяМодуля, "ОбщийМодуль." + ФрагментыИмени[0] + ".") 
				Тогда 
					МетодМодуля = мПлатформа.СтрокаМетодаМодуляПоИмени(мМодульМетаданных, ФрагментыИмени[1]);
					Если МетодМодуля <> Неопределено Тогда
						ПерейтиКОпределениюЛокальногоМетода(МетодМодуля);
						Возврат Истина;
					КонецЕсли;
				КонецЕсли;
				АнализаторКода = ирОбщий.НовыйАнализаторКодаЛкс(0);
				АнализаторКода.УстановитьТекст(); // Для установки динамического модуля
				Выражение = мКонтекст;
				Если Не ирОбщий.СтрКончаетсяНаЛкс(Выражение, "(") Тогда
					Выражение = Выражение + "(";
				КонецЕсли;
				ТаблицаТипов = АнализаторКода.ВычислитьТипЗначенияВыражения(Выражение);
			КонецЕсли;
		КонецЕсли;
		ТаблицаТиповРодителя = ВычислитьТипЗначенияВыражения(мРодительскийКонтекст, мТекстДляПоискаОпределения, мПредшествующийТекст, Истина); 
		Если Не ЗначениеЗаполнено(ТаблицаТипов) Тогда
			ЛиВЗаголовкеМетода = ЛиВЗаголовкеМетода(, Истина);
			Если Ложь
				Или Не ЛиВЗаголовкеМетода 
				Или (Истина
					И ЛиВЗаголовкеМетода
					И (Ложь
						Или Не ЛиВнутриКомментария() 
						Или ирОбщий.СтрНайтиЛкс(мтекущаяСтрокаНачало, "см. ",,,, Ложь) = 0))
			Тогда
				СтрокаПараметра = СтрокаПараметраМетодаМодуля(мКонтекст);
				Если СтрокаПараметра <> Неопределено Тогда
					ПерейтиКОпределениюЛокальногоМетода(мМетодМодуля, СтрокаПараметра.Имя);
					Возврат Истина;
				КонецЕсли;
			КонецЕсли;
			// Заменено на ДобавитьПереходНаСловоМодуляВСписокВыбора()
			//СтрокаПеременной = мМодульМетаданных.Переменные.Найти(НРег(мТекущееСлово), "НИмя");
			//Если СтрокаПеременной <> Неопределено Тогда
			//	Если СтрокаПеременной.ПозицияСОписанием <> 0 Тогда
			//		ПолеТекста.УстановитьГраницыВыделения(СтрокаПеременной.ПозицияСОписанием, СтрокаПеременной.ПозицияСОписанием,,,, ФормаВладелец);
			//		ВыделитьДиапазонОдномерныйДляПользователя(СтрокаПеременной.ПозицияСОписанием, СтрокаПеременной.ПозицияСОписанием + СтрДлина("Перем " + СтрокаПеременной.Имя));
			//	КонецЕсли;
			//	Возврат Истина;
			//КонецЕсли;
			// РазрешитьАнализИмениТипа=Истина нужно для вычисления контекста текстового литерала, например Документы.РеализацияТоваровУслуг.ПолучитьМакет("Ак<>т")
			ТаблицаТипов = ВычислитьТипЗначенияВыражения(мКонтекст, мТекстДляПоискаОпределения, мПредшествующийТекст, Истина); 
			Если Истина
				//И Прав(мКонтекст, 1) <> "("  
				И (Ложь
					Или мЭтоТекстовыйЛитерал
					Или ЛиВнутриКомментария())
				И (Ложь
					Или ТаблицаТипов.Количество() = 0
					Или (Истина
						И ТаблицаТипов[0].Детальность = 0
						И ТаблицаТипов[0].СтрокаОписания = Неопределено))
			Тогда
				ТаблицаТипов = ТаблицаТиповИзПолногоИмениМетодаИлиПараметра(мКонтекст); 
			КонецЕсли;
		КонецЕсли;
		Если ТаблицаТипов <> Неопределено Тогда
			СтруктураТипаРодителя = Неопределено;
			Если ТаблицаТиповРодителя.Количество() > 0 Тогда
				СтруктураТипаРодителя = ТаблицаТиповРодителя[0];
			КонецЕсли;
			Для Каждого СтруктураТипа Из ТаблицаТипов Цикл
				Если РазрешитьДиалоги И ТипЗнч(СтруктураТипа.Метаданные) = Тип("ТабличныйДокумент") Тогда
					ПолноеИмяМакета = "";
					Если ТипЗнч(СтруктураТипа.ДержательМетаданных) = Тип("ОбъектМетаданных") Тогда
						ПолноеИмяМакета = СтруктураТипа.ДержательМетаданных.ПолноеИмя();
					КонецЕсли;
					Область = СтруктураТипа.Метаданные.Области.Найти(мКонтекст);
					Если Область <> Неопределено Тогда
						СтруктураТипа.Метаданные.ТекущаяОбласть = Область;
					КонецЕсли;
					ирКлиент.ОткрытьЗначениеЛкс(СтруктураТипа.Метаданные,,, ПолноеИмяМакета);
					Возврат Истина;
				КонецЕсли;
				ДобавитьПереходыИзСтруктурыТипаВСписокВыбора(СтруктураТипа, Результат, СтруктураТипаРодителя);
			КонецЦикла;
		КонецЕсли;
		Если Истина
			И Лев(СокрЛ(мТекущаяСтрокаНачало), 1) = "&"
			И (Ложь
				Или ирОбщий.СтрокиРавныЛкс(мВызовМетода, "Вместо(") 
				Или ирОбщий.СтрокиРавныЛкс(мВызовМетода, "После(")
				Или ирОбщий.СтрокиРавныЛкс(мВызовМетода, "Перед(")
				Или ирОбщий.СтрокиРавныЛкс(мВызовМетода, "Around(") 
				Или ирОбщий.СтрокиРавныЛкс(мВызовМетода, "After(")
				Или ирОбщий.СтрокиРавныЛкс(мВызовМетода, "Before("))
		Тогда
			Результат.Очистить(); // Удаляем непрямую ссылку
			Результат.Добавить(, "Метод прямой",, ирКэш.КартинкаПоИмениЛкс("ирМетодыМодуля"));
		КонецЕсли;
		ИменаМД = ирОбщий.ИменаМетаданныхИзОписанияТиповЛкс(мКонтекст);
		Для Каждого ЭлементСписка Из ИменаМД Цикл
			ДобавитьТипДанныхВСписокПереходов(ЭлементСписка.Значение, Результат);
		КонецЦикла; 
		ВхожденияГиперСсылок = ирОбщий.НайтиРегВыражениеЛкс(мТекущаяСтрокаНачало + мТекущаяСтрокаКонец, мПлатформа.шГиперСсылка);
		Для Каждого Вхождение Из ВхожденияГиперСсылок Цикл
			Если Истина
				И СтрДлина(мТекущаяСтрокаНачало) >= Вхождение.ПозицияВхождения
				И СтрДлина(мТекущаяСтрокаНачало) <= Вхождение.ПозицияВхождения + Вхождение.ДлинаВхождения
			Тогда
				Результат.Добавить(Вхождение.ТекстВхождения, "ГиперСсылка",, ирКэш.КартинкаПоИмениЛкс("ирHttp"));
				Прервать;
			КонецЕсли;
		КонецЦикла;
		Результат.СортироватьПоПредставлению();
		Если Истина
			И Результат.Количество() = 0 
			И Прав(мКонтекст, 1) = "(" 
			И ПустаяСтрока(мРодительскийКонтекст)
			И СтруктураТипа = Неопределено
		Тогда
			Если РазрешитьДиалоги Тогда
				ОткрытьКонструкторИзВызоваМетода();
			Иначе
				Результат.Добавить(, "Создать метод");
			КонецЕсли;
		Иначе
			Если РазрешитьДиалоги Тогда
				ВыбратьПереход(Результат);
			Иначе
				Если Результат.Количество() = 0 Тогда
					СтруктураСсылки = ирОбщий.СтруктураСсылкиСтрокиМодуляЛкс(мТекущаяСтрокаНачало);
					Если СтруктураСсылки <> Неопределено Тогда
						Результат.Добавить(СтруктураСсылки.ТекстСсылки); 
					КонецЕсли;
				КонецЕсли;
			КонецЕсли;
		КонецЕсли;
	ИначеЕсли мЯзыкПрограммы = 1 Тогда 
		Если ПоследнееВхождение <> Неопределено Тогда
			ЗапомнитьИсточникПерехода();
			Если ирОбщий.СтрКончаетсяНаЛкс(мКонтекст, "(") И мЯзыкПрограммы = 0 Тогда
				НачальнаяПозицияОпределения = 0;
			Иначе
				НачальнаяПозицияОпределения = мПозицияТекстаДляПоискаОпределения;
			КонецЕсли;
			НачальнаяПозицияОпределения = НачальнаяПозицияОпределения + ПоследнееВхождение.FirstIndex + Найти(ПоследнееВхождение.Value, ПоследнееОпределение);
			КонечнаяПозицияОпределения = НачальнаяПозицияОпределения + СтрДлина(ПоследнееОпределение);
			ВыделитьДиапазонОдномерныйДляПользователя(НачальнаяПозицияОпределения, КонечнаяПозицияОпределения);
			Результат = Истина;
		Иначе 
			ОписаниеТаблицыБД = ирОбщий.ОписаниеТаблицыБДЛкс(мКонтекст);
			Если ОписаниеТаблицыБД <> Неопределено Тогда
				ирКлиент.ОткрытьОбъектМетаданныхЛкс(ОписаниеТаблицыБД.ПолноеИмяМД);
				Результат = ОписаниеТаблицыБД.ПолноеИмяМД;
			Иначе
				ТаблицаТиповКонтекста = ВычислитьТипЗначенияВыражения(мРодительскийКонтекст, " " + мТекстДляПоискаОпределения, мПредшествующийТекст, Истина);
				Если ТаблицаТиповКонтекста.Количество() > 0 Тогда
					СтруктураТипаКонтекста = ТаблицаТиповКонтекста[0];
					ИмяТаблицы = мПлатформа.ИмяТипаИзСтруктурыТипа(СтруктураТипаКонтекста);
					ОписаниеТаблицыБД = ирОбщий.ОписаниеТаблицыБДЛкс(ИмяТаблицы);
					Если ОписаниеТаблицыБД <> Неопределено Тогда
						Если ОписаниеТаблицыБД.Тип = "ВиртуальнаяТаблица" Тогда
							ИмяТаблицы = ирОбщий.СтрокаБезПоследнегоФрагментаЛкс(ИмяТаблицы);
						КонецЕсли;
						ФормаКолонки = ирКлиент.ОткрытьКолонкуБДЛкс(ИмяТаблицы, мТекущееСлово);
						Если ФормаКолонки <> Неопределено Тогда
							Если Не РазрешитьДиалоги Тогда
								ФормаКолонки.Закрыть();
								Результат.Добавить(ИмяТаблицы + "." + ФормаКолонки.РолиПоля + "." + мТекущееСлово, "_Реквизит МД"); // "_" добавил чтобы всегда первым шло после сортировки
								Результат.Добавить(ИмяТаблицы + "." + мТекущееСлово, "Колонка БД");
							КонецЕсли;
						КонецЕсли;
					КонецЕсли;
				КонецЕсли;
			КонецЕсли;
		КонецЕсли;
	КонецЕсли;
	Если Истина
		И Не РазрешитьДиалоги
		И ТипЗнч(Результат) = Тип("СписокЗначений")
		И Результат.Количество() = 0 
	Тогда 
		//Результат.Добавить(мКонтекст); // Вредно, т.к. Турбоконф будет несколько секунд думать на непонятной ссылке
		Результат.Добавить("*"); 
	КонецЕсли;
	Возврат Результат;

КонецФункции

Функция СтрокаПараметраМетодаМодуля(Знач ИмяПараметра, Знач МетодМодуля = Неопределено) Экспорт
	Если МетодМодуля = Неопределено Тогда
		МетодМодуля = мМетодМодуля;
	КонецЕсли;
	ПараметрыМетода = мПлатформа.ПараметрыМетодаМодуля(МетодМодуля);
	СтрокаПараметра = Неопределено;
	Если ПараметрыМетода <> Неопределено Тогда
		СтрокаПараметра = ПараметрыМетода.Найти(НРег(ИмяПараметра), "НИмя");
	КонецЕсли;
	Возврат СтрокаПараметра;
КонецФункции

Функция ПолноеИмяМетода(Знач СтрокаМетода = Неопределено, Знач РазрешитьЛокальное = Ложь) Экспорт 
	Если СтрокаМетода = Неопределено Тогда
		Если мМетодМодуля = Неопределено Тогда
			Результат = ИмяТекущегоМетода();
			Если Не РазрешитьЛокальное Тогда
				Результат = мМодульМетаданных.Имя + "." + Результат;
			КонецЕсли;
			Возврат Результат;
		КонецЕсли;
		СтрокаМетода = мМетодМодуля;
		СтрокаМетода.ИмяМодуля = мИмяМодуля;
	КонецЕсли;
	Если Не ЗначениеЗаполнено(СтрокаМетода.ИмяМодуля) Тогда
		ВызватьИсключение "Пустое имя модуля";
	КонецЕсли;
	Если РазрешитьЛокальное И мМодульМетаданных.Имя = СтрокаМетода.ИмяМодуля Тогда
		Возврат СтрокаМетода.Имя;
	КонецЕсли;
	Результат = ПрямоеИмяМодуляИзПолного(СтрокаМетода.ИмяМодуля);
	Результат = Результат + "." + СтрокаМетода.Имя;
	Возврат Результат; 
КонецФункции

Функция ПрямоеИмяМодуляИзПолного(Знач ИмяМодуля, Знач ТолькоВычисляемое = Ложь) Экспорт
	Фрагменты = ирОбщий.СтрРазделитьЛкс(ИмяМодуля, ".");
	Если Фрагменты.Количество() = 1 Тогда
		// Внешний модуль
		Возврат "";
	КонецЕсли;
	Если Истина
		И Фрагменты[Фрагменты.ВГраница() - 1] = "Форма" 
		И Фрагменты[Фрагменты.ВГраница()] = "Модуль" 
	Тогда
		Если ТолькоВычисляемое Тогда
			Возврат "";
		КонецЕсли;
		Фрагменты.Удалить(Фрагменты.ВГраница());
		Фрагменты.Удалить(Фрагменты.ВГраница());
	ИначеЕсли Фрагменты[Фрагменты.ВГраница()] = "МодульОбъекта" Тогда
		Если ТолькоВычисляемое Тогда
			Возврат "";
		КонецЕсли;
		Фрагменты.Удалить(Фрагменты.ВГраница());
		Фрагменты[0] = Фрагменты[0] + "Объект";
	ИначеЕсли Фрагменты[Фрагменты.ВГраница()] = "МодульКоманды" Тогда
		Если ТолькоВычисляемое Тогда
			Возврат "";
		КонецЕсли;
		Фрагменты.Удалить(Фрагменты.ВГраница());
	ИначеЕсли Фрагменты[Фрагменты.ВГраница()] = "МодульМенеджера" Тогда
		Фрагменты.Удалить(Фрагменты.ВГраница());
		Фрагменты[0] = ирОбщий.МножественноеИмяМДЛкс(Фрагменты[0]);
	ИначеЕсли Фрагменты[0] = "ОбщийМодуль" Тогда
		Фрагменты.Удалить(0);
	КонецЕсли; 
	Если Фрагменты[Фрагменты.ВГраница()] = "Модуль" Тогда
		Фрагменты.Удалить(Фрагменты.ВГраница());
	КонецЕсли;
	Результат = ирОбщий.СтрСоединитьЛкс(Фрагменты, ".");
	Возврат Результат;
КонецФункции

// Вызывается из адаптера
Функция ПерейтиВНачалоРодителя() Экспорт
	КончитьОбработкуКоманды();
	ЗапомнитьИсточникПерехода();
	РазобратьТекущийКонтекст(,, Ложь);
	НоваяПозиция0ВМодуле = Неопределено;
	Результат = Ложь;
	Если мЭтоТекстовыйЛитерал Тогда
		ВыделитьТекстовыйЛитерал(, НоваяПозиция0ВМодуле);
	Иначе 
		СмещениеНачалаТела = 0;
		Если мМетодМодуля <> Неопределено Тогда
			СмещениеНачалаТела = мМетодМодуля.ПозицияТела - мМетодМодуля.ПозицияОпределения;
		КонецЕсли;
		Области = Неопределено; // см. РодителиПозицииВТексте()
		СтроитьДеревоПрограммныхСкобок(,, СмещениеНачалаТела + мПозицияВБлоке - 1, Области,, Истина);
		Если Области = Неопределено Тогда
			// не метод
			Возврат Результат;
		КонецЕсли;
		СтрокаОбласти = Области.Добавить();
		СтрокаОбласти.Область = "<Метод>";
		СтрокаОбласти.ПозицияНачала = 1;
		НоваяПозиция0ВМодуле = Области[0].ПозицияНачала + мПозицияТекстаДляПоискаОпределения - СмещениеНачалаТела;
		НачалоСтроки = Сред(мОригинальныйТекст, НоваяПозиция0ВМодуле + 1, 200);
		НоваяПозиция0ВМодуле = НоваяПозиция0ВМодуле + СтрДлина(НачалоСтроки) - СтрДлина(СокрЛ(НачалоСтроки)); // Отрезаем лидирующие непечатные
	КонецЕсли;
	Если НоваяПозиция0ВМодуле <> Неопределено Тогда
		УстановитьГраницыВыделения(НоваяПозиция0ВМодуле + 1, НоваяПозиция0ВМодуле + 1);
		Результат = Истина;
	КонецЕсли;
	Возврат Результат;
КонецФункции

Функция ПерейтиКГраницеКонструкции() Экспорт 
	#Если Сервер И Не Сервер Тогда
		ПолеТекста = Обработки.ирОболочкаПолеТекста.Создать();
	#КонецЕсли
	ЗапомнитьИсточникПерехода();
	НачальнаяГраница0Литерала = 0;
	КонечнаяГраница0Литерала = 0;
	КончитьОбработкуКоманды();
	ТекстВЛитерале = ВыделитьТекстовыйЛитерал(, НачальнаяГраница0Литерала, КонечнаяГраница0Литерала);
	Если ТекстВЛитерале = Неопределено Тогда
		Возврат Ложь;
	КонецЕсли;
	Если мПозицияВТексте = НачальнаяГраница0Литерала + 1 Тогда
		ПолеТекста.УстановитьГраницыВыделения(КонечнаяГраница0Литерала, КонечнаяГраница0Литерала);
	Иначе
		ПолеТекста.УстановитьГраницыВыделения(НачальнаяГраница0Литерала + 1, НачальнаяГраница0Литерала + 1);
	КонецЕсли;
	Возврат Истина;
КонецФункции

// .
// Параметры:
//   МетодМодуля -  - 
//   ИмяПараметра -  - 
//   СмещениеСтрокиМетода -  - 
//   НомерКолонки -  - 
//   НужноОписаниеПараметра - Булево, Неопределено - если Истина, то выделяется описание параметра в комментарии к методу, иначе выделяется объявление параметра
Процедура ПерейтиКОпределениюЛокальногоМетода(МетодМодуля, Знач ИмяПараметра = "", Знач СмещениеСтрокиМетода = 0, Знач НомерКолонки = 1, Знач НужноОписаниеПараметра = Неопределено) Экспорт
	Если МетодМодуля.ПозицияТела = 0 Тогда
		Возврат;
	КонецЕсли; 
	//Если Истина
	//	И мПозицияВТексте >= МетодМодуля.ПозицияОпределения 
	//	И мПозицияВТексте < МетодМодуля.ПозицияОпределения 
	//Тогда
	//	НоваяПозиция = мПозицияВТексте;
	//КонецЕсли;
	РазобратьТекущийКонтекст();
	ЗапомнитьИсточникПерехода();
	Если Не ЗначениеЗаполнено(ИмяПараметра) Тогда
		НомерПервойСтрокиОпределенияМетода = НомерСтрокиИзПозиции(МетодМодуля.ПозицияОпределения);
		ВыделитьСтрокуВПолеТекста(НомерПервойСтрокиОпределенияМетода + СмещениеСтрокиМетода, НомерКолонки, 0);
	Иначе
		Если НужноОписаниеПараметра = Неопределено Тогда
			НужноОписаниеПараметра = ЛиВЗаголовкеМетода(МетодМодуля);
		КонецЕсли;
		Если НужноОписаниеПараметра Тогда
			НачалоОбласти = МетодМодуля.ПозицияСОписанием;
			КонецОбласти = МетодМодуля.ПозицияОпределения;
			ШаблонПоиска = "(" + мПлатформа.шПустоеНачалоСтроки + "//\s+)(#Слово#)([\t ]*[-\n])";
		Иначе
			НачалоОбласти = МетодМодуля.ПозицияОпределения;
			КонецОбласти = МетодМодуля.ПозицияТела;
			ШаблонПоиска = "([\(,]\s*(?:Знач\s+)?)(#Слово#)(\s*[\),=\/])";
		КонецЕсли;
		Успех = ирКлиент.НайтиПоказатьФрагментВПолеТекстаЛкс(ФормаВладелец, ПолеТекста, ИмяПараметра, ШаблонПоиска, Истина,,, НачалоОбласти, КонецОбласти);
		Если Успех Тогда
			УстановитьФокус();
			Если НужноОписаниеПараметра Тогда
				ПолучитьГраницыВыделения();
				УстановитьГраницыВыделения(мНачальнаяСтрока, мКонечнаяКолонка + 3, мНачальнаяСтрока, мКонечнаяКолонка + 3);
			КонецЕсли;
		КонецЕсли;
		ПолучитьГраницыВыделения();
	КонецЕсли;
КонецПроцедуры

//.
// Параметры:
//    МетодМодуля - ? - 
Функция ЛиВЗаголовкеМетода(МетодМодуля = Неопределено, Знач ВключаяКомметарийМетода = Ложь) Экспорт
	Если МетодМодуля = Неопределено Тогда
		МетодМодуля = мМетодМодуля;
	КонецЕсли;
	Результат = Истина
		И МетодМодуля <> Неопределено
		И мПозицияВТексте < МетодМодуля.ПозицияТела 
		И (Ложь
			Или ВключаяКомметарийМетода
			Или мПозицияВТексте > МетодМодуля.ПозицияОпределения);
	Возврат Результат;
КонецФункции

Процедура ВыделитьДиапазонОдномерныйДляПользователя(Знач НачальнаяПозицияОпределения, Знач КонечнаяПозицияОпределения)
	
	СлужебноеПолеТекстаДолгое.УстановитьГраницыВыделения(НачальнаяПозицияОпределения, КонечнаяПозицияОпределения);
	СлужебноеПолеТекстаДолгое.ПолучитьГраницыВыделения(мНачальнаяСтрока, мНачальнаяКолонка, мКонечнаяСтрока, мКонечнаяКолонка); // Там текст без комментариев и опасных строковых литералов
	ПолеТекста.УстановитьГраницыВыделения(мНачальнаяСтрока, мНачальнаяКолонка, мКонечнаяСтрока, мКонечнаяКолонка,, ФормаВладелец); // Для ТуброКонфа

КонецПроцедуры

Процедура ОткрытьОпределениеСтруктурыТипа(Знач СтруктураТипа, Знач ЭтоОбщийТип = Ложь, Знач ИмяПараметраМетода = "") Экспорт 
	СписокВыбора = ДобавитьПереходыИзСтруктурыТипаВСписокВыбора(СтруктураТипа,,,, Истина);
	ВыбратьПереход(СписокВыбора, ЭтоОбщийТип, ИмяПараметраМетода);
КонецПроцедуры

//.
// Параметры:
//    СписокВыбора - Булево, СписокЗначений - 
//    ЭтоОбщийТип - Булево - 
//    ИмяПараметраМетода - Строка - применяется если выбрана НЕ строковая ссылка
Процедура ВыбратьПереход(Знач СписокВыбора, Знач ЭтоОбщийТип = Ложь, Знач ИмяПараметраМетода = "") Экспорт
	Если СписокВыбора.Количество() = 0 Тогда
		Возврат;
	ИначеЕсли СписокВыбора.Количество() > 1 Тогда 
		РезультатВыбора = ирКлиент.ВыбратьЭлементСпискаЗначенийЛкс(СписокВыбора,,, "Выберите переход",, Истина);
		Если РезультатВыбора = Неопределено Тогда
			Возврат;
		КонецЕсли;
	Иначе 
		РезультатВыбора = СписокВыбора[0];
	КонецЕсли;
	СтруктураСсылки = Неопределено;
	Если ТипЗнч(РезультатВыбора.Значение) = Тип("Строка") Тогда 
		СтруктураСсылки = ирОбщий.СтруктураСсылкиСтрокиМодуляЛкс(РезультатВыбора.Значение);
	КонецЕсли;
	Если СтруктураСсылки <> Неопределено Тогда
		ПерейтиПоСсылкеСтрокиМодуля(РезультатВыбора.Значение, Ложь);
	ИначеЕсли ирОбщий.ЛиСсылкаНаОбъектБДЛкс(РезультатВыбора.Значение) Тогда 
		ирКлиент.ОткрытьЗначениеЛкс(РезультатВыбора.Значение);
		//ирКлиент.ОткрытьСсылкуВРедактореОбъектаБДЛкс(РезультатВыбора.Значение);
	ИначеЕсли ирОбщий.СтрНачинаетсяСЛкс(РезультатВыбора.Представление, "Метод ") Тогда 
		ирКлиент.ОткрытьМетодМодуляПоОпределениюЛкс(РезультатВыбора.Значение, ИмяПараметраМетода, ЭтотОбъект);
	ИначеЕсли РезультатВыбора.Представление = "ГиперСсылка" Тогда 
		ЗапуститьПриложение(РезультатВыбора.Значение);
	ИначеЕсли ирОбщий.СтрНачинаетсяСЛкс(РезультатВыбора.Представление, "Справка") Тогда
		СтруктураТипа = РезультатВыбора.Значение;
		Если ЭтоОбщийТип Тогда
			ПутьКСлову = СтруктураТипа.ИмяОбщегоТипа;
		Иначе
			ПутьКСлову = мКонтекст;
		КонецЕсли;  
		НайтиПоказатьСправкуПоСтруктуреТипа(ПутьКСлову, СтруктураТипа);
	Иначе
		ПолноеИмяМД = ирОбщий.ПоследнийФрагментЛкс(РезультатВыбора.Значение, " ");
		Если ирОбщий.МножественноеИмяМДЛкс(ирОбщий.ПервыйФрагментЛкс(ПолноеИмяМД,, Ложь)) <> Неопределено Тогда 
			Если ирОбщий.СтрНачинаетсяСЛкс(РезультатВыбора.Представление, "Картинка") Тогда
				ирКлиент.ОткрытьЗначениеЛкс(БиблиотекаКартинок[ирОбщий.ПоследнийФрагментЛкс(ПолноеИмяМД)]);
			ИначеЕсли ирОбщий.СтрНачинаетсяСЛкс(РезультатВыбора.Представление, "Форма") Тогда
				ирКлиент.ПассивнаяФормаПоИмениЛкс(ПолноеИмяМД).Открыть();
			ИначеЕсли ирОбщий.СтрНачинаетсяСЛкс(РезультатВыбора.Представление, "Макет") Тогда
				ОбъектМД = Метаданные.НайтиПоПолномуИмени(ПолноеИмяМД);
				Макет = ирОбщий.ПолучитьМенеджерЛкс(ОбъектМД.Родитель()).ПолучитьМакет(ирОбщий.ПоследнийФрагментЛкс(ПолноеИмяМД));
				ирКлиент.ОткрытьЗначениеЛкс(Макет);
			Иначе 
				ирКлиент.ОткрытьОбъектМетаданныхЛкс(ПолноеИмяМД);
			КонецЕсли; 
		КонецЕсли;
	КонецЕсли;
КонецПроцедуры

//.
// Параметры:
//    СсылкаСтрокиМодуля - Строка - 
//    ТолькоЛокально - Булево - 
Функция ПерейтиПоСсылкеСтрокиМодуля(Знач СсылкаСтрокиМодуля, Знач ТолькоЛокально = Истина) Экспорт
	ЗапомнитьИсточникПерехода();
	Если ТипЗнч(СсылкаСтрокиМодуля) = Тип("Строка") Тогда
		СтруктураСсылки = ирОбщий.СтруктураСсылкиСтрокиМодуляЛкс(СсылкаСтрокиМодуля);
	КонецЕсли;         
	Если СтруктураСсылки = Неопределено Тогда
		Возврат Ложь;
	КонецЕсли; 
	Если СтруктураСсылки.Модуль = мМодульМетаданных.Имя Тогда
		ПозицияБлока = Неопределено;
		Если СтруктураСсылки.Метод = мПлатформа.ИмяМетодаИнициация() Тогда
			ПозицияБлока = мМодульМетаданных.ПозицияПрограммы;
			НомерСтроки = ирОбщий.СтрЧислоСтрокЛкс(Лев(мОригинальныйТекст, ПозицияБлока - 1)) + СтруктураСсылки.СмещениеСтрокиМетода - 1;
			ВыделитьСтрокуВПолеТекста(НомерСтроки, СтруктураСсылки.НомерКолонки);
		ИначеЕсли ЗначениеЗаполнено(СтруктураСсылки.Метод) Тогда 
			СтрокаМетода = мПлатформа.СтрокаМетодаМодуляПоИмени(мМодульМетаданных, СтруктураСсылки.Метод);
			Если СтрокаМетода <> Неопределено Тогда
				ПозицияБлока = СтрокаМетода.ПозицияТела;
				Если ПозицияБлока <> Неопределено Тогда
					ПерейтиКОпределениюЛокальногоМетода(СтрокаМетода, СтруктураСсылки.ПараметрМетода, СтруктураСсылки.СмещениеСтрокиМетода, СтруктураСсылки.НомерКолонки);
				КонецЕсли;
			КонецЕсли;
		КонецЕсли;
		Если ПозицияБлока = Неопределено Тогда
			ВыделитьСтрокуВПолеТекста(СтруктураСсылки.НомерСтроки, СтруктураСсылки.НомерКолонки);
		КонецЕсли;
		Возврат Истина;
	ИначеЕсли Не ТолькоЛокально Тогда 
		Если ЗначениеЗаполнено(СтруктураСсылки.Метод) Тогда
			Модуль = мПлатформа.МодульМетаданныхИзКэша(СтруктураСсылки.Модуль); 
			Если Модуль = Неопределено Тогда
				ВызватьИсключение "Некорректное имя модуля """ + СтруктураСсылки.Модуль + """";
			КонецЕсли;
			СтрокаМетода = мПлатформа.СтрокаМетодаМодуляПоИмени(Модуль, СтруктураСсылки.Метод);
			ирКлиент.ОткрытьМетодМодуляПоОпределениюЛкс(СтрокаМетода, СтруктураСсылки.ПараметрМетода,, СтруктураСсылки.СмещениеСтрокиМетода, СтруктураСсылки.НомерКолонки);
		Иначе 
			Если Не ирКлиент.ОткрытьСсылкуСтрокиМодуляЛкс(СсылкаСтрокиМодуля) Тогда 
				Если СтруктураСсылки.Модуль = мПлатформа.ИмяДинамическогоМодуля() Тогда 
					ФормаВладелец.Активизировать();
					ПолеТекстаЛ = ПолеТекста;
				Иначе
					ПолеТекстаЛ = ирКлиент.ОткрытьПолеТекстаМодуляКонфигурацииЛкс(СтруктураСсылки.Модуль).ПолеТекста;
				КонецЕсли;
				ПолеТекстаЛ.УстановитьГраницыВыделения(СтруктураСсылки.НомерСтроки, 1, СтруктураСсылки.НомерСтроки, 200, Истина);
			КонецЕсли;
		КонецЕсли;
	КонецЕсли;
	Возврат Ложь;
КонецФункции

//.
// Параметры:
//    НомерСтроки - Число - 
Процедура ВыделитьСтрокуВПолеТекста(Знач НомерСтроки, Знач НомерКолонки = 1, Знач Длина = 1) Экспорт
	УстановитьГраницыВыделения(НомерСтроки, НомерКолонки, НомерСтроки, НомерКолонки);
	ВыделитьТекущееСлово();
	Если СтрДлина(ВыделенныйТекст()) = 0 Тогда
		УстановитьГраницыВыделения(НомерСтроки, НомерКолонки, НомерСтроки, НомерКолонки + Длина);
	КонецЕсли;
	ПолучитьГраницыВыделения();
КонецПроцедуры

// Процедура - Загрузить модуль метаданных
// Параметры:
//   Модуль - см. мПлатформа.МодульМетаданных() - 
Процедура ЗагрузитьМодульМетаданных(Модуль) Экспорт 
	мМодульМетаданных = Модуль;
	Если Модуль.Текст = Неопределено Тогда
		Модуль.Текст = мОригинальныйТекст;
	Иначе
		УстановитьТекстБезМетаданных(Модуль.Текст);
	КонецЕсли;
КонецПроцедуры

Функция ДобавитьПереходыИзСтруктурыТипаВСписокВыбора(Знач СтруктураТипа, Знач СписокВыбора = Неопределено, Знач СтруктураТипаРодителя = Неопределено, Знач ИскатьСозданиеТаблицы = Ложь,
	Знач ДобавлятьСправку = Ложь)
	
	Если СписокВыбора = Неопределено Тогда
		СписокВыбора = Новый СписокЗначений;
	КонецЕсли;
	Если Истина
		И ТипЗнч(СтруктураТипа.ДержательМетаданных) = Тип("Структура") 
		И (Ложь
			Или СтруктураТипа.ДержательМетаданных.Тип = Тип("МенеджерВременныхТаблиц") 
			Или СтруктураТипа.ДержательМетаданных.Тип = "ПакетЗапросов")
	Тогда 
		Если СтруктураТипа.ДержательМетаданных.Тип = Тип("МенеджерВременныхТаблиц") Тогда 
			ПакетЗапросов = НовыйПакетЗапросов();
			МенеджерВременныхТаблиц = СтруктураТипа.ДержательМетаданных; // см. НовыйМенеджерВременныхТаблиц()
			Если СтруктураТипа.ИмяОбщегоТипа = "Неопределено" Тогда
				// 
			ИначеЕсли Ложь
				Или СтруктураТипа.ИмяОбщегоТипа = "ВременнаяТаблицаЗапроса"
				Или СтруктураТипа.ИмяОбщегоТипа = "КолонкаВременнойТаблицыЗапроса"
			Тогда
				НайтиЗапросВременнойТаблицы(мТекущееСлово, МенеджерВременныхТаблиц, ПакетЗапросов);
			ИначеЕсли МенеджерВременныхТаблиц.ПакетыЗапросов.Количество() > 0 Тогда
				ПакетЗапросов = МенеджерВременныхТаблиц.ПакетыЗапросов[МенеджерВременныхТаблиц.ПакетыЗапросов.ВГраница()];
			КонецЕсли;
		Иначе
			// Колонка результата запроса
			ПакетЗапросов = СтруктураТипа.ДержательМетаданных; // см. НовыйПакетЗапросов()
		КонецЕсли;
		КоординатыТекстаЗапроса = ПакетЗапросов.КоординатыТекста; 
		Если КоординатыТекстаЗапроса <> Неопределено Тогда
			АнализаторКода = мПлатформа.ПолеТекстаМодуля(КоординатыТекстаЗапроса.Модуль);
			АнализаторКода.мЯзыкПрограммы = 1; 
			//АнализаторКода.ЗагрузитьМодульМетаданных(КоординатыТекстаЗапроса.Модуль); // Отключил 24.08.2024
			АнализаторКода.ЗагрузитьМетодМодуля(КоординатыТекстаЗапроса.Метод);
			НачальнаяПозицияПоиска = КоординатыТекстаЗапроса.Позиция0ВБлоке + 1;
			//АнализаторКода.мТекстДляПоискаОпределения = Сред(АнализаторКода.мТекстБлока, НачальнаяПозицияПоиска, КоординатыТекстаЗапроса.ДлинаТекста); // Полный текст
			АнализаторКода.мТекстДляПоискаОпределения = ПакетЗапросов.Текст;
			Позиции0Запросов = Новый Массив;
			ТекстыЗапросов = мПлатформа.РазбитьГрубоТекстПакетногоЗапросаНаЗапросы(АнализаторКода.мТекстДляПоискаОпределения,, Позиции0Запросов);
			Если ПакетЗапросов.Свойство("ИндексВПакете") Тогда
				//! ПакетЗапросов.Вставить("ИндексВПакете")
				ИндексВПакете = ПакетЗапросов.ИндексВПакете;
			Иначе 
				ИндексВПакете = ТекстыЗапросов.ВГраница();
			КонецЕсли;
			НачальнаяПозицияПоиска = НачальнаяПозицияПоиска + Позиции0Запросов[ИндексВПакете];
			АнализаторКода.мТекстДляПоискаОпределения = Сред(АнализаторКода.мТекстБлока, НачальнаяПозицияПоиска, СтрДлина(ТекстыЗапросов[ИндексВПакете]));
			ПоследнееВхождение = Неопределено;
			ПозицияВМетоде = НачальнаяПозицияПоиска; 
			Если ИскатьСозданиеТаблицы Тогда
				ПозицияВЛитерале = ирОбщий.НайтиРегВыражениеЛкс(АнализаторКода.мТекстДляПоискаОпределения, "ПОМЕСТИТЬ\s+" + ирОбщий.ТекстДляРегВыраженияЛкс(мТекущееСлово),, Ложь);
				Если ПозицияВЛитерале.Количество() > 0 Тогда
					ПозицияВМетоде = НачальнаяПозицияПоиска + ПозицияВЛитерале[0].ПозицияВхождения;
				КонецЕсли;
			Иначе 
				АнализаторКода.НайтиОпределениеСлова(мТекущееСлово,, ПоследнееВхождение);
				Если ПоследнееВхождение <> Неопределено Тогда
					ПозицияВМетоде = -1 + НачальнаяПозицияПоиска + ПоследнееВхождение.FirstIndex + ирОбщий.СтрНайтиЛкс(ПоследнееВхождение.Value, мТекущееСлово, Истина,,, Ложь);
				КонецЕсли;
			КонецЕсли;
			мПолеТекстаВременное.УстановитьТекст(АнализаторКода.мТекстБлока);
			мПолеТекстаВременное.УстановитьГраницыВыделения(ПозицияВМетоде, ПозицияВМетоде);
			НомерСтрокиМетода = 0;
			НомерКолонкиМетода = 0;
			мПолеТекстаВременное.ПолучитьГраницыВыделения(НомерСтрокиМетода, НомерКолонкиМетода, НомерСтрокиМетода, НомерКолонкиМетода);
			Если КоординатыТекстаЗапроса.Метод <> Неопределено Тогда
				ИмяМетода = КоординатыТекстаЗапроса.Метод.Имя;
			Иначе 
				ИмяМетода = мПлатформа.ИмяМетодаИнициация(); // Нужно в консоли кода при ЭтоМодуль=Ложь
				//ИмяМетода = "";
			КонецЕсли;
			КлючПерехода = ирОбщий.СсылкаСтрокиМодуляЛкс(КоординатыТекстаЗапроса.Модуль.Имя,, ИмяМетода, НомерСтрокиМетода,, НомерКолонкиМетода);
			Если СписокВыбора.НайтиПоЗначению(КлючПерехода) = Неопределено Тогда
				СписокВыбора.Добавить(КлючПерехода, "Запрос",, ирКэш.КартинкаПоИмениЛкс("ирЗапрос"));
			КонецЕсли;
		КонецЕсли;
	КонецЕсли;
	Если ТипЗнч(СтруктураТипа.СтрокаОписания) = Тип("Структура") Тогда
		//! СтруктураТипа.СтрокаОписания = 0 // см. НовоеОписаниеДинамическогоСвойства
		КоординатыТекста = СтруктураТипа.СтрокаОписания.Координаты;
		АнализаторКода = мПлатформа.ПолеТекстаМодуля(КоординатыТекста.Модуль);
		АнализаторКода.ЗагрузитьМетодМодуля(КоординатыТекста.Метод);
		Позиция = АнализаторКода.мПозицияТекстаДляПоискаОпределения;
		Если КоординатыТекста.Метод <> Неопределено Тогда
			Позиция = КоординатыТекста.Метод.ПозицияТела; 
		КонецЕсли;
		НомерСтроки = АнализаторКода.НомерСтрокиИзПозиции(Позиция + КоординатыТекста.Позиция0ВБлоке);
		КлючПерехода = АнализаторКода.СсылкаСтрокиМодуля(НомерСтроки);
		Если СписокВыбора.НайтиПоЗначению(КлючПерехода) = Неопределено Тогда
			СписокВыбора.Добавить(КлючПерехода, "Свойство");
		КонецЕсли;
	ИначеЕсли ТипЗнч(СтруктураТипа.СтрокаОписания) = Тип("СтрокаТаблицыЗначений") Тогда 
		ТаблицаВладелец = СтруктураТипа.СтрокаОписания.Владелец();
		#Если Сервер И Не Сервер Тогда
			ТаблицаВладелец = Новый ТаблицаЗначений;
		#КонецЕсли                           
		Если ТаблицаВладелец.Колонки.Найти("ЛиЭкспорт") <> Неопределено Тогда
			СтрокаСловаМодуля = СтруктураТипа.СтрокаОписания; // см. мМетодМодуля
			Если СтрокаСловаМодуля.Имя = "<>" И Не ПустаяСтрока(мРодительскийКонтекст) Тогда
				ВиртуальныйМетод = СтрокаСловаМодуля.Владелец().Добавить();
				ЗаполнитьЗначенияСвойств(ВиртуальныйМетод, СтрокаСловаМодуля);
				ВиртуальныйМетод.Имя = ирОбщий.ПервыйФрагментЛкс(мТекущееСлово, "(");
				ирОбщий.ОбновитьКопиюСвойстваВНижнемРегистреЛкс(ВиртуальныйМетод);
				СтрокаСловаМодуля = ВиртуальныйМетод;
			КонецЕсли;
			Если Истина
				И СтрокаСловаМодуля.Имя <> "<>" 
				И Найти(мВызовМетода, "." + СтрокаСловаМодуля.Имя + "(") = 0 // защита от добавления вызываемого метода на параметре ирОбщий.СообщитьЛкс("ирОбщий.ЛиКаталогДоступен<>Лкс")
			Тогда
				ДобавитьПереходНаСловоМодуляВСписокВыбора(СтрокаСловаМодуля, СписокВыбора);
				Если Истина
					И СтрокаСловаМодуля.ИмяМодуля <> мПлатформа.ИмяДинамическогоМодуля()
					И (Ложь
						Или Найти(мТекущееСлово, "(") > 0 
						Или мЭтоТекстовыйЛитерал)
				Тогда
					Для Каждого КлючИЗначение Из ирКэш.РасширенияКонфигурацииЛкс(Ложь) Цикл
						Расширение = КлючИЗначение.Ключ;
						ИмяРасширенияМодуля = Расширение.Имя + " " + СтрокаСловаМодуля.ИмяМодуля;
						ПолеТекстаМодуля = мПлатформа.ПолеТекстаМодуля(ИмяРасширенияМодуля);
						РасширениеМетода = ПолеТекстаМодуля.мМодульМетаданных.Методы.Найти(СтрокаСловаМодуля.Имя, "РасширяемыйМетод");
						Если РасширениеМетода <> Неопределено Тогда
							РасширениеМетода.ИмяМодуля = ИмяРасширенияМодуля;
							ДобавитьПереходНаСловоМодуляВСписокВыбора(РасширениеМетода, СписокВыбора, Расширение.Имя);
						КонецЕсли;
					КонецЦикла;
				КонецЕсли;
			КонецЕсли;
		ИначеЕсли ТаблицаВладелец.Колонки.Найти("Знач") <> Неопределено Тогда 
			СтрокаПараметра = СтруктураТипа.СтрокаОписания; // см. мПлатформа.ПараметрыМетодаМодуля()[0]
			КлючПерехода = ирОбщий.СсылкаСтрокиМодуляЛкс(СтрокаПараметра.ИмяМодуля,, СтрокаПараметра.ИмяМетода,,,, СтрокаПараметра.Имя); // Колонки ИмяМодуля и ИмяМодуля добавляются тут Мультиметка4819233927 
			Если СписокВыбора.НайтиПоЗначению(КлючПерехода) = Неопределено Тогда
				СписокВыбора.Добавить(КлючПерехода, "Параметр метода",, ирКэш.КартинкаПоИмениЛкс("ирПараметрыМетода"));
			КонецЕсли;
		ИначеЕсли ТаблицаВладелец.Колонки.Найти("Значение") <> Неопределено Тогда
			СтрокаПоляБД = СтруктураТипа.СтрокаОписания; // см. Обработка.ирКонсольКода.Форма.Форма.Параметры[0]
			Если Истина
				И ирОбщий.ЛиСсылкаНаОбъектБДЛкс(СтрокаПоляБД.Значение)
				И ЗначениеЗаполнено(СтрокаПоляБД.Значение) 
			Тогда 
				КлючПерехода = СтрокаПоляБД.Значение;
				Если СписокВыбора.НайтиПоЗначению(КлючПерехода) = Неопределено Тогда
					СписокВыбора.Добавить(КлючПерехода, "Объект БД",, ирКэш.КартинкаПоИмениЛкс("ирСсылка"));
				КонецЕсли;
			КонецЕсли;
		ИначеЕсли Истина
			И ТаблицаВладелец.Колонки.Найти("ТипЗначения") <> Неопределено 
			И СтруктураТипа.СтрокаОписания.ТипЗначения = "Картинка"
			И ТипЗнч(СтруктураТипа.Метаданные) = Тип("ОбъектМетаданных")
		Тогда    
			КлючПерехода = СтруктураТипа.Метаданные.ПолноеИмя();  
			Если СписокВыбора.НайтиПоЗначению(КлючПерехода) = Неопределено Тогда
				СписокВыбора.Добавить(КлючПерехода, "Картинка " + СтруктураТипа.Метаданные.Имя,, ирКэш.КартинкаПоИмениЛкс("Картинка"));
			КонецЕсли;
		ИначеЕсли ТаблицаВладелец.Колонки.Найти("ТипКонтекста") <> Неопределено Тогда    
			ИмяТипа = "";
			ПрефиксИмениКоллекции = "";
			Если ТипЗнч(СтруктураТипа.Метаданные) = Тип("ОбъектМетаданных") Тогда 
				Если СтруктураТипа.СтрокаОписания.Слово = "ПолучитьМакет" Тогда
					ИмяТипа = "Макет";
					Картинка = ирКэш.КартинкаПоИмениЛкс("ирМакетКонфигурации");
				ИначеЕсли СтруктураТипа.СтрокаОписания.Слово = "ПолучитьФорму" Тогда
					ИмяТипа = "Форма";
					Картинка = ирКэш.КартинкаПоИмениЛкс("ирФорма"); 
				КонецЕсли;
			ИначеЕсли СтруктураТипа.СтрокаОписания.Слово = "ПолучитьОбщийМакет" Тогда
				ПрефиксИмениКоллекции = "Общие";
				ИмяТипа = "Макет";
				Картинка = ирКэш.КартинкаПоИмениЛкс("ирМакетКонфигурации");
			ИначеЕсли СтруктураТипа.СтрокаОписания.Слово = "ПолучитьОбщуюФорму" Тогда
				ПрефиксИмениКоллекции = "Общие";
				ИмяТипа = "Форма";
				Картинка = ирКэш.КартинкаПоИмениЛкс("ирФорма");
			КонецЕсли;
			Если ЗначениеЗаполнено(ИмяТипа) Тогда
				ОбъектМДРодитель = СтруктураТипа.Метаданные;
				Если ОбъектМДРодитель = Неопределено Тогда
					ОбъектМДРодитель = Метаданные;
				КонецЕсли;
				ОбъектМД = ОбъектМДРодитель[ПрефиксИмениКоллекции + ирОбщий.МножественноеИмяМДЛкс(ИмяТипа)].Найти(мКонтекст); // см. Метаданные.Обработки.ирПлатформа
				Если ОбъектМД <> Неопределено Тогда
					КлючПерехода = ирОбщий.ПолноеИмяМДСРасширениемЛкс(ОбъектМД);
					Если СписокВыбора.НайтиПоЗначению(КлючПерехода) = Неопределено Тогда
						СписокВыбора.Добавить(КлючПерехода, ИмяТипа + " " + ОбъектМДРодитель.Имя,, Картинка); 
					КонецЕсли;
				КонецЕсли;
			КонецЕсли;
			Если СтруктураТипаРодителя <> Неопределено Тогда
				ИмяТипа = "";
				Если ТипЗнч(СтруктураТипаРодителя.Метаданные) = Тип("ОбъектМетаданных") Тогда 
					Если СтруктураТипа.СтрокаОписания.Слово = "<Имя реквизита>" Тогда
						ИмяТипа = "Реквизит";
						Картинка = ирКэш.КартинкаПоИмениЛкс("ирРеквизит");
					ИначеЕсли СтруктураТипа.СтрокаОписания.Слово = "<Имя табличной части>" Тогда
						ИмяТипа = "ТабличнаяЧасть";
						Картинка = ирКэш.КартинкаПоИмениЛкс("ирТабличнаяЧасть");
					КонецЕсли;
				КонецЕсли;
				Если ЗначениеЗаполнено(ИмяТипа) Тогда
					ОбъектМД = СтруктураТипаРодителя.Метаданные[ПрефиксИмениКоллекции + ирОбщий.МножественноеИмяМДЛкс(ИмяТипа)].Найти(мТекущееСлово); // см. Метаданные.Обработки.ирПлатформа
					Если ОбъектМД <> Неопределено Тогда
						КлючПерехода = ирОбщий.ПолноеИмяМДСРасширениемЛкс(ОбъектМД);
						Если СписокВыбора.НайтиПоЗначению(КлючПерехода) = Неопределено Тогда
							СписокВыбора.Добавить(КлючПерехода, ИмяТипа + " " + мТекущееСлово,, Картинка);
						КонецЕсли;
					КонецЕсли;
				КонецЕсли;
			КонецЕсли;
		КонецЕсли;                                                        
	КонецЕсли; 
	Если ирОбщий.ЛиФормаИлиИмитаторЛкс(СтруктураТипа.ДержательМетаданных) Тогда
		КлючПерехода = ирОбщий.ПолноеИмяФормыЛкс(СтруктураТипа.ДержательМетаданных);
		Попытка
			ИмяЭлементаФормы = СтруктураТипа.Метаданные.Имя;
		Исключение
			ИмяЭлементаФормы = Неопределено;
		КонецПопытки;
		Если ИмяЭлементаФормы <> Неопределено Тогда
			Если ирОбщий.ЛиФормаИлиИмитаторЛкс(СтруктураТипа.ДержательМетаданных, Ложь) Тогда
				КлючПерехода = КлючПерехода + ".Элементы." + ИмяЭлементаФормы;
			Иначе 
				Если Истина
					И СтруктураТипа.ИмяОбщегоТипа <> "КнопкаКоманднойПанели"
					И СтруктураТипа.ИмяОбщегоТипа <> "КолонкаТабличногоПоля"
				Тогда
					КлючПерехода = КлючПерехода + ".ЭлементыФормы." + ИмяЭлементаФормы;
				КонецЕсли;
			КонецЕсли;
		КонецЕсли;
		Если СписокВыбора.НайтиПоЗначению(КлючПерехода) = Неопределено Тогда
			СписокВыбора.Добавить(КлючПерехода, "Форма",, ирКэш.КартинкаПоИмениЛкс("ирФорма"));
		КонецЕсли;
	КонецЕсли;
	Если ТипЗнч(СтруктураТипа.Метаданные) = Тип("ОбъектМетаданных") Тогда
		Если Истина
			И СтруктураТипа.ИмяОбщегоТипа = "ОбщийМодуль"
			И мКонтекст = СтруктураТипа.Метаданные.Имя
			И ПустаяСтрока(мРодительскийКонтекст)
			И Не ЛиВнутриКомментария()
			И Не мЭтоТекстовыйЛитерал
			И Не ирОбщий.ЛиВнутриПрепроцессораЛкс(мТекущаяСтрокаНачало)
		Тогда
			СписокВыбора.Добавить(КлючПерехода, "Модуль прямой " + мКонтекст,, Картинка);
		Иначе
			КлючПерехода = ирОбщий.ПолноеИмяМДСРасширениемЛкс(СтруктураТипа.Метаданные);
			ДобавитьТипДанныхВСписокПереходов(КлючПерехода, СписокВыбора);
		КонецЕсли;
	КонецЕсли;
	Если ТипЗнч(СтруктураТипа.ДержательМетаданных) = Тип("ОбъектМетаданных") Тогда
		КлючПерехода = ирОбщий.ПолноеИмяМДСРасширениемЛкс(СтруктураТипа.ДержательМетаданных);
		Если Истина
			И ТипЗнч(СтруктураТипа.Метаданные) = Тип("ТабличныйДокумент") 
			И СтруктураТипа.Метаданные.Области.Найти(мКонтекст) <> Неопределено
		Тогда
			КлючПерехода = КлючПерехода + "." + мКонтекст;
		КонецЕсли;
		ДобавитьТипДанныхВСписокПереходов(КлючПерехода, СписокВыбора);
	КонецЕсли;
	Если ДобавлятьСправку Тогда
		СписокВыбора.Добавить(СтруктураТипа, "Справка",, ирКэш.КартинкаПоИмениЛкс("ирСинтаксПомощник")); // для кликов на типах в подсказке удержания HTML. Могут появляться дубли
	КонецЕсли;
	Возврат СписокВыбора;

КонецФункции

// .
//
// Параметры:
//  СтрокаМетода	 - СтрокаТаблицыЗначений - 
//  ИмяМодуля		 - Строка - надо передавать, т.к. атрибут строки метода заполнен не всегда, см. мПлатформа.ТаблицаТиповСловаМодуля()
//  СписокВыбора	 - Булево, СписокЗначений	 - 
//  ИмяРасширения	 - 							 - 
// 
// Возвращаемое значение:
//  Строка - 
//
Функция ДобавитьПереходНаСловоМодуляВСписокВыбора(Знач СтрокаСловаМодуля, Знач СписокВыбора, Знач ИмяРасширения = "") Экспорт
	КлючПерехода = ирКлиент.СсылкаСловаМодуляИзСтрокиСловаЛкс(СтрокаСловаМодуля);
	Если СтрокаСловаМодуля.Владелец().Колонки.Найти("ПозицияТела") <> Неопределено Тогда
		Представление = "Метод";
	Иначе 
		//Если СтрокаСловаМодуля.ПозицияОпределения = 0 Тогда // Наверное это невозможно
		//	Представление = "Реквизит";
		//Иначе 
			Представление = "Переменная";
		//КонецЕсли;
	КонецЕсли;
	Если СписокВыбора.НайтиПоЗначению(КлючПерехода) = Неопределено Тогда
		Если Ложь
			Или Представление = "Метод"
			Или Представление = "Переменная"
		Тогда
			ДобавкаПредставления = " " + СтрокаСловаМодуля.Имя;
			Если ЗначениеЗаполнено(ИмяРасширения) Тогда
				ДобавкаПредставления = ДобавкаПредставления + " " + ИмяРасширения;
			КонецЕсли;
			Картинка = ирКэш.КартинкаПоИмениЛкс("ирМетодыМодуля");
			Если Истина
				И Не ЗначениеЗаполнено(ИмяРасширения)
				И (Ложь
					Или Представление = "Переменная" И СтрокаСловаМодуля.ПозицияОпределения > 0
					Или Представление = "Метод" И Найти(мРодительскийКонтекст, "(") = 0)
				И Не ЛиВнутриКомментария()
				И Не мЭтоТекстовыйЛитерал
				И Не ирОбщий.ЛиВнутриПрепроцессораЛкс(мТекущаяСтрокаНачало)
				И (Ложь
					Или Не ЗначениеЗаполнено(мРодительскийКонтекст)
					Или Метаданные.ОбщиеМодули.Найти(мРодительскийКонтекст) <> Неопределено 
					Или ирОбщий.ЕдинственноеИмяМДЛкс(ирОбщий.ПервыйФрагментЛкс(мРодительскийКонтекст)) <> Неопределено)
			Тогда
				// Штатная команда конфигуратора может перейти к определению
				СписокВыбора.Добавить(КлючПерехода, Представление + " прямой" + ДобавкаПредставления,, Картинка);
			Иначе  
				СписокВыбора.Добавить(КлючПерехода, Представление + " непрямой" + ДобавкаПредставления,, Картинка);
			КонецЕсли;
		КонецЕсли;
		Если Представление = "Переменная" Тогда
			ВсеПрисвоения = Новый СписокЗначений;
			ПолеТекстаМодуля = мПлатформа.ПолеТекстаМодуля(СтрокаСловаМодуля.ИмяМодуля);
			ПолеТекстаМодуля.ВычислитьТипЗначенияВыражения(СтрокаСловаМодуля.Имя,,,,,,, Истина,,,,,,,, ВсеПрисвоения);
			Для Каждого Присвоение Из ВсеПрисвоения Цикл
				НомерСтрокиМодуля = ПолеТекстаМодуля.НомерСтрокиИзПозиции(Найти(ПолеТекстаМодуля.мОригинальныйТекст, Присвоение.Представление));
				Если Найти(Присвоение.Представление, Символы.ПС) > 0 Тогда
					НомерСтрокиМодуля = НомерСтрокиМодуля + 1;
				КонецЕсли;
				КлючПерехода = ирОбщий.СсылкаСтрокиМодуляЛкс(СтрокаСловаМодуля.ИмяМодуля, НомерСтрокиМодуля);
				Присвоение = СокрЛ(Присвоение.Представление);
				Если Лев(Присвоение, 1) = ";" Тогда
					Присвоение = СокрЛ(Сред(Присвоение, 2));
				КонецЕсли;
				СписокВыбора.Добавить(КлючПерехода, Представление + " присвоение " + Присвоение,, Картинка);
			КонецЦикла;
		КонецЕсли;
	КонецЕсли;
	Возврат КлючПерехода;
КонецФункции

Функция ПредставлениеЯзыкаВыражения() Экспорт 
	Если ЛиВнутриКомментария() Тогда 
		Результат = "Комментарий";
	ИначеЕсли мЯзыкПрограммы = 1 Тогда 
		Результат = "Запрос";
	ИначеЕсли мЭтоТекстовыйЛитерал Тогда 
		Результат = "Литерал";
	Иначе
		Результат = "Обычный";
	КонецЕсли;
	Возврат Результат;
КонецФункции

//.
// Параметры:
//    КлючПерехода - Строка - 
//    СписокВыбора - Булево, СписокЗначений - 
Функция ДобавитьТипДанныхВСписокПереходов(Знач КлючПерехода, Знач СписокВыбора = Неопределено) Экспорт
	Если СписокВыбора = Неопределено Тогда
		СписокВыбора = Новый СписокЗначений;
	КонецЕсли;
	Если СписокВыбора.НайтиПоЗначению(КлючПерехода) = Неопределено Тогда
		СписокВыбора.Добавить(КлючПерехода, "я Тип " + ирОбщий.ПоследнийФрагментЛкс(КлючПерехода, " "),, ирКэш.КартинкаПоИмениЛкс("ирМетаданные"));
	КонецЕсли;
	Возврат СписокВыбора;
КонецФункции

// Перед вызовом можно установить свойство мНачальнаяСтрока например через ПолучитьГраницыВыделения()
Функция СсылкаСтрокиМодуля(Знач НомерСтроки = 0, Знач Расширенная = Истина, Знач НомерКолонки = 0) Экспорт 
	ИмяМетода = "";
	Если Не ЗначениеЗаполнено(НомерСтроки) Тогда
		НомерСтроки = мНачальнаяСтрока;
	КонецЕсли;
	Если Не ЗначениеЗаполнено(НомерКолонки) Тогда
		НомерКолонки = мНачальнаяКолонка;
	КонецЕсли;
	Если мМетодМодуля <> Неопределено Тогда
		ИмяМетода = мМетодМодуля.Имя;
		СмещениеСтрокиМетода = НомерСтроки - НомерСтрокиИзПозиции(мМетодМодуля.ПозицияОпределения);
	КонецЕсли;      
	Результат = ирОбщий.СсылкаСтрокиМодуляЛкс(мИмяМодуля, НомерСтроки, ИмяМетода, СмещениеСтрокиМетода, ПолеТекста.ПолучитьСтроку(НомерСтроки), НомерКолонки,, Расширенная);
	Возврат Результат;
КонецФункции

// Вызывается из адаптера
// Параметры:
//    ПозицияВМодуле - Число - начиная с 1
// Возвращаемое значение:
//    Число - 
Функция НомерСтрокиИзПозиции(ПозицияВМодуле) Экспорт
	НомерСтроки = ВыделениеДвумерноеИзПозиции(ПозицияВМодуле).КонечнаяСтрока;
	Возврат НомерСтроки;
КонецФункции

// Вызывается из адаптера
Функция ИмяТекущегоМетода() Экспорт 
	Если мМетодМодуля = Неопределено Тогда
		ИмяМетода = мПлатформа.ИмяМетодаИнициация();
	Иначе
		ИмяМетода = мМетодМодуля.Имя;
	КонецЕсли;
	Возврат ИмяМетода
КонецФункции

Функция ВыделениеДвумерноеИзПозиции(ПозицияВМодуле) Экспорт
	ОболочкаПоля = ирКлиент.ОболочкаПоляТекстаЛкс(СлужебноеПолеТекстаДолгое);
	Если ПозицияВМодуле = Неопределено Тогда
		Результат = ОболочкаПоля.НоваяСтруктураДвумерногоВыделения();
	Иначе 
		ОболочкаПоля.УстановитьГраницыВыделения(ПозицияВМодуле, ПозицияВМодуле);
		Результат = ОболочкаПоля.ВыделениеДвумерное();
	КонецЕсли;
	Возврат Результат;
КонецФункции

// Ищем в мТекстДляПоискаОпределения. TODO переделать на ВычислитьТипЗначенияВыражения
//
// Параметры:
//  Слово						 - 	 - 
//  ПоследнееОпределение		 - 	 - 
//  ПоследнееВхождение			 - ОбработкаОбъект.ирОболочкаРегВхождение - выходной 
//  выхПозицияУжеВОпределении	 - 	 - 
// 
// Возвращаемое значение:
//   - 
//
Функция НайтиОпределениеСлова(Слово, ПоследнееОпределение = Неопределено, ПоследнееВхождение = Неопределено, выхПозицияУжеВОпределении = Ложь) Экспорт 
	                                 
	ПоследнееОпределение = Неопределено;
	Если мЯзыкПрограммы = 1 Тогда 
		ФрагментыСлова = ирОбщий.СтрРазделитьЛкс(Слово);
		Если ФрагментыСлова.Количество() < 3 Тогда
			ПсевдонимТаблицыИлиПоля = ФрагментыСлова[0];
			мРегВыражение.Global = Истина; 
			//мТекстДляПоискаОпределения = СтрЗаменить(мТекстДляПоискаОпределения, Символы.ПС + "|", Символы.ПС + " ");
			Если ЯзыкПрограммы = 0 Тогда
				мТекстДляПоискаОпределения = ЗалитьРазметкуТекстовогоЛитералаСохраняяПозиции(мТекстДляПоискаОпределения);
			КонецЕсли;
			мРегВыражение.Pattern = СтрЗаменить(шПоискОписанияТаблицы, "#Идентификатор#", ирОбщий.ТекстДляРегВыраженияЛкс(ПсевдонимТаблицыИлиПоля));
			ЛиНайденоИмяДоступнойТаблицы = Ложь;
			РезультатТекста = мРегВыражение.НайтиВхождения(мТекстДляПоискаОпределения);
			Если РезультатТекста.Количество() = 0 Тогда
				// Ищем явный псевдоним поля
				мРегВыражение.Pattern = "(ъъъ)?(ъъъ)?(\s*)?(" + шВыражениеЗапроса + ")?\s(?:КАК|AS)\s*" + ирОбщий.ТекстДляРегВыраженияЛкс(ПсевдонимТаблицыИлиПоля);
				РезультатТекста = мРегВыражение.НайтиВхождения(мТекстДляПоискаОпределения);
				Если РезультатТекста.Количество() = 0 Тогда
					// Ищем неявный псевдоним поля
					мРегВыражение.Pattern = "(ъъъ)?(ъъъ)?(\s*)?(" + шВыражениеЗапроса + "\s*\.\s*" + ирОбщий.ТекстДляРегВыраженияЛкс(ПсевдонимТаблицыИлиПоля) + ")\s*(?:,|ПОМЕСТИТЬ|INTO|ИЗ|FROM)";
					РезультатТекста = мРегВыражение.НайтиВхождения(мТекстДляПоискаОпределения);
					Если РезультатТекста.Количество() = 0 Тогда
						ПоследнееВхождение = Неопределено;
						ПоследнееОпределение = ПсевдонимТаблицыИлиПоля;
						ЛиНайденоИмяДоступнойТаблицы = Истина;
					КонецЕсли;
				КонецЕсли;
			КонецЕсли; 
			Если РезультатТекста.Количество() > 0 Тогда
				ПоследнееВхождение = РезультатТекста[0];
				НачалоЧасти = 0;
				Если мПозицияВТексте <> Неопределено Тогда
					мРегВыражение.Global = Ложь; 
					мРегВыражение.Pattern = "\sУПОРЯДОЧИТЬ\s|\ИТОГИ\s";
					Если мРегВыражение.НайтиВхождения(Лев(мТекстДляПоискаОпределения, мПозицияВБлоке)).Количество() = 0 Тогда
						НачалоЧасти = НачалоЧастиОбъединенияЗапроса(мТекстДляПоискаОпределения, мПозицияВБлоке);
						Для Каждого Вхождение Из РезультатТекста Цикл
							Если Вхождение.FirstIndex > НачалоЧасти Тогда
								ПоследнееВхождение = Вхождение;
								Прервать;
							КонецЕсли;
						КонецЦикла;
					КонецЕсли;
				КонецЕсли;
				ПоследнееОпределение = ПоследнееВхождение.SubMatches(3);
				Если Истина
					И ФрагментыСлова.Количество() = 1
					И мПозицияВТексте <> Неопределено
					И ПоследнееВхождение.FirstIndex > НачалоЧасти
					И ПоследнееВхождение.FirstIndex + 1 <= мПозицияВТексте 
					И ПоследнееВхождение.FirstIndex + 1 + СтрДлина(Слово) >= мПозицияВБлоке
				Тогда
					// Для вызова из консоли запросов в ведущей структуре запроса
					выхПозицияУжеВОпределении = Истина;
				КонецЕсли;
			КонецЕсли;
			ПакетЗапросов = Неопределено; // см. НовыйПакетЗапросов()
			ИндексЗапроса = Неопределено;
			НайтиЗапросВременнойТаблицы(ПоследнееОпределение,, ПакетЗапросов, ИндексЗапроса);
			Если ИндексЗапроса <> Неопределено Тогда
				Если ФрагментыСлова.Количество() = 2 Тогда
					Если Ложь
						Или ЯзыкПрограммы = 1
						Или ПакетЗапросов.КоординатыТекста.Модуль = мМодульМетаданных 
					Тогда
						ЗагрузитьЗапросПакетаПоИндексу(ПакетЗапросов, ИндексЗапроса);
						Возврат НайтиОпределениеСлова(ФрагментыСлова[1], ПоследнееОпределение, ПоследнееВхождение);
					КонецЕсли;
				Иначе 
					Если ПоследнееВхождение <> Неопределено Тогда
						лНачальнаяСтрока = 0;
						лНачальнаяКолонка = 0;
						лКонечнаяСтрока = 0;
						лКонечнаяКолонка = 0;
						НачальнаяПозицияВхождения = мПозицияТекстаДляПоискаОпределения + ПоследнееВхождение.FirstIndex + 1;
						СлужебноеПолеТекстаДолгое.УстановитьГраницыВыделения(НачальнаяПозицияВхождения, НачальнаяПозицияВхождения + СтрДлина(ПоследнееОпределение));
						СлужебноеПолеТекстаДолгое.ПолучитьГраницыВыделения(лНачальнаяСтрока, лНачальнаяКолонка, лКонечнаяСтрока, лКонечнаяКолонка);
						ЛиНайденоИмяДоступнойТаблицы = Истина
							И лНачальнаяСтрока = мНачальнаяСтрока И лНачальнаяКолонка <= мНачальнаяКолонка 
							И лКонечнаяСтрока = мКонечнаяСтрока И лКонечнаяКолонка >= мКонечнаяКолонка;
					КонецЕсли;
					Если Истина
						И ЛиНайденоИмяДоступнойТаблицы
						И (Ложь
							Или ЯзыкПрограммы = 1
							Или ПакетЗапросов.КоординатыТекста.Модуль = мМодульМетаданных)
					Тогда 
						ЗагрузитьЗапросПакетаПоИндексу(ПакетЗапросов, ИндексЗапроса);
						мРегВыражение.Global = Ложь;
						ШаблонСозданияТаблицы = "(?:" + шРазделитель + "|\|)+" + "(?:ПОМЕСТИТЬ|INTO(?:" + шРазделитель + "+TABLE)?)" + шРазделитель + "+(#Идентификатор#)" + шРазделитель;
						мРегВыражение.Pattern = СтрЗаменить(ШаблонСозданияТаблицы, "#Идентификатор#", ирОбщий.ТекстДляРегВыраженияЛкс(ПоследнееОпределение));
						РезультатТекста = мРегВыражение.НайтиВхождения(мТекстДляПоискаОпределения);
						Если РезультатТекста.Количество() > 0 Тогда
							ПоследнееОпределение = РезультатТекста[0].SubMatches(0);
							ПоследнееВхождение = ирОбщий.СоздатьОбъектПоИмениМетаданныхЛкс("Обработка.ирОболочкаРегВхождение");
							ЗаполнитьЗначенияСвойств(ПоследнееВхождение, РезультатТекста[0],, "SubMatches"); // Создаем неполноценный объект ради изменения свойства FirstIndex
							//ПоследнееВхождение.FirstIndex = ПоследнееВхождение.FirstIndex - мПозицияТекстаДляПоискаОпределения;
						КонецЕсли; 
					КонецЕсли;
				КонецЕсли;
			Иначе
				Если ФрагментыСлова.Количество() = 2 Или ПоследнееВхождение = Неопределено Тогда
					ПоследнееВхождение = Неопределено;
					ПоследнееОпределение = Неопределено;
				КонецЕсли;
			КонецЕсли;
		Иначе
			МаркерЗначение = "ЗНАЧЕНИЕ(";
			Если Прав(мПредшествующийТекст, СтрДлина(МаркерЗначение)) = МаркерЗначение Тогда
				мРегВыражение.Global = Ложь;
				мРегВыражение.Pattern = шИмя;
				Если мРегВыражение.Проверить(Слово) Тогда 
					Попытка
						ПредопределенноеЗначение = ПредопределенноеЗначение(Слово);
					Исключение
						ПредопределенноеЗначение = Неопределено;
					КонецПопытки; 
					Если ПредопределенноеЗначение <> Неопределено Тогда
						ОткрытьЗначение(ПредопределенноеЗначение);
					КонецЕсли; 
				КонецЕсли; 
			КонецЕсли; 
		КонецЕсли;
	Иначе
		мРегВыражение.Global = Истина;
		ЭкранированноеСлово = ирОбщий.ТекстДляРегВыраженияЛкс(ирОбщий.ПервыйФрагментЛкс(Слово, "("));
		Если ирОбщий.СтрКончаетсяНаЛкс(Слово, "(") Тогда
			// Ищем определение метода в тексте модуля
			мРегВыражение.Pattern = ирОбщий.СтрЗаменитьЛкс(мПлатформа.ШаблоныДляАнализаВстроенногоЯзыка().ОписаниеМетодаЧистое, шИмя, ЭкранированноеСлово);
			РезультатТекста = мРегВыражение.НайтиВхождения(мОригинальныйТекст);
		ИначеЕсли Лев(Слово, 1) = "~" Тогда 
			мРегВыражение.Pattern = мПлатформа.шПустоеНачалоСтроки + "(" + Слово + ":)";
			РезультатТекста = мРегВыражение.НайтиВхождения(мТекстБлока);
		ИначеЕсли Ложь
			Или ирОбщий.СтрокиРавныЛкс(Слово, "Продолжить") 
			Или ирОбщий.СтрокиРавныЛкс(Слово, "Прервать") 
		Тогда
			РезультатТекста = Новый Массив;
			ГлубинаЦикла = 0;
			мРегВыражение.Pattern = мПлатформа.шПустоеНачалоСтроки + "(?:(Пока|Для)[^\n]*\s(Цикл)|КонецЦикла)";
			ВхожденияЕсли = мРегВыражение.НайтиВхождения(Лев(мТекстДляПоискаОпределения, мПозицияВТексте));
			Для ИндексВхожденияЕсли = -ВхожденияЕсли.ВГраница() По 0 Цикл
				ВхождениеЦикла = ВхожденияЕсли[-ИндексВхожденияЕсли];
				Токен = НРег(ВхождениеЦикла.SubMatches(1));
				Если Токен = "цикл" Тогда
					ГлубинаЦикла = ГлубинаЦикла + 1;
					Если ГлубинаЦикла > 0 Тогда
						РезультатТекста = ирОбщий.ЗначенияВМассивЛкс(ВхождениеЦикла);
						Прервать;
					КонецЕсли;
				Иначе
					ГлубинаЦикла = ГлубинаЦикла - 1;
				КонецЕсли;
			КонецЦикла;
		Иначе
			мРегВыражение.Pattern = шПредИмяПрямое + ЭкранированноеСлово + "(" + шПрисвоение + "[ \t]*(?=;|\n\s*(?:Конец|Исключение|Иначе))|" + шОбходКоллекции + ")";
			РезультатТекста = мРегВыражение.НайтиВхождения(мТекстДляПоискаОпределения);
		КонецЕсли;
		Если РезультатТекста.Количество() > 0 Тогда
			ПоследнееВхождение = РезультатТекста[РезультатТекста.Количество() - 1];
			ПоследнееОпределение = ПоследнееВхождение.SubMatches(0);
			//Если ПоследнееВхождение.SubMatches(1) <> Неопределено Тогда
			//	// Это присвоение
			//	ПоследнееОпределение = ПоследнееВхождение.SubMatches(1);
			//Иначе
			//	// Это обход коллекции
			//	ПоследнееОпределение = ПоследнееВхождение.SubMatches(20);
			//КонецЕсли;
		КонецЕсли;
	КонецЕсли;
	Возврат ПоследнееОпределение;

КонецФункции

//.
// Возвращаемое значение:
//    Строка - 
Функция ЗалитьРазметкуТекстовогоЛитералаСохраняяПозиции(Знач Текст = "") Экспорт
	Если Не ЗначениеЗаполнено(Текст) Тогда
		Текст = мТекстДляПоискаОпределения;
	КонецЕсли;
	Если Лев(Текст, 1) = """" Тогда
		Текст = " " + Сред(Текст, 2);
	КонецЕсли; 
	Если Прав(Текст, 1) = """" Тогда
		Текст = Лев(Текст, СтрДлина(Текст) - 1) + " ";
	КонецЕсли;
	Текст = СтрЗаменить(Текст, "|", " ");
	Возврат Текст;
КонецФункции

// .
// Параметры:
//  ИмяТаблицы		 - 	 - 
//  ПакетЗапросов	 - см. НовыйПакетЗапросов() - 
// 
// Возвращаемое значение:
//  Число - 
//
Функция НайтиИндексЗапросаСозданияВременнойТаблицы(Знач ИмяТаблицы, Знач ПакетЗапросов = Неопределено) Экспорт
	Если ПакетЗапросов = Неопределено Тогда
		ПакетЗапросов = мПакетЗапросов;
	КонецЕсли;
	Если ПакетЗапросов = Неопределено Тогда
		Возврат Неопределено;
	КонецЕсли;
	ПодготовитьПакетЗапросов(ПакетЗапросов);
	СтруктураПакета = ПакетЗапросов.Структура;
	ЭлементСписка = СтруктураПакета.НайтиПоЗначению(НРег(ИмяТаблицы));
	Если ЭлементСписка <> Неопределено Тогда
		ИндексЗапроса = СтруктураПакета.Индекс(ЭлементСписка);
		ПакетЗапросов.Вставить("ИндексВПакете", ИндексЗапроса);
	КонецЕсли;
	Возврат ИндексЗапроса;
КонецФункции

Процедура ПодготовитьПакетЗапросов(Знач ПакетЗапросов) Экспорт
	Если ПакетЗапросов.Структура = Неопределено Тогда
		Если ПакетЗапросов.ТекстыЗапросов = Неопределено Тогда
			ПакетЗапросов.ТекстыЗапросов = мПлатформа.РазбитьГрубоТекстПакетногоЗапросаНаЗапросы(ПакетЗапросов.Текст,, ПакетЗапросов.Позиции0Запросов);
		КонецЕсли;
		ПакетЗапросов.Структура = мПлатформа.СоздаваемыеВременныеТаблицыПакетаЗапросов(ПакетЗапросов.ТекстыЗапросов,,,, Истина);
	КонецЕсли;
КонецПроцедуры

//.
// Параметры:
//    ИндексЗапроса - Число, Неопределено - 
Процедура ЗагрузитьЗапросПакетаПоИндексу(Знач ПакетЗапросов, Знач ИндексЗапроса) Экспорт
	мТекстБлока = ПакетЗапросов.ТекстыЗапросов[ИндексЗапроса];
	мТекстДляПоискаОпределения = мТекстБлока; 
	мПозицияТекстаДляПоискаОпределения = ПакетЗапросов.Позиции0Запросов[ИндексЗапроса]; // В режиме языка запросов мПозицияТекстаДляПоискаОпределения начинается с 0
	Если ПакетЗапросов.КоординатыТекста <> Неопределено Тогда
		Позиция0Блока = ?(ПакетЗапросов.КоординатыТекста.Метод <> Неопределено, ПакетЗапросов.КоординатыТекста.Метод.ПозицияТела, 1);
		мПозицияТекстаДляПоискаОпределения = мПозицияТекстаДляПоискаОпределения + Позиция0Блока + ПакетЗапросов.КоординатыТекста.Позиция0ВБлоке;
	КонецЕсли;
КонецПроцедуры

// Вычисляет массив структур типа дочернего контекста.
//
// Параметры:
//  РодительскиеСтрутурыТипа - см. мПлатформа.НоваяТаблицаТипов - родительских структур типа;
//  ТекущееСлово - Строка - дочернеее слово;
//  ТипСлова     - Строка - тип слова;
//  ТекущийИндекс - Строка, *Неопределено - выражение в квадратных скобках;
//  ТекущиеАргументы - Строка - аргументы метода;
//  ПредшествующийТекст - Строка" - текст для поиска определения таблицы в режиме языка запросов.
//
// Возвращаемое значение:
//  МассивСтрутурТипа - Массив - дочерних структур типа.
//
Функция ВычислитьТипДочернегоЭлемента(Знач РодительскиеСтрутурыТипа, Знач ТекущееСлово, Знач ТипСлова, Знач ТекущийИндекс = Неопределено, Знач ТекущиеАргументы = "", Знач ПредшествующийТекст = "",
	Знач ПолныйАнализСоставаТипов = Истина, выхЛиПеременнаяМодуля = Ложь, Знач ПозицияВМетоде = 0, ТаблицаТипов = Неопределено, Знач ДляСвойства = "", Знач ЗапретВычисленияВМодуле = Ложь) Экспорт 

	#Если Сервер И Не Сервер Тогда
		мПлатформа = Обработки.ирПлатформа.Создать(); 
		ПолеТекста = Обработки.ирОболочкаПолеТекста.Создать();
	#КонецЕсли  
	Если мРекурсивныйПуть = Неопределено Тогда
		ИнициироватьРекурсивныйПуть();
	КонецЕсли;
	ТаблицаСвойствТипа = мПлатформа.НоваяТаблицаСлов(); // Ускорение
	Если ТаблицаТипов = Неопределено Тогда
		ТаблицаТипов = мПлатформа.НоваяТаблицаТипов(); 
	КонецЕсли;  
	//ЛиЭтоКонструкторСтруктуры = Истина
	//	И ТипСлова = "Конструктор"
	//	И ирОбщий.СтрокиРавныЛкс(ТекущееСлово, "Структура");
	СчетчикТипов = 0;
	ПараметрыИсходящегоВызова = Неопределено;
	ЭтоЛокальныйКонтекст = Ложь;
	ЛиВместеСЛокальнымКонтекстом = Ложь;
	ЕстьПроизвольныйТип = Ложь;
	НаследоватьОбрезку = ЗначениеЗаполнено(ТекущийИндекс);
	ЗапретитьВычислятьТипыМетодовМодулей = Истина  
		И ТипСлова = "Метод"
		И ТекущиеАргументы = "(" + ИмяФиктивногоПараметра() + ")";
	РазрешитьВытеснять = Не мПлатформа.мРежимПроверкиМодуля Или ТипСлова <> "Метод";
	БазовоеРасширениеКонфигурации = БазовоеРасширениеКонфигурации();
	Для Каждого РодительскаяСтруктураТипа Из РодительскиеСтрутурыТипа Цикл
		СчетчикТипов = СчетчикТипов + 1;
		Если Истина
			И Не ПолныйАнализСоставаТипов
			И СчетчикТипов > 50
		Тогда 
			Прервать;
		КонецЕсли; 
		Если РодительскаяСтруктураТипа.ИмяОбщегоТипа = "НеизвестныйКонтекст" Тогда
			Продолжить;
		КонецЕсли;

		//ЭтоЛокальныйКонтекст = РодительскаяСтруктураТипа.ИмяОбщегоТипа = "Локальный";  // Всегда идет первым
		//Если ЭтоЛокальныйКонтекст Тогда
		//	ЛиВместеСЛокальнымКонтекстом = Истина; // Используется на следующих проходах цикла!
		//КонецЕсли;
		//	
		Если РодительскаяСтруктураТипа.ИмяОбщегоТипа = "Локальный" Тогда // Всегда идет первым
			ЛиВместеСЛокальнымКонтекстом = Истина;
			ЭтоЛокальныйКонтекст = Истина;  
			Если РодительскиеСтрутурыТипа.Количество() > 1 Тогда
				Продолжить;
			КонецЕсли;
		КонецЕсли;

		Если РодительскаяСтруктураТипа.ИмяОбщегоТипа = "Произвольный" Тогда
			ЕстьПроизвольныйТип = Истина;
		КонецЕсли;
		ВиртуальнаяТаблица = Неопределено;
		ТаблицаТиповПоПравилу = Неопределено;
		МетаданныеРодителя = РодительскаяСтруктураТипа.Метаданные;
		Если Истина  
			И ЗначениеЗаполнено(ТекущийИндекс)
			И РодительскаяСтруктураТипа.ИмяОбщегоТипа = "ВременныеТаблицыЗапроса" 
			И ТипЗнч(РодительскаяСтруктураТипа.Метаданные) = Тип("Структура")
		Тогда
			ИмяВременнойТаблицы = ВычислитьЗначениеВыражения(ТекущееСлово,,,, ПозицияВМетоде);
			ПостроительЗапроса = НайтиЗапросВременнойТаблицы(ИмяВременнойТаблицы, РодительскаяСтруктураТипа.Метаданные); 
			Если ПостроительЗапроса <> Неопределено Тогда
				СтруктраТипа = мПлатформа.НоваяСтруктураТипа("ВременнаяТаблицаЗапроса");
				СтруктраТипа.Метаданные = ПостроительЗапроса;
				СтруктраТипа.ДержательМетаданных = РодительскаяСтруктураТипа.ДержательМетаданных;
				мПлатформа.ДобавитьВТаблицуТипов(ТаблицаТипов, СтруктраТипа);
				Прервать;
			КонецЕсли;
		КонецЕсли;
		Если Истина
			И ЭтоЛокальныйКонтекст
			И Найти(РодительскаяСтруктураТипа.ИмяОбщегоТипа, "Объект.") > 0
			И ТекущееСлово = "ДополнительныеСвойства"
			И мМетодМодуля <> Неопределено
			И (Ложь
				Или мМетодМодуля.НИмя = НРег("ПередЗаписью")
				Или мМетодМодуля.НИмя = НРег("ПриЗаписи")
				Или мМетодМодуля.НИмя = НРег("ОбработкаПроведения"))
		Тогда
			ТаблицаТиповФорм = ТаблицаТиповОсновнойФормыОбъекта(РодительскаяСтруктураТипа);
			Для Каждого СтруктураТипаФормы Из ТаблицаТиповФорм Цикл
				МодульФормы = мПлатформа.ПодготовитьМодульМетаданных(СтруктураТипаФормы);
				Если ирОбщий.ЛиИмяТипаФормыЛкс(СтруктураТипаФормы.ИмяОбщегоТипа) Тогда
					ИмяОбработчика = "ПередЗаписьюНаСервере";
					ИмяПеременнойОбъекта = "ТекущийОбъект";
				Иначе
					ИмяОбработчика = "ПередЗаписью";
					ИмяПеременнойОбъекта = "ЭтотОбъект";
				КонецЕсли;
				СтрокаМетода = МодульФормы.Методы.Найти(НРег(ИмяОбработчика), "НИмя");
				Если СтрокаМетода = Неопределено Тогда
					Продолжить;
				КонецЕсли;
				АнализаторМодуляФормы = мПлатформа.ПолеТекстаМодуля(МодульФормы);
				АнализаторМодуляФормы.ЗагрузитьМетодМодуля(СтрокаМетода);
				ТаблицаТиповДопСвойств = АнализаторМодуляФормы.ВычислитьТипЗначенияВыражения(ИмяПеременнойОбъекта + "." + ТекущееСлово,,,,,,,,,,,,, ДляСвойства);
				мПлатформа.ДобавитьВТаблицуТипов(ТаблицаТипов, ТаблицаТиповДопСвойств);
			КонецЦикла;
		КонецЕсли;
		Если Не ЗначениеЗаполнено(ТекущийИндекс) Тогда
			Если Истина
				И ЭтоЛокальныйКонтекст
				И ТипСлова = "Свойство"
				И ПозицияВМетоде >= 0 // Чтобы в комментарии к методу нельзя было ссылаться на соседние параметры
			Тогда
				СтрокаПараметра = СтрокаПараметраМетодаМодуля(ТекущееСлово);
				Если СтрокаПараметра <> Неопределено Тогда
					ТаблицаТиповИсточник = Неопределено;
					Если Истина
						И мМетодМодуля.КлючевыеПараметры <> Неопределено
						И мМетодМодуля.КлючевыеПараметры.Свойство(ТекущееСлово, ТаблицаТиповИсточник) 
					Тогда
						Если ТаблицаТиповИсточник <> Неопределено Тогда
							мПлатформа.ДобавитьВТаблицуТипов(ТаблицаТипов, ТаблицаТиповИсточник);
							Прервать;
						КонецЕсли;
					КонецЕсли;
					ТаблицаТиповПараметра = ВычислитьТипПараметраМетодаМодуля(СтрокаПараметра.Владелец(), СтрокаПараметра, ДляСвойства); 
					мПлатформа.ДобавитьВТаблицуТипов(ТаблицаТипов, ТаблицаТиповПараметра); 
					Прервать;
				КонецЕсли;
			КонецЕсли;
			Если мЯзыкПрограммы = 1 Тогда
				Если ЭтоЛокальныйКонтекст Тогда  
					Если Лев(ТекущееСлово, 1) = "&" Тогда 
						ТаблицаТиповТаблицыПараметра = Неопределено;
						Если Истина
							И мПакетЗапросов <> Неопределено
							И мПакетЗапросов.Свойство("Параметры")
							И мПакетЗапросов.Параметры.Свойство(Сред(ТекущееСлово, 2), ТаблицаТиповТаблицыПараметра) 
							И ТаблицаТиповТаблицыПараметра <> Неопределено
							И ТаблицаТиповТаблицыПараметра.Количество() > 0
						Тогда 
							СтруктраТипа = мПлатформа.НоваяСтруктураТипа("ВременнаяТаблица");
							СтруктраТипа.Метаданные = ТаблицаТиповТаблицыПараметра[0].Метаданные;
							мПлатформа.ДобавитьВТаблицуТипов(ТаблицаТипов, СтруктраТипа);
							Прервать;
						КонецЕсли;    
					ИначеЕсли ирОбщий.СтрокиРавныЛкс(ТекущееСлово, "ЗНАЧЕНИЕ") Тогда
						ИмяМД = ирОбщий.ПервыеФрагментыЛкс(ТекстБезКрайнихСимволов(ТекущиеАргументы));
						ОбъектМД = Метаданные.НайтиПоПолномуИмени(ИмяМД);
						Если ОбъектМД <> Неопределено Тогда
							СтруктраТипа = мПлатформа.СтруктураТипаИзКонкретногоТипа(Тип(ирОбщий.ИмяТипаИзПолногоИмениМДЛкс(ИмяМД)));
							мПлатформа.ДобавитьВТаблицуТипов(ТаблицаТипов, СтруктраТипа);
						КонецЕсли;
					Иначе
						МенеджерВременныхТаблиц = РодительскаяСтруктураТипа.ДержательМетаданных;
						Если МенеджерВременныхТаблиц = Неопределено Тогда
							МенеджерВременныхТаблиц = мМенеджерВременныхТаблиц;
						КонецЕсли;
						ПостроительЗапроса = НайтиЗапросВременнойТаблицы(ТекущееСлово, МенеджерВременныхТаблиц);
						Если ПостроительЗапроса <> Неопределено Тогда
							СтруктраТипа = мПлатформа.НоваяСтруктураТипа("ВременнаяТаблица");
							СтруктраТипа.Метаданные = ПостроительЗапроса;
							СтруктраТипа.ДержательМетаданных = МенеджерВременныхТаблиц;   
							мПлатформа.ДобавитьВТаблицуТипов(ТаблицаТипов, СтруктраТипа);
							Прервать;
						КонецЕсли;
					КонецЕсли;
				Иначе
					ВиртуальнаяТаблица = Новый Структура("Выражение, НомерСтроки");
					ВиртуальнаяТаблица.Выражение = "." + ТекущееСлово; // Тут мы пока не уверены, это обращение к полю или виртуальной таблице
					Если ЗначениеЗаполнено(ТекущиеАргументы) Тогда
						//ВиртуальнаяТаблица.Выражение = ВиртуальнаяТаблица.Выражение + "." + ТекущиеАргументы;  // Кажется это было сделано умышленно
						ВиртуальнаяТаблица.Выражение = ВиртуальнаяТаблица.Выражение + ТекущиеАргументы; // https://www.hostedredmine.com/issues/958394
					КонецЕсли;
					ВиртуальнаяТаблица.НомерСтроки = СтрЧислоСтрок(ПредшествующийТекст);
				КонецЕсли;
			КонецЕсли;
		КонецЕсли;
		ТаблицаСвойствТипа.Очистить();
		МожноУточнитьТип = Истина;
		СтрокаОписанияМетода = Неопределено;
		ПравилоВычисленияФункции = Неопределено;
		Модуль = МодульМетаданныхКонтекста(РодительскаяСтруктураТипа, ЭтоЛокальныйКонтекст И ЗапретВычисленияВМодуле);
		Если Ложь
			Или ТаблицаТиповПоПравилу <> Неопределено
			Или ЗапретитьВычислятьТипыМетодовМодулей
		Тогда
			ВычислятьТипыМетодовМодулей = Ложь;
		Иначе
			ВычислятьТипыМетодовМодулей = Неопределено;
		КонецЕсли;
		ПараметрыЗаполнения = мПлатформа.НовыеПараметрыЗаполненияСлов(ТипСлова, БазовоеРасширениеКонфигурации, мЯзыкПрограммы, Конфигурация,,,, мФлагиКомпиляции, ТекущееСлово, Модуль,
			ВычислятьТипыМетодовМодулей, ТаблицаСвойствТипа, ЭтоЛокальныйКонтекст,,,,,, ТекущийИндекс, ДляСвойства, ЛиВместеСЛокальнымКонтекстом, ВиртуальнаяТаблица);
		Если Не ЗначениеЗаполнено(ТекущийИндекс) Тогда
			мПлатформа.СловаКонтекстаПредопределенные(РодительскаяСтруктураТипа, ПараметрыЗаполнения);
			Если ТаблицаСвойствТипа.Количество() > 0 Тогда
				МожноУточнитьТип = Ложь;
				МаксКоличествоВариантов = 5;
				КоличествоВариантов = 0;
				Для Каждого СтрокаСлова Из ТаблицаСвойствТипа Цикл
					//Если Истина
					//	И ЛиЭтоКонструкторСтруктуры
					//	И СтрокаСлова.ТаблицаТипов[0].СтрокаОписания.Слово <> "По ключам и значениям"
					//Тогда
					//	Продолжить;
					//КонецЕсли;
					Если СтрокаСлова.МожноУточнитьТип Тогда
						МожноУточнитьТип = СтрокаСлова.МожноУточнитьТип;
					КонецЕсли;
					ТаблицаТиповВарианта = СтрокаСлова.ТаблицаТипов;
					мПлатформа.ДобавитьВТаблицуТипов(ТаблицаТипов, ТаблицаТиповВарианта,, РазрешитьВытеснять);
					Если Истина
						//И ТипЗнч(РодительскаяСтруктураТипа.Метаданные) = Тип("Структура")
						//И ТипЗнч(РодительскаяСтруктураТипа.Метаданные) = Тип("ПостроительЗапроса")
						И ТаблицаТиповВарианта[0].Метаданные = РодительскаяСтруктураТипа.Метаданные 
					Тогда
						НаследоватьОбрезку = Истина;
					КонецЕсли;
					КоличествоВариантов = КоличествоВариантов + 1;
					Если КоличествоВариантов >= МаксКоличествоВариантов Тогда
						Прервать;
					КонецЕсли; 
				КонецЦикла;
				Если ТипСлова = "Метод" Тогда
					СтрокаОписанияМетода = ТаблицаТипов[0].СтрокаОписания;
				КонецЕсли;
			ИначеЕсли Истина
				И ЗначениеЗаполнено(РодительскаяСтруктураТипа.ТипЯзыка) 
				И РодительскаяСтруктураТипа.ИмяОбщегоТипа = "Строка" 
			Тогда 
				ЗаполнитьЗначенияСвойств(ТаблицаТипов.Добавить(), РодительскаяСтруктураТипа); 
				Продолжить;
			КонецЕсли;
			Если ТипСлова = "Метод" Тогда
				// Ищем правило вычисления
				ПравилоВычисленияФункции = НайтиПравилоВычисленияФункции(ТекущееСлово, РодительскаяСтруктураТипа, ЭтоЛокальныйКонтекст);
				Если ПравилоВычисленияФункции <> Неопределено Тогда 
					Если ПараметрыИсходящегоВызова = Неопределено Тогда
						ПараметрыИсходящегоВызова = РазобратьФактическиеПараметрыВызова(ТекущиеАргументы);
					КонецЕсли;
					мРекурсивныйПуть.ДобавлятьКлючевыеПараметры = Истина; // Для Вычислить()
					ТаблицаТиповПоПравилу = Вычислить(ПравилоВычисленияФункции.Правило + "(РодительскаяСтруктураТипа, ПараметрыИсходящегоВызова, ТекущееСлово, ПредшествующийТекст, ПозицияВМетоде, ТаблицаТипов, ДляСвойства)"); // см. мПлатформа.НоваяТаблицаТипов()
					мРекурсивныйПуть.ДобавлятьКлючевыеПараметры = Ложь;
					Если Истина
						И ТаблицаТиповПоПравилу <> Неопределено 
						И ТаблицаТиповПоПравилу.Количество() > 0
						И ТаблицаТипов <> ТаблицаТиповПоПравилу
					Тогда 
						// Перенес ниже
					Иначе 
						ТаблицаТиповПоПравилу = Неопределено;
					КонецЕсли;
				КонецЕсли;
			КонецЕсли;
			Если Истина
				И Не МожноУточнитьТип 
				И ТаблицаТиповПоПравилу = Неопределено 
			Тогда
				Продолжить;
			КонецЕсли;
		КонецЕсли;
		Если МожноУточнитьТип Тогда
			Если ЗапретВычисленияВМодуле И ТипСлова = "Свойство" Тогда
				выхЛиПеременнаяМодуля = Истина;
			КонецЕсли;
			Если Истина
				И ЭтоЛокальныйКонтекст 
				И мМодульМетаданных <> Неопределено 
				И Не ЗапретВычисленияВМодуле
			Тогда
				СтруктураКлюча = Новый Структура("НИмя", Нрег(ТекущееСлово));  
				НайденныеСтроки = ТаблицаЛокальногоКонтекста(ТипСлова).НайтиСтроки(СтруктураКлюча);
				Если НайденныеСтроки.Количество() > 0 Тогда
					// Это локальный метод или свойство модуля
					СтрокаСлова = НайденныеСтроки[0];
					Если Истина
						И СтрокаСлова.Вычислено
						И СтрокаСлова.ТаблицаТипов = Неопределено
						И ТипСлова = "Свойство"
					Тогда
						// тип переменной определен через одноименный метод
						Прервать;
					ИначеЕсли ТаблицаТиповПоПравилу <> Неопределено Тогда
						СтрокаОписанияМетода = СтрокаСлова; 
					Иначе
						Если мЯзыкПрограммы <> 1 Тогда
							ПолеТекстаПрограммыВызова = КопияКомпоненты();
							Если ТипСлова = "Метод" Тогда
								ТаблицаТиповСловаМодуля = мПлатформа.ПодготовитьТипРезультатаМетода(СтрокаСлова, мМодульМетаданных, ПолеТекстаПрограммыВызова,, ДляСвойства); // TODO Переделать на СловаМетаданные(), чтобы видеть методы расширяемого модуля
							Иначе
								выхЛиПеременнаяМодуля = мМодульМетаданных.Имя <> мПлатформа.ИмяДинамическогоМодуля(); 
								ТаблицаТиповСловаМодуля = мПлатформа.ПодготовитьТипЗначенияПеременнойМодуля(СтрокаСлова, мМодульМетаданных, ПолеТекстаПрограммыВызова, ДляСвойства); 
							КонецЕсли;  
						КонецЕсли;
						ТаблицаТиповСловаМодуля = мПлатформа.ТаблицаТиповСловаМодуля(СтрокаСлова, мМодульМетаданных, ТаблицаТиповСловаМодуля);
						Если Истина
							И мЯзыкПрограммы <> 1
							И ЗначениеЗаполнено(ТекущиеАргументы) 
							И ТипСлова = "Метод" 
						Тогда
							//ПолеТекстаПрограммыВызова.мМетодМодуля = мМетодМодуля;
							ТаблицаТиповМетода = ВычислитьТипФункцииСФактПараметрами(СтрокаСлова, ТекущиеАргументы, ПредшествующийТекст, ПолныйАнализСоставаТипов, ПараметрыИсходящегоВызова,
								ПолеТекстаПрограммыВызова, ДляСвойства);
							Если ТаблицаТиповМетода <> Неопределено Тогда
								ТаблицаТиповСловаМодуля = ТаблицаТиповМетода;
							КонецЕсли;
						КонецЕсли;
						мПлатформа.ДобавитьВТаблицуТипов(ТаблицаТипов, ТаблицаТиповСловаМодуля);  
						Если Ложь
							Или ТипСлова = "Метод" 
							Или мПлатформа.ЛиДетальностьТиповДостаточна(ТаблицаТипов, 4) // 4 нужно чтобы ТаблицаЗначений без метаданных от реквизита обычной формы не выходила сразу и дальше в нее добавилась натуральная таблица
						Тогда
							Прервать; 
						КонецЕсли;
						// Продолжаем вычисление, чтобы в модуле обычной формы переменная модуля ее объекта могла расчитаться по модулю объекта
						ЭтоЛокальныйКонтекст = Ложь;
						//Продолжить;
					КонецЕсли;
				КонецЕсли;
			КонецЕсли;
			ТаблицаСвойствТипа.Очистить();
			Если Истина
				И СтрокаОписанияМетода = Неопределено
				//И (Ложь
				//	Или Не ЭтоЛокальныйКонтекст 
				//	Или Не ЗапретВычисленияВМодуле)
			Тогда
				мПлатформа.СловаКонтекстаМетаданные(РодительскаяСтруктураТипа, ПараметрыЗаполнения);
			Иначе 
				// была бесконечная рекурсия при анализе этого модуля из-за вычисления Обработка.ирКонсольЗапросов.Форма.ДеревоЗапроса
			КонецЕсли;
			Если ТаблицаСвойствТипа.Количество() > 0 Тогда
				Для Каждого СтрокаСлова Из ТаблицаСвойствТипа Цикл
					ТаблицаТиповИсточник = СтрокаСлова.ТаблицаТипов;
					Если ТаблицаТиповИсточник = Неопределено Тогда
						Продолжить;
					КонецЕсли;
					Если ТаблицаТиповПоПравилу <> Неопределено Тогда
						Если ТаблицаТиповИсточник.Количество() > 0 Тогда
							СтрокаОписанияМетода = ТаблицаТиповИсточник[0].СтрокаОписания;
						КонецЕсли;
						Прервать;
					КонецЕсли;
					Если Ложь 
						Или Найти(СтрокаСлова.Слово, "<") = 0
						Или ТаблицаТипов.Количество() = 0
						Или Найти(ТаблицаТипов[0].ИмяОбщегоТипа, "<") > 0
					Тогда
						Если ТаблицаТиповИсточник.Количество() > 0 Тогда
							СтрокаОписания = ТаблицаТиповИсточник[0].СтрокаОписания; 
							Если Истина
								И ЗначениеЗаполнено(ТекущиеАргументы)
								И ТипСлова = "Метод"
								И ТипЗнч(СтрокаОписания) = Тип("СтрокаТаблицыЗначений")
								И СтрокаОписания.Владелец().Колонки.Найти("ЛиЭкспорт") <> Неопределено
								И ПравилоВычисленияФункции = Неопределено
							Тогда 
								ТаблицаТиповМетода = ВычислитьТипФункцииСФактПараметрами(СтрокаОписания, ТекущиеАргументы, ПредшествующийТекст, ПолныйАнализСоставаТипов, ПараметрыИсходящегоВызова,, ДляСвойства);
								Если ТаблицаТиповМетода <> Неопределено Тогда
									ТаблицаТиповИсточник = ТаблицаТиповМетода;
								КонецЕсли;
							КонецЕсли;
							Если Найти(СтрокаСлова.Слово, "<") > 0 Тогда
								НаследоватьОбрезку = Истина;
							КонецЕсли;
							мПлатформа.ДобавитьВТаблицуТипов(ТаблицаТипов, ТаблицаТиповИсточник,, РазрешитьВытеснять);
						КонецЕсли;
					КонецЕсли; 
				КонецЦикла;
				//Если ТаблицаТиповПоПравилу = Неопределено Тогда
				//	Продолжить;
				//КонецЕсли;
			КонецЕсли;
		КонецЕсли;
		Если ТаблицаТиповПоПравилу <> Неопределено Тогда
			Если СтрокаОписанияМетода <> Неопределено Тогда
				ТаблицаТиповПоПравилу.ЗаполнитьЗначения(СтрокаОписанияМетода, "СтрокаОписания");
			КонецЕсли;
			ТаблицаТипов.Очистить();
			мПлатформа.ДобавитьВТаблицуТипов(ТаблицаТипов, ТаблицаТиповПоПравилу);
			Прервать;
		КонецЕсли;
	КонецЦикла;
	Если Истина
		И НаследоватьОбрезку
		И РодительскиеСтрутурыТипа.Колонки.Метаданные.Заголовок <> "" 
	Тогда
		ТаблицаТипов.Колонки.Метаданные.Заголовок = ЗаголовокФлагОбрезкиГлубины();
	КонецЕсли;
	Если Истина
		И ТаблицаТиповСловаМодуля <> Неопределено 
		И ТаблицаТипов.Количество() > 1 
	Тогда
		СтрокаПустогоТипа = ТаблицаТипов.Найти("", "ИмяОбщегоТипа");
		Если СтрокаПустогоТипа <> Неопределено Тогда
			ТаблицаТипов.Удалить(СтрокаПустогоТипа);
		КонецЕсли;
	КонецЕсли;
	Если Истина
		И ЕстьПроизвольныйТип
		И ТаблицаТипов.Количество() = 0
	Тогда
		// Чтобы не обнаруживалась ошибка проверкой модуля
		СтруктраТипа = мПлатформа.НоваяСтруктураТипа("Произвольный");
		мПлатформа.ДобавитьВТаблицуТипов(ТаблицаТипов, СтруктраТипа);
	КонецЕсли;
	Возврат ТаблицаТипов;
КонецФункции

//.
// Параметры:
//    ТекущееСлово - Строка - 
//    МенеджерВременныхТаблиц - см. НовыйМенеджерВременныхТаблиц() - 
//    ПакетЗапросовТекущий - Структура - 
// Возвращаемое значение:
//    ПостроительЗапроса, Неопределено - 
Функция НайтиЗапросВременнойТаблицы(Знач ТекущееСлово, Знач МенеджерВременныхТаблиц = Неопределено, выхПакетЗапросовТекущий = Неопределено, выхИндексЗапроса = Неопределено) Экспорт
	Если Истина
		И ЯзыкПрограммы = 0 
		И ТипЗнч(МенеджерВременныхТаблиц) <> Тип("Структура") 
	Тогда
		МенеджерВременныхТаблиц = мМенеджерВременныхТаблиц;
	КонецЕсли;
	ПостроительЗапроса = Неопределено;                                     
	Если МенеджерВременныхТаблиц = Неопределено Тогда
		выхПакетЗапросовТекущий = мПакетЗапросов;
		выхИндексЗапроса = НайтиИндексЗапросаСозданияВременнойТаблицы(ТекущееСлово, выхПакетЗапросовТекущий);
	Иначе 
		Если выхИндексЗапроса = Неопределено И ТипЗнч(МенеджерВременныхТаблиц) = Тип("Структура") Тогда
			ПакетыЗапросов = МенеджерВременныхТаблиц.ПакетыЗапросов;
			Для Индекс = 1 - ПакетыЗапросов.Количество() По 0 Цикл // Обратный обход
				ПакетЗапросовЦикл = ПакетыЗапросов[-Индекс];
				выхИндексЗапроса = НайтиИндексЗапросаСозданияВременнойТаблицы(ТекущееСлово, ПакетЗапросовЦикл);
				Если выхИндексЗапроса <> Неопределено Тогда
					выхПакетЗапросовТекущий = ПакетЗапросовЦикл;
					Прервать;
				КонецЕсли;
			КонецЦикла;
		КонецЕсли;
	КонецЕсли;
	Если выхИндексЗапроса <> Неопределено Тогда
		//Для Каждого ПакетЦикл Из МенеджерВременныхТаблиц.ПакетыЗапросов Цикл
		//	ПодготовитьПакетЗапросов(ПакетЦикл);
		//КонецЦикла;
		ПостроительЗапроса = мПлатформа.ПостроительПакетаЗапросовДоИндекса(выхПакетЗапросовТекущий.ТекстыЗапросов, выхИндексЗапроса, выхПакетЗапросовТекущий.Параметры, ТекущееСлово, МенеджерВременныхТаблиц);
		Если Истина
			И ПостроительЗапроса <> Неопределено 
			И ПостроительЗапроса.ВыбранныеПоля.Количество() = 0 
		Тогда
			ПостроительЗапроса = Неопределено;
		Иначе 
			//ирОбщий.СкопироватьКоллекциюЛкс(выхПакетЗапросовТекущий.Параметры, ПостроительЗапроса.Параметры); // Вроде пока не нужно
		КонецЕсли;
	КонецЕсли;
	Возврат ПостроительЗапроса;
КонецФункции

//.
// Параметры:
//    ПараметрыМетода - ТаблицаЗначений - 
//    СтрокаПараметраМетода - СтрокаТаблицыЗначений - 
//    ДляСвойства - Строка - 
Функция ВычислитьТипПараметраМетодаМодуля(Знач ПараметрыМетода, Знач СтрокаПараметраМетода, Знач ДляСвойства = "", Знач СтрокаМетода = Неопределено) Экспорт
	Если СтрокаМетода = Неопределено Тогда
		СтрокаМетода = мМетодМодуля;
	КонецЕсли;
	Если мРекурсивныйПуть = Неопределено Тогда
		ИнициироватьРекурсивныйПуть();
	КонецЕсли;
	ЛиКлючевойПараметр = Истина
		И мРекурсивныйПуть.ВычислениеРезультатаМетода = СтрокаМетода.Имя 
		И мРекурсивныйПуть.ДобавлятьКлючевыеПараметры; // Для Вычислить()
	Если Ложь
		Или Не СтрокаПараметраМетода.Вычислено
		//Или мРекурсивныйПуть.ДопКлючКэша = Неопределено // Так будет циклическая рекурсия при проверке этого модуля
		Или ЛиКлючевойПараметр
		Или ЛиТаблицаТиповКэшНеГотова(СтрокаПараметраМетода.ТаблицаТипов, ДляСвойства) 
	Тогда
		Если Ложь
			Или Не ЗначениеЗаполнено(ДляСвойства) 
			//Или мПлатформа.мРежимПроверкиМодуля
		Тогда
			СтрокаПараметраМетода.Вычислено = Истина;
		КонецЕсли;
	ИначеЕсли Ложь 
		Или ДляСвойства = ИмяФиктивногоСвойства()
		Или СтрокаПараметраМетода.ТаблицаТипов.Колонки.Метаданные.Заголовок = ""
	Тогда
		ТаблицаТипов = СтрокаПараметраМетода.ТаблицаТипов; // Попадание в кэш параметра
		//ТаблицаТипов = ТаблицаТипов.Скопировать(); // против циклической ссылки
		//ТаблицаТипов.ЗаполнитьЗначения(СтрокаПараметраМетода, "СтрокаОписания"); 
		Возврат ТаблицаТипов;
	КонецЕсли;
	
	//Если мРекурсивныйПуть = Неопределено Тогда
	//	ИнициироватьРекурсивныйПуть();
	//КонецЕсли;
	ПройденныеВызовы = мРекурсивныйПуть.ВходящиеВызовы;
	Если ЗначениеЗаполнено(ДляСвойства) Тогда
		ТаблицаТипов = мПлатформа.НоваяТаблицаТипов();
	Иначе
		Если СтрокаПараметраМетода.ТаблицаТипов = Неопределено Тогда
			СтрокаПараметраМетода.ТаблицаТипов = мПлатформа.НоваяТаблицаТипов();
		КонецЕсли;
		ТаблицаТипов = СтрокаПараметраМетода.ТаблицаТипов;
	КонецЕсли;
	// Тип из комментария
	ТипЗначения = СтрокаПараметраМетода.ТипЗначения;
	Если ПустаяСтрока(ТипЗначения) И ЗначениеЗаполнено(СтрокаПараметраМетода.Описание) Тогда
		ТипЗначения = мПлатформа.ГрязныйТипИзОписанияПараметра(СтрокаПараметраМетода.Описание);
	КонецЕсли; 
	Если ЗначениеЗаполнено(СтрокаПараметраМетода.Значение) Тогда
		Если Истина                         
			И НРег(СтрокаПараметраМетода.Значение) = "неопределено" 
			И ТаблицаТипов.Найти("Неопределено", "ИмяОбщегоТипа") = Неопределено
		Тогда
			СтруктураТипа = мПлатформа.НоваяСтруктураТипа("Неопределено");
			СтруктураТипа.Вставить("Детальность", 1); 
			ЗаполнитьЗначенияСвойств(ТаблицаТипов.Добавить(), СтруктураТипа);
			//мПлатформа.ДобавитьВТаблицуТипов(ТаблицаТипов, СтруктураТипа);
		// Тип Булево добавляем в см. мПлатформа.ПараметрыМетодаМодуля
		//ИначеЕсли ирОбщий.ЛиБулевыйЛитералЛкс(СтрокаПараметраМетода.Значение) Тогда
		//	мПлатформа.ДобавитьВТаблицуТипов(ТаблицаТипов, НоваяСтруктураТипа("Булево"));
		КонецЕсли;
	КонецЕсли;
	СтрокаСистемногоПараметра = Неопределено;
	Если мМодульМетаданных.СтруктураТипа <> Неопределено Тогда
		// События формы
		ФормаМодуля = мМодульМетаданных.СтруктураТипа.Метаданные;
		Если Истина
			И мПлатформа.ЛиИмяМодуляФормы(мМодульМетаданных.Имя)
			И ирОбщий.ЛиФормаИлиИмитаторЛкс(ФормаМодуля) 
		Тогда
			СтрокаОбработчика = Неопределено;
			ВсеОбработчикиСобытий = ирОбщий.ВсеОбработчикиСобытийФормаЛкс(ФормаМодуля, Истина);
			Если ВсеОбработчикиСобытий <> Неопределено Тогда
				СтрокаОбработчика = ВсеОбработчикиСобытий.Найти(НРег(СтрокаМетода.Имя), "НОбработчик");
			КонецЕсли;
			Если СтрокаОбработчика = Неопределено Тогда 
				ВсеСобытия = ирОбщий.СобытияЭлементаФормыЛкс(ФормаМодуля);
				СтрокаСобытия = ирОбщий.НайтиЭлементКоллекцииЛкс(ВсеСобытия, "НСлово", НРег(СтрокаМетода.Имя));
				Если СтрокаСобытия <> Неопределено Тогда
					мПлатформа.ДобавитьОтсутствиеЭлементаФормы(ФормаМодуля, "Событие:" + СтрокаМетода.Имя);
					СтрокаОбработчика = ВсеОбработчикиСобытий.Добавить();
					СтрокаОбработчика.Событие = СтрокаМетода.Имя;
					СтрокаОбработчика.Обработчик = СтрокаМетода.Имя;
					СтрокаОбработчика.НОбработчик = НРег(СтрокаМетода.Имя);
					СтрокаОбработчика.СтрокаОписания = СтрокаСобытия;
				ИначеЕсли ВсеОбработчикиСобытий <> Неопределено Тогда
					// Если прямой связи нет, то подберем вероятную по шаблону имени <Элемент><Событие>
					ВсеИменаСобытийЭлементовФормы = мПлатформа.ВсеИменаСобытийЭлементовФормы();
					Для Каждого КлючИЗначение Из ВсеИменаСобытийЭлементовФормы Цикл
						Если Не ирОбщий.СтрКончаетсяНаЛкс(СтрокаМетода.Имя, КлючИЗначение.Ключ) Тогда
							Продолжить;
						КонецЕсли;
						ИмяЭлементаФормы = ирОбщий.СтрокаБезПоследнегоФрагментаЛкс(СтрокаМетода.Имя, КлючИЗначение.Ключ);
						Если ПустаяСтрока(ИмяЭлементаФормы) Тогда
							Продолжить;
						КонецЕсли;
						СтрокаОбработчика = ВсеОбработчикиСобытий.Добавить();
						СтрокаОбработчика.Имя = ИмяЭлементаФормы;
						СтрокаОбработчика.Событие = КлючИЗначение.Ключ;
						СтрокаОбработчика.Обработчик = СтрокаМетода.Имя;
						СтрокаОбработчика.НОбработчик = НРег(СтрокаМетода.Имя);
						СтрокаОбработчика.СтрокаОписания = КлючИЗначение.Значение;
						Прервать;
					КонецЦикла;
				КонецЕсли;
			КонецЕсли;
			Если СтрокаОбработчика <> Неопределено Тогда
				ЭлементФормы = Неопределено;
				ПараметрыСобытия = мПлатформа.ПараметрыМетодаПлатформы(СтрокаОбработчика.СтрокаОписания);
				Если ЗначениеЗаполнено(СтрокаОбработчика.Имя) Тогда
					СтрокаПараметраЭлемент = ПараметрыСобытия.Вставить(0);
					СтрокаПараметраЭлемент.Слово = "Элемент";
					Если ТипЗнч(ФормаМодуля) = Тип("Форма") Тогда
						Попытка
							ЭлементФормы = Вычислить("ФормаМодуля.ЭлементыФормы." + СтрокаОбработчика.Имя);
						Исключение
						КонецПопытки;
					ИначеЕсли ТипЗнч(ФормаМодуля) = ирОбщий.ТипУправляемаяФормаЛкс() Тогда
						// Нельзя использовать Найти(), т.к. возможен имитатор формы
						Попытка
							ЭлементФормы = ФормаМодуля.Элементы[СтрокаОбработчика.Имя];
						Исключение 
						КонецПопытки;
					КонецЕсли;
				КонецЕсли;
				СтрокаСистемногоПараметра = ЗаполнитьОписанияПараметровИзСобытия(СтрокаОбработчика.СтрокаОписания, СтрокаПараметраМетода, ПараметрыСобытия);
				Если ЭлементФормы <> Неопределено Тогда
					ШаблонСтруктурыТипа = Новый Структура("Метаданные, ДержательМетаданных", ЭлементФормы, ФормаМодуля);
					Если ирОбщий.СтрокиРавныЛкс(СтрокаПараметраМетода.Имя, "Элемент") Тогда 
						Если ТипЗнч(ЭлементФормы) = Тип("Структура") Тогда
							СтрукутраТипаЭлемента = мПлатформа.СтруктураТипаИзКонкретногоТипа(ЭлементФормы.Тип,, ШаблонСтруктурыТипа);   
						Иначе 
							СтрукутраТипаЭлемента = мПлатформа.СтруктураТипаИзЗначения(ЭлементФормы,, ШаблонСтруктурыТипа);
						КонецЕсли;
						мПлатформа.ДобавитьВТаблицуТипов(ТаблицаТипов, СтрукутраТипаЭлемента);
						Возврат ТаблицаТипов;
					ИначеЕсли Истина                         
						И ПараметрыМетода[0].Имя = "Элемент"
						И (Ложь
							Или СтрокаПараметраМетода.Имя = "ВыбраннаяСтрока"
							Или СтрокаПараметраМетода.Имя = "Строка"
							Или СтрокаПараметраМетода.Имя = "Родитель"
							Или СтрокаПараметраМетода.Имя = "ДанныеСтроки")
						И ТипЗнч(ФормаМодуля) = Тип("Форма")
					Тогда 
						ПараметрыЗаполнения = мПлатформа.НовыеПараметрыЗаполненияСлов("Свойство",,,,,,,, "ТекущиеДанные");
						ТаблицаДочернихСлов = мПлатформа.СловаКонтекстаПредопределенные(мПлатформа.СтруктураТипаИзЗначения(ЭлементФормы,, ШаблонСтруктурыТипа), ПараметрыЗаполнения);
						мПлатформа.ДобавитьВТаблицуТипов(ТаблицаТипов, ТаблицаДочернихСлов[0].ТаблицаТипов);
						Если СтрокаПараметраМетода.Имя = "ДанныеСтроки" Тогда
							мПлатформа.ДобавитьВТаблицуТипов(ТаблицаТипов, мПлатформа.НоваяСтруктураТипа("Неопределено"));
						КонецЕсли;
						Возврат ТаблицаТипов;
					ИначеЕсли Истина                         
						И ПараметрыМетода[0].Имя = "Элемент"
						И ТипЗнч(ФормаМодуля) = Тип("Форма")
					Тогда
						Попытка
							Тип = Тип(СтрокаПараметраМетода.ТипЗначения);
						Исключение
							Тип = Неопределено;
						КонецПопытки;
						Если Тип <> Неопределено Тогда
							мПлатформа.ДобавитьВТаблицуТипов(ТаблицаТипов, мПлатформа.СтруктураТипаИзКонкретногоТипа(Тип,, ШаблонСтруктурыТипа));
						КонецЕсли;
						Возврат ТаблицаТипов;
					КонецЕсли; 
				Иначе 
					Если СтрокаПараметраМетода.Имя = "ТекущийОбъект" Тогда 
						КлючОсновногоОбъекта = ирОбщий.КлючОсновногоОбъектаФормыЛкс(ФормаМодуля);                    
						СтруктураТипа = мПлатформа.СтруктураТипаИзЗначения(КлючОсновногоОбъекта);
						СтруктураТипа.ИмяОбщегоТипа = СтрЗаменить(СтруктураТипа.ИмяОбщегоТипа, "Ссылка.", "Объект.");
						мПлатформа.ДобавитьВТаблицуТипов(ТаблицаТипов, СтруктураТипа);
					//  Пока неполезно, т.к. ключи соответствия не собираем
					//ИначеЕсли Истина
					//	И СтрокаПараметраМетода.Имя = "Настройки" 
					//	И (Ложь 
					//		Или СтрокаОбработчика.СтрокаОписания.Слово = "ПередЗагрузкойДанныхИзНастроекНаСервере"
					//		Или СтрокаОбработчика.СтрокаОписания.Слово = "ПриЗагрузкеДанныхИзНастроекНаСервере")
					//Тогда 
					//	// TODO сделать сбор ключей соответствия аналогично структуре
					//	СтрокаОбработчикаСохранения = ВсеОбработчикиСобытий.Найти(НРег("ПриСохраненииДанныхВНастройкахНаСервере"), "НОбработчик");
					//	Если СтрокаОбработчикаСохранения <> Неопределено Тогда
					//		СтрокаМетодаСохранения = мМодульМетаданных.Методы.Найти(СтрокаОбработчикаСохранения.НОбработчик, "НИмя");
					//		АнализаторМетода = КопияКомпоненты();
					//		АнализаторМетода.ЗагрузитьМетодМодуля(СтрокаМетодаСохранения);
					//		ТаблицаТиповСохранения = АнализаторМетода.ВычислитьТипЗначенияВыражения("Настройки");
					//		мПлатформа.ДобавитьВТаблицуТипов(ТаблицаТипов, ТаблицаТиповСохранения);
					//	КонецЕсли;
					КонецЕсли;
				КонецЕсли;
			КонецЕсли; 
		КонецЕсли;
		// Подсказка по параметрам обработчиков методов Http-сервисов
		Если Истина
			И ирОбщий.СтрНачинаетсяСЛкс(мМодульМетаданных.Имя, "HTTPСервис.")
			И ПараметрыМетода.Индекс(СтрокаПараметраМетода) = 0
			И ТипЗнч(мМодульМетаданных.СтруктураТипа.Метаданные) = Тип("ОбъектМетаданных")
		Тогда
			ОбъектМД = мМодульМетаданных.СтруктураТипа.Метаданные; // ОбъектМетаданныхHTTPСервис
			Для Каждого Шаблон Из ОбъектМД.ШаблоныURL Цикл
				Если ирОбщий.НайтиЭлементКоллекцииЛкс(Шаблон.Методы, "Обработчик", СтрокаМетода.Имя) <> Неопределено Тогда 
					мПлатформа.ДобавитьВТаблицуТипов(ТаблицаТипов, мПлатформа.СтруктураТипаИзКонкретногоТипа(Тип("HTTPЗапрос")));
				КонецЕсли;
			КонецЦикла;
		КонецЕсли;
		// Подсказка по параметрам обработчиков модуля команды
		Если Истина
			И ирОбщий.СтрКончаетсяНаЛкс(мМодульМетаданных.Имя, ".МодульКоманды")
			И СтрокаМетода.Имя = "ОбработкаКоманды"
			И ТипЗнч(мМодульМетаданных.СтруктураТипа.Метаданные) = Тип("ОбъектМетаданных")
		Тогда
			ОбъектМД = мМодульМетаданных.СтруктураТипа.Метаданные; // ОбъектМетаданныхКоманда
			Если ПараметрыМетода.Индекс(СтрокаПараметраМетода) = 0 Тогда
				Если ОбъектМД.РежимИспользованияПараметра = РежимИспользованияПараметраКоманды.Множественный Тогда
					// Мультиметка240808_112012
					//СтруктураТипа = мПлатформа.НоваяСтруктураТипа("Массив" + "[" + ПредставлениеМассиваСтруктурТипов(ТаблицаТиповЭлементов) + "]");
					СтруктураТипа = мПлатформа.НоваяСтруктураТипа("Массив");
					СтруктураТипа.Метаданные = мПлатформа.ДобавитьВТаблицуТипов(, ОбъектМД.ТипПараметраКоманды);
					ТаблицаТипов.Очистить();
					мПлатформа.ДобавитьВТаблицуТипов(ТаблицаТипов, СтруктураТипа);
				Иначе
					мПлатформа.ДобавитьВТаблицуТипов(ТаблицаТипов, ОбъектМД.ТипПараметраКоманды);
				КонецЕсли;
			КонецЕсли;
			СобытияМодуля = ирКэш.СобытияПоИмениОбщегоТипаЛкс("МодульКоманды");
			СтрокаСистемногоПараметра = ЗаполнитьОписанияПараметровИзСобытия(СобытияМодуля[0], СтрокаПараметраМетода);
		КонецЕсли;
		// Подсказка по параметрам обработчиков с фиксированными именами
		Если Ложь
			Или ирОбщий.СтрКончаетсяНаЛкс(мМодульМетаданных.Имя, ".МодульКоманды") 
			Или ирОбщий.СтрКончаетсяНаЛкс(мМодульМетаданных.Имя, ".МодульМенеджера") 
			Или ирОбщий.СтрКончаетсяНаЛкс(мМодульМетаданных.Имя, ".МодульОбъекта")
			Или ирОбщий.СтрКончаетсяНаЛкс(мМодульМетаданных.Имя, ".МодульНабораЗаписей")
			Или ирОбщий.СтрКончаетсяНаЛкс(мМодульМетаданных.Имя, ".МодульМенеджераЗначения")
			Или ирОбщий.СтрКончаетсяНаЛкс(мМодульМетаданных.Имя, ".МодульУправляемогоПриложения")
			Или ирОбщий.СтрКончаетсяНаЛкс(мМодульМетаданных.Имя, ".МодульОбычногоПриложения")
			Или ирОбщий.СтрКончаетсяНаЛкс(мМодульМетаданных.Имя, ".МодульСеанса")
		Тогда
			СобытияМодуля = ирКэш.СобытияПоИмениОбщегоТипаЛкс(мМодульМетаданных.СтруктураТипа.ИмяОбщегоТипа);
			СтрокаСобытия = ирОбщий.НайтиЭлементКоллекцииЛкс(СобытияМодуля, "НСлово", НРег(СтрокаМетода.Имя));
			Если СтрокаСобытия <> Неопределено Тогда 
				СтрокаСистемногоПараметра = ЗаполнитьОписанияПараметровИзСобытия(СтрокаСобытия, СтрокаПараметраМетода);
				СтруктураТипа = мПлатформа.НоваяСтруктураТипа(СтрокаСистемногоПараметра.ТипЗначения);
				Если Истина
					И СтрокаСобытия.Слово = "ОбработкаПолученияДанныхВыбора" 
					И СтрокаПараметраМетода.Имя = "Параметры"
				Тогда
					СтруктураТипа.Метаданные = Новый Структура("СтрокаПоиска, Отбор, ВыборГруппИЭлементов, СпособПоискаСтроки, ПолнотекстовыйПоиск, РежимПолученияДанныхВыбора");
				ИначеЕсли Истина
					И СтрокаСобытия.Слово = "ПриКопировании" 
					И СтрокаПараметраМетода.Имя = "ОбъектКопирования"
				Тогда
					СтруктураТипа.Метаданные = мМодульМетаданных.СтруктураТипа.Метаданные;
				КонецЕсли;
				мПлатформа.ДобавитьВТаблицуТипов(ТаблицаТипов, СтруктураТипа);
			КонецЕсли;
		КонецЕсли;
		// Подсказка по параметру "Источник" обработчиков подписок на события
		Если Истина
			И СтрокаПараметраМетода.Имя = "Источник"
			И ирОбщий.СтрНачинаетсяСЛкс(мМодульМетаданных.Имя, "ОбщийМодуль.")
			И ТипЗнч(мМодульМетаданных.СтруктураТипа.Метаданные) = Тип("ОбъектМетаданных")
		Тогда
			ОбъектМД = мМодульМетаданных.СтруктураТипа.Метаданные; // ОбъектМетаданныхОбщийМодуль
			ИмяМодуля = ОбъектМД.Имя; 
			Для Каждого ПодпискаНаСобытие Из Метаданные.ПодпискиНаСобытия Цикл
				Если ирОбщий.СтрокиРавныЛкс(ПодпискаНаСобытие.Обработчик, ИмяМодуля + "." + СтрокаМетода.Имя) Тогда 
					// Для СправочникМенеджер будет пустой набор типов https://www.hostedredmine.com/issues/989526
					мПлатформа.ДобавитьВТаблицуТипов(ТаблицаТипов, ПодпискаНаСобытие.Источник);
				КонецЕсли;
			КонецЦикла;
		КонецЕсли; 
	КонецЕсли; 
	Если Не ЗначениеЗаполнено(ТипЗначения) И СтрокаСистемногоПараметра <> Неопределено Тогда
		ТипЗначения = СтрокаСистемногоПараметра.ТипЗначения;
	КонецЕсли;
	Если ЗначениеЗаполнено(ТипЗначения) Тогда 
		ТипЗначения = СокрЛП(ТипЗначения);
		ТаблицаТиповНазначенных = ТаблицаТиповИзТекста(СтрокаПараметраМетода.ТипЗначения, СтрокаПараметраМетода.Описание,, ДляСвойства,,,, СтрокаПараметраМетода.ПозицияСОписанием);
		мПлатформа.ДобавитьВТаблицуТипов(ТаблицаТипов, ТаблицаТиповНазначенных);  
		Если мПлатформа.ЛиДетальностьТиповДостаточна(ТаблицаТипов, 4, Истина) Тогда 
			Перейти ~Выход;
		КонецЕсли;
		Если ТаблицаТипов.Количество() > 0 Тогда
			ИмяОбщегоТипа = ТаблицаТипов[0].ИмяОбщегоТипа;
			Если Ложь
				// TODO переделать на мМассивТиповСМетаданными Мультиметка121095773
				Или ИмяОбщегоТипа = "ТаблицаЗначений"
				Или ИмяОбщегоТипа = "ДеревоЗначений"
				Или ИмяОбщегоТипа = "СтрокаТаблицыЗначений"
				Или ИмяОбщегоТипа = "СтрокаДереваЗначений"
				Или ИмяОбщегоТипа = "ВыборкаИзРезультатаЗапроса"
				Или ИмяОбщегоТипа = "Структура"
				Или ИмяОбщегоТипа = "ФиксированнаяСтруктура"
				Или ИмяОбщегоТипа = "Соответствие"
				Или ИмяОбщегоТипа = "ФиксированноеСоответствие"
				Или ИмяОбщегоТипа = "СписокЗначений"
				Или ИмяОбщегоТипа = "Массив"
				Или ИмяОбщегоТипа = "Запрос"
				Или ИмяОбщегоТипа = "РезультатЗапроса"
				Или ИмяОбщегоТипа = "ПостроительЗапроса"
				Или ИмяОбщегоТипа = "ПостроительОтчета"
				Или ИмяОбщегоТипа = "МенеджерВременныхТаблиц"
				Или ИмяОбщегоТипа = "Отбор"
				Или ИмяОбщегоТипа = "ДанныеФормыСтруктура"
				Или ИмяОбщегоТипа = "ДанныеФормыСтруктураСКоллекцией"
				Или ИмяОбщегоТипа = "ДанныеФормыКоллекция"
				Или ИмяОбщегоТипа = "ДанныеФормыКоллекцияЭлементовДерева"
				Или ИмяОбщегоТипа = "ДанныеФормыДерево"
				Или ИмяОбщегоТипа = "ДанныеФормыЭлементКоллекции"
				Или ИмяОбщегоТипа = "ДанныеФормыЭлементДерева"
				Или ИмяОбщегоТипа = "Форма"
				Или ИмяОбщегоТипа = "ТабличноеПоле"
				Или ИмяОбщегоТипа = "КоманднаяПанель"
				Или ИмяОбщегоТипа = "ФормаКлиентскогоПриложения"
				Или ИмяОбщегоТипа = "УправляемаяФорма"
				Или ИмяОбщегоТипа = "ДекорацияФормы"
				Или ИмяОбщегоТипа = "ГруппаФормы"
				Или ИмяОбщегоТипа = "ПолеФормы"
				Или ИмяОбщегоТипа = "ТаблицаФормы"
				Или ИмяОбщегоТипа = "Произвольный"
			Тогда
				//
			Иначе 
				Перейти ~Выход;
			КонецЕсли;
		КонецЕсли;
	КонецЕсли;
	
	Если Не ирОбщий.СтрокиРавныЛкс(ТипЗначения, "Произвольный") Тогда
		// Анализ входящих вызовов
		ВызывающиеМодули = Новый Массив;
		Если СтрокаМетода.ВызывающиеМодули <> Неопределено Тогда
			Для Каждого ИмяВызывающегоМодуля Из СтрокаМетода.ВызывающиеМодули Цикл
				ВызывающиеМодули.Добавить(ИмяВызывающегоМодуля);
			КонецЦикла;
		КонецЕсли;
		ВызывающиеМодули.Добавить(мМодульМетаданных.Имя);
		СчетчикВызовов = 0;
		МинДетальность = 3;
		МаксЧислоВызовов = 3;
		ШаблонПараметра = "(" + шВыражениеПрограммы + ")?" + шРазделитель + "*(?:$|,|\))";
		ИндексПараметра = ПараметрыМетода.Индекс(СтрокаПараметраМетода);
		НачалоИмениМодуляОбъекта = "";
		Если Истина
			И СтрокаМетода.ЛиЭкспорт
			И (Ложь
				Или ирОбщий.СтрКончаетсяНаЛкс(мИмяМодуля, "МодульОбъекта", Истина) 
				Или ирОбщий.СтрКончаетсяНаЛкс(мИмяМодуля, "МодульМенеджера", Истина))
		Тогда
			НачалоИмениМодуляОбъекта = ирОбщий.СтрокаБезПоследнегоФрагментаЛкс(мИмяМодуля);
			ОбъектМД = мМодульМетаданных.СтруктураТипа.Метаданные; // ОбъектМетаданныхСправочник
			Если ТипЗнч(ОбъектМД) = Тип("ОбъектМетаданных") Тогда
				ОсновнаяМетаФорма = ирОбщий.ОсновнаяФормаОбъектаМДЛкс(ОбъектМД);
				ПозицияФорм = ВызывающиеМодули.Количество();
				МаксЧислоФорм = 20;
				Счетчик = 0;
				Для Каждого МетаФорма Из ОбъектМД.Формы Цикл
					ИмяМодуляФормы = НачалоИмениМодуляОбъекта + ".Форма." + МетаФорма.Имя;
					Если ОсновнаяМетаФорма = МетаФорма Тогда
						ВызывающиеМодули.Вставить(ПозицияФорм, ИмяМодуляФормы);
					Иначе
						ВызывающиеМодули.Добавить(ИмяМодуляФормы);
					КонецЕсли;
					Счетчик = Счетчик + 1;
					Если Счетчик = МаксЧислоФорм Тогда
						Прервать;
					КонецЕсли;
				КонецЦикла;
			КонецЕсли;
		КонецЕсли;
		ПрямоеИмяМодуля = ПрямоеИмяМодуляИзПолного(мИмяМодуля);
		Для Каждого ИмяМодуля Из ВызывающиеМодули Цикл
			ПолеТекстаПрограммыВызова = Неопределено;
			Если ИмяМодуля = мМодульМетаданных.Имя Тогда
				ЭтоФорма = Неопределено;
				ВызывающийМодуль = мМодульМетаданных;
			Иначе
				ЭтоФорма = Найти(ИмяМодуля, ".Форма.") > 0;
				СтруктураТипаМодуля = Неопределено;
				Если ЭтоФорма Тогда
					ИмяМодуля = ИмяМодуля + ".Форма.Модуль";
				Иначе
					Если Найти(ИмяМодуля, ".Команда.") > 0 Тогда   
						ТаблицаТиповМодуля = ТаблицаТиповИзТекста("см. " + ИмяМодуля);
					ИначеЕсли Найти(ИмяМодуля, "Объект.") > 0  Тогда
						ТаблицаТиповМодуля = ТаблицаТиповИзТекста(ИмяМодуля);
					Иначе
						ТаблицаТиповМодуля = ВычислитьТипЗначенияВыражения(ИмяМодуля,,,,,, Ложь);
					КонецЕсли;
					Если ТаблицаТиповМодуля.Количество() > 0 Тогда
						СтруктураТипаМодуля = ЛучшийТипИзТаблицыТипов(ТаблицаТиповМодуля);
						ИмяМодуля = мПлатформа.ИмяМодуляИзСтруктурыТипа(СтруктураТипаМодуля);
					КонецЕсли;
				КонецЕсли;
				Если Не ЗначениеЗаполнено(ИмяМодуля) Тогда
					Продолжить;
				КонецЕсли;
				ВызывающийМодуль = мПлатформа.МодульМетаданныхИзКэша(ИмяМодуля);
			КонецЕсли;
			ТекстМодуля = Неопределено;
			Если ВызывающийМодуль <> Неопределено Тогда
				ТекстМодуля = ВызывающийМодуль.Текст;
			КонецЕсли;
			Если ТекстМодуля = Неопределено Тогда
				ТекстМодуля = ирКэш.ПолеТекстаМодуляБезСтруктурыТипаЛкс(ИмяМодуля).мОригинальныйТекст;
				Если ВызывающийМодуль <> Неопределено Тогда
					ВызывающийМодуль.Текст = ТекстМодуля;
				КонецЕсли;
			КонецЕсли;
			Если Ложь
				Или ИмяМодуля = мМодульМетаданных.Имя 
				Или ирОбщий.СтрНайтиЛкс("." + ИмяМодуля + ".", "." + НачалоИмениМодуляОбъекта + ".",,,, Ложь) > 0 // Мультиметка240720_160801 TODO переделать на анализ основного объекта формы
			Тогда
				// Поиск вызовов всех методов с кэшированием
				ПрямыеВызовыМетодов = мПлатформа.ПрямыеВызовыМетодовМодуля(ИмяМодуля);
				Если ПрямыеВызовыМетодов = Неопределено Тогда
					Если Истина
						И ИмяМодуля <> мМодульМетаданных.Имя
						И ирОбщий.НайтиРегВыражениеЛкс(ТекстМодуля, СтрокаМетода.Имя + "[""\(]",, Ложь,,,, Истина, мРегВыражение).Количество() = 0 
					Тогда
						Продолжить;
					КонецЕсли;
					ПрямыеВызовыМетодов = мПлатформа.НовыйИндексПоискаВызововСловаВМодуле(ВызывающийМодуль,, ЭтоФорма);
					ЗаполнитьИндексПоискаВызововМетодовВМодуле(ПрямыеВызовыМетодов, ТекстМодуля);
					мПлатформа.УстановитьПрямыеВызовыМетодовМодуля(ИмяМодуля, ПрямыеВызовыМетодов);
					ирОбщий.ДобавитьИндексВТаблицуЛкс(ПрямыеВызовыМетодов.Вызовы, "НомерСлова");
					ПрямыеВызовыМетодов.Вызовы.Колонки.Добавить("ПараметрыВызова"); // Строка, Массив 
					ПрямыеВызовыМетодов.Вызовы.Колонки.Добавить("ТекстВхождения"); // Строка               
					ПрямыеВызовыМетодов.Вызовы.Колонки.Добавить("Метод"); // Строка       
					Если ПрямыеВызовыМетодов.Оповещения <> Неопределено Тогда
						ирОбщий.ДобавитьИндексВТаблицуЛкс(ПрямыеВызовыМетодов.Оповещения, "НомерСлова");
						ПрямыеВызовыМетодов.Оповещения.Колонки.Добавить("Метод"); // Строка
					КонецЕсли;
				КонецЕсли;
			Иначе
				// Поиск вызовов только текущего метода без кэширования
				ПрямыеВызовыМетодов = мПлатформа.НовыйИндексПоискаВызововСловаВМодуле(ВызывающийМодуль,, ЭтоФорма);
				ШаблонОповещения = "";
				Если ПрямыеВызовыМетодов.Оповещения <> Неопределено Тогда
					// Добавляет 7мс на каждые 10к строк
					ШаблонОповещения = шПредИмяПрямое + "Новый\s+ОписаниеОповещения\s*\(\s*""(" + шИмя + ")""\s*,\s*(?:"+ ПрямоеИмяМодуля +")\s*,\s*(" + шПростоеВыражениеПрограммы + ")";
				КонецЕсли;
				ШаблонВнешнегоВызова = ШаблонПрямогоВызоваСлова(ПрямоеИмяМодуля + "\.(" + СтрокаМетода.Имя + ")",, Истина); 
				мПлатформа.ЗаполнитьИндексПоискаВызововСловаВМодуле(ПрямыеВызовыМетодов, ТекстМодуля, ШаблонВнешнегоВызова, ШаблонОповещения);
				ПрямыеВызовыМетодов.Вызовы.Колонки.Добавить("ПараметрыВызова"); // Строка, Массив 
				ПрямыеВызовыМетодов.Вызовы.Колонки.Добавить("ТекстВхождения"); // Строка               
				ПрямыеВызовыМетодов.Вызовы.Колонки.Добавить("Метод"); // Строка       
				Если ПрямыеВызовыМетодов.Оповещения <> Неопределено Тогда
					ирОбщий.ДобавитьИндексВТаблицуЛкс(ПрямыеВызовыМетодов.Оповещения, "НомерСлова");
					ПрямыеВызовыМетодов.Оповещения.Колонки.Добавить("Метод"); // Строка
				КонецЕсли;
			КонецЕсли;
			ОтфильтрованныеВхождения = Новый Массив; 
			НомерМетодаВИндексе = Неопределено;
			Если ПрямыеВызовыМетодов.СтруктураСлов.Свойство(СтрокаМетода.Имя, НомерМетодаВИндексе) Тогда 
				Если ВызывающийМодуль = Неопределено Тогда
					Если ЭтоФорма Тогда   
						СтруктураТипаМодуля = ВычислитьСловоФормыПоПолномуИмени(ирОбщий.СтрокаБезПоследнегоФрагментаЛкс(ИмяМодуля, ".Форма.Модуль"));
					КонецЕсли;
					ВызывающийМодуль = Неопределено;
					Если СтруктураТипаМодуля <> Неопределено Тогда
						ВызывающийМодуль = мПлатформа.ПодготовитьМодульМетаданных(СтруктураТипаМодуля);
					КонецЕсли;
					Если ВызывающийМодуль = Неопределено Тогда
						Продолжить;
					КонецЕсли;
				КонецЕсли; 
				ВхожденияВызова = ПрямыеВызовыМетодов.Вызовы.НайтиСтроки(Новый Структура("НомерСлова", НомерМетодаВИндексе));
				ВГраница = ВхожденияВызова.Количество() - 1;
				Для Счетчик = 0 По ВГраница Цикл
					// Идем с краев к середине модуля, чтобы увеличить вероятность найти выгодный вызов
					Индекс = Цел(Счетчик/2);
					Если Счетчик % 2 = 0 Тогда
						Индекс = ВГраница - Индекс;
					КонецЕсли;
					ВхождениеВызова = ВхожденияВызова[Индекс];
					ЛиПодходящее = Истина;
					Если Истина
						И ВхождениеВызова.ПозицияВхождения > СтрокаМетода.ПозицияОпределения 
						И ВхождениеВызова.ПозицияВхождения < СтрокаМетода.ПозицияТела
					Тогда
						// В области заголовка определения текущего метода
						ЛиПодходящее = Ложь;
					КонецЕсли;
					ПараметрыВызова = ВхождениеВызова.ПараметрыВызова;
					Если ПараметрыВызова = Неопределено Тогда
						Если ВхождениеВызова.ТекстВхождения = Неопределено Тогда
							ВхождениеВызова.ТекстВхождения = Сред(ТекстМодуля, ВхождениеВызова.ПозицияВхождения + 1, ВхождениеВызова.ДлинаВхождения);
						КонецЕсли;
						ПараметрыВызова = Сред(ВхождениеВызова.ТекстВхождения, Найти(Сред(ВхождениеВызова.ТекстВхождения, 2), "(") + 2);
						ВхождениеВызова.ПараметрыВызова = ПараметрыВызова;
					КонецЕсли;
					Если ТипЗнч(ПараметрыВызова) = Тип("Строка") Тогда
						// Грубая проверка, что не указан фактический параметр
						Если Ложь
							Или ПараметрыВызова = ")" // Нельзя отрезать этот символ, т.к. далее вызывается СтрокаБезКонцаЛкс
							Или ИндексПараметра > СтрЧислоВхождений(ПараметрыВызова, ",") 
						Тогда
							ЛиПодходящее = Ложь;
						КонецЕсли;
					Иначе 
						ЛиПодходящее = ПараметрыВызова.Количество() > ИндексПараметра; 
					КонецЕсли;
					Если ЛиПодходящее Тогда
						ОтфильтрованныеВхождения.Добавить(ВхождениеВызова);
						Если ОтфильтрованныеВхождения.Количество() >= МаксЧислоВызовов * 3 Тогда
							Прервать;
						КонецЕсли;
					КонецЕсли;
				КонецЦикла;
			КонецЕсли;
			Для Каждого ВхождениеВызова Из ОтфильтрованныеВхождения Цикл
				ПараметрыВызова = ВхождениеВызова.ПараметрыВызова;
				Если ТипЗнч(ПараметрыВызова) = Тип("Строка") Тогда
					ПараметрыВызова = ирОбщий.НайтиРегВыражениеЛкс(ВхождениеВызова.ПараметрыВызова, ШаблонПараметра,,,,,, Истина, мРегВыражение); // Передаем РегВыражение для ускорения
					ВхождениеВызова.ПараметрыВызова = ПараметрыВызова;
				КонецЕсли;
				#Если Сервер И Не Сервер Тогда
					ПараметрыВызова = Обработки.ирПлатформа.Создать().ВхожденияРегВыражения;
				#КонецЕсли
				// Точная проверка, что указан нужный фактический параметр
				Если ПараметрыВызова.Количество() > ИндексПараметра Тогда
					ВхождениеПараметра = ПараметрыВызова[ИндексПараметра];
					ФактическийПараметр = СокрЛП(ирОбщий.СтрокаБезКонцаЛкс(ВхождениеПараметра.ТекстВхождения));
					Если ЛиБесполезноеПрисвоениеПеременной(ФактическийПараметр) Тогда
						Если ЗначениеЗаполнено(ФактическийПараметр) Тогда
							мПлатформа.ДобавитьВТаблицуТипов(ТаблицаТипов, мПлатформа.НоваяСтруктураТипа(ФактическийПараметр));
						КонецЕсли;
						Продолжить;
					ИначеЕсли ирОбщий.ЛиБулевыйЛитералЛкс(ФактическийПараметр) Тогда
						мПлатформа.ДобавитьВТаблицуТипов(ТаблицаТипов, мПлатформа.НоваяСтруктураТипа("Булево"));
					Иначе
						Если ПолеТекстаПрограммыВызова = Неопределено Тогда
							Если ВызывающийМодуль = мМодульМетаданных Тогда
								ПолеТекстаПрограммыВызова = КопияКомпоненты();
							Иначе
								ПолеТекстаПрограммыВызова = мПлатформа.ПолеТекстаМодуля(ВызывающийМодуль);
							КонецЕсли;
						КонецЕсли;
						#Если Сервер И Не Сервер Тогда
							ПолеТекстаПрограммыВызова = Обработки.ирКлсПолеТекстаПрограммы.Создать();
						#КонецЕсли 
						//! ЗагрузитьМетодМодуляПоПозицииИРазобратьКонтекст(ВхождениеВызова.ПозицияВхождения,, ВхождениеВызова);
						НачальнаяПозицияБлока = ПолеТекстаПрограммыВызова.ЗагрузитьМетодМодуляПоПозицииИРазобратьКонтекст(ВхождениеВызова.ПозицияВхождения,, ВхождениеВызова);
						Если ПолеТекстаПрограммыВызова.мМетодМодуля = Неопределено Тогда
							ИмяВызывающегоМетода = мПлатформа.ИмяМетодаИнициация();
						Иначе
							ИмяВызывающегоМетода = ПолеТекстаПрограммыВызова.мМетодМодуля.Имя;
							Если Истина
								И (Ложь	
									Или ЛиКлючевойПараметр 
									Или ОтфильтрованныеВхождения.Найти(ВхождениеВызова) < ОтфильтрованныеВхождения.Количество() - 1) 
								И (Ложь
									Или ПолеТекстаПрограммыВызова.мМетодМодуля.ДлинаОпределения > 20000 // Для ускорения. Для Обработка.ирКлсПолеТекстаПрограммы.Форма.КонструкторЗапроса.ЗаполнитьПоТокену() нужно 20000
									Или ИмяВызывающегоМетода = СтрокаМетода.Имя)
							Тогда
								// Пропускаем прямую рекурсию и большие методы, кроме последнего
								Продолжить;
							КонецЕсли;
						КонецЕсли;
						КлючВызова = ИмяВызывающегоМетода + "-" + СтрокаМетода.Имя + "-" + СтрокаПараметраМетода.Имя + "-" + ДляСвойства;
						Если ПройденныеВызовы[КлючВызова] = Неопределено Тогда 
							ПройденныеВызовы[КлючВызова] = 1; // Таким образом мы не более одного вызова из каждого ключа проверяем
							ПозицияФактическогоПараметра = ВхождениеВызова.ПозицияВхождения - НачальнаяПозицияБлока; // TODO более точно посчитать
							ТаблицаТиповИсточник = ПолеТекстаПрограммыВызова.ВычислитьТипЗначенияВыражения(ФактическийПараметр,,,,,, Ложь,,,,, ПозицияФактическогоПараметра,, ДляСвойства);
							Если мПлатформа.ЛиДетальностьТиповДостаточна(ТаблицаТиповИсточник, 1) Тогда 
								мПлатформа.ДобавитьВТаблицуТипов(ТаблицаТипов, ТаблицаТиповИсточник);
								Если мПлатформа.ЛиДетальностьТиповДостаточна(ТаблицаТиповИсточник, МинДетальность) Тогда
									Перейти ~Выход;
								КонецЕсли;
							КонецЕсли;
							СчетчикВызовов = СчетчикВызовов + 1;
							Если МаксЧислоВызовов = СчетчикВызовов Тогда
								Прервать;
							КонецЕсли;
						КонецЕсли;
					КонецЕсли;
				КонецЕсли;
			КонецЦикла;
			Если Истина
				И СтрокаМетода.Клиент
				И ИндексПараметра = 1 // Было 0 (иногда нужно) 
				И ПараметрыМетода.Количество() = 2 
				И ПрямыеВызовыМетодов.Оповещения <> Неопределено
			Тогда
				ВхожденияВызова = ПрямыеВызовыМетодов.Оповещения.НайтиСтроки(Новый Структура("НомерСлова", НомерМетодаВИндексе));
				Для Каждого ВхождениеВызова Из ВхожденияВызова Цикл
					Если ПолеТекстаПрограммыВызова = Неопределено Тогда
						Если ВызывающийМодуль = мМодульМетаданных Тогда
							ПолеТекстаПрограммыВызова = КопияКомпоненты();
						Иначе
							ПолеТекстаПрограммыВызова = мПлатформа.ПолеТекстаМодуля(ВызывающийМодуль);
						КонецЕсли;
					КонецЕсли;
					#Если Сервер И Не Сервер Тогда
						ПолеТекстаПрограммыВызова = Обработки.ирКлсПолеТекстаПрограммы.Создать();
					#КонецЕсли 
					НачальнаяПозицияБлока = ПолеТекстаПрограммыВызова.ЗагрузитьМетодМодуляПоПозицииИРазобратьКонтекст(ВхождениеВызова.ПозицияВхождения,, ВхождениеВызова);
					ТаблицаТиповИсточник = ПолеТекстаПрограммыВызова.ВычислитьТипЗначенияВыражения(ВхождениеВызова.Параметр,,,,,, Ложь,,,,, ВхождениеВызова.ПозицияВхождения - 1 - НачальнаяПозицияБлока,, ДляСвойства);
					Если мПлатформа.ЛиДетальностьТиповДостаточна(ТаблицаТиповИсточник, 1) Тогда 
						мПлатформа.ДобавитьВТаблицуТипов(ТаблицаТипов, ТаблицаТиповИсточник);
						Если мПлатформа.ЛиДетальностьТиповДостаточна(ТаблицаТиповИсточник, МинДетальность) Тогда
							Перейти ~Выход;
						КонецЕсли;
					КонецЕсли;
				КонецЦикла;
			КонецЕсли;
		КонецЦикла;
	КонецЕсли;
~Выход: 
	// Ключевым является обязательный параметр удовлетворяющий хотя бы одному из условий:
	// - составной тип
	// - тип "Произвольный"
	// - тип с собственными метаданными
	Если ЛиКлючевойПараметр Тогда
		Если Не ЗначениеЗаполнено(СтрокаМетода.ТипЗначения) Тогда
			СтрокаМетода.ТипЗначения = "Произвольный"; // чтобы последующая проверка типа результата метода не удалила ключевые параметры см. мПлатформа.ПодготовитьТипЗначенияПеременнойМодуля()
		КонецЕсли;
	ИначеЕсли Истина
		И Не ЛиКлючевойПараметр 
		//И ПустаяСтрока(СтрокаПараметраМетода.Значение) 
	Тогда 
		ЛиКлючевойПараметр = Истина
			И ТаблицаТипов.Найти("Строка", "ИмяОбщегоТипа") <> Неопределено
			И (Ложь
				Или Найти(мТекстБлока, "Новый Структура(" + СтрокаПараметраМетода.Имя) > 0
				Или Найти(мТекстБлока, ".Свойство(" + СтрокаПараметраМетода.Имя) > 0);
	КонецЕсли;
	Если Не ЛиКлючевойПараметр Тогда
		ЛиКлючевойПараметр = мПлатформа.ЛиНестрогаяТаблицаТипов(ТаблицаТипов, Истина, СтрокаПараметраМетода.ТипЗначения);
	КонецЕсли;
	Если ЛиКлючевойПараметр Тогда       
		//ПравилоВычисленияФункции = НайтиПравилоВычисленияФункции(СтрокаМетода.Имя, мМодульМетаданных.СтруктураТипа);
		//Если ПравилоВычисленияФункции = Неопределено Тогда
			КлючевыеПараметры = СтрокаМетода.КлючевыеПараметры;
			Если КлючевыеПараметры = Неопределено Тогда
				КлючевыеПараметры = Новый Структура;
				СтрокаМетода.КлючевыеПараметры = КлючевыеПараметры;
			КонецЕсли; 
			КлючевыеПараметры.Вставить(СтрокаПараметраМетода.Имя); 
		//КонецЕсли;
	КонецЕсли;
	Если ТаблицаТипов.Количество() = 0 Тогда
		// Добавим пустой тип чтобы строку описания в него помещать
		СтруктураТипа = ТаблицаТипов.Добавить();
		мПлатформа.ОбновитьДетальностьСтруктурыТипа(СтруктураТипа); 
	КонецЕсли;
	//ТаблицаТипов.ЗаполнитьЗначения(СтрокаПараметраМетода, "СтрокаОписания"); // Отключено, т.к. будет циклическая ссылка
	//ТаблицаТипов = ТаблицаТипов.Скопировать(); // против циклической ссылки
	//ТаблицаТипов.ЗаполнитьЗначения(СтрокаПараметраМетода, "СтрокаОписания"); 
	Если СтрокаСистемногоПараметра <> Неопределено Тогда
		ТаблицаТипов.ЗаполнитьЗначения(СтрокаСистемногоПараметра, "СтрокаОписания");
	КонецЕсли;
	Возврат ТаблицаТипов;
КонецФункции

//.
// Параметры:
//    СтруктураТипаОбъекта - Структура, Неопределено - 
// Возвращаемое значение:
//    ТаблицаЗначений, Неопределено - 
Функция ТаблицаТиповОсновнойФормыОбъекта(Знач СтруктураТипаОбъекта) Экспорт
	ТаблицаТиповМодуляФормы = ВычислитьТипДочернегоЭлемента(мПлатформа.ДобавитьВТаблицуТипов(, СтруктураТипаОбъекта), "ПолучитьФорму", "Метод");
	Возврат ТаблицаТиповМодуляФормы;
КонецФункции

// Статический.
// Параметры:
//    ПрямыеВызовыМетодов - Структура - 
//    ТекстБлока - Неопределено - 
Процедура ЗаполнитьИндексПоискаВызововМетодовВМодуле(Знач ПрямыеВызовыМетодов, Знач ТекстБлока, Знач Смещение = 0) Экспорт
	ШаблонОповещения = "";
	Если ПрямыеВызовыМетодов.Оповещения <> Неопределено Тогда
		// Добавляет 7мс на каждые 10к строк
		ШаблонОповещения = шПредИмяПрямое + "Новый\s+ОписаниеОповещения\s*\(\s*""(" + шИмя + ")""\s*,\s*(?:ЭтотОбъект|ЭтаФорма)\s*,\s*(" + шПростоеВыражениеПрограммы + ")";
	КонецЕсли;
	мПлатформа.ЗаполнитьИндексПоискаВызововСловаВМодуле(ПрямыеВызовыМетодов, ТекстБлока, ШаблонПрямогоВызоваСлова("(" + шИмя + ")",, Истина), ШаблонОповещения,, Смещение);
КонецПроцедуры

//.
// Параметры:
//    МетодМодуля - см. мМодульМетаданных.Методы.Добавить() -
//    ТекущиеАргументы - Строка - 
//    ПредшествующийТекст - Строка, Строка - 
//    ПолныйАнализСоставаТипов - Булево - 
//    ПараметрыИсходящегоВызова - Массив - 
Функция ВычислитьТипФункцииСФактПараметрами(Знач МетодМодуля, Знач ТекущиеАргументы, Знач ПредшествующийТекст, Знач ПолныйАнализСоставаТипов, Знач ПараметрыИсходящегоВызова,
	Знач ПолеТекстаПрограммыВызова = Неопределено, Знач ДляСвойства = "")
	
	Если Ложь
		Или МетодМодуля.КлючевыеПараметры = Неопределено 
		Или ТекущиеАргументы = "(" + ИмяФиктивногоПараметра() + ")"
	Тогда
		Возврат Неопределено;
	КонецЕсли;
	СчетчикиВызовов = мРекурсивныйПуть.СчетчикиВызовов; 
	КлючСчетчика = МетодМодуля.ИмяМодуля + "." + МетодМодуля.Имя;
	СчетчикВызовов = СчетчикиВызовов[КлючСчетчика];
	Если СчетчикВызовов = Неопределено Тогда
		СчетчикВызовов = 0;
	КонецЕсли;
	Если СчетчикВызовов > 0 Тогда
		// Для ускорения
		Возврат Неопределено;
	КонецЕсли;
	СчетчикВызовов = СчетчикВызовов + 1;
	СчетчикиВызовов[КлючСчетчика] = СчетчикВызовов;
	Если ПолеТекстаПрограммыВызова = Неопределено И мМодульМетаданных.Имя = МетодМодуля.ИмяМодуля Тогда
		ПолеТекстаПрограммыВызова = КопияКомпоненты();
	КонецЕсли;
	Если ПараметрыИсходящегоВызова = Неопределено Тогда
		ПараметрыИсходящегоВызова = РазобратьФактическиеПараметрыВызова(ТекущиеАргументы);
	КонецЕсли;
	ПараметрыМетода = мПлатформа.ПараметрыМетодаМодуля(МетодМодуля);
	ФактическиеПараметры = Новый Структура;
	Для Каждого КлючИЗначение Из МетодМодуля.КлючевыеПараметры Цикл 
		Если КлючИЗначение.Значение <> Неопределено Тогда
			// Защита от рекурсии. СчетчикВызовов не поможет, т.к. очищается при рекурсии в анализуемом коде.
			Возврат Неопределено;
		КонецЕсли;
		СтрокаПараметра = ПараметрыМетода.Найти(НРег(КлючИЗначение.Ключ), "НИмя");
		ИндексПараметра = ПараметрыМетода.Индекс(СтрокаПараметра);
		Если ПараметрыИсходящегоВызова.ВГраница() < ИндексПараметра Тогда
			ВыражениеПараметра = "";  
		Иначе 
			ВыражениеПараметра = ПараметрыИсходящегоВызова[ИндексПараметра];
		КонецЕсли;
		Если Не ЗначениеЗаполнено(ВыражениеПараметра) Тогда
			Продолжить;
		КонецЕсли;
		
		// ДляСвойства здесь вредно передавать, т.к. ключевые параметры часто будут иметь сложную связь с результатом функции.
		ТаблицаТиповПараметра = ВычислитьТипЗначенияВыражения(ВыражениеПараметра, ПредшествующийТекст,,,, ПолныйАнализСоставаТипов, Ложь,,, Истина); 
		Если Не мПлатформа.ЛиДетальностьТиповДостаточна(ТаблицаТиповПараметра, 1) Тогда 
			Продолжить;
		КонецЕсли;
		ФактическиеПараметры.Вставить(КлючИЗначение.Ключ, ТаблицаТиповПараметра);
	КонецЦикла;
	Если ФактическиеПараметры.Количество() = 0 Тогда
		Возврат Неопределено;
	КонецЕсли;
	МетодМодуля.КлючевыеПараметры = ФактическиеПараметры;
	ТаблицаТиповИсточник = мПлатформа.ПодготовитьТипРезультатаМетода(МетодМодуля, МетодМодуля.ИмяМодуля, ПолеТекстаПрограммыВызова, Истина, ДляСвойства);
	МетодМодуля.КлючевыеПараметры = ирОбщий.СкопироватьСтруктуруБезЗначенийЛкс(МетодМодуля.КлючевыеПараметры);
	Возврат ТаблицаТиповИсточник;
КонецФункции

//.
// Параметры:
//    ТекущиеАргументы - Строка - должна начинаться с "(" и кончаться на ")"
// Возвращаемое значение:
//    Массив - 
Функция РазобратьФактическиеПараметрыВызова(Знач ТекущиеАргументы) Экспорт
	Если Прав(ТекущиеАргументы, 1) = "(" Тогда
		ТекущиеАргументы = ТекущиеАргументы + "))"; // Пытаемся восстановить обрезованое
	КонецЕсли;
	ТекущиеАргументы = ТекстБезКрайнихСимволов(ТекущиеАргументы);
	МассивПараметров = Новый Массив;
	Если Найти(ТекущиеАргументы, ",") = 0 Тогда
		ОдинПараметр = СокрЛП(ТекущиеАргументы);
		Если ЗначениеЗаполнено(ОдинПараметр) Тогда
			МассивПараметров.Добавить(ОдинПараметр);
		КонецЕсли;
	Иначе 
		мРегВыражение.Global = Истина;
		Если мЯзыкПрограммы = 0 Тогда
			мРегВыражение.Pattern = "(" + шВыражениеПрограммы + ")?" + шРазделитель + "*,";
		Иначе
			мРегВыражение.Pattern = "(" + шВыражениеЗапроса   + ")?" + шРазделитель + "*,";
		КонецЕсли;
		Результат = мРегВыражение.НайтиВхождения(ТекущиеАргументы + ",",, Истина);
		Для Каждого Вхождение Из Результат Цикл
			МассивПараметров.Добавить(СокрЛП(Вхождение.SubMatches(0)));
		КонецЦикла;
	КонецЕсли;
	Возврат МассивПараметров;
КонецФункции

Функция ТекстБезКрайнихСимволов(Знач ТекущиеАргументы)
	
	Возврат Сред(ТекущиеАргументы, 2, СтрДлина(ТекущиеАргументы) - 2);

КонецФункции

Функция ЗаполнитьОписанияПараметровИзСобытия(СтрокаСобытия, Знач СтрокаПараметраМетода, Знач ПараметрыСобытия = Неопределено, Знач СтрокаМетода = Неопределено) Экспорт
	Если СтрокаМетода = Неопределено Тогда
		СтрокаМетода = мМетодМодуля;
	КонецЕсли;
	Результат = Неопределено;
	Если Истина
		И ЗначениеЗаполнено(СтрокаМетода.Параметры) 
		И (Ложь
			Или Не ЗначениеЗаполнено(СтрокаМетода.Параметры[0].ТипЗначения)
			Или Не ЗначениеЗаполнено(СтрокаПараметраМетода.ТаблицаТипов))
	Тогда
		Если ПараметрыСобытия = Неопределено Тогда   
			ПараметрыСобытия = мПлатформа.ПараметрыМетодаПлатформы(СтрокаСобытия);
		КонецЕсли;
		СтрокаМетода.Описание = СтрокаСобытия.Описание;
		// TODO перенести в мПлатформа.ПараметрыМетодаМодуля()
		ИндексПараметра = 0;
		МаксИндекс = СтрокаМетода.Параметры.Количество() - 1;
		Для Каждого СтрокаПараметраСобытия Из ПараметрыСобытия Цикл
			Если МаксИндекс < ИндексПараметра Тогда
				Прервать;
			КонецЕсли;
			СтрокаПараметраЦикл = СтрокаМетода.Параметры[ИндексПараметра];
			СтрокаПараметраЦикл.ТипЗначения = СтрокаПараметраСобытия.ТипЗначения;
			СтрокаПараметраЦикл.Описание = СтрокаПараметраСобытия.Описание;
			ИндексПараметра = ИндексПараметра + 1;
			Если СтрокаПараметраМетода = СтрокаПараметраЦикл Тогда
				Результат = СтрокаПараметраСобытия;
			КонецЕсли;
		КонецЦикла;
	КонецЕсли;
	Возврат Результат;
КонецФункции

// Статический.
Функция ШаблонПрямогоВызоваСлова(Знач ИмяВызова, Знач ТипСлова = "Метод", Знач ЛиШаблон = Ложь) Экспорт 
	
	Если Лев(ИмяВызова, 1) = "." Тогда
		Начало = "(?:" + шИмяСТочками + ")?";
	ИначеЕсли ТипСлова = "Конструктор" Тогда
		Начало = шПредИмяПрямое + "Новый\s+";
	Иначе
		// Начало = "(?:[^" + мПлатформа.шБуква + "\d\.\s]|^|[^\.\s]\s+)" // Более строгий, но медленный
		Начало = шПредИмяПрямое;
	КонецЕсли;
	Если Не ЛиШаблон Тогда
		ИмяВызова = ирОбщий.ТекстДляРегВыраженияЛкс(ИмяВызова);
	КонецЕсли;
	ШаблонВызова = Начало + ИмяВызова;
	Если ТипСлова = "Свойство" Тогда
		ШаблонВызова = ШаблонВызова + шПостИмяСвойства; 
	Иначе 
		ШаблонВызова = ШаблонВызова + "\s*\(((?:(?:" + шВыражениеПрограммы + ")?" + шРазделитель + "*(?=[,\)])|,)*)\)";
	КонецЕсли;
	Возврат ШаблонВызова;

КонецФункции

Функция МодульМетаданныхКонтекста(Знач РодительскаяСтрутураТипа, Знач НуженПустой = Ложь)
	
	Если НуженПустой Тогда
		МодульМетаданных = мПлатформа.ПустойМодульМетаданных();
	ИначеЕсли РодительскаяСтрутураТипа.ИмяОбщегоТипа = "Локальный" Тогда
		МодульМетаданных = мМодульМетаданных;
	Иначе
		МодульМетаданных = Неопределено;
	КонецЕсли;
	Возврат МодульМетаданных;

КонецФункции

// Определяет тип значения слова в режиме внутреннего языка.
//
// Параметры:
//  Выражение					 - Строка		 - 
//  ТекстДляПоискаОпределения	 - Строка		 - где ищем определение;
//  ПредшествующийТекст			 - 				 - 
//  РазрешитьАнализИмениТипа	 - 				 - 
//  ЭтоВызовКонструктора		 - Булево		 - передается когда выражение конструктора передано без слова "Новый"
//  ПолныйАнализСоставаТипов	 - 				 - 
//  ЛиКорневойВызов				 - 				 - 
//  ГлобальныйПоискВМодуле		 - 				 - 
//  ТаблицаТиповОтРодителя		 - 				 - 
//  ВычислитьЗначение			 - 				 - 
//  Позиция0ВМетодеОт			 - 				 - при глобальном поиске игнорируется
//  Позиция0ВМетодеДо			 - 				 - при глобальном поиске игнорируется
//  ДопКлючКэша					 - 				 - Применяется при ЛиКорневойВызов Или мРекурсивныйПуть = Неопределено. Значение Неопределено отключает кэш выражений.
//  ДляСвойства					 - Строка		 - путь к свойству, например "ПервыйБлок.Начало", для отсечения вычисления внутренней структуры передавать ИмяФиктивногоСвойства() 
//  СобиратьОшибки				 - Булево		 - 
//  ВсеПрисвоения				 - СписокЗначений, Неопределено	 - :
//  	*Значение - Число - позиция в блоке
//  	*Представление - Строка - инструкция присвоения
//  ЛиПолноеВыражение			 - 								 - 
// 
// Возвращаемое значение:
//  см. мПлатформа.НоваяТаблицаТипов()
//
Функция ВычислитьТипЗначенияВыражения(Знач Выражение = "", Знач ТекстДляПоискаОпределения = "", Знач ПредшествующийТекст = "", Знач РазрешитьАнализИмениТипа = Ложь,
	Знач ЭтоВызовКонструктора = Ложь, ПолныйАнализСоставаТипов = Истина, Знач ЛиКорневойВызов = Истина, Знач ГлобальныйПоискВМодуле = Ложь, Знач ТаблицаТиповОтРодителя = Неопределено, Знач ВычислитьЗначение = Ложь,
	Знач Позиция0ВМетодеОт = 0, Знач Позиция0ВМетодеДо = 0, Знач ДопКлючКэша = "", Знач ДляСвойства = "", СобиратьОшибки = Ложь, ВсеПрисвоения = Неопределено, ЛиПолноеВыражение = Истина) Экспорт
	
	#Если Сервер И Не Сервер Тогда
		мПлатформа = Обработки.ирПлатформа.Создать();
		мРегВыражение = Обработки.ирОболочкаРегВыражение.Создать();
	#КонецЕсли  
	Если ЛиКорневойВызов Или мРекурсивныйПуть = Неопределено Тогда
		ИнициироватьРекурсивныйПуть(Выражение, ДопКлючКэша);
	КонецЕсли;
	//Если мПлатформа.мРежимПроверкиМодуля Тогда
	//	ДляСвойства = ""; // При включенной строке проверка этого модуля 100с, а при отключенной 88с
	//КонецЕсли;
	ГлобальныйПоискВМодулеВход = ГлобальныйПоискВМодуле;
	Если ГлобальныйПоискВМодуле Тогда
		Позиция0ВМетодеОт = 0;
		Позиция0ВМетодеДо = 0;
		СтарыйМетод = мМетодМодуля;
		ЗагрузитьМетодМодуля(Неопределено);
		Если СтрДлина(мОригинальныйТекст) > 100000 Тогда
			// В больших модулях глобальный поиск типа делаем только в блоке инициации модуля
			ГлобальныйПоискВМодуле = Ложь; 
			ТекстДляПоиска = мМодульМетаданных.ТекстПоискаОпределенияСловМодуля;
			Если ТекстДляПоиска = Неопределено Тогда
				ИменаМетодов = Новый Структура;
				ИменаМетодов.Вставить("ПриСозданииНаСервере");
				ИменаМетодов.Вставить("ПриОткрытии");
				ВхожденияВызова = ирОбщий.НайтиРегВыражениеЛкс(мТекстБлока, мПлатформа.шПустоеНачалоСтроки + "(?:" + шНачалоДок + "\s*)?(" + шИмя + ")\(\)",,,,,, Истина, мРегВыражение); // Передаем РегВыражение для ускорения
				Если ВхожденияВызова.Количество() > 0 Тогда
					Для Каждого ВхождениеВызова Из ВхожденияВызова Цикл
						ИменаМетодов.Вставить(ВхождениеВызова.Группы.Submatches(0));
					КонецЦикла;
				КонецЕсли;
				ТелаМетодов = Новый Массив;
				Для Каждого КлючИЗначение Из ИменаМетодов Цикл
					СтрокаМетода = мМодульМетаданных.Методы.Найти(НРег(КлючИЗначение.Ключ), "НИмя");
					Если СтрокаМетода <> Неопределено Тогда
						ТелаМетодов.Добавить(ТелоМетода(СтрокаМетода));
					КонецЕсли;
				КонецЦикла;
				Если ТелаМетодов.Количество() > 0 Тогда
					ТелаМетодов.Вставить(0, мТекстБлока);
					ТекстДляПоиска = ирОбщий.СтрСоединитьЛкс(ТелаМетодов, Символы.ПС);
				Иначе 
					ТекстДляПоиска = мТекстБлока;
				КонецЕсли;
				мМодульМетаданных.ТекстПоискаОпределенияСловМодуля = ТекстДляПоиска;
			КонецЕсли;
			мТекстБлока = ТекстДляПоиска;
		Иначе 
			ТекстДляПоискаОпределения = мОригинальныйТекст;
		КонецЕсли;
	КонецЕсли;
	Если Не ГлобальныйПоискВМодуле Тогда 
		Если Не ЗначениеЗаполнено(ТекстДляПоискаОпределения) Тогда
			Если мЯзыкПрограммы = 1 Тогда
				ТекстДляПоискаОпределения = мТекстБлока;
			Иначе
				ТекстДляПоискаОпределения = ДиапазонТекстаДляПоиска(мТекстБлока, Позиция0ВМетодеОт, Позиция0ВМетодеДо);
			КонецЕсли;
		КонецЕсли;
		Если Не ЗначениеЗаполнено(ПредшествующийТекст) Тогда
			Если РазрешитьАнализИмениТипа И ЗначениеЗаполнено(Позиция0ВМетодеДо) Тогда
				ПредшествующийТекст = Лев(мТекстБлока, Позиция0ВМетодеДо);
			Иначе 
				ПредшествующийТекст = ТекстДляПоискаОпределения;
			КонецЕсли;
		КонецЕсли;
		Если Не ЗначениеЗаполнено(Позиция0ВМетодеДо) Тогда
			Позиция0ВМетодеДо = СтрДлина(ТекстДляПоискаОпределения);
		КонецЕсли;
		Если мЯзыкПрограммы <> ЯзыкПрограммы Тогда
			// TODO Сделать более универсально. Возможно надо сразу при разборе мТекстБлока очищать от символов разметки с сохранением позиций
			ТекстДляПоискаОпределения = СтрЗаменить(ТекстДляПоискаОпределения, "|", " "); 
			Если Прав(ТекстДляПоискаОпределения, 1) = """" Тогда
				ТекстДляПоискаОпределения = ирОбщий.СтрокаБезКонцаЛкс(ТекстДляПоискаОпределения);
			КонецЕсли;
		КонецЕсли;
	КонецЕсли;
	Если ТаблицаТиповОтРодителя <> Неопределено Тогда
		ТаблицаТипов = ТаблицаТиповОтРодителя;
	Иначе 
		ТаблицаТипов = мПлатформа.НоваяТаблицаТипов();
	КонецЕсли;
	СтруктураТипа = НоваяСтруктураТипа();
	Если РазрешитьАнализИмениТипа Тогда
		ПредшествующийТекстКонец = Прав(ПредшествующийТекст, 200);
		Если мЯзыкПрограммы > 0 Тогда
			мТолькоСсылочныеИменаТипов = Истина;
			мРегВыражение.Global = Истина;
			мРегВыражение.Pattern = шПредИмяПрямое + "(?:ССЫЛКА|REFS)" + шРазделитель + "+$";
			Вхождения = мРегВыражение.НайтиВхождения(ПредшествующийТекстКонец);
			Если Вхождения.Количество() > 0 Тогда
				СтруктураТипа.ТипЯзыка = "ИмяТипа";
			КонецЕсли;
			//мРегВыражение.Pattern = шПредИмяПрямое + "(?:ВЫРАЗИТЬ|CAST)" + шРазделитель + "*\(" + шВыражениеЗапроса + шРазделитель + "+(?:КАК|AS)" + шРазделитель + "+$"; // Привязка к концу вызывала катастрофическое шагание назад
			мРегВыражение.Pattern = шПредИмяПрямое + "(?:ВЫРАЗИТЬ|CAST)" + шРазделитель + "*\(" + шВыражениеЗапроса + шРазделитель + "+(?:КАК|AS)" + шРазделитель + "+"; // 08.02.2023
			Вхождения = мРегВыражение.НайтиВхождения(ПредшествующийТекстКонец, Истина);
			Если Истина
				И Вхождения.Количество() > 0 
				И ПустаяСтрока(Сред(ПредшествующийТекстКонец, Вхождения[0].FirstIndex + Вхождения[0].Length)) // 08.02.2023
			Тогда
				СтруктураТипа.ТипЯзыка = "ИмяТипа";
				мТолькоСсылочныеИменаТипов = Ложь;
			КонецЕсли;
			мРегВыражение.Pattern = шПредИмяПрямое + "(?:ТИП|TYPE)" + шРазделитель + "*\(" + шРазделитель + "*$";
			Вхождения = мРегВыражение.НайтиВхождения(ПредшествующийТекстКонец);
			Если Вхождения.Количество() > 0 Тогда
				СтруктураТипа.ТипЯзыка = "ИмяТипа";
				мТолькоСсылочныеИменаТипов = Ложь;
			КонецЕсли;
			мРегВыражение.Pattern = шПредИмяПрямое + "(?:ЗНАЧЕНИЕ|VALUE)" + шРазделитель + "*\(" + шРазделитель + "*$";
			Вхождения = мРегВыражение.НайтиВхождения(ПредшествующийТекстКонец);
			Если Вхождения.Количество() > 0 Тогда
				СтруктураТипа.ТипЯзыка = "ЗначениеВЗапросе";
			КонецЕсли;
		Иначе
			мРегВыражение.Global = Истина;
			мРегВыражение.Pattern = шПредИмяПрямое + "(?:Новый|New)" + шРазделитель + "+$";
			Вхождения = мРегВыражение.НайтиВхождения(ПредшествующийТекстКонец);
			Если Вхождения.Количество() > 0 Тогда
				СтруктураТипа.Конструктор = Истина;
				СтруктураТипа.ТипЯзыка = "ИмяТипа";
			КонецЕсли;
			мРегВыражение.Pattern = шПредИмяПрямое + "(?:Новый|New)" + шРазделитель + "*\(" + шРазделитель + "*""$";
			Вхождения = мРегВыражение.НайтиВхождения(ПредшествующийТекстКонец);
			Если Вхождения.Количество() > 0 Тогда
				// Активная следующая строка блокирует недокументированные возможности.
				//СтруктураТипа.Конструктор = Истина;
				СтруктураТипа.ТипЯзыка = "ИмяТипа";
			КонецЕсли;
			мРегВыражение.Pattern = шПредИмяПрямое + "Тип" + шРазделитель + "*\(" + шРазделитель + "*""$";
			Вхождения = мРегВыражение.НайтиВхождения(ПредшествующийТекстКонец);
			Если Вхождения.Количество() > 0 Тогда
				СтруктураТипа.ТипЯзыка = "ИмяТипа";
			КонецЕсли;
			мРегВыражение.Pattern = шПредИмяПрямое + "(?:Новый|New)" + шРазделитель + "*ОписаниеТипов\(" + шРазделитель + "*""[^""]*$";
			Вхождения = мРегВыражение.НайтиВхождения(ПредшествующийТекстКонец);
			Если Вхождения.Количество() > 0 Тогда
				СтруктураТипа.ТипЯзыка = "ИмяТипа";
			КонецЕсли;
		КонецЕсли;
		Если Ложь
			Или СтруктураТипа.ТипЯзыка = "ИмяТипа"
			Или СтруктураТипа.ТипЯзыка = "ЗначениеВЗапросе"
		Тогда
			СтруктураТипа.ИмяОбщегоТипа = "";
		Иначе
			РазрешитьАнализИмениТипа = Ложь;
			Если мЭтоТекстовыйЛитерал Тогда
				ТаблицаТипов = ВычислитьТипЗначенияВыражения(мВызовМетода + ИмяФиктивногоПараметра() + ")", ТекстДляПоискаОпределения, ПредшествующийТекст,, мЭтоКонструктор, ПолныйАнализСоставаТипов,
					Ложь,,,,, Позиция0ВМетодеДо,, ДляСвойства);
				Возврат ТаблицаТипов;
			КонецЕсли; 
		КонецЕсли;
	КонецЕсли;
	Если Ложь
		Или Выражение = Неопределено
		Или Выражение = ""
	Тогда
		Если СтруктураТипа.ИмяОбщегоТипа = "НеизвестныйКонтекст" Тогда
			СтруктураТипа.ИмяОбщегоТипа = "Локальный"; // Приватные свойства + глобальный контекст
			мПлатформа.ДобавитьВТаблицуТипов(ТаблицаТипов, СтруктураТипа);
			Если Истина
				И мЯзыкПрограммы = 0
				И мМодульМетаданных <> Неопределено 
				И мМодульМетаданных.СтруктураТипа <> Неопределено 
			Тогда
				мПлатформа.ДобавитьВТаблицуТипов(ТаблицаТипов, мМодульМетаданных.СтруктураТипа);
			КонецЕсли;
		КонецЕсли;
	ИначеЕсли Нрег(Выражение) = "неопределено" Тогда
		СтруктураТипа.ИмяОбщегоТипа = "Неопределено";
	ИначеЕсли Лев(Выражение, 1) = """" Тогда
		СтруктураТипа.ИмяОбщегоТипа = "Строка";
		Если ВычислитьЗначение И Прав(Выражение, 1) = """" Тогда 
			СтруктураТипа.Метаданные = ирОбщий.ТекстИзВстроенногоЯзыкаЛкс(Выражение);
			//Если СтрДлина(СтруктураТипа.Метаданные) > 50 Тогда // Для сбора текстов запроса нужно обязательно возвращать координаты
				СтруктураТипа.ДержательМетаданных = НовыеКоординатыВыражения(Выражение, Позиция0ВМетодеДо);
			//КонецЕсли;
		КонецЕсли;
	ИначеЕсли ирОбщий.ЛиЦифраЛкс(Лев(Выражение, 1)) Тогда
		СтруктураТипа.ИмяОбщегоТипа = "Число";
		Если ВычислитьЗначение Тогда 
			Попытка
				СтруктураТипа.Метаданные = Число(Выражение);
			Исключение
			КонецПопытки;
		КонецЕсли;
	ИначеЕсли Ложь
		Или ирОбщий.ЛиБулевыйЛитералЛкс(Выражение, СтруктураТипа.Метаданные) 
		Или (Истина
			И Найти(Выражение, "(") = 0 
			И Найти(Выражение, "[") = 0 
			И (Ложь
				Или Найти(Выражение, ">") > 0 
				Или Найти(Выражение, "=") > 0))
	Тогда
		СтруктураТипа.ИмяОбщегоТипа = "Булево";
	Иначе                        
		ВычислениеРазрешено = Истина;
		ЛиВиртПрисвоение = Ложь;    
		ЛиПеременнаяРезультата = Выражение = ИмяПеременнойВозвращаемогоЗначения();
		ТекущееСлово = Выражение;
		ДляСвойстваВверх = Неопределено;
		ТекущийИндекс = Неопределено;
		ТекущиеАргументы = Неопределено;
		Если мЯзыкПрограммы = 1 И Лев(Выражение, 1) = "&" Тогда
			РодительскийКонтекст = "";
			ТекущееСлово = Выражение;
		Иначе
			Если ирОбщий.СтрНачинаетсяСЛкс(Выражение, "Новый ") Тогда
				// Для ускорения
				ЛиВиртПрисвоение = Истина;
				ЭтоВызовКонструктора = Истина;
			ИначеЕсли Ложь
				//Или Выражение = ИмяПеременнойВозвращаемогоЗначения() // Наверно не даст ускорения
				Или Найти(Выражение, ".") = 0 И ирОбщий.ЛиИмяПеременнойЛкс(Выражение) 
			Тогда
				// Для ускорения
				ТипСлова = "Свойство";
				РодительскийКонтекст = "";
			Иначе                     
				КэшРазбораВыражений = мПлатформа.мКэшРазбораВыражений;
				Если мПлатформа.мКэшРазбораВыражений = Неопределено Тогда 
					КэшРазбораВыражений = Новый Соответствие;
					мПлатформа.мКэшРазбораВыражений = КэшРазбораВыражений;
				КонецЕсли;
				КлючКэшаРазбора = НРег(Выражение);
				Вхождения = КэшРазбораВыражений[КлючКэшаРазбора];  
				Если Вхождения = Неопределено Тогда  
					мРегВыражение.Global = Ложь;
					мРегВыражение.Pattern = "(((\.(" + шИмя + "|\?|)" + шСкобки + "?)|" + шИндекс + ")*)" +
						              "((\.(" + шИмя + "|\?|)" + шСкобкиЛенивые + "?)|" + шИндекс + ")$";  // Возможно нужно заменить на шИмяСкобкиЛенивые
					Вхождения = мРегВыражение.НайтиВхождения("." + Выражение);
					КэшРазбораВыражений[КлючКэшаРазбора] = Вхождения;
				КонецЕсли;
				Если Вхождения.Количество() > 0 Тогда 
					ТипСлова = "Свойство";
					Вхождение = Вхождения[0];
					РодительскийКонтекст = Сред(Вхождение.SubMatches(0), 2);
					ТекущееСлово = Вхождение.SubMatches(8);
					ТекущийИндекс = Вхождение.SubMatches(10);
					ТекущиеАргументы = Вхождение.SubMatches(9);
					Если ТекущийИндекс <> Неопределено Тогда
						ТекущееСлово = Сред(ТекущийИндекс, 2, СтрДлина(ТекущийИндекс) - 2); // Здесь могут прийти выражения, не отвечающие требованиям к имени переменной
						//Если Не ирОбщий.ЛиИмяПеременнойЛкс(ТекущееСлово) Тогда 
						//КонецЕсли;
					КонецЕсли;
				Иначе
					ЛиВиртПрисвоение = Истина;
				КонецЕсли;
			КонецЕсли;
		КонецЕсли; 
		Если мЯзыкПрограммы = 1 Тогда
			ТипСлова = Неопределено; // Нельзя указывать конкретный тип, т.к. в этом языке несколько нужных типов
		ИначеЕсли ЗначениеЗаполнено(ТекущееСлово) Тогда 
			ТипСлова = "Свойство";
			Если Истина
				И ТекущиеАргументы <> Неопределено
				И СтруктураТипа.ТипЯзыка <> "ИмяТипа"
			Тогда                         
				// Это метод или функция
				Если ЭтоВызовКонструктора Тогда
					ТипСлова = "Конструктор";
				Иначе
					ТипСлова = "Метод";
				КонецЕсли; 
			КонецЕсли;
		Иначе
			ВычислениеРазрешено = Ложь;
		КонецЕсли;
		Если ВычислениеРазрешено Тогда
			Если Истина
				И ТипСлова = "Метод" 
				И Найти(Выражение, "(" + ИмяФиктивногоПараметра() + ")") > 0 
				И Найти(Выражение, ".") = 0 // Иначе Запрос.УстановитьПараметр("") не будет собирать данные
			Тогда 
				// Метаданные результата не нужны. Нужно только описание метода.
				ДляСвойства = ИмяФиктивногоСвойства();
				Позиция0ВМетодеОт = 0;
				Позиция0ВМетодеДо = 0;
			КонецЕсли;
		
			// Кэш проверяем в первую очередь!
			КлючВыраженияСПозицией = "";
			КлючВыраженияСПозициейИСвойством = "";
			ЛиПолнаяТаблицаТипов = Истина;
			СобиратьВсеПрисвоения = ВсеПрисвоения <> Неопределено;
			Если Истина
				И мРекурсивныйПуть.ДопКлючКэша <> Неопределено  
				И Не СобиратьВсеПрисвоения
				И мМодульМетаданных <> Неопределено
				И ЛиПолноеВыражение
			Тогда
				ТипыВыраженийМетода = Неопределено; // Соответствие
				ТаблицаТиповКэш = ТаблицаТиповВыраженияИзКэша(Выражение, Позиция0ВМетодеДо, ДляСвойства, ЭтоВызовКонструктора, ГлобальныйПоискВМодулеВход,
					КлючВыраженияСПозицией, КлючВыраженияСПозициейИСвойством, ТипыВыраженийМетода);
				Если ТаблицаТиповКэш <> Неопределено Тогда
					////ТаблицаТипов = ТаблицаТиповКэш; // Если раскомментировать, то проверка модуля ирКлсПолеТекстаПрограммы уходит в бесконечную рекурсию
					//Если ЛиТаблицаТиповКэшНеГотова(ТаблицаТиповКэш, ДляСвойства) Тогда
					//	// TODO защита от бесконечной рекурсии
					//	Пустышка = 0; // Для отладки
					//Иначе 
						ТаблицаТипов = ТаблицаТиповКэш; // Попадание в кэш выражения
						Перейти ~Возврат;
					//КонецЕсли;
				КонецЕсли;
				//Если ЗначениеЗаполнено(ЛиПолноеВыражение) Тогда
					ТипыВыраженийМетода.Вставить(КлючВыраженияСПозицией, ТаблицаТипов); 
				//КонецЕсли;
			КонецЕсли;
			
			ТаблицаТиповРодителя = новый Массив;
			Если Истина
				И Не ЛиВиртПрисвоение
				И Не ЛиПеременнаяРезультата
				И (Ложь
					Или ТаблицаТиповОтРодителя = Неопределено 
					Или Найти(Выражение, ".") = 0)  
			Тогда
				Если Истина
					И ПустаяСтрока(РодительскийКонтекст) 
					И СтруктураТипа.ТипЯзыка = ""
					И мКорневаяТаблицаТипов <> Неопределено 
					//И мЯзыкПрограммы = ЯзыкПрограммы
				Тогда
					ТаблицаТиповРодителя = мКорневаяТаблицаТипов; 
				Иначе
					НТекущееСлово = НРег(ТекущееСлово);
					ЛиЭлементКоллекции = Истина
						И мЯзыкПрограммы = 0
						И (Ложь
							Или ЗначениеЗаполнено(ТекущийИндекс) 
							Или (Истина
								// Опасно - принимаем решение только по имени метода, хотя в редких случаях они могут быть не связаны с коллекцией
								И ТипСлова = "Метод" 
								И (Ложь
									Или НТекущееСлово = "получить" 
									Или НТекущееСлово = "добавить"
									Или НТекущееСлово = "найти")));
					Если Истина
						И ЗначениеЗаполнено(РодительскийКонтекст) 
						И ТипСлова = "Свойство" 
						И ПустаяСтрока(ТекущийИндекс) 
					Тогда
						Если ЗначениеЗаполнено(ДляСвойства) Тогда
							ДляСвойстваВверх = ТекущееСлово + "." + ДляСвойства;
						Иначе
							ДляСвойстваВверх = ТекущееСлово;
						КонецЕсли;
					ИначеЕсли Истина
						И ТипСлова = "Метод" 
						И ДляСвойства <> ИмяФиктивногоСвойства()
						И Не ЛиЭлементКоллекции
					Тогда
						Если ДляСвойства = "Значение" Тогда
							ДляСвойстваВверх = "0"; // Для ЭлементСпискаЗначений или КлючИЗначение
						Иначе
							ДляСвойстваВверх = "";
						КонецЕсли;
					Иначе
						ДляСвойстваВверх = ДляСвойства;
					КонецЕсли;
					Если ЛиЭлементКоллекции Тогда 
						// TODO передавать конкретное имя когда оно есть
						Если ЗначениеЗаполнено(ДляСвойстваВверх) Тогда
							ДляСвойстваВверх = "0." + ДляСвойстваВверх; 
						Иначе
							ДляСвойстваВверх = "0";
						КонецЕсли;
					КонецЕсли;
					ТаблицаТиповРодителя = ВычислитьТипЗначенияВыражения(РодительскийКонтекст, ТекстДляПоискаОпределения, ПредшествующийТекст, РазрешитьАнализИмениТипа,, ПолныйАнализСоставаТипов, Ложь,,,,,
						Позиция0ВМетодеДо,, ДляСвойстваВверх, СобиратьОшибки,, Ложь);
					Если Истина
						И ПустаяСтрока(РодительскийКонтекст) 
						И СтруктураТипа.ТипЯзыка = ""
						И мКорневаяТаблицаТипов = Неопределено 
					Тогда
						мКорневаяТаблицаТипов = ТаблицаТиповРодителя;
					КонецЕсли;
				КонецЕсли; 
			КонецЕсли;
			ЛиПеременнаяМодуля = Ложь;
			Если ТаблицаТиповРодителя.Количество() > 0 Тогда
				Если ЗначениеЗаполнено(ТекущийИндекс) Тогда
					Если Истина
						И ТаблицаТиповРодителя[0].ИмяОбщегоТипа = "Массив" 
						И ТипЗнч(ТаблицаТиповРодителя[0].Метаданные) = Тип("ТаблицаЗначений")
						И ТаблицаТиповРодителя[0].Метаданные.Найти("РезультатЗапроса", "ИмяОбщегоТипа") <> Неопределено
					Тогда
						КопияКомпоненты = КопияКомпоненты();
						КопияКомпоненты.ЗаполнитьЛокальныеСвойстваИМетодыПоТексту(, Ложь,,,, ТекущееСлово,, Истина);
						ПеременныеВыражения = Новый Структура;
						Для Каждого СтрокаСлова Из КопияКомпоненты.ТаблицаСлов Цикл
							ЗначениеПеременной = Неопределено;
							// Мультиметка6091573442
							ТаблицаСтруктурТипа = ВычислитьТипЗначенияВыражения(СтрокаСлова.Слово, ПредшествующийТекст, ПредшествующийТекст,,,, Ложь,,, Истина,, Позиция0ВМетодеДо);
							Если ТаблицаСтруктурТипа.Количество() > 0 Тогда
								ЗначениеПеременной = ТаблицаСтруктурТипа[0].Метаданные;
								Если Истина
									И ТаблицаСтруктурТипа[0].ИмяОбщегоТипа = "Массив" 
									И ТипЗнч(ЗначениеПеременной) = Тип("ТаблицаЗначений")
								Тогда
									ЗначениеПеременной = ЗначениеПеременной[0].Метаданные;
									Если ТипЗнч(ЗначениеПеременной) = Тип("ПостроительЗапроса") Тогда
										ЗначениеПеременной = мПлатформа.РазбитьГрубоТекстПакетногоЗапросаНаЗапросы(ЗначениеПеременной.Текст);
									КонецЕсли;
								КонецЕсли;
							КонецЕсли;
							ПеременныеВыражения.Вставить(СтрокаСлова.Слово, ЗначениеПеременной);
						КонецЦикла;
						Алгоритм = ирОбщий.СтрСоединитьЛкс(ПеременныеВыражения,,,, "%1=_АлгоритмОбъект.%1;" + Символы.ПС, "Ключ")
							+ "Результат = " + ТекущееСлово;
						ЗначениеВыражения = Неопределено;
						ТекущееСлово = "?";
						Попытка
							ЗначениеВыражения = ирОбщий.ВыполнитьАлгоритм(Алгоритм, ПеременныеВыражения);
							ТекущееСлово = XMLСтрока(ЗначениеВыражения);
						Исключение
						КонецПопытки;
					Иначе 
						ТекущееСлово = "?";
						Если Истина
							И Найти(ТекущийИндекс, "-") = 0
							И Найти(ТекущийИндекс, "+") = 0
							И Найти(ТекущийИндекс, ",") = 0
						Тогда
							// Такие вычисления могут быть неоправданно затратными, особенно если ТекущийИндекс содержит ".".
							ЗначениеИндекса = ВычислитьЗначениеВыражения(ТекстБезКрайнихСимволов(ТекущийИндекс),,, Позиция0ВМетодеОт, Позиция0ВМетодеДо);
							Если Истина
								И ТипЗнч(ЗначениеИндекса) = Тип("Строка") 
								И ЗначениеИндекса <> ""
							Тогда
								ТекущееСлово = """" + ЗначениеИндекса + """";
							КонецЕсли;
						КонецЕсли;
					КонецЕсли;
				КонецЕсли;
				ВычислитьТипДочернегоЭлемента(ТаблицаТиповРодителя, ТекущееСлово, ТипСлова, ТекущийИндекс, ТекущиеАргументы, ПредшествующийТекст, ПолныйАнализСоставаТипов, ЛиПеременнаяМодуля,
					Позиция0ВМетодеДо, ТаблицаТипов, ДляСвойства, ГлобальныйПоискВМодулеВход);
			КонецЕсли;
			Если мЯзыкПрограммы = 1 Тогда
				Если Истина
					И РодительскийКонтекст = ""
					И СтруктураТипа.ТипЯзыка = "" 
				Тогда
					Если ЗначениеЗаполнено(ТекущееСлово) Тогда
						ТекстЧасти = "";
						НачалоЧасти = НачалоЧастиОбъединенияЗапроса(ТекстДляПоискаОпределения, Позиция0ВМетодеДо,, ТекстЧасти);
						мРегВыражение.Global = Ложь;
						мРегВыражение.Pattern = СтрЗаменить(шПоискОписанияТаблицы, "#Идентификатор#", ирОбщий.ТекстДляРегВыраженияЛкс(ТекущееСлово));
						РезультатТекста = мРегВыражение.НайтиВхождения(ТекстЧасти);
						Если РезультатТекста.Количество() > 0 Тогда
							ПоследнееВхождение = РезультатТекста[0];
							Позиция0ВхожденияВМетоде = НачалоЧасти + ПоследнееВхождение.FirstIndex;
							СледРекурсии = мРекурсивныйПуть.ПозицииЗапроса.Найти(Позиция0ВхожденияВМетоде);
							Если СледРекурсии = Неопределено Тогда
								мРекурсивныйПуть.ПозицииЗапроса.Добавить(Позиция0ВхожденияВМетоде);
								ПрисвоенныйКонтекст = ПоследнееВхождение.SubMatches(3);
								Если Лев(ПрисвоенныйКонтекст, 1) = "(" Тогда
									// Подзапрос
									ТекстыЗапросов = ирОбщий.СкопироватьКоллекциюЛкс(мПакетЗапросов.ТекстыЗапросов);
									ПрисвоенныйКонтекст = ТекстБезКрайнихСимволов(ПрисвоенныйКонтекст);
									Если Лев(ТекстыЗапросов[0], 1) = """" Тогда
										ПрисвоенныйКонтекст = ирОбщий.ТекстВВыражениеВстроенногоЯзыкаЛкс(ПрисвоенныйКонтекст);
										Если мИндексЗапросаПакета > 0 Тогда
											ПрисвоенныйКонтекст = "|" + Сред(ПрисвоенныйКонтекст, 2);
										КонецЕсли;
									КонецЕсли;
									ТекстыЗапросов[мИндексЗапросаПакета] = ПрисвоенныйКонтекст;
									СтруктураТипа = мПлатформа.НоваяСтруктураТипа("ВременнаяТаблица");  // TODO переделать на новый тип ВложенныйЗапрос
									СтруктураТипа.Метаданные = мПлатформа.ПостроительПакетаЗапросовДоИндекса(ТекстыЗапросов, мИндексЗапросаПакета, мПакетЗапросов.Параметры);
									мПлатформа.ДобавитьВТаблицуТипов(ТаблицаТипов, СтруктураТипа); 
								ИначеЕсли ПрисвоенныйКонтекст <> Выражение Тогда
									ТаблицаПрисвоенныхТипов = ВычислитьТипЗначенияВыражения(ПрисвоенныйКонтекст, ТекстДляПоискаОпределения,
										Лев(ТекстДляПоискаОпределения, Позиция0ВхожденияВМетоде - 1),,, ПолныйАнализСоставаТипов, Ложь,,,,, Позиция0ВхожденияВМетоде,,, СобиратьОшибки);
									мПлатформа.ДобавитьВТаблицуТипов(ТаблицаТипов, ТаблицаПрисвоенныхТипов); 
								КонецЕсли;
							КонецЕсли;
						КонецЕсли;
					КонецЕсли;
					Если ЗначениеЗаполнено(ТекущиеАргументы) Тогда
						//Если Не ЗначениеЗаполнено(ТекущееСлово) Тогда
						//	ТекущееСлово = ирОбщий.УдалитьВнешниеСкобкиВыраженияЛкс(ТекущиеАргументы);
						//КонецЕсли;
						Если ирОбщий.СтрокиРавныЛкс(ТекущееСлово, "Выразить") Тогда
							//ТекущиеАргументы = ирОбщий.ТекстМеждуМаркерамиЛкс(ТекущиеАргументы, "(", ")", Ложь, Истина);
							мРегВыражение.Pattern = шРазделитель + "(?:КАК|AS)" + шРазделитель + "+(" + шИмяСТочками + ")";
							Вхождения = мРегВыражение.НайтиВхождения(ТекущиеАргументы);
							Если Вхождения.Количество() > 0 Тогда
								ИмяТипаВыражения = Вхождения[Вхождения.Количество() - 1].Submatches(0);
								Если Найти(ИмяТипаВыражения, ".") > 0 Тогда
									ИмяТипаВыражения = ирОбщий.ИмяТипаИзПолногоИмениМДЛкс(ИмяТипаВыражения);
								КонецЕсли; 
								СтруктураТипа = мПлатформа.СтруктураТипаИзКонкретногоТипа(Тип(ИмяТипаВыражения));
								СтруктураТипа.ИмяОбщегоТипа = СтрЗаменить(СтруктураТипа.ИмяОбщегоТипа, ирОбщий.ПеревестиСтроку("Ссылка") + ".", ".");
								мПлатформа.ДобавитьВТаблицуТипов(ТаблицаТипов, СтруктураТипа);
							КонецЕсли; 
						КонецЕсли; 
					КонецЕсли; 
				КонецЕсли;
			ИначеЕсли Истина
				И ЗначениеЗаполнено(ТекущееСлово) 
				И ТипСлова = "Свойство" 
				И СтруктураТипа.ТипЯзыка = "" 
				И ЗначениеЗаполнено(ТекстДляПоискаОпределения)
			Тогда  
				Если ТаблицаТиповРодителя.Количество() > 0 Тогда
					МетаданныеРодителя = ТаблицаТиповРодителя[0].Метаданные;
				Иначе 
					МетаданныеРодителя = Неопределено;
				КонецЕсли;                          
				ЭтоФактическийТип = Истина
					И РодительскийКонтекст = ""
					И мМетодМодуля <> Неопределено  
					И мМетодМодуля.КлючевыеПараметры <> Неопределено
					И ирОбщий.ЛиИмяПеременнойЛкс(Выражение)
					И мМетодМодуля.КлючевыеПараметры.Свойство(Выражение)
					И мМетодМодуля.КлючевыеПараметры[Выражение] <> Неопределено;
				Если Ложь
					Или (Истина
						И ТипЗнч(МетаданныеРодителя) = Тип("ПостроительЗапроса")
						И ТекущееСлово = "МенеджерВременныхТаблиц")
					Или (Истина
						И МетаданныеРодителя <> Неопределено
						И ТаблицаТипов.Количество() = 1
						И (Ложь
							Или ТаблицаТипов[0].ИмяОбщегоТипа = "ОбщийМодуль"
							//Или ТипЗнч(МетаданныеРодителя) = Тип("ТаблицаЗначений")
							Или ТипЗнч(МетаданныеРодителя) = Тип("ДанныеФормыКоллекция")
							Или ТипЗнч(МетаданныеРодителя) = Тип("ДанныеФормыСтруктураСКоллекцией")
							//Или ЭтоФактическийТип // Нужно для СкопироватьКоллекциюЛкс(). Вредно для вычисления результата РодительЭлементаУправляемойФормыЛкс()
							))              
				Тогда
					// Считаем что тип уже достаточно точно вычислен. Отсекаем малополезное обогащение типов
				Иначе
					// Обогощаем присвоенными типами
					ПроверятьТипЧерезЕсли = Ложь;
					Если ЛиВиртПрисвоение Тогда
						// = Новый ...
						ИмяВиртПеременной = "ВиртВыражение294";
						ЧислоГруппВШаблонеВыражения = 0;
						мРегВыражение.Pattern = ШаблонНазначенияТипаВыражению(ИмяВиртПеременной, ПроверятьТипЧерезЕсли);
						ТекстДляПоискаОпределения = ИмяВиртПеременной + "=" + Выражение;
						Вхождения = мРегВыражение.НайтиВхождения(ТекстДляПоискаОпределения);
						Если Вхождения.Количество() > 0 Тогда
							яяя = Новый Массив;
							яяя.Добавить(Новый Структура("Вхождение", Вхождения[0]));
							Вхождения = яяя;
						КонецЕсли;
						Выражение = ИмяВиртПеременной;
						КэшПоискаМетода = Неопределено;
					Иначе 
						ЧислоГруппВШаблонеВыражения = 4;
						ШаблонПоиска = "(" + шОбъектноеВыражение + ")";
						Если Истина
							И ПустаяСтрока(РодительскийКонтекст)
							И мМодульМетаданных <> Неопределено
							И мМодульМетаданных.СтруктураТипа <> Неопределено
							И мМодульМетаданных.СтруктураТипа.ИмяОбщегоТипа <> "ОбщийМодуль"
						Тогда
							ШаблонПоиска = ШаблонПоискаСловаЧерезЭтотОбъект(ШаблонПоиска);
						КонецЕсли;
						ШаблонПоиска = ШаблонНазначенияТипаВыражению("(?!ТипЗнч\()" + ШаблонПоиска, Истина);
						КлючКэшаПоиска = Нрег("НазначениеТипа");
						Вхождения = НайтиВхожденияРегВыраженияКэш(ШаблонПоиска, ГлобальныйПоискВМодуле, ТекстДляПоискаОпределения, КлючКэшаПоиска, КэшПоискаМетода);
						ВыражениеНРег = НРег(Выражение);
						//ИндексВыражения2 = ЧислоГруппВШаблонеВыражения + 24;
						ИндексВыражения1 = ЧислоГруппВШаблонеВыражения + 26;
						ИндексВыражения2 = ЧислоГруппВШаблонеВыражения*2 + 26;
						Если ТипЗнч(Вхождения) <> Тип("ТаблицаЗначений") Тогда
							ТаблицаВхождений = Новый ТаблицаЗначений;
							ТаблицаВхождений.Колонки.Добавить("ВыражениеНрег");
							ТаблицаВхождений.Колонки.Добавить("Вхождение"); // см. Вхождения[0]
							_РежимОтладки = Ложь;
							Если _РежимОтладки Тогда // Можно менять на Истина в точке останова, например условием ирОбщий.Пр(_РежимОтладки, 1, 1)
								// Пассивный оригинал расположенного ниже однострочного кода. Выполняйте изменения синхронно в обоих вариантах.
								Для Каждого Вхождение Из Вхождения Цикл
									СтрокаВхождения = ТаблицаВхождений.Добавить();
									СтрокаВхождения.Вхождение = Вхождение;
									ВыражениеВхождения = Вхождение.SubMatches(1);
									Если ВыражениеВхождения = Неопределено Тогда
										ВыражениеВхождения = Вхождение.SubMatches(ИндексВыражения1);
									КонецЕсли;
									Если ВыражениеВхождения = Неопределено Тогда
										ВыражениеВхождения = Вхождение.SubMatches(ИндексВыражения2);
									КонецЕсли;
									СтрокаВхождения.ВыражениеНрег = НРег(ВыражениеВхождения);
								КонецЦикла; 
							Иначе
								// Однострочный код использован для ускорения при разрешенной отладке. Выше расположен оригинал. Выполняйте изменения синхронно в обоих вариантах. Преобразовано консолью кода из подсистемы "Инструменты разработчика"
								Для Каждого Вхождение Из Вхождения Цикл  									СтрокаВхождения = ТаблицаВхождений.Добавить();  									СтрокаВхождения.Вхождение = Вхождение;  									ВыражениеВхождения = Вхождение.SubMatches(1);  									Если ВыражениеВхождения = Неопределено Тогда  										ВыражениеВхождения = Вхождение.SubMatches(ИндексВыражения1);  									КонецЕсли;  									Если ВыражениеВхождения = Неопределено Тогда  										ВыражениеВхождения = Вхождение.SubMatches(ИндексВыражения2);  									КонецЕсли;  									СтрокаВхождения.ВыражениеНрег = НРег(ВыражениеВхождения);  								КонецЦикла;  
							КонецЕсли;
							ТаблицаВхождений.Индексы.Добавить("ВыражениеНрег");
							Вхождения = ТаблицаВхождений;
							Если КэшПоискаМетода <> Неопределено Тогда
								КэшПоискаМетода[КлючКэшаПоиска] = Вхождения;
							КонецЕсли;
						КонецЕсли;
						Вхождения = Вхождения.НайтиСтроки(Новый Структура("ВыражениеНрег", ВыражениеНРег));
						ПроверятьТипЧерезЕсли = Истина
							И Не СобиратьВсеПрисвоения
							И Не ГлобальныйПоискВМодуле
							И Найти(Выражение, "(") = 0
							И Не ЛиПеременнаяРезультата;
					КонецЕсли; 
					ЛиТипЧерезЕслиНазначен = Ложь;
					ГлубинаИзмениласьПослеПрисвоения = Истина;
					Если Вхождения.Количество() > 0 Тогда
						СтруктураМоноТипа = Неопределено;
						ОтборПоПроизвольномуИмениТипа = Новый Структура("ИмяОбщегоТипа", "Произвольный");
						НачальнаяПозицияТелаМетода = 0; 
						ГлубинаВеток = НоваяГлубинаВеток(Позиция0ВМетодеДо);
						ЧислоПроверенныхВариантов = 0;
						ЛиУстановкаЗначения = Ложь;
						ИндексВхождения = Вхождения.Количество();
						Пока ИндексВхождения > 0 Цикл 
							ИндексВхождения = ИндексВхождения - 1;
							ПоследнееВхождение = Вхождения[ИндексВхождения].Вхождение;
							//Если Истина
							//	И НРег(ПоследнееВхождение.SubMatches(1)) <> ВыражениеНРег
							//	И (Ложь
							//		Или Не ПроверятьТипЧерезЕсли 
							//		Или НРег(ПоследнееВхождение.SubMatches(ИндексВыражения2)) <> ВыражениеНРег)
							//Тогда
							//	Продолжить;
							//КонецЕсли;
							Если Истина
								И Не ЛиВиртПрисвоение
								И Не ГлобальныйПоискВМодуле
								И ЛиВхождениеВЗапрешенномДиапазоне(ПоследнееВхождение, Позиция0ВМетодеОт, Позиция0ВМетодеДо, ЛиКорневойВызов) 
							Тогда
								Продолжить;
							КонецЕсли;
							Если ЛиВиртПрисвоение Тогда
								Позиция0ВхожденияВМетоде = Позиция0ВМетодеДо;
							Иначе
								Позиция0ВхожденияВМетоде = ПоследнееВхождение.FirstIndex; 
								Если ГлобальныйПоискВМодуле Тогда 
									НачальнаяПозицияТелаМетода = ЗагрузитьМетодМодуляПоПозицииИРазобратьКонтекст(Позиция0ВхожденияВМетоде);
									ТекстДляПоискаОпределения = мТекстБлока;
								КонецЕсли;
								Позиция0ВхожденияВМетоде = Позиция0ВхожденияВМетоде - 1 - НачальнаяПозицияТелаМетода;
								Позиция0ВхожденияВМетоде = Макс(1, Позиция0ВхожденияВМетоде); // Если это не делать, то будет циклическая рекурсия в ВычислитьНеизменяющаяСтроковаяФункция при обработке ОбработкаОбъект.ирПлатформа.РазмаскироватьДирективыПрепроцессора
							КонецЕсли;
							СчитатьГлубинуВеток(ТекстДляПоискаОпределения, ГлубинаВеток, Позиция0ВхожденияВМетоде, ПоследнееВхождение, ГлубинаИзмениласьПослеПрисвоения);
							Если Ложь
								Или (Истина
									И ГлубинаВеток.Альтернативная >= 0 
									И ГлубинаВеток.Необязательная <> ГлубинаВеток.Альтернативная)
								Или (Истина
									// Нужно для СкопироватьКоллекциюЛкс()
									И ЭтоФактическийТип 
									И ГлубинаВеток.Необязательная <> Неопределено // для вычисления результата РодительЭлементаУправляемойФормыЛкс()
									)
							Тогда
								Продолжить;
							КонецЕсли; 
							ТаблицаТиповИзКомментария = Неопределено;
							ПрисвоенныйТип = ПоследнееВхождение.SubMatches(ЧислоГруппВШаблонеВыражения + 23);
							Если ПрисвоенныйТип <> Неопределено Тогда 
								Если Лев(ПрисвоенныйТип, 1) = "@" Тогда 
									Если мПлатформа.мРежимПроверкиМодуля Тогда 
										Если ПрисвоенныйТип = ИнструкцияПодавленияПроверки(, Истина) Тогда
											СтруктураМоноТипа = мПлатформа.НоваяСтруктураТипа("Произвольный");
											ДобавитьЕдинственныйТип(ТаблицаТипов, СтруктураМоноТипа);
											Прервать;
										КонецЕсли;
									КонецЕсли;
								ИначеЕсли Истина
									И Найти(ПрисвоенныйТип, "=") = 0
									И Найти(ПрисвоенныйТип, ";") = 0
									И Найти(ПрисвоенныйТип, """") = 0
									И Не СобиратьВсеПрисвоения
								Тогда
									// Назначение типа в комментарии
									ТекстДоВхождения = Сред(ТекстДляПоискаОпределения, 0, Позиция0ВхожденияВМетоде + 2); // МультиМетка8294218
									ТаблицаТиповИзКомментария = ТаблицаТиповИзТекста(ирОбщий.ПервыйФрагментЛкс(ПрисвоенныйТип, "-"),, ТекстДоВхождения, ДляСвойства,,,, Позиция0ВхожденияВМетоде);
									Если ТаблицаТиповИзКомментария.Количество() > 0 Тогда
										//ТекстПослеВхождения = Сред(ТекстДляПоискаОпределения, Позиция0ВхожденияВМетоде, Позиция0ВМетодеДо - Позиция0ВхожденияВМетоде);
										Если ЛиПеременнаяРезультата И ТаблицаТиповИзКомментария.Количество() > 1 Тогда
											ТаблицаТипов.Очистить();
											мПлатформа.ДобавитьВТаблицуТипов(ТаблицаТипов, ТаблицаТиповИзКомментария);
											Прервать;
										КонецЕсли;
										Если Истина
											И ЧислоПроверенныхВариантов = 0
											И СтруктураМоноТипа = Неопределено
											И ГлубинаВеток.Необязательная = Неопределено
											И мПлатформа.ЛиДетальностьТиповДостаточна(ТаблицаТиповИзКомментария,, Истина, СтруктураМоноТипа)
										Тогда
											ДобавитьЕдинственныйТип(ТаблицаТипов, СтруктураМоноТипа, ЭтоФактическийТип);
											ТаблицаТиповИзКомментария = Неопределено;
											Если мПлатформа.ЛиДетальностьТиповДостаточна(ТаблицаТипов, 4) Тогда
												Прервать;
											КонецЕсли;
										Иначе 
											мПлатформа.ДобавитьВТаблицуТипов(ТаблицаТипов, ТаблицаТиповИзКомментария);
											Если ТаблицаТиповИзКомментария.Количество() > 1 Тогда
												ТаблицаТиповИзКомментария = Неопределено;
											КонецЕсли;
										КонецЕсли;
									Иначе
										ТаблицаТиповИзКомментария = Неопределено;
									КонецЕсли;
								КонецЕсли;
							КонецЕсли;
							ЭтоПрисвоение = ПоследнееВхождение.SubMatches(ЧислоГруппВШаблонеВыражения + 2) <> Неопределено;
							Если ЭтоПрисвоение И Не СобиратьВсеПрисвоения Тогда
								ПрисвоенныйКонтекст = ПоследнееВхождение.SubMatches(ЧислоГруппВШаблонеВыражения + 3);
								ПоследнийСимвол = Прав(ПрисвоенныйКонтекст, 1);
								Если Ложь
									Или ПоследнийСимвол = "="
									Или ПоследнийСимвол = "<"
									Или ПоследнийСимвол = ">"
								Тогда
									СтруктураТипа.ИмяОбщегоТипа = "Булево";
									мПлатформа.ДобавитьВТаблицуТипов(ТаблицаТипов, СтруктураТипа);
									Продолжить;
								ИначеЕсли Ложь
									Или ПоследнийСимвол = "-"
									Или ПоследнийСимвол = "*"
									Или ПоследнийСимвол = "/"
									Или ПоследнийСимвол = "%"
								Тогда
									СтруктураТипа.ИмяОбщегоТипа = "Число";
									мПлатформа.ДобавитьВТаблицуТипов(ТаблицаТипов, СтруктураТипа);
									Продолжить;
								ИначеЕсли ЛиБесполезноеПрисвоениеПеременной(ПрисвоенныйКонтекст) Тогда  
									Если ЗначениеЗаполнено(ПрисвоенныйКонтекст) Тогда
										мПлатформа.ДобавитьВТаблицуТипов(ТаблицаТипов, мПлатформа.НоваяСтруктураТипа(ПрисвоенныйКонтекст));
									КонецЕсли;
									Продолжить;
								КонецЕсли;
								Если ирОбщий.СтрокиРавныЛкс(Выражение, ПрисвоенныйКонтекст) Тогда 
									// Например ф = ф + 1
									Продолжить;
								КонецЕсли;
							КонецЕсли;
							Если ПроверятьТипЧерезЕсли Тогда 
								//ПрисвоенныйТипЕсли = ПоследнееВхождение.SubMatches(ЧислоГруппВШаблонеВыражения*2 + 24);
								ПрисвоенныйТипЕсли = ПоследнееВхождение.SubMatches(ЧислоГруппВШаблонеВыражения*3 + 26);
								Если ПрисвоенныйТипЕсли <> Неопределено Тогда
									// Теперь делаем это выше
									//Если ЭтоФактическийТип Тогда
									//	ЛиТипЧерезЕслиНазначен = Истина;
									//КонецЕсли;
									Если Не ЛиУстановкаЗначения И Не ЛиТипЧерезЕслиНазначен Тогда
										//ПрименитьТип = МожноПрименитьПрисвоениеТипаИзЕсли(ТекстПроверкиВеток, ГлубинаВеток.Необязательная);
										ПрименитьТип = МожноПрименитьПрисвоениеТипаИзЕсли(ТекстДляПоискаОпределения, Позиция0ВМетодеДо, ПоследнееВхождение, Позиция0ВхожденияВМетоде, ГлубинаВеток.Необязательная);
										Если ПрименитьТип Тогда 
											//ЛиТипЧерезЕслиНазначен = Истина;
											Тип = Неопределено;
											Если Найти(ПрисвоенныйТипЕсли, """") > 0 Тогда 
												ИмяТипа = ирОбщий.ТекстМеждуМаркерамиЛкс(ПрисвоенныйТипЕсли, """", """");
												Попытка
													Тип = Тип(ИмяТипа);
												Исключение
												КонецПопытки;
												//Иначе 
												//	Тип = ВычислитьЗначениеВыражения(ПрисвоенныйТипЕсли, ПредшествующийТекст,,, Позиция0ВхожденияВМетоде);
											КонецЕсли; 
											Если ТипЗнч(Тип) = Тип("Тип") Тогда 
												Если Тип = Тип("ОбъектМетаданных") Тогда
													СтруктураМоноТипа = мПлатформа.НоваяСтруктураТипа("ОбъектМетаданных");
												Иначе 
													СтруктураМоноТипа = мПлатформа.СтруктураТипаИзКонкретногоТипа(Тип);
													Если СтруктураМоноТипа.ИмяОбщегоТипа = "НеизвестныйКонтекст" Тогда
														// Например тупиковый устаревший ПолеТабличногоДокументаФормы Или ОсновнойЭлементФормы
														СтруктураМоноТипа = Неопределено;
													КонецЕсли;
												КонецЕсли;   
												Если СтруктураМоноТипа <> Неопределено Тогда
													//Если ирОбщий.СтрНачинаетсяСЛкс(СокрЛ(ПоследнееВхождение.Value), "Или ") Тогда  
													//	мПлатформа.ДобавитьВТаблицуТипов(ТаблицаТипов, СтруктураМоноТипа);
													//	СтруктураМоноТипа = Неопределено;
													//Иначе 
														ЛиТипЧерезЕслиНазначен = ДобавитьЕдинственныйТип(ТаблицаТипов, СтруктураМоноТипа, ЭтоФактическийТип);
													//КонецЕсли;
												КонецЕсли;
											КонецЕсли;
										КонецЕсли;
									КонецЕсли;
									Продолжить;
								КонецЕсли;
							КонецЕсли;
							// Если включено, то ускоряет, но иногда отрезает дополнительные типы, отображаемые в списке автодополнения
							//Если Истина
							//	И ДляСвойства = ИмяФиктивногоСвойства()
							//	И мПлатформа.ЛиДетальностьТиповДостаточна(ТаблицаТипов)
							//Тогда
							//	ТаблицаТипов.Колонки.Метаданные.Заголовок = ЗаголовокФлагОбрезкиГлубины();
							//	Прервать;
							//КонецЕсли;
							Если Истина
								И ЛиПеременнаяМодуля 
								И Не ЛиКорневойВызов 
								И Не СобиратьВсеПрисвоения 
								И мПлатформа.ЛиДетальностьТиповДостаточна(ТаблицаТипов)
							Тогда
								// Для ускорения
								Перейти ~Возврат;
							КонецЕсли;
							Если Истина
								И ЧислоПроверенныхВариантов = 0 
								И Не ЛиПеременнаяРезультата
								И Не СобиратьВсеПрисвоения
							Тогда
								// Ищем уже вычисленное ближайшее сзади выражение. Можно добавить точку, чтобы не учитывать бесполезные элементы (например Ф[], ТипЗнч(Ф))
								Позиция0БлижайшегоОбращения = ирОбщий.СтрНайтиЛкс(мТекстДляПоискаОпределения, Выражение, Истина) - 1;
								Если Позиция0БлижайшегоОбращения > Позиция0ВхожденияВМетоде + ПоследнееВхождение.Length Тогда
									ТаблицаТиповКэш = ТаблицаТиповВыраженияИзКэша(Выражение, Позиция0БлижайшегоОбращения, ДляСвойства, ЭтоВызовКонструктора, ГлобальныйПоискВМодулеВход);
									Если ТаблицаТиповКэш <> Неопределено Тогда
										ЛиГлубинаВетокПодходит = ГлубинаВеток.Необязательная = Неопределено;
										Если Не ЛиГлубинаВетокПодходит Тогда
											ДлинаДиапазонаМеждуВхождениями = Позиция0ВМетодеДо - Позиция0БлижайшегоОбращения;
											Если ДлинаДиапазонаМеждуВхождениями < 5000 Тогда
												ДиапазонМеждуВхождениями = НРег(Сред(мТекстБлока, Позиция0БлижайшегоОбращения + 1, ДлинаДиапазонаМеждуВхождениями));
												ЛиГлубинаВетокПодходит = Истина
													И Найти(ДиапазонМеждуВхождениями, "конецесли") = 0
													И Найти(ДиапазонМеждуВхождениями, "иначе") = 0;
											КонецЕсли;
										КонецЕсли;
										Если ЛиГлубинаВетокПодходит Тогда
											ТаблицаТипов = ТаблицаТиповКэш; // Попадание в кэш выражения. Возможно нужно скопировать таблицу
											Если ТипыВыраженийМетода <> Неопределено Тогда
												ТипыВыраженийМетода[КлючВыраженияСПозицией] = ТаблицаТипов;
											КонецЕсли;
											Перейти ~Возврат;
										КонецЕсли;
									КонецЕсли;
								КонецЕсли;
							КонецЕсли;
							Если Истина
								И Не ГлубинаИзмениласьПослеПрисвоения 
								И Не СобиратьВсеПрисвоения
							Тогда
								Продолжить;
							КонецЕсли;
							ПервыйСимвол = Лев(ПоследнееВхождение.Value, 1);
							Если ВычислитьЗначение И Лев(ПрисвоенныйКонтекст, 1) = """" Тогда
								СмещениеПозиции = Найти(ПоследнееВхождение.Value, Лев(ПрисвоенныйКонтекст, 10));
							ИначеЕсли ПервыйСимвол = ";" Тогда
								// TODO Нужно этот начальный фрагмент прямо в регулярном выражении захватывать и брать его длину
								СмещениеПозиции = 2; 
							ИначеЕсли ПервыйСимвол = Символы.ПС Тогда
								// TODO Нужно этот начальный фрагмент прямо в регулярном выражении захватывать и брать его длину
								СмещениеПозиции = 1;
							Иначе
								// Для ускорения
								СмещениеПозиции = 0;
							КонецЕсли;
							Позиция0ВхожденияВМетоде = Позиция0ВхожденияВМетоде + СмещениеПозиции;
							ЛиУстановкаЗначения = Истина;
							ЧислоПроверенныхВариантов = ЧислоПроверенныхВариантов + 1;
							Если ПоследнееВхождение.SubMatches(ИндексВыражения1) <> Неопределено Тогда
								// Структура.Свойство(, Выражение)
								ВыражениеСтруктуры = ПоследнееВхождение.SubMatches(ИндексВыражения1 - 2);
								ВыражениеСвойства = ПоследнееВхождение.SubMatches(ИндексВыражения1 - 1);
								ИмяСвойства = ВычислитьЗначениеВыражения(ВыражениеСвойства,,, Позиция0ВМетодеОт, ПоследнееВхождение.FirstIndex);
								ТаблицаТиповСтруктуры = ВычислитьТипЗначенияВыражения(ВыражениеСтруктуры,,,,,, Ложь,,, Истина, Позиция0ВМетодеОт, ПоследнееВхождение.FirstIndex);
								Если Истина
									И ЗначениеЗаполнено(ИмяСвойства)
									И ЗначениеЗаполнено(ТаблицаТиповСтруктуры) 
								Тогда
									ИмяОбщегоТипа = ТаблицаТиповСтруктуры[0].ИмяОбщегоТипа;
									Если Ложь
										Или ИмяОбщегоТипа = "Структура"
										Или ИмяОбщегоТипа = "ФиксированнаяСтруктура"
										Или ИмяОбщегоТипа = "ДанныеФормыСтруктура"
										Или ИмяОбщегоТипа = "ДанныеФормыЭлементКоллекции"
										Или ИмяОбщегоТипа = "ДанныеФормыЭлементДерева"
										Или ИмяОбщегоТипа = "ДанныеФормыСтруктураСКоллекцией"
									Тогда
										ТаблицаТиповСвойства = ВычислитьТипДочернегоЭлемента(ТаблицаТиповСтруктуры, ИмяСвойства, "Свойство");
										мПлатформа.ДобавитьВТаблицуТипов(ТаблицаТипов, ТаблицаТиповСвойства);
									КонецЕсли;
								КонецЕсли;
								Продолжить;
							КонецЕсли;
							Если ЭтоПрисвоение Тогда
								СловоНовый = НРег(ПоследнееВхождение.SubMatches(ЧислоГруппВШаблонеВыражения + 4));
								Если СловоНовый = Нрег("Новый") Или СловоНовый = Нрег("New") Тогда
									Если ПоследнееВхождение.SubMatches(ЧислоГруппВШаблонеВыражения + 5) <> Неопределено Тогда 
										ИмяТипа = ПоследнееВхождение.SubMatches(ЧислоГруппВШаблонеВыражения + 5);
									ИначеЕсли ПоследнееВхождение.SubMatches(ЧислоГруппВШаблонеВыражения + 6) <> Неопределено Тогда 
										ИмяТипа = ПоследнееВхождение.SubMatches(ЧислоГруппВШаблонеВыражения + 6);
										ИмяТипа = ирОбщий.ТекстИзВстроенногоЯзыкаЛкс(ИмяТипа);
									Иначе
										ИмяТипа = Неопределено;
									КонецЕсли;
									Если ЗначениеЗаполнено(ИмяТипа) Тогда
										Попытка
											ТипНового = Тип(ИмяТипа);
										Исключение
											ТипНового = Неопределено;
											СтруктураТипа.ИмяОбщегоТипа = ИмяТипа; // Имя внешней компоненты, например AddIn.T1CDLib.DB1CD
										КонецПопытки; 
										Если Истина
											И ТипНового = Тип("COMОбъект")
											И ПоследнееВхождение.SubMatches(ЧислоГруппВШаблонеВыражения + 6) <> Неопределено 
										Тогда
											ПолноеИмяОсновногоКлассаCOM = ВычислитьЗначениеВыражения(ПоследнееВхождение.SubMatches(ЧислоГруппВШаблонеВыражения + 6),,, Позиция0ВМетодеОт, Позиция0ВхожденияВМетоде);
											СтруктураКОМТипа = мИменаОбщихТиповПоИменамКлассовCOM[ПолноеИмяОсновногоКлассаCOM];
											Если СтруктураКОМТипа = Неопределено Тогда
												СтруктураКОМТипа = Новый Структура;
												МетаданныеСлова = мПлатформа.ПолучитьОбразецCOMОбъекта(ПолноеИмяОсновногоКлассаCOM); // При этом может открыться форма Automation-сервера например RegexBuddy так делает
												Если МетаданныеСлова = Неопределено Тогда
													ИмяОсновногоКлассаCOM = ирОбщий.ПоследнийФрагментЛкс(ПолноеИмяОсновногоКлассаCOM);
													ИмяОбщегоТипа = ИмяОсновногоКлассаCOM + " {" + ПолноеИмяОсновногоКлассаCOM + "}";
												Иначе
													ИмяОбщегоТипа = мПлатформа.ПолноеИмяТипаCOMОбъекта(МетаданныеСлова, ПолноеИмяОсновногоКлассаCOM);
													Если ирОбщий.СтрокиРавныЛкс(ИмяОбщегоТипа, "COMОбъект") Тогда
														ИмяОсновногоКлассаCOM = ирОбщий.ПоследнийФрагментЛкс(ПолноеИмяОсновногоКлассаCOM);
														ИмяОбщегоТипа = ИмяОсновногоКлассаCOM + " {" + ПолноеИмяОсновногоКлассаCOM + "}";
													КонецЕсли; 
													СтруктураКОМТипа.Вставить("Метаданные", МетаданныеСлова);
												КонецЕсли; 
												СтруктураКОМТипа.Вставить("ИмяОбщегоТипа", ИмяОбщегоТипа); 
												мИменаОбщихТиповПоИменамКлассовCOM[ПолноеИмяОсновногоКлассаCOM] = СтруктураКОМТипа;
											КонецЕсли; 
											ЗаполнитьЗначенияСвойств(СтруктураТипа, СтруктураКОМТипа); 
										ИначеЕсли ТипНового <> Неопределено Тогда
											СтруктураТипа = мПлатформа.СтруктураТипаИзКонкретногоТипа(ТипНового, мЯзыкПрограммы);
											Если Ложь
												Или ТипНового = Тип("Запрос") 
												Или ТипНового = Тип("ПостроительЗапроса") 
											Тогда 
												ПервыйФактПараметр = ПоследнееВхождение.SubMatches(ЧислоГруппВШаблонеВыражения + 6);
												Если ПервыйФактПараметр <> Неопределено Тогда 
													КоординатыТекста = Неопределено; // см. НовыеКоординатыВыражения()
													ТекстПакета = ВычислитьЗначениеВыражения(ПервыйФактПараметр,,, Позиция0ВМетодеОт, Позиция0ВхожденияВМетоде, КоординатыТекста);
													Если КоординатыТекста <> Неопределено Тогда
														СтруктураТипа.ДержательМетаданных = НовыйМенеджерВременныхТаблиц(Ложь);
														СтруктураТипа.ДержательМетаданных.ПакетыЗапросов.Добавить(НовыйПакетЗапросов(КоординатыТекста.Выражение, КоординатыТекста));  
														СтруктураТипа.Метаданные = мПлатформа.ПостроительЗапросаИзТекстаДляТипа(ТекстПакета);
													КонецЕсли;
												КонецЕсли;
											ИначеЕсли ТипНового = Тип("МенеджерВременныхТаблиц") Тогда
												Если Истина
													И ТаблицаТиповРодителя.Количество() > 0
													И ТаблицаТиповРодителя[0].ИмяОбщегоТипа = "Запрос"
													И ТипЗнч(ТаблицаТиповРодителя[0].ДержательМетаданных) = Тип("Структура")
													И ТаблицаТиповРодителя[0].ДержательМетаданных.Активен
													И ирОбщий.СтрокиРавныЛкс(ТекущееСлово, "МенеджерВременныхТаблиц")
												Тогда
													// Опасно
												Иначе
													СтруктураТипа.Метаданные = НовыйМенеджерВременныхТаблиц(Истина);
													СтруктураТипа.ДержательМетаданных = НовыеКоординатыВыражения(ПрисвоенныйКонтекст, Позиция0ВхожденияВМетоде);
												КонецЕсли;
											ИначеЕсли ТипНового = Тип("ОписаниеИсточникаДанных") Тогда
												ПервыйФактПараметр = ПоследнееВхождение.SubMatches(ЧислоГруппВШаблонеВыражения + 6);
												Если ПервыйФактПараметр <> Неопределено Тогда
													ТаблицаТиповПараметра = ВычислитьТипЗначенияВыражения(ПервыйФактПараметр,,,,,, Ложь,,, Истина, Позиция0ВМетодеОт, Позиция0ВхожденияВМетоде);
													Если мПлатформа.ЛиДетальностьТиповДостаточна(ТаблицаТиповПараметра, 4) Тогда
														СтруктураТипа.Метаданные = ТаблицаТиповПараметра;
													КонецЕсли;
												КонецЕсли;
											ИначеЕсли ТипНового = Тип("ИсточникДоступныхНастроекКомпоновкиДанных") Тогда
												ПервыйФактПараметр = ПоследнееВхождение.SubMatches(ЧислоГруппВШаблонеВыражения + 6);
												Если ПервыйФактПараметр <> Неопределено Тогда
													СхемаКомпоновки = ВычислитьЗначениеВыражения(ПервыйФактПараметр,,, Позиция0ВМетодеОт, Позиция0ВхожденияВМетоде);
													Если СхемаКомпоновки <> Неопределено Тогда
														СтруктураТипа.Метаданные = СхемаКомпоновки;
													КонецЕсли;
												КонецЕсли;
											ИначеЕсли ТипНового = Тип("ОписаниеТипов") Тогда
												ПервыйФактПараметр = ПоследнееВхождение.SubMatches(ЧислоГруппВШаблонеВыражения + 6);
												Если ПервыйФактПараметр <> Неопределено Тогда
													ИменаТипов = ВычислитьЗначениеВыражения(ПервыйФактПараметр,,, Позиция0ВМетодеОт, Позиция0ВхожденияВМетоде);
													Если ЗначениеЗаполнено(ИменаТипов) Тогда
														Попытка
															СтруктураТипа.Метаданные = Новый ОписаниеТипов(ИменаТипов);
														Исключение
														КонецПопытки;
													КонецЕсли;
												КонецЕсли;
											ИначеЕсли ТипНового = Тип("ХранилищеЗначения") Тогда
												ПервыйФактПараметр = ПоследнееВхождение.SubMatches(ЧислоГруппВШаблонеВыражения + 6); // Не поддерживается вложенный конструктор
												Если ПервыйФактПараметр <> Неопределено Тогда
													ТаблицаТиповПараметра = ВычислитьТипЗначенияВыражения(ПервыйФактПараметр,,,,,, Ложь,,, Истина, Позиция0ВМетодеОт, Позиция0ВхожденияВМетоде);
													СтруктураТипа.Метаданные = ТаблицаТиповПараметра;
												КонецЕсли;
											ИначеЕсли Ложь
												Или ТипНового = Тип("Структура") 
												Или ТипНового = Тип("ФиксированнаяСтруктура") 
											Тогда                                                
												ПервыйФактПараметр = ПоследнееВхождение.SubMatches(ЧислоГруппВШаблонеВыражения + 6);
												Если ПервыйФактПараметр <> Неопределено Тогда
													ТаблицаТиповПараметра = ВычислитьТипЗначенияВыражения(ПервыйФактПараметр,,,,,, Ложь,,, Истина, Позиция0ВМетодеОт, Позиция0ВхожденияВМетоде);
													ИменаСвойств = "";
													ЛучшийТип = ЛучшийТипИзТаблицыТипов(ТаблицаТиповПараметра);
													Если ЛучшийТип <> Неопределено Тогда
														Если Ложь
															Или ТипЗнч(ЛучшийТип.Метаданные) = Тип("Структура") 
															Или ТипЗнч(ЛучшийТип.Метаданные) = Тип("ТаблицаЗначений")
														Тогда
															СтруктураТипа.Метаданные = ЛучшийТип.Метаданные;
														ИначеЕсли ТипЗнч(ЛучшийТип.Метаданные) = Тип("Строка") Тогда
															ИменаСвойств = ЛучшийТип.Метаданные;
															Если ЗначениеЗаполнено(ИменаСвойств) Тогда
																Попытка
																	СтруктураТипа.Метаданные = Новый Структура(ИменаСвойств);
																Исключение
																	ИменаСвойств = "";
																КонецПопытки; 
															КонецЕсли;
														КонецЕсли;
													КонецЕсли;
													Если ЗначениеЗаполнено(ИменаСвойств) Тогда
														Если ЗначениеЗаполнено(ДляСвойства) Тогда
															ДляСвойстваПервое = ирОбщий.ПервыйФрагментЛкс(ДляСвойства);
															ДляСвойстваВниз = ирОбщий.СтрокаБезПервогоФрагментаЛкс(ДляСвойства);
														Иначе
															ДляСвойстваПервое = "";
															ДляСвойстваВниз = ИмяФиктивногоСвойства(); 
														КонецЕсли;
														ИменаСвойств = ирОбщий.СтрРазделитьЛкс(ИменаСвойств, ",", Истина,,, Истина);
														ПараметрыКонструктора = Сред(ПоследнееВхождение.Value, Найти(ПоследнееВхождение.Value, "("));
														ПараметрыКонструктора = СокрП(ПараметрыКонструктора);
														ВыраженияЗначений = РазобратьФактическиеПараметрыВызова(ПараметрыКонструктора);
														Для ИндексСвойства = 0 По Мин(ИменаСвойств.ВГраница(), ВыраженияЗначений.Количество() - 2) Цикл 
															ВыражениеЗначения = ВыраженияЗначений[ИндексСвойства + 1];
															Если ПустаяСтрока(ВыражениеЗначения) Тогда
																Продолжить;
															КонецЕсли;
															ИмяСвойства = ИменаСвойств[ИндексСвойства];
															Если Истина
																И ЗначениеЗаполнено(ДляСвойстваПервое)
																И Не ирОбщий.СтрокиРавныЛкс(ДляСвойстваПервое, ИмяСвойства)
															Тогда
																Продолжить;
															КонецЕсли;
															ТаблицаПрисвоенныхТипов = ВычислитьТипЗначенияВыражения(ВыражениеЗначения,,,,, ПолныйАнализСоставаТипов, Ложь,,,,, Позиция0ВхожденияВМетоде,, ДляСвойстваВниз);
															Если ТаблицаПрисвоенныхТипов.Количество() = 0 Тогда
																ТаблицаПрисвоенныхТипов = Неопределено;
															ИначеЕсли ЗначениеЗаполнено(ДляСвойстваПервое) Тогда
																ТаблицаПрисвоенныхТипов.Колонки.Метаданные.Заголовок = ЗаголовокФлагОбрезкиГлубины();
															КонецЕсли;
															СтруктураТипа.Метаданные[ИмяСвойства] = ТаблицаПрисвоенныхТипов;
														КонецЦикла;
														Если мПлатформа.мРежимПереходаКОпределению Тогда
															Для Каждого ИмяСвойства Из ИменаСвойств Цикл 
																СтруктураТипа.Метаданные[ИмяСвойства] = ТаблицаТиповДинамическогоСвойства(СтруктураТипа.Метаданные[ИмяСвойства], ПоследнееВхождение.FirstIndex);
															КонецЦикла;
														КонецЕсли;
													КонецЕсли;
												КонецЕсли;
											КонецЕсли;
										КонецЕсли;
									КонецЕсли; 
									мПлатформа.ДобавитьВТаблицуТипов(ТаблицаТипов, СтруктураТипа);
								Иначе
									ПредСлово = ПоследнееВхождение.SubMatches(0);
									Если Ложь
										Или ПредСлово = "И"
										Или ПредСлово = "Или"
										Или ПредСлово = "Если"
										Или ПредСлово = "ИначеЕсли"
									Тогда
										ЛиУстановкаЗначения = Ложь;
										Если ПроверятьТипЧерезЕсли Тогда 
											//ПрименитьТип = МожноПрименитьПрисвоениеТипаИзЕсли(ТекстПроверкиВеток, ГлубинаВеток.Необязательная);
											ПрименитьТип = МожноПрименитьПрисвоениеТипаИзЕсли(ТекстДляПоискаОпределения, Позиция0ВМетодеДо, ПоследнееВхождение, Позиция0ВхожденияВМетоде, ГлубинаВеток.Необязательная);
										Иначе 
											ПрименитьТип = Ложь;
										КонецЕсли;
									Иначе 
										ПрименитьТип = Истина;
									КонецЕсли;
									Если ПрименитьТип Тогда 
										ТаблицаПрисвоенныхТипов = ВычислитьТипЗначенияВыражения(ПрисвоенныйКонтекст,,,,, ПолныйАнализСоставаТипов, Ложь,,, ВычислитьЗначение,, Позиция0ВхожденияВМетоде,, ДляСвойства);
										Если ТаблицаПрисвоенныхТипов.Количество() > 0 Тогда
											Если ТаблицаТиповИзКомментария <> Неопределено Тогда
												ДобавитьЕдинственныйТип(ТаблицаПрисвоенныхТипов, ТаблицаТиповИзКомментария[0]);
											КонецЕсли;
											ИмяОбщегоТипа = ТаблицаПрисвоенныхТипов[0].ИмяОбщегоТипа;
											Если Истина
												И ирОбщий.СтрНачинаетсяСЛкс(ИмяОбщегоТипа, "Обещание", Истина) 
												И (Ложь
													// TODO переделать на группу
													Или ирОбщий.СтрНайтиЛкс(ПоследнееВхождение.Value, " Ждать ") > 0 
													Или ирОбщий.СтрНайтиЛкс(ПоследнееВхождение.Value, " ждать ") > 0)
											Тогда
												ТаблицаПрисвоенныхТипов[0].ИмяОбщегоТипа = ирОбщий.ТекстМеждуМаркерамиЛкс(ИмяОбщегоТипа, "[", "]", Ложь);
											КонецЕсли;
											Для Каждого СтрокаТипа Из ТаблицаПрисвоенныхТипов.НайтиСтроки(ОтборПоПроизвольномуИмениТипа) Цикл
												СтрокаТипа.Метаданные = Неопределено; // Чтобы колонки владеющей таблицы значений не переносились
											КонецЦикла; 
											Если Истина
												И ГлубинаВеток.Необязательная = Неопределено 
												И ЧислоПроверенныхВариантов = 1 
												И ТаблицаТипов.Количество() > 0
												И Не ЛиСистемноеСлово(ТаблицаТипов[0]) // 
											Тогда
												// Опасно. Для см. Обработка.ирПлатформа.Форма.СписокЗначений.ЗагрузитьЭлементыСписка: Таблица.НайтиСтроки(Новый Структура("Картинка"))
												ТаблицаТипов.Очистить();
											КонецЕсли;
											мПлатформа.ДобавитьВТаблицуТипов(ТаблицаТипов, ТаблицаПрисвоенныхТипов,,,, ИмяОбщегоТипа = "ЭлементыФормы"); // особый двойственный тип
										КонецЕсли;
									Иначе
										ЧислоПроверенныхВариантов = ЧислоПроверенныхВариантов - 1;
									КонецЕсли;
								КонецЕсли;
							Иначе
								// Это обход коллекции
								ПрисвоенныйКонтекст = ПоследнееВхождение.SubMatches(ЧислоГруппВШаблонеВыражения + 17);
								ДляСвойстваВниз = "0";
								Если Истина
									И ЗначениеЗаполнено(ДляСвойства)
									И НРег(ирОбщий.ПервыйФрагментЛкс(ДляСвойства)) <> "значение" //TODO передать хвост вниз 
								Тогда
									ДляСвойстваВниз = ДляСвойстваВниз + "." + ДляСвойства;
								КонецЕсли;
								ТаблицаТиповКоллекции = ВычислитьТипЗначенияВыражения(ПрисвоенныйКонтекст,,,,, ПолныйАнализСоставаТипов, Ложь,,,,, Позиция0ВхожденияВМетоде,, ДляСвойстваВниз);
								Для Каждого СтруктураТипаКоллекции Из ТаблицаТиповКоллекции Цикл
									Если ЗначениеЗаполнено(СтруктураТипаКоллекции.ИмяОбщегоТипа) Тогда
										ЛиУстановкаЗначения = Истина;
										мПлатформа.ТаблицаТиповЭлементовКоллекции(СтруктураТипаКоллекции,, мЯзыкПрограммы, ТаблицаТипов);
									КонецЕсли;
								КонецЦикла;
								Если ТаблицаТиповКоллекции.Колонки.Метаданные.Заголовок <> "" Тогда
									ТаблицаТипов.Колонки.Метаданные.Заголовок = ТаблицаТиповКоллекции.Колонки.Метаданные.Заголовок;         
								КонецЕсли;
							КонецЕсли;
							Если ЛиУстановкаЗначения Тогда
								ГлубинаИзмениласьПослеПрисвоения = Ложь;
							КонецЕсли;
							Если СобиратьВсеПрисвоения Тогда
								Если ЛиУстановкаЗначения Тогда
									ВсеПрисвоения.Добавить(ПоследнееВхождение.FirstIndex, ПоследнееВхождение.Value); // Возможно нужно заменить на Позиция0ВхожденияВМетоде
								КонецЕсли;
								Продолжить;
							КонецЕсли;
							Если Ложь
								Или (Истина
									И ЛиУстановкаЗначения 
									И ГлубинаВеток.Необязательная = Неопределено
									И Не ЛиПеременнаяРезультата)
								Или ЧислоПроверенныхВариантов >= 3 И Не ЭтоФактическийТип // для ускорения 
								Или ЧислоПроверенныхВариантов >= 5 И ЭтоФактическийТип // для ускорения 
								Или Истина
									И Не ЛиПеременнаяРезультата
									И ЧислоПроверенныхВариантов >= ?(ГлубинаВеток.Необязательная = Неопределено, 1, 2) // для СтруктураКлючаТаблицыБДЛкс нужно 2
									И мПлатформа.ЛиДетальностьТиповДостаточна(ТаблицаТипов, 4,,, Ложь) // если делать меньше 3, то будет давать артефакты частичное обновление модуля, т.к. там не очищаем колонку ТипЗначения
							Тогда 
								Прервать;
							КонецЕсли;
						КонецЦикла;
						Если Истина
							И ЛиУстановкаЗначения 
							И ДопКлючКэша <> "МенеджерВременныхТаблиц" 
						Тогда 
							Позиция0ВМетодеОт = Позиция0ВхожденияВМетоде;
						КонецЕсли;
						Если ТаблицаТипов.Количество() > 0 Тогда
							Если СтруктураМоноТипа <> Неопределено Тогда
								Если Не ДобавитьЕдинственныйТип(ТаблицаТипов, СтруктураМоноТипа, ЭтоФактическийТип) Тогда
									ТаблицаТипов.Очистить();
								КонецЕсли;
							КонецЕсли;
						КонецЕсли;
					КонецЕсли;
				КонецЕсли;
			КонецЕсли; 
			Если ТаблицаТипов.Количество() > 0 Тогда
				СтруктураТипа = ТаблицаТипов[0];   
			КонецЕсли;
			Если Истина
				И ТипСлова = "Свойство"
				И Не СтруктураТипа.Конструктор
				И (Ложь // Отсечки циклических зависимостей для модуля конструктора запросов
					Или Не ЛиПеременнаяМодуля
					Или ГлобальныйПоискВМодулеВход)
			Тогда     
				Если ЛиПеременнаяРезультата Тогда 
					ЛиВиртПрисвоение = Истина;
				КонецЕсли;
				СобратьДинамическиеСвойстваОбъекта(Выражение, ТаблицаТипов,, ЭтоВызовКонструктора, ПолныйАнализСоставаТипов, ГлобальныйПоискВМодуле, Позиция0ВМетодеОт,
					Позиция0ВМетодеДо, ДляСвойства, ЛиВиртПрисвоение, ЛиПеременнаяМодуля);
			КонецЕсли;
			Если Истина 
				И мЯзыкПрограммы = 1
				И РодительскийКонтекст = ""
				И СтруктураТипа.ИмяОбщегоТипа = "НеизвестныйКонтекст"
				И Не ЗначениеЗаполнено(ТаблицаПрисвоенныхТипов)
			Тогда 
				Если Истина
					И ТипЗнч(КонтекстВыполнения) = Тип("Запрос") 
					И КонтекстВыполнения.МенеджерВременныхТаблиц <> Неопределено
					И Лев(ТекущееСлово, 1) <> "&"
				Тогда 
					ВременныйЗапрос = Новый Запрос;
					ВременныйЗапрос.МенеджерВременныхТаблиц = КонтекстВыполнения.МенеджерВременныхТаблиц;
					ВременныйЗапрос.Текст = "ВЫБРАТЬ * ИЗ " + ТекущееСлово + " ГДЕ ЛОЖЬ";
					Попытка
						// Активное вычисление!
						СтруктураТипа.Метаданные = ВременныйЗапрос.Выполнить();
						СтруктураТипа.ИмяОбщегоТипа = "ВременнаяТаблица";
						СтруктураТипа.ВиртуальнаяТаблица.Выражение = ТекущееСлово; // Используем не по назначению  
					Исключение
					КонецПопытки;
				ИначеЕсли ирОбщий.НайтиРегВыражениеЛкс(мТекстБлока, "КАК\s+" + ТекущееСлово,, Ложь).Количество() Тогда // Добавил условие чтобы предложение псевдонима таблицы не создавало сразу временную таблицу
					СтрокаДоступнойТаблицы = НайтиДобавитьДоступнуюВременнуюТаблицу(ТекущееСлово);
					ТаблицаДоступныхПолей = ПоляДоступнойТаблицы(СтрокаДоступнойТаблицы);
					Если ТаблицаДоступныхПолей.Колонки.Найти("Заголовок") = Неопределено Тогда   
						ТаблицаДоступныхПолей.Колонки.Добавить("Заголовок");
					КонецЕсли;
					СтруктураТипа.ИмяОбщегоТипа = "ВременнаяТаблица";
					СтруктураТипа.Метаданные = ирОбщий.УстановитьМетаданныеКоллекцииЛкс(ТаблицаДоступныхПолей);
				Иначе
					СтрокаДоступнойТаблицы = ДоступнаяТаблицаПоЛюбомуИмени(ТекущееСлово);
					Если СтрокаДоступнойТаблицы <> Неопределено Тогда
						ТаблицаДоступныхПолей = ПоляДоступнойТаблицы(СтрокаДоступнойТаблицы);
						Если ТаблицаДоступныхПолей.Колонки.Найти("Заголовок") = Неопределено Тогда   
							ТаблицаДоступныхПолей.Колонки.Добавить("Заголовок");
						КонецЕсли;
						СтруктураТипа.ИмяОбщегоТипа = "ВременнаяТаблица";
						СтруктураТипа.Метаданные = ирОбщий.УстановитьМетаданныеКоллекцииЛкс(ТаблицаДоступныхПолей);
					КонецЕсли;
				КонецЕсли;
			КонецЕсли;
			//Если ТипыВыраженийМетода <> Неопределено Тогда
			//	ТипыВыраженийМетода.Вставить(КлючВыраженияСПозицией, ТаблицаТипов);
			//КонецЕсли;
		КонецЕсли; 
	КонецЕсли;
	Если ТаблицаТипов.Количество() = 0 Тогда
		мПлатформа.ДобавитьВТаблицуТипов(ТаблицаТипов, СтруктураТипа);
	КонецЕсли;
	Если СобиратьОшибки Тогда 
		ПроверитьВозможныеОшибкиВыражения(ТаблицаТиповОтРодителя, Позиция0ВМетодеДо, ТаблицаТипов, ЛиВиртПрисвоение, РодительскийКонтекст, ТаблицаТиповРодителя, ТекущееСлово, ТекущиеАргументы, ТекущийИндекс, ТипСлова);
	КонецЕсли;
~Возврат:
	Если Истина
		И ТипыВыраженийМетода <> Неопределено 
		И ТаблицаТипов.Колонки.Метаданные.Заголовок <> ""
	Тогда
		ТипыВыраженийМетода[КлючВыраженияСПозицией] = Неопределено;
		ТипыВыраженийМетода[КлючВыраженияСПозициейИСвойством] = ТаблицаТипов;
	КонецЕсли;
	Если ЛиКорневойВызов Тогда
		мРекурсивныйПуть = Неопределено;
		Если ТаблицаТипов.Количество() > 1 Тогда
			ТаблицаТипов.Сортировать("Детальность Убыв");
		КонецЕсли;  
	КонецЕсли;
	Если ГлобальныйПоискВМодулеВход Тогда
		ЗагрузитьМетодМодуля(СтарыйМетод);
	КонецЕсли;
	Возврат ТаблицаТипов;

КонецФункции

//.
// Параметры:
//   Выражение - Строка - 
//   Позиция0ДляКэша - при глобальном поиске игнорируется - 
//   ЭтоВызовКонструктора - Булево - передается когда выражение конструктора передано без слова "Новый"
//   ДляСвойства - Строка - путь к свойству, например "ПервыйБлок.Начало", для отсечения вычисления внутренней структуры передавать ИмяФиктивногоСвойства()
//   КлючВыраженияСПозицией - Строка - 
//   КлючВыраженияСПозициейИСвойством - Строка - 
//   ТипыВыраженийМетода - Соответствие - 
// Возвращаемое значение:
//   ТаблицаЗначений, Неопределено - 
Функция ТаблицаТиповВыраженияИзКэша(Знач Выражение, Знач Позиция0ДляКэша, Знач ДляСвойства = "", Знач ЭтоВызовКонструктора = Ложь, Знач ГлобальныйПоискВМодулеВход, 
		КлючВыраженияСПозицией = "", КлючВыраженияСПозициейИСвойством = "", ТипыВыраженийМетода = Неопределено) Экспорт
	Если ЯзыкПрограммы = 0 Тогда
		Если ЭтоВызовКонструктора И Найти(Выражение, "(") = 0 Тогда
			// Ускорение. Независимый терминал, например "Новый Массив"
			Позиция0ДляКэша = 0;
			ТипыВыраженийМетода = мПлатформа.мТипыВыражений;
		ИначеЕсли мМетодМодуля <> Неопределено Тогда
			ТипыВыраженийМетода = мМетодМодуля.ТипыВыражений;
			Если ТипыВыраженийМетода = Неопределено Тогда
				ТипыВыраженийМетода = Новый Соответствие;
				мМетодМодуля.ТипыВыражений = ТипыВыраженийМетода;
			КонецЕсли;
		Иначе
			ТипыВыраженийМетода = мМодульМетаданных.ТипыВыраженийПрограммы;
		КонецЕсли;
	Иначе
		ТипыВыраженийМетода = мРекурсивныйПуть.ТипыВыраженийЗапроса;
	КонецЕсли;
	КлючВыраженияСПозицией = XMLСтрока(Позиция0ДляКэша) + ";" + мРекурсивныйПуть.ДопКлючКэша 
		//+ ";" + ГлобальныйПоискВМодулеВход //Нужно против рекурсивного попадания в недосчитанный тип для самозависимой переменной модуля, например Обработка.ирКонсольЗапросов.Форма.Форма.мТекущаяСтрокаДереваЗапросов
		+ ";" + Лев(Выражение, 200); // Случай НЕ обрезаемых метаданных
	// Жесткая обрезка по глубине сделана для конструктора запроса "0.ЧастиОбъединения.0.СвязиТаблиц.Строки.0.Таблица.ВложенныйПакет.0.ЧастиОбъединения"
	// Опасно! Такая обрезка может приводить к использованию структур обрезанных на большей глубине чем требуется
	КлючВыраженияСПозициейИСвойством = КлючВыраженияСПозицией + ";#" + ирОбщий.ПервыеФрагментыЛкс(ДляСвойства,, 8); // Случай обрезаемых метаданных по глубине или ширине
	ТаблицаТиповКэш = ТипыВыраженийМетода[КлючВыраженияСПозицией]; // см. мПлатформа.НоваяТаблицаТипов()
	Если Истина
		И ТаблицаТиповКэш = Неопределено
		//И ЗначениеЗаполнено(ДляСвойства) // Отключил условие 31.12.2024
		//И Не мПлатформа.мРежимПроверкиМодуля
	Тогда
		ТаблицаТиповКэш = ТипыВыраженийМетода[КлючВыраженияСПозициейИСвойством]; // см. мПлатформа.НоваяТаблицаТипов()
	КонецЕсли;
	Возврат ТаблицаТиповКэш;
КонецФункции

//.
// Параметры:
//    Позиция0ВМетодеДо - Число -  
// Возвращаемое значение:
//    Структура - 
Функция НоваяГлубинаВеток(Знач Позиция0ВМетодеДо = 0) Экспорт
	ГлубинаВеток = Новый Структура;
	ГлубинаВеток.Вставить("Основная", 0); // - разница глубины
	ГлубинаВеток.Вставить("Максимальная", 0); // - максимальная глубина
	ГлубинаВеток.Вставить("Альтернативная", -1); // - глубина альтернативной ветки, т.е. она точно не будет выполнена
	ГлубинаВеток.Вставить("Необязательная", Неопределено); // - глубина предшествующей ветка внутри родителя, т.е. она не обязательно будет выполнена
	ГлубинаВеток.Вставить("ПредКонецВхождения", Позиция0ВМетодеДо);
	Возврат ГлубинаВеток;
КонецФункции

//.
// Параметры:
//    ТекстДляПоискаОпределения - Строка  -  где ищем определение;
//    ГлубинаВеток - Структура - 
//    ПозицияВхождения0 -  - 
//    ПоследнееВхождение -  - 
// Возвращаемое значение:
//    Строка - 
Функция СчитатьГлубинуВеток(Знач ТекстДляПоискаОпределения, Знач ГлубинаВеток, Знач ПозицияВхождения0, Знач ПоследнееВхождение, БылиИзменения = Ложь) Экспорт
	КонецВхождения = ПозицияВхождения0 + ПоследнееВхождение.Length;
	ТекстПроверкиВеток = Сред(ТекстДляПоискаОпределения, КонецВхождения, ГлубинаВеток.ПредКонецВхождения - КонецВхождения + 2);
	ГлубинаВеток.ПредКонецВхождения = КонецВхождения; 
	мРегВыражение.Global = Истина;
	мРегВыражение.Pattern = мПлатформа.шПустоеНачалоСтроки + "(?:(?:Если\s[^\n]*КонецЕсли)|(?:Попытка\s[^\n]*КонецПопытки)|(Если|ИначеЕсли|Иначе|КонецЕсли|Попытка|Исключение|КонецПопытки)(?=\s|/|;|$))";
	ВхожденияЕсли = мРегВыражение.НайтиВхождения(ТекстПроверкиВеток);
	Если ВхожденияЕсли.Количество() > 0 Тогда
		БылиИзменения = Истина;
	КонецЕсли;
	_РежимОтладки = Ложь;
	Если _РежимОтладки Тогда // Можно менять на Истина в точке останова, например условием ирОбщий.Пр(_РежимОтладки, 1, 1)
		// Пассивный оригинал расположенного ниже однострочного кода. Выполняйте изменения синхронно в обоих вариантах.
		// Внутри метода ОбработкаОбъект.ирПлатформа.СловаКонтекстаМетаданные результатов более 400
		Для ИндексВхожденияЕсли = -ВхожденияЕсли.ВГраница() По 0 Цикл
			ВхождениеЕсли = ВхожденияЕсли[-ИндексВхожденияЕсли];
			Токен = НРег(ВхождениеЕсли.SubMatches(0));
			Если Не ЗначениеЗаполнено(Токен) Тогда
				Продолжить;
			ИначеЕсли Токен = "если" Или Токен = "попытка" Тогда
				ГлубинаВеток.Основная = ГлубинаВеток.Основная + 1;
				Если ГлубинаВеток.Основная > ГлубинаВеток.Максимальная Тогда
					ГлубинаВеток.Максимальная = ГлубинаВеток.Основная;
				КонецЕсли;
				Если ГлубинаВеток.Основная > ГлубинаВеток.Альтернативная Тогда
					ГлубинаВеток.Альтернативная = -1;
				КонецЕсли;
				Если ГлубинаВеток.Необязательная <> Неопределено И ГлубинаВеток.Основная > ГлубинаВеток.Необязательная Тогда
					ГлубинаВеток.Необязательная = Неопределено;
				КонецЕсли;
			ИначеЕсли Токен = "конецесли" или Токен = "конецпопытки" Тогда
				ГлубинаВеток.Основная = ГлубинаВеток.Основная - 1;
				Если ГлубинаВеток.Необязательная = Неопределено Тогда
					ГлубинаВеток.Необязательная = ГлубинаВеток.Основная;
				КонецЕсли;
			ИначеЕсли Истина
				И Токен <> "исключение"
				//И ГлубинаВеток.Основная > ГлубинаВеток.Альтернативная 
				И ГлубинаВеток.Основная = ГлубинаВеток.Максимальная
			Тогда
				ГлубинаВеток.Альтернативная = ГлубинаВеток.Основная;
			КонецЕсли;
		КонецЦикла;
	Иначе
		// Однострочный код использован для ускорения при разрешенной отладке. Выше расположен оригинал. Выполняйте изменения синхронно в обоих вариантах. Преобразовано консолью кода из подсистемы "Инструменты разработчика"
		Для ИндексВхожденияЕсли = -ВхожденияЕсли.ВГраница() По 0 Цикл  		ВхождениеЕсли = ВхожденияЕсли[-ИндексВхожденияЕсли];  		Токен = НРег(ВхождениеЕсли.SubMatches(0));  		Если Не ЗначениеЗаполнено(Токен) Тогда  			Продолжить;  		ИначеЕсли Токен = "если" Или Токен = "попытка" Тогда  			ГлубинаВеток.Основная = ГлубинаВеток.Основная + 1;  			Если ГлубинаВеток.Основная > ГлубинаВеток.Максимальная Тогда  				ГлубинаВеток.Максимальная = ГлубинаВеток.Основная;  			КонецЕсли;  			Если ГлубинаВеток.Основная > ГлубинаВеток.Альтернативная Тогда  				ГлубинаВеток.Альтернативная = -1;  			КонецЕсли;  			Если ГлубинаВеток.Необязательная <> Неопределено И ГлубинаВеток.Основная > ГлубинаВеток.Необязательная Тогда  				ГлубинаВеток.Необязательная = Неопределено;  			КонецЕсли;  		ИначеЕсли Токен = "конецесли" или Токен = "конецпопытки" Тогда  			ГлубинаВеток.Основная = ГлубинаВеток.Основная - 1;  			Если ГлубинаВеток.Необязательная = Неопределено Тогда  				ГлубинаВеток.Необязательная = ГлубинаВеток.Основная;  			КонецЕсли;  		ИначеЕсли Истина  			И Токен <> "исключение"    			И ГлубинаВеток.Основная = ГлубинаВеток.Максимальная  		Тогда  			ГлубинаВеток.Альтернативная = ГлубинаВеток.Основная;  		КонецЕсли;  	КонецЦикла;  
	КонецЕсли;
	Возврат ТекстПроверкиВеток;
КонецФункции

Процедура ПроверитьВозможныеОшибкиВыражения(Знач ТаблицаТиповОтРодителя, Знач Позиция0ВМетодеДо, Знач ТаблицаТипов, Знач ЛиВиртПрисвоение, Знач РодительскийКонтекст, Знач ТаблицаТиповРодителя, Знач ТекущееСлово,
	Знач ТекущиеАргументы, Знач ТекущийИндекс, Знач ТипСлова) Экспорт
	
	Если ЗначениеЗаполнено(ТекущиеАргументы) Тогда 
		ВызовМетода = РодительскийКонтекст + "." + ТекущееСлово;
		ПозицияОшибки = Позиция0ВМетодеДо + СтрДлина(ВызовМетода + "(");
		Если Истина
			И ТекущиеАргументы <> "()"
			И мРекурсивныйПуть.ВложенныеВыражения.Найти(ТекущиеАргументы, "Выражение") = Неопределено // Если тут ошибка, то где то опять забыл установить ВычислитьТипЗначенияВыражения(ЛиКорневойВызов=Ложь)
		Тогда
			СтрокаВыражения = мРекурсивныйПуть.ВложенныеВыражения.Добавить();
			СтрокаВыражения.Выражение = ТекущиеАргументы;
			СтрокаВыражения.ВызовМетода = ВызовМетода;
			СтрокаВыражения.Позиция0ВБлоке = ПозицияОшибки;
		КонецЕсли;
		Если Истина
			И (Ложь
				Или Не мФлагиПодавленияОшибок.Свойство("МалоПараметров") 
				Или Не мФлагиПодавленияОшибок.Свойство("МногоПараметров"))
			И ЗначениеЗаполнено(РодительскийКонтекст) // Корневые вызовы платформа проверяет. Поэтому не будет тратить на них время
			И ТаблицаТипов.Количество() > 0 
			И СтрЧислоВхождений(ТекущиеАргументы, "(") < 3 // Иначе РазобратьФактическиеПараметрыВызова() будет часто давать некорректный результат 
		Тогда
			ЕстьНарушение = Неопределено;
			ФактическиеПараметры = Неопределено;
			ПройденныеСтроки = Новый Соответствие;
			ТипОшибки = "";
			Для Каждого СтрокаТипа Из ТаблицаТипов Цикл
				СтрокаОписания = СтрокаТипа.СтрокаОписания;
				Если ПройденныеСтроки[СтрокаОписания] <> Неопределено Тогда
					Продолжить;
				КонецЕсли;
				ПройденныеСтроки[СтрокаОписания] = 1;
				Если ТипЗнч(СтрокаОписания) = Тип("СтрокаТаблицыЗначений") Тогда
					ЧислоФормальныхПараметров = Неопределено;
					Если Истина
						И СтрокаОписания.Владелец().Колонки.Найти("ТелоБезВозвратов") <> Неопределено 
						//! СтрокаОписания = 0 // см. мПлатформа.НоваяТаблицаМетодовМодуля()[0]
						И СтрокаОписания.Имя <> "<>"
					Тогда  
						ФормальныеПараметрыМетода = мПлатформа.ПараметрыМетодаМодуля(СтрокаОписания);
						Если ФормальныеПараметрыМетода = Неопределено Тогда
							ЧислоФормальныхПараметров = 0;
						Иначе
							ЧислоФормальныхПараметров = ФормальныеПараметрыМетода.Количество();
						КонецЕсли;
						МинЧислоПараметров = СтрокаОписания.МинЧислоПараметров;
					ИначеЕсли Истина
						И СтрокаОписания.Владелец().Колонки.Найти("ТипКонтекста") <> Неопределено 
						//! СтрокаОписания = 0 // см. мПлатформа.ТаблицаКонтекстов[0]
						И СтрокаОписания.ТипСлова = "Метод"
						И Найти(СтрокаОписания.Слово, "<") = 0
					Тогда
						ФормальныеПараметрыМетода = мПлатформа.ПараметрыМетодаПлатформы(СтрокаОписания);
						ЧислоФормальныхПараметров = ФормальныеПараметрыМетода.Количество();
						Варианты = ирОбщий.РазличныеЗначенияКолонкиТаблицыЛкс(ФормальныеПараметрыМетода, "ВариантСинтаксиса");
						МинЧислоПараметров = 0;
						Если Варианты.Количество() > 0 Тогда
							МинЧислоПараметров = 100;
						КонецЕсли;
						Для Каждого Вариант Из Варианты Цикл
							МаксСтрока = ирОбщий.ЛучшиеЭлементыКоллекцииЛкс(ФормальныеПараметрыМетода, "Номер",, Новый Структура("ВариантСинтаксиса, Необязательный", Вариант, Ложь));
							МинЧислоПараметров = Мин(МинЧислоПараметров, ?(МаксСтрока = Неопределено, 0, МаксСтрока.Номер));
						КонецЦикла;
					КонецЕсли;
					Если ЧислоФормальныхПараметров <> Неопределено И ЕстьНарушение <> Ложь Тогда
						Если ФактическиеПараметры = Неопределено Тогда
							ФактическиеПараметры = РазобратьФактическиеПараметрыВызова(ТекущиеАргументы);
						КонецЕсли;
						Если Истина
							И Не мФлагиПодавленияОшибок.Свойство("МногоПараметров")
							И ЧислоФормальныхПараметров < ФактическиеПараметры.Количество() 
						Тогда
							ЕстьНарушение = Истина;
							ТипОшибки = "МногоПараметров";
						ИначеЕсли Истина
							И Не мФлагиПодавленияОшибок.Свойство("МалоПараметров")
							И МинЧислоПараметров > ФактическиеПараметры.Количество() 
						Тогда
							ЕстьНарушение = Истина;
							ТипОшибки = "МалоПараметров";
						Иначе
							ЕстьНарушение = Ложь;
						КонецЕсли;
						Если Не ЕстьНарушение Тогда
							Прервать;
						КонецЕсли;
					КонецЕсли;
				КонецЕсли;
			КонецЦикла;
			Если ЕстьНарушение = Истина Тогда
				ОшибкаМодуля = ДобавитьОшибкуМодуля(ПозицияОшибки, ТипОшибки); // https://www.hostedredmine.com/issues/983739
				ОшибкаМодуля.ВыражениеРодитель = ВызовМетода + "(";
				ОшибкаМодуля.Слово = ирОбщий.ПредставлениеЗначенияСОграничениемДлиныЛкс(ТекущиеАргументы, Метаданные().ТабличныеЧасти.ОшибкиМодуля.Реквизиты.Слово.Тип.КвалификаторыСтроки.Длина);
				ОшибкаМодуля.Язык = ПредставлениеЯзыкаВыражения();
				ОшибкаМодуля.ТипРодителя = мПлатформа.ПредставлениеМассиваСтруктурТипов(ТаблицаТиповРодителя);
			КонецЕсли;
		КонецЕсли;
	КонецЕсли;
	ЛучшийТипРодителя = Неопределено; // см. мПлатформа.НоваяТаблицаТипов()[0]
	Если Истина
		И Не мФлагиПодавленияОшибок.Свойство("НеизвестноеСлово")
		И ТаблицаТиповОтРодителя = Неопределено 
		И ЗначениеЗаполнено(РодительскийКонтекст) 
		И Не ЛиВиртПрисвоение
		И Не ЗначениеЗаполнено(ТекущийИндекс)
		И ТаблицаТиповРодителя <> Неопределено // не попали в кэш
		И ТаблицаТиповРодителя.Найти("Произвольный", "ИмяОбщегоТипа") = Неопределено // Обработка.ирКлсПолеТекстаПрограммы.Реквизит.Конфигурация
		И мПлатформа.ЛиДетальностьТиповДостаточна(ТаблицаТиповРодителя, 2, Истина, ЛучшийТипРодителя)
		И Не ирОбщий.СтрНачинаетсяСЛкс(ЛучшийТипРодителя.ИмяОбщегоТипа, "ISWbemObject")
		И Не ирОбщий.СтрНачинаетсяСЛкс(ЛучшийТипРодителя.ИмяОбщегоТипа, "AddIn")
		И Не ирОбщий.СтрНачинаетсяСЛкс(ЛучшийТипРодителя.ИмяОбщегоТипа, "IHTMLWindow")
		И Не ирОбщий.ЛиИмяТипаВнешнегоОбъектаМетаданныхЛкс(ЛучшийТипРодителя.ИмяОбщегоТипа)
		//И Найти(ЛучшийТипРодителя.ИмяОбщегоТипа, "<") = 0 // такое условие блокирует проверки реквизитов
		И (Ложь
			Или ирКэш.ЛиПортативныйРежимЛкс()
			Или ЛучшийТипРодителя.Метаданные <> Метаданные.ОбщиеМодули.ирПортативный)
		И Не (Истина
			И ирОбщий.СтрНачинаетсяСЛкс(ЛучшийТипРодителя.ИмяОбщегоТипа, "ПеречислениеКлавиша")
			И (Ложь
				Или СтрДлина(ТекущееСлово) = 1
				Или ирОбщий.СтрНачинаетсяСЛкс(ТекущееСлово, "F"))) 
	Тогда 
		ПозицияОшибки = Позиция0ВМетодеДо + СтрДлина(РодительскийКонтекст + ".");
		ЛучшийТип = Неопределено;
		Если ТаблицаТипов.Количество() > 1 Тогда
			ТаблицаТипов.Сортировать("Детальность Убыв");
			ЛучшийТип = ТаблицаТипов.Найти("СтандартноеХранилищеНастроекМенеджер", "ИмяОбщегоТипа"); // Против Метаданные.ХранилищеОбщихНастроек
		КонецЕсли;
		Если ЛучшийТип = Неопределено И ТаблицаТипов.Количество() > 0 Тогда
			ЛучшийТип = ТаблицаТипов[0]; 
		КонецЕсли;
		ЛиСистемноеСлово = ЛиСистемноеСлово(ЛучшийТип);
		Если Ложь
			Или ЛучшийТип = Неопределено
			Или (Истина
				И ЛучшийТип.Детальность = 0
				И Не ЗначениеЗаполнено(ТекущиеАргументы))
			Или (Истина
				И Прав(РодительскийКонтекст, 1) <> "]"
				И (Ложь
					Или ТипСлова = "Свойство"
					Или ТипСлова = Неопределено)
				И ЛучшийТип.Метаданные <> Неопределено // Язык запросов сюда null пишет
				И ТипЗнч(ЛучшийТип.Метаданные) <> Тип("ОбъектМетаданных")
				И Не ирОбщий.ЛиИмяТипаВнешнегоОбъектаМетаданныхЛкс(ЛучшийТип.ИмяОбщегоТипа)
				И (Ложь
					Или (Истина
						И Найти(ЛучшийТип.ИмяОбщегоТипа, "<") > 0 
						И ЛучшийТип.СтрокаОписания <> Неопределено
						И (Ложь
							Или Найти(ЛучшийТипРодителя.ИмяОбщегоТипа, "<") = 0 
							Или мЯзыкПрограммы = 1 И ТипЗнч(ЛучшийТипРодителя.Метаданные) = Тип("ОбъектМетаданных")))
					Или (Истина 
						И ирОбщий.СтрНачинаетсяСЛкс(ЛучшийТипРодителя.ИмяОбщегоТипа, "КоллекцияМетаданных")
						И ирОбщий.СтрНачинаетсяСЛкс(ЛучшийТип.ИмяОбщегоТипа, "ОбъектМетаданных"))
					))
			Или (Истина
				И ЛучшийТип.ИмяОбщегоТипа = "Произвольный"
				И ТипСлова <> "Метод"
				И (Ложь
					Или (Истина
						И ТипЗнч(ЛучшийТип.Метаданные) = Тип("Структура") // Сюда попадаем для свойства "Значение" объекта ЭлементСпискаЗначений
						// TODO можно переделать на проверку СтрокаОписания
						//И ЛучшийТипРодителя.ИмяОбщегоТипа = "Структура"
						И ЛучшийТипРодителя.ИмяОбщегоТипа <> "ЭлементСпискаЗначений"
						И ЛучшийТипРодителя.ИмяОбщегоТипа <> "КлючИЗначение"
						И Найти(ЛучшийТипРодителя.ИмяОбщегоТипа, "Форм") = 0
						И ТипЗнч(ирОбщий.СвойствоСтруктурыЛкс(ЛучшийТип.Метаданные, "Тип")) <> Тип("Тип") // Не имитатор элемента формы
						И (Ложь
							Или ЛучшийТип.Метаданные.Количество() > 0
							Или ТаблицаТипов.Колонки.Метаданные.Заголовок <> ""))
					Или (Истина
						И ТипЗнч(ЛучшийТип.Метаданные) = Тип("ТаблицаЗначений")
						И ЛучшийТип.Метаданные.Колонки.Количество() > 0)
					Или (Истина
						И ЛиСистемноеСлово
						И Найти(ЛучшийТип.СтрокаОписания.Слово, "<") > 0
						И (Ложь
							Или ЛучшийТип.Метаданные = Null // Мультиметка29332671
							Или ирОбщий.ЛиФормаИлиИмитаторЛкс(ЛучшийТип.Метаданные)
							Или ТипЗнч(ЛучшийТип.Метаданные) = Тип("ТабличныйДокумент")
							Или (Истина
								И ТипЗнч(ЛучшийТип.Метаданные) = Тип("ПостроительЗапроса")
								И ЛучшийТип.Метаданные.ВыбранныеПоля.Количество() > 0)))
					))
			Или (Истина
				И ТаблицаТипов.Количество() = 1
				И ТипЗнч(ЛучшийТип.СтрокаОписания) = Тип("СтрокаТаблицыЗначений")
				И ЛучшийТип.СтрокаОписания.Владелец().Колонки.Найти("Имя") <> Неопределено
				И ЛучшийТип.СтрокаОписания.Имя = "<>")
			Или (Истина
				// Отсуствующие элементы управляемой формы
				И ЛучшийТипРодителя.ИмяОбщегоТипа = "ВсеЭлементыФормы"
				И ЛучшийТип.ИмяОбщегоТипа = "Неопределено"
				И ЛиСистемноеСлово)
			Или (Истина
				И ЛучшийТип.ИмяОбщегоТипа = "" 
				И ЛучшийТип.ТипЯзыка <> "")
		Тогда 
			СобиратьОшибки = Ложь;
			Если мЭтоТекстовыйЛитерал И мЯзыкПрограммы = 0 Тогда
				ПозицияОшибки = ПозицияОшибки + 1;
			КонецЕсли;
			ОшибкаМодуля = ДобавитьОшибкуМодуля(ПозицияОшибки);
			ОшибкаМодуля.ВыражениеРодитель = РодительскийКонтекст;
			ОшибкаМодуля.Слово = ТекущееСлово;
			ОшибкаМодуля.Язык = ПредставлениеЯзыкаВыражения();
			ОшибкаМодуля.ТипРодителя = мПлатформа.ПредставлениеМассиваСтруктурТипов(ТаблицаТиповРодителя);
			Если ТипСлова = "Метод" Тогда
				ОшибкаМодуля.Слово = ОшибкаМодуля.Слово + "(";
			КонецЕсли;
		ИначеЕсли Истина
			И мЯзыкПрограммы = 1
			И Найти(ЛучшийТипРодителя.ИмяОбщегоТипа, "<") > 0 
			И ЛучшийТипРодителя.Метаданные = Неопределено
		Тогда
			ОшибкаМодуля = ДобавитьОшибкуМодуля(ПозицияОшибки, "МногоСоединений"); // https://www.hostedredmine.com/issues/992188
			ОшибкаМодуля.ВыражениеРодитель = РодительскийКонтекст;
			ОшибкаМодуля.Слово = ТекущееСлово;
			ОшибкаМодуля.Язык = ПредставлениеЯзыкаВыражения();
			ОшибкаМодуля.ТипРодителя = мПлатформа.ПредставлениеМассиваСтруктурТипов(ТаблицаТиповРодителя);
		КонецЕсли;
	КонецЕсли;
КонецПроцедуры

Функция ЛиСистемноеСлово(Знач СтруктураТипа, Знач ТолькоСТипомКонтекста = Ложь) Экспорт
	Результат = Истина
		И СтруктураТипа <> Неопределено
		И ТипЗнч(СтруктураТипа.СтрокаОписания) = Тип("СтрокаТаблицыЗначений")
		И СтруктураТипа.СтрокаОписания.Владелец().Колонки.Найти("Слово") <> Неопределено
		И (Ложь 
			Или Не ТолькоСТипомКонтекста
			Или СтруктураТипа.СтрокаОписания.Владелец().Колонки.Найти("ТипКонтекста") <> Неопределено);
	Возврат Результат;
КонецФункции

// .
// Параметры:
//  ТекстДляПоискаОпределения	 - Строка	 - где ищем определение;
//  Позиция0ВМетодеДо			 - Число	 - 
//  ВзятьПолныйТекстЧасти		 - Булево	 - Если выключено, то берем текст части до указанной позици
// Возвращаемое значение:
//  Число - начальная позиция текста части объединения начиная с 0
Функция НачалоЧастиОбъединенияЗапроса(Знач ТекстДляПоискаОпределения, Знач Позиция0ВМетодеДо, Знач ВзятьПолныйТекстЧасти = Истина, выхТекстЧасти = "") Экспорт
	мРегВыражение.Global = Истина;
	мРегВыражение.Pattern = "\sОБЪЕДИНИТЬ\s|\sUNION\s";
	ВхожденияЧастей = мРегВыражение.НайтиВхождения(ТекстДляПоискаОпределения,, Истина);
	НачалоЧасти = 0; 
	КонецЧасти = СтрДлина(ТекстДляПоискаОпределения);
	Для Каждого Вхождение Из ВхожденияЧастей Цикл
		Если Позиция0ВМетодеДо <= Вхождение.FirstIndex Тогда
			КонецЧасти = Вхождение.FirstIndex;
			Прервать;
		КонецЕсли; 
		НачалоЧасти = Вхождение.FirstIndex + 1;
	КонецЦикла;
	Если ВзятьПолныйТекстЧасти Тогда 
		Длина = КонецЧасти - НачалоЧасти;
	Иначе
		Длина = Позиция0ВМетодеДо - НачалоЧасти;
	КонецЕсли;
	выхТекстЧасти = Сред(ТекстДляПоискаОпределения, НачалоЧасти + 1, Длина);
	Возврат НачалоЧасти;
КонецФункции

// Используется когда метаданные результата вызова не нужны, а нужно только описание метода.
Функция ИмяФиктивногоПараметра() Экспорт
	Возврат "Зукер6да45";
КонецФункции

//.
// Параметры:
//    ПозицияНачалаМетода - Число - 
// Возвращаемое значение:
//    ОбработкаТабличнаяЧастьСтрока.ирКлсПолеТекстаПрограммы.ОшибкиМодуля - 
Функция ДобавитьОшибкуМодуля(Позиция0ВБлоке, ТипОшибки = "НеизвестноеСлово") Экспорт
    Позиция0ВМодуле = мПозицияТекстаДляПоискаОпределения + Позиция0ВБлоке;
	ОшибкаМодуля = ОшибкиМодуля.Добавить();
	ОшибкаМодуля.ДатаОбнаружения = ТекущаяДата();
	Если мМетодМодуля <> Неопределено Тогда
		ОшибкаМодуля.Метод = мМетодМодуля.Имя;
		ПозицияНачалаМетода = мМетодМодуля.ПозицияТела;
	Иначе 
		ОшибкаМодуля.Метод = мПлатформа.ИмяМетодаИнициация();
		ПозицияНачалаМетода = мМодульМетаданных.ПозицияПрограммы;
    КонецЕсли;
    ОшибкаМодуля.Позиция = Позиция0ВМодуле;
    ОшибкаМодуля.ПозицияВМетоде = Позиция0ВМодуле - ПозицияНачалаМетода;
	ОшибкаМодуля.ТипОшибки = ТипОшибки;
	Возврат ОшибкаМодуля;
КонецФункции

//.
// Возвращаемое значение:
//    Структура - 
Функция НоваяСтруктураТипа(Знач ИмяОбщегоТипа = "НеизвестныйКонтекст") Экспорт
	СтруктураТипа = мПлатформа.НоваяСтруктураТипа(ИмяОбщегоТипа);
	СтруктураТипа.Метаданные = Конфигурация; // Произвольный  
	Возврат СтруктураТипа;
КонецФункции

//.
// Параметры:
//    ШаблонПоиска - Строка - 
// Возвращаемое значение:
//    Строка - 
Функция ШаблонПоискаСловаЧерезЭтотОбъект(Знач ШаблонПоиска) Экспорт
	Если мМодульМетаданных.СтруктураТипа <> Неопределено Тогда
		Если ирОбщий.ЛиИмяТипаФормыЛкс(мМодульМетаданных.СтруктураТипа.ИмяОбщегоТипа, Истина, Ложь) Тогда
			ИмяСамоСвойствоКонтекста = "ЭтаФорма";
		ИначеЕсли ирОбщий.ЛиИмяТипаФормыЛкс(мМодульМетаданных.СтруктураТипа.ИмяОбщегоТипа, Ложь, Истина) Тогда
			ИмяСамоСвойствоКонтекста = "(?:ЭтаФорма|ЭтотОбъект)";
		Иначе
			ИмяСамоСвойствоКонтекста = "ЭтотОбъект";
		КонецЕсли;
		ШаблонПоиска = "(?:" + ИмяСамоСвойствоКонтекста + "\.)?" + ШаблонПоиска;
	КонецЕсли;
	Возврат ШаблонПоиска;
КонецФункции

Функция ИмяСамоСвойстваМодуля() Экспорт
	ИмяСамоСвойстваМодуля = "ЭтотОбъект";
	Если мМодульМетаданных <> Неопределено Тогда
		СтруктураТипаМодуля = мМодульМетаданных.СтруктураТипа;
	КонецЕсли;
	Если Истина
		И СтруктураТипаМодуля <> Неопределено
		И ирОбщий.ЛиИмяТипаФормыЛкс(СтруктураТипаМодуля.ИмяОбщегоТипа, Истина)
	Тогда
		ИмяСамоСвойстваМодуля = "ЭтаФорма";
	КонецЕсли;
	Возврат ИмяСамоСвойстваМодуля;
КонецФункции

Функция ЗаголовокФлагОбрезкиГлубины()
	Возврат "Обрезано";
КонецФункции

//.
// Параметры:
//    Выражение - Строка	  -  
//    ТаблицаТипов - см. мПлатформа.НоваяТаблицаТипов() - 
//    ТекстДляПоискаОпределения - Строка	  -  где ищем определение;
//    ЭтоВызовКонструктора - Булево -  
//    ПолныйАнализСоставаТипов - Булево -  
//    ГлобальныйПоискВМодуле - Булево -  
//    Позиция0ВМетодеОт - Число, Неопределено -  
//    Позиция0ВМетодеДо - Число(10,0) -  
//    ДляСвойстваПуть - Строка - 
//    ЛиВиртПрисвоение - Булево - 
Процедура СобратьДинамическиеСвойстваОбъекта(Знач Выражение, Знач ТаблицаТипов, Знач _ТекстДляПоискаОпределения = "", Знач ЭтоВызовКонструктора = Ложь, Знач ПолныйАнализСоставаТипов = Истина,
	Знач ГлобальныйПоискВМодуле = Ложь, Знач Позиция0ВМетодеОт = 0, Знач Позиция0ВМетодеДо = 0, Знач ДляСвойстваПуть = "", Знач ЛиВиртПрисвоение = Ложь, Знач ЛиПеременнаяМодуля = Ложь) 
	
	//Если Ложь
	//	Или ЗначениеЗаполнено(Позиция0ВМетодеОт) 
	//	Или ЗначениеЗаполнено(Позиция0ВМетодеДо) 
	//Тогда
	//	ТекстДляПоискаОпределения = ДиапазонТекстаДляПоиска(ТекстДляПоискаОпределения, Позиция0ВМетодеОт, Позиция0ВМетодеДо);
	//КонецЕсли;
	Если ЗначениеЗаполнено(ДляСвойстваПуть) Тогда
		ДляСвойства = ирОбщий.ПервыйФрагментЛкс(ДляСвойстваПуть);
		ДляСвойстваВниз = ирОбщий.СтрокаБезПервогоФрагментаЛкс(ДляСвойстваПуть);
	Иначе
		ДляСвойства = "";
		ДляСвойстваВниз = ИмяФиктивногоСвойства(); 
	КонецЕсли;
	ШаблонВыражения = ирОбщий.ТекстДляРегВыраженияЛкс(Выражение);
	Если Истина
		И ЛиПеременнаяМодуля
		//И мМодульМетаданных <> Неопределено
		//И мМодульМетаданных.СтруктураТипа <> Неопределено
		//И мМодульМетаданных.СтруктураТипа.ИмяОбщегоТипа <> "ОбщийМодуль"
	Тогда
		ШаблонВыражения = ШаблонПоискаСловаЧерезЭтотОбъект(ШаблонВыражения);
	КонецЕсли;
	Для Каждого СтруктураТипаЦикл Из ТаблицаТипов Цикл
		Если СтруктураТипаЦикл.ИмяОбщегоТипа = "Неопределено" Тогда
			Продолжить;
		КонецЕсли;
		ЛиПараметрыФормы = Истина
			И СтруктураТипаЦикл.ИмяОбщегоТипа = "ДанныеФормыСтруктура" 
			И ТипЗнч(СтруктураТипаЦикл.СтрокаОписания) = Тип("СтрокаТаблицыЗначений")
			И СтруктураТипаЦикл.СтрокаОписания.Владелец().Колонки.Найти("ТипКонтекста") <> Неопределено
			И СтруктураТипаЦикл.СтрокаОписания.Слово = "Параметры";
		Если Ложь
			Или СтруктураТипаЦикл.ИмяОбщегоТипа = "Структура"
			Или СтруктураТипаЦикл.ИмяОбщегоТипа = "ФиксированнаяСтруктура"
			Или ЛиПараметрыФормы
		Тогда
			Если ДляСвойства = ИмяФиктивногоСвойства() Тогда
				ТаблицаТипов.Колонки.Метаданные.Заголовок = ЗаголовокФлагОбрезкиГлубины();
				Продолжить;
			КонецЕсли;
			Если ЛиПараметрыФормы Тогда
				СтруктураТипаЦикл.Метаданные = мПлатформа.СхемаКоллекцииПараметровФормы(СтруктураТипаЦикл, ДляСвойства);
				ЛиОбрезано = ЗначениеЗаполнено(ДляСвойства);
			Иначе
				ЛиОбрезано = Ложь;
			КонецЕсли;
			СтруктураТипаЦикл.Метаданные = СобратьСвойстваСтруктуры(Выражение, СтруктураТипаЦикл.Метаданные, ГлобальныйПоискВМодуле, ЛиВиртПрисвоение, Позиция0ВМетодеОт, Позиция0ВМетодеДо, ДляСвойства,
				ДляСвойстваВниз, ЛиОбрезано, ШаблонВыражения, ЛиПараметрыФормы);
			Если ЛиОбрезано Тогда
				ТаблицаТипов.Колонки.Метаданные.Заголовок = ЗаголовокФлагОбрезкиГлубины();
			КонецЕсли;
			Если Истина
				И ТипЗнч(СтруктураТипаЦикл.Метаданные) = Тип("Структура")
				И СтруктураТипаЦикл.Метаданные.Количество() = 0 
			Тогда
				//СтруктураТипаЦикл.Метаданные = Неопределено; // чтобы детальность не стала 5 Мультиметка481662548
				СтруктураТипаЦикл.Детальность = 3;
			Иначе
				мПлатформа.ОбновитьДетальностьСтруктурыТипа(СтруктураТипаЦикл);
			КонецЕсли;
		КонецЕсли; 
		Если ЛиВиртПрисвоение Тогда
			Продолжить;
		КонецЕсли;
		Если ирОбщий.ПервыйФрагментЛкс(СтруктураТипаЦикл.ИмяОбщегоТипа, "[") = "Массив" Тогда
			Если ДляСвойства = ИмяФиктивногоСвойства() Тогда
				ТаблицаТипов.Колонки.Метаданные.Заголовок = ЗаголовокФлагОбрезкиГлубины();
				Продолжить;
			КонецЕсли;
			Если Найти(СтруктураТипаЦикл.ИмяОбщегоТипа, "[") > 0 Тогда
				ИмяТипаЭлемента = ирОбщий.ТекстМеждуМаркерамиЛкс(СтруктураТипаЦикл.ИмяОбщегоТипа, "[", "]");
				Если ИмяТипаЭлемента = "РезультатЗапроса" Тогда
					Продолжить;
				КонецЕсли;
				ТаблицаТиповЭлемента = Неопределено;
				Если ТипЗнч(СтруктураТипаЦикл.Метаданные) = Тип("ТаблицаЗначений") Тогда
					ТаблицаТиповЭлемента = СтруктураТипаЦикл.Метаданные;
				КонецЕсли;
				СтруктураТипаЦикл.Метаданные = мПлатформа.ДобавитьВТаблицуТипов(ТаблицаТиповЭлемента, мПлатформа.НоваяСтруктураТипа(ИмяТипаЭлемента));
			КонецЕсли;
			ШаблонПоиска = шПредИнструкция + ШаблонВыражения + "\s*\.\s*(?:Добавить\s*\(|Вставить\s*\((?:" + шИмя + "|\d+),)\s*(" + шПростоеВыражениеПрограммы + ")\s*\)";
			Вхождения = НайтиВхожденияРегВыраженияКэш(ШаблонПоиска, ГлобальныйПоискВМодуле,, "ДобавлениеВМассив;" + Выражение);
			МаксЭлементов = 2;
			ИндексСвойства = 1;
			Для Каждого ВхождениеСвойства Из Вхождения Цикл
				Если ИндексСвойства > МаксЭлементов Тогда 
					Прервать;
				КонецЕсли;
				Если ЛиВхождениеВЗапрешенномДиапазоне(ВхождениеСвойства, Позиция0ВМетодеОт, Позиция0ВМетодеДо) Тогда
					Продолжить;
				КонецЕсли;
				ИндексСвойства = ИндексСвойства + 1;
				ТаблицаТиповЭлемента = ВычислитьТипЗначенияВыражения(ВхождениеСвойства.SubMatches(0),,,,
					ЭтоВызовКонструктора, ПолныйАнализСоставаТипов, Ложь, ГлобальныйПоискВМодуле,,,, ВхождениеСвойства.FirstIndex,, ДляСвойстваВниз);
				Если ТаблицаТиповЭлемента.Количество() > 0 Тогда
					СтруктураТипаЦикл.Метаданные = мПлатформа.ДобавитьВТаблицуТипов(СтруктураТипаЦикл.Метаданные, ТаблицаТиповЭлемента);
				КонецЕсли;
				Если ТаблицаТиповЭлемента.Колонки.Метаданные.Заголовок <> "" Тогда
					ТаблицаТипов.Колонки.Метаданные.Заголовок = ЗаголовокФлагОбрезкиГлубины();
				КонецЕсли;
			КонецЦикла;
			СтруктураТипаЦикл.ИмяОбщегоТипа = "Массив"; 
			мПлатформа.ОбновитьДетальностьСтруктурыТипа(СтруктураТипаЦикл);
		ИначеЕсли Ложь
			Или СтруктураТипаЦикл.ИмяОбщегоТипа = "СписокЗначений"
			Или СтруктураТипаЦикл.ИмяОбщегоТипа = "Соответствие"
		Тогда
			Если ДляСвойства = ИмяФиктивногоСвойства() Тогда
				ТаблицаТипов.Колонки.Метаданные.Заголовок = ЗаголовокФлагОбрезкиГлубины();
				Продолжить;
			КонецЕсли;
			Если Истина
				И Тип(СтруктураТипаЦикл.ИмяОбщегоТипа) = ТипЗнч(СтруктураТипаЦикл.Метаданные)
				И СтруктураТипаЦикл.Метаданные.Количество() > 0
			Тогда
				Продолжить;
			КонецЕсли; 
			ТаблицаТиповЗначенияВсехЭлементов = Неопределено;
			ТаблицаТиповКлючаВсехЭлементов = Неопределено;
			Если ТипЗнч(СтруктураТипаЦикл.Метаданные) <> Тип("Структура") Тогда
				СтруктураТипаЦикл.Метаданные = Новый Структура;
			КонецЕсли;
			МетаданныеСтруктуры = СтруктураТипаЦикл.Метаданные;
			Если МетаданныеСтруктуры.Свойство("Ключ") Тогда
				ТаблицаТиповКлючаВсехЭлементов = МетаданныеСтруктуры.Ключ;
			Иначе
				МетаданныеСтруктуры.Вставить("Ключ");
			КонецЕсли;
			Если МетаданныеСтруктуры.Свойство("Значение") Тогда
				ТаблицаТиповЗначенияВсехЭлементов = МетаданныеСтруктуры.Значение;
			Иначе
				МетаданныеСтруктуры.Вставить("Значение");
			КонецЕсли;
			Если СтруктураТипаЦикл.ИмяОбщегоТипа = "СписокЗначений" Тогда 
				ШаблонПоиска = шПредИнструкция + ШаблонВыражения + "\s*\.\s*Добавить\s*\(\s*()()(" + шПростоеВыражениеПрограммы + ")\s*[,\)]";
			Иначе // Если СтруктураТипаЦикл.ИмяОбщегоТипа = "Соответствие" 
				ШаблонПоиска = шПредИнструкция + ШаблонВыражения + "\s*(?:\.\s*Вставить\s*\(([^,\)]*),|\[([^\]]*)\]\s*=)\s*(" + шПростоеВыражениеПрограммы + ")\s*[\);\n]";
			КонецЕсли;
			Вхождения = НайтиВхожденияРегВыраженияКэш(ШаблонПоиска, ГлобальныйПоискВМодуле,, "ВставкаВСоответствие;" + Выражение);
			МаксЭлементов = 2;
			ИндексСвойства = 1;
			Для Каждого ВхождениеСвойства Из Вхождения Цикл
				Если ИндексСвойства > МаксЭлементов Тогда 
					Прервать;
				КонецЕсли;
				Если ЛиВхождениеВЗапрешенномДиапазоне(ВхождениеСвойства, Позиция0ВМетодеОт, Позиция0ВМетодеДо) Тогда
					Продолжить;
				КонецЕсли;
				ИндексСвойства = ИндексСвойства + 1;
				ВыражениеКлюча = ВхождениеСвойства.SubMatches(0);
				Если Не ЗначениеЗаполнено(ВыражениеКлюча) Тогда
					ВыражениеКлюча = ВхождениеСвойства.SubMatches(1);
				КонецЕсли;
				Если Истина
					И ЗначениеЗаполнено(ВыражениеКлюча) 
					И Не мПлатформа.ЛиДетальностьТиповДостаточна(ТаблицаТиповКлючаВсехЭлементов, 4) 
				Тогда
					ТаблицаТиповКлючаЭлемента = ВычислитьТипЗначенияВыражения(ВыражениеКлюча,,,, 
						ЭтоВызовКонструктора, ПолныйАнализСоставаТипов, Ложь, ГлобальныйПоискВМодуле,,,, ВхождениеСвойства.FirstIndex,, ДляСвойстваВниз);
					мПлатформа.ДобавитьВТаблицуТипов(ТаблицаТиповКлючаВсехЭлементов, ТаблицаТиповКлючаЭлемента);
				КонецЕсли;
				Если Не мПлатформа.ЛиДетальностьТиповДостаточна(ТаблицаТиповЗначенияВсехЭлементов, 4) Тогда
					ТаблицаТиповЗначенияЭлемента = ВычислитьТипЗначенияВыражения(ВхождениеСвойства.SubMatches(2),,,, 
						ЭтоВызовКонструктора, ПолныйАнализСоставаТипов, Ложь, ГлобальныйПоискВМодуле,,,, ВхождениеСвойства.FirstIndex,, ДляСвойстваВниз);
					мПлатформа.ДобавитьВТаблицуТипов(ТаблицаТиповЗначенияВсехЭлементов, ТаблицаТиповЗначенияЭлемента);
				КонецЕсли;
				Если Ложь
					Или ТаблицаТиповЗначенияВсехЭлементов.Колонки.Метаданные.Заголовок <> "" 
					Или (Истина 
						И ТаблицаТиповКлючаВсехЭлементов <> Неопределено
						И ТаблицаТиповКлючаВсехЭлементов.Колонки.Метаданные.Заголовок <> "")
				Тогда
					ТаблицаТипов.Колонки.Метаданные.Заголовок = ЗаголовокФлагОбрезкиГлубины();
				КонецЕсли;
			КонецЦикла;
			МетаданныеСтруктуры.Значение = ТаблицаТиповЗначенияВсехЭлементов;
			МетаданныеСтруктуры.Ключ = ТаблицаТиповКлючаВсехЭлементов;
			мПлатформа.ОбновитьДетальностьСтруктурыТипа(СтруктураТипаЦикл);
		ИначеЕсли Ложь
			Или СтруктураТипаЦикл.ИмяОбщегоТипа = "ТаблицаЗначений"
			Или СтруктураТипаЦикл.ИмяОбщегоТипа = "ДеревоЗначений"
		Тогда
			Если ДляСвойства = ИмяФиктивногоСвойства() Тогда
				ТаблицаТипов.Колонки.Метаданные.Заголовок = ЗаголовокФлагОбрезкиГлубины();
				Продолжить;
			КонецЕсли;
			МетаданныеТаблицы = СтруктураТипаЦикл.Метаданные;
			Если ТипЗнч(МетаданныеТаблицы) = Тип("Структура") Тогда
				НовыеМетаданныеТаблицы = МетаданныеТаблицы;
			Иначе 
				НовыеМетаданныеТаблицы = Новый Структура;
			КонецЕсли;
			// шПредИнструкция здесь не используем, т.к. ищем вызовы функции, а не процедуры. В таком режиме приходится учитывать и закомментированный код.
			ШаблонПоиска = шПредИмяПрямое + ШаблонВыражения + "\s*\.\s*Колонки\s*.\s*(?:Добавить\s*\(|Вставить\s*\((?:" + шИмя + "|\d+),|(?:" + шИмя + "|\[" + шИмя + "|\d+\])\.Имя\s*=)\s*" 
				+ "(" + шЛитералПрограммы + "|" + шИмяСТочками + ")\s*(?:,\s*(" + шПростоеВыражениеПрограммы + ")|,|;|\))" 
				+ "(?:\s*,\s*(?:" + шЛитералПрограммы + "|" + шСкобкиЛенивые + "|[^\)""])*)?(?:\)\s*)?" + шНазначениеТипаПриПрисвоении;
			Вхождения = НайтиВхожденияРегВыраженияКэш(ШаблонПоиска, ГлобальныйПоискВМодуле,, "ДобавлениеКолонок;" + Выражение);
			ЕстьДобавленияКолонок = Ложь;
			ЛиОбрезано = Ложь;
			ДляСвойстваТаблицы = ДляСвойства;
			ДляСвойстваВнизТаблицы = ДляСвойстваВниз;
			ОбрезатьДляСвойстваКоллекции(ДляСвойстваВнизТаблицы, ДляСвойстваТаблицы);
			Для Каждого ВхождениеСвойства Из Вхождения Цикл
				Если Ложь
					Или ЛиВхождениеВЗапрешенномДиапазоне(ВхождениеСвойства, Позиция0ВМетодеОт, Позиция0ВМетодеДо) 
					Или Лев(ВхождениеСвойства.Value, 1) = "/" // Закомментированная инструкция
				Тогда
					Продолжить;
				КонецЕсли; 
				ПрисвоенноеВыражение = ВхождениеСвойства.SubMatches(0);
				ПозицияСвойства = ВхождениеСвойства.FirstIndex; 
				Если Лев(ПрисвоенноеВыражение, 1) = """" Тогда
					ТекстовоеЗначение = ирОбщий.ТекстИзВстроенногоЯзыкаЛкс(ПрисвоенноеВыражение);
				Иначе
					ТекстовоеЗначение = ВычислитьЗначениеВыражения(ПрисвоенноеВыражение,,, Позиция0ВМетодеОт, ПозицияСвойства);
				КонецЕсли;
				Если ирОбщий.ЛиИмяПеременнойЛкс(ТекстовоеЗначение) Тогда
					ЕстьДобавленияКолонок = Истина; // Чтобы не требовалось слияние разных типов метаданных одной таблицы, которое не реализовано в ДобавитьВТаблицуТипов()
					Если Истина
						И ЗначениеЗаполнено(ДляСвойстваТаблицы) 
						И Не ирОбщий.СтрокиРавныЛкс(ДляСвойстваТаблицы, ТекстовоеЗначение)
						//И Не мПлатформа.мРежимПроверкиМодуля
					Тогда
						ЛиОбрезано = Истина;
						Продолжить;
					КонецЕсли;
					ПрисвоенныйТип = ВхождениеСвойства.SubMatches(8);
					ТаблицаТиповКолонки = ТаблицаТиповИзОднострочногоКомментария(ПрисвоенныйТип, ДляСвойстваВнизТаблицы, ПозицияСвойства);
					Если Не мПлатформа.ЛиДетальностьТиповДостаточна(ТаблицаТиповКолонки) Тогда
						ОписаниеТипов = ВычислитьЗначениеВыражения(ВхождениеСвойства.SubMatches(1),,, Позиция0ВМетодеОт, ПозицияСвойства,, Истина);
						Если ЗначениеЗаполнено(ОписаниеТипов) Тогда
							ТаблицаТиповКолонки = мПлатформа.ТаблицаТиповИзОписанияТипов(ОписаниеТипов);
						КонецЕсли;
					КонецЕсли;
					ТаблицаТиповКолонки = ТаблицаТиповДинамическогоСвойства(ТаблицаТиповКолонки, ПозицияСвойства, ПрисвоенныйТип);
					Если ЗначениеЗаполнено(ТаблицаТиповКолонки) Тогда
						Если ТаблицаТиповКолонки.Колонки.Метаданные.Заголовок <> "" Тогда
							ЛиОбрезано = Истина;
						КонецЕсли;
					КонецЕсли;
					НовыеМетаданныеТаблицы.Вставить(ТекстовоеЗначение, ТаблицаТиповКолонки);
				КонецЕсли;
			КонецЦикла; 
			Если ЛиОбрезано Тогда
				ТаблицаТипов.Колонки.Метаданные.Заголовок = ЗаголовокФлагОбрезкиГлубины();
			КонецЕсли;
			Если ЕстьДобавленияКолонок И НовыеМетаданныеТаблицы <> МетаданныеТаблицы Тогда
				КолонкиКоллекцииВСтруктуру(МетаданныеТаблицы, НовыеМетаданныеТаблицы);
				СтруктураТипаЦикл.Метаданные = НовыеМетаданныеТаблицы;
				мПлатформа.ОбновитьДетальностьСтруктурыТипа(СтруктураТипаЦикл);
			КонецЕсли;
		ИначеЕсли Ложь
			Или СтруктураТипаЦикл.ИмяОбщегоТипа = "Запрос"
			Или СтруктураТипаЦикл.ИмяОбщегоТипа = "ПостроительЗапроса"
			Или СтруктураТипаЦикл.ИмяОбщегоТипа = "ПостроительОтчета"
		Тогда
			Если ДляСвойства = ИмяФиктивногоСвойства() Тогда
				ТаблицаТипов.Колонки.Метаданные.Заголовок = ЗаголовокФлагОбрезкиГлубины();
				Продолжить;
			КонецЕсли;
			Если ТипЗнч(СтруктураТипаЦикл.Метаданные) = Тип("Запрос") Тогда
				СтруктураТипаЦикл.Метаданные = мПлатформа.ПостроительЗапросаИзТекстаДляТипа(СтруктураТипаЦикл.Метаданные.Текст);
			ИначеЕсли ТипЗнч(СтруктураТипаЦикл.Метаданные) <> Тип("ПостроительЗапроса") Тогда
				СтруктураТипаЦикл.Метаданные = Новый ПостроительЗапроса;
			КонецЕсли;
			Если ТипЗнч(СтруктураТипаЦикл.ДержательМетаданных) <> Тип("Структура") Тогда
				СтруктураТипаЦикл.ДержательМетаданных = НовыйМенеджерВременныхТаблиц();
			КонецЕсли;
			ПостроительЗапроса = СтруктураТипаЦикл.Метаданные;
			ТаблицаТиповИсточника = Неопределено;
			Если СтруктураТипаЦикл.ИмяОбщегоТипа <> "Запрос" Тогда
				ШаблонПоискаИсточника = ШаблонНазначенияТипаВыражению(ШаблонВыражения + "\.ИсточникДанных");
				ВхожденияИсточника = НайтиВхожденияРегВыраженияКэш(ШаблонПоискаИсточника, ГлобальныйПоискВМодуле,, "НазначениеТипа;" + Выражение + ".ИсточникДанных");
				Для Каждого ВхождениеИсточника Из ВхожденияИсточника Цикл
					Если ЛиВхождениеВЗапрешенномДиапазоне(ВхождениеИсточника, Позиция0ВМетодеОт, Позиция0ВМетодеДо) Тогда
						Продолжить;
					КонецЕсли;
					ПрисвоенноеВыражение = ВхождениеИсточника.SubMatches(3);
					ТаблицаТиповИсточника = ВычислитьТипЗначенияВыражения(ПрисвоенноеВыражение,,,,,, Ложь, ГлобальныйПоискВМодуле,,,, ВхождениеИсточника.FirstIndex);
					Прервать;
				КонецЦикла;
			КонецЕсли;
			Если ТаблицаТиповИсточника <> Неопределено Тогда
				Если мПлатформа.ЛиДетальностьТиповДостаточна(ТаблицаТиповИсточника, 4) Тогда
					ПустаяТаблица = мПлатформа.ПодготовитьЗначениеПараметраЗапроса(ТаблицаТиповИсточника[0].Метаданные);
					Если Ложь
						Или ТипЗнч(ПустаяТаблица) = Тип("ТаблицаЗначений") 
						Или ТипЗнч(ПустаяТаблица) = Тип("РезультатЗапроса") 
					Тогда
						ПостроительЗапроса.ИсточникДанных = Новый ОписаниеИсточникаДанных(ПустаяТаблица);
					ИначеЕсли ТипЗнч(ПустаяТаблица) = Тип("ТабличныйДокумент") Тогда
						ПостроительЗапроса.ИсточникДанных = Новый ОписаниеИсточникаДанных(ПустаяТаблица.Область());
					КонецЕсли;
				КонецЕсли;
			Иначе
				МенеджерВременныхТаблиц = СтруктураТипаЦикл.ДержательМетаданных;
				ЛиМенеджерГотов = ЛиМенеджерВременныхТаблицОбработалМетод(МенеджерВременныхТаблиц);
				Если Не ЛиМенеджерГотов И СтруктураТипаЦикл.ИмяОбщегоТипа = "Запрос" Тогда
					СобратьОперацииМенеджераВременныхТаблиц(МенеджерВременныхТаблиц, Выражение, Позиция0ВМетодеОт, Позиция0ВМетодеДо, ДляСвойстваПуть, Истина);
				КонецЕсли; 
				ПозицияПоискаТекстаДо = Позиция0ВМетодеДо;  
				ПозицияПоискаТекстаОт = Позиция0ВМетодеОт; // TODO сдвинуть вперед до позиции найденной установки менеджера
				
				СобратьСвойстваСтруктуры(Выражение + ".Параметры", ПостроительЗапроса.Параметры,,, ПозицияПоискаТекстаОт, ПозицияПоискаТекстаДо);
				//Если ТипЗнч(ПараметрыЗапроса) = Тип("Структура") Тогда
					ШаблонПоиска = шПредИнструкция + ШаблонВыражения + "\s*\.\s*УстановитьПараметр\s*\(\s*(" + шЛитералПрограммы + ")\s*,\s*((?:" + шЛитералПрограммы + "|" + шСкобкиЛенивые + "|[^\)""])*)";
					Вхождения = НайтиВхожденияРегВыраженияКэш(ШаблонПоиска, ГлобальныйПоискВМодуле,, "УстановитьПараметрЗапроса;" + Выражение);
					Для Каждого Вхождение Из Вхождения Цикл
						Если ЛиВхождениеВЗапрешенномДиапазоне(Вхождение, ПозицияПоискаТекстаОт, ПозицияПоискаТекстаДо) Тогда
							Продолжить;
						КонецЕсли;
						ВыражениеИмени = Вхождение.SubMatches(0);
						ТекстовоеЗначение = ирОбщий.ТекстИзВстроенногоЯзыкаЛкс(ВыражениеИмени);
						Если Не ирОбщий.ЛиИмяПеременнойЛкс(ТекстовоеЗначение) Тогда 
							Продолжить;
						КонецЕсли;  
						ВыражениеЗначения = Вхождение.SubMatches(1);
						ТаблицаТиповЗначения = Неопределено;
						Если ЗначениеЗаполнено(ВыражениеЗначения) Тогда
							ТаблицаТиповНовая = ВычислитьТипЗначенияВыражения(ВыражениеЗначения,,,,,, Ложь,,,,, Вхождение.FirstIndex);
							Если ТаблицаТиповНовая.Количество() = 0 Тогда
								ТаблицаТиповЗначения = Неопределено;
							Иначе 
								ТаблицаТиповЗначения = ТаблицаТиповНовая; // Пустые таблицы запрещены, т.к. проверка пустоты участвует в разделении таблицы-значения и таблицы типов значения
							КонецЕсли;
						КонецЕсли;
						Если ТаблицаТиповЗначения = Неопределено И ПостроительЗапроса.Параметры.Свойство(ТекстовоеЗначение) Тогда
							Продолжить;
						КонецЕсли;
						ПостроительЗапроса.Параметры.Вставить(ТекстовоеЗначение, ТаблицаТиповЗначения);
					КонецЦикла;
				//КонецЕсли;
				
				УстановленныеПараметры = ирОбщий.СкопироватьКоллекциюЛкс(ПостроительЗапроса.Параметры);
				ТекстВЭтомБлокеУстановлен = Ложь;
				НачальныйИндекс = МенеджерВременныхТаблиц.ПакетыЗапросов.Количество();
				ШаблонПоискаТекста = ШаблонНазначенияТипаВыражению(ШаблонВыражения + "\.Текст", Истина);
				ВхожденияТекста = НайтиВхожденияРегВыраженияКэш(ШаблонПоискаТекста, ГлобальныйПоискВМодуле,, "НазначениеТипа;" + Выражение + ".Текст");
				Для Индекс = 1 - ВхожденияТекста.Количество() По 0 Цикл // Обратный обход
					ВхождениеТекста = ВхожденияТекста[-Индекс];
					Если ЛиВхождениеВЗапрешенномДиапазоне(ВхождениеТекста, ПозицияПоискаТекстаОт, ПозицияПоискаТекстаДо) Тогда
						Продолжить;
					КонецЕсли;
					ПрисвоенноеВыражение = ВхождениеТекста.SubMatches(3);
					Если Не ЗначениеЗаполнено(ПрисвоенноеВыражение) Тогда
						Продолжить;
					КонецЕсли;  
					Позиция0Группы = Найти(ВхождениеТекста.Value, Лев(ПрисвоенноеВыражение, 50)) - 1;
					КоординатыТекста = Неопределено; // см. НовыеКоординатыВыражения()
					ТекстПакета = ВычислитьЗначениеВыражения(ПрисвоенноеВыражение,, ГлобальныйПоискВМодуле, ПозицияПоискаТекстаОт, ВхождениеТекста.FirstIndex + Позиция0Группы, КоординатыТекста);
					Если ЗначениеЗаполнено(ТекстПакета) Тогда
						ПакетУжеДобавлен = Ложь;
						Для Каждого ПакетЗапросов Из МенеджерВременныхТаблиц.ПакетыЗапросов Цикл
							Если ПакетЗапросов.КоординатыТекста.Позиция0ВТексте = КоординатыТекста.Позиция0ВТексте Тогда
								ПакетУжеДобавлен = Истина;
								Прервать;
							КонецЕсли;
						КонецЦикла;
						Если Не ПакетУжеДобавлен Тогда
							ПакетЗапросов = НовыйПакетЗапросов(КоординатыТекста.Выражение, КоординатыТекста);
							МенеджерВременныхТаблиц.ПакетыЗапросов.Вставить(НачальныйИндекс, ПакетЗапросов); 
							ирОбщий.СкопироватьКоллекциюЛкс(УстановленныеПараметры, ПостроительЗапроса.Параметры);
							ирОбщий.СкопироватьКоллекциюЛкс(ПостроительЗапроса.Параметры, ПакетЗапросов.Параметры);
							Если Не ТекстВЭтомБлокеУстановлен Тогда
								мПлатформа.ПостроительЗапросаИзТекстаДляТипа(ТекстПакета, ПостроительЗапроса);
								ТекстВЭтомБлокеУстановлен = Истина;
							КонецЕсли;
						КонецЕсли;
					КонецЕсли; 
					//Если Ложь
					//	Или ТекстПакета = Неопределено 
					//	Или Не МенеджерВременныхТаблиц.Активен 
					//Тогда
					//	Прервать;
					//КонецЕсли;
				КонецЦикла;
				Если МенеджерВременныхТаблиц.ПакетыЗапросов.Количество() > 0 Тогда
					СтруктураТипаЦикл.ДержательМетаданных = МенеджерВременныхТаблиц;
				КонецЕсли;
			КонецЕсли;
			мПлатформа.ОбновитьДетальностьСтруктурыТипа(СтруктураТипаЦикл);
		ИначеЕсли СтруктураТипаЦикл.ИмяОбщегоТипа = "МенеджерВременныхТаблиц" Тогда
			Если ДляСвойства = ИмяФиктивногоСвойства() Тогда
				ТаблицаТипов.Колонки.Метаданные.Заголовок = ЗаголовокФлагОбрезкиГлубины();
				Продолжить;
			КонецЕсли;
			ЛиМенеджерГотов = ЛиМенеджерВременныхТаблицОбработалМетод(СтруктураТипаЦикл.Метаданные);
			Если ЛиМенеджерГотов Тогда
				Продолжить;
			КонецЕсли;
			Если ТипЗнч(СтруктураТипаЦикл.Метаданные) <> Тип("Структура") Тогда
				СтруктураТипаЦикл.Метаданные = НовыйМенеджерВременныхТаблиц();
			КонецЕсли;
			МенеджерВременныхТаблиц = СтруктураТипаЦикл.Метаданные; // см. НовыйМенеджерВременныхТаблиц()
			ШаблонПоиска = шПредИнструкция + "(" + шИмя + ").МенеджерВременныхТаблиц\s*=\s*" + Выражение + шКонецТокена;
			Вхождения = НайтиВхожденияРегВыраженияКэш(ШаблонПоиска, ГлобальныйПоискВМодуле,, "МенеджерВременныхТаблицВЗапрос;" + Выражение);
			Для Каждого ВхождениеСвойства Из Вхождения Цикл
				Если ЛиВхождениеВЗапрешенномДиапазоне(ВхождениеСвойства, Позиция0ВМетодеОт, Позиция0ВМетодеДо) Тогда
					Продолжить;
				КонецЕсли;
				СобратьОперацииМенеджераВременныхТаблиц(МенеджерВременныхТаблиц, ВхождениеСвойства.SubMatches(0), ВхождениеСвойства.FirstIndex + ВхождениеСвойства.Length, Позиция0ВМетодеДо, ДляСвойстваПуть);
			КонецЦикла;
			ШаблонПоиска = шПредИнструкция + Выражение + "\s*\.\s*докДобавить\(\s*(" + шПростоеВыражениеПрограммы + ")\s*\)"; // Виртуальный документирующий метод докДобавить
			Вхождения = НайтиВхожденияРегВыраженияКэш(ШаблонПоиска, ГлобальныйПоискВМодуле,, "ДобавлениеВременнойТаблицы;" + Выражение);
			Для Каждого ВхождениеСвойства Из Вхождения Цикл
				Если ЛиВхождениеВЗапрешенномДиапазоне(ВхождениеСвойства, Позиция0ВМетодеОт, Позиция0ВМетодеДо) Тогда
					Продолжить;
				КонецЕсли;
				ТаблицаТиповМенеджера = ВычислитьТипЗначенияВыражения(ВхождениеСвойства.SubMatches(0),,,,,,,,,, Позиция0ВМетодеОт, ВхождениеСвойства.FirstIndex);
				Если ТаблицаТиповМенеджера.Количество() > 0 Тогда
					ДобавляемыйМенеджер = ТаблицаТиповМенеджера[0].Метаданные;
					Если ТипЗнч(ДобавляемыйМенеджер) = Тип("Структура") Тогда
						ирОбщий.ДополнитьМассивЛкс(МенеджерВременныхТаблиц.ПакетыЗапросов, ДобавляемыйМенеджер.ПакетыЗапросов);
					КонецЕсли;
				КонецЕсли;
			КонецЦикла; 
			мПлатформа.ОбновитьДетальностьСтруктурыТипа(СтруктураТипаЦикл);
		ИначеЕсли СтруктураТипаЦикл.ИмяОбщегоТипа = "КомпоновщикНастроекКомпоновкиДанных" Тогда
			Если ДляСвойства = ИмяФиктивногоСвойства() Тогда
				ТаблицаТипов.Колонки.Метаданные.Заголовок = ЗаголовокФлагОбрезкиГлубины();
				Продолжить;
			КонецЕсли;
			Если ТипЗнч(СтруктураТипаЦикл.Метаданные) = Тип("СхемаКомпоновкиДанных") Тогда
				СтруктураТипаЦикл.Метаданные = ирОбщий.КомпоновщикПоСхемеКомпоновкиЛкс(СтруктураТипаЦикл.Метаданные);
			ИначеЕсли ТипЗнч(СтруктураТипаЦикл.Метаданные) = Тип("ДинамическийСписок") Тогда
				СтруктураТипаЦикл.Метаданные = СтруктураТипаЦикл.Метаданные.КомпоновщикНастроек;
			Иначе
				Если ТипЗнч(СтруктураТипаЦикл.Метаданные) <> Тип("КомпоновщикНастроекКомпоновкиДанных") Тогда
					СтруктураТипаЦикл.Метаданные = Новый КомпоновщикНастроекКомпоновкиДанных;
				КонецЕсли;
				Компоновщик = СтруктураТипаЦикл.Метаданные;
				СхемаКомпоновки = Неопределено;
				ШаблонПоиска = шПредИнструкция + ШаблонВыражения + "\s*\.\s*Инициализировать\(\s*(" + шПростоеВыражениеПрограммы + ")\s*\)";
				Вхождения = НайтиВхожденияРегВыраженияКэш(ШаблонПоиска, ГлобальныйПоискВМодуле,, "ИнициацияКомпоновщика;" + Выражение);
				Для Индекс = 1 - Вхождения.Количество() По 0 Цикл // Обратный обход
					Вхождение = Вхождения[-Индекс];
					Если ЛиВхождениеВЗапрешенномДиапазоне(Вхождение, Позиция0ВМетодеОт, Позиция0ВМетодеДо) Тогда
						Продолжить;
					КонецЕсли;
					ТаблицаТиповИсточника = ВычислитьТипЗначенияВыражения(Вхождение.SubMatches(0),,,,,, Ложь,,,,, Вхождение.FirstIndex);
					Если ТаблицаТиповИсточника.Количество() > 0 Тогда
						СхемаКомпоновкиЛ = ТаблицаТиповИсточника[0].Метаданные;
						Если ТипЗнч(СхемаКомпоновкиЛ) = Тип("СхемаКомпоновкиДанных") Тогда
							СхемаКомпоновки = СхемаКомпоновкиЛ;
							Прервать;
						КонецЕсли;
					КонецЕсли;
				КонецЦикла; 
				Если СхемаКомпоновки <> Неопределено Тогда
					СтруктураТипаЦикл.Метаданные = ирОбщий.КомпоновщикПоСхемеКомпоновкиЛкс(СхемаКомпоновки);
				Иначе
					ПолноеИмяОтчета = "";
					Если Истина
						И Вхождения.Количество() = 0 
						И мМодульМетаданных.СтруктураТипа <> Неопределено
					Тогда
						Если мМодульМетаданных.СтруктураТипа.ИмяОбщегоТипа = "РасширениеФормыОтчета" Тогда
							СтруктураТипаОбъекта = мПлатформа.СтруктураТипаОбъектаОбычнойФормы(мМодульМетаданных.СтруктураТипа.Метаданные);
							Если СтруктураТипаОбъекта <> Неопределено Тогда
								ПолноеИмяОтчета = СтруктураТипаОбъекта.Метаданные.ПолноеИмя();
							КонецЕсли;
						ИначеЕсли мМодульМетаданных.СтруктураТипа.ИмяОбщегоТипа = "РасширениеФормыКлиентскогоПриложенияДляОтчета" Тогда
							СтруктураТипаОбъекта = мПлатформа.СтруктураТипаОбъектаОбычнойФормы(мМодульМетаданных.СтруктураТипа.Метаданные);
							Если СтруктураТипаОбъекта <> Неопределено Тогда
								ПолноеИмяОтчета = СтруктураТипаОбъекта.Метаданные.ПолноеИмя();
							КонецЕсли;
						КонецЕсли;
					КонецЕсли;
					Если ЗначениеЗаполнено(ПолноеИмяОтчета) Тогда
						СхемаКомпоновки = ирКэш.ОсновнаяСхемаКомпоновкиОтчетаЛкс(ПолноеИмяОтчета); 
						Если СхемаКомпоновки <> Неопределено Тогда
							СтруктураТипаЦикл.Метаданные = ирОбщий.КомпоновщикПоСхемеКомпоновкиЛкс(СхемаКомпоновки);
						КонецЕсли;
					КонецЕсли;
				КонецЕсли;
			КонецЕсли;
			//СтруктураТипаЦикл.ДержательМетаданных = СтруктураТипаЦикл.Метаданные;
			мПлатформа.ОбновитьДетальностьСтруктурыТипа(СтруктураТипаЦикл);
		ИначеЕсли Ложь
			Или СтруктураТипаЦикл.ИмяОбщегоТипа = "ДекорацияФормы"
			Или СтруктураТипаЦикл.ИмяОбщегоТипа = "ПолеФормы" 
			Или СтруктураТипаЦикл.ИмяОбщегоТипа = "ГруппаФормы"
		Тогда
			ШаблонПоиска = "(?:" + шПредИмяПрямое + "(" + ШаблонВыраженияВУсловии() + ")?)" + шПредИмяПрямое + Выражение + "\s*\.\s*Вид\s*=\s*(" + шПростоеВыражениеПрограммы + ")";  // Сделать замену на кэшированный поиск назначения типа
			Вхождения = НайтиВхожденияРегВыраженияКэш(ШаблонПоиска, ГлобальныйПоискВМодуле,, "УстановкаВидПоля;" + Выражение);
			Для Каждого ВхождениеСвойства Из Вхождения Цикл
				Если Ложь
					Или ЛиВхождениеВЗапрешенномДиапазоне(ВхождениеСвойства, Позиция0ВМетодеОт, Позиция0ВМетодеДо) 
					Или (Истина
						И ВхождениеСвойства.SubMatches(0) <> Неопределено 
						И Не МожноПрименитьПрисвоениеТипаИзЕсли(мТекстДляПоискаОпределения, Позиция0ВМетодеДо, ВхождениеСвойства, ВхождениеСвойства.FirstIndex))
				Тогда
					Продолжить;
				КонецЕсли;
				ПрисвоенноеВыражение = ВхождениеСвойства.SubMatches(1);
				Если СтруктураТипаЦикл.ИмяОбщегоТипа = "ДекорацияФормы" Тогда
					ИмяПеречисления = "ВидДекорацииФормы";
				ИначеЕсли СтруктураТипаЦикл.ИмяОбщегоТипа = "ПолеФормы" Тогда
					ИмяПеречисления = "ВидПоляФормы";
				ИначеЕсли СтруктураТипаЦикл.ИмяОбщегоТипа = "ГруппаФормы" Тогда
					ИмяПеречисления = "ВидГруппыФормы";
				Иначе 
					ВызватьИсключение "Э";
				КонецЕсли;
				Если ирОбщий.СтрНачинаетсяСЛкс(ПрисвоенноеВыражение, ИмяПеречисления + ".") Тогда
					Попытка
						ВидПоля = ПредопределенноеЗначение(ПрисвоенноеВыражение);
					Исключение
						ВидПоля = Неопределено;
					КонецПопытки;
					Если ВидПоля <> Неопределено Тогда
						ИмяРасширения = мПлатформа.ИмяТипаРасширенияЭлементаФормы(СтруктураТипаЦикл.ИмяОбщегоТипа, Новый Структура("Вид", ВидПоля));
						Если ЗначениеЗаполнено(ИмяРасширения) Тогда
							СтруктураТипаЦикл.ИмяОбщегоТипа = ИмяРасширения;
							СтруктураТипаЦикл.Детальность = 5; // Сделал тут вместо мПлатформа.ОбновитьДетальностьСтруктурыТипа для ускорения
							Прервать;
						КонецЕсли;
					КонецЕсли;
				КонецЕсли;
			КонецЦикла; 
		ИначеЕсли Ложь
			Или СтруктураТипаЦикл.ИмяОбщегоТипа = "СообщениеПользователю"
		Тогда
			ШаблонПоиска = шПредИнструкция + Выражение + "\s*\.\s*КлючДанных\s*=\s*(" + шПростоеВыражениеПрограммы + ")";
			Вхождения = НайтиВхожденияРегВыраженияКэш(ШаблонПоиска, ГлобальныйПоискВМодуле,, "УстановкаКлючДанных;" + Выражение);
			Для Каждого ВхождениеСвойства Из Вхождения Цикл
				Если ЛиВхождениеВЗапрешенномДиапазоне(ВхождениеСвойства, Позиция0ВМетодеОт, Позиция0ВМетодеДо) Тогда
					Продолжить;
				КонецЕсли;
				СтруктураТипаЦикл.Метаданные = ВычислитьТипЗначенияВыражения(ВхождениеСвойства.SubMatches(0),,,,,, Ложь);
				Прервать;
			КонецЦикла; 
		ИначеЕсли Истина
			И СтруктураТипаЦикл.ИмяОбщегоТипа = "ЭлементБлокировкиДанных"
			И ТипЗнч(СтруктураТипаЦикл.Метаданные) = Тип("БлокировкаДанных")
		Тогда
			ШаблонПоиска = шПредИнструкция + Выражение + "\s*\.\s*ИсточникДанных\s*=\s*(" + шПростоеВыражениеПрограммы + ")";
			Вхождения = НайтиВхожденияРегВыраженияКэш(ШаблонПоиска, ГлобальныйПоискВМодуле,, "УстановкаИсточникДанных;" + Выражение);
			Для Каждого ВхождениеСвойства Из Вхождения Цикл
				Если ЛиВхождениеВЗапрешенномДиапазоне(ВхождениеСвойства, Позиция0ВМетодеОт, Позиция0ВМетодеДо) Тогда
					Продолжить;
				КонецЕсли;
				ТаблицаТиповИсточника = ВычислитьТипЗначенияВыражения(ВхождениеСвойства.SubMatches(0),,,,,, Ложь);
				Если мПлатформа.ЛиДетальностьТиповДостаточна(ТаблицаТиповИсточника, 4) Тогда
					СтруктураТипаЦикл.Метаданные[0].ИсточникДанных = ТаблицаТиповИсточника;
					Прервать;
				КонецЕсли;
			КонецЦикла; 
		КонецЕсли; 
	КонецЦикла;
КонецПроцедуры

//.
// Параметры:
//    МетаданныеТаблицы - РезультатЗапроса, ТаблицаЗначений, ДеревоЗначений, Произвольный - 
//    НовыеМетаданныеТаблицы - Структура, Неопределено - 
// Возвращаемое значение:
//    Структура, Неопределено - 
Функция КолонкиКоллекцииВСтруктуру(Знач МетаданныеТаблицы, Знач НовыеМетаданныеТаблицы = Неопределено) Экспорт
	Если Ложь
		Или ТипЗнч(МетаданныеТаблицы) = Тип("РезультатЗапроса")
		Или ТипЗнч(МетаданныеТаблицы) = Тип("ДеревоЗначений")
		Или ТипЗнч(МетаданныеТаблицы) = Тип("ТаблицаЗначений")
	Тогда
		Если НовыеМетаданныеТаблицы = Неопределено Тогда
			НовыеМетаданныеТаблицы = Новый Структура;
		КонецЕсли;
		Для Каждого Колонка Из МетаданныеТаблицы.Колонки Цикл
			Если ПустаяСтрока(Колонка.Имя) Тогда
				Продолжить;
			КонецЕсли;
			Если Не НовыеМетаданныеТаблицы.Свойство(Колонка.Имя) Тогда
				ТаблицаТиповКолонки = мПлатформа.ТаблицаТиповИзОписанияТипов(Колонка.ТипЗначения);
				Если ТаблицаТиповКолонки.Количество() = 0 Тогда
					ТаблицаТиповКолонки = Неопределено;
				КонецЕсли;
				НовыеМетаданныеТаблицы.Вставить(Колонка.Имя, ТаблицаТиповКолонки);
			КонецЕсли;
		КонецЦикла;
	КонецЕсли;
	Возврат НовыеМетаданныеТаблицы;
КонецФункции

//.
// Параметры:
//    ДляСвойстваВнизТаблицы - Строка - 
//    ДляСвойстваТаблицы - Строка, Неопределено - 
Процедура ОбрезатьДляСвойстваКоллекции(ДляСвойстваВнизТаблицы, ДляСвойстваТаблицы) Экспорт
	Пока Ложь
		Или ДляСвойстваТаблицы = "0"
		Или ДляСвойстваТаблицы = "Строки" 
		Или ДляСвойстваТаблицы = "Колонки" 
		Или ДляСвойстваТаблицы = "Индексы"  
	Цикл
		ДляСвойстваТаблицы = ирОбщий.ПервыйФрагментЛкс(ДляСвойстваВнизТаблицы);
		ДляСвойстваВнизТаблицы = ирОбщий.СтрокаБезПервогоФрагментаЛкс(ДляСвойстваВнизТаблицы);
	КонецЦикла;
	ДляСвойстваВнизТаблицы = ?(ЗначениеЗаполнено(ДляСвойстваТаблицы), ДляСвойстваВнизТаблицы, ИмяФиктивногоСвойства());
КонецПроцедуры

//.
// Параметры:
//    МенеджерВременныхТаблиц - см. НовыйМенеджерВременныхТаблиц - 
//    ВыражениеЗапроса - Строка	   -   
//    Позиция0ВМетодеОт - Число, Неопределено  -   
//    Позиция0ВМетодеДо - Число(10,0)  -   
//    ДляСвойстваПуть - Строка  -  
Процедура СобратьОперацииМенеджераВременныхТаблиц(Знач МенеджерВременныхТаблиц, Знач ВыражениеЗапроса, Знач Позиция0ВМетодеОт, Знач Позиция0ВМетодеДо, Знач ДляСвойстваПуть, Знач ОтЗапроса = Ложь) Экспорт
	Если ОтЗапроса Тогда
		ТаблицаТиповОтРодителя = мПлатформа.ТаблицаТиповИзОписанияТипов(Новый ОписаниеТипов("МенеджерВременныхТаблиц"));
		ТаблицаТиповОтРодителя[0].Метаданные = МенеджерВременныхТаблиц;
	КонецЕсли;
	ЛиНовыйКэшВыражений = ирОбщий.СтрНачинаетсяСЛкс(ДляСвойстваПуть, "МенеджерВременныхТаблиц");
	РекурсивныйПуть = мРекурсивныйПуть;
	ТаблицаТиповМенеджера = ВычислитьТипЗначенияВыражения(ВыражениеЗапроса + ".МенеджерВременныхТаблиц",,,,,, ЛиНовыйКэшВыражений,, ТаблицаТиповОтРодителя, Истина, Позиция0ВМетодеОт,
			Позиция0ВМетодеДо, "МенеджерВременныхТаблиц"); 
	мРекурсивныйПуть = РекурсивныйПуть;
	ЛучшийТип = ЛучшийТипИзТаблицыТипов(ТаблицаТиповМенеджера, 2);
	Если ЛучшийТип <> Неопределено Тогда
		Если ТипЗнч(ЛучшийТип.Метаданные) = Тип("Структура") Тогда 
			НовыйМенеджерВременныхТаблиц = ЛучшийТип.Метаданные; // см. НовыйМенеджерВременныхТаблиц()
			Если НовыйМенеджерВременныхТаблиц <> МенеджерВременныхТаблиц Тогда
				МенеджерВременныхТаблиц.Активен = Истина;
				ирОбщий.ДополнитьМассивЛкс(МенеджерВременныхТаблиц.ПакетыЗапросов, НовыйМенеджерВременныхТаблиц.ПакетыЗапросов);
			КонецЕсли;
		КонецЕсли;
	КонецЕсли;
КонецПроцедуры

// Опасная защита от повторных вычислений менеджера
// Параметры:
//    МенеджерВременныхТаблиц - Структура - 
// Возвращаемое значение:
//    Булево - 
Функция ЛиМенеджерВременныхТаблицОбработалМетод(Знач МенеджерВременныхТаблиц) Экспорт
	Результат = Ложь;
	Если ТипЗнч(МенеджерВременныхТаблиц) = Тип("Структура") Тогда
		Для Каждого ПакетЗапросов Из МенеджерВременныхТаблиц.ПакетыЗапросов Цикл
			Если Истина
				И ПакетЗапросов.КоординатыТекста.Модуль = мМодульМетаданных     
				И ПакетЗапросов.КоординатыТекста.Метод = мМетодМодуля 
			Тогда
				Результат = Истина;
				Прервать;
			КонецЕсли;
		КонецЦикла;
	КонецЕсли;
	Возврат Результат;
КонецФункции

//.
// Параметры:
//    ТаблицаТиповКэш - ТаблицаЗначений - 
//    ДляСвойства - Строка - 
// Возвращаемое значение:
//     - 
Функция ЛиТаблицаТиповКэшНеГотова(Знач ТаблицаТиповКэш, Знач ДляСвойства) Экспорт
	Результат = ТаблицаТиповКэш = Неопределено;
	Если Истина
		И Не Результат 
		И ЗначениеЗаполнено(ДляСвойства)
		И ТаблицаТиповКэш.Количество() > 0
	Тогда
		ДляСвойства = ирОбщий.ПервыйФрагментЛкс(ДляСвойства);
		Если Истина 
			И ДляСвойства <> ИмяФиктивногоСвойства()
			И ДляСвойства <> "0"
		Тогда
			МаксПроверок = 10;
			Счетчик = 0;
			Для Каждого СтрокаТипа Из ТаблицаТиповКэш Цикл
				Если ТипЗнч(СтрокаТипа.Метаданные) = Тип("Структура") Тогда 
					ТаблицаТиповСвойства = Неопределено;
					СтрокаТипа.Метаданные.Свойство(ДляСвойства, ТаблицаТиповСвойства);
					Результат = ТаблицаТиповСвойства = Неопределено; // При наличии свойство со значением Неопределено возможны повторные расчеты
					Прервать;
				Иначе
					Счетчик = Счетчик + 1;
					Если Счетчик = МаксПроверок Тогда 
						Прервать;
					КонецЕсли;
				КонецЕсли;
			КонецЦикла;
		КонецЕсли;
	КонецЕсли;
	Возврат Результат;
КонецФункции

//.
// Возвращаемое значение:
//    Структура - 
Функция НовыйМенеджерВременныхТаблиц(Знач Активен = Ложь) Экспорт
	МенеджерВременныхТаблиц = Новый Структура("Тип,ПакетыЗапросов,Активен");
	МенеджерВременныхТаблиц.Тип = Тип("МенеджерВременныхТаблиц");
	МенеджерВременныхТаблиц.ПакетыЗапросов = Новый Массив; // Массив из НовыйПакетЗапросов()
	МенеджерВременныхТаблиц.Активен = Активен;
	Возврат МенеджерВременныхТаблиц;
КонецФункции

//.
// Параметры:
//    Выражение - Строка(0) - 
//    ДопКлючКэша - Строка, Неопределено - 
Функция ИнициироватьРекурсивныйПуть(Знач Выражение = "", Знач ДопКлючКэша = "") Экспорт
	Если ДопКлючКэша = "" Тогда
		ДопКлючКэша = ДопКлючКэшаДляВычисленийВМетоде();
	КонецЕсли;
	РекурсивныйПуть = Новый Структура;
	РекурсивныйПуть.Вставить("ДобавлятьКлючевыеПараметры", Ложь);
	РекурсивныйПуть.Вставить("ДопКлючКэша", ДопКлючКэша);
	РекурсивныйПуть.Вставить("ВходящиеВызовы", Новый Соответствие);
	РекурсивныйПуть.Вставить("СчетчикиВызовов", Новый Соответствие);
	РекурсивныйПуть.Вставить("ТипыВыраженийЗапроса", Новый Соответствие);
	РекурсивныйПуть.Вставить("ПозицииЗапроса", Новый Массив); // TODO избавиться, т.к. теперь это обеспечивает ТипыВыраженийЗапроса. Для языка запросов защита от циклической рекурсии
	РекурсивныйПуть.Вставить("ВложенныеВыражения");
	РекурсивныйПуть.Вставить("ПозицияПоследнегоВыраженияВМетоде", Неопределено);
	Если Выражение = ИмяПеременнойВозвращаемогоЗначения() И мМетодМодуля <> Неопределено Тогда
		ВычислениеРезультатаМетода = мМетодМодуля.Имя;
	Иначе 
		ВычислениеРезультатаМетода = Неопределено;
	КонецЕсли;
	РекурсивныйПуть.Вставить("ВычислениеРезультатаМетода", ВычислениеРезультатаМетода);
	мРекурсивныйПуть = РекурсивныйПуть;
	Возврат РекурсивныйПуть;
КонецФункции

//.
// Параметры:
//    Выражение - Строка(0) - 
//    Позиция0ВМетодеДо - Число - 
// Возвращаемое значение:
//    Структура - 
Функция НовыеКоординатыВыражения(Знач Выражение, Знач Позиция0ВМетодеДо) Экспорт 
	СтруктураСтрокиМодуля = Новый Структура;
	СтруктураСтрокиМодуля.Вставить("Тип", "КоординатыВыражения");
	СтруктураСтрокиМодуля.Вставить("Метод", мМетодМодуля);
	СтруктураСтрокиМодуля.Вставить("Модуль", мМодульМетаданных);
	СтруктураСтрокиМодуля.Вставить("Позиция0ВБлоке", Позиция0ВМетодеДо);
	Позиция0ВТексте = ?(мПозицияТекстаДляПоискаОпределения = Неопределено, 0, мПозицияТекстаДляПоискаОпределения + Позиция0ВМетодеДо);
	СтруктураСтрокиМодуля.Вставить("Позиция0ВТексте", Позиция0ВТексте);
	СтруктураСтрокиМодуля.Вставить("ДлинаТекста", СтрДлина(Выражение));
	СтруктураСтрокиМодуля.Вставить("Выражение", Выражение);
	Возврат СтруктураСтрокиМодуля;
КонецФункции

//.
// Параметры:
//    ТаблицаТипов - ТаблицаЗначений - 
//    СтруктураТипа - Структура - 
Функция ДобавитьЕдинственныйТип(Знач ТаблицаТипов, СтруктураТипа, Знач ЗапретитьЗаменуТипа = Ложь) Экспорт
	Если ТаблицаТипов.Количество() > 0 Тогда
		ИмяЕдинственногоТипа = СтруктураТипа.ИмяОбщегоТипа;
		НайденныйТип = Новый Массив;
		Если ИмяЕдинственногоТипа = "COMОбъект" Тогда 
			Для Каждого СтрокаТипа Из ТаблицаТипов Цикл
				Если Найти(СтрокаТипа.ИмяОбщегоТипа, "{") > 0 Тогда
					НайденныйТип.Добавить(СтрокаТипа);
				КонецЕсли;
			КонецЦикла;
		ИначеЕсли ирОбщий.СтрНачинаетсяСЛкс(ИмяЕдинственногоТипа, "Форма") Тогда
			Для Каждого СтрокаТипа Из ТаблицаТипов Цикл
				Если ирОбщий.СтрНачинаетсяСЛкс(СтрокаТипа.ИмяОбщегоТипа, "РасширениеФормыКлиентского", Истина ) Тогда
					Если ИмяЕдинственногоТипа = "ФормаКлиентскогоПриложения" Тогда
						НайденныйТип.Добавить(СтрокаТипа);
					КонецЕсли; 
				ИначеЕсли ирОбщий.СтрНачинаетсяСЛкс(СтрокаТипа.ИмяОбщегоТипа, "РасширениеФормы", Истина ) Тогда
					Если ИмяЕдинственногоТипа = "Форма" Тогда
						НайденныйТип.Добавить(СтрокаТипа);
					КонецЕсли; 
				КонецЕсли;
			КонецЦикла;
		ИначеЕсли ИмяЕдинственногоТипа = "ПолеФормы" Тогда 
			Для Каждого СтрокаТипа Из ТаблицаТипов Цикл 
				Если ирОбщий.СтрНачинаетсяСЛкс(СтрокаТипа.ИмяОбщегоТипа, "РасширениеПоляФормы", Истина ) Тогда
					НайденныйТип.Добавить(СтрокаТипа);
				КонецЕсли;
			КонецЦикла;
		ИначеЕсли ИмяЕдинственногоТипа = "ПолеВвода" Тогда  
			Для Каждого СтрокаТипа Из ТаблицаТипов Цикл
				Если ирОбщий.СтрНачинаетсяСЛкс(СтрокаТипа.ИмяОбщегоТипа, "РасширениеПоляВвода", Истина ) Тогда
					НайденныйТип.Добавить(СтрокаТипа);
				КонецЕсли;
			КонецЦикла;
		ИначеЕсли ИмяЕдинственногоТипа = "ТаблицаФормы" Тогда
			Для Каждого СтрокаТипа Из ТаблицаТипов Цикл
				Если ирОбщий.СтрНачинаетсяСЛкс(СтрокаТипа.ИмяОбщегоТипа, "РасширениеТаблицыФормы", Истина ) Тогда
					НайденныйТип.Добавить(СтрокаТипа);
				КонецЕсли;
			КонецЦикла;
		ИначеЕсли ИмяЕдинственногоТипа = "ТабличноеПоле" Тогда
			Для Каждого СтрокаТипа Из ТаблицаТипов Цикл
				Если ирОбщий.СтрНачинаетсяСЛкс(СтрокаТипа.ИмяОбщегоТипа, "РасширениеТабличногоПоля", Истина ) Тогда
					НайденныйТип.Добавить(СтрокаТипа);
				КонецЕсли;
			КонецЦикла;
		ИначеЕсли ИмяЕдинственногоТипа = "ОбъектМетаданных" Тогда
			Для Каждого СтрокаТипа Из ТаблицаТипов Цикл
				Если Истина
					И СтрокаТипа.ИмяОбщегоТипа <> "ОбъектМетаданныхКонфигурация"
					И ирОбщий.СтрНачинаетсяСЛкс(СтрокаТипа.ИмяОбщегоТипа, "ОбъектМетаданных", Истина) 
				Тогда
					НайденныйТип.Добавить(СтрокаТипа);
					//Прервать;
				КонецЕсли;
			КонецЦикла;
		ИначеЕсли ИмяЕдинственногоТипа = "ТабличнаяЧасть" Тогда
			НачалоИмениТипа = ИмяЕдинственногоТипа + ".";
			Для Каждого СтрокаТипа Из ТаблицаТипов Цикл
				Если Найти(СтрокаТипа.ИмяОбщегоТипа, НачалоИмениТипа) > 0 Тогда
					НайденныйТип.Добавить(СтрокаТипа);
				КонецЕсли;
			КонецЦикла;
		// Недоделано!
		//ИначеЕсли Найти(ИмяЕдинственногоТипа, ".") = 0 Тогда
		//	ОтборТипов = Новый Структура("БазовыйТип, ЯзыкПрограммы", ИмяЕдинственногоТипа, мЯзыкПрограммы);
		//	Если мПлатформа.ТаблицаОбщихТипов.НайтиСтроки(ОтборТипов)[0].Слово <> ИмяЕдинственногоТипа Тогда
		//		НачалоИмениТипа = ИмяЕдинственногоТипа + ".";
		//		Для Каждого СтрокаТипа Из ТаблицаТипов Цикл
		//			Если ирОбщий.СтрНачинаетсяСЛкс(СтрокаТипа.ИмяОбщегоТипа, НачалоИмениТипа, Истина) Тогда
		//				НайденныйТип.Добавить(СтрокаТипа);
		//				//Прервать;
		//			КонецЕсли;
		//		КонецЦикла;
		//	КонецЕсли;
		КонецЕсли;
		Если НайденныйТип.Количество() = 0 Тогда
			ОтборТипов = Новый Структура("ИмяОбщегоТипа", ИмяЕдинственногоТипа);
			Если СтруктураТипа.Метаданные <> Неопределено Тогда
				ОтборТипов.Вставить("Метаданные", СтруктураТипа.Метаданные);
			КонецЕсли;
			НайденныйТип = ТаблицаТипов.НайтиСтроки(ОтборТипов);
		КонецЕсли;
		Если НайденныйТип.Количество() > 0 Тогда
			// Сужаем тип, сохраняя квалификаторы и описание слова
			НайденныйТип = НайденныйТип[0];
			Для Индекс = 1 - ТаблицаТипов.Количество() По 0 Цикл // Обратный обход
				СтрокаТипа = ТаблицаТипов[-Индекс];
				Если СтрокаТипа <> НайденныйТип Тогда
					ТаблицаТипов.Удалить(СтрокаТипа);
				КонецЕсли;
			КонецЦикла;
		Иначе
			Если ЗапретитьЗаменуТипа Тогда
				//СтруктураТипа = Неопределено;
				//ТаблицаТипов.Очистить();
				Возврат Ложь;
			Иначе
				ТаблицаТипов.Очистить();
			КонецЕсли;
		КонецЕсли;
	КонецЕсли;
	Если ТаблицаТипов.Количество() = 0 Тогда
		Если ИмяЕдинственногоТипа = "ОбъектМетаданных" Тогда
			СтруктураТипа.ИмяОбщегоТипа = мПлатформа.ИмяОбщегоТипаОбъектаМетаданных(); 
		КонецЕсли;
		мПлатформа.ДобавитьВТаблицуТипов(ТаблицаТипов, СтруктураТипа);
	КонецЕсли;
	Если Истина
		И ТипЗнч(СтруктураТипа) = Тип("СтрокаТаблицыЗначений") 
		И СтруктураТипа.Владелец().Колонки.Метаданные.Заголовок <> ""
	Тогда
		ТаблицаТипов.Колонки.Метаданные.Заголовок = ЗаголовокФлагОбрезкиГлубины();
	КонецЕсли;
	Возврат Истина;
КонецФункции

Функция МожноПрименитьПрисвоениеТипаИзЕсли(Знач ТекстДляПоискаОпределения, Знач Позиция0ВМетодеДо, Знач ПоследнееВхождение, Знач ПозицияВхождения0, Знач ГлубинаНеобязательной = Неопределено)
	Если ГлубинаНеобязательной <> Неопределено Тогда
		Возврат Ложь;
	КонецЕсли;
	ПрименитьТип = Ложь; 
	НачальнаяПозицияЕсли = ПозицияВхождения0 + ПоследнееВхождение.Length;
	ТекстПоискаЕсли = Сред(ТекстДляПоискаОпределения, НачальнаяПозицияЕсли + 1, Позиция0ВМетодеДо - НачальнаяПозицияЕсли);
	ПозицияЕсли = Найти(ТекстПоискаЕсли, "Если ");
	Если ПозицияЕсли = 0 Тогда
		ТекстПоискаТогда = ТекстПоискаЕсли;
	Иначе 
		ТекстПоискаТогда = Лев(ТекстПоискаЕсли, ПозицияЕсли);
	КонецЕсли;
	ПозицияТогда = Найти(ТекстПоискаТогда, "Тогда");
	ПрименитьТип = Ложь
		Или ПозицияТогда > 0 
		Или (Истина
			// Чтобы внутри условия применялось https://www.hostedredmine.com/issues/978910
			И Найти(ТекстПоискаТогда, "ИЛИ ") = 0 
			И Найти(ТекстПоискаТогда, "Или ") = 0
			И Найти(ТекстПоискаТогда, ";") = 0);
	Возврат ПрименитьТип;
КонецФункции

Функция ЛиВхождениеВЗапрешенномДиапазоне(Знач ПоследнееВхождение, Знач Позиция0ВМетодеОт = 0, Знач Позиция0ВМетодеДо = 0, Знач ЛиКорневойВызов = Ложь) Экспорт 
	Если Позиция0ВМетодеДо > 0 Тогда
		КонецВхождения = ПоследнееВхождение.FirstIndex + ПоследнееВхождение.Length;
	КонецЕсли;
	Результат = Ложь
		Или Позиция0ВМетодеОт > 0 И ПоследнееВхождение.FirstIndex < Позиция0ВМетодеОт
		Или (Истина
			И Позиция0ВМетодеДо > 0 
			И (Ложь
				Или КонецВхождения > Позиция0ВМетодеДо
				Или (Истина
					И ЛиКорневойВызов 
					И Прав(ПоследнееВхождение.Value, 1) = "("
					И Найти(Сред(мТекстБлока, КонецВхождения + 1, Позиция0ВМетодеДо - КонецВхождения), ";") = 0)
				));
	Возврат Результат;
КонецФункции

Функция ДиапазонТекстаДляПоиска(Знач ТекстДляПоискаОпределения = "", Знач ПозицияВМетодеОт = 0, Знач ПозицияВМетодеДо = 0)
	Если ПозицияВМетодеДо = 0 Тогда
		Длина = 1000000;
	Иначе
		Длина = ПозицияВМетодеДо - ПозицияВМетодеОт;
	КонецЕсли;
	ТекстДляПоискаОпределения = Сред(ТекстДляПоискаОпределения, ПозицияВМетодеОт, Длина);
	Возврат ТекстДляПоискаОпределения;
КонецФункции

// .
// Параметры:
//  ШаблонПоиска				 - Строка	 - 
//  ГлобальныйПоискВМодуле		 - Булево	 - 
//  выхТекстДляПоискаОпределения - Строка - только выход
// Возвращаемое значение:
//  Массив из ОбработкаОбъект.ирОболочкаРегВхождение
Функция НайтиВхожденияРегВыраженияКэш(Знач ШаблонПоиска, Знач ГлобальныйПоискВМодуле = Ложь, выхТекстДляПоискаОпределения = "", Знач КлючКэшаПоиска = "", КэшПоиска = Неопределено)
	Вхождения = Неопределено; 
	Если ГлобальныйПоискВМодуле Тогда
		выхТекстДляПоискаОпределения = мОригинальныйТекст;
	Иначе 
		выхТекстДляПоискаОпределения = мТекстБлока;
	КонецЕсли; 
	Если Не ЗначениеЗаполнено(КлючКэшаПоиска) Тогда
		КлючКэшаПоиска = ШаблонПоиска;
	КонецЕсли;
	КлючКэшаПоиска = НРег(Лев(КлючКэшаПоиска, 300));
	Если Истина
		И мМетодМодуля <> Неопределено 
		И Не ГлобальныйПоискВМодуле 
	Тогда 
		КэшПоиска = мМетодМодуля.КэшПоиска;
		Если КэшПоиска = Неопределено Тогда 
			КэшПоиска = Новый Соответствие;
			мМетодМодуля.КэшПоиска = КэшПоиска;
		КонецЕсли; 
		Вхождения = КэшПоиска[КлючКэшаПоиска];  
	Иначе
		КэшПоиска = мМодульМетаданных.КэшПоискаПрограммы;
	КонецЕсли;
	Если Вхождения = Неопределено Тогда  
		мРегВыражение.Global = Истина;
		мРегВыражение.Pattern = ШаблонПоиска;
		Вхождения = мРегВыражение.НайтиВхождения(выхТекстДляПоискаОпределения);
		КэшПоиска[КлючКэшаПоиска] = Вхождения;
	КонецЕсли;
	Возврат Вхождения;
КонецФункции

Функция ЗагрузитьМетодМодуляПоПозицииИРазобратьКонтекст(Знач Позиция0, Знач ГлобальныйПоискВМодуле = Истина, Знач ОписаниеПозиции = Неопределено) Экспорт 
	
	Если Не ГлобальныйПоискВМодуле Тогда 
		// В рамках текущего метода
		НачальнаяПозицияБлока = 0;
	Иначе
		Если Истина
			И ОписаниеПозиции <> Неопределено 
			И ЗначениеЗаполнено(ОписаниеПозиции.Метод) 
		Тогда
			ЗагрузитьМетодМодуля(мМодульМетаданных.Методы.Найти(ОписаниеПозиции.Метод, "НИмя")); 
		Иначе
			Позиция1 = Позиция0 + 1;
			Если ЗагрузитьМетодМодуляПоПозиции(Позиция1) Тогда
				// Для ускорения отключил
				//СлужебноеПолеТекстаДолгое.УстановитьГраницыВыделения(Позиция1, Позиция1);
				//НачальнаяСтрока = 0;
				//НачальнаяКолонка = 0;
				//СлужебноеПолеТекстаДолгое.ПолучитьГраницыВыделения(НачальнаяСтрока, НачальнаяКолонка,,);
				//КончитьОбработкуКоманды();
				//РазобратьТекущийКонтекст(,,, НачальнаяСтрока, НачальнаяКолонка,, Позиция1);
			КонецЕсли;
			Если ОписаниеПозиции <> Неопределено Тогда
				ОписаниеПозиции.Метод = НРег(ИмяТекущегоМетода());
			КонецЕсли;
		КонецЕсли;
		НачальнаяПозицияБлока = мПозицияТекстаДляПоискаОпределения;
	КонецЕсли;
	Возврат НачальнаяПозицияБлока;

КонецФункции

Функция ЗагрузитьМетодМодуляПоВхождениюИРазобратьКонтекст(Знач ГлобальныйПоискВМодуле = Ложь, Знач Вхождение, Знач ТекстДляПоискаОпределения = "")
	НачальнаяПозицияБлока = ЗагрузитьМетодМодуляПоПозицииИРазобратьКонтекст(Вхождение.FirstIndex, ГлобальныйПоискВМодуле);
	ТекстДоВхождения = Сред(ТекстДляПоискаОпределения, НачальнаяПозицияБлока, Вхождение.FirstIndex - 1 - НачальнаяПозицияБлока); // МультиМетка8294218
	Возврат ТекстДоВхождения;
КонецФункции

//.
// Параметры:
//    Выражение - Строка - 
//    Структура - Структура, ПостроительЗапроса - 
//    ТекстДляЗаполненияМетаданных - Строка - 
//    ТекстДляПоискаОпределения - Строка - 
//    ПредшествующийТекст - Строка - 
Функция СобратьСвойстваСтруктуры(Знач Выражение, Знач Структура = Неопределено, Знач ГлобальныйПоискВМодуле = Ложь, Знач ТолькоПрисвоение = Ложь, Знач Позиция0ВМетодеОт = 0, Знач Позиция0ВМетодеДо = 0,
	Знач ДляСвойства = "", Знач ДляСвойстваВниз = "", выхОбрезано = Ложь, Знач ШаблонВыражения = "", Знач ЛиПараметрыФормы = Ложь)
	
	Если Истина
		И ГлобальныйПоискВМодуле
		И ТипЗнч(Структура) = Тип("Структура")
		И Структура.Количество() > 0
	Тогда
		// Для сокращения редко полезных затратных поисков по большим модулям
		ГлобальныйПоискВМодуле = Ложь; // Грязно. Подразумеваем что обычно остаемся в том же методе, где структура родилась.
	КонецЕсли;
	Если ТипЗнч(Структура) = Тип("Структура") Тогда
		Структура = ирОбщий.СкопироватьКоллекциюЛкс(Структура); // Могла быть взята из кэша
	КонецЕсли;
	ТаблицаТиповВсехЭлементов = Неопределено;
	Если ТипЗнч(Структура) = Тип("ТаблицаЗначений") Тогда
		Если ТолькоПрисвоение Тогда
			Возврат Структура;
		КонецЕсли;
		ТаблицаТиповВсехЭлементов = Структура;
	КонецЕсли;
	Если Истина
		//И Не НашлиСоздание
		И ТипЗнч(Структура) <> Тип("Структура") 
		И ТипЗнч(Структура) <> Тип("ФиксированнаяСтруктура") 
	Тогда
		Если ТипЗнч(Структура) = Тип("ПостроительЗапроса") Тогда
			Структура = мПлатформа.ПараметрыИзТекстаЗапроса(Структура.Текст, Истина);
		Иначе
			Структура = Новый Структура;
		КонецЕсли;
	КонецЕсли;
	Если ТолькоПрисвоение Тогда
		Возврат Структура;
	КонецЕсли;
	Если Не ЗначениеЗаполнено(ШаблонВыражения) Тогда
		ШаблонВыражения = ирОбщий.ТекстДляРегВыраженияЛкс(Выражение);
	КонецЕсли;
	ИмяКолонкиФлагаТаблицыТипов = мПлатформа.ИмяКолонкиФлагаТаблицыТипов();
	ЛиСобиратьИменованные = Ложь
		Или ЗначениеЗаполнено(ДляСвойства) И ДляСвойства <> "0"
		Или ДляСвойстваВниз = ИмяФиктивногоСвойства();
	МинДетальность = 4;
	ШаблонПоиска = шПредИмяПрямое + ШаблонВыражения + "\s*\.\s*(Вставить|Свойство)\s*\(\s*(" + шЛитералПрограммы + "|" + шИмяСТочками + ")(?:\s*,\s*((?:" + шЛитералПрограммы + "|" + шСкобкиЛенивые + "|[^\)""])*))?" 
		+ "(?:\)\s*)?" + шНазначениеТипаПриПрисвоении;
	Вхождения = НайтиВхожденияРегВыраженияКэш(ШаблонПоиска, ГлобальныйПоискВМодуле,, "ВставкаВСтруктуру;" + Выражение);
	ПозицииВыражений = Новый Структура;
	Для Каждого Вхождение Из Вхождения Цикл
		Если ЛиВхождениеВЗапрешенномДиапазоне(Вхождение, Позиция0ВМетодеОт, Позиция0ВМетодеДо) Тогда
			Продолжить;
		КонецЕсли;
		ТипВставки = НРег(Вхождение.SubMatches(0));
		ВыражениеИмени = Вхождение.SubMatches(1);
		Если Лев(ВыражениеИмени, 1) = """" Тогда
			ТекстовоеЗначение = ирОбщий.ТекстИзВстроенногоЯзыкаЛкс(ВыражениеИмени);
		Иначе
			ЗагрузитьМетодМодуляПоВхождениюИРазобратьКонтекст(ГлобальныйПоискВМодуле, Вхождение);
			ТекстовоеЗначение = ВычислитьЗначениеВыражения(ВыражениеИмени,,,, Вхождение.FirstIndex);
		КонецЕсли;
		ЛиИмяПеременной = ирОбщий.ЛиИмяПеременнойЛкс(ТекстовоеЗначение);
		Если ЛиИмяПеременной И Не ЛиСобиратьИменованные Тогда
			выхОбрезано = Истина;
			ЛиИмяПеременной = Ложь;
		КонецЕсли;
		Если ТипВставки = "свойство" Тогда
			Если Истина
				И ЛиИмяПеременной 
				И Не Структура.Свойство(ТекстовоеЗначение) 
				И (Ложь
					Или Не мПлатформа.мРежимПроверкиМодуля 
					Или Структура.Количество() > 0
					Или ирОбщий.СтрокиРавныЛкс(ТекстовоеЗначение, ДляСвойства))
			Тогда
				ЗначениеСвойства = Неопределено;
				Если ЛиПараметрыФормы Тогда
					ЗначениеСвойства = Новый ОписаниеТипов;
				КонецЕсли;
				Структура.Вставить(ТекстовоеЗначение, ЗначениеСвойства);
			КонецЕсли;
			Продолжить;
		КонецЕсли;
		Если ЛиИмяПеременной Тогда
			Если Истина
				И ЗначениеЗаполнено(ДляСвойства) 
				И Не ирОбщий.СтрокиРавныЛкс(ДляСвойства, ТекстовоеЗначение) 
				//И Не мПлатформа.мРежимПроверкиМодуля
			Тогда
				выхОбрезано = Истина;
				Продолжить;
			КонецЕсли;
			ТаблицаТиповЗначения = ВычислитьТипыЭлементаСтруктурыПоВхождению(Вхождение, ГлобальныйПоискВМодуле, ДляСвойстваВниз);
			Структура.Вставить(ТекстовоеЗначение, ТаблицаТиповЗначения);
			ПозицииВыражений.Вставить(ТекстовоеЗначение, Вхождение.FirstIndex);
		ИначеЕсли Истина
			И Структура.Количество() = 0 
			И Найти(Вхождение.Value, ",") > 0
			И (Ложь
				Или ТаблицаТиповВсехЭлементов = Неопределено 
				Или ДляСвойства = "0" И Не мПлатформа.ЛиДетальностьТиповДостаточна(ТаблицаТиповВсехЭлементов, 5)
				)
		Тогда
			ТаблицаТиповЗначения = ВычислитьТипыЭлементаСтруктурыПоВхождению(Вхождение, ГлобальныйПоискВМодуле, ДляСвойстваВниз);
			Если мПлатформа.ЛиДетальностьТиповДостаточна(ТаблицаТиповЗначения) Тогда
				ТаблицаТиповВсехЭлементов = мПлатформа.ДобавитьВТаблицуТипов(ТаблицаТиповВсехЭлементов, ТаблицаТиповЗначения);
			КонецЕсли;
		КонецЕсли;
	КонецЦикла;
	Если Истина
		И ЛиСобиратьИменованные
		И Не ГлобальныйПоискВМодуле // Для сокращения редко полезных затратных вычислений
		И Структура.Количество() > 0    
	Тогда 
		ШаблонПоиска = шПредИнструкция + "ЗаполнитьЗначенияСвойств\s*\(\s*" + ШаблонВыражения + "\s*,\s*(" + шПростоеВыражениеПрограммы + ")(?=\s*[,\)])";
		Вхождения = НайтиВхожденияРегВыраженияКэш(ШаблонПоиска,,, "ЗаполнитьЗначенияСвойствСтруктура;" + Выражение); 
		БазовоеРасширениеКонфигурации = БазовоеРасширениеКонфигурации();
		Для Каждого Вхождение Из Вхождения Цикл
			Если ЛиВхождениеВЗапрешенномДиапазоне(Вхождение, Позиция0ВМетодеОт, Позиция0ВМетодеДо) Тогда
				Продолжить;
			КонецЕсли;
			ВыражениеЗначения = Вхождение.SubMatches(0);
			ТаблицаТиповЗначения = ВычислитьТипЗначенияВыражения(ВыражениеЗначения,,,,,, Ложь,,,,, Вхождение.FirstIndex,, ДляСвойства);
			Если ТаблицаТиповЗначения.Количество() = 0 Тогда
				Продолжить;
			КонецЕсли;
			ПараметрыЗаполнения = мПлатформа.НовыеПараметрыЗаполненияСлов("Свойство", БазовоеРасширениеКонфигурации);
			ТаблицаСловИсточника = мПлатформа.ТаблицаСловИзСтруктурыТипа(ТаблицаТиповЗначения[0], ПараметрыЗаполнения);
			Для Каждого СтрокаСлова Из ТаблицаСловИсточника Цикл
				Если Структура.Свойство(СтрокаСлова.Слово) Тогда
					Структура[СтрокаСлова.Слово] = СтрокаСлова.ТаблицаТипов;
					//Структура[СтрокаСлова.Слово] = мПлатформа.ДобавитьВТаблицуТипов(, СтрокаСлова.ТаблицаТипов,,, Истина, Ложь); // Вызывает аварийное завершение (возможно позднее) на проверке модуля ирПлатформа
				КонецЕсли;
			КонецЦикла;
		КонецЦикла;
		
		// Уточняем типы значений элементов через присвоения им
		ШаблонПоиска = шПредИмяПрямое + ШаблонВыражения + "\.(" + шИмя + ")(?![\(\d" + шБуква + "])(\s*=[^\n]*//)?";
		Вхождения = НайтиВхожденияРегВыраженияКэш(ШаблонПоиска,,, "ОбращениеКЭлементуСтруктуры;" + Выражение); 
		Если Вхождения.Количество() > 0 Тогда
			СвойстваЧерезТочкуИзТекста = Новый Структура;
			ЗначениеСвойства = Неопределено;
			Для Каждого Вхождение Из Вхождения Цикл
				ИмяСвойства = Вхождение.SubMatches(0);
				ЕстьУказаниеТипа = Вхождение.SubMatches(1) <> Неопределено;
				Если СвойстваЧерезТочкуИзТекста.Свойство(ИмяСвойства, ЗначениеСвойства) Тогда
					ЕстьУказаниеТипа = ЕстьУказаниеТипа Или ЗначениеСвойства;
				КонецЕсли;
				СвойстваЧерезТочкуИзТекста.Вставить(ИмяСвойства, ЕстьУказаниеТипа);
			КонецЦикла;
			ЗначениеСвойства = Неопределено;
			Для Каждого КлючИЗначение Из СвойстваЧерезТочкуИзТекста Цикл
				Если Не Структура.Свойство(КлючИЗначение.Ключ, ЗначениеСвойства) Тогда
					Продолжить;
				КонецЕсли; 
				Если Истина
					И ЗначениеСвойства <> Неопределено 
					И Не (Истина
						И ТипЗнч(ЗначениеСвойства) = Тип("ТаблицаЗначений")
						И ЗначениеСвойства.Колонки.Найти(ИмяКолонкиФлагаТаблицыТипов) <> Неопределено)
				Тогда
					Продолжить;
				КонецЕсли;
				Если Истина
					И ЗначениеЗаполнено(ДляСвойства) 
					И Не ирОбщий.СтрокиРавныЛкс(ДляСвойства, КлючИЗначение.Ключ) 
					//И Не мПлатформа.мРежимПроверкиМодуля
				Тогда
					Продолжить;
				КонецЕсли;
				ВыражениеЗначения = Выражение + "." + КлючИЗначение.Ключ;
				ПозицияВМетодеОт = 0;
				ПозицииВыражений.Свойство(КлючИЗначение.Ключ, ПозицияВМетодеОт);
				Если ПозицияВМетодеОт = Неопределено Тогда
					ПозицияВМетодеОт = 0;
				КонецЕсли;
				ТаблицаТиповСоздания = Структура[КлючИЗначение.Ключ]; // см. мПлатформа.НоваяТаблицаТипов()
				Если Истина
					И ТаблицаТиповСоздания <> Неопределено
					И мПлатформа.ЛиДетальностьТиповДостаточна(ТаблицаТиповСоздания, 4) 
					И Не КлючИЗначение.Значение // нет указания типа        
				Тогда
					// Нужно для ускорения вычисления мПлатформа.СброситьКэшТиповВыраженийМодуля()
					// TODO Может приводить к нестабильности вложенных в это свойство свойств. При первом вычислении берем первое определение, а при последующих - последнее
					// TODO сделать копию и затем ее установить в элемент структуры
					СобратьДинамическиеСвойстваОбъекта(ВыражениеЗначения, ТаблицаТиповСоздания,,,, ГлобальныйПоискВМодуле, Позиция0ВМетодеОт, Позиция0ВМетодеДо, ДляСвойстваВниз);
				Иначе
					ТаблицаТиповЗначения = ТаблицаТиповСоздания;
					Если ТаблицаТиповЗначения = Неопределено Тогда
						ТаблицаТиповЗначения = мПлатформа.НоваяТаблицаТипов();
					Иначе 
						ТаблицаТиповЗначения = ТаблицаТиповСоздания.Скопировать();
					КонецЕсли;
					ТаблицаТиповЗначения = ВычислитьТипЗначенияВыражения(ВыражениеЗначения,,,,,, Ложь, ГлобальныйПоискВМодуле, ТаблицаТиповЗначения,, ПозицияВМетодеОт, Позиция0ВМетодеДо,, ДляСвойстваВниз);
					Если ТаблицаТиповЗначения.Количество() = 0 Тогда 
						//Если ТаблицаТиповСоздания = Неопределено Тогда
						//	// Пустые таблицы запрещены, т.к. проверка пустоты участвует в разделении таблицы-значения и таблицы типов значения
						//Иначе 
						//	СобратьДинамическиеСвойстваОбъекта(ВыражениеЗначения, ТаблицаТиповСоздания,,,, ГлобальныйПоискВМодуле, Позиция0ВМетодеОт, Позиция0ВМетодеДо);
						//КонецЕсли;
					Иначе 
						Если ТаблицаТиповСоздания = Неопределено Тогда                                                                              
							Структура[КлючИЗначение.Ключ] = ТаблицаТиповЗначения;
						ИначеЕсли ТаблицаТиповСоздания <> ТаблицаТиповЗначения Тогда
							мПлатформа.ДобавитьВТаблицуТипов(ТаблицаТиповСоздания, ТаблицаТиповЗначения);
						КонецЕсли;
					КонецЕсли;
				КонецЕсли;
			КонецЦикла;
		КонецЕсли;
	КонецЕсли;
	Для Каждого КлючИЗначение Из Структура Цикл
		Если Истина
			И ТипЗнч(КлючИЗначение.Значение) = Тип("ТаблицаЗначений")
			И КлючИЗначение.Значение.Колонки.Найти(ИмяКолонкиФлагаТаблицыТипов) <> Неопределено
			И КлючИЗначение.Значение.Колонки.Метаданные.Заголовок <> "" 
		Тогда
			выхОбрезано = Истина;
			Прервать;
		КонецЕсли;
	КонецЦикла;
	Если Структура.Количество() = 0 Тогда
		Если ТаблицаТиповВсехЭлементов <> Неопределено Тогда
			Структура = ТаблицаТиповВсехЭлементов.Скопировать();
			Если ТаблицаТиповВсехЭлементов.Колонки.Метаданные.Заголовок <> "" Тогда
				выхОбрезано = Истина;
			КонецЕсли;
		Иначе //Если выхОбрезано Тогда
			Структура = Неопределено; // Чтобы проверка выражений не находила ошибку
		КонецЕсли;
	КонецЕсли;
	Возврат Структура;
КонецФункции

//.
// Параметры:
//    Вхождение - ОбработкаОбъект.ирОболочкаРегВхождение - 
//    ГлобальныйПоискВМодуле - Булево - 
//    ДляСвойстваВниз - Строка - 
//    ВыражениеЗначения - Строка - 
// Возвращаемое значение:
//    ТаблицаЗначений, Неопределено - 
Функция ВычислитьТипыЭлементаСтруктурыПоВхождению(Знач Вхождение, Знач ГлобальныйПоискВМодуле = Ложь, Знач ДляСвойстваВниз = "") Экспорт
	СтруктураМоноТипа = Неопределено;
	ТаблицаТиповЗначения = Неопределено;
	ЗагрузитьМетодМодуляПоВхождениюИРазобратьКонтекст(ГлобальныйПоискВМодуле, Вхождение);
	ПрисвоенныйТип = Вхождение.SubMatches(4);
	ЛиДетальностьТиповДостаточна = Ложь;
	ПозицияСвойства = Вхождение.FirstIndex;
	ТаблицаТиповИзКомментария = ТаблицаТиповИзОднострочногоКомментария(ПрисвоенныйТип, ДляСвойстваВниз, ПозицияСвойства + 10);
	Если ЗначениеЗаполнено(ТаблицаТиповИзКомментария) Тогда
		ТаблицаТиповЗначения = ТаблицаТиповИзКомментария;
		СтруктураМоноТипа = ТаблицаТиповИзКомментария[0];
		ЛиДетальностьТиповДостаточна = мПлатформа.ЛиДетальностьТиповДостаточна(ТаблицаТиповИзКомментария, 4);
	КонецЕсли;
	Если Не ЛиДетальностьТиповДостаточна Тогда
		ВыражениеЗначения = Вхождение.SubMatches(2);
		Если ирОбщий.ЛиБулевыйЛитералЛкс(ВыражениеЗначения) Тогда
			мПлатформа.ДобавитьВТаблицуТипов(ТаблицаТиповЗначения, мПлатформа.НоваяСтруктураТипа("Булево"));
		ИначеЕсли ВыражениеЗначения <> Неопределено Тогда 
			ТаблицаТиповНовая = ВычислитьТипЗначенияВыражения(ВыражениеЗначения,,,,,, Ложь,,,,, ПозицияСвойства,, ДляСвойстваВниз);
			ТаблицаТиповЗначения = мПлатформа.ДобавитьВТаблицуТипов(ТаблицаТиповЗначения, ТаблицаТиповНовая,,, Истина, Ложь); // Копируем вложенные структуры чтобы не влиять на кэш, из которого могла быть взята таблица
			Если СтруктураМоноТипа <> Неопределено Тогда
				ДобавитьЕдинственныйТип(ТаблицаТиповЗначения, СтруктураМоноТипа);
			КонецЕсли;
		КонецЕсли;
		ТаблицаТиповЗначения = ТаблицаТиповДинамическогоСвойства(ТаблицаТиповЗначения, ПозицияСвойства, ПрисвоенныйТип);
	КонецЕсли;
	Возврат ТаблицаТиповЗначения;
КонецФункции

//.
// Параметры:
//   ТаблицаТипов - ТаблицаЗначений, Неопределено - 
//   ПозицияСвойства - Число - 
//   ОписаниеСвойства - Строка - 
// Возвращаемое значение:
//   ТаблицаЗначений, Неопределено - 
Функция ТаблицаТиповДинамическогоСвойства(Знач ТаблицаТипов, Знач ПозицияСвойства, Знач ОписаниеСвойства = "") Экспорт
	Если Истина
		И Не ЗначениеЗаполнено(ТаблицаТипов)
		И (Ложь
			Или ЗначениеЗаполнено(ОписаниеСвойства)
			Или мПлатформа.мРежимПереходаКОпределению)
	Тогда
		СтруктураТипа = НоваяСтруктураТипа("Произвольный");
		ТаблицаТипов = мПлатформа.ДобавитьВТаблицуТипов(ТаблицаТипов, СтруктураТипа);
	КонецЕсли;
	Если Не ЗначениеЗаполнено(ТаблицаТипов) Тогда
		ТаблицаТипов = Неопределено; // Пустые таблицы запрещены, т.к. проверка пустоты участвует в разделении таблицы-значения и таблицы типов значения
	Иначе
		ТаблицаТипов.ЗаполнитьЗначения(НовоеОписаниеДинамическогоСвойства(ирОбщий.СтрокаБезПервогоФрагментаЛкс(ОписаниеСвойства, "-"), ПозицияСвойства + 10), "СтрокаОписания");
	КонецЕсли;
	Возврат ТаблицаТипов;
КонецФункции

// Параметры:
//    ПрисвоенныйТип - Строка - 
//    ДляСвойстваВниз - Строка -  - 
// Возвращаемое значение:
//    ТаблицаЗначений - 
Функция ТаблицаТиповИзОднострочногоКомментария(Знач ПрисвоенныйТип, Знач ДляСвойстваВниз, Знач Позиция0ВМетоде = 0) Экспорт
	Если ЗначениеЗаполнено(ПрисвоенныйТип) Тогда
		ТипЗначения = ирОбщий.ПервыйФрагментЛкс(ПрисвоенныйТип, "-");
		Если ЗначениеЗаполнено(ТипЗначения) Тогда
			ТаблицаТиповИзКомментария = ТаблицаТиповИзТекста(СокрЛП(ТипЗначения), СокрЛП(Сред(ПрисвоенныйТип, СтрДлина(ТипЗначения) + 2)),, ДляСвойстваВниз,,,, Позиция0ВМетоде);
		КонецЕсли;
	КонецЕсли;
	Возврат ТаблицаТиповИзКомментария;
КонецФункции

//.
// Параметры:
//    Выражение - Строка - 
//    ПрисвоенныйКонтекст - Строка - 
// Возвращаемое значение:
//    Булево - 
Функция ЛиБесполезноеПрисвоениеПеременной(ПрисвоенноеВыражение) Экспорт
	Если ПустаяСтрока(ПрисвоенноеВыражение) Тогда
		Возврат Истина;
	КонецЕсли;
	ПрисвоенноеВыражениеНрег = НРег(ПрисвоенноеВыражение);
	Если ПрисвоенноеВыражениеНрег = "null" Тогда
		ПрисвоенноеВыражение = "Null";
		Возврат Истина;
	КонецЕсли;
	Если Ложь 
		Или ПрисвоенноеВыражениеНрег = "неопределено"
		Или ПрисвоенноеВыражениеНрег = "undefined"
	Тогда
		ПрисвоенноеВыражение = "Неопределено";
		Возврат Истина;
	КонецЕсли;
	Возврат Ложь;
КонецФункции    

//.
// Параметры:
//    ШаблонПриемника - Строка - регулярное выражение
// Возвращаемое значение:
//    Строка - 
Функция ШаблонНазначенияТипаВыражению(Знач ШаблонПриемника, Знач ПроверятьТипЧерезЕсли = Ложь) Экспорт
	Результат = "(?:" + мПлатформа.шПустоеНачалоСтроки + "(?:" + шНачалоДок + "\s*)?|;\s*|" 
		+ шПредИмяПрямое + "(" + ШаблонВыраженияВУсловии() + "|Каждого|Each)" + "\s+)" 
		+ ШаблонПриемника 
		+ "(" + шПрисвоение + "|" + шОбходКоллекции + ")" + шНазначениеТипаПриПрисвоении;
	шСвойствоСтруктуры = шПредИмяПрямое + "(" + шИмяСТочками + ")\.Свойство\((" + шИмя + "|" + шЛитералВЗапросе + ")\s*,\s*" + ШаблонПриемника + "\s*\)"; // 2+N групп
	Результат = Результат + "|" + шСвойствоСтруктуры;
	Если ПроверятьТипЧерезЕсли Тогда
		шУсловиеСПроверкойТипа = шПредИмяПрямое + "(?:" + ШаблонВыраженияВУсловии() + ")\s+(?:ТипЗнч|TypeOf)\(" + ШаблонПриемника + "\)\s*=\s*((?:Тип|Type)\s*\(\s*""" + шИмяСТочками + """\s*\))";
		//шУсловиеСПроверкойТипа = шПредИмяПрямое + "(?:Если|ИначеЕсли)([\s\S](?![\s\)]Тогда\s))*?(?:ТипЗнч|TypeOf)\(" + ШаблонПриемника + "\)\s*=\s*((?:Тип|Type)\s*\(\s*""" + шИмя + """\s*\))[\s\S]*?(?:[\s\)]Тогда\s)"; // Дольше на 30%
		Результат = Результат + "|" + шУсловиеСПроверкойТипа;
	КонецЕсли;
	Возврат Результат;
КонецФункции

Функция ШаблонВыраженияВУсловии() Экспорт
	Возврат "Если|ИначеЕсли|И|Или|If|ElseIf|And|Or";
КонецФункции

Функция ВычислитьЗначениеВыражения(Выражение, Знач ПредшествующийТекст, Знач ГлобальныйПоискВМодуле = Ложь, Знач Позиция0ВМетодеОт = 0, Знач Позиция0ВМетодеДо = 0, выхКоординаты = Неопределено,
	Знач РазрешитьВычислятьРодителя = Ложь)
	
	Если ПустаяСтрока(Выражение) Тогда
		Возврат "";
	КонецЕсли;                      
	ТаблицаТиповБезРодителя = Неопределено;
	Если Найти(Выражение, "(") = 0 И Не РазрешитьВычислятьРодителя Тогда 
		// Для ускорения
		ТаблицаТиповБезРодителя = мПлатформа.НоваяТаблицаТипов();
	КонецЕсли;
	ТаблицаТипов = ВычислитьТипЗначенияВыражения(Выражение, ПредшествующийТекст, ПредшествующийТекст,,,, Ложь, ГлобальныйПоискВМодуле, ТаблицаТиповБезРодителя, Истина, Позиция0ВМетодеОт, Позиция0ВМетодеДо);
	Если ТаблицаТипов.Количество() > 0 Тогда
		СтруктураТипа = ТаблицаТипов[0];
		ТипЗначения = ТипЗнч(СтруктураТипа.Метаданные); 
		Если Ложь
			Или ТипЗначения = Тип("Число")
			Или ТипЗначения = Тип("Строка")
			Или ТипЗначения = Тип("Булево")
			Или ТипЗначения = Тип("Тип")
			Или ТипЗначения = Тип("ОписаниеТипов")
			Или ТипЗначения = Тип("ТипОбъектаXDTO")
			Или ТипЗначения = Тип("ТабличныйДокумент")
			Или ТипЗначения = Тип("СхемаКомпоновкиДанных")
		Тогда
			Результат = СтруктураТипа.Метаданные;
			Если ТипЗнч(СтруктураТипа.ДержательМетаданных) = Тип("Структура") Тогда
				выхКоординаты = СтруктураТипа.ДержательМетаданных;
			КонецЕсли;   
		ИначеЕсли Истина
			И СтруктураТипа.ИмяОбщегоТипа = "ОписаниеТипов" 
			И ТипЗнч(СтруктураТипа.Метаданные) = Тип("ОбъектМетаданных")
		Тогда
			Результат = СтруктураТипа.Метаданные.Тип;
		КонецЕсли;
	КонецЕсли;
	Возврат Результат;
КонецФункции

//.
// Параметры:
//    ПрисвоенныйТип - Строка - 
//    ТекстДоВхождения - Строка - 
// Возвращаемое значение:
//    ТаблицаЗначений - 
Функция ТаблицаТиповИзТекста(Знач ТекстТипа, Знач Описание = "", Знач ТекстДоВхождения = "", Знач ДляСвойстваПуть = "", СчетчикСтрок = 1, Знач ЛиВложенный = Ложь, Знач ЛиВнутриКоллекции = Ложь,
		Знач Позиция0ВМетоде = 0) Экспорт
	ТаблицаТипов = мПлатформа.НоваяТаблицаТипов();
	Если Прав(ТекстТипа, 1) = ":" Тогда
		ТекстТипа = СокрП(ирОбщий.СтрокаБезКонцаЛкс(ТекстТипа));
	КонецЕсли;
	Если Прав(ТекстТипа, 1) = "]" И Прав(ТекстТипа, 3) <> "[0]" Тогда
		ФрагментыЗапятой = Новый Массив;
		ФрагментыЗапятой.Добавить(ТекстТипа);
	Иначе 
		ФрагментыЗапятой = ирОбщий.СтрРазделитьЛкс(ТекстТипа, ",", Истина);
	КонецЕсли;
	ТекстОписания = Новый ТекстовыйДокумент; 
	Если ЗначениеЗаполнено(Описание) Тогда
		ТекстОписания.УстановитьТекст(Описание);
	Иначе
		СчетчикСтрок = 0;
	КонецЕсли;
	Позиция0ВМетоде = Позиция0ВМетоде + СтрДлина(ТекстТипа); 
	КорневоеСловоБД = "БД."; 
	ЛиВнутриДвоеточия = Ложь;
	КорневоеСловоКомпоновщикТаблицыБД = "КомпоновщикНастроекКомпоновкиДанных.";
	Для Каждого УказательТипа Из ФрагментыЗапятой Цикл
		Если Ложь
			Или Не ЗначениеЗаполнено(УказательТипа) И Не ЗначениеЗаполнено(Описание) 
			Или УказательТипа = "??"
		Тогда
			Продолжить;
		КонецЕсли;   
		ЭтоИмяТипа = Не мПлатформа.УдалитьПрефиксИзТекстаТипов(УказательТипа);
		Если ЭтоИмяТипа Тогда
			Если ЛиВложенный Тогда
				ПрефиксУровня = "**";
			Иначе
				ПрефиксУровня = "*";
			КонецЕсли;
			ДлинаПрефикса = СтрДлина(ПрефиксУровня);
			ОписаниеСвойств = Новый Структура;
			СчетчикСтрок = Мин(СчетчикСтрок, ТекстОписания.КоличествоСтрок()); // Если в одной строке указано несколько типов, то дочерние строки будут применяться только к первому типу
			Пока СчетчикСтрок <= ТекстОписания.КоличествоСтрок() Цикл
				Если ЛиВложенный Или ЛиВнутриКоллекции Тогда
					// Уходим от неоднозначности между родителем и ребенком
				Иначе
					СтрокаОписания = СокрЛП(ТекстОписания.ПолучитьСтроку(СчетчикСтрок));
					Позиция0ВМетоде = Позиция0ВМетоде + СтрДлина(СтрокаОписания) + 1; 
					Если Истина
						И Лев(СтрокаОписания, 1) = "-"
						И (Ложь
							Или СчетчикСтрок > 1
							Или ПустаяСтрока(УказательТипа))
					Тогда
						УказательТипа = СокрЛП(ирОбщий.ТекстМеждуМаркерамиЛкс(СтрокаОписания, "-", "-", Ложь,,, Истина));
						Если Прав(УказательТипа, 1) = ":" Тогда
							УказательТипа = СокрП(ирОбщий.СтрокаБезКонцаЛкс(УказательТипа));
							ЛиВнутриДвоеточия = Истина;
						КонецЕсли;
					ИначеЕсли Не ЗначениеЗаполнено(УказательТипа) Тогда
						СчетчикСтрок = СчетчикСтрок + 1;
						Продолжить;
					ИначеЕсли Прав(СтрокаОписания, 1) = ":" Тогда
						ЛиВнутриДвоеточия = Истина;
					КонецЕсли; 
				КонецЕсли;
				ТекстБезВопроса = СтрЗаменить(УказательТипа, "??,", "");
				МаркерКоллекции = " из ";
				ПозицияРазделителя = ирОбщий.СтрНайтиЛкс(ТекстБезВопроса, МаркерКоллекции,,,, Ложь); // Обязательно без учета регистра, т.к. далее рекурсивный вызов на это опирается!
				Если ПозицияРазделителя = 0 Тогда
					МаркерКоллекции = "[";
					ПозицияРазделителя = Найти(ТекстБезВопроса, МаркерКоллекции);
				КонецЕсли;
				Фрагменты = Новый Массив;
				Если ПозицияРазделителя > 0 Тогда
					Фрагменты.Добавить(Лев(ТекстБезВопроса, ПозицияРазделителя - 1));
					Фрагменты.Добавить(Сред(ТекстБезВопроса, ПозицияРазделителя + СтрДлина(МаркерКоллекции)));
				Иначе 
					Фрагменты.Добавить(ТекстБезВопроса);
				КонецЕсли;
				БазовыйТип = Фрагменты[0];
				Если Истина
					И Найти(БазовыйТип, " ") > 0  
					И Найти(БазовыйТип, "{") = 0 // имена COM типов
					И Найти(БазовыйТип, "см.") = 0
				Тогда 
					Перейти ~Конец; // Криво
				КонецЕсли;
				Если ЗначениеЗаполнено(ДляСвойстваПуть) Тогда
					ДляСвойства = ирОбщий.ПервыйФрагментЛкс(ДляСвойстваПуть);
					ДляСвойстваВниз = ирОбщий.СтрокаБезПервогоФрагментаЛкс(ДляСвойстваПуть);
				Иначе
					ДляСвойства = "";
					ДляСвойстваВниз = ИмяФиктивногоСвойства(); 
				КонецЕсли; 
				Если Ложь
					Или БазовыйТип = "ТаблицаЗначений"
					Или БазовыйТип = "ДеревоЗначений"
					Или БазовыйТип = "Соответствие"
					Или БазовыйТип = "СписокЗначений"
				Тогда
					ОбрезатьДляСвойстваКоллекции(ДляСвойстваВниз, ДляСвойства);
				КонецЕсли;
				ОписаниеСвойствОбрезано = Ложь;
				Если Фрагменты.Количество() > 1 Тогда
					ЭтоТипСтруктура = ирОбщий.СтрКончаетсяНаЛкс(БазовыйТип, "Структура");
					//ЭтоТипСоответствие = ирОбщий.СтрКончаетсяНаЛкс(БазовыйТип, "Соответствие");
					Если ЭтоТипСтруктура Тогда
						ДляСвойстваПуть = "Значение";
						БазовыйТип = "Структура"; // Исправим регистр букв
					ИначеЕсли ДляСвойстваПуть = "0" Тогда
						ДляСвойстваПуть = "";
					ИначеЕсли Лев(ДляСвойстваПуть, 1) = "0" Тогда 
						ДляСвойстваПуть = ирОбщий.СтрокаБезПервогоФрагментаЛкс(ДляСвойстваПуть);
					КонецЕсли;
					//Если Прав(СтрокаОписания, 1) = ":" Тогда // Отключил проверку, т.к. описание свойства может быть многострочным, а тут проверяется только первая строка
						ТаблицаТиповКоллекции = ТаблицаТиповИзТекста(ирОбщий.ПервыйФрагментЛкс(Фрагменты[1], "]"), Описание, ТекстДоВхождения, ДляСвойстваПуть, СчетчикСтрок, ЛиВложенный, Истина, Позиция0ВМетоде);
					//КонецЕсли; 
					СтруктураТипа = мПлатформа.НоваяСтруктураТипа(БазовыйТип);
					Если ирОбщий.СтрКончаетсяНаЛкс(БазовыйТип, "Массив") Тогда
						СтруктураТипа.ИмяОбщегоТипа = "Массив"; // Исправим регистр букв
						Если ТаблицаТиповКоллекции.Количество() > 0 Тогда
							СтруктураТипа.Метаданные = ТаблицаТиповКоллекции;
						КонецЕсли;
					Иначе
						Если ТаблицаТиповКоллекции.Количество() > 0 Тогда 
							Попытка
								Тип = Тип(ТаблицаТиповКоллекции[0].ИмяОбщегоТипа);
							Исключение
								Тип = Неопределено;
							КонецПопытки;
							МетаданныеТипа = ТаблицаТиповКоллекции[0].Метаданные;
							Если ТипЗнч(МетаданныеТипа) = Тип Тогда
								СтруктураТипа.Метаданные = ирОбщий.ЗначенияВМассивЛкс(МетаданныеТипа);
							ИначеЕсли Истина
								И ЭтоТипСтруктура 
								И ТипЗнч(МетаданныеТипа) = Тип("Структура")
							Тогда
								СтруктураТипа.Метаданные = МетаданныеТипа.Значение;
								СтруктураТипа.СтрокаОписания = ТаблицаТиповКоллекции[0].СтрокаОписания;
							Иначе
								СтруктураТипа.Метаданные = МетаданныеТипа;
							КонецЕсли;
						КонецЕсли;
					КонецЕсли;
					Если ТаблицаТиповКоллекции.Колонки.Метаданные.Заголовок <> "" Тогда
						ТаблицаТипов.Колонки.Метаданные.Заголовок = ЗаголовокФлагОбрезкиГлубины();
					КонецЕсли;
					мПлатформа.ДобавитьВТаблицуТипов(ТаблицаТипов, СтруктураТипа); 
				//ИначеЕсли Найти(УказательТипа, "[") > 0 Тогда
				//	СтруктураТипа = мПлатформа.НоваяСтруктураТипа(БазовыйТип);
				//	мПлатформа.ДобавитьВТаблицуТипов(ТаблицаТипов, СтруктураТипа); 
				ИначеЕсли ирОбщий.СтрНачинаетсяСЛкс(УказательТипа, "ОпределяемыйТип.") Тогда 
					ОбъектМД = Метаданные.ОпределяемыеТипы.Найти(ирОбщий.ПоследнийФрагментЛкс(УказательТипа));
					Если ОбъектМД <> Неопределено Тогда
						мПлатформа.ДобавитьВТаблицуТипов(ТаблицаТипов, ОбъектМД.Тип);
					КонецЕсли;
				ИначеЕсли ирОбщий.СтрНачинаетсяСЛкс(УказательТипа, "Характеристика.") Тогда 
					ОбъектМД = Метаданные.ПланыВидовХарактеристик.Найти(ирОбщий.ПоследнийФрагментЛкс(УказательТипа));
					Если ОбъектМД <> Неопределено Тогда
						мПлатформа.ДобавитьВТаблицуТипов(ТаблицаТипов, ОбъектМД.Тип);
					КонецЕсли;
				КонецЕсли;	
				СчетчикСтрок = СчетчикСтрок + 1;
				МаксДлинаОтступа = 20;
				ФрагментыОписания = Неопределено; // Массив
				ОписаниеДинамическогоСвойства = Неопределено; // см. НовоеОписаниеДинамическогоСвойства
				Пока СчетчикСтрок <= ТекстОписания.КоличествоСтрок() Цикл
					СтрокаОписанияГрязная = ТекстОписания.ПолучитьСтроку(СчетчикСтрок);
					СтрокаОписания = СокрЛП(СтрокаОписанияГрязная);
					Если Не ЛиВнутриДвоеточия И Лев(СтрокаОписания, 1) = "-" Тогда
						Прервать;
					ИначеЕсли Лев(СтрокаОписания, ДлинаПрефикса + 1) = ПрефиксУровня + "*" Тогда
						// дочерний уровень от свойства
						Если ОписаниеДинамическогоСвойства <> Неопределено И ФрагментыОписания <> Неопределено Тогда
							ОписаниеДинамическогоСвойства.Описание = ирОбщий.СтрСоединитьЛкс(ФрагментыОписания, Символы.ПС);
							ФрагментыОписания = Неопределено;
						КонецЕсли;
						СчетчикСтрок = СчетчикСтрок + 1;
						Позиция0ВМетоде = Позиция0ВМетоде + СтрДлина(СтрокаОписанияГрязная) + 1; 
						Продолжить;
					ИначеЕсли ирОбщий.ДлинаОтступаЛкс(СтрокаОписанияГрязная) > МаксДлинаОтступа Тогда
						// продолжение описания свойства
						Если ФрагментыОписания <> Неопределено Тогда
							ФрагментыОписания.Добавить(СтрокаОписания);
						КонецЕсли;
						СчетчикСтрок = СчетчикСтрок + 1;
						Позиция0ВМетоде = Позиция0ВМетоде + СтрДлина(СтрокаОписанияГрязная) + 1; 
						Продолжить;
					Иначе
						Если ОписаниеДинамическогоСвойства <> Неопределено И ФрагментыОписания <> Неопределено Тогда
							ОписаниеДинамическогоСвойства.Описание = ирОбщий.СтрСоединитьЛкс(ФрагментыОписания, Символы.ПС);
							ФрагментыОписания = Неопределено;
						КонецЕсли;
						Если Лев(СтрокаОписания, ДлинаПрефикса) = ПрефиксУровня Тогда
							ЧастьДляПоискаТипа = Сред(СтрокаОписания, ДлинаПрефикса + 1);
						ИначеЕсли ЛиВнутриДвоеточия И Лев(СтрокаОписания, 1) = "-"  Тогда
							ЧастьДляПоискаТипа = СтрокаОписания;
						Иначе
							Прервать;
						КонецЕсли;
						ФрагментыОписания = ирОбщий.СтрРазделитьЛкс(ЧастьДляПоискаТипа, "-", Истина);
						СчетчикСтрок = СчетчикСтрок + 1;
						ИмяСвойства = ФрагментыОписания[0];
						Если ирОбщий.ЛиИмяПеременнойЛкс(ИмяСвойства) Тогда 
							Если Истина
								И ЗначениеЗаполнено(ДляСвойства) 
								И ДляСвойства <> "0"
								И Не ирОбщий.СтрокиРавныЛкс(ДляСвойства, ИмяСвойства) 
								//И Не мПлатформа.мРежимПроверкиМодуля
							Тогда
								Позиция0ВМетоде = Позиция0ВМетоде + СтрДлина(СтрокаОписанияГрязная) + 1; 
								ОписаниеСвойствОбрезано = Истина;
								Продолжить;
							КонецЕсли;
							ТаблицаТиповСвойства = Неопределено;
						ИначеЕсли ЗначениеЗаполнено(ИмяСвойства) Тогда
							Прервать;
						КонецЕсли; 
						Если ФрагментыОписания.Количество() > 1 Тогда
							Если Истина
								И Прав(СтрокаОписания, 1) = ":" 
								И ирОбщий.ДлинаОтступаЛкс(ТекстОписания.ПолучитьСтроку(СчетчикСтрок + 1)) < МаксДлинаОтступа
							Тогда
								СчетчикСтрок = СчетчикСтрок - 1;
								ТаблицаТиповСтроки = ТаблицаТиповИзТекста(ирОбщий.ПервыйФрагментЛкс(ФрагментыОписания[1], ":"), Описание, ТекстДоВхождения, ДляСвойстваВниз, СчетчикСтрок, Истина,, Позиция0ВМетоде);
								ФрагментыОписания = Неопределено;
							Иначе
								Попытка 
									ОписаниеТипов = Новый ОписаниеТипов(ФрагментыОписания[1]);
									ТаблицаТиповСтроки = мПлатформа.ТаблицаТиповИзОписанияТипов(ОписаниеТипов);
								Исключение
									ТаблицаТиповСтроки = ТаблицаТиповИзТекста(ФрагментыОписания[1],, ТекстДоВхождения, ДляСвойстваВниз);  
								КонецПопытки;
								Если Не ЗначениеЗаполнено(ТаблицаТиповСтроки) Тогда
									мПлатформа.ДобавитьВТаблицуТипов(ТаблицаТиповСтроки, НоваяСтруктураТипа("Произвольный"));
								КонецЕсли;
								ОписаниеСвойства = Неопределено;
								Если ФрагментыОписания.Количество() > 2 Тогда
									ОписаниеСвойства = ФрагментыОписания[2];
								КонецЕсли;
								ФрагментыОписания.Удалить(0); 
								Если ФрагментыОписания.Количество() > 0 Тогда
									ФрагментыОписания.Удалить(0);
								КонецЕсли;
								ОписаниеДинамическогоСвойства = НовоеОписаниеДинамическогоСвойства(ОписаниеСвойства, Позиция0ВМетоде);
								ТаблицаТиповСтроки.ЗаполнитьЗначения(ОписаниеДинамическогоСвойства, "СтрокаОписания");
							КонецЕсли;
							Если ТаблицаТиповСтроки.Колонки.Метаданные.Заголовок <> "" Тогда
								ОписаниеСвойствОбрезано = Истина;
							КонецЕсли;
						КонецЕсли;
						Если ЗначениеЗаполнено(ИмяСвойства) Тогда
							ТаблицаТиповСвойства = ТаблицаТиповСтроки;
							ОписаниеСвойств.Вставить(ИмяСвойства, ТаблицаТиповСвойства);
						Иначе
							мПлатформа.ДобавитьВТаблицуТипов(ТаблицаТиповСвойства, ТаблицаТиповСтроки);
						КонецЕсли;
						Позиция0ВМетоде = Позиция0ВМетоде + СтрДлина(СтрокаОписанияГрязная) + 1; 
					КонецЕсли;
				КонецЦикла;
				СтруктураТипа = Неопределено;
				Если Ложь 
					Или УказательТипа = "Произвольный"
					Или УказательТипа = "ЛюбаяСсылка"
				Тогда
					СтруктураТипа = мПлатформа.НоваяСтруктураТипа(УказательТипа);
				Иначе 
					ИмяБезВложенных = ирОбщий.ПервыйФрагментЛкс(УказательТипа, "[");
					ФрагментыДвоеточия = ирОбщий.СтрРазделитьЛкс(ИмяБезВложенных, ":");
					Если ФрагментыДвоеточия.Количество() > 1 Тогда
						ИмяБезВложенных = ФрагментыДвоеточия[0];
						ТаблицаТипоКолонок = ТаблицаТиповИзТекста(ФрагментыДвоеточия[1], Описание, ТекстДоВхождения, ДляСвойстваПуть, СчетчикСтрок, Истина);
						Если ЗначениеЗаполнено(ТаблицаТипоКолонок) Тогда
							ОписаниеСвойств = ТаблицаТипоКолонок[0].Метаданные;
							Если ОписаниеСвойств = Неопределено Тогда
								ОписаниеСвойств = Новый Структура;
							КонецЕсли;
						КонецЕсли;
					КонецЕсли;
					Попытка
						Тип = Тип(ИмяБезВложенных);
					Исключение
						Тип = Неопределено;
					КонецПопытки;
					Если Истина
						И Тип <> Неопределено 
						И УказательТипа <> "ОтчетОбъект" // Непонятный тип https://www.hostedredmine.com/issues/979813
					Тогда
						СтруктураТипа = мПлатформа.СтруктураТипаИзКонкретногоТипа(Тип);
						//Если ТипЗнч(СтруктураТипа.Метаданные) = Тип("Неопределено") Тогда
						//	СтруктураТипа.ИмяОбщегоТипа = УказательТипа; // Мешает в случае подмены ОбъектМетаданных на ОбъектМетаданныхСправочник
						//КонецЕсли;
						Если ОписаниеСвойств.Количество() > 0 Тогда
							Если ИмяБезВложенных = "Строка" И ОписаниеСвойств.Свойство("Значение") Тогда
								СтруктураТипа.Метаданные = ОписаниеСвойств.Значение;
							Иначе
								СтруктураТипа.Метаданные = ОписаниеСвойств;
							КонецЕсли;
						КонецЕсли;
						Если ОписаниеСвойствОбрезано Тогда
							ТаблицаТипов.Колонки.Метаданные.Заголовок = ЗаголовокФлагОбрезкиГлубины();
						КонецЕсли;
					ИначеЕсли мПлатформа.ЛиИмяТипаComОбъекта(УказательТипа) Тогда 
						СтруктураТипа = мПлатформа.НоваяСтруктураТипа(УказательТипа);
					Иначе
						ОбщиеТипы = Неопределено; 
						Если Найти(УказательТипа, " ") = 0 Тогда
							ОбщиеТипы = мПлатформа.ТаблицаОбщихТипов.НайтиСтроки(Новый Структура("БазовыйТип, ЯзыкПрограммы", УказательТипа, 0));
						КонецЕсли;
						Если ЗначениеЗаполнено(ОбщиеТипы) Тогда
							УказательТипа = ОбщиеТипы[0].Слово;
							СтруктураТипа = мПлатформа.НоваяСтруктураТипа(УказательТипа);
						Иначе
							ИмяБезВложенных = НРег(ИмяБезВложенных);
							Если Ложь
								Или ирОбщий.СтрНачинаетсяСЛкс(ИмяБезВложенных, "см.", Истина) 
								//Или ирОбщий.СтрНайтиЛкс(ИмяБезВложенных, МаркерКоллекции) // выше уже сделано это
							Тогда
								СтруктураТипа = ТаблицаТиповИзТекста(УказательТипа, Описание, ТекстДоВхождения, ДляСвойстваПуть, СчетчикСтрок, Истина);
							Иначе 
								Продолжить;
							КонецЕсли;
						КонецЕсли;
					КонецЕсли;
					Если Истина
						И ОписаниеСвойств.Количество() > 0
						И ирОбщий.ЛиИмяТипаФормыЛкс(УказательТипа) 
						И ТипЗнч(СтруктураТипа.Метаданные) <> ирОбщий.ТипУправляемаяФормаЛкс()
					Тогда
						Если Истина
							И ТипЗнч(СтруктураТипа.Метаданные) = Тип("Структура") 
							И СтруктураТипа.Свойство("Реквизиты")
						Тогда
							ИмитаторФормы = СтруктураТипа.Метаданные;
						Иначе
							ИмитаторФормы = мПлатформа.ИмитаторУправляемойФормы();
							ИмитаторФормы.Вставить("Тип", ирОбщий.ТипУправляемаяФормаЛкс());
							ИмитаторФормы.Вставить("ИмяФормы");
							ИмитаторФормы.Реквизиты = мПлатформа.НоваяТаблицаРеквизитовФормы();
						КонецЕсли;
						Для Каждого КлючИЗначение Из ОписаниеСвойств Цикл 
							Если ИмитаторФормы.Свойство(КлючИЗначение.Ключ) Тогда
								КоллекцияФормы = ИмитаторФормы[КлючИЗначение.Ключ]; // Структура
								Если Истина
									И КлючИЗначение.Значение.Количество() > 0 
									И ТипЗнч(КлючИЗначение.Значение[0].Метаданные) = Тип("Структура")
								Тогда
									Для Каждого ВложенныйЭлемент Из КлючИЗначение.Значение[0].Метаданные Цикл
										Если КлючИЗначение.Ключ = "Элементы" Тогда
											Попытка
												ТипЭлемента = Тип(ВложенныйЭлемент.Значение[0].ИмяОбщегоТипа);
											Исключение
												ТипЭлемента = Неопределено;
											КонецПопытки;
											ИмитаторЭлементаФормы = мПлатформа.ИмитаторЭлементаФормы(ВложенныйЭлемент.Ключ,,,,, ТипЭлемента);
										Иначе
											ИмитаторЭлементаФормы = Неопределено;
										КонецЕсли;
										КоллекцияФормы.Вставить(ВложенныйЭлемент.Ключ, ИмитаторЭлементаФормы);
									КонецЦикла;
								КонецЕсли;
							Иначе
								ОписаниеРеквизита = ИмитаторФормы.Реквизиты.Добавить();
								ОписаниеРеквизита.Имя = КлючИЗначение.Ключ;
								ирОбщий.ОбновитьКопиюСвойстваВНижнемРегистреЛкс(ОписаниеРеквизита);
								ОписаниеРеквизита.ОписаниеТипов = КлючИЗначение.Значение;
							КонецЕсли;
						КонецЦикла;
						СтруктураТипа.Метаданные = ИмитаторФормы;
					КонецЕсли;
				КонецЕсли; 
				//Если ЗначениеЗаполнено(Описание) Тогда
					СтруктураТипа.СтрокаОписания = НовоеОписаниеДинамическогоСвойства(Описание, Позиция0ВМетоде);
				//КонецЕсли;
				мПлатформа.ДобавитьВТаблицуТипов(ТаблицаТипов, СтруктураТипа);
				УказательТипа = "";
				Если ЛиВложенный Тогда
					//СчетчикСтрок = СчетчикСтрок - 1;
					Прервать;
				КонецЕсли;
			КонецЦикла;
		Иначе
			СтруктураТипа = Неопределено;
			Если Истина
				//И Найти(УказательТипа, "(") = 0 // Отключил для различимости методов форм
				И Найти(УказательТипа, ".") > 0 
			Тогда
				ПервоеСлово = ирОбщий.ПервыйФрагментЛкс(УказательТипа);
				ИмяМножественное = ирОбщий.МножественноеИмяМДЛкс(ПервоеСлово);
				Если ирОбщий.СтрНачинаетсяСЛкс(УказательТипа, КорневоеСловоБД) Тогда
					мЯзыкПрограммы = 1;
					СтруктураТипа = ВычислитьТипЗначенияВыражения(Сред(УказательТипа, СтрДлина(КорневоеСловоБД) + 1),,,,,, Ложь)[0].Квалификаторы;
					мЯзыкПрограммы = 0;
				ИначеЕсли ирОбщий.СтрНачинаетсяСЛкс(УказательТипа, КорневоеСловоКомпоновщикТаблицыБД) Тогда
					мЯзыкПрограммы = 1;
					СтруктураТипа = НоваяСтруктураТипа();
					СтруктураТипа.ИмяОбщегоТипа = "КомпоновщикНастроекКомпоновкиДанных";
					СтруктураТипа.Метаданные = ирОбщий.КомпоновщикТаблицыМетаданныхЛкс(Сред(УказательТипа, СтрДлина(КорневоеСловоКомпоновщикТаблицыБД) + 1));
					мЯзыкПрограммы = 0;
				ИначеЕсли ЛиКорневоеИмяТиповXDTO(ПервоеСлово) Тогда
					Фрагменты = ирОбщий.СтрРазделитьЛкс(УказательТипа);
					ОбъектМД = Метаданные.ПакетыXDTO.Найти(Фрагменты[1]); // ОбъектМетаданныхПакетXDTO
					СтруктураТипа = мПлатформа.НоваяСтруктураТипа("ОбъектXDTO");
					СтруктураТипа.Метаданные = ФабрикаXDTO.Пакеты.Получить(ОбъектМД.ПространствоИмен).Получить(Фрагменты[2]);
				ИначеЕсли ИмяМножественное <> Неопределено Тогда
					СтруктураТипа = ВычислитьСловоФормыПоПолномуИмени(УказательТипа, ДляСвойстваПуть, ТаблицаТиповСвойства);
					Если СтруктураТипа <> Неопределено Тогда 
						Если ЗначениеЗаполнено(ТаблицаТиповСвойства.Колонки.Метаданные.Заголовок) Тогда
							ТаблицаТипов.Колонки.Метаданные.Заголовок = ЗаголовокФлагОбрезкиГлубины();
						КонецЕсли;
					Иначе
						ОбъектМД = Метаданные.НайтиПоПолномуИмени(УказательТипа);
						Попытка
							СтруктураТипа = ОбъектМД.Тип;
						Исключение
						КонецПопытки;
						Если СтруктураТипа = Неопределено Тогда
							Попытка
								СтруктураТипа = ОбъектМД.ТипЗначения;
							Исключение
							КонецПопытки;
						КонецЕсли; 
					КонецЕсли;
				КонецЕсли;
			КонецЕсли;
			Если СтруктураТипа <> Неопределено Тогда 
				мПлатформа.ДобавитьВТаблицуТипов(ТаблицаТипов, СтруктураТипа);
			Иначе
				НоваяТаблицаТипов = Новый Массив;
				Если Найти(УказательТипа, "Объект.") > 0 И СтрЧислоВхождений(УказательТипа, ".") > 1 Тогда
					ИмяТипаОбъекта = ирОбщий.ПервыеФрагментыЛкс(УказательТипа);
					Попытка
						ОписаниеТиповОбъекта = Новый ОписаниеТипов(ИмяТипаОбъекта);
					Исключение
						ОписаниеТиповОбъекта = Неопределено;
					КонецПопытки;
					Если ОписаниеТиповОбъекта <> Неопределено Тогда
						ТаблицаТиповРодителя = мПлатформа.ТаблицаТиповИзОписанияТипов(ОписаниеТиповОбъекта);
						ПоследнийФрагмент = Сред(УказательТипа, СтрДлина(ИмяТипаОбъекта) + 2);
						Слово = ПоследнийФрагмент;
						Если Найти(Слово, "(") > 0 Тогда
							Слово = ирОбщий.ПервыйФрагментЛкс(Слово, "(");
						КонецЕсли;
						ТекущийИндекс = "";
						Если Найти(Слово, "[") > 0 Тогда
							ТекущийИндекс = "0";
							Слово = ирОбщий.ПервыйФрагментЛкс(Слово, "[");
						КонецЕсли;
						НоваяТаблицаТипов = ВычислитьТипДочернегоЭлемента(ТаблицаТиповРодителя, Слово, "Метод",,,,,,,, ДляСвойстваПуть); // Мультметка481922915
						ирОбщий.УдалитьСтрокиТаблицыИлиДереваПоЗначениюЛкс(НоваяТаблицаТипов, "Детальность", 0);
						Если НоваяТаблицаТипов.Количество() = 0 И ПоследнийФрагмент = Слово Тогда
							НоваяТаблицаТипов = ВычислитьТипДочернегоЭлемента(ТаблицаТиповРодителя, Слово, "Свойство",,,,,,,, ДляСвойстваПуть);
						КонецЕсли;
						Если ЗначениеЗаполнено(ТекущийИндекс) Тогда
							НоваяТаблицаТипов = ВычислитьТипДочернегоЭлемента(НоваяТаблицаТипов, ТекущийИндекс, "Свойство", ТекущийИндекс,,,,,,, ДляСвойстваПуть);
						КонецЕсли;
					КонецЕсли;
				КонецЕсли;
				Если НоваяТаблицаТипов.Количество() = 0 Тогда
					НоваяТаблицаТипов = ВычислитьТипЗначенияВыражения(УказательТипа, ТекстДоВхождения, ТекстДоВхождения,,,, Ложь,,,,, Позиция0ВМетоде,, ДляСвойстваПуть); // Мультметка481922915 Позицию передаем чтобы можно было отличить комментарий метода
				КонецЕсли;
				Если НоваяТаблицаТипов.Количество() = 0 И Найти(УказательТипа, "(") = 0 Тогда
					НоваяТаблицаТипов = ТаблицаТиповИзПолногоИмениМетодаИлиПараметра(УказательТипа, ДляСвойстваПуть);
				КонецЕсли;
				мПлатформа.ДобавитьВТаблицуТипов(ТаблицаТипов, НоваяТаблицаТипов);
			КонецЕсли;
		КонецЕсли;
	КонецЦикла;
	//Если ТаблицаТипов.Количество() = 0 Тогда
	//	мПлатформа.ДобавитьВТаблицуТипов(ТаблицаТипов, мПлатформа.НоваяСтруктураТипа());
	//КонецЕсли;
~Конец:
	Возврат ТаблицаТипов;
КонецФункции

Функция НовоеОписаниеДинамическогоСвойства(Знач Описание, Знач Позиция0ВМетоде = 0) Экспорт
	Возврат Новый Структура("Описание, Координаты, СтрокаОписания", Описание, НовыеКоординатыВыражения(, Позиция0ВМетоде));
КонецФункции

//.
// Параметры:
//    ТекстТипа - Строка - 
// Возвращаемое значение:
//    ТаблицаЗначений, Неопределено - 
Функция ТаблицаТиповИзПолногоИмениМетодаИлиПараметра(ПолноеИмя, Знач ДляСвойства = "") Экспорт
	ТаблицаТипов = ВычислитьТипЗначенияВыражения(ПолноеИмя + "(",,, Ложь,,, Ложь,,,,,,, ДляСвойства);
	Если ТаблицаТипов.Количество() > 0 Или Найти(ПолноеИмя, "(") > 0 Тогда
		Возврат ТаблицаТипов;
	КонецЕсли;
	ТаблицаТипов = ВычислитьТипЗначенияВыражения(ирОбщий.СтрокаБезПоследнегоФрагментаЛкс(ПолноеИмя) + "(",,, Ложь,,, Ложь,,,,,,, ДляСвойства);
	Если ТаблицаТипов.Количество() > 0 Тогда
		СтрокаМетода = ТаблицаТипов[0].СтрокаОписания; // см. мПлатформа.НоваяТаблицаМетодовМодуля()[0]
		Если Истина
			И ТипЗнч(СтрокаМетода) = Тип("СтрокаТаблицыЗначений") 
			И СтрокаМетода.Владелец().Колонки.Найти("ЛиЭкспорт") <> Неопределено
		Тогда
			Если СтрокаМетода.Имя = "<>" Тогда
				ТаблицаТипов = Неопределено;
			Иначе 
				ПараметрыМетода = мПлатформа.ПараметрыМетодаМодуля(СтрокаМетода);
				Если ПараметрыМетода <> Неопределено Тогда
					ПараметрыМетода = ПараметрыМетода.Скопировать();
					СтрокаПараметра = ПараметрыМетода.Найти(НРег(ирОбщий.ПоследнийФрагментЛкс(ПолноеИмя)), "НИмя");
					Если СтрокаПараметра <> Неопределено Тогда                                                        
						ПараметрыМетода.Колонки.Добавить("ИмяМодуля"); // Мультиметка4819233927
						ПараметрыМетода.Колонки.Добавить("ИмяМетода");
						ПараметрыМетода.ЗаполнитьЗначения(СтрокаМетода.ИмяМодуля, "ИмяМодуля");
						ПараметрыМетода.ЗаполнитьЗначения(СтрокаМетода.Имя, "ИмяМетода");
						НоваяТаблицаТипов = ТаблицаТиповИзПараметраМетодаМодуля(СтрокаМетода, СтрокаПараметра, ДляСвойства);
						Если НоваяТаблицаТипов <> Неопределено Тогда
							ТаблицаТипов = НоваяТаблицаТипов.Скопировать(); // Чтобы не было циклической ссылки в СтрокаОписания
							Если ТаблицаТипов.Количество() = 0 Тогда
								СтрокаТипа = ТаблицаТипов.Добавить();
								СтрокаТипа.Детальность = 0;
							КонецЕсли;
							ТаблицаТипов.ЗаполнитьЗначения(СтрокаПараметра, "СтрокаОписания"); // Только здесь ее заполняем для унификации перехода к определению
						КонецЕсли;
					КонецЕсли;
				КонецЕсли;
			КонецЕсли;
		КонецЕсли;
	КонецЕсли;
	Возврат ТаблицаТипов;
КонецФункции

// Быстро получает таблицу типов без анализа вызовов метода.
// Параметры:
//    СтрокаМетода - СтрокаТаблицыЗначений - 
//    СтрокаПараметра - СтрокаТаблицыЗначений - 
// Возвращаемое значение:
//    ТаблицаЗначений, Неопределено - 
Функция ТаблицаТиповИзПараметраМетодаМодуля(Знач СтрокаМетода, Знач СтрокаПараметра, Знач ДляСвойства = "", Знач Позиция0ВМетоде = 0) Экспорт
	Если СтрокаПараметра.ТаблицаТипов <> Неопределено Тогда
		НоваяТаблицаТипов = СтрокаПараметра.ТаблицаТипов;
	ИначеЕсли ЗначениеЗаполнено(СтрокаПараметра.ТипЗначения) Тогда
		АнализаторМодуля = мПлатформа.ПолеТекстаМодуля(СтрокаМетода.ИмяМодуля);
		НоваяТаблицаТипов = АнализаторМодуля.ТаблицаТиповИзТекста(СтрокаПараметра.ТипЗначения, СтрокаПараметра.Описание,, ДляСвойства,,,, Позиция0ВМетоде); // TODO защита от бесконечной рекурсии
	Иначе 
		НоваяТаблицаТипов = Неопределено;
	КонецЕсли;
	Возврат НоваяТаблицаТипов;
КонецФункции

Функция ВычислитьСловоФормыПоПолномуИмени(Знач ИмяТипа, Знач ДляСвойства = "", выхТаблицаТипов = Неопределено)
	
	ЧастиИмени = ЧастиПолногоИмениЭлементаФормы(ИмяТипа);
	Если ЧастиИмени = Неопределено Тогда
		Возврат Неопределено;
	КонецЕсли;
	Выражение = """" + ЧастиИмени.ИмяФормы + """";
	Если ЗначениеЗаполнено(ЧастиИмени.ПутьКЭлементу) Тогда
		// Так форма на 5мс дольше создается
		Выражение = "ПолучитьФорму(" + Выражение + ")." + ЧастиИмени.ПутьКЭлементу;
		выхТаблицаТипов = ВычислитьТипЗначенияВыражения(Выражение,,,,,, Ложь,,,, Истина,,, ДляСвойства);
		Если выхТаблицаТипов.Количество() > 0 Тогда
			Если выхТаблицаТипов[0].Детальность < 2 Тогда // Опасно
				выхТаблицаТипов = ВычислитьТипЗначенияВыражения(Выражение + "(",,,,,, Ложь,,,, Истина,,, ДляСвойства);
			КонецЕсли; 
		КонецЕсли;
	Иначе
		выхТаблицаТипов = ВычислитьПолучитьФорму(ВычислитьТипЗначенияВыражения("",,,,,, Ложь), ирОбщий.ЗначенияВМассивЛкс(Выражение));
	КонецЕсли;
	Если ЗначениеЗаполнено(выхТаблицаТипов) Тогда
		Результат = выхТаблицаТипов[0];  
	КонецЕсли;
	Возврат Результат;

КонецФункции                                           

Функция ЧастиПолногоИмениЭлементаФормы(Знач ИмяТипа) Экспорт
	Если Найти(ИмяТипа, "Форма") = 0 Тогда
		Возврат Неопределено;
	КонецЕсли;
	ФрагментыТочки = ирОбщий.СтрРазделитьЛкс(ИмяТипа);
	КоличествоФрагментов = ФрагментыТочки.Количество();
	Если КоличествоФрагментов > 1 И ФрагментыТочки[0] = "ОбщаяФорма" Тогда 
		ЧислоФрагментовИмени = 2;
	ИначеЕсли КоличествоФрагментов > 2 И ФрагментыТочки[2] = "Форма" Тогда 
		ЧислоФрагментовИмени = Мин(4, КоличествоФрагментов);
	Иначе
		ВсеИменаСтандартныхФорм = мПлатформа.ВсеИменаСтандартныхФорм();
		РолиФормКласса = Неопределено; // СписокЗначений
		Если ВсеИменаСтандартныхФорм.Свойство(ФрагментыТочки[0], РолиФормКласса) Тогда
			Для Индекс = 2 По ФрагментыТочки.ВГраница() Цикл
				Если ирОбщий.НайтиЭлементКоллекцииЛкс(РолиФормКласса, "Значение", ФрагментыТочки[Индекс],, Ложь) <> Неопределено Тогда
					ЧислоФрагментовИмени = Индекс + 1;
					Прервать;
				КонецЕсли;
			КонецЦикла;
		КонецЕсли;
		Если ЧислоФрагментовИмени = Неопределено Тогда
			Возврат Неопределено;
		КонецЕсли;
	КонецЕсли;
	Результат = Новый Структура;
	Результат.Вставить("ИмяФормы", ирОбщий.СтрСоединитьЛкс(ФрагментыТочки, ".", ЧислоФрагментовИмени));
	Для Счетчик = 1 По ЧислоФрагментовИмени Цикл
		ФрагментыТочки.Удалить(0);
	КонецЦикла;
	Результат.Вставить("ПутьКЭлементу", ирОбщий.СтрСоединитьЛкс(ФрагментыТочки, "."));
	Возврат Результат;
КонецФункции

Функция ЧастиПолногоИмениЭлементаМакета(Знач ИмяТипа) Экспорт
	Если Найти(ИмяТипа, "Макет") = 0 Тогда
		Возврат Неопределено;
	КонецЕсли;
	ФрагментыТочки = ирОбщий.СтрРазделитьЛкс(ИмяТипа);
	КоличествоФрагментов = ФрагментыТочки.Количество();
	Если КоличествоФрагментов > 1 И ФрагментыТочки[0] = "ОбщийМакет" Тогда 
		ЧислоФрагментовИмени = 2;
	ИначеЕсли КоличествоФрагментов > 2 И ФрагментыТочки[2] = "Макет" Тогда 
		ЧислоФрагментовИмени = Мин(4, КоличествоФрагментов);
	КонецЕсли;
	Результат = Новый Структура;
	Результат.Вставить("ИмяМакета", ирОбщий.СтрСоединитьЛкс(ФрагментыТочки, ".", ЧислоФрагментовИмени));
	Для Счетчик = 1 По ЧислоФрагментовИмени Цикл
		ФрагментыТочки.Удалить(0);
	КонецЦикла;
	Результат.Вставить("ПутьКЭлементу", ирОбщий.СтрСоединитьЛкс(ФрагментыТочки, "."));
	Возврат Результат;
КонецФункции

Процедура ОбновитьКонтекстВыраженияЗапросаПоНастройкеКомпоновкиЛкс(НастройкаКомпоновки) Экспорт 
	
	#Если Сервер И Не Сервер Тогда
		НастройкаКомпоновки = Новый НастройкиКомпоновкиДанных;
	#КонецЕсли
	ОчиститьТаблицуСловЛокальногоКонтекста();
	Для Каждого ДоступноеПоле Из НастройкаКомпоновки.ДоступныеПоляОтбора.Элементы Цикл
		НрегПервыйФрагмент = ирОбщий.ПервыйФрагментЛкс(НРег(ДоступноеПоле.Поле));
		Если НрегПервыйФрагмент = НРег("ПараметрыДанных") Тогда
			Для Каждого ДоступныйПараметр Из ДоступноеПоле.Элементы Цикл
				ИмяСвойства = мПараметрыДиалектаSQL.ПрефиксПараметра + ирОбщий.ПоследнийФрагментЛкс(ДоступныйПараметр.Поле);
				ИмяОбщегоТипа = ИмяОбщегоТипаДляКорневогоСловаИзДоступногоПоля(ДоступныйПараметр);
				ДобавитьСловоЛокальногоКонтекста(ИмяСвойства, "Свойство", ДоступныйПараметр.ТипЗначения, ДоступныйПараметр,,,, ИмяОбщегоТипа);
			КонецЦикла; 
		Иначе
			ИмяОбщегоТипа = ИмяОбщегоТипаДляКорневогоСловаИзДоступногоПоля(ДоступноеПоле);
			ДобавитьСловоЛокальногоКонтекста("" + ДоступноеПоле.Поле, "Свойство", ДоступноеПоле.ТипЗначения, ДоступноеПоле,,,, ИмяОбщегоТипа);
		КонецЕсли; 
	КонецЦикла;

КонецПроцедуры

Функция ИмяОбщегоТипаДляКорневогоСловаИзДоступногоПоля(Знач ДоступныйПараметр)
	ИмяОбщегоТипа = "СтрокаТаблицы"; // Виртуальный тип для псевдонимов таблиц
	Если ДоступныйПараметр.ТипЗначения.Типы().Количество() > 0 Тогда
		ИмяОбщегоТипа = "";
	КонецЕсли;
	Возврат ИмяОбщегоТипа;
КонецФункции

Процедура УстановитьПризнакМодифицированностиФормы() Экспорт

	Если ПолеТекста.ЭлементФормы.ИзменяетДанные Тогда
		ФормаВладелец.Модифицированность = Истина;
	КонецЕсли; 

КонецПроцедуры

Функция ПолучитьСтруктуруТипаСправаОтРавно() Экспорт 
	
	КончитьОбработкуКоманды();
	ТаблицаТипов = ТаблицаТиповТекущегоВыражения(Истина);
	КончитьОбработкуКоманды();
	СписокТиповКонтекста = Новый СписокЗначений;
	МассивДляПроверкиДублей = Новый Массив;
	Для Каждого СтруктураТипаКонтекста Из ТаблицаТипов Цикл
		ИмяОбщегоТипа = СтруктураТипаКонтекста.ИмяОбщегоТипа;
		Если Ложь
			Или Не мПлатформа.ЭтоАгрегатныйОбщийТип(ИмяОбщегоТипа, ЯзыкПрограммы) 
			Или ТипЗнч(СтруктураТипаКонтекста.Метаданные) <> Тип("ОбъектМетаданных")
			Или (Истина
				И ЯзыкПрограммы = 0
				И Найти(ИмяОбщегоТипа, "Ссылка.") = 0)
		Тогда 
			Продолжить;
		КонецЕсли;
		ПредставлениеКонкретногоТипа = "";
		ПредставлениеКонкретногоТипа = ПредставлениеКонкретногоТипа + мПлатформа.ИмяТипаИзСтруктурыТипа(СтруктураТипаКонтекста);
		Если МассивДляПроверкиДублей.Найти(ПредставлениеКонкретногоТипа) = Неопределено Тогда
			СписокТиповКонтекста.Добавить(СтруктураТипаКонтекста, ПредставлениеКонкретногоТипа);
			МассивДляПроверкиДублей.Добавить(ПредставлениеКонкретногоТипа);
		КонецЕсли;
	КонецЦикла;
	Если СписокТиповКонтекста.Количество() > 0 Тогда
		Ответ = Вопрос("Хотите использовать предсказанные равенством метаданные?", РежимДиалогаВопрос.ДаНет);
		Если Ответ = КодВозвратаДиалога.Нет Тогда
			Возврат Неопределено;
		КонецЕсли;
	КонецЕсли; 
	Если СписокТиповКонтекста.Количество() = 1 Тогда 
		ВыбраннаяСтруктураТипа = СписокТиповКонтекста[0].Значение;
		КонкретныйТип = СписокТиповКонтекста[0].Представление;
	ИначеЕсли СписокТиповКонтекста.Количество() > 1 Тогда
		СписокТиповКонтекста.СортироватьПоПредставлению();
		ВыбранныйТип = СписокТиповКонтекста.ВыбратьЭлемент("Выберите тип контекста");
		Если ВыбранныйТип <> Неопределено Тогда
			ВыбраннаяСтруктураТипа = ВыбранныйТип.Значение;
			КонкретныйТип = ВыбранныйТип.Представление;
		КонецЕсли;
	КонецЕсли;
	//Если ВыбраннаяСтруктураТипа <> Неопределено Тогда
	//	СтруктураТипаКонтекста = мПлатформа.НоваяСтруктураТипа();
	//	ЗаполнитьЗначенияСвойств(СтруктураТипаКонтекста, ВыбраннаяСтруктураТипа);
	//КонецЕсли;
	Возврат ВыбраннаяСтруктураТипа;

КонецФункции//ПолучитьСтруктуруТипаСправоОтРавно

Функция ТаблицаТиповТекущегоВыражения(ВзятьЛевоеОтРавенства = Ложь, БезКонструкторов = Ложь, ПолныйАнализСоставаТипов = Истина, Знач ЛиCOMВызов = Ложь, Знач ЛиДляРодителя = Истина) Экспорт

	НомерСтроки = 0; // Был параметром
	НомерКолонки = 0; // Был параметром
	РазобратьТекущийКонтекст(ВзятьЛевоеОтРавенства,,, НомерСтроки, НомерКолонки, Истина);
	лКонтекст = ?(ВзятьЛевоеОтРавенства Или ЛиДляРодителя <> Истина, мКонтекст, мРодительскийКонтекст);
	Если Ложь                                 
		Или (Истина
			И Прав(мТекущаяСтрокаНачало, 1) = """"
			И Не ирОбщий.ЛиВнутриТекстовогоЛитералаЛкс(мТекущаяСтрокаНачало))
		Или (Истина
			И Не ВзятьЛевоеОтРавенства 
			И Прав(мТекущаяСтрокаНачало, 1) = "."  
			И ПустаяСтрока(мРодительскийКонтекст))
	Тогда
		Возврат мПлатформа.НоваяТаблицаТипов();
	КонецЕсли;
	мПлатформа.мРежимПроверкиМодуля = Ложь;
	мПлатформа.мРежимПереходаКОпределению = Ложь;
	Если мЯзыкПрограммы = 0 И ЗначениеЗаполнено(мТекстДляПоискаОпределения) Тогда
		Позиция0ВМетодеДо = СтрДлина(мТекстДляПоискаОпределения);
		Позиция0ВМетодеДо = Позиция0ВМетодеДо + СтрДлина(мТекущаяСтрокаНачало) - СтрДлина(мНачалоКонтекста); // Встаем в начало выражения
	Иначе
		Позиция0ВМетодеДо = мПозицияВБлоке; 
	КонецЕсли;
	Попытка
		ТаблицаТиповКонтекста = ВычислитьТипЗначенияВыражения(лКонтекст, мТекстДляПоискаОпределения, мПредшествующийТекст, Истина,, ПолныйАнализСоставаТипов,,,,,, Позиция0ВМетодеДо);
	Исключение
		Ошибка = ИнформацияОбОшибке();
		Если Ошибка.Описание = "ОшибкаВычисленияВиртуальнойТаблицы" Тогда 
			Возврат мПлатформа.НоваяТаблицаТипов();
		КонецЕсли;
		Если ЛиCOMВызов Тогда
			ВызватьИсключение ОписаниеОшибки();
		Иначе
			ВызватьИсключение;
		КонецЕсли;
	КонецПопытки;
	ТаблицаТиповКонтекста = ТаблицаТиповКонтекста.Скопировать(); // Могла вернуться прямая таблица из кэша
	Если БезКонструкторов Тогда
		Для Каждого СтрокаТаблицы Из ТаблицаТиповКонтекста.НайтиСтроки(Новый Структура("Конструктор", Истина)) Цикл
			ТаблицаТиповКонтекста.Удалить(СтрокаТаблицы);
		КонецЦикла;
	КонецЕсли; 
    Возврат ТаблицаТиповКонтекста;
	
КонецФункции

Функция ПодготовитьИмяПараметраМетодаПлатформы(ИмяПараметра) Экспорт 
	
	//ирОбщий.ДекодироватьТекстИзXMLЛкс(СтрокаПараметра.Параметр);
	ИмяПараметра = СтрЗаменить(ИмяПараметра, "&gt;", "");
	ИмяПараметра = СтрЗаменить(ИмяПараметра, "&lt;", "");
	Возврат ИмяПараметра;

КонецФункции

Функция СтрокаИменПараметровМетода() Экспорт 
	Возврат ирОбщий.СтрСоединитьЛкс(мПлатформа.ПараметрыМетодаМодуля(мМетодМодуля).ВыгрузитьКолонку("Имя"), ",")
КонецФункции

// Вызывает контекстную подсказку в текстовом поле.
//
// Параметры:
//  Нет.
//
Процедура ОткрытьАвтодополнение(Знач КодКлавиши = "", Знач Модально = Ложь) Экспорт 
	
	Если ирОбщий.ПроверитьПлатформаНеWindowsЛкс(,, Истина) Тогда 
		Возврат;
	КонецЕсли; 
	#Если Сервер И Не Сервер Тогда
		мПлатформа = Обработки.ирПлатформа.Создать();
	#КонецЕсли
	// Мультиметка00452941 Удаляем лишние точки истории из-за запоминания по нажатию CTRL
	УдалитьПоследнийПереходИзИстории();
	ФормаАвтодополнение = ФормаАвтодополнение();
	КодыКлавиш = ирКэш.КодыКлавишЛкс();
	Если Ложь
		Или ПолеТекста.ТолькоПросмотр()
		Или ФормаВладелец <> Неопределено И ФормаВладелец.ТолькоПросмотр     
	Тогда
		Возврат;
	КонецЕсли;
	Если Истина
		И ФормаАвтодополнение.Открыта() 
		И Не ирКлиент.ЛиПерехватКлавиатурногоВводаЛкс() 
	Тогда
		ирКлиент.Форма_АктивироватьОткрытьЛкс(ФормаАвтодополнение);
		Возврат;
	КонецЕсли;
	Если Истина
		И Не ЗначениеЗаполнено(КодКлавиши) 
		И ирКлиент.ЛиПерехватКлавиатурногоВводаЛкс() 
	Тогда
		Возврат;
	КонецЕсли;
	Если Истина
		//И Найти(КодКлавиши, "04128") = 1 // CTRL+SPACE
		И КодКлавиши = "" // Вызов из обработчика нажатия кнопки
		И ТипЗнч(ПолеТекста.ЭлементФормы) = Тип("ПолеHTMLДокумента")
		И ирКэш.НомерВерсииПлатформыЛкс() <= 803016
	Тогда
		// https://github.com/salexdv/bsl_console/issues/124
		ПолеТекста.РедакторHTML().triggerSuggestions(); 
		Возврат;
	КонецЕсли; 
	
	//Если Истина
	//	И ЯзыкПрограммы = 1
	//	И Не мДоступныеТаблицыПолучены 
	//Тогда
	//	Если ирОбщий.СтрокиРавныЛкс(мДиалектSQL, "1С") Тогда
	//	ИначеЕсли ирОбщий.СтрокиРавныЛкс(мДиалектSQL, "WQL") Тогда
	//	Иначе
	//		ЗаполнитьДоступныеТаблицыADO(); // Может быть очень долго
	//		Для Каждого СтрокаДоступнойТаблицы Из ДоступныеТаблицы Цикл
	//			ДобавитьСловоЛокальногоКонтекста(СтрокаДоступнойТаблицы.Имя,,,,,,, "ВременнаяТаблица");
	//		КонецЦикла; 
	//	КонецЕсли; 
	//КонецЕсли; 
	СтруктураТипаКонтекста = Неопределено;
	ТаблицаТиповКонтекста = Неопределено;  
	//Модально = Модально Или Не ЛиДоступноОткрытиеСвободнойФормы();
	Модально = Не ирКлиент.ЛиПерехватКлавиатурногоВводаЛкс();
	ЛиАвтовызов = ЗначениеЗаполнено(КодКлавиши) И Найти(КодКлавиши, КодыКлавиш["CTRL+Space"]) = 0;
	Пока Истина Цикл
		ЕстьЛучшееСлово = Ложь;
		Успешно = ЗаполнитьТаблицуСлов(ТаблицаТиповКонтекста,, ЕстьЛучшееСлово, Модально,, Не ЛиАвтовызов);
		Если Не Успешно Тогда
			Возврат;
		КонецЕсли;
		//Если Ложь 
		//	Или Не Успешно 
		//	Или (Истина
		//		И мСтруктураТипаКонтекста.ТипЯзыка = "ИмяТипа" 
		//		И Найти(мКодКлавишиОткрытияАвтодополнения, КодыКлавиш["Space"]) = 1
		//		И мСтрокаЛучшегоСлова = Неопределено)
		//Тогда
		//	Возврат;
		//КонецЕсли;
		Если Истина
			И ТаблицаСлов.Количество() = 0
			И Не ирОбщий.ВосстановитьЗначениеЛкс(ИмяКласса + ".ЛиОткрыватьПустойСписок") = Истина
		Тогда
			Возврат;
		КонецЕсли;
		//Попытка
		//	ФормаАвтодополнение.мСтруктураТипаКонтекста = мСтруктураТипаКонтекста;
		//Исключение
		//	ВызватьИсключение "Экземпляр формы автодополнения контекстной подсказки сломан ошибкой платформы. Переоткройте форму чтобы восстановить ее работу";
		//КонецПопытки;
		//Если ЗначениеЗаполнено(мСтруктураТипаКонтекста.ТипЯзыка) Тогда
		//	ФормаАвтодополнение.Контекст = мСтруктураТипаКонтекста.ТипЯзыка;
		//Иначе
		//	ФормаАвтодополнение.Контекст = мРодительскийКонтекст;
		//КонецЕсли; 
		Если ФормаВладелец <> Неопределено Тогда
			Если ФормаАвтодополнение.Открыта() Тогда
				// Иначе будет считана некорректная позиция окна 
				ФормаАвтодополнение.Закрыть();
			КонецЕсли;
			ФормаАвтодополнение.ЗапомнитьПозициюКаретки();
			ФормаВладелец.Активизировать(); 
		КонецЕсли;
		//ирКлиент.Форма_АктивироватьОткрытьЛкс(ФормаВладелец); // https://www.hostedredmine.com/issues/911214
		ФормаАвтодополнение.НачальноеЗначениеВыбора = мСтрокаЛучшегоСлова;
		ФормаАвтодополнение.ОжидаемыйТип = мИмяОжидаемогоТипа;
		ФормаАвтодополнение.Автозакрытие = мЭтоОбъявлениеПсевдонима;
		ПараметрЗакрытияПодсказки = Неопределено;
		Если Модально Тогда
			//ПараметрЗакрытияПодсказки = ФормаАвтодополнение.ОткрытьМодально(); // В УП портит свободный режим
			ФормаАвтодополнение.ТекущееСлово = мНачалоСлова;
			ФормаАвтодополнение.ПараметрАктивизировать = Истина;
			ФормаАвтодополнение.Открыть();
		Иначе
			Если ФормаАвтодополнение.Автозакрытие Тогда
				ФормаАвтодополнение.ТекущееСлово = мНачалоСлова;
			КонецЕсли;
			ОткрытьФормуПассивно(ФормаАвтодополнение);
		КонецЕсли;
		Если ПараметрЗакрытияПодсказки = Неопределено Тогда
			Возврат;
		КонецЕсли; 
		СтрокаРезультата = ФормаАвтодополнение.СтрокаСловаРезультата;
		Если СтрокаРезультата = Неопределено Тогда
			Возврат;
		КонецЕсли;
		ВставитьВыбранноеСловоАвтодополнения(СтрокаРезультата, ТаблицаТиповКонтекста, ПараметрЗакрытияПодсказки);
		Если ТаблицаТиповКонтекста.Количество() = 0 Тогда
			Возврат;
		КонецЕсли;
	КонецЦикла;

КонецПроцедуры

//.
// Параметры:
//    ФормаАвтодополнение - Форма[Обработка.ирКлсПолеТекстаПрограммы.Форма.АвтодополнениеCOM], Неопределено - 
Процедура ОткрытьФормуПассивно(Форма) Экспорт
	Если ирКэш.ЛиСеансТолстогоКлиентаУПЛкс() Тогда
		Если Не Форма.СвободныйРежим Тогда
			ОсвободительФормУП = ПолучитьФорму("Обработка.ирПлатформа.Форма.ОсвободительФормУП");
			ОсвободительФормУП.ОткрытьМодально();                                              
			ОсвободительФормУП.НеЗакрыватьПриОткрытии = Истина;
			ОсвободительФормУП.Открыть();
			Форма.Открыть(); // Фокус ввода не получает
			Форма.СвободныйРежим = Истина;
			ОсвободительФормУП.Закрыть();
			Если ирОбщий.СлужебныеДанныеФормыЛкс(Форма).ИмяФормы = "Обработка.ирКлсПолеТекстаПрограммы.Форма.ВызовМетода" Тогда
				// Первый раз оно почему то считывает коордиты каретки
				Форма.Закрыть();
				Форма.ЗапомнитьПозициюКаретки();
				Форма.Открыть();
			КонецЕсли;
		Иначе
			Форма.Открыть(); // Фокус ввода не получает
		КонецЕсли;
		Форма.Открыть(); // Фокус ввода получает только, если в этот момент уже открыта, т.е. на втором вызове
	Иначе
		Форма.Открыть();
	КонецЕсли;
КонецПроцедуры

// Процедура - Активировать владельца
//
// Параметры:
//  Форма	 - Форма
//
Процедура АктивироватьВладельца(Форма) Экспорт
	Если Форма.МодальныйРежим Или Форма.ВладелецФормы = Неопределено Тогда
		Возврат;
	КонецЕсли;
	ирКлиент.Форма_АктивироватьОткрытьЛкс(Форма.ВладелецФормы);
КонецПроцедуры

Функция ФормаАвтодополнение() Экспорт
	Если мФормаАвтодополнение = Неопределено Тогда
		мФормаАвтодополнение = ПолучитьФорму("Автодополнение", ФормаВладелец); 
		Если Не мФормаАвтодополнение.Открыта() Тогда
			мФормаАвтодополнение.КлючСохраненияПоложенияОкна = ЯзыкПрограммы; 
		КонецЕсли;
	КонецЕсли;
	Возврат мФормаАвтодополнение;
КонецФункции

Процедура УдалитьПоследнийПереходИзИстории()
	
	Если мИсторияПереходов <> Неопределено И мИсторияПереходов.Количество() > 0 Тогда
		мИсторияПереходов.Удалить(0); 
	КонецЕсли;

КонецПроцедуры

// Функция - Заполнить таблицу слов
// Параметры:
//   ТаблицаТиповКонтекста - см. мПлатформа.НоваяТаблицаТипов() - очищается внутри, поэтому часто нужно передавать копию!
//   ПрименитьОжидаемыйТип -  - 
//   выхЕстьЛучшееСлово - Булево - мСтрокаЛучшегоСлова <> Неопределено
//   РазрешитьОткрытиеОкон -  - 
//   Сортировать -  - 
//   ДобавлятьНизкоВероятные -  - 
//   ОтделятьБольшиеНаборыСлов -  - 
//   ФильтроватьСлово -  - 
// Возвращаемое значение:
//   Булево - нужно ли открывать список подсказки
Функция ЗаполнитьТаблицуСлов(ТаблицаТиповКонтекста = Неопределено, Знач ПрименитьОжидаемыйТип = Истина, выхЕстьЛучшееСлово = Неопределено, Знач РазрешитьОткрытиеОкон = Истина,
	Знач Сортировать = Истина, Знач ДобавлятьНизкоВероятные = Ложь, Знач ОтделятьБольшиеНаборыСлов = Ложь, Знач ФильтроватьСлово = Неопределено, Знач ЗапретГлобальногоКонтекста = Ложь) Экспорт
	
	#Если Сервер И Не Сервер Тогда
		мПлатформа = Обработки.ирПлатформа.Создать();
	#КонецЕсли
	ВычислятьТипы = ПоказыватьВсеТипыВСпискеАвтодополненияHTML();
	мРегВыражение.Global = Истина;
	ТаблицаСтатистикиВыбора = мПлатформа.ТаблицаСтатистикиВыбора;
	Если ТаблицаТиповКонтекста = Неопределено Тогда
		ТаблицаТиповКонтекста = ТаблицаТиповТекущегоВыражения();
	КонецЕсли;
	Если ОтделятьБольшиеНаборыСлов Тогда
		мНаборыСлов = Новый Соответствие;
	Иначе
		мНаборыСлов = Неопределено;
	КонецЕсли;
	мЛиТаблицаСловСортированаПоРейтингу = Истина;
	ТаблицаСлов.Очистить();
	выхЕстьЛучшееСлово = Ложь;
	Если ТаблицаТиповКонтекста.Количество() = 0 Тогда
		ЗаполнитьЗначенияСвойств(ТаблицаТиповКонтекста.Добавить(), мПлатформа.НоваяСтруктураТипа());
		ТаблицаТиповКонтекста[0].Детальность = 0;
	КонецЕсли; 
	мЭтоЛокальныйКонтекстТаблицыСлов = Ложь;
	Если мЭтоТекстовыйЛитерал Тогда
		РазрешитьОткрытиеОкон = Ложь;
	КонецЕсли;
	ЛиВнутриКомментария = ЛиВнутриКомментария();
	ЛиВнутриВыражения = Ложь;
	ТекущаяСтрокаНачало = НРег(мТекущаяСтрокаНачало);
	Если ЯзыкПрограммы = 0 Тогда
		ДобавлятьНизкоВероятные = Ложь
			Или ДобавлятьНизкоВероятные
			//Или ирОбщий.СтрКончаетсяНаЛкс(ТекущаяСтрокаНачало, "Новый") И не ЛиВнутриКомментария 
			Или ирОбщий.СтрКончаетсяНаЛкс(СокрП(ТекущаяСтрокаНачало), "см.") И ЛиВнутриКомментария
			Или ирОбщий.СтрКончаетсяНаЛкс(СокрП(ТекущаяСтрокаНачало), "Массив из") И ЛиВнутриКомментария;
	Иначе
		//ДобавлятьНизкоВероятные = Ложь;
	КонецЕсли;
	мСтруктураТипаКонтекста = Неопределено;
	мАгрегатныеТипыКонтекста = Новый СписокЗначений;
	СоответствиеСтруктурТипов = Новый Соответствие;
	МассивДляПроверкиДублей = Новый Массив;
	Для Каждого СтруктураТипаКонтекста Из ТаблицаТиповКонтекста Цикл
		ИмяОбщегоТипа = СтруктураТипаКонтекста.ИмяОбщегоТипа;
		Если ИмяОбщегоТипа = "Локальный" Тогда
			мЭтоЛокальныйКонтекстТаблицыСлов = Истина;
		КонецЕсли; 
		Если Истина
			И Не ЗначениеЗаполнено(СтруктураТипаКонтекста.ТипЯзыка) 
			И Не мПлатформа.ЭтоАгрегатныйОбщийТип(ИмяОбщегоТипа, мЯзыкПрограммы) 
			//И СтруктураТипаКонтекста.Детальность < 4 // нужно для защиты COM объектов, но мешает в случае ОбъектМетаданных+ОбъектМетаданныхСправочник
		Тогда 
			Продолжить;
		КонецЕсли;
		ПредставлениеКонкретногоТипа = "";
		//Если СтруктураТипаКонтекста.СтрокаОписания <> Неопределено Тогда
		//	// Наверное логичнее было бы из ВычислитьТипЗначенияВыражения ее получать
		//	РодительскаяСтруктураТипа = мПлатформа.НоваяСтруктураТипа();
		//	Если СтруктураТипаКонтекста.СтрокаОписания.Владелец().Колонки.Найти("ТипКонтекста") <> Неопределено Тогда
		//		ЗаполнитьЗначенияСвойств(РодительскаяСтруктураТипа, СтруктураТипаКонтекста);
		//		РодительскаяСтруктураТипа.ИмяОбщегоТипа = СтруктураТипаКонтекста.СтрокаОписания.ТипКонтекста;
		//	КонецЕсли;
		//	ПредставлениеКонкретногоТипа = ПредставлениеКонкретногоТипа 
		//		+ мПлатформа.ИмяТипаИзСтруктурыТипа(РодительскаяСтруктураТипа) + " / ";
		//КонецЕсли;
		ПредставлениеКонкретногоТипа = ПредставлениеКонкретногоТипа + мПлатформа.ИмяТипаИзСтруктурыТипа(СтруктураТипаКонтекста);
		Если МассивДляПроверкиДублей.Найти(ПредставлениеКонкретногоТипа) = Неопределено Тогда
			мАгрегатныеТипыКонтекста.Добавить(ПредставлениеКонкретногоТипа, ПредставлениеКонкретногоТипа + " [" + СтруктураТипаКонтекста.Детальность + "]");
			МассивДляПроверкиДублей.Добавить(ПредставлениеКонкретногоТипа);
		КонецЕсли;
		МассивСтруктурТипа = СоответствиеСтруктурТипов[ПредставлениеКонкретногоТипа];
		Если МассивСтруктурТипа = Неопределено Тогда
			МассивСтруктурТипа = Новый Массив;
		КонецЕсли; 
		МассивСтруктурТипа.Добавить(СтруктураТипаКонтекста);
		СоответствиеСтруктурТипов[ПредставлениеКонкретногоТипа] = МассивСтруктурТипа;
	КонецЦикла; 
	ЭтоГруппаОбщихМодулей = Истина
		И Не мЭтоЛокальныйКонтекстТаблицыСлов
		И мАгрегатныеТипыКонтекста.Количество() > 1 
		И ирОбщий.ПервыйФрагментЛкс(мАгрегатныеТипыКонтекста[0].Значение, "[") = "ОбщийМодуль";
	мКонкретныйТипКонтекста = "";
	ЛиВЗаголовкеМетода = ЛиВЗаголовкеМетода();
	Если ЛиВЗаголовкеМетода Тогда
		ВыбраннаяСтруктураТипа = мПлатформа.НоваяСтруктураТипа();
		ТаблицаТиповКонтекста.Очистить();
		ЗаполнитьЗначенияСвойств(ТаблицаТиповКонтекста.Добавить(), ВыбраннаяСтруктураТипа);
		мЭтоЛокальныйКонтекстТаблицыСлов = Ложь;
	ИначеЕсли Истина
		И Не ЛиВнутриКомментария 
		И ирОбщий.СтрНачинаетсяСЛкс(СокрЛ(мТекущаяСтрокаНачало), "Перем ") 
	Тогда
		ВыбраннаяСтруктураТипа = мПлатформа.НоваяСтруктураТипа();
		ТаблицаТиповКонтекста.Очистить();
		ЗаполнитьЗначенияСвойств(ТаблицаТиповКонтекста.Добавить(), ВыбраннаяСтруктураТипа);
		мЭтоЛокальныйКонтекстТаблицыСлов = Ложь;
		Если мМетодМодуля = Неопределено Тогда
			УстановитьРейтингСлову("Экспорт", 2, "Конструкция");
		КонецЕсли;
	ИначеЕсли мАгрегатныеТипыКонтекста.Количество() = 0 Тогда 
		ВыбраннаяСтруктураТипа = ТаблицаТиповКонтекста[0];
		мКонкретныйТипКонтекста = мПлатформа.ИмяТипаИзСтруктурыТипа(СтруктураТипаКонтекста);
	Иначе
		ВыбраннаяСтруктураТипа = Неопределено;
		мАгрегатныеТипыКонтекста.СортироватьПоПредставлению();
		Если мАгрегатныеТипыКонтекста.Количество() > 1 И РазрешитьОткрытиеОкон И Не ЭтоГруппаОбщихМодулей Тогда
			НачальныйВыбор = Неопределено;
			КлючПоискаСтатистики = Новый Структура("ЯзыкПрограммы, ТипКонтекста", мЯзыкПрограммы, "<ИмяТипа>");
			ВыбранныеРанееТипы = ТаблицаСтатистикиВыбора.Скопировать(КлючПоискаСтатистики);
			ВыбранныеРанееТипы.Сортировать("Рейтинг Убыв");
			Для Каждого СтрокаТипа Из ВыбранныеРанееТипы Цикл
				Для Каждого ЭлементСписка Из мАгрегатныеТипыКонтекста Цикл
					Если СтрокаТипа.Слово = ЭлементСписка.Представление Тогда
						НачальныйВыбор = ЭлементСписка;
						Прервать;
					КонецЕсли; 
				КонецЦикла;
				Если НачальныйВыбор <> Неопределено Тогда
					Прервать;
				КонецЕсли; 
			КонецЦикла;
			ВыбранныйЭлементСписка = мАгрегатныеТипыКонтекста.ВыбратьЭлемент("Выберите тип контекста", НачальныйВыбор);
			Если ВыбранныйЭлементСписка = Неопределено Тогда
				Возврат Ложь;
			КонецЕсли;
			мКонкретныйТипКонтекста = ВыбранныйЭлементСписка.Значение;
			// Обновим статистику выбора
			КлючПоискаСтатистики.Вставить("Слово", мКонкретныйТипКонтекста);
			НайденныеСтроки = ТаблицаСтатистикиВыбора.НайтиСтроки(КлючПоискаСтатистики);
			Если НайденныеСтроки.Количество() > 0 Тогда
				СтрокаСтатистикиВыбора = НайденныеСтроки[0];
			Иначе
				СтрокаСтатистикиВыбора = ТаблицаСтатистикиВыбора.Добавить();
				ЗаполнитьЗначенияСвойств(СтрокаСтатистикиВыбора, КлючПоискаСтатистики);
			КонецЕсли;
			СтрокаСтатистикиВыбора.Рейтинг = СтрокаСтатистикиВыбора.Рейтинг + 1;
		Иначе
			ВыбранныйЭлементСписка = мАгрегатныеТипыКонтекста[0];
			мКонкретныйТипКонтекста = ВыбранныйЭлементСписка.Значение;
		КонецЕсли;
		МассивСтруктурТипа = СоответствиеСтруктурТипов[мКонкретныйТипКонтекста];
		Для Каждого СтруктураТипа Из МассивСтруктурТипа Цикл
			Если Ложь
				Или ВыбраннаяСтруктураТипа = Неопределено 
				Или ВыбраннаяСтруктураТипа.Метаданные = Неопределено
			Тогда
				ВыбраннаяСтруктураТипа = СтруктураТипа;
			КонецЕсли; 
		КонецЦикла;
	КонецЕсли; 
	мСтруктураТипаКонтекста = мПлатформа.НоваяСтруктураТипа();
	Если мЭтоТекстовыйЛитерал Тогда
		мАгрегатныеТипыКонтекста.Очистить();
	КонецЕсли;
	мТаблицаСловЛитерала = Неопределено;
	мСтрокаЛучшегоСлова = Неопределено;
	ДобавлятьСтатистическиеСлова = Ложь;
	УстановитьНСлово = Ложь;
	ШагРейтингаСлова = ШагРейтингаСлова();
	мТаблицаТиповКонтекста = ТаблицаТиповКонтекста.Скопировать();
	Если мЯзыкПрограммы = 0 И ирОбщий.ЛиВнутриПрепроцессораЛкс(мТекущаяСтрокаНачало) Тогда 
		Слова = Новый Массив;
		Слова.Добавить("Если");
		Слова.Добавить("Тогда");
		Слова.Добавить("ИначеЕсли");
		Слова.Добавить("Иначе");
		Слова.Добавить("КонецЕсли");
		Слова.Добавить("Вставка");
		Слова.Добавить("КонецВставки");
		Слова.Добавить("Удаление"); 
		Слова.Добавить("КонецУдаления");
		Слова.Добавить("Область");
		Слова.Добавить("КонецОбласти");
		Слова.Добавить("Клиент");
		Слова.Добавить("Сервер");
		Слова.Добавить("ТолстыйКлиентУправляемоеПриложение");
		Слова.Добавить("ТолстыйКлиентОбычноеПриложение");
		Слова.Добавить("ТонкийКлиент");
		Слова.Добавить("ВебКлиент");
		Слова.Добавить("МобильныйКлиент");
		Слова.Добавить("ВнешнееСоединение");
		Для Каждого Слово Из Слова Цикл
			мПлатформа.ДобавитьВТаблицуСлов(ТаблицаСлов, Слово, "Конструкция",, "", "Предопределенный");
		КонецЦикла; 
		мСтруктураТипаКонтекста.ИмяОбщегоТипа = "";
		мСтруктураТипаКонтекста.ТипЯзыка = "Препроцессор";
	ИначеЕсли Истина
		И мЯзыкПрограммы = 1 
		И мЭтоОбъявлениеПсевдонима 
		И ВыбраннаяСтруктураТипа.ТипЯзыка = ""
	Тогда
		мРегВыражение.Pattern = "(" + шПараметрЗапроса + "|" + шОбъектноеВыражение + ")\s+(КАК|AS)\s+(?:" + шИмя + ")?$";
		Результат = мРегВыражение.НайтиВхождения(мТекущаяСтрокаНачало);
		Если Результат.Количество() > 0 Тогда
			ПервоеВхождение = Результат[0].SubMatches(0); 
			СтрокаДоступнойТаблицы = ирОбщий.ОписаниеТаблицыБДЛкс(ПервоеВхождение);
			ВариантыИмениПеременной = Новый Массив;
			Если СтрокаДоступнойТаблицы <> Неопределено Тогда
				ОсновнойПсевдоним = ОсновнойПсевдонимТаблицыБД(СтрокаДоступнойТаблицы);
				ВариантыИмениПеременной.Добавить(ОсновнойПсевдоним);
				Если Найти(ОсновнойПсевдоним, "_") > 0 Тогда
					ВариантыИмениПеременной.Добавить(ирОбщий.ПоследнийФрагментЛкс(ОсновнойПсевдоним, "_"));
				КонецЕсли;
			Иначе
				ВхожденияИмен = ирОбщий.НайтиРегВыражениеЛкс(ПервоеВхождение, шПараметрЗапроса + "|" + шИмяСТочками,,,,,, Истина);
				Для Каждого ВхождениеИмени Из ВхожденияИмен Цикл
					ТекстВхождения = ВхождениеИмени.ТекстВхождения;
					//Если Истина
					//	И Найти(ТекстВхождения, ".") = 0
					//	И Лев(ТекстВхождения, 1) <> мПараметрыДиалектаSQL.ПрефиксПараметра
					//Тогда
					//	Продолжить;
					//КонецЕсли;
					ТекстВхождения = СтрЗаменить(ТекстВхождения, мПараметрыДиалектаSQL.ПрефиксПараметра, "");
					Фрагменты = ирОбщий.СтрРазделитьЛкс(ТекстВхождения);
					//Если ирОбщий.МножественноеИмяМДЛкс(Фрагменты[0]) <> Неопределено Тогда
					//	Пока Фрагменты.Количество() > 1 Цикл
					//		Фрагменты.Удалить(0);
					//	КонецЦикла;
					//КонецЕсли;
					Пока Фрагменты.Количество() > 0 Цикл
						ПоследнееСлово = ирОбщий.СтрСоединитьЛкс(Фрагменты, "");
						ВариантыИмениПеременной.Добавить(ПоследнееСлово);
						Фрагменты.Удалить(0);
					КонецЦикла;
				КонецЦикла;
				Если Истина
					И СтрЧислоВхождений(ПервоеВхождение, ".") = 1
					И ирОбщий.СтрокиРавныЛкс(ПоследнееСлово, "ссылка")
				Тогда
					ТаблицаТипов = ВычислитьТипЗначенияВыражения(ПервоеВхождение, мТекстДляПоискаОпределения);
					ДобавитьВариантыИмениНовойПеременнойИзТипа(ВариантыИмениПеременной, ТаблицаТипов); 
				КонецЕсли;
			КонецЕсли;
			Для Каждого ВариантИмени Из ВариантыИмениПеременной Цикл
				мПлатформа.ДобавитьВТаблицуСлов(ТаблицаСлов, ВариантИмени, "Свойство",, "", "Локальный");
			КонецЦикла;
		КонецЕсли;
		ПрименитьОжидаемыйТип = Ложь;
		мСтруктураТипаКонтекста.ИмяОбщегоТипа = "";
	ИначеЕсли Истина
		И мЯзыкПрограммы = 0 
		И ирОбщий.СтрКончаетсяНаЛкс(ирОбщий.СтрокаБезПоследнегоФрагментаЛкс(мТекущаяСтрокаНачало, " "), "Для каждого")
	Тогда
		мРегВыражение.Pattern = "(?:" + шИмя + ")?\s+Из\s+(" + шОбъектноеВыражение + ")\s+Цикл(?:$|\s)";
		Результат = мРегВыражение.НайтиВхождения(мТекущаяСтрокаКонец);
		Если Результат.Количество() > 0 Тогда
			ВариантыИмениПеременной = Новый Массив;
			ПервоеВхождение = Результат[0].SubMatches(0); 
			ТаблицаТиповКоллекции = ВычислитьТипЗначенияВыражения(ПервоеВхождение, мТекстДляПоискаОпределения);
			Если ТаблицаТиповКоллекции.Количество() > 0 Тогда
				ТаблицаТиповЭлемента = мПлатформа.ТаблицаТиповЭлементовКоллекции(ТаблицаТиповКоллекции[0]);
				Если ТаблицаТиповЭлемента.Количество() > 0 Тогда
					ИмяТипаЭлемента = ДобавитьВариантыИмениНовойПеременнойИзТипа(ВариантыИмениПеременной, ТаблицаТиповЭлемента); 
				КонецЕсли;
			КонецЕсли;
			ПоследнееИмя = ирОбщий.ПоследнийФрагментЛкс(ПервоеВхождение);
			ДобавитьВариантыИмениНовойПеременнойИзСлова(ВариантыИмениПеременной, ПоследнееИмя,, "Элемент");
			Для Каждого ВариантИмени Из ВариантыИмениПеременной Цикл
				НоваяСтрока = мПлатформа.ДобавитьВТаблицуСлов(ТаблицаСлов, ВариантИмени, "Свойство",, ИмяТипаЭлемента, "Локальный");
				НоваяСтрока.Рейтинг = 3 * ШагРейтингаСлова;
			КонецЦикла;
		КонецЕсли;
		мЭтоОбъявлениеПсевдонима = Истина;
		ПрименитьОжидаемыйТип = Ложь;
		мСтруктураТипаКонтекста.ИмяОбщегоТипа = "";
	Иначе
		КоллекцияЭлементовМД = Новый Массив;
		Если мЭтоТекстовыйЛитерал И ВыбраннаяСтруктураТипа.ТипЯзыка <> "ИмяТипа" Тогда
			ЛиНаборЗначенийПолный = Истина;
			мРекурсивныйПуть = Неопределено;
			СтараяТекущаяПозиция = мПозицияВТексте;
			СтарыйМетод = мМетодМодуля;
			КоллекцияЭлементовМД = ЗаполнитьТаблицуВозможныхЗначенийЛитерала(ВыбраннаяСтруктураТипа, ЛиНаборЗначенийПолный,, ДобавлятьНизкоВероятные, ФильтроватьСлово);
			ПерезагрузитьКонтекстЕслиПозицияИзменилась(СтараяТекущаяПозиция, СтарыйМетод); // 10мс // TODO для неизмененной позиции и метода платформы - убрать лишние действия
			Если Истина
				И Не ЛиНаборЗначенийПолный
				И (Ложь
					Или КоллекцияЭлементовМД.Количество() > 0 
					Или мТаблицаСловЛитерала <> Неопределено)
			Тогда
				Если мПлатформа.мРежимПроверкиМодуля Тогда 
					КоллекцияЭлементовМД = Новый Массив;
					мТаблицаСловЛитерала = Неопределено;
				Иначе 
					ЛиНаборЗначенийПолный = Истина; // Возможно вместо этого лучше поднять приоритет найденным словам
				КонецЕсли;
			КонецЕсли;
			мСтруктураТипаКонтекста.ТипЯзыка = ВыбраннаяСтруктураТипа.ТипЯзыка;
			Если мЭтоТекстовыйЛитерал Тогда // Может измениться в ЗаполнитьТаблицуВозможныхЗначенийЛитерала()
				мСтруктураТипаКонтекста.ИмяОбщегоТипа = "Строка";
			КонецЕсли;
		ИначеЕсли Истина
			И мЭтоТекстовыйЛитерал 
			И ВыбраннаяСтруктураТипа.ТипЯзыка = "ИмяТипа" 
			И мИмяМетодаВызова = "Тип"
		Тогда 
			// TODO Перенести в ЗаполнитьТаблицуВозможныхЗначенийЛитерала
			ЛиНаборЗначенийПолный = Истина;
			ПолеТекстаПрограммыВызова = КопияКомпоненты();
			#Если Сервер И Не Сервер Тогда
				ПолеТекстаПрограммыВызова = Обработки.ирКлсПолеТекстаПрограммы.Создать();
			#КонецЕсли
			ПолеТекстаПрограммыВызова.РазобратьТекущийКонтекст(,, Истина, мНачальнаяСтрока, мНачальнаяКолонка - СтрДлина(мВызовМетода + мНачалоСлова), Истина);
			МассивИменТипов = Новый Массив;
			ИмяМетода = ПолеТекстаПрограммыВызова.мИмяМетодаВызова;
			Если Истина
				И ЛиИмяМетодаВозвращающегоЗначениеТипаИзПараметра(ИмяМетода) 
				//И ПолеТекстаПрограммыВызова.мНомерПараметра = 1 // 1 не подходит для Форма.Элементы
			Тогда 
				ТаблицаТипов = ПолеТекстаПрограммыВызова.ВычислитьТипЗначенияВыражения(ПолеТекстаПрограммыВызова.мВызовМетода, ПолеТекстаПрограммыВызова.мТекстДляПоискаОпределения);
				Если ТаблицаТипов.Количество() > 1 Тогда
					Для Каждого СтруктураТипаЭлемента Из ТаблицаТипов Цикл
						МассивИменТипов.Добавить(СтруктураТипаЭлемента.ИмяОбщегоТипа);
					КонецЦикла; 
				КонецЕсли;
			ИначеЕсли Истина
				И ПолеТекстаПрограммыВызова.мИмяМетодаВызова = "УстановитьЭлементУправления" 
			Тогда 
				МассивИменТипов.Добавить("ПолеВвода");
				МассивИменТипов.Добавить("ПолеВыбора");
				МассивИменТипов.Добавить("Флажок");
			ИначеЕсли Истина
				И ПолеТекстаПрограммыВызова.мИмяМетодаВызова = "Выполнить" // КомпоновщикМакетаКомпоновкиДанных.Выполнить()
				И ПолеТекстаПрограммыВызова.мНомерПараметра = 5
			Тогда 
				ТаблицаТипов = ПолеТекстаПрограммыВызова.ВычислитьТипЗначенияВыражения(ПолеТекстаПрограммыВызова.мВызовМетода, ПолеТекстаПрограммыВызова.мТекстДляПоискаОпределения);
				Если Истина
					И ТаблицаТипов.Количество() > 0
					И ТипЗнч(ТаблицаТипов[0].СтрокаОписания) = Тип("СтрокаТаблицыЗначений") 
					И ТаблицаТипов[0].СтрокаОписания.Владелец().Колонки.Найти("ТипКонтекста") <> Неопределено
					И ТаблицаТипов[0].СтрокаОписания.ТипКонтекста = "КомпоновщикМакетаКомпоновкиДанных" 
				Тогда
					МассивИменТипов = Новый Массив;
					МассивИменТипов.Добавить("ГенераторМакетаКомпоновкиДанных");
					МассивИменТипов.Добавить("ГенераторМакетаКомпоновкиДанныхДляКоллекцииЗначений");
				КонецЕсли;
			КонецЕсли; 
			Для Каждого ИмяТипа Из МассивИменТипов Цикл
				СтрокаСлова = ТаблицаСлов.Добавить();
				СтрокаСлова.Слово = ИмяТипа;
				СтрокаСлова.ТипСлова = "Свойство";
				СтрокаСлова.Определение = "Предопределенный";
			КонецЦикла;
			Если ТаблицаСлов.Количество() = 0 Тогда
				ЗаполнитьЗначенияСвойств(мСтруктураТипаКонтекста, ВыбраннаяСтруктураТипа);
			Иначе
				мСтруктураТипаКонтекста.ИмяОбщегоТипа = "Строка";
				мСтруктураТипаКонтекста.ТипЯзыка = "ИмяТипа";
				ВыбраннаяСтруктураТипа.ТипЯзыка = "ИмяТипа";
			КонецЕсли; 
		Иначе
			ЛиНаборЗначенийПолный = ВыбраннаяСтруктураТипа.ТипЯзыка = "ИмяТипа";
			Если Истина
				И мЯзыкПрограммы = 1 
				И (Ложь
					Или мЭтоЛокальныйКонтекстТаблицыСлов
					Или ВыбраннаяСтруктураТипа.ИмяОбщегоТипа = "")
			Тогда 
				Если Истина
					И ВыбраннаяСтруктураТипа.ТипЯзыка = "ИмяТипа"
					И Не мТолькоСсылочныеИменаТипов
				Тогда
					ИменаФиксированныхТипов = Новый Массив;
					ИменаФиксированныхТипов.Добавить("БУЛЕВО");
					ИменаФиксированныхТипов.Добавить("ДАТА");
					ИменаФиксированныхТипов.Добавить("СТРОКА");
					ИменаФиксированныхТипов.Добавить("ЧИСЛО");
					Для Каждого ЭлементКоллекцииМД Из ИменаФиксированныхТипов Цикл
						СтрокаСлова = ТаблицаСлов.Добавить();
						СтрокаСлова.Слово = ЭлементКоллекцииМД;
						СтрокаСлова.ТипСлова = "Свойство";
						СтрокаСлова.Определение = "Предопределенный";
						СтрокаСлова.ТипЗначения = "Тип";
						СтрокаСлова.ТипЗначенияИндекс = СтрокаСлова.ТипЗначения;
					КонецЦикла;
				КонецЕсли; 
				Если ВыбраннаяСтруктураТипа.ТипЯзыка = "" Тогда
					Для Каждого ОписаниеТаблицы Из ДоступныеТаблицы.НайтиСтроки(Новый Структура("Тип, Схема", "ДоступнаяВременнаяТаблица", "")) Цикл
						СтрокаСлова = ТаблицаСлов.Добавить();
						СтрокаСлова.Слово = ОписаниеТаблицы.Имя;
						СтрокаСлова.ТипСлова = "Свойство";
						СтрокаСлова.Определение = "Локальный";
						СтрокаСлова.ТипЗначения = ОписаниеТаблицы.Тип;
						СтрокаСлова.ТипЗначенияИндекс = мПлатформа.ТипЗначенияИндексИзТипа(СтрокаСлова.ТипЗначения);
					КонецЦикла;
					СтрокаСлова = ТаблицаСлов.Добавить();
					СтрокаСлова.Слово = СокрП(мМаркерПорядкаОтладки);
					СтрокаСлова.ТипСлова = "Конструкция";
				КонецЕсли;
			КонецЕсли; 
			ЗаполнитьЗначенияСвойств(мСтруктураТипаКонтекста, ВыбраннаяСтруктураТипа);
		КонецЕсли; 
		ДобавитьВТаблицуСловИменаМодуляИМетаданныхИТипов(ВыбраннаяСтруктураТипа, ЛиНаборЗначенийПолный, ДобавлятьНизкоВероятные);
		Если Истина
			И мТаблицаСловЛитерала <> Неопределено 
			И мТаблицаСловЛитерала.Колонки.Слово.Заголовок = ""
		Тогда
			ДобавитьПростыеСловаВТаблицу(мТаблицаСловЛитерала);
		КонецЕсли;
		ДобавитьПростыеСловаВТаблицу(КоллекцияЭлементовМД);
		Если Истина
			И Не ЭтоГруппаОбщихМодулей 
			И (Ложь
				Или РазрешитьОткрытиеОкон
				Или мЭтоТекстовыйЛитерал 
				Или ЛиВнутриКомментария
				Или мЭтоЛокальныйКонтекстТаблицыСлов)
		Тогда
			мТаблицаТиповКонтекста = ирОбщий.ЗначенияВМассивЛкс(мСтруктураТипаКонтекста);
		ИначеЕсли мТаблицаТиповКонтекста.Количество() > мПлатформа.МаксРазмерТаблицыТиповДляЗаполненияТаблицыСлов() Тогда 
			// Для ускорения. Если не урезать, то надо делать аналогично обобщенному типу ОбъектМетаданных: ИмяОбщегоТипаРодителяБезДеталей = "ОбъектМетаданных"
			Если мТаблицаТиповКонтекста[0].ИмяОбщегоТипа = "Диаграмма" Тогда
				мСтруктураТипаКонтекста = мПлатформа.НоваяСтруктураТипа("ТабличноеПоле");
			ИначеЕсли мТаблицаТиповКонтекста[0].ИмяОбщегоТипа = "АтрибутDOM" Тогда
				мСтруктураТипаКонтекста = мПлатформа.НоваяСтруктураТипа("ЭлементDOM"); 
			Иначе
				мСтруктураТипаКонтекста = мТаблицаТиповКонтекста[0];
			КонецЕсли;
			мТаблицаТиповКонтекста = ирОбщий.ЗначенияВМассивЛкс(мСтруктураТипаКонтекста);
		Иначе
			ПодготовитьТаблицуТиповКЗаполнениюТаблицыСлов(мТаблицаТиповКонтекста);
		КонецЕсли;
		ЛиВнутриВыражения = ЛиВнутриВыражения(мСтруктураТипаКонтекста, ЛиВнутриКомментария);
		ДобавлятьЛокальныйКонтекст = Истина
			И мЭтоЛокальныйКонтекстТаблицыСлов
			И (Ложь
				Или Не мЭтоТекстовыйЛитерал
				Или мСтруктураТипаКонтекста.ТипЯзыка <> "" 
				Или РазрешитьОткрытиеОкон);
		БазовоеРасширениеКонфигурации = БазовоеРасширениеКонфигурации();
		// Сделать единый разбор см. РассчитатьОжидаемыйТипВыражения
		ПараметрыЗаполнения = мПлатформа.НовыеПараметрыЗаполненияСлов(, БазовоеРасширениеКонфигурации, мЯзыкПрограммы, Конфигурация, ВнешниеФункцииКомпоновкиДанных, ВычислятьТипы,
			ЭтоГруппаОбщихМодулей,, ФильтроватьСлово,,,, ДобавлятьЛокальныйКонтекст, мНаборыСлов,,, ЛиВнутриВыражения, ЗапретГлобальногоКонтекста);
		Попытка
			Для Каждого СтруктураКонтекста Из мТаблицаТиповКонтекста Цикл
				ПараметрыЗаполнения.ФлагиКомпиляции = ?(мЭтоТекстовыйЛитерал И СтруктураКонтекста.ТипЯзыка <> "ИмяТипа", Неопределено, мФлагиКомпиляции);
				ПараметрыЗаполнения.МодульМетаданных = МодульМетаданныхКонтекста(СтруктураКонтекста);
				ВыгрузкаТаблицыСлов = мПлатформа.ТаблицаСловИзСтруктурыТипа(СтруктураКонтекста, ПараметрыЗаполнения);
				ПараметрыЗаполнения.ТаблицаСлов = ВыгрузкаТаблицыСлов; 
			КонецЦикла;
			ЗаполнитьТипыЗначенийСлов(ВыгрузкаТаблицыСлов, ВычислятьТипы);
			Если Ложь
				Или мЭтоЛокальныйКонтекстТаблицыСлов
				Или мСтруктураТипаКонтекста.ИмяОбщегоТипа = "ВнешнийИсточникДанных.<Имя внешнего источника>.ВременнаяТаблица"
			Тогда
				Если Ложь
					Или ЯзыкПрограммы <> 0 И мЭтоЛокальныйКонтекстТаблицыСлов
				Тогда
					Для Каждого СтрокаСлова Из ТаблицаЛокальногоКонтекста("Свойство") Цикл
						НоваяСтрока = мПлатформа.ДобавитьВТаблицуСлов(ВыгрузкаТаблицыСлов, СтрокаСлова.Имя, "Свойство",,,,,, УстановитьНСлово); 
						Если Не ЗначениеЗаполнено(НоваяСтрока.Определение) Тогда
							НоваяСтрока.Определение = "Локальный";
						КонецЕсли;
						//Если ЗаполнятьТипы Тогда // Если откладывать вычисление типа, то потом через метод УточнитьТипЗначенияВСтрокеТаблицыСлов он не вычислится
							НоваяСтрока.ТипЗначения = мПлатформа.ПредставлениеМассиваСтруктурТипов(СтрокаСлова.ТаблицаТипов);
							НоваяСтрока.ТипЗначенияИндекс = мПлатформа.ТипЗначенияИндексИзТипа(НоваяСтрока.ТипЗначения);
						//КонецЕсли; 
					КонецЦикла;
				КонецЕсли;
				ирОбщий.ДобавитьИндексВТаблицуЛкс(ВыгрузкаТаблицыСлов, "Слово, ТипСлова");
				Если мСтруктураТипаКонтекста.ИмяОбщегоТипа = "ВнешнийИсточникДанных.<Имя внешнего источника>.ВременнаяТаблица" Тогда
					Для Каждого СтрокаВременнойТаблицы Из ДоступныеТаблицы.НайтиСтроки(Новый Структура("Тип", "ВременнаяТаблица")) Цикл
						мПлатформа.ДобавитьВТаблицуСлов(ВыгрузкаТаблицыСлов, СтрокаВременнойТаблицы.Имя, "Свойство",, "ДоступнаяВременнаяТаблица", "Локальный",,, УстановитьНСлово);
					КонецЦикла;
				КонецЕсли;
			КонецЕсли;
			Если Истина
				И мЭтоЛокальныйКонтекстТаблицыСлов
				И мЯзыкПрограммы = 1
				И мПакетЗапросов <> Неопределено
			Тогда
				Для Каждого КлючИЗначение Из мПакетЗапросов.Параметры Цикл 
					ТипЗначения = СтрЗаменить(ПредставлениеМассиваСтруктурТипов(КлючИЗначение.Значение), "Ссылка.", ".");
					мПлатформа.ДобавитьВТаблицуСлов(ВыгрузкаТаблицыСлов, мПараметрыДиалектаSQL.ПрефиксПараметра + КлючИЗначение.Ключ, "Свойство", КлючИЗначение.Значение, ТипЗначения, "Локальный",,, УстановитьНСлово);
				КонецЦикла;
				ПодготовитьПакетЗапросов(мПакетЗапросов);
				Для Каждого ЭлементСписка Из мПакетЗапросов.Структура Цикл 
					Если ЗначениеЗаполнено(ЭлементСписка.Представление) Тогда
						мПлатформа.ДобавитьВТаблицуСлов(ВыгрузкаТаблицыСлов, ЭлементСписка.Представление, "Свойство",, "ДоступнаяВременнаяТаблица", "Локальный", Ложь,, УстановитьНСлово);
					КонецЕсли;
				КонецЦикла;
			КонецЕсли;  
			ирОбщий.ЗагрузитьВТаблицуЗначенийЛкс(ВыгрузкаТаблицыСлов, ТаблицаСлов);
			
			Если Истина
				//И мЭтоТекстовыйЛитерал // в параметре метода ОтобратьКоллекциюЛкс будет ложь
				И мЯзыкПрограммы = 0
				И мЭтоЛокальныйКонтекстТаблицыСлов
				И мПлатформа.ИмяДинамическогоМодуля() = мМодульМетаданных.Имя
				И мСтруктураТипаКонтекста.ТипЯзыка = ""
			Тогда
				Для Каждого СтрокаСлова Из ТаблицаЛокальногоКонтекста() Цикл
					УстановитьРейтингСлову(СтрокаСлова.Имя, 2, "Свойство");
				КонецЦикла;
			КонецЕсли;
			Если Истина
				И мСтруктураТипаКонтекста.ИмяОбщегоТипа = "МенеджерВременныхТаблиц" 
				И мСтруктураТипаКонтекста.ТипЯзыка = "" 
			Тогда 
				мПлатформа.ДобавитьВТаблицуСлов(ТаблицаСлов, "докДобавить", "Метод",, Неопределено, "Локальный",,, УстановитьНСлово);
			КонецЕсли;
			Если Истина
				И мЯзыкПрограммы = 0
				И мЭтоЛокальныйКонтекстТаблицыСлов
				И Не мЭтоТекстовыйЛитерал
				И мМетодМодуля <> Неопределено
			Тогда 
				ПараметрыМетодаМодуля = мПлатформа.ПараметрыМетодаМодуля(мМетодМодуля);
				Если ПараметрыМетодаМодуля <> Неопределено Тогда
					Для Каждого СтрокаПараметра Из ПараметрыМетодаМодуля Цикл 
						ТипЗначения = ПредставлениеМассиваСтруктурТипов(СтрокаПараметра.ТаблицаТипов);
						Если Не ЗначениеЗаполнено(ТипЗначения) Тогда
							ТипЗначения = СтрокаПараметра.ТипЗначения;
						КонецЕсли;
						ТипЗначения = ?(ПустаяСтрока(ТипЗначения), "??", ТипЗначения);
						СтрокаСлова = мПлатформа.ДобавитьВТаблицуСлов(ТаблицаСлов, СтрокаПараметра.Имя, "Свойство",, ТипЗначения, "Локальный",, мМетодМодуля.СтарыеТипы, УстановитьНСлово); 
						СтрокаСлова.Рейтинг = ШагРейтингаСлова;
					КонецЦикла;
				КонецЕсли;
			КонецЕсли; 
		Исключение
			Ошибка = ИнформацияОбОшибке();
			Если Ошибка.Описание = "ОшибкаВычисленияВиртуальнойТаблицы" Тогда 
				Возврат Ложь;
			КонецЕсли;
			ВызватьИсключение;
		КонецПопытки;
		СтруктураКлюча = Новый Структура("ТипКонтекста, ЯзыкПрограммы, ТипЯзыка",
			мСтруктураТипаКонтекста.ИмяОбщегоТипа, мЯзыкПрограммы, мСтруктураТипаКонтекста.ТипЯзыка);
		ДобавлятьСтатистическиеСлова = Ложь
			Или ЗначениеЗаполнено(мРодительскийКонтекст)
			//Или мСтруктураТипаКонтекста.ИмяОбщегоТипа = "НеизвестныйКонтекст" // Дает мусор при спуске через ЗаполнитьТаблицуВозможныхЗначенийЛитерала
			Или ЛиВЗаголовкеМетода
			Или ДобавлятьЛокальныйКонтекст
			Или мПлатформа.ТаблицаШаблоновКонтекстов.НайтиСтроки(СтруктураКлюча).Количество() > 0;
	КонецЕсли;
	ЗаполнитьСловаВНижнемРегистре();
	УстановитьНСлово = Истина;
	Если РазрешитьОткрытиеОкон Или ВычислятьТипы Или ДобавлятьСтатистическиеСлова Тогда
		Если ДобавлятьСтатистическиеСлова Тогда
			ВключатьКонструкции = Истина
				И Не ЗапретГлобальногоКонтекста
				И Не мЭтоТекстовыйЛитерал 
				И Не ЗначениеЗаполнено(мРодительскийКонтекст) 
				И мЯзыкПрограммы = 0
				И Не ЛиВЗаголовкеМетода;
			ЗаполнитьЛокальныеСвойстваИМетодыПоТексту(Ложь, ВключатьКонструкции, Истина, Ложь,,,,, ЛиВЗаголовкеМетода);
			//Если Истина
			//	И _УдалитьФункциюНовый // https://www.hostedredmine.com/issues/963017
			//	И мЭтоЛокальныйКонтекст
			//Тогда
			//	СтрокаСловаНовый = ТаблицаСлов.НайтиСтроки(Новый Структура("Слово, ТипСлова", "Новый", "Метод"));
			//	Если СтрокаСловаНовый.Количество() > 0 Тогда
			//		ТаблицаСлов.Удалить(СтрокаСловаНовый[0]);
			//	КонецЕсли;
			//КонецЕсли;
		КонецЕсли;
		Если Ложь
			Или мЯзыкПрограммы <> 0 
			Или ЗначениеЗаполнено(мРодительскийКонтекст)
		Тогда
			Если Прав(мТекущееСлово, 1) = "(" Тогда 
				ЧистоеТекущееСлово = Лев(мТекущееСлово, СтрДлина(мТекущееСлово) - 1);
				ТипТекущегоСлова = "Метод";
			Иначе
				ЧистоеТекущееСлово = мТекущееСлово;
				ТипТекущегоСлова = "Свойство";
			КонецЕсли;
			КлючПоиска = Новый Структура("НСлово, Определение, ТипСлова", НРег(ЧистоеТекущееСлово), "Статистический", ТипТекущегоСлова);
			НайденныеСтроки = ТаблицаСлов.НайтиСтроки(КлючПоиска);
			Если НайденныеСтроки.Количество() > 0 Тогда
				НайденнаяСтрока = НайденныеСтроки[0];
				НайденнаяСтрока.Частота = НайденнаяСтрока.Частота - 1;
				Если НайденнаяСтрока.Частота = 0 Тогда
					ТаблицаСлов.Удалить(НайденнаяСтрока);
				КонецЕсли;
			КонецЕсли;
		КонецЕсли;
		//ТаблицаСлов.Свернуть("НСлово, Слово, ТипСлова, Определение, ТипЗначения", "Частота"); // Очищает рейтинги локальных и статистических слов
	КонецЕсли;
	Если ПрименитьОжидаемыйТип <> Ложь Тогда
		ПрименитьОжидаемыйТипВТаблицеСлов(ЛиВнутриВыражения, ОтделятьБольшиеНаборыСлов); 
		Если мЯзыкПрограммы = 1 И мЭтоЛокальныйКонтекстТаблицыСлов И Не мЭтоОбъявлениеПсевдонима Тогда
			мПлатформа.ДобавитьВТаблицуСлов(ТаблицаСлов, "ЕСТЬ NULL", "Конструкция",,,,,, УстановитьНСлово);
			мПлатформа.ДобавитьВТаблицуСлов(ТаблицаСлов, "ЛЕВОЕ СОЕДИНЕНИЕ", "Конструкция",,,,,, УстановитьНСлово);
			мПлатформа.ДобавитьВТаблицуСлов(ТаблицаСлов, "ПРАВОЕ СОЕДИНЕНИЕ", "Конструкция",,,,,, УстановитьНСлово);
			мПлатформа.ДобавитьВТаблицуСлов(ТаблицаСлов, "ВНУТРЕННЕЕ СОЕДИНЕНИЕ", "Конструкция",,,,,, УстановитьНСлово);
			мПлатформа.ДобавитьВТаблицуСлов(ТаблицаСлов, "ВНЕШНЕЕ СОЕДИНЕНИЕ", "Конструкция",,,,,, УстановитьНСлово);
			мПлатформа.ДобавитьВТаблицуСлов(ТаблицаСлов, "СГРУППИРОВАТЬ ПО", "Конструкция",,,,,, УстановитьНСлово);
			мПлатформа.ДобавитьВТаблицуСлов(ТаблицаСлов, "УПОРЯДОЧИТЬ ПО", "Конструкция",,,,,, УстановитьНСлово);
			мПлатформа.ДобавитьВТаблицуСлов(ТаблицаСлов, "ОБЪЕДИНИТЬ ВСЕ", "Конструкция",,,,,, УстановитьНСлово);
		КонецЕсли; 
		Если ВключатьКонструкции = Истина Тогда
			УстановитьРейтингСлову("Новый",, "Конструкция");
		КонецЕсли;
		Если Истина
			И мЯзыкПрограммы = 0
			И ирОбщий.СтрокиРавныЛкс(мВызовМетода, "ТипЗнч(") 
		Тогда
			СтрокиСвойств = ТаблицаСлов.НайтиСтроки(Новый Структура("ТипСлова", "Свойство"));
			Если СтрокиСвойств.Количество() < 200 Тогда
				Для Каждого СтрокаСлова Из СтрокиСвойств Цикл
					ЧистыйТипЗначения = СтрЗаменить(СтрокаСлова.ТипЗначения, "??,", "");
					ЧистыйТипЗначения = СтрЗаменить(ЧистыйТипЗначения, ", Неопределено", "");
					Если Найти(ЧистыйТипЗначения, ",") > 0 Тогда
						УстановитьРейтингВСтрокеСлова(СтрокаСлова, 1, Ложь);
					КонецЕсли;
				КонецЦикла;
			КонецЕсли;
		КонецЕсли;
		ТекущаяСтрокаКонец = СокрЛП(мТекущаяСтрокаКонец);
		Если Лев(ТекущаяСтрокаКонец, 1) = "=" Тогда
			ТекущаяСтрокаКонец = Сред(ТекущаяСтрокаКонец, 2);
		КонецЕсли;
		Если Истина
			И ПустаяСтрока(мТекущаяСтрокаНачало)
			И СтрДлина(ТекущаяСтрокаКонец) > 10
			И Прав(ТекущаяСтрокаКонец, 1) = ";"
			И Найти(ТекущаяСтрокаКонец, "=") = 0
		Тогда
			ВариантыИмениПеременной = Новый Массив;
			ТаблицаТипов = ВычислитьТипЗначенияВыражения(ТекущаяСтрокаКонец, мТекстДляПоискаОпределения,,,,,,,,,,,, ИмяФиктивногоСвойства());
			Если ТаблицаТипов.Количество() > 0 Тогда
				ИмяТипаВыражения = ДобавитьВариантыИмениНовойПеременнойИзТипа(ВариантыИмениПеременной, ТаблицаТипов); 
				Если ПустаяСтрока(ИмяТипаВыражения) Тогда
					// Это вызов процедуры
					ВариантыИмениПеременной = Неопределено;
				КонецЕсли;
			КонецЕсли;
			Если ВариантыИмениПеременной <> Неопределено Тогда
				ВхожденияИмен = ирОбщий.НайтиРегВыражениеЛкс(ТекущаяСтрокаКонец, шИмяСТочками,,,,,, Истина);
				Для Каждого ВхождениеИмени Из ВхожденияИмен Цикл
					ТекстВхождения = ВхождениеИмени.ТекстВхождения;
					ПоследнееИмя = ирОбщий.ПоследнийФрагментЛкс(ТекстВхождения);
					ДобавитьВариантыИмениНовойПеременнойИзСлова(ВариантыИмениПеременной, ПоследнееИмя, ПоследнееИмя <> ТекстВхождения);
				КонецЦикла;
				Для Каждого Имя Из ВариантыИмениПеременной Цикл
					СтрокаСлова = мПлатформа.ДобавитьВТаблицуСлов(ТаблицаСлов, Имя + " =", "Конструкция",,,,,, УстановитьНСлово);
					СтрокаСлова.Рейтинг = 3 * ШагРейтингаСлова;
				КонецЦикла;
			КонецЕсли;
		КонецЕсли;
		Если Истина
			И мЯзыкПрограммы = 0 
			И ЛиВнутриКомментария 
			И мМетодМодуля <> Неопределено 
			И мПозицияВТексте < мМетодМодуля.ПозицияОпределения
			И мЭтоЛокальныйКонтекстТаблицыСлов
		Тогда
			Заголовки = Новый Массив;
			Если ПараметрыМетодаМодуля <> Неопределено Тогда
				Заголовки.Добавить("Параметры:");
			КонецЕсли;
			Если мМетодМодуля.ТипЗначения <> Неопределено Тогда
				Заголовки.Добавить(мПлатформа.ЗаголовокРазделаВозвращаемоеЗначение());
			КонецЕсли;
			Если мМетодМодуля.ЛиЭкспорт Тогда
				Заголовки.Добавить(мПлатформа.ЗаголовокРазделаВызывающиеМодули());
			КонецЕсли;
			Если Заголовки.Количество() > 0 Тогда
				ТекстОписанияМетода = НРег(ТекстОписанияМетода(мМетодМодуля));
				НачалоСтрокиВнутри = НРег(СокрЛ(ирОбщий.СтрокаБезПервогоФрагментаЛкс(мТекущаяСтрокаНачало, "//")));
				Для Каждого Заголовок Из Заголовки Цикл
					ЗаголовокНрег = НРег(Заголовок);
					Если Найти(ТекстОписанияМетода, ЗаголовокНрег) = 0 Тогда
						СтрокаСлова = мПлатформа.ДобавитьВТаблицуСлов(ТаблицаСлов, Заголовок, "Конструкция",,,,,, УстановитьНСлово);
						Если Найти(НачалоСтрокиВнутри, " ") = 0 Тогда
							СтрокаСлова.Рейтинг = ШагРейтингаСлова;
						КонецЕсли;
					КонецЕсли;
				КонецЦикла;
			КонецЕсли;
		КонецЕсли;
		Если Истина
			И Не ЛиВнутриКомментария 
			И Не мЭтоТекстовыйЛитерал
			И мЭтоЛокальныйКонтекстТаблицыСлов
			И ЛиВнутриВыражения
		Тогда
			СтрокаСлова = мПлатформа.ДобавитьВТаблицуСлов(ТаблицаСлов, "Истина И", "Конструкция",,,,,, УстановитьНСлово);
			СтрокаСлова = мПлатформа.ДобавитьВТаблицуСлов(ТаблицаСлов, "Ложь Или", "Конструкция",,,,,, УстановитьНСлово);
		КонецЕсли;
		Если Истина
			И Не ЛиВнутриКомментария 
			И Не мЭтоТекстовыйЛитерал
			И мЭтоЛокальныйКонтекстТаблицыСлов
			И Не ЛиВнутриВыражения
		Тогда
			Если мЯзыкПрограммы = 0 Тогда
				Если Не ОтделятьБольшиеНаборыСлов Тогда
					СтрокаСлова = мПлатформа.ДобавитьВТаблицуСлов(ТаблицаСлов, "Если Тогда", "Конструкция",,,,,, УстановитьНСлово);
					СтрокаСлова = мПлатформа.ДобавитьВТаблицуСлов(ТаблицаСлов, "Пока Цикл", "Конструкция",,,,,, УстановитьНСлово);
					СтрокаСлова = мПлатформа.ДобавитьВТаблицуСлов(ТаблицаСлов, "Для Каждого", "Конструкция",,,,,, УстановитьНСлово);
					СтрокаСлова = мПлатформа.ДобавитьВТаблицуСлов(ТаблицаСлов, "Попытка Исключение", "Конструкция",,,,,, УстановитьНСлово);
					СтрокаСлова = мПлатформа.ДобавитьВТаблицуСлов(ТаблицаСлов, "Функция КонецФункции", "Конструкция",,,,,, УстановитьНСлово);
					СтрокаСлова = мПлатформа.ДобавитьВТаблицуСлов(ТаблицаСлов, "Процедура КонецПроцедуры", "Конструкция",,,,,, УстановитьНСлово);
				КонецЕсли;
				СтрокаСлова = мПлатформа.ДобавитьВТаблицуСлов(ТаблицаСлов, "Для По", "Конструкция",,,,,, УстановитьНСлово);
				СтрокаСлова = мПлатформа.ДобавитьВТаблицуСлов(ТаблицаСлов, "НачатьТранзакцию Попытка", "Конструкция",,,,,, УстановитьНСлово);
			ИначеЕсли мЯзыкПрограммы = 1 Тогда
				СтрокаСлова = мПлатформа.ДобавитьВТаблицуСлов(ТаблицаСлов, "ВЫБОР КОГДА", "Конструкция",,,,,, УстановитьНСлово);
			КонецЕсли;
		КонецЕсли;
		Если Истина                                                    
			И ПустаяСтрока(мРодительскийКонтекст)
			И ВыбраннаяСтруктураТипа.Конструктор
			И ВыбраннаяСтруктураТипа.ТипЯзыка = "ИмяТипа"
		Тогда
			ЧастыеТипы = Новый Массив;
			ЧастыеТипы.Добавить("Массив");
			ЧастыеТипы.Добавить("Структура");
			ЧастыеТипы.Добавить("Соответствие");
			//ЧастыеТипы.Добавить("СписокЗначений"); // нет смысла, т.к. он уже первый после "сп"
			Для Каждого ИмяТипа Из ЧастыеТипы Цикл
				УстановитьРейтингСлову(ИмяТипа,, "Свойство",, Истина);
			КонецЦикла;
		КонецЕсли;
		Если Истина                                                    
			И мЭтоЛокальныйКонтекстТаблицыСлов
			И мЯзыкПрограммы = 0
			И ДобавлятьСтатистическиеСлова
		Тогда
			УстановитьРейтингСлову("Строка", -1, "Метод", "Строка"); // Подавляем обычно бесполезную функцию, но при этом стоящую выше многих полезных переменных, имеющих то же начало
			УстановитьРейтингСлову("Знач", -1, "Конструкция");
			УстановитьРейтингСлову("ТипЗнч",, "Метод", "Тип");
			мПлатформа.ДобавитьВТаблицуСлов(ТаблицаСлов, "Дата(1,1,1)", "Конструкция",,,,,, УстановитьНСлово);
		КонецЕсли;
		ТипКонтекстаСтатистики = ТипКонтекстаСтатистики();
		Если Истина
			И ТипКонтекстаСтатистики <> Неопределено 
			И (Ложь
				Или ТаблицаСлов.Количество()
				Или ЗначениеЗаполнено(мНаборыСлов))
		Тогда 
			Если ТипКонтекстаСтатистики <> "Глобальный" Тогда
				ЗагрузитьСтатистикуВыбораВТаблицуСлов(ТипКонтекстаСтатистики);
			КонецЕсли;
			Если мЭтоЛокальныйКонтекстТаблицыСлов Тогда
				ЗагрузитьСтатистикуВыбораВТаблицуСлов("Глобальный");
			КонецЕсли;
		КонецЕсли;
	КонецЕсли;
	Если Истина
		И мЯзыкПрограммы = 0
		И Не мЭтоТекстовыйЛитерал
		И мЭтоЛокальныйКонтекстТаблицыСлов
		И ПустаяСтрока(мВызовМетода)
		И мМодульМетаданных <> Неопределено
		И мПлатформа.ЛиИмяМодуляФормы(мИмяМодуля)
		И (Ложь
			Или мМетодМодуля = Неопределено
			Или мПозицияВТексте < мМетодМодуля.ПозицияОпределения)
	Тогда
		ДирективыКомпиляцииТипаМодуля = Новый Массив;
		ДирективыКомпиляцииТипаМодуля.Добавить("НаСервере");
		ДирективыКомпиляцииТипаМодуля.Добавить("НаКлиенте");
		ДирективыКомпиляцииТипаМодуля.Добавить("НаКлиентеНаСервереБезКонтекста");
		ДирективыКомпиляцииТипаМодуля.Добавить("НаСервереБезКонтекста");
		Для Каждого Директива Из ДирективыКомпиляцииТипаМодуля Цикл
			мПлатформа.ДобавитьВТаблицуСлов(ТаблицаСлов, "&" + Директива, "Конструкция",, "", "Предопределенный",,, УстановитьНСлово);
		КонецЦикла;
	КонецЕсли;
	ТаблицаТиповКонтекста.Очистить(); // Нужно для прерывания циклического выбора слова автодополнения
	выхЕстьЛучшееСлово = мСтрокаЛучшегоСлова <> Неопределено;
	ЭтоВводЗначенияПоУмолчанию = Истина
		И ЛиВЗаголовкеМетода 
		//И ЗначениеЗаполнено(мНачалоСлова)
		И Не ЗначениеЗаполнено(мКонецКонтекста)
		И Прав(СокрП(ирОбщий.СтрокаБезКонцаЛкс(мТекущаяСтрокаНачало, СтрДлина(мНачалоСлова))), 1) = "=";
	ПредСимвол = Прав(ТекущаяСтрокаНачало, 1);
	СледСимвол = Лев(мТекущаяСтрокаКонец, 1);
	ЗапретАвтооткрытия = Ложь 
		Или (Истина
			// Дописываем спереди к свойству обращение к его родителю
			И Не ДобавлятьНизкоВероятные
			И ПредСимвол = "." 
			И ирОбщий.ЛиБукваЛкс(СледСимвол)
			И ТаблицаСлов.Найти(НРег(ирОбщий.ПервыйФрагментЛкс(мТекущееСлово, "(")), "НСлово") <> Неопределено) 
		Или (Истина 
			И Не ДобавлятьНизкоВероятные
			И Не выхЕстьЛучшееСлово 
			И Не ЭтоВводЗначенияПоУмолчанию
			И (Ложь
				Или ЛиВЗаголовкеМетода
				Или ЗначениеЗаполнено(мНаборыСлов)
				Или ТаблицаСлов.Количество() > 50)
			И (Ложь
				Или ЛиВЗаголовкеМетода
				Или ПредСимвол = "=" 
				Или ПредСимвол = "("
				Или ПредСимвол = ","
				Или ПредСимвол = ""
				Или ПредСимвол = " "    
				Или ПредСимвол = Символы.Таб
				Или (Истина
					И мРодительскийКонтекст = ""
					//И Прав(СокрП(ТекущаяСтрокаНачало), 1) = "."
					И ПредСимвол = "."
					)
				Или (Истина
					И мРодительскийКонтекст = ""
					И мЭтоТекстовыйЛитерал
					И (Ложь
						Или Не ЗначениеЗаполнено(мКонтекст)
						Или Не ирОбщий.СтрКончаетсяНаЛкс(ТекущаяСтрокаНачало, """" + мКонтекст)))));
	Возврат Не ЗапретАвтооткрытия; 
КонецФункции

Функция ЛиВнутриВыражения(Знач СтруктураТипаКонтекста, Знач ЛиВнутриКомментария = Неопределено) Экспорт
	Если ЛиВнутриКомментария = Неопределено Тогда
		ЛиВнутриКомментария = ЛиВнутриКомментария();
	КонецЕсли;
	ПредСимвол = Прав(СокрП(мПредшествующийТекст), 1);
	ЛиВнутриВыражения = Истина
		И мЯзыкПрограммы = 0
		И Не ЛиВнутриКомментария
		И Не мЭтоТекстовыйЛитерал
		И СтруктураТипаКонтекста.ТипЯзыка = ""
		И (Ложь
			Или ПредСимвол = "("
			Или ПредСимвол = ","
			Или ПредСимвол = "="
			Или ПредСимвол = "+"
			Или ПредСимвол = "-"
			Или ЗначениеЗаполнено(мНомерПараметра)
			Или ЗначениеЗаполнено(мКонтекст) И СокрЛ("" + мТекущаяСтрокаНачало) <> мНачалоКонтекста // грязно
			);
	Возврат ЛиВнутриВыражения;
КонецФункции

Функция ЛиИмяМетодаВозвращающегоЗначениеТипаИзПараметра(Знач ИмяМетода) Экспорт
	Возврат Ложь
		Или ИмяМетода = "Добавить"
		Или ИмяМетода = "Вставить"
		Или ИмяМетода = "НайтиОбъект"
		Или ИмяМетода = "ПолучитьОбъект";
КонецФункции

Функция ДобавитьВариантыИмениНовойПеременнойИзТипа(Знач ВариантыИмениПеременной, Знач ТаблицаТипов) Экспорт
	Если Не ЗначениеЗаполнено(ТаблицаТипов) Тогда 
		Возврат Неопределено;
	КонецЕсли;
	ИмяТипаЭлемента = мПлатформа.ИмяТипаИзСтруктурыТипа(ТаблицаТипов[0]);
	ДобавитьВариантыИмениНовойПеременнойИзСлова(ВариантыИмениПеременной, ирОбщий.ПервыйФрагментЛкс(ИмяТипаЭлемента));
	ОбъектМД = ТаблицаТипов[0].Метаданные; // ОбъектМетаданныхСправочник
	Если Истина
		И ТипЗнч(ОбъектМД) = Тип("ОбъектМетаданных")
		И ирОбщий.ЛиМетаданныеСсылочногоОбъектаЛкс(ОбъектМД,, Истина)
		И ЗначениеЗаполнено(ОбъектМД.ПредставлениеОбъекта)
	Тогда
		Слово = ирОбщий.ИдентификаторИзПредставленияЛкс(ОбъектМД.ПредставлениеОбъекта);
		КлючПоиска = Новый Структура;
		КлючПоиска.Вставить("НСлово", НРег(Слово));
		КлючПоиска.Вставить("ТипСлова", "Свойство");
		Если ТаблицаСлов.НайтиСтроки(КлючПоиска).Количество() = 0 Тогда
			ВариантыИмениПеременной.Добавить(Слово);
		КонецЕсли;
	КонецЕсли;
	Возврат ИмяТипаЭлемента;
КонецФункции

//.
// Параметры:
//   МассивПриемник - Массив - 
//   ИмяИзПрисвоенногоВыражения - Строка - 
Процедура ДобавитьВариантыИмениНовойПеременнойИзСлова(Знач МассивПриемник, Знач ИмяИзПрисвоенногоВыражения, Знач РазрешитьПолноеИмя = Истина, Знач Постфикс = "") Экспорт
	ИмяИзПрисвоенногоВыражения = ирОбщий.ПервыйФрагментЛкс(ИмяИзПрисвоенногоВыражения, "(");
	ИмяИзПрисвоенногоВыражения = ирОбщий.ПервыйФрагментЛкс(ИмяИзПрисвоенногоВыражения, "[");
	Фрагменты = ирОбщий.СтрРазделитьЛкс(ирОбщий.ПредставлениеИзИдентификатораЛкс(ИмяИзПрисвоенногоВыражения), " ");
	Если Ложь
		Или ирОбщий.СтрКончаетсяНаЛкс(Фрагменты[0], "ть")
		Или ирОбщий.СтрКончаетсяНаЛкс(Фрагменты[0], "ти")
	Тогда
		// Глагол
		Фрагменты.Удалить(0);
		Если Фрагменты.Количество() = 0 Тогда
			Возврат;
		КонецЕсли;
	КонецЕсли;
	Если Не РазрешитьПолноеИмя Тогда
		Фрагменты.Удалить(Фрагменты.ВГраница());
	КонецЕсли;
	Пока Фрагменты.Количество() > 0 Цикл
		Если Истина
			И Фрагменты.Количество() = 1
			И (Ложь
				Или Фрагменты[0] = "Булево"
				Или ирОбщий.СтрокиРавныЛкс(Фрагменты[0], "Новый") 
				Или Метаданные.ОбщиеМодули.Найти(Фрагменты[0]) <> Неопределено)
		Тогда
			Прервать;
		КонецЕсли;
		ВариантИмени = ирОбщий.ИдентификаторИзПредставленияЛкс(ирОбщий.СтрСоединитьЛкс(Фрагменты, " "),,,, Истина) + Постфикс;
		КлючПоиска = Новый Структура;
		КлючПоиска.Вставить("НСлово", НРег(ВариантИмени));
		КлючПоиска.Вставить("ТипСлова", "Свойство");
		Если ТаблицаСлов.НайтиСтроки(КлючПоиска).Количество() = 0 Тогда
			МассивПриемник.Добавить(ВариантИмени); 
		КонецЕсли;
		Фрагменты.Удалить(Фрагменты.ВГраница());
	КонецЦикла;
КонецПроцедуры

//.
// Параметры:
//   ТипКонтекстаСтатистики - Произвольный, Строка, Неопределено - 
Процедура ЗагрузитьСтатистикуВыбораВТаблицуСлов(Знач ТипКонтекстаСтатистики) Экспорт
	КлючПоискаСтатистики = Новый Структура("ЯзыкПрограммы, ТипКонтекста", ЯзыкПрограммы, ТипКонтекстаСтатистики);
	СтатистикаПоКонтексту = мПлатформа.ТаблицаСтатистикиВыбора.Скопировать(КлючПоискаСтатистики, "Слово, ЭтоМетод, Рейтинг");
	СуммаВсехСлов = СтатистикаПоКонтексту.Итог("Рейтинг");
	Если СуммаВсехСлов > 0 Тогда
		ВключатьАвтоОткрытие = Ложь
			Или ЗначениеЗаполнено(мРодительскийКонтекст)
			Или мСтруктураТипаКонтекста.ТипЯзыка = "ИмяТипа";
		ТаблицаСловТЗ = Неопределено;
		ОбщееЧислоСлов = ТаблицаСлов.Количество();
		Если ЗначениеЗаполнено(мНаборыСлов) Тогда
			Для Каждого КлючИЗначение Из мНаборыСлов Цикл
				ОбщееЧислоСлов = ОбщееЧислоСлов + КлючИЗначение.Значение.Количество();
			КонецЦикла;
		КонецЕсли; 
		ПремируемаяДоляСлова = Макс(0.05, Мин(0.5, 5/ОбщееЧислоСлов)); // Должна быть в 5 раз больше чем равномерная, но в пределах [0.05;0.5]
		ШагРейтингаСлова = ШагРейтингаСлова();
		Для Каждого СтрокаРейтинга Из СтатистикаПоКонтексту Цикл
			Если ПремируемаяДоляСлова > СтрокаРейтинга.Рейтинг / СуммаВсехСлов Тогда
				Продолжить;
			КонецЕсли;
			//Если ТаблицаСловТЗ = Неопределено Тогда
			//	ТаблицаСловТЗ = ТаблицаСлов.Выгрузить(, "НСлово, Рейтинг");
			//	ТаблицаСловТЗ.Индексы.Добавить("НСлово");
			//КонецЕсли;
			//СтрокаСлова = ТаблицаСловТЗ.Найти(НРег(СтрокаРейтинга.Слово), "НСлово");
			КлючПоискаСлова = Новый Структура("НСлово", НРег(СтрокаРейтинга.Слово));
			СловоНайдено = Ложь;
			Для Каждого СтрокаСлова Из ТаблицаСлов.НайтиСтроки(КлючПоискаСлова) Цикл
				Если Ложь
					Или СтрокаРейтинга.ЭтоМетод И СтрокаСлова.ТипСлова = "Метод" 
					Или Не СтрокаРейтинга.ЭтоМетод И СтрокаСлова.ТипСлова <> "Метод" 
				Тогда
					СтрокаСлова.Рейтинг = СтрокаСлова.Рейтинг + ШагРейтингаСлова;
					СловоНайдено = Истина;
					Прервать;
				КонецЕсли;
			КонецЦикла;
			Если Не СловоНайдено И ЗначениеЗаполнено(мНаборыСлов) Тогда
				КлючПоискаСлова = Новый Структура("Слово", СтрокаРейтинга.Слово);
				Для Каждого КлючИЗначение Из мНаборыСлов Цикл
					Для Каждого СтрокаСлова Из КлючИЗначение.Значение.НайтиСтроки(КлючПоискаСлова) Цикл
						Если Ложь
							Или СтрокаРейтинга.ЭтоМетод И СтрокаСлова.ТипСлова = "Метод" 
							Или Не СтрокаРейтинга.ЭтоМетод И СтрокаСлова.ТипСлова <> "Метод" 
						Тогда
							СтрокаСлова = УстановитьРейтингСлову(СтрокаСлова.Слово,, СтрокаСлова.ТипСлова, СтрокаСлова.ТипЗначения, ВключатьАвтоОткрытие);
							Перейти ~ВыходЦикловСлова;
						КонецЕсли;
					КонецЦикла;
				КонецЦикла;
				~ВыходЦикловСлова:
			КонецЕсли; 
		КонецЦикла;
		//Если ТаблицаСловТЗ <> Неопределено Тогда
		//	ТаблицаСлов.ЗагрузитьКолонку(ТаблицаСловТЗ.ВыгрузитьКолонку("Рейтинг"), "Рейтинг");
		//КонецЕсли;
	КонецЕсли;
КонецПроцедуры

Функция УстановитьРейтингСлову(Знач Слово, Знач МножительРейтинга = 1, Знач ТипСлова = "Свойство", Знач ТипЗначения = "", Знач ВключатьАвтоОткрытие = Ложь) Экспорт
	СтрокаСлова = ТаблицаСлов.НайтиСтроки(Новый Структура("НСлово, ТипСлова", НРег(Слово), ТипСлова));
	Если СтрокаСлова.Количество() Тогда
		СтрокаСлова = СтрокаСлова[0];
	Иначе
		СтрокаСлова = мПлатформа.ДобавитьВТаблицуСлов(ТаблицаСлов, Слово, ТипСлова,, ТипЗначения, "Предопределенный", Ложь,, Истина);
	КонецЕсли;
	УстановитьРейтингВСтрокеСлова(СтрокаСлова, МножительРейтинга, ВключатьАвтоОткрытие);
	Возврат СтрокаСлова;
КонецФункции

Процедура ПодготовитьТаблицуТиповКЗаполнениюТаблицыСлов(Знач ТаблицаТипов) Экспорт
	СтрокаТипаОбъектМетаданных = ТаблицаТипов.Найти("ТаблицаФормы", "ИмяОбщегоТипа");
	Если СтрокаТипаОбъектМетаданных <> Неопределено Тогда
		ТаблицаТипов.Сдвинуть(СтрокаТипаОбъектМетаданных, -ТаблицаТипов.Индекс(СтрокаТипаОбъектМетаданных));
	КонецЕсли;
	СтрокаТипаОбъектМетаданных = ТаблицаТипов.Найти("ОбъектМетаданных", "ИмяОбщегоТипа");
	Если СтрокаТипаОбъектМетаданных <> Неопределено Тогда
		ТаблицаТипов.Сдвинуть(СтрокаТипаОбъектМетаданных, -ТаблицаТипов.Индекс(СтрокаТипаОбъектМетаданных));
	КонецЕсли;
КонецПроцедуры

//.
// Параметры:
//    ВнутренняяТаблицаСлов - см. мПлатформа.НоваяТаблицаСлов - 
//    ПринудительноВсе - Булево - 
Процедура ЗаполнитьТипыЗначенийСлов(Знач ВнутренняяТаблицаСлов, Знач ПринудительноВсе = Ложь, Знач ЛиФинальныйРасчет = Ложь) Экспорт
	НаборыСлов = НаборыСлов();
	НаборыСлов.Добавить(ВнутренняяТаблицаСлов);
	Для Каждого НаборСлов Из НаборыСлов Цикл
		СловаДляУточненияТипа = НаборСлов.НайтиСтроки(Новый Структура("МожноУточнитьТип", Истина));
		Если ПринудительноВсе Или СловаДляУточненияТипа.Количество() < МаксЧислоСловДляЗаполненияТипов() Тогда
			Для Каждого ВнутренняяСтрокаСлова Из СловаДляУточненияТипа Цикл
				ОбновитьТипЗначенияИзТаблицыТипов(ВнутренняяСтрокаСлова,, Ложь, ЛиФинальныйРасчет);
			КонецЦикла;
		КонецЕсли;
	КонецЦикла;
КонецПроцедуры

Функция МаксЧислоСловДляЗаполненияТипов() Экспорт
	Возврат 100;
КонецФункции

//.
// Параметры:
//    ВыбраннаяСтруктураТипа - СтрокаТаблицыЗначений - 
//    ЛиНаборЗначенийПолный - Булево - 
//    ДобавлятьНизкоВероятные - Булево -  
Процедура ДобавитьВТаблицуСловИменаМодуляИМетаданныхИТипов(Знач ВыбраннаяСтруктураТипа, Знач ЛиНаборЗначенийПолный, Знач ДобавлятьНизкоВероятные = Ложь) Экспорт
	КоллекцияЭлементовМД = Новый Массив; 
	Если ЗначениеЗаполнено(мРодительскийКонтекст) Тогда
		ПервоеСловоРодителя = ирОбщий.ПервыйФрагментЛкс(мРодительскийКонтекст);
	КонецЕсли;
	ЛиИмяМетода = Ложь
		Или ВыбраннаяСтруктураТипа.ТипЯзыка = "ИмяМетода"
		Или ВыбраннаяСтруктураТипа.ТипЯзыка = "ИмяПроцедуры"
		Или ВыбраннаяСтруктураТипа.ТипЯзыка = "ИмяФункции";
	ЛиВнутриКомментария = ЛиВнутриКомментария();
		
	// Имена типов и метаданных внутри комментария и текстового литерала
	Если Истина
		И мСтруктураТипаКонтекста.ТипЯзыка <> "ИмяТипа"
		И Не ЛиИмяМетода
		И (Ложь
			Или ЛиВнутриКомментария 
			Или мЭтоТекстовыйЛитерал)
	Тогда  
		// Имена метаданных
		Если Ложь
			Или ВыбраннаяСтруктураТипа.ТипЯзыка = "Местоположение" 
			Или Найти(ВыбраннаяСтруктураТипа.ТипЯзыка, "ИмяФормы") > 0
			Или Найти(ВыбраннаяСтруктураТипа.ТипЯзыка, "ПолноеИмя") > 0  
			Или (Истина
				И ВыбраннаяСтруктураТипа.ТипЯзыка <> "ИмяПредопределенногоЗначения"
				И ирОбщий.ЛиКорневойТипМетаданныхЛкс(ПервоеСловоРодителя))
			Или (Истина
				//И ВыбраннаяСтруктураТипа.ТипЯзыка = "" 
				И Не ЛиНаборЗначенийПолный
				И ДобавлятьНизкоВероятные)
		Тогда
			Если ВыбраннаяСтруктураТипа.ТипЯзыка = "Местоположение" Тогда
				ЛиНаборЗначенийПолный = Истина;
				ИмяДочернегоТипаМД = "Макет";
				ИмяКорневогоТипаМД = "ОбщийМакет";
			ИначеЕсли Ложь
				Или Найти(ВыбраннаяСтруктураТипа.ТипЯзыка, "ИмяФормы") > 0
				Или ирОбщий.СтрокиРавныЛкс(ПервоеСловоРодителя, "ОбщаяФорма") > 0
			Тогда 
				ЛиНаборЗначенийПолный = Истина;
				ИмяДочернегоТипаМД = "Форма";
				ИмяКорневогоТипаМД = "ОбщаяФорма";
			Иначе
				Если Истина
					И ирОбщий.ЛиКорневойТипМетаданныхЛкс(ПервоеСловоРодителя) 
					И Не ЗначениеЗаполнено(ВыбраннаяСтруктураТипа.ТипЯзыка)
				Тогда 
					ВыбраннаяСтруктураТипа.ТипЯзыка = "ИмяМетаданных";
					мСтруктураТипаКонтекста.ТипЯзыка = ВыбраннаяСтруктураТипа.ТипЯзыка;
				КонецЕсли;
				ИмяКорневогоТипаМД = "";
				ИмяДочернегоТипаМД = "";
			КонецЕсли; 
			Если Ложь
				Или ЛиНаборЗначенийПолный
				Или Не мПлатформа.мРежимПроверкиМодуля
			Тогда
				Если ЗначениеЗаполнено(мРодительскийКонтекст) Тогда
					ВычислятьСловаФормы = Ложь;
					ПервоеСловоРодителя = ирОбщий.ПервыйФрагментЛкс(мРодительскийКонтекст);
					Если Истина
						И ЗначениеЗаполнено(ПервоеСловоРодителя)
						И ирОбщий.СтрокиРавныЛкс(ИмяКорневогоТипаМД, ПервоеСловоРодителя) 
					Тогда
						Если СтрЧислоВхождений(мРодительскийКонтекст, ".") = 0 Тогда
							Для Каждого МетаМакет Из Метаданные[ирОбщий.МножественноеИмяМДЛкс(ИмяКорневогоТипаМД)] Цикл
								КоллекцияЭлементовМД.Добавить(МетаМакет.Имя);
							КонецЦикла;
						ИначеЕсли ИмяДочернегоТипаМД = "Форма" Тогда
							ВычислятьСловаФормы = Истина;
						КонецЕсли; 
					Иначе
						Если СтрЧислоВхождений(мРодительскийКонтекст, ".") = 0 Тогда
							Если Истина
								И ирОбщий.СтрНачинаетсяСЛкс(мРодительскийКонтекст, "Внешн")
								И ирОбщий.СтрНачинаетсяСЛкс(мМодульМетаданных.СтруктураТипа.ДержательМетаданных, "Внешн")
							Тогда
								КоллекцияЭлементовМД.Добавить(мМодульМетаданных.СтруктураТипа.ДержательМетаданных.Метаданные().Имя);
							ИначеЕсли мРодительскийКонтекст = "Характеристика" Тогда
								КоллекцияЭлементовМД = Метаданные.ПланыВидовХарактеристик;
							Иначе
								КорневойТип = ПервоеСловоРодителя;
								МножественноеИмяМД = ирОбщий.МножественноеИмяМДЛкс(КорневойТип);
								Если МножественноеИмяМД <> Неопределено Тогда
									Попытка
										КоллекцияМД = Метаданные[МножественноеИмяМД];
									Исключение
										КоллекцияМД = Новый Массив;
									КонецПопытки;
									Для Каждого МетаОбъект Из КоллекцияМД Цикл
										КоллекцияЭлементовМД.Добавить(МетаОбъект.Имя);
									КонецЦикла;
								КонецЕсли; 
							КонецЕсли;
						ИначеЕсли СтрЧислоВхождений(мРодительскийКонтекст, ".") = 1 Тогда
							Если ЗначениеЗаполнено(ИмяДочернегоТипаМД) Тогда
								КоллекцияЭлементовМД.Добавить(ИмяДочернегоТипаМД);
								Если ИмяДочернегоТипаМД = "Форма" Тогда 
									ВсеИменаСтандартныхФорм = мПлатформа.ВсеИменаСтандартныхФорм();
									Если ВсеИменаСтандартныхФорм.Свойство(ПервоеСловоРодителя) Тогда
										Для Каждого ЭлементСписка Из ВсеИменаСтандартныхФорм[ПервоеСловоРодителя] Цикл
											КоллекцияЭлементовМД.Добавить(ЭлементСписка.Значение);
										КонецЦикла;
									КонецЕсли;
									Если ирОбщий.ЛиКорневойТипТаблицыБДЛкс(ПервоеСловоРодителя) Тогда
										Если ирКэш.НомерВерсииПлатформыЛкс() > 803020 Тогда
											КоллекцияЭлементовМД.Добавить("ФормаИсторииИзмененийИсторииДанных");
											КоллекцияЭлементовМД.Добавить("ФормаДанныхВерсииИсторииДанных");
											КоллекцияЭлементовМД.Добавить("ФормаРазличийВерсийИсторииДанных");
										КонецЕсли;
									КонецЕсли;
								КонецЕсли;
							ИначеЕсли ЛиКорневоеИмяТиповXDTO(ПервоеСловоРодителя) Тогда
								ПространствоИмен = Метаданные.ПакетыXDTO.Найти(ирОбщий.ПоследнийФрагментЛкс(мРодительскийКонтекст)).ПространствоИмен;
								КоллекцияЭлементовМД = ФабрикаXDTO.Пакеты.Получить(ПространствоИмен);
							Иначе
								ТипыДочерние = ирКэш.ТипыМетаОбъектов().НайтиСтроки(Новый Структура("Категория", 2));
								Для Каждого СтрокаТипаМетаОбъекта Из ТипыДочерние Цикл
									ОтборСвойств = Новый Структура("ТипКонтекста, ЯзыкПрограммы, ТипЯзыка, НСлово, ТипСлова", 
											"ОбъектМетаданных" + ПервоеСловоРодителя, 0, "", НРег(СтрокаТипаМетаОбъекта.Множественное), "Свойство");
									Если мПлатформа.ТаблицаКонтекстов.НайтиСтроки(ОтборСвойств).Количество() = 0 Тогда 
										Продолжить;
									КонецЕсли;
									КоллекцияЭлементовМД.Добавить(СтрокаТипаМетаОбъекта.Единственное);
								КонецЦикла;
							КонецЕсли;
						ИначеЕсли СтрЧислоВхождений(мРодительскийКонтекст, ".") = 2 Тогда
							Если Истина
								И ирОбщий.СтрНачинаетсяСЛкс(мРодительскийКонтекст, "Внешн")
								И ирОбщий.СтрНачинаетсяСЛкс(мМодульМетаданных.СтруктураТипа.ДержательМетаданных, "Внешн")
							Тогда
								ОбъектМД = мМодульМетаданных.СтруктураТипа.ДержательМетаданных.Метаданные();
							Иначе
								ОбъектМД = Метаданные.НайтиПоПолномуИмени(ирОбщий.СтрокаБезПоследнегоФрагментаЛкс(мРодительскийКонтекст, "."));
							КонецЕсли;
							#Если Сервер И Не Сервер Тогда
							ОбъектМД = Метаданные.Справочники.Валюты;
							#КонецЕсли
							Если ОбъектМД <> Неопределено Тогда
								ИмяМножественное = ирОбщий.МножественноеИмяМДЛкс(ирОбщий.ПоследнийФрагментЛкс(мРодительскийКонтекст));
								Если ИмяМножественное <> Неопределено Тогда
									Для Каждого МетаДоча Из ОбъектМД[ИмяМножественное] Цикл
										КоллекцияЭлементовМД.Добавить(МетаДоча);
									КонецЦикла;
								КонецЕсли;
							КонецЕсли;
						Иначе
							ВычислятьСловаФормы = Истина;
						КонецЕсли; 
					КонецЕсли; 
					Если ВычислятьСловаФормы Тогда
						СтруктураТипаКонтекста = ВычислитьСловоФормыПоПолномуИмени(мРодительскийКонтекст);
						Если СтруктураТипаКонтекста <> Неопределено Тогда
							мСтруктураТипаКонтекста = СтруктураТипаКонтекста; 
						КонецЕсли;
					КонецЕсли;
				Иначе
					КоллекцияЭлементовМД.Добавить("Характеристика");
					Для Каждого СтрокаТипаМетаОбъекта Из ирКэш.ТипыМетаОбъектов(Истина, Ложь) Цикл
						НадоДобавить = Ложь 
							Или Не ЗначениеЗаполнено(ИмяКорневогоТипаМД) 
							Или ИмяКорневогоТипаМД = СтрокаТипаМетаОбъекта.Единственное;
						Если Истина
							И Не НадоДобавить 
							И мМодульМетаданных.СтруктураТипа <> Неопределено 
							И ирОбщий.ЛиФормаИлиИмитаторЛкс(мМодульМетаданных.СтруктураТипа.Метаданные, Ложь)
						Тогда
							НадоДобавить = Ложь
								Или (Истина
									И СтрокаТипаМетаОбъекта.Единственное = "ВнешняяОбработка" 
									И ирОбщий.СтрНайтиЛкс(мМодульМетаданных.СтруктураТипа.Метаданные.ИмяФормы, ".epf") > 0)
								Или (Истина
									И СтрокаТипаМетаОбъекта.Единственное = "ВнешнийОтчет" 
									И ирОбщий.СтрНайтиЛкс(мМодульМетаданных.СтруктураТипа.Метаданные.ИмяФормы, ".erf") > 0);
						КонецЕсли;
						Если Не НадоДобавить Тогда
							ОтборСвойств = Новый Структура("ТипКонтекста, ЯзыкПрограммы, ТипЯзыка, НСлово, ТипСлова", 
									"ОбъектМетаданных" + СтрокаТипаМетаОбъекта.Единственное, 0, "", НРег(ирОбщий.МножественноеИмяМДЛкс(ИмяДочернегоТипаМД)), "Свойство");
							НадоДобавить = мПлатформа.ТаблицаКонтекстов.НайтиСтроки(ОтборСвойств).Количество() > 0;
						КонецЕсли; 
						Если НадоДобавить Тогда 
							КоллекцияЭлементовМД.Добавить(СтрокаТипаМетаОбъекта.Единственное);
						КонецЕсли; 
					КонецЦикла;
				КонецЕсли;
			КонецЕсли;
		КонецЕсли;
	КонецЕсли;
	Если Ложь
		Или ЛиИмяМетода И Не ЛиНаборЗначенийПолный
		Или мЭтоТекстовыйЛитерал И Не ЛиНаборЗначенийПолный
		Или (Истина
			И ЛиВнутриКомментария 
			И ирОбщий.СтрКончаетсяНаЛкс(мТекущаяСтрокаНачало, "см. " + мНачалоКонтекста))
	Тогда
		Если Не ЛиНаборЗначенийПолный Тогда
			ЛиНаборЗначенийПолный = ЛиИмяМетода;
		КонецЕсли;
		ИменаТиповМетаданныхСМенеджерами = мПлатформа.ИменаТиповМетаданныхСМенеджерами();
		Если ЗначениеЗаполнено(мРодительскийКонтекст) Тогда
			ЛиИмяОбщегоМодуля = Метаданные.ОбщиеМодули.Найти(мРодительскийКонтекст) <> Неопределено;
			ЛиИмяМножественноеМетаданных = Истина
				И ЗначениеЗаполнено(мРодительскийКонтекст)
				И СтрЧислоВхождений(мРодительскийКонтекст, ".") < 2
				И ирОбщий.ЛиИмяПеременнойЛкс(ПервоеСловоРодителя)
				И ИменаТиповМетаданныхСМенеджерами.Свойство(ПервоеСловоРодителя);
			Если ЛиИмяОбщегоМодуля Тогда
				ЛиНаборЗначенийПолный = Истина;
				мСтруктураТипаКонтекста.ТипЯзыка = "ИмяМетода";
				мСтруктураТипаКонтекста.ИмяОбщегоТипа = "ОбщийМодуль";
				мСтруктураТипаКонтекста.Метаданные = Метаданные.ОбщиеМодули.Найти(мРодительскийКонтекст);
				// Дублирует работу основного добавления слов
				//ВнутренняяТаблицаСлов = мПлатформа.СловаКонтекстаМетаданные(мСтруктураТипаКонтекста,, "Метод",,,,,, мПлатформа.НовыеФлагиКомпиляции(, Ложь, Ложь),,,,,, БазовоеРасширениеКонфигурации());
				//ЗагрузитьВТаблицуСловИзВнутреннейТаблицыСлов(ВнутренняяТаблицаСлов, ТаблицаСлов);
			ИначеЕсли ЛиИмяМножественноеМетаданных Тогда 
				ЛиНаборЗначенийПолный = Истина;
				ЕдинственноеИмяМД = ирОбщий.ЕдинственноеИмяМДЛкс(ПервоеСловоРодителя);
				Если СтрЧислоВхождений(мРодительскийКонтекст, ".") = 0 Тогда 
					мСтруктураТипаКонтекста.ТипЯзыка = ЕдинственноеИмяМД;
					Для Каждого ОбъектМД Из Метаданные[мРодительскийКонтекст] Цикл
						КоллекцияЭлементовМД.Добавить(ОбъектМД.Имя);
					КонецЦикла;
				Иначе 
					мСтруктураТипаКонтекста = мПлатформа.СтруктураТипаИзКонкретногоТипа(Тип(ЕдинственноеИмяМД + "Менеджер." + ирОбщий.ПоследнийФрагментЛкс(мРодительскийКонтекст)));
					// Дублирует работу основного добавления слов
					//ВнутренняяТаблицаСлов = мПлатформа.СловаКонтекстаМетаданные(мСтруктураТипаКонтекста,, "Метод",,,,,, мПлатформа.НовыеФлагиКомпиляции(, Ложь, Ложь),,,,,, БазовоеРасширениеКонфигурации());
					//ЗагрузитьВТаблицуСловИзВнутреннейТаблицыСлов(ВнутренняяТаблицаСлов, ТаблицаСлов);
				КонецЕсли;
				мСтруктураТипаКонтекста.ТипЯзыка = "ИмяМетода";
			ИначеЕсли Найти(мРодительскийКонтекст, "(") = 0 Тогда
				ТаблицаТипов = ВычислитьТипЗначенияВыражения(мРодительскийКонтекст + "(",,,,,, Ложь);
				Если ТаблицаТипов.Количество() > 0 Тогда
					СтрокаМетода = ТаблицаТипов[0].СтрокаОписания; // см. мПлатформа.НоваяТаблицаМетодовМодуля()[0]
					Если Истина
						И ТипЗнч(СтрокаМетода) = Тип("СтрокаТаблицыЗначений") 
						И СтрокаМетода.Владелец().Колонки.Найти("ЛиЭкспорт") <> Неопределено
						И СтрокаМетода.Имя <> "<>"
					Тогда
						ПараметрыМетода = мПлатформа.ПараметрыМетодаМодуля(СтрокаМетода);
						мТаблицаСловЛитерала = мПлатформа.НоваяТаблицаСлов();
						Если ПараметрыМетода <> Неопределено Тогда
							Для Каждого СтрокаПараметра Из ПараметрыМетода Цикл
								мПлатформа.ДобавитьВТаблицуСлов(мТаблицаСловЛитерала, СтрокаПараметра.Имя,, СтрокаПараметра.ТаблицаТипов, СтрокаПараметра.ТипЗначения, "Метаданные");
							КонецЦикла;
						КонецЕсли;
						ДобавитьПростыеСловаВТаблицу(мТаблицаСловЛитерала);
						мСтруктураТипаКонтекста.ТипЯзыка = "ИмяПараметраМетода";
					КонецЕсли;
				КонецЕсли;
			КонецЕсли;
		ИначеЕсли Истина
			И Не ЛиВнутриКомментария
			И (Ложь
				Или ДобавлятьНизкоВероятные
				Или ЛиИмяМетода И ЛиСистемноеСлово(ВыбраннаяСтруктураТипа))
		Тогда 
			Для Каждого КлючИЗначение Из ирКэш.ДоступныеОбщиеМодулиЛкс(Истина, Истина, Истина) Цикл
				КоллекцияЭлементовМД.Добавить(КлючИЗначение.Значение.Имя);
			КонецЦикла;
			Для Каждого КлючИЗначение Из ИменаТиповМетаданныхСМенеджерами Цикл
				КоллекцияЭлементовМД.Добавить(КлючИЗначение.Ключ);
			КонецЦикла;
			Для Каждого СтрокаМетода Из мМодульМетаданных.Методы Цикл
				Если СтрокаМетода.имя = "<>" Тогда
					Продолжить;
				КонецЕсли;
				КоллекцияЭлементовМД.Добавить(СтрокаМетода.Имя);
			КонецЦикла;
		КонецЕсли; 
	КонецЕсли;
	
	Если Истина
		И мСтруктураТипаКонтекста.ТипЯзыка <> "ИмяТипа"
		И (Ложь
			Или ЛиВнутриКомментария 
			Или мЭтоТекстовыйЛитерал)
	Тогда 
		// Имена типов без второго уровня
		Если Истина
			И Не ЗначениеЗаполнено(мРодительскийКонтекст) 
			И Не ЛиНаборЗначенийПолный
			И ДобавлятьНизкоВероятные 
		Тогда 
			СтруктураТипаИменТипов = мПлатформа.НоваяСтруктураТипа("");
			СтруктураТипаИменТипов.ТипЯзыка = "ИмяТипа";
			ПараметрыЗаполнения = мПлатформа.НовыеПараметрыЗаполненияСлов("Свойство", БазовоеРасширениеКонфигурации(), мЯзыкПрограммы, Конфигурация, ВнешниеФункцииКомпоновкиДанных,,, мФлагиКомпиляции,,,,,, мНаборыСлов);
			ТаблицаИменТипов = мПлатформа.ТаблицаСловИзСтруктурыТипа(СтруктураТипаИменТипов, ПараметрыЗаполнения);
			ирОбщий.ЗагрузитьВТаблицуЗначенийЛкс(ТаблицаИменТипов, ТаблицаСлов); 
			Если ЛиВнутриКомментария Тогда
				ТаблицаИменТипов = мПлатформа.ТаблицаОбщихТипов.Скопировать(Новый Структура("ЯзыкПрограммы, ТипТипа, ИД", мЯзыкПрограммы, "Расширение", ""), "Слово, НСлово");
				ирОбщий.СкопироватьКолонкиКоллекцииЛкс(мПлатформа.НоваяТаблицаСлов(), ТаблицаИменТипов);
				ТаблицаИменТипов.ЗаполнитьЗначения("Свойство", "ТипСлова");
				Если мНаборыСлов <> Неопределено Тогда
					мНаборыСлов.Вставить("ВиртуальныеТипы", ТаблицаИменТипов);
				Иначе 
					// 15-20мс
					ирОбщий.ЗагрузитьВТаблицуЗначенийЛкс(ТаблицаИменТипов, ТаблицаСлов);
				КонецЕсли;
				СтрокаСлова = ТаблицаСлов.Добавить();
				СтрокаСлова.Слово = "Произвольный";
				СтрокаСлова.НСлово = "произвольный";
				СтрокаСлова.ТипСлова = "Свойство";
				СтрокаСлова.Определение = "Предопределенный";
			КонецЕсли;
		ИначеЕсли ЗначениеЗаполнено(мРодительскийКонтекст) Тогда 
			СтрокаОбщегоТипа = мПлатформа.ТаблицаОбщихТипов.НайтиСтроки(Новый Структура("БазовыйТип, ЯзыкПрограммы", ирОбщий.ПервыйФрагментЛкс(мРодительскийКонтекст), мЯзыкПрограммы));
			Если СтрокаОбщегоТипа.Количество() > 0 Тогда
				СтрокаОбщегоТипа = СтрокаОбщегоТипа[0];
				Если Найти(СтрокаОбщегоТипа.Слово, "<") > 0 Тогда
					ТаблицаТипов = ВычислитьТипЗначенияВыражения(мРодительскийКонтекст, , "Тип(""", Истина,,,,,,,,, "Тип");
					Если ТаблицаТипов.Количество() > 0 Тогда
						// ОбработкаОбъект.Х.
						мСтруктураТипаКонтекста = ТаблицаТипов[0];
						ВыбраннаяСтруктураТипа.ТипЯзыка = "ИмяТипа";
						мСтруктураТипаКонтекста.ТипЯзыка = ВыбраннаяСтруктураТипа.ТипЯзыка; 
						Если Найти(мРодительскийКонтекст, ".") = 0 Тогда
							мСтруктураТипаКонтекста.Метаданные = Неопределено;
						КонецЕсли;
					КонецЕсли;
				КонецЕсли;
			КонецЕсли;
		КонецЕсли;
		
		// Имена БД
		КорневыеСловаБД = Новый Массив;
		КорневыеСловаБД.Добавить("БД");
		КорневыеСловаБД.Добавить("КомпоновщикНастроекКомпоновкиДанных");
		Для Каждого КорневоеСловоБД Из КорневыеСловаБД Цикл
			Если Истина
				И Не ЗначениеЗаполнено(мРодительскийКонтекст) 
				И Не ЛиНаборЗначенийПолный
				И ДобавлятьНизкоВероятные 
			Тогда 
				КоллекцияЭлементовМД.Добавить(КорневоеСловоБД);
			ИначеЕсли ирОбщий.СтрокиРавныЛкс(ПервоеСловоРодителя, КорневоеСловоБД) Тогда
				мЯзыкПрограммы = 1; 
				мКорневаяТаблицаТипов = Неопределено;
				РодительскийКонтекст = Сред(мРодительскийКонтекст, СтрДлина(КорневоеСловоБД + ".") + 1);
				СтруктураТипаИменБД = ВычислитьТипЗначенияВыражения(РодительскийКонтекст)[0];
				ПараметрыЗаполнения = мПлатформа.НовыеПараметрыЗаполненияСлов(, БазовоеРасширениеКонфигурации(), 1, Конфигурация, ВнешниеФункцииКомпоновкиДанных,,, мФлагиКомпиляции);
				мТаблицаСловЛитерала = мПлатформа.ТаблицаСловИзСтруктурыТипа(СтруктураТипаИменБД, ПараметрыЗаполнения);
				Если Не ЗначениеЗаполнено(РодительскийКонтекст) Тогда
					ирОбщий.УдалитьСтрокиТаблицыИлиДереваПоЗначениюЛкс(мТаблицаСловЛитерала, "ТипЗначения", "");
					ирОбщий.УдалитьСтрокиТаблицыИлиДереваПоЗначениюЛкс(мТаблицаСловЛитерала, "ТипСлова", "Метод");
				КонецЕсли;
				мЯзыкПрограммы = 0;
				мКорневаяТаблицаТипов = Неопределено;
			КонецЕсли;
		КонецЦикла;
	КонецЕсли;
	ДобавитьПростыеСловаВТаблицу(КоллекцияЭлементовМД);
КонецПроцедуры

Функция ЛиКорневоеИмяТиповXDTO(Текст) Экспорт
	Результат = Ложь
		Или ирОбщий.СтрокиРавныЛкс(Текст, "ПакетXDTO") 
		Или ирОбщий.СтрокиРавныЛкс(Текст, "XDTOПакет") // EDT
		;
	Возврат Результат;
КонецФункции

Функция ИмяФиктивногоСвойства() Экспорт 
	Возврат "__________________";
КонецФункции

Процедура ПрименитьОжидаемыйТипВТаблицеСлов(Знач ЛиВнутриВыражения, Знач ОтделятьБольшиеНаборыСлов)
	ЭтоСсылочныйЛитерал = Неопределено;
	ОписаниеОжидаемогоТипа = РассчитатьОжидаемыйТипВыражения(ЭтоСсылочныйЛитерал);
	Если ОписаниеОжидаемогоТипа = Неопределено Тогда
		Возврат;
	КонецЕсли;
	КлючОсновногоНабора = "";
	Если мНаборыСлов = Неопределено Тогда
		НаборыСлов = Новый Соответствие;
	Иначе
		НаборыСлов = ирОбщий.СкопироватьКоллекциюЛкс(мНаборыСлов);
	КонецЕсли;
	//Если ТаблицаСлов.Количество() > КонстантаМаксСловПроверятьДляОжидаемогоТипа() Тогда
		НаборыСлов[КлючОсновногоНабора] = ТаблицаСлов;
	//КонецЕсли;
	ПеременнаяПредСтроки = Неопределено;
	ШагРейтингаСлова = ШагРейтингаСлова();
	Если Истина
		И мКонечнаяСтрока > 1 
		И ЗначениеЗаполнено(мПредшествующийТекст) // Защита от выполнения в параметре метода ОтобратьКоллекциюЛкс
	Тогда
		ПредСтрока = СокрП(ирОбщий.ПервыйФрагментЛкс(СлужебноеПолеТекстаДолгое.ПолучитьСтроку(мКонечнаяСтрока - 1), "//"));
		Если мЯзыкПрограммы = 0 Тогда
			Если Ложь
				Или Прав(ПредСтрока, 1) = ";" 
				Или ирОбщий.СтрКончаетсяНаЛкс(ПредСтрока, "цикл")
			Тогда
				// При вводе новой инструкции даем приоритет переменной, с которой начинается предшествующая инструкция
				мРегВыражение.Pattern = мПлатформа.шПустоеНачалоСтроки + "(Для\s+Каждого\s+|Возврат\s+|Если\s+)?(" + шИмя + ")\s*(=|\.|из)";
				Вхождения = мРегВыражение.НайтиВхождения(Символы.ПС + ПредСтрока);
				Если Вхождения.Количество() Тогда
					Вхождение = Вхождения[0];
					Если Ложь
						Или Вхождение.SubMatches(2) <> "="
						Или Вхождение.SubMatches(0) = Неопределено
					Тогда
						ИмяПеременной = Вхождение.SubMatches(1);
						//Если ирОбщий.ЛиИмяПеременнойЛкс(ИмяПеременной) Тогда
							ПеременнаяПредСтроки = ИмяПеременной;
						//КонецЕсли;
					КонецЕсли;
				КонецЕсли;
			КонецЕсли;
		Иначе
			Если Лев(ПредСтрока, 1) = "|" Тогда
				ПредСтрока = СокрЛ(Сред(ПредСтрока, 2));
			КонецЕсли;
			Если Ложь
				Или Прав(ПредСтрока, 1) = "," 
				Или ирОбщий.СтрНачинаетсяСЛкс(ПредСтрока, "И")
			Тогда
				// При вводе элемента списка даем приоритет таблице, из которой выбрано предшествующее поле
				мРегВыражение.Pattern = "(?:(?:И|ИЛИ|ГДЕ|ПО)\s+)?(" + шИмя + ")\.";
				Вхождения = мРегВыражение.НайтиВхождения(Символы.ПС + ПредСтрока);
				Если Вхождения.Количество() Тогда
					ИмяПеременной = Вхождения[0].SubMatches(0);
					//Если ирОбщий.ЛиИмяПеременнойЛкс(ИмяПеременной) Тогда
						ПеременнаяПредСтроки = ИмяПеременной;
					//КонецЕсли;
				КонецЕсли;
			КонецЕсли;
		КонецЕсли;
		Если Истина
			И мЯзыкПрограммы = 0
			И ирОбщий.СтрНачинаетсяСЛкс(мТекущееСлово, СокрЛП(мТекущаяСтрокаНачало), Истина)
		Тогда
			СтрокаНачалаКонструкции = Неопределено;
			НепечатноеНачало = ирОбщий.НепечатноеНачалоСтрокиЛкс(мТекущаяСтрокаНачало);
			ДлинаТекущегоОтступа = СтрДлина(НепечатноеНачало);
			Для Счетчик = 1 По 100 Цикл
				ТекстСтроки = СлужебноеПолеТекстаДолгое.ПолучитьСтроку(мКонечнаяСтрока - Счетчик);
				Если ПустаяСтрока(ТекстСтроки) Тогда
					Продолжить;
				КонецЕсли;
				ОтступСтроки = ирОбщий.НепечатноеНачалоСтрокиЛкс(ТекстСтроки);
				Если СтрДлина(ОтступСтроки) < ДлинаТекущегоОтступа Тогда
					Прервать;
				КонецЕсли;
				Если ОтступСтроки = НепечатноеНачало Тогда
					СтрокаНачалаКонструкции = НРег(ТекстСтроки);
					Прервать;
				КонецЕсли;
			КонецЦикла;	
			Если СтрокаНачалаКонструкции <> Неопределено Тогда
				КлючПоиска = Новый Структура("Слово");
				КлючПоиска.Вставить("ТипСлова", "Конструкция");
				ПервоеСлово = СокрЛ(ирОбщий.ПервыйФрагментЛкс(СтрокаНачалаКонструкции, " "));
				Если Ложь
					Или ПервоеСлово = "если"
					Или ПервоеСлово = "иначеесли"
					Или ПервоеСлово = "иначе"
					Или ПервоеСлово = "тогда"
				Тогда
					КлючПоиска.Слово = "КонецЕсли";
					ОбозначитьСловоСОжидаемымТипомВТаблицеСлов(КлючПоиска, НаборыСлов, КлючОсновногоНабора,, 3);
				КонецЕсли;
				Если Ложь
					Или ПервоеСлово = "если"
					Или ПервоеСлово = "тогда"
				Тогда
					КлючПоиска.Слово = "Иначе";
					ОбозначитьСловоСОжидаемымТипомВТаблицеСлов(КлючПоиска, НаборыСлов, КлючОсновногоНабора,, 2);
				КонецЕсли;
				Если Ложь
					Или ПервоеСлово = "пока"
					Или ПервоеСлово = "для"
				Тогда
					КлючПоиска.Слово = "КонецЦикла";
					ОбозначитьСловоСОжидаемымТипомВТаблицеСлов(КлючПоиска, НаборыСлов, КлючОсновногоНабора,, 2);
				КонецЕсли;
				Если ПервоеСлово = "попытка" Тогда
					КлючПоиска.Слово = "Исключение";
					ОбозначитьСловоСОжидаемымТипомВТаблицеСлов(КлючПоиска, НаборыСлов, КлючОсновногоНабора,, 2);
				КонецЕсли;
				Если ПервоеСлово = "исключение" Тогда
					КлючПоиска.Слово = "КонецПопытки";
					ОбозначитьСловоСОжидаемымТипомВТаблицеСлов(КлючПоиска, НаборыСлов, КлючОсновногоНабора,, 2);
				КонецЕсли;
				Если ПервоеСлово = "функция" Тогда
					КлючПоиска.Слово = "КонецФункции";
					ОбозначитьСловоСОжидаемымТипомВТаблицеСлов(КлючПоиска, НаборыСлов, КлючОсновногоНабора,, 2);
				КонецЕсли;
				Если ПервоеСлово = "процедура" Тогда
					КлючПоиска.Слово = "КонецПроцедуры";
					ОбозначитьСловоСОжидаемымТипомВТаблицеСлов(КлючПоиска, НаборыСлов, КлючОсновногоНабора,, 2);
				КонецЕсли;
				Если мСтрокаЛучшегоСлова <> Неопределено Тогда
					Возврат;
				КонецЕсли;
			КонецЕсли;
		КонецЕсли;
	КонецЕсли;
	Если Истина
		И Не ЛиВнутриВыражения
		И СокрЛП(мТекущаяСтрокаНачало) = мРодительскийКонтекст + "." + мТекущееСлово
		И ТаблицаСлов.Найти("Свойство", "ТипСлова") <> Неопределено
		И Найти(мРодительскийКонтекст, "(") = 0
		И Не ирОбщий.СтрНачинаетсяСЛкс(мСтруктураТипаКонтекста.ИмяОбщегоТипа, "Перечисление")
	Тогда
		СтрокаСлова = мПлатформа.ДобавитьВТаблицуСлов(ТаблицаСлов, СловоГенераторКодаЗаполненияСвойств(), "Конструкция",,,, Ложь,, Истина);
		ПредСтрокаНРег = СокрЛ(НРег(ПредСтрока));
		Если Ложь
			Или ирОбщий.СтрНачинаетсяСЛкс(ПредСтрокаНРег, НРег(мРодительскийКонтекст + " = Новый"), Истина)
			Или (Истина
				И ирОбщий.СтрНачинаетсяСЛкс(ПредСтрокаНРег, НРег(мРодительскийКонтекст + " ="), Истина)
				И Найти(ПредСтрокаНРег, НРег(".Добавить(")) > 0)
		Тогда
			//
		Иначе
			СтрокаСлова.Рейтинг = - ШагРейтингаСлова;
		КонецЕсли;
	КонецЕсли;
	Если Истина
		И Не ЛиВнутриВыражения
		И мЭтоТекстовыйЛитерал
		И (Ложь
			Или ирОбщий.СтрКончаетсяНаЛкс(мВызовМетода, ".УстановитьПараметр(") 
			Или ирОбщий.СтрКончаетсяНаЛкс(мВызовМетода, ".Вставить(")) 
		И ТаблицаСлов.Количество() > 1
	Тогда
		мПлатформа.ДобавитьВТаблицуСлов(ТаблицаСлов, СловоГенераторКодаЗаполненияСвойств(), "Конструкция",,,, Ложь,, Истина);
	КонецЕсли;
	Если Истина
		И ЗначениеЗаполнено(мРодительскийКонтекст)
		И Найти(ОписаниеОжидаемогоТипа.ВыражениеПриемник, ".") > 0
		И Найти(ОписаниеОжидаемогоТипа.ВыражениеПриемник, "(") = 0
		И Прав(ОписаниеОжидаемогоТипа.ВыражениеПриемник, 1) <> "]" 
		И Найти(мРодительскийКонтекст, "(") = 0
		И ОписаниеОжидаемогоТипа.ПредшествующийТокен = "="
		И ТаблицаСлов.Найти("Свойство", "ТипСлова") <> Неопределено
		И мСтруктураТипаКонтекста.ИмяОбщегоТипа <> "ОбщийМодуль"
		И Не мПлатформа.ЛиИмяСистемногоПеречисления(мСтруктураТипаКонтекста.ИмяОбщегоТипа)
	Тогда
		СтрокаСлова = мПлатформа.ДобавитьВТаблицуСлов(ТаблицаСлов, СловоГенераторКодаСопоставитьСвойства(), "Конструкция",,,, Ложь,, Истина);
	КонецЕсли;
	Если Истина
		И Не ЛиВнутриВыражения
		И мСтруктураТипаКонтекста.ИмяОбщегоТипа = "РезультатЗапроса" 
		И ТипЗнч(мСтруктураТипаКонтекста.Метаданные) = Тип("ПостроительЗапроса") 
		И мСтруктураТипаКонтекста.Метаданные.Измерения.Количество()
	Тогда
		мПлатформа.ДобавитьВТаблицуСлов(ТаблицаСлов, СловоГенераторКодаОбходРезультатаЗапроса(), "Конструкция",,,, Ложь,, Истина);
	КонецЕсли;
	СтрокаОбщегоТипа = мПлатформа.ТаблицаОбщихТипов.НайтиСтроки(Новый Структура("Слово, ЯзыкПрограммы", мСтруктураТипаКонтекста.ИмяОбщегоТипа, мЯзыкПрограммы));
	Если Истина
		И Не ЛиВнутриВыражения
		И СтрокаОбщегоТипа.Количество()
		И ЗначениеЗаполнено(СтрокаОбщегоТипа[0].ТипЭлементаКоллекции)
		И ТаблицаСлов.НайтиСтроки(Новый Структура("Слово, ТипСлова", "Количество", "Метод")).Количество()
		И ТаблицаСлов.НайтиСтроки(Новый Структура("Слово, ТипСлова", "Удалить", "Метод")).Количество()
	Тогда
		СтрокаСлова = мПлатформа.ДобавитьВТаблицуСлов(ТаблицаСлов, СловоГенераторКодаУдалитьВыбранныеЭлементы() + РазделительВариантаКонтекста(), "Конструкция",,,, Ложь,, Истина); // добавка нужна для захвата родителя в Турбоконфе
		СтрокаСлова.Рейтинг = - ШагРейтингаСлова;
	КонецЕсли;
	Если Истина
		И Не ЛиВнутриВыражения
		И СтрокаОбщегоТипа.Количество()
		И ЗначениеЗаполнено(СтрокаОбщегоТипа[0].ТипЭлементаКоллекции)
	Тогда
		мПлатформа.ДобавитьВТаблицуСлов(ТаблицаСлов, СловоГенераторКодаОбойтиЭлементы() + РазделительВариантаКонтекста(), "Конструкция",,,, Ложь,, Истина); // добавка нужна для захвата родителя в Турбоконфе
	КонецЕсли;
	ВыражениеПриемник = ОписаниеОжидаемогоТипа.ВыражениеПриемник;
	ТаблицаОжидаемыхТипов = ОписаниеОжидаемогоТипа.ТаблицаОжидаемыхТипов;
	РазрешитьМногоТипов = ОписаниеОжидаемогоТипа.РазрешитьМногоТипов;
	ПредшествующийТокен = ОписаниеОжидаемогоТипа.ПредшествующийТокен;
	ИменаВложенныхТипов = ОписаниеОжидаемогоТипа.ИменаВложенныхТипов;
	Если Истина
		И ТаблицаОжидаемыхТипов = Неопределено 
		И мИмяОжидаемогоТипа = "" 
		И ВыражениеПриемник = "" 
		И ПеременнаяПредСтроки = Неопределено
	Тогда
		Возврат;
	КонецЕсли; 
	ОбщееЧислоСлов = 0;
	Для Каждого КлючИЗначение Из НаборыСлов Цикл
		ОбщееЧислоСлов = ОбщееЧислоСлов + КлючИЗначение.Значение.Количество();
	КонецЦикла;
	Если Истина
		//И мСтруктураТипаКонтекста.ТипЯзыка = "ИмяТипа"
		И Не ЗначениеЗаполнено(ТаблицаОжидаемыхТипов)
		И Не ЗначениеЗаполнено(мИмяОжидаемогоТипа)
		И ПредшествующийТокен = "="
		И ирОбщий.ЛиИмяПеременнойЛкс(ВыражениеПриемник)
	Тогда
		КлючПоиска = Новый Структура("НСлово, ЯзыкПрограммы");
		КлючПоиска.ЯзыкПрограммы = 0;
		КлючПоиска.НСлово = ВыражениеПриемник;
		Если ирОбщий.СтрНачинаетсяСЛкс(ВыражениеПриемник, "сз", Истина) Тогда
			КлючПоиска.НСлово = "СписокЗначений";
		ИначеЕсли ирОбщий.СтрНачинаетсяСЛкс(ВыражениеПриемник, "тз", Истина) Тогда
			КлючПоиска.НСлово = "ТаблицаЗначений";
		ИначеЕсли ирОбщий.СтрНачинаетсяСЛкс(ВыражениеПриемник, "дз", Истина) Тогда
			КлючПоиска.НСлово = "ДеревоЗначений";
		ИначеЕсли ирОбщий.СтрНачинаетсяСЛкс(ВыражениеПриемник, "мс", Истина) Тогда
			КлючПоиска.НСлово = "Массив";
		ИначеЕсли ирОбщий.СтрНачинаетсяСЛкс(ВыражениеПриемник, "стк", Истина) Тогда
			КлючПоиска.НСлово = "Структура";
		ИначеЕсли ирОбщий.СтрНачинаетсяСЛкс(ВыражениеПриемник, "стт", Истина) Тогда
			КлючПоиска.НСлово = "Соответствие";
		КонецЕсли;
		КлючПоиска.НСлово = НРег(КлючПоиска.НСлово);
		ОбщиеТипы = мПлатформа.ТаблицаОбщихТипов.НайтиСтроки(КлючПоиска);
		Если ОбщиеТипы.Количество() > 0 Тогда
			мИмяОжидаемогоТипа = ОбщиеТипы[0].Слово;
		Иначе
			мИмяОжидаемогоТипа = ирОбщий.ИмяТипаИзИмениПеременнойЛкс(ВыражениеПриемник);
		КонецЕсли; 
	КонецЕсли;
	ЛиСистемноеСлово = Ложь;
	Если Не ЗначениеЗаполнено(мИмяОжидаемогоТипа) Тогда
		мИмяОжидаемогоТипа = мПлатформа.ПредставлениеМассиваСтруктурТипов(ТаблицаОжидаемыхТипов);
	КонецЕсли;
	ВсеИменаТипов = ирОбщий.СтрРазделитьЛкс(мИмяОжидаемогоТипа, ", ", Истина, Ложь);
	Если Не РазрешитьМногоТипов Тогда
		ирОбщий.УдалитьЗначениеИзМассиваЛкс(ВсеИменаТипов, "Произвольный");
		ирОбщий.УдалитьЗначениеИзМассиваЛкс(ВсеИменаТипов, "?");
		ИменаТиповУрезанные = ирОбщий.СкопироватьКоллекциюЛкс(ВсеИменаТипов);
		ирОбщий.УдалитьЗначениеИзМассиваЛкс(ИменаТиповУрезанные, "Неопределено");
		Если ИменаТиповУрезанные.Количество() > 1 Тогда
			// Нужно для конструктора ИсточникДоступныхНастроекКомпоновкиДанных
			ирОбщий.УдалитьЗначениеИзМассиваЛкс(ИменаТиповУрезанные, "Строка");
		КонецЕсли;
		Если ИменаТиповУрезанные.Количество() > 1 Тогда
			ирОбщий.УдалитьЗначениеИзМассиваЛкс(ИменаТиповУрезанные, "Массив");
		КонецЕсли;
		Если ИменаТиповУрезанные.Количество() > 1 Тогда
			ирОбщий.УдалитьЗначениеИзМассиваЛкс(ИменаТиповУрезанные, "СписокЗначений");
		КонецЕсли;
		Если ИменаТиповУрезанные.Количество() > 1 Тогда
			ИменаТиповУрезанные = ирОбщий.СвернутьМассивЛкс(ИменаТиповУрезанные);
		КонецЕсли;
		Если ИменаТиповУрезанные.Количество() > 0 Тогда
			Если ЗначениеЗаполнено(ТаблицаОжидаемыхТипов) Тогда
				ЛучшаяСтрокаТипа = ТаблицаОжидаемыхТипов.Найти(ИменаТиповУрезанные[0], "ИмяОбщегоТипа");
				Если ЛучшаяСтрокаТипа <> Неопределено Тогда
					ЛиСистемноеСлово = ЛиСистемноеСлово(ЛучшаяСтрокаТипа, Истина);
					СтрокаОписания = ЛучшаяСтрокаТипа.СтрокаОписания;
					Если Истина
						И СтрокаОписания <> Неопределено
						И ТипЗнч(СтрокаОписания) <> Тип("СтрокаТаблицыЗначений") 
					Тогда
						СтрокаОписания = Неопределено;
						мКэшОжидаемогоТипа.ЛиДинамическоеСвойство = Истина;
					КонецЕсли;
				КонецЕсли;
			КонецЕсли; 
			мИмяОжидаемогоТипа = ИменаТиповУрезанные[0]; 
			Если Истина 
				И ИменаТиповУрезанные.Количество() > 1
				И (Ложь
					Или Не ЛиСистемноеСлово
					Или СтрокаОписания.Слово <> "ТекущийЭлемент")
			Тогда  
				мИмяОжидаемогоТипа = "";
			КонецЕсли;
		Иначе
			мИмяОжидаемогоТипа = "";
		КонецЕсли; 
		ИменаТиповУрезанные = Неопределено; // - Чтобы не путаться
	КонецЕсли;
	//ЛучшаяСтрокаТипа = ЛучшийТипИзТаблицыТипов(ТаблицаОжидаемыхТипов);
	Если Истина
		И ЛучшаяСтрокаТипа <> Неопределено
		И ТипЗнч(ЛучшаяСтрокаТипа.СтрокаОписания) = Тип("СтрокаТаблицыЗначений")
		И ЛучшаяСтрокаТипа.СтрокаОписания.Владелец().Колонки.Найти("ТелоБезВозвратов") <> Неопределено
	Тогда
		// Функция-конструктор
		ИмяКонструктораЛокальное = ЛучшаяСтрокаТипа.СтрокаОписания.Имя;
		ВсеИменаТипов.Добавить("см. " + ИмяКонструктораЛокальное);
		//ИмяКонструктораГлобальное = ПолноеИмяМетода(ЛучшаяСтрокаТипа.СтрокаОписания, Ложь);
		//ВсеИменаТипов.Добавить("см. " + ИмяКонструктораГлобальное);
	КонецЕсли;
	мИмяОжидаемогоТипа = ирОбщий.ПервыйФрагментЛкс(мИмяОжидаемогоТипа, "(");
	ИмяТаблицыБД = СтрЗаменить(мИмяОжидаемогоТипа, "Ссылка.", ".");
	Если мЯзыкПрограммы = 1 Тогда
		мИмяОжидаемогоТипа = ИмяТаблицыБД;
	КонецЕсли; 
	Если Не ЗначениеЗаполнено(мРодительскийКонтекст) Тогда
		Если Истина
			И ПредшествующийТокен = "=" 
			И ЗначениеЗаполнено(ВыражениеПриемник) 
			//И Найти(ВыражениеПриемник, ".") = 0
			И Найти(ВыражениеПриемник, "(") = 0
			И (Ложь
				Или мИмяОжидаемогоТипа = "Число"
				Или мИмяОжидаемогоТипа = "Строка")
		Тогда
			УстановитьРейтингСлову(ВыражениеПриемник,,,,); // для Ф=Ф+1
		КонецЕсли;
		ЛиСравнение = Ложь
			Или ПредшествующийТокен = "="
			Или ПредшествующийТокен = "<>";
		Если Истина
			И ЛиСравнение
			И мСтруктураТипаКонтекста.ТипЯзыка = ""
		Тогда
			ПоднятьНеопределено = Ложь
				Или мИмяОжидаемогоТипа <> "Тип" И ПредшествующийТокен = "<>"
				Или ирОбщий.СтрокиРавныЛкс(ирОбщий.ПоследнийФрагментЛкс(ВыражениеПриемник), "ТекущаяСтрока");
			Если Не ПоднятьНеопределено И ирОбщий.ЛиИмяПеременнойЛкс(ВыражениеПриемник) Тогда
				Найденные = ТаблицаСлов.НайтиСтроки(Новый Структура("Слово, ТипСлова", ВыражениеПриемник, "Свойство"));
				// Этот способ опирался на полный сбор переменных тела метода. После перехода к сбору из предшествующего текста стал неактуальным.
				//Если Истина
				//	И Найденные.Количество()
				//	И Найденные[0].Определение = "Статистический"
				//Тогда
				//	шСозданиеПеременной = шПредИмяПрямое + ВыражениеПриемник + "\s*=|" + шПредИмяПрямое + "Для\s+(Каждого\s+)" + ВыражениеПриемник + "(?:\s*=|\s+Из)|Перем\s+" + ВыражениеПриемник + шПостИмяСвойства;
				//	Если ирОбщий.НайтиРегВыражениеЛкс(мТекстДляПоискаОпределения, шСозданиеПеременной,, Ложь).Количество() = 0 Тогда
				//		// Ввод значения новой переменной
				//		ПоднятьНеопределено = Истина;
				//	КонецЕсли;
				//КонецЕсли;
				Если Найденные.Количество() = 0 Тогда
					ПоднятьНеопределено = Истина;
				КонецЕсли;
			КонецЕсли;
			Если ПоднятьНеопределено Тогда 
				ВключатьАвтоОткрытие = Не ирОбщий.СтрНачинаетсяСЛкс(СокрЛ(мТекущаяСтрокаНачало), ВыражениеПриемник);
				УстановитьРейтингСлову("Неопределено", 2,,, ВключатьАвтоОткрытие);
			КонецЕсли;
		КонецЕсли;
		Если Истина
			И ПеременнаяПредСтроки <> Неопределено
			И мСтруктураТипаКонтекста.ТипЯзыка = ""
			И (Ложь
				Или Не ЛиСравнение
				Или ВыражениеПриемник <> ПеременнаяПредСтроки)
		Тогда
			УстановитьРейтингСлову(ПеременнаяПредСтроки, 2); // Опасно, т.е. атрибут "Определение" будет некорректным если слова нет в списке
			//КлючПоиска = Новый Структура;
			//КлючПоиска.Вставить("Слово", ПеременнаяПредСтроки);
			//КлючПоиска.Вставить("ТипСлова", "Свойство");
			//ОбозначитьСловоСОжидаемымТипомВТаблицеСлов(КлючПоиска, НаборыСлов, КлючОсновногоНабора,, 2);
		КонецЕсли;  
	КонецЕсли;
	мСтрокаЛучшегоСлова = Неопределено;
	Если Истина
		//И мМодульМетаданных.СтруктураТипа <> Неопределено
		//И ирОбщий.ЛиИмяТипаФормыЛкс(мМодульМетаданных.СтруктураТипа.ИмяОбщегоТипа)
		И ЛиСистемноеСлово
		И ирОбщий.СтрНачинаетсяСЛкс(ВыражениеПриемник, мРодительскийКонтекст)
		И (Ложь
			Или СтрокаОписания.Слово = "ТекущаяОбласть" И СтрокаОписания.ТипКонтекста = "ТабличныйДокумент"
			Или СтрокаОписания.Слово = "ТекущаяКолонка" И СтрокаОписания.ТипКонтекста = "ТабличноеПоле"
			Или СтрокаОписания.Слово = "ТекущаяСтраница" И СтрокаОписания.ТипКонтекста = "Панель"
			Или СтрокаОписания.Слово = "ТекущаяСтраница" И СтрокаОписания.ТипКонтекста = "РасширениеГруппыФормыДляСтраниц"
			Или СтрокаОписания.Слово = "ТекущийЭлемент" И СтрокаОписания.ТипКонтекста = "ТаблицаФормы"
			Или СтрокаОписания.Слово = "ТекущийЭлемент" И СтрокаОписания.ТипКонтекста = "Форма"
			Или СтрокаОписания.Слово = "ТекущийЭлемент" И СтрокаОписания.ТипКонтекста = "ФормаКлиентскогоПриложения")  
	Тогда
		Если СтрокаОписания.ТипКонтекста = "ТабличноеПоле" Тогда 
			ИмяКоллекции = "Колонки";        
		ИначеЕсли СтрокаОписания.ТипКонтекста = "Панель" Тогда 
			ИмяКоллекции = "Страницы";
		ИначеЕсли СтрокаОписания.ТипКонтекста = "ТабличныйДокумент" Тогда 
			ИмяКоллекции = "Области";
		ИначеЕсли СтрокаОписания.ТипКонтекста = "Форма" Тогда 
			ИмяКоллекции = "ЭлементыФормы";
		ИначеЕсли СтрокаОписания.ТипКонтекста = "ФормаКлиентскогоПриложения" Тогда 
			ИмяКоллекции = "Элементы";
		Иначе
			ИмяКоллекции = "ПодчиненныеЭлементы";
		КонецЕсли;
		ФрагментыСлеваОтРавно = ирОбщий.СтрРазделитьЛкс(ВыражениеПриемник);
		ФрагментыСлеваОтРавно[ФрагментыСлеваОтРавно.ВГраница()] = ИмяКоллекции;
		Если Не ЗначениеЗаполнено(мРодительскийКонтекст) Тогда
			УровеньСвойства = 0;
		Иначе 
			УровеньСвойства = 1 + СтрЧислоВхождений(мРодительскийКонтекст, ".");
		КонецЕсли;
		КлючПоиска = Новый Структура("Слово", ФрагментыСлеваОтРавно[УровеньСвойства]);
		ОбозначитьСловоСОжидаемымТипомВТаблицеСлов(КлючПоиска, НаборыСлов, КлючОсновногоНабора);
	Иначе
		ТипТаблицы = ирОбщий.ПервыйФрагментЛкс(ИмяТаблицыБД);
		МножественноеКорневогоТипа = ирОбщий.МножественноеИмяМДЛкс(ТипТаблицы);
		КлючПоиска = Новый Структура("ТипКонтекста, ЯзыкПрограммы, ТипЯзыка, ТипСлова");
		КлючПоиска.ТипКонтекста = "ПеречислимыеСвойстваОбъектовМетаданных";
		КлючПоиска.ЯзыкПрограммы = 0;
		КлючПоиска.ТипЯзыка = "";
		КлючПоиска.ТипСлова = "Свойство";
		ПеречислимыеСвойстваМД = мПлатформа.ТаблицаКонтекстов.Скопировать(КлючПоиска);
		//ПеречислимыеСвойстваМД.Индексы.Добавить("Слово");
		Если ПеречислимыеСвойстваМД.Найти(ИмяТаблицыБД, "Слово") <> Неопределено Тогда
			УровеньСвойства = СтрЧислоВхождений(мРодительскийКонтекст, ".");
			Если Не ЗначениеЗаполнено(мРодительскийКонтекст) И УровеньСвойства = 0 Тогда
				//КлючПоиска = Новый Структура("Слово", "Метаданные");
				//ОбозначитьСловоСОжидаемымТипомВТаблицеСлов(КлючПоиска, НаборыСлов, КлючОсновногоНабора);
				СтрокаСлова = мПлатформа.ДобавитьВТаблицуСлов(ТаблицаСлов, "Метаданные.СвойстваОбъектов." + ИмяТаблицыБД, "Конструкция",,,, Ложь);
				СтрокаСлова.Рейтинг = 2 * ШагРейтингаСлова;
				СтрокаСлова.НСлово = НРег(СтрокаСлова.Слово);
			ИначеЕсли ЗначениеЗаполнено(мРодительскийКонтекст) И УровеньСвойства = 0 Тогда
				КлючПоиска = Новый Структура("Слово", "СвойстваОбъектов");
				ОбозначитьСловоСОжидаемымТипомВТаблицеСлов(КлючПоиска, НаборыСлов, КлючОсновногоНабора);
			ИначеЕсли УровеньСвойства = 1 Тогда
				КлючПоиска = Новый Структура("Слово", ИмяТаблицыБД);
				ОбозначитьСловоСОжидаемымТипомВТаблицеСлов(КлючПоиска, НаборыСлов, КлючОсновногоНабора);
			КонецЕсли;
		ИначеЕсли Истина
			И (Ложь
				Или ирОбщий.СтрНачинаетсяСЛкс(ТипТаблицы, мРодительскийКонтекст)
				Или ирОбщий.СтрНачинаетсяСЛкс(МножественноеКорневогоТипа, мРодительскийКонтекст))
			И (Ложь
				Или ирОбщий.ЛиТипТаблицыМетассылкиЛкс(ТипТаблицы) 
				Или ирОбщий.ЛиКорневойТипОбъектаСПредопределеннымЛкс(ТипТаблицы))
		Тогда
			УровеньСвойства = СтрЧислоВхождений(мРодительскийКонтекст, ".");
			Если Не ЗначениеЗаполнено(мРодительскийКонтекст) И УровеньСвойства = 0 Тогда
				Если ЭтоСсылочныйЛитерал Тогда
					КлючПоиска = Новый Структура("Слово", ТипТаблицы);
				ИначеЕсли мЯзыкПрограммы = 0 Тогда
					КлючПоиска = Новый Структура("Слово", МножественноеКорневогоТипа);
				Иначе
					КлючПоиска = Неопределено;
				КонецЕсли;
				Если КлючПоиска <> Неопределено Тогда
					ОбозначитьСловоСОжидаемымТипомВТаблицеСлов(КлючПоиска, НаборыСлов, КлючОсновногоНабора);
				КонецЕсли;
			ИначеЕсли ЗначениеЗаполнено(мРодительскийКонтекст) И УровеньСвойства = 0 Тогда
				КлючПоиска = Новый Структура("Слово", ирОбщий.ПоследнийФрагментЛкс(ИмяТаблицыБД));
				ОбозначитьСловоСОжидаемымТипомВТаблицеСлов(КлючПоиска, НаборыСлов, КлючОсновногоНабора);
			КонецЕсли;
		КонецЕсли;
		Если Истина
			И Не ЗначениеЗаполнено(мРодительскийКонтекст)
			И ВсеИменаТипов.Найти("Неопределено") <> Неопределено
		Тогда
			КлючПоиска = Новый Структура("Слово", "Неопределено");
			ОбозначитьСловоСОжидаемымТипомВТаблицеСлов(КлючПоиска, НаборыСлов, КлючОсновногоНабора);
		КонецЕсли;
		Если мСтруктураТипаКонтекста.ТипЯзыка = "ИмяТипа" Тогда
			Если ИменаВложенныхТипов <> Неопределено Тогда
				ВсеИменаТипов = ИменаВложенныхТипов;
			КонецЕсли;
			Для Каждого ИмяТипа Из ВсеИменаТипов Цикл
				ИмяТипа = ирОбщий.ПервыйФрагментЛкс(ИмяТипа, "(");
				КлючПоиска = Новый Структура("Слово", ИмяТипа);
				Если Истина
					И Не ОбозначитьСловоСОжидаемымТипомВТаблицеСлов(КлючПоиска, НаборыСлов, КлючОсновногоНабора) 
					И Не ЗначениеЗаполнено(мРодительскийКонтекст) 
					И Не мСтруктураТипаКонтекста.Конструктор
				Тогда     
					мСтрокаЛучшегоСлова = мПлатформа.ДобавитьВТаблицуСлов(ТаблицаСлов, ИмяТипа, "Конструкция",, "Тип",, Ложь);
					мСтрокаЛучшегоСлова.Рейтинг = ШагРейтингаСлова;
					мСтрокаЛучшегоСлова.НСлово = НРег(мСтрокаЛучшегоСлова.Слово);
				КонецЕсли;
			КонецЦикла;
		Иначе 
			Если Истина
				И Не ЗначениеЗаполнено(мРодительскийКонтекст)
				И ВсеИменаТипов.Найти("Булево") <> Неопределено
			Тогда
				НПоследнееСловоПриемника = НРег(ирОбщий.ПоследнийФрагментЛкс(ВыражениеПриемник));
				ПремироватьЛожь = Ложь
					Или НПоследнееСловоПриемника = "видимость"
					Или НПоследнееСловоПриемника = "доступность"
					Или НПоследнееСловоПриемника = НРег("СтандартнаяОбработка");
				КлючПоиска = Новый Структура("Слово", "Ложь");
				ОбозначитьСловоСОжидаемымТипомВТаблицеСлов(КлючПоиска, НаборыСлов, КлючОсновногоНабора,, ?(ПремироватьЛожь, 5, 3));
				ПремироватьИстину = Ложь
					Или НПоследнееСловоПриемника = "загрузка"
					Или НПоследнееСловоПриемника = "использование"
					Или НПоследнееСловоПриемника = "отказ";
				КлючПоиска = Новый Структура("Слово", "Истина");
				ОбозначитьСловоСОжидаемымТипомВТаблицеСлов(КлючПоиска, НаборыСлов, КлючОсновногоНабора,, ?(ПремироватьИстину, 5, 3));
				// Вредно в списке родной формы ИР
				//КлючПоиска = Новый Структура("Слово", "Не");
				//ОбозначитьСловоСОжидаемымТипомВТаблицеСлов(КлючПоиска, НаборыСлов, КлючОсновногоНабора);
			ИначеЕсли мИмяОжидаемогоТипа = "КАК" Тогда
				КлючПоиска = Новый Структура("Слово", "КАК");
				ОбозначитьСловоСОжидаемымТипомВТаблицеСлов(КлючПоиска, НаборыСлов, КлючОсновногоНабора);
			КонецЕсли;
			РодительПриемника = ирОбщий.СтрокаБезПоследнегоФрагментаЛкс(ВыражениеПриемник);
			ПоследнееСловоПриемника = ирОбщий.ПоследнийФрагментЛкс(ВыражениеПриемник);
			// По совпадению слова и типа
			Если Истина
				И ирОбщий.ЛиИмяПеременнойЛкс(ПоследнееСловоПриемника)
				И (Ложь
					Или ПредшествующийТокен <> "=" И ПредшествующийТокен <> "<>"
					Или (Истина
						И Не ирОбщий.СтрокиРавныЛкс(РодительПриемника, мРодительскийКонтекст) 
						//И ЗначениеЗаполнено(РодительПриемника)
						И РодительПриемника <> "ЭтаФорма"
						И РодительПриемника <> "ЭтотОбъект")) 
			Тогда
				КлючПоиска = Новый Структура;
				КлючПоиска.Вставить("ТипСлова", "Свойство");
				КлючПоиска.Вставить("Слово", ПоследнееСловоПриемника); // В закэшированных наборах НСлово может отсутствовать, например Глобальный-ЗначениеВЗапросе
				Если ЗначениеЗаполнено(мИмяОжидаемогоТипа) Тогда
					КлючПоиска.Вставить("ТипЗначенияИндекс", мИмяОжидаемогоТипа); 
				КонецЕсли;
				ОбозначитьСловоСОжидаемымТипомВТаблицеСлов(КлючПоиска, НаборыСлов, КлючОсновногоНабора,, 4);
				ЛиПриемникЧерезЭтотОбъект = Ложь;
			Иначе
				ЛиПриемникЧерезЭтотОбъект = Истина;
			КонецЕсли;
			МаксТиповПроверять = 3;
			ЧислоПроверенныхТипов = 0;
			ЛиМногоСлов = ОбщееЧислоСлов > 100;
			Для Каждого ИмяТипа Из ВсеИменаТипов Цикл
				Если ИмяТипа = "Неопределено" Тогда
					Продолжить;
				КонецЕсли;
				ИмяТипа = ирОбщий.ПервыйФрагментЛкс(ИмяТипа, "(");
				ЗапретитьНепохожиеСлова = Ложь
					Или ЛиПримитивныйТип(ИмяТипа)
					Или ИмяТипа = "Массив"
					Или ИмяТипа = "СписокЗначений"
					Или ИмяТипа = "Структура"
					Или ИмяТипа = "ТаблицаЗначений"
					Или ИмяТипа = "СтрокаТаблицыЗначений"
					Или ИмяТипа = "ДанныеФормыСтруктура"
					Или ИмяТипа = "ДанныеФормыКоллекция"
					Или ИмяТипа = "ДанныеФормыЭлементКоллекции";
				КлючПоиска = Новый Структура;
				КлючПоиска.Вставить("ТипЗначенияИндекс", ИмяТипа); 
				//Если ЛиПриемникЧерезЭтотОбъект Тогда
					КромеСлова = ПоследнееСловоПриемника;
				//Иначе
				//	КромеСлова = "";
				//КонецЕсли;
				ОбозначитьСловоСОжидаемымТипомВТаблицеСлов(КлючПоиска, НаборыСлов, КлючОсновногоНабора, КромеСлова,, ПоследнееСловоПриемника, ЗапретитьНепохожиеСлова);
				ЧислоПроверенныхТипов = ЧислоПроверенныхТипов + 1;
				Если ЧислоПроверенныхТипов = МаксТиповПроверять Тогда
					Прервать;
				КонецЕсли;
			КонецЦикла;
			ЛиПримитивныйТип = ЛиПримитивныйТип(мИмяОжидаемогоТипа);
			Если Истина
				И ЗначениеЗаполнено(мИмяОжидаемогоТипа) 
				И Не ЛиПримитивныйТип
				И ПустаяСтрока(мРодительскийКонтекст)
			Тогда
				//ЛиСозданиеКолонки = ирОбщий.СтрКончаетсяНаЛкс(мВызовМетода, ".Колонки.Добавить(");
				КлючПоиска = Новый Структура("НСлово, ЯзыкПрограммы, ЕстьКонструктор");
				КлючПоиска.ЯзыкПрограммы = 0;
				КлючПоиска.ЕстьКонструктор = Истина;
				УровеньРейтинга = 2;
				Для Каждого ИмяТипа Из ВсеИменаТипов Цикл
					ИмяТипа = ирОбщий.ПервыйФрагментЛкс(ИмяТипа, "[");
					КлючПоиска.НСлово = НРег(ИмяТипа);
					Если Ложь
						Или мПлатформа.ТаблицаОбщихТипов.НайтиСтроки(КлючПоиска).Количество() = 0 
						Или мЭтоКонструктор И мВызовМетода = "Структура("
					Тогда
						Продолжить;
					КонецЕсли;
					Если Истина
						//И ЛиСозданиеКолонки
						И ИмяТипа = "ОписаниеТипов"
					Тогда
						СтрокаСлова = мПлатформа.ДобавитьВТаблицуСлов(ТаблицаСлов, "Новый " + ИмяТипа + "(""Строка"")", "Конструкция",,,, Ложь,, Истина);
						СтрокаСлова.Рейтинг = УровеньРейтинга * ШагРейтингаСлова;
						СтрокаСлова = мПлатформа.ДобавитьВТаблицуСлов(ТаблицаСлов, "Новый " + ИмяТипа + "(""Число"")", "Конструкция",,,, Ложь,, Истина);
						СтрокаСлова.Рейтинг = УровеньРейтинга * ШагРейтингаСлова;
						СтрокаСлова = мПлатформа.ДобавитьВТаблицуСлов(ТаблицаСлов, "Новый " + ИмяТипа + "(""Булево"")", "Конструкция",,,, Ложь,, Истина);
						СтрокаСлова.Рейтинг = УровеньРейтинга * ШагРейтингаСлова;
					КонецЕсли;
					СтрокаСлова = мПлатформа.ДобавитьВТаблицуСлов(ТаблицаСлов, "Новый " + ИмяТипа, "Конструкция",,,, Ложь,, Истина);
					Если Ложь
						// Эти типы могут создаваться конструктором в готовом виде
						Или ИмяТипа = "Структура"
						Или ИмяТипа = "ПолеКомпоновкиДанных"
						Или ИмяТипа = "ПараметрКомпоновкиДанных"
						Или ИмяТипа = "ОписаниеТипов"
						Или ИмяТипа = "ОписаниеОповещения"
						Или ИмяТипа = "МенеджерВременныхТаблиц"
						Или ИмяТипа = "КвалификаторыДаты"
						Или ИмяТипа = "КвалификаторыДвоичныхДанных"
						Или ИмяТипа = "КвалификаторыСтроки"
						Или ИмяТипа = "КвалификаторыЧисла"
						Или ИмяТипа = "УникальныйИдентификатор"
						Или ИмяТипа = "ФиксированныйМассив"
						Или ИмяТипа = "ФиксированнаяСтруктура"
						Или ИмяТипа = "ФиксированноеСоответствие"
					Тогда
						СтрокаСлова.Рейтинг = УровеньРейтинга * ШагРейтингаСлова;
					КонецЕсли;
				КонецЦикла;
				Если Истина
					И ЗначениеЗаполнено(ИменаВложенныхТипов) 
					И ИменаВложенныхТипов.Количество() < 10
				Тогда
					УжеДобавленные = Новый Соответствие;
					Для Каждого ИмяТипа Из ИменаВложенныхТипов Цикл
						Если Ложь
							Или ИмяТипа = "Произвольный" 
							Или ИмяТипа = "Неопределено" 
						Тогда
							Продолжить;
						КонецЕсли;
						ОписаниеРасширенногоТипа = мПлатформа.ОписаниеРасширенногоТипа(ИмяТипа);
						Если ОписаниеРасширенногоТипа <> Неопределено Тогда
							ИмяТипа = ОписаниеРасширенногоТипа.ОсновнойТип;
						КонецЕсли;
						Если УжеДобавленные[ИмяТипа] <> Неопределено Тогда
							Продолжить;
						КонецЕсли;
						УжеДобавленные[ИмяТипа] = 1;
						СтрокаСлова = мПлатформа.ДобавитьВТаблицуСлов(ТаблицаСлов, "Тип(""" + ИмяТипа + """)", "Конструкция",, "Тип",, Ложь);
						СтрокаСлова.Рейтинг = 3 * ШагРейтингаСлова;
						СтрокаСлова.НСлово = НРег(СтрокаСлова.Слово);
					КонецЦикла;
				КонецЕсли;
				Если Истина
					И мЯзыкПрограммы > 0
					И ирОбщий.ЛиКорневойТипСсылкиЛкс(ТипТаблицы)
				Тогда
					СтрокаСлова = мПлатформа.ДобавитьВТаблицуСлов(ТаблицаСлов, "ЗНАЧЕНИЕ(" + мИмяОжидаемогоТипа + ".ПустаяСсылка)", "Конструкция",, мИмяОжидаемогоТипа,, Ложь);
					СтрокаСлова.Рейтинг = 2 * ШагРейтингаСлова;
					СтрокаСлова.НСлово = НРег(СтрокаСлова.Слово);
				КонецЕсли;
				Если мЯзыкПрограммы = 1 Тогда
					ИмяЛевойТаблицы = НРег(ирОбщий.ПервыйФрагментЛкс(ВыражениеПриемник));
					ТекстДляПоискаОпределения = "";
					НачалоЧастиОбъединенияЗапроса(мТекстДляПоискаОпределения, мПозицияВБлоке,, ТекстДляПоискаОпределения);
					Вхождения = ирОбщий.НайтиРегВыражениеЛкс(ТекстДляПоискаОпределения, "\s(?:ИЗ|FROM)\s",, Ложь,,,, Истина);
					Если ЗначениеЗаполнено(Вхождения) Тогда
						ПараметрыЗаполнения = мПлатформа.НовыеПараметрыЗаполненияСлов(,, мЯзыкПрограммы);
						ПоследняяВыбраннаяТаблица = ирОбщий.НайтиРегВыражениеЛкс(Сред(ТекстДляПоискаОпределения, Вхождения[0].ПозицияВхождения), "(" + шИмяСТочками + ")\s+(?:КАК|AS)\s+(" + шИмя + ")");
						Для Индекс = 1 - ПоследняяВыбраннаяТаблица.Количество() По 0 Цикл // Обратный обход
							ПоследнееВхождение = ПоследняяВыбраннаяТаблица[-Индекс];
							ИмяПравойТаблицы = ПоследнееВхождение.Группы[1];
							Если НРег(ИмяПравойТаблицы) = ИмяЛевойТаблицы Тогда
								Продолжить;
							КонецЕсли;
							ТаблицаТиповВыбраннойТаблицы = ВычислитьТипЗначенияВыражения(ПоследнееВхождение.Группа0);
							Если ЗначениеЗаполнено(ТаблицаТиповВыбраннойТаблицы) Тогда
								ТаблицаДочернихСлов = мПлатформа.ТаблицаСловИзСтруктурыТипа(ТаблицаТиповВыбраннойТаблицы[0], ПараметрыЗаполнения);
								ЗаполнитьТипыЗначенийСлов(ТаблицаДочернихСлов,, Истина);
								КлючПоиска = Новый Структура("ТипЗначения", мИмяОжидаемогоТипа);
								НайденныеДочерние = ТаблицаДочернихСлов.НайтиСтроки(КлючПоиска);
								Для Каждого СтрокаДочерняя Из НайденныеДочерние Цикл
									СтрокаСлова = мПлатформа.ДобавитьВТаблицуСлов(ТаблицаСлов, ИмяПравойТаблицы + "." + СтрокаДочерняя.Слово, "Конструкция",, мИмяОжидаемогоТипа,, Ложь);
									СтрокаСлова.Рейтинг = 2 * ШагРейтингаСлова;
									СтрокаСлова.НСлово = НРег(СтрокаСлова.Слово);
								КонецЦикла;
							КонецЕсли;
						КонецЦикла;
					КонецЕсли;
				КонецЕсли;
				Если ЗначениеЗаполнено(ИмяКонструктораЛокальное) Тогда
					// Функция-конструктор
					СтрокаСлова = мПлатформа.ДобавитьВТаблицуСлов(ТаблицаСлов, ПолноеИмяМетода(ЛучшаяСтрокаТипа.СтрокаОписания, Истина), "Метод",,, "Метаданные", Ложь);
					СтрокаСлова.Рейтинг = 2 * ШагРейтингаСлова;
					СтрокаСлова.НСлово = НРег(СтрокаСлова.Слово);
				КонецЕсли;
			КонецЕсли;
			Если Истина
				И ЗначениеЗаполнено(мИмяОжидаемогоТипа)
				И Не ЛиПримитивныйТип
				И ТаблицаСлов.Количество() < КонстантаМаксСловПроверятьДляОжидаемогоТипа() 
			Тогда
				// Для малых наборов слов проверяем вхождение подстроки в каждое слово
				_РежимОтладки = Ложь;
				Если _РежимОтладки Тогда // Можно менять на Истина в точке останова, например условием ирОбщий.Пр(_РежимОтладки, 1, 1)
					// Пассивный оригинал расположенного ниже однострочного кода. Выполняйте изменения синхронно в обоих вариантах.
					Для Каждого СтрокаСлова Из ТаблицаСлов Цикл
						Если Истина
							И Найти(СтрокаСлова.ТипЗначения, мИмяОжидаемогоТипа) > 0
							И (Ложь
								Или Не ЛиПриемникЧерезЭтотОбъект
								Или СтрокаСлова.НСлово <> НРег(ПоследнееСловоПриемника))
						Тогда
							УстановитьРейтингВСтрокеСлова(СтрокаСлова, 2, Ложь);
						КонецЕсли;
					КонецЦикла;
				Иначе
					// Однострочный код использован для ускорения при разрешенной отладке. Выше расположен оригинал. Выполняйте изменения синхронно в обоих вариантах. Преобразовано консолью кода из подсистемы "Инструменты разработчика"
					Для Каждого СтрокаСлова Из ТаблицаСлов Цикл  						Если Истина  							И Найти(СтрокаСлова.ТипЗначения, мИмяОжидаемогоТипа) > 0  							И (Ложь  								Или Не ЛиПриемникЧерезЭтотОбъект  								Или СтрокаСлова.НСлово <> НРег(ПоследнееСловоПриемника))  						Тогда  							УстановитьРейтингВСтрокеСлова(СтрокаСлова, 2, Ложь);  						КонецЕсли;  					КонецЦикла;  
				КонецЕсли;
			КонецЕсли;
		КонецЕсли;
	КонецЕсли;
	//Если Истина
	//	И ОтделятьБольшиеНаборыСлов
	//	И ЛиПримитивныйТип
	//Тогда
	//	мИмяОжидаемогоТипа = "";
	//КонецЕсли;
КонецПроцедуры

Функция СловоГенераторКодаЗаполненияСвойств() Экспорт
	Возврат "<Заполнить свойства>";
КонецФункции

Функция СловоГенераторКодаСопоставитьСвойства() Экспорт
	Возврат "<Сопоставить свойства>";
КонецФункции

Функция СловоГенераторКодаОбходРезультатаЗапроса() Экспорт
	Возврат "<Выбрать по группировкам>";
КонецФункции 

Функция СловоГенераторКодаУдалитьВыбранныеЭлементы() Экспорт
	Возврат "<Удалить выбранные элементы>";
КонецФункции

Функция СловоГенераторКодаОбойтиЭлементы() Экспорт
	Возврат "<Обойти элементы>";
КонецФункции

Функция ЛиПримитивныйТип(Знач ИмяТипа) Экспорт
	Возврат Ложь
		Или ИмяТипа = "Неопределено"
		Или ИмяТипа = "Булево"
		Или ИмяТипа = "Строка"
		Или ИмяТипа = "Число"
		Или ИмяТипа = "Дата"
		Или ИмяТипа = "Null";
КонецФункции

//.
// Параметры:
//    ЭтоСсылочныйЛитерал - Булево - 
Функция РассчитатьОжидаемыйТипВыражения(ЭтоСсылочныйЛитерал = Неопределено, Знач РазрешитьДолгийРасчет = Ложь) Экспорт
	мСтрокаЛучшегоСлова = Неопределено;
	мИмяОжидаемогоТипа = "";
	ИменаВложенныхТипов = Неопределено;
	ВыражениеПриемник = "";
	Если Ложь
		Или мПлатформа.мРежимПроверкиМодуля
		Или (Истина
			И ТаблицаСлов.Количество() < 2 
			И Не ЗначениеЗаполнено(мНаборыСлов))
	Тогда
		Возврат Неопределено;
	КонецЕсли;
	ТаблицаОжидаемыхТипов = Неопределено;
	СтараяПозиция = мПозицияВТексте;  
	МаркерСсылочногоЛитерала = "";
	Если мСтруктураТипаКонтекста.ТипЯзыка = "ЗначениеВЗапросе" Тогда
		МаркерСсылочногоЛитерала = "ЗНАЧЕНИЕ(" + мНачалоКонтекста;
	ИначеЕсли мЯзыкПрограммы = 0 Тогда
		МаркерСсылочногоЛитерала = "ПредопределенноеЗначение(""" + мНачалоКонтекста;
	ИначеЕсли мЭтоТекстовыйЛитерал Тогда
		Возврат Неопределено;
	КонецЕсли; 
	ЭтоСсылочныйЛитерал = Ложь;
	Если Истина
		И ЗначениеЗаполнено(МаркерСсылочногоЛитерала)
		И ирОбщий.СтрКончаетсяНаЛкс(мТекущаяСтрокаНачало, МаркерСсылочногоЛитерала) 
	Тогда
		НоваяПозиция = СтараяПозиция - СтрДлина(МаркерСсылочногоЛитерала);
		УстановитьГраницыВыделения(НоваяПозиция, НоваяПозиция,,, Ложь);
		РазобратьТекущийКонтекст(,,,,, Истина, НоваяПозиция);
		ЭтоСсылочныйЛитерал = Истина;
	КонецЕсли;
	РазрешитьМногоТипов = Ложь;
	ДлинаПредТекста = 200;
	ПредшествующийТекст = Прав(СокрП(мПредшествующийТекст), ДлинаПредТекста);
	Если Ложь
		Или мКэшОжидаемогоТипа = Неопределено
		Или ПредшествующийТекст <> мКэшОжидаемогоТипа.ПредшествующийТекст
		Или мКэшОжидаемогоТипа.ЛиДинамическоеСвойство
		Или РазрешитьДолгийРасчет
	Тогда
		МаркерНовый = "Новый";
		ДлинаОтрезаемогоКонца = 0;
		Если ирОбщий.СтрКончаетсяНаЛкс(ПредшествующийТекст, МаркерНовый, Ложь) Тогда
			ДлинаОтрезаемогоКонца = СтрДлина(МаркерНовый);
		Иначе
			Пока ирОбщий.ЛиЦифраЛкс(Сред(ПредшествующийТекст, ДлинаПредТекста - ДлинаОтрезаемогоКонца, 1)) Цикл
				ДлинаОтрезаемогоКонца = ДлинаОтрезаемогоКонца + 1;
			КонецЦикла;
		КонецЕсли;
		Если ДлинаОтрезаемогоКонца > 0 Тогда
			ПредшествующийТекст = СокрЛП(ирОбщий.СтрокаБезКонцаЛкс(ПредшествующийТекст, ДлинаОтрезаемогоКонца));
		КонецЕсли;
		ДлинаПредТекста = СтрДлина(ПредшествующийТекст);
		Если мЭтоТекстовыйЛитерал Тогда
			ПредшествующийТокен = """"; // чтобы внутри кавычек перечисление слов через запятую учитывалось
		ИначеЕсли ирОбщий.СтрКончаетсяНаЛкс(ПредшествующийТекст, "<>") Тогда
			ПредшествующийТокен = "<>";
		Иначе
			ПредшествующийТокен = Прав(ПредшествующийТекст, 1);
		КонецЕсли;
		Если ПредшествующийТокен = "," Или ПредшествующийТокен = "(" Тогда
			СтруктураВызова = ТекущийВызовМетода(,, Истина);
			Если ЗначениеЗаполнено(мВызовМетода) Тогда
				ТаблицаТиповВызова = ВычислитьТипЗначенияВыражения(мВызовМетода + ИмяФиктивногоПараметра() + ")",,,, мЭтоКонструктор,,,,,,, мПозицияВБлоке);
				Если ТаблицаТиповВызова.Количество() > 0 Тогда
					ТаблицаОжидаемыхТипов = ТаблицаОжидаемыхТиповПараметраМетода(ТаблицаТиповВызова[0], ВыражениеПриемник, СтруктураВызова.ВыражениеПриемник,, РазрешитьДолгийРасчет);
					Если Истина
						И ТаблицаОжидаемыхТипов <> Неопределено
						И ТаблицаОжидаемыхТипов.Найти("Тип", "ИмяОбщегоТипа") <> Неопределено
						И ЛиИмяМетодаВозвращающегоЗначениеТипаИзПараметра(мИмяМетодаВызова) 
					Тогда
						ИменаВложенныхТипов = ТаблицаТиповВызова.ВыгрузитьКолонку("ИмяОбщегоТипа");
					КонецЕсли;
				КонецЕсли;
			КонецЕсли; 
		ИначеЕсли Ложь
			Или ПредшествующийТокен = "=" 
			Или ПредшествующийТокен = "<>" 
		Тогда
			ШаблонРазбора = "(?:^|\s)(" + шПростоеВыражениеПрограммы + ")\s*\" + ПредшествующийТокен + "$";
			ВыражениеПриемник = РассчитатьИмяОжидаемогоТипа(ШаблонРазбора, ПредшествующийТекст, ДлинаПредТекста,, ТаблицаОжидаемыхТипов, ИменаВложенныхТипов);
		ИначеЕсли ПредшествующийТокен = "[" Тогда
			ШаблонРазбора = "(?:^|\s)(" + шПростоеВыражениеПрограммы + ")\s*\" + ПредшествующийТокен + "$";
			мРегВыражение.Pattern = ШаблонРазбора;
			Вхождения = мРегВыражение.НайтиВхождения(ПредшествующийТекст);
			Если Вхождения.Количество() > 0 Тогда
				ВыражениеПриемник = Вхождения[0].SubMatches(0);
				ТаблицаТиповКоллекции = ВычислитьТипЗначенияВыражения(ВыражениеПриемник,,,,,,,,,,, мПозицияВБлоке,, ИмяФиктивногоСвойства());
				ВыражениеПриемник = ВыражениеПриемник + ".ИмяКлючИндекс"; // Сборка всех частых имен ключевого свойства коллекции, чтобы потом нечетким сравнением лучше подбирать приемники
				Если ТаблицаТиповКоллекции.Количество() > 0 Тогда
					СтруктураТипаКоллекции = ТаблицаТиповКоллекции[0];
					Если ирОбщий.СтрКончаетсяНаЛкс(СтруктураТипаКоллекции.ИмяОбщегоТипа, "Соответствие") Тогда
						ТаблицаТиповЭлементов = мПлатформа.ТаблицаТиповЭлементовКоллекции(СтруктураТипаКоллекции);
						Если Истина
							И ЗначениеЗаполнено(ТаблицаТиповЭлементов) 
							И ТаблицаТиповЭлементов[0].Метаданные <> Неопределено
						Тогда
							ТаблицаОжидаемыхТипов = ТаблицаТиповЭлементов[0].Метаданные.Ключ;
						КонецЕсли;
					КонецЕсли;
					КлючПоискаСвойств = Новый Структура("ТипКонтекста, ЯзыкПрограммы, ТипЯзыка", СтруктураТипаКоллекции.ИмяОбщегоТипа, ЯзыкПрограммы, СтруктураТипаКоллекции.ТипЯзыка);
					Если мПлатформа.ТаблицаШаблоновКонтекстов.НайтиСтроки(КлючПоискаСвойств).Количество() > 0 Тогда
						ТаблицаОжидаемыхТипов = мПлатформа.ДобавитьВТаблицуТипов(ТаблицаОжидаемыхТипов, НоваяСтруктураТипа("Строка"));
					КонецЕсли;
					ТаблицаТиповИндекса = ВычислитьТипДочернегоЭлемента(ТаблицаТиповКоллекции, "Получить", "Метод");
					Если ЗначениеЗаполнено(ТаблицаТиповИндекса) Тогда
						ТаблицаОжидаемыхТипов = мПлатформа.ДобавитьВТаблицуТипов(ТаблицаОжидаемыхТипов, НоваяСтруктураТипа("Число"));
					КонецЕсли;
				КонецЕсли;
			КонецЕсли;
		ИначеЕсли Истина
			И мЯзыкПрограммы > 0
			И (Ложь
				Или ирОбщий.СтрКончаетсяНаЛкс(ПредшествующийТекст, "ТОГДА") 
				Или ирОбщий.СтрКончаетсяНаЛкс(ПредшествующийТекст, "ИНАЧЕ"))
		Тогда
			ШаблонРазбора = "\sТОГДА\s+(" + шПростоеВыражениеПрограммы + ")\s+" + шИмя + "$";
			ВыражениеПриемник = РассчитатьИмяОжидаемогоТипа(ШаблонРазбора, ПредшествующийТекст, ДлинаПредТекста,, ТаблицаОжидаемыхТипов, ИменаВложенныхТипов);
		ИначеЕсли Истина
			И мЯзыкПрограммы > 0
			И ирОбщий.СтрКончаетсяНаЛкс(ПредшествующийТекст, " КАК") 
			И ирОбщий.СтрНайтиЛкс(мТекущаяСтрокаНачало, "ВЫРАЗИТЬ(",,,, Ложь) 
		Тогда
			ШаблонРазбора = "\sВЫРАЗИТЬ\((" + шПростоеВыражениеПрограммы + ")\s+КАК$";
			ВыражениеПриемник = РассчитатьИмяОжидаемогоТипа(ШаблонРазбора, ПредшествующийТекст, ДлинаПредТекста,, ТаблицаОжидаемыхТипов, ИменаВложенныхТипов);
		ИначеЕсли Истина
			И мЯзыкПрограммы > 0
			И ирОбщий.СтрКончаетсяНаЛкс(ПредшествующийТекст, " ССЫЛКА") 
		Тогда
			ШаблонРазбора = шПредИмяПрямое + "(" + шПростоеВыражениеПрограммы + ")\s+ССЫЛКА$";
			ВыражениеПриемник = РассчитатьИмяОжидаемогоТипа(ШаблонРазбора, ПредшествующийТекст, ДлинаПредТекста,, ТаблицаОжидаемыхТипов, ИменаВложенныхТипов);
		ИначеЕсли Истина
			И ПредшествующийТокен = """" 
			И ирОбщий.СтрокиРавныЛкс(мВызовМетода, "Тип(")
		Тогда
			ШаблонРазбора = "\s(" + шПростоеВыражениеПрограммы + ")\s*(?:=|<>)\s*" + ирОбщий.ТекстДляРегВыраженияЛкс(мВызовМетода + """") + "$";
			ВыражениеПриемник = РассчитатьИмяОжидаемогоТипа(ШаблонРазбора, ПредшествующийТекст, ДлинаПредТекста, Истина, ТаблицаОжидаемыхТипов, ИменаВложенныхТипов);
			РазрешитьМногоТипов = Истина;
		//ИначеЕсли ирОбщий.НайтиРегВыражениеЛкс(ПредшествующийТекст, шРазделитель + "(Не|Или|И)\s+$",, Ложь).Количество() Тогда
			//	мИмяОжидаемогоТипа = "Булево";
		ИначеЕсли Истина
			И мЯзыкПрограммы = 0
			И ирОбщий.СтрКончаетсяНаЛкс(ПредшествующийТекст, " цикл") 
		Тогда
			// При вводе новой первой инструкции цикла даем приоритет итератору цикла
			мРегВыражение.Pattern = "Для\s+Каждого\s+(" + шИмя + ")\s+Из\s+" + шОбъектноеВыражение + "\s+Цикл$";
			ТекстовыйДокумент = Новый ТекстовыйДокумент;
			ТекстовыйДокумент.УстановитьТекст(ПредшествующийТекст);
			Вхождения = мРегВыражение.НайтиВхождения(ТекстовыйДокумент.ПолучитьСтроку(ТекстовыйДокумент.КоличествоСтрок()));
			Если Вхождения.Количество() Тогда
				ИмяПеременной = Вхождения[0].SubMatches(0);
				Если ирОбщий.ЛиИмяПеременнойЛкс(ИмяПеременной) Тогда
					ВыражениеПриемник = ИмяПеременной;
				КонецЕсли;
			КонецЕсли;
		ИначеЕсли мЯзыкПрограммы = 1 Тогда
			ЧистыйТекст = ирОбщий.ПоследнийФрагментЛкс(СокрП(мТекущаяСтрокаНачало), "|");
			Выражение = ирОбщий.ПоследнийФрагментЛкс(ЧистыйТекст, Символы.Таб, Ложь);
			Если Не ЗначениеЗаполнено(Выражение) Тогда
				Выражение = ирОбщий.ПоследнийФрагментЛкс(ЧистыйТекст, " ", Ложь);
			КонецЕсли;
			Если Истина
				И Не ирОбщий.СтрКончаетсяНаЛкс(мТекущаяСтрокаНачало, Выражение) // Хотя бы один пробел в конце должен быть
				И ирОбщий.ЛиТаблицаБДСуществуетЛкс(Выражение) 
			Тогда
				мИмяОжидаемогоТипа = "КАК";
			КонецЕсли;
		КонецЕсли;
		мКэшОжидаемогоТипа = КэшОжидаемогоТипа(ТаблицаОжидаемыхТипов, ВыражениеПриемник, РазрешитьМногоТипов, ПредшествующийТокен, ИменаВложенныхТипов, ПредшествующийТекст);
	Иначе
		мВызовМетода = мКэшОжидаемогоТипа.мВызовМетода;
		мНомерПараметра = мКэшОжидаемогоТипа.мНомерПараметра;
		мЭтоКонструктор = мКэшОжидаемогоТипа.мЭтоКонструктор;
		мИмяОжидаемогоТипа = мКэшОжидаемогоТипа.мИмяОжидаемогоТипа;
	КонецЕсли;
	Если СтараяПозиция <> мПозицияВТексте Тогда
		УстановитьГраницыВыделения(СтараяПозиция, СтараяПозиция);
		РазобратьТекущийКонтекст(,,,,, Истина, СтараяПозиция);
	КонецЕсли;
	Возврат мКэшОжидаемогоТипа;
КонецФункции

// Предварительно нужно вызывать ТекущийВызовМетода() или РазобратьТекущийКонтекст().
// Может менять позицию каретки в поле и контекст, т.к. зовет ВозможныеТекстовыеЗначенияВыраженияИзТекущегоМетода(). Безопаснее вызывать через копию компоненты с подменой ПолеТекста.
Функция ТаблицаОжидаемыхТиповПараметраМетода(Знач СтруктураТипаМетода, ВыражениеПриемник = Неопределено, Знач ПеременнаяКонструктора = "", Знач ВариантСинтаксиса = Неопределено, Знач РассчитатьТипПараметра = Ложь) Экспорт
	СтрокаОписанияМетода = СтруктураТипаМетода.СтрокаОписания; // см. мПлатформа.ТаблицаКонтекстов[0]
	ТаблицаОжидаемыхТипов = Неопределено;
	ВыражениеПриемник = ИмяПараметраВызоваМетода(СтрокаОписанияМетода, Ложь, ТаблицаОжидаемыхТипов, СтруктураТипаМетода, ВариантСинтаксиса, РассчитатьТипПараметра);
	ЛиСистемныйМетод = Истина
		И СтрокаОписанияМетода <> Неопределено
		И СтрокаОписанияМетода.Владелец().Колонки.Найти("ТипКонтекста") <> Неопределено;
	Если Истина
		И ЛиСистемныйМетод
		И СтрокаОписанияМетода.ТипКонтекста = "Запрос"
		И СтрокаОписанияМетода.Слово = "УстановитьПараметр"
		И мФактическиеПараметры.Количество()
		И мНомерПараметра = 2
	Тогда
		ИмяПараметраЗапроса = ирОбщий.ТекстИзВстроенногоЯзыкаЛкс(мФактическиеПараметры[0]);
		Если ирОбщий.ЛиИмяПеременнойЛкс(ИмяПараметраЗапроса) Тогда
			ВыражениеПриемник = ИмяПараметраЗапроса;
			ПостроительЗапроса = СтруктураТипаМетода.Метаданные; // ПостроительЗапроса
			ОписанияПараметров = мПлатформа.ПараметрыИзТекстаЗапроса(ПостроительЗапроса.Текст, Истина);
			ОписанияПараметров.Свойство(ИмяПараметраЗапроса, ТаблицаОжидаемыхТипов);
		КонецЕсли;
	ИначеЕсли Истина
		И ЛиСистемныйМетод
		И СтрокаОписанияМетода.ТипКонтекста = "ТаблицаЗначений"
		И СтрокаОписанияМетода.Слово = "Найти"
		И мФактическиеПараметры.Количество() > 1
		И мНомерПараметра = 1
	Тогда
		ИмяКолонки = ирОбщий.ТекстИзВстроенногоЯзыкаЛкс(мФактическиеПараметры[1]);
		Если ирОбщий.ЛиИмяПеременнойЛкс(ИмяКолонки) Тогда
			ВыражениеПриемник = ИмяКолонки; 
			Если ТипЗнч(СтруктураТипаМетода.Метаданные) = Тип("Структура") Тогда
				СтруктураТипаМетода.Метаданные.Свойство(ИмяКолонки, ТаблицаОжидаемыхТипов);
			ИначеЕсли ТипЗнч(СтруктураТипаМетода.Метаданные) = Тип("ТаблицаЗначений") Тогда
				Колонка = СтруктураТипаМетода.Метаданные.Колонки.Найти(ИмяКолонки);
				Если Колонка <> Неопределено Тогда
					ТаблицаОжидаемыхТипов = мПлатформа.ТаблицаТиповИзОписанияТипов(Колонка.ТипЗначения);
				КонецЕсли;
			КонецЕсли;
		КонецЕсли;
	ИначеЕсли Истина
		И ЛиСистемныйМетод
		И СтрокаОписанияМетода.ТипКонтекста = "ТабличнаяЧасть"
		И СтрокаОписанияМетода.Слово = "Найти"
		И мФактическиеПараметры.Количество() > 1
		И мНомерПараметра = 1
		И ТипЗнч(СтруктураТипаМетода.Метаданные) = Тип("ОбъектМетаданных")
	Тогда
		ИмяКолонки = ирОбщий.ТекстИзВстроенногоЯзыкаЛкс(мФактическиеПараметры[1]);
		Если ирОбщий.ЛиИмяПеременнойЛкс(ИмяКолонки) Тогда
			ВыражениеПриемник = ИмяКолонки; 
			Колонка = СтруктураТипаМетода.Метаданные.Реквизиты.Найти(ИмяКолонки);
			Если Колонка <> Неопределено Тогда
				ТаблицаОжидаемыхТипов = мПлатформа.ТаблицаТиповИзОписанияТипов(Колонка.Тип);
			КонецЕсли;
		КонецЕсли;
	ИначеЕсли Истина
		И ЛиСистемныйМетод
		И мЯзыкПрограммы = 1
		И СтрокаОписанияМетода.ТипКонтекста = "Глобальный"
		И СтрокаОписанияМетода.Слово = "ЕСТЬNULL"
		И мНомерПараметра = 2
	Тогда
		ТаблицаОжидаемыхТипов = ВычислитьТипЗначенияВыражения(мФактическиеПараметры[0],,,,,, Ложь);
	ИначеЕсли Истина
		И ЛиСистемныйМетод
		И СтрокаОписанияМетода.ТипКонтекста = "Структура"
		И (Ложь
			Или СтрокаОписанияМетода.Слово = "Вставить"
			Или СтрокаОписанияМетода.Слово = "По ключам и значениям"
			)
		И мФактическиеПараметры.Количество()
		И мНомерПараметра = 2
	Тогда
		ИмяКлюча = ирОбщий.ТекстИзВстроенногоЯзыкаЛкс(мФактическиеПараметры[0]);
		Если ирОбщий.ЛиИмяПеременнойЛкс(ИмяКлюча) Тогда
			ВыражениеПриемник = ИмяКлюча;
			Если мЭтоКонструктор Тогда
				Переменная = ПеременнаяКонструктора;
			Иначе
				Переменная = ирОбщий.ПервыйФрагментЛкс(мВызовМетода);
			КонецЕсли;
			Если ЗначениеЗаполнено(Переменная) Тогда
				ТаблицаВозможныхСлов = ВозможныеТекстовыеЗначенияВыраженияИзТекущегоМетода(Переменная,, "Структура",,, ИмяКлюча); // см. мПлатформа.НоваяТаблицаСлов()
				Если Истина
					И ТаблицаВозможныхСлов <> Неопределено
					И ТаблицаВозможныхСлов.Количество() > 0 
				Тогда
					СтрокаСлова = ТаблицаВозможныхСлов.Найти(ИмяКлюча, "Слово"); // TODO Нрег
					Если СтрокаСлова <> Неопределено Тогда
						ТаблицаОжидаемыхТипов = СтрокаСлова.ТаблицаТипов;
						Если Истина
							И СтрокаСлова.МожноУточнитьТип <> Ложь 
							И СтрокаСлова.ТаблицаТипов <> Неопределено
						Тогда
							ОбновитьТипЗначенияИзТаблицыТипов(СтрокаСлова,,, Истина);
							СтрокаСлова.МожноУточнитьТип = Ложь;
						КонецЕсли;
						мИмяОжидаемогоТипа = СтрокаСлова.ТипЗначения;
					КонецЕсли; 
				КонецЕсли;
			КонецЕсли;
		КонецЕсли;
	ИначеЕсли Истина
		И ЛиСистемныйМетод
		И СтрокаОписанияМетода.ТипКонтекста = "Массив"
		И СтрокаОписанияМетода.Слово = "Добавить"
	Тогда
		Если ТипЗнч(СтруктураТипаМетода.Метаданные) = Тип("ТаблицаЗначений") Тогда
			ТаблицаОжидаемыхТипов = СтруктураТипаМетода.Метаданные;  
		Иначе
			ТаблицаОжидаемыхТипов = СтруктураТипаМетода.Владелец(); // Опасно, т.к. это процедура и формально у нее нет типа значения. Можно заменить на новую таблицу
		КонецЕсли;
	ИначеЕсли Истина
		// БСП
		И Не ЛиСистемныйМетод
		И СтрокаОписанияМетода <> Неопределено
		//! СтрокаОписанияМетода = мПлатформа.НоваяТаблицаМетодовМодуля()[0] 
		И (Ложь
			Или СтрокаОписанияМетода.Имя = "ВыполнитьФункцию"
			Или СтрокаОписанияМетода.Имя = "ВыполнитьПроцедуру")
		И мФактическиеПараметры.Количество() > 1
		И мНомерПараметра > 2
	Тогда
		ВыражениеВызоваМетода = ирОбщий.ТекстИзВстроенногоЯзыкаЛкс(мФактическиеПараметры[1]) + "(" + ИмяФиктивногоПараметра() + ")";
		ТаблицаТипов = ВычислитьТипЗначенияВыражения(ВыражениеВызоваМетода,,,,,, Ложь);
		Если ТаблицаТипов.Количество() Тогда
			СтрокаМетода = ТаблицаТипов[0].СтрокаОписания; // см. мМетодМодуля
			ПараметрыМетода = мПлатформа.ПараметрыМетодаМодуля(СтрокаМетода);
			Если ПараметрыМетода <> Неопределено Тогда
				ЗагрузитьМетодМодуля(СтрокаМетода);
				ИндексПараметра = мНомерПараметра - 3;
				Если ПараметрыМетода.Количество() > ИндексПараметра Тогда
					СтрокаПараметра = ПараметрыМетода[ИндексПараметра];
					ВыражениеПриемник = СтрокаПараметра.Имя;
					ТаблицаОжидаемыхТипов = ВычислитьТипПараметраМетодаМодуля(ПараметрыМетода, СтрокаПараметра);
				КонецЕсли;
			КонецЕсли;
		КонецЕсли;
	КонецЕсли;
	Возврат ТаблицаОжидаемыхТипов;
КонецФункции

Функция РассчитатьИмяОжидаемогоТипа(Знач ШаблонРазбора, Знач НачалоПредТекста, Знач ДлинаПредТекста, Знач ЛиВложенныйТип = Ложь, выхТаблицаОжидаемыхТипов, выхИменаВложенныхТипов) Экспорт
	выхИменаВложенныхТипов = Неопределено;
	мИмяОжидаемогоТипа = Неопределено;
	мРегВыражение.Pattern = ШаблонРазбора;
	Вхождения = мРегВыражение.НайтиВхождения(НачалоПредТекста);
	Если Вхождения.Количество() > 0 Тогда
		ВыражениеПриемник = Вхождения[0].SubMatches(0);
		СтарыеТипы = Неопределено;
		Если ирОбщий.ЛиИмяПеременнойЛкс(ВыражениеПриемник) Тогда
			СтарыеТипы = СтарыеТипыПеременныхТекущегоМетода();
			ИмяСтарогоТипа = СтарыеТипы[Нрег(ВыражениеПриемник)];
			Если ИмяСтарогоТипа <> Неопределено Тогда
				мИмяОжидаемогоТипа = ИмяСтарогоТипа;
			КонецЕсли;
		ИначеЕсли ирОбщий.СтрНачинаетсяСЛкс(ВыражениеПриемник, "ТипЗнч(") Тогда
			//ВыражениеПриемник = ирОбщий.ТекстМеждуМаркерамиЛкс(ВыражениеПриемник, "(", ")");
			ЛиВложенныйТип = Истина;
		КонецЕсли; 
		Если мИмяОжидаемогоТипа = Неопределено Тогда
			//Если СтарыеТипы <> Неопределено Тогда
				ДляСвойства = ИмяФиктивногоСвойства();
			//Иначе
			//	ДляСвойства = ""; // Отключил для ускорения
			//КонецЕсли;
			Позиция0ВМетодеДо = мПозицияВБлоке + Вхождения[0].FirstIndex + Найти(Вхождения[0].Value, ВыражениеПриемник) - ДлинаПредТекста - 1; // Было -2
			Если Позиция0ВМетодеДо > 0 Тогда
				Если Истина
					И ВыражениеПриемник = ИмяПеременнойВозвращаемогоЗначения() 
					И мМетодМодуля <> Неопределено
				Тогда
					ТаблицаТипов = мПлатформа.ПодготовитьТипРезультатаМетода(мМетодМодуля, мМодульМетаданных,,, ДляСвойства);
				Иначе
					ТаблицаТипов = ВычислитьТипЗначенияВыражения(ВыражениеПриемник,,,,,,,,,,, Позиция0ВМетодеДо,, ДляСвойства);
				КонецЕсли;
				ИмяТипа = мПлатформа.ПредставлениеМассиваСтруктурТипов(ТаблицаТипов);
				Если СтарыеТипы <> Неопределено Тогда
					СтарыеТипы[Нрег(ВыражениеПриемник)] = ИмяТипа; // Жертвуем свежестью ради скорости
				КонецЕсли; 
				Если ЛиВложенныйТип Тогда
					мИмяОжидаемогоТипа = "Тип";
					выхИменаВложенныхТипов = Новый Массив;
					Если Истина
						И ЗначениеЗаполнено(ТаблицаТипов)
						И ТипЗнч(ТаблицаТипов[0].Метаданные) = Тип("ТаблицаЗначений") 
					Тогда
						Для Каждого СтрокаТипа Из ТаблицаТипов[0].Метаданные Цикл
							выхИменаВложенныхТипов.Добавить(мПлатформа.ИмяТипаИзСтруктурыТипа(СтрокаТипа, Ложь));
						КонецЦикла;
					КонецЕсли;
					ВыражениеПриемник = "";
				Иначе
					мИмяОжидаемогоТипа = ИмяТипа;
					выхТаблицаОжидаемыхТипов = ТаблицаТипов;
				КонецЕсли;
			КонецЕсли;
		КонецЕсли;
	КонецЕсли;
	Возврат ВыражениеПриемник;
КонецФункции

//.
// Параметры:
//    ТаблицаОжидаемыхТипов - см. мПлатформа.НоваяТаблицаТипов - 
//    ВыражениеПриемник - Строка - 
//    ИменаВложенныхТипов - Массив из Строка, Неопределено - 
// Возвращаемое значение:
//    Структура - 
Функция КэшОжидаемогоТипа(Знач ТаблицаОжидаемыхТипов, Знач ВыражениеПриемник, Знач РазрешитьМногоТипов, Знач ПредшествующийТокен, Знач ИменаВложенныхТипов, Знач ПредшествующийТекст) Экспорт
	Результат = Новый Структура;
	Результат.Вставить("ТаблицаОжидаемыхТипов", ТаблицаОжидаемыхТипов);
	Результат.Вставить("ВыражениеПриемник", ВыражениеПриемник);
	Результат.Вставить("мВызовМетода", мВызовМетода);
	Результат.Вставить("мНомерПараметра", мНомерПараметра);
	Результат.Вставить("мЭтоКонструктор", мЭтоКонструктор);
	Результат.Вставить("РазрешитьМногоТипов", РазрешитьМногоТипов);
	Результат.Вставить("мИмяОжидаемогоТипа", мИмяОжидаемогоТипа);
	Результат.Вставить("ПредшествующийТокен", ПредшествующийТокен);
	Результат.Вставить("ПредшествующийТекст", ПредшествующийТекст);
	Результат.Вставить("ИменаВложенныхТипов", ИменаВложенныхТипов);
	Результат.Вставить("ЛиДинамическоеСвойство", Ложь);
	Возврат Результат;
КонецФункции

//.
// Параметры:
//   КлючПоиска - Структура - если передавать тип, то в свойстве ТипЗначенияИндекс
//   НаборыСлов -  - 
//   КлючОсновногоНабора -  - 
//   КромеСлова -  - 
//   МножительРейтинга -  - 
//   НечеткийПоискПоСлову -  - 
//   ЗапретитьНепохожиеСлова -  - 
// Возвращаемое значение:
//    - 
Функция ОбозначитьСловоСОжидаемымТипомВТаблицеСлов(Знач КлючПоиска, Знач НаборыСлов, Знач КлючОсновногоНабора, Знач КромеСлова = "", Знач МножительРейтинга = 3, Знач НечеткийПоискПоСлову = "",
		Знач ЗапретитьНепохожиеСлова = Ложь) Экспорт
	ВариантыИмениТипа = Новый Массив;
	КлючПоискаБезТипа = ирОбщий.СкопироватьКоллекциюЛкс(КлючПоиска);
	КлючПоискаЦикл = КлючПоискаБезТипа;
	Если КлючПоиска.Свойство("ТипЗначенияИндекс") Тогда
		Если КлючПоиска.Количество() > 1 Тогда
			ВариантыИмениТипа.Добавить("*");  
			//! КлючПоискаБезТипа.Вставить("ТипЗначенияИндекс");
			КлючПоискаБезТипа.Удалить("ТипЗначенияИндекс");
		КонецЕсли;
		ИмяТипа = КлючПоиска.ТипЗначенияИндекс;
		Если ирОбщий.СтрНачинаетсяСЛкс(ИмяТипа, "РасширениеФормы") Тогда
			СтрокаРасширения = мПлатформа.ТаблицаРасширенийТипов.Найти(ИмяТипа, "Расширение");
			Если СтрокаРасширения <> Неопределено Тогда
				ИмяТипа = СтрокаРасширения.ОсновнойТип;
			КонецЕсли;
		ИначеЕсли ИмяТипа = "ФормаКлиентскогоПриложения" Тогда
			ВариантыИмениТипа.Добавить("РасширениеФормыКлиентскогоПриложенияДляСправочника");
			ВариантыИмениТипа.Добавить("РасширениеФормыКлиентскогоПриложенияДляДокумента");
			ВариантыИмениТипа.Добавить("РасширениеФормыКлиентскогоПриложенияДляДинамическогоСписка");
		ИначеЕсли ИмяТипа = "Форма" Тогда
			ВариантыИмениТипа.Добавить("РасширениеФормыЭлементаСправочника");
			ВариантыИмениТипа.Добавить("РасширениеФормыДокумента");
			ВариантыИмениТипа.Добавить("РасширениеФормыСпискаСправочника");
			ВариантыИмениТипа.Добавить("РасширениеФормыСпискаДокументов");
		КонецЕсли;
		ВариантыИмениТипа.Добавить(ИмяТипа); 
		//Если ЗначениеЗаполнено(НечеткийПоискПоСлову) Тогда
		//	ВариантыИмениТипа.Добавить("??");
		//КонецЕсли;
		//ВариантыИмениТипа.Добавить("??, " + ИмяТипа);
		//ВариантыИмениТипа.Добавить("??, " + ИмяТипа + ", Неопределено");
		//ВариантыИмениТипа.Добавить(ИмяТипа + ", Неопределено");
	Иначе
		ВариантыИмениТипа.Добавить("");
	КонецЕсли;
	СловоНайдено = Ложь;
	НечеткоеСравнениеСлов = Неопределено;
	Для Каждого КлючИЗначение Из НаборыСлов Цикл
		//Если Истина
		//	И ЗапретитьНепохожиеСлова
		//	И Найти(КлючИЗначение.Ключ, "Глобальный;") > 0
		//Тогда
		//	Продолжить;
		//КонецЕсли;
		//
		// Для больших наборов слов ищем первое точное совпадение
		Для Каждого ВариантИмениТипа Из ВариантыИмениТипа Цикл
			Если ВариантИмениТипа = "*" Тогда
				КлючПоискаЦикл = ирОбщий.СкопироватьКоллекциюЛкс(КлючПоискаБезТипа);
			ИначеЕсли ЗначениеЗаполнено(ВариантИмениТипа) Тогда
				КлючПоискаЦикл.Вставить("ТипЗначенияИндекс", ВариантИмениТипа);
			КонецЕсли;
			НаборСлов = КлючИЗначение.Значение;
			//: НаборСлов.НайтиСтроки(КлючПоиска)
			Найденные = НаборСлов.НайтиСтроки(КлючПоискаЦикл);
			Если Истина
				И КлючПоискаЦикл.Свойство("ТипЗначенияИндекс") 
				И Найденные.Количество() = 0 
				И Найти(ВариантИмениТипа, ".") = 0
				И мЯзыкПрограммы = 0
				И ВариантИмениТипа <> "Строка"
				И ВариантИмениТипа <> "Число"
				И ВариантИмениТипа <> "Булево"
				И ВариантИмениТипа <> "Массив"
				И ВариантИмениТипа <> "Структура"
			Тогда
				КлючПоискаПеречисления = ирОбщий.СкопироватьКоллекциюЛкс(КлючПоискаБезТипа);
				КлючПоискаПеречисления.Вставить("ТипЗначенияИндекс", "Перечисление" + ВариантИмениТипа);
				Найденные = НаборСлов.НайтиСтроки(КлючПоискаПеречисления);
			КонецЕсли;
			Если Истина
				И ЗначениеЗаполнено(КромеСлова) 
				И Найденные.Количество()
				И ирОбщий.СтрокиРавныЛкс(Найденные[0].Слово, КромеСлова)
				И Найденные[0].ТипСлова <> "Метод"
			Тогда
				Найденные.Удалить(0);
			КонецЕсли;
			Если Найденные.Количество() Тогда
				Прервать;
			КонецЕсли;
		КонецЦикла;
		Если Найденные.Количество() > 0 Тогда
			Если Истина
				И КлючПоиска.Свойство("ТипЗначенияИндекс")
				И КлючПоиска.Количество() > 1 
			Тогда
				УточнитьТипЗначенияВСтрокеТаблицыСлов(Найденные[0]);
				ТипыСовместимы = Ложь
					Или ирОбщий.СтрНайтиЛкс(Найденные[0].ТипЗначенияИндекс + ",", КлючПоиска.ТипЗначенияИндекс + ",")
					Или (Истина
						И ирОбщий.СтрНачинаетсяСЛкс(Найденные[0].ТипЗначенияИндекс, "РасширениеФормы")
						И ирОбщий.СтрНачинаетсяСЛкс(КлючПоиска.ТипЗначенияИндекс, "Форма")); 
				Если Не ТипыСовместимы Тогда
					Продолжить;
				КонецЕсли;
			КонецЕсли;
			Если ЗапретитьНепохожиеСлова Тогда
				СтрокаЛучшегоСлова = Неопределено;
			Иначе
				СтрокаЛучшегоСлова = Найденные[0];
			КонецЕсли;
			//ВключатьАвтоОткрытие = Истина;
			Если Истина
				И ЗначениеЗаполнено(НечеткийПоискПоСлову) 
				И Найденные.Количество() > 1
				И Найденные.Количество() < 100
			Тогда
				НечеткоеСравнениеСлов = мПлатформа.НечеткоеСравнениеСлов();
				КандидатыСхожести = ирОбщий.СтрСоединитьЛкс(Найденные,,,,, "Слово");
				Если ЗначениеЗаполнено(КромеСлова) Тогда
					КандидатыСхожести = СтрЗаменить(" " + КандидатыСхожести + ",", " " + КромеСлова + ",", " ,");
				КонецЕсли;
				Для УровеньНепохожести = 1 По 3 Цикл
					Если Ложь
						Или УровеньНепохожести = 2 И Найденные.Количество() > 70
						Или УровеньНепохожести = 3 И Найденные.Количество() > 40 
					Тогда
						Прервать;
					КонецЕсли;
					РезультатСравнения = НечеткоеСравнениеСлов.StringSearch(НечеткийПоискПоСлову, КандидатыСхожести, ",", 8, 20 * (5 - УровеньНепохожести) + 10, 20 * (5 - УровеньНепохожести));
					Если ЗначениеЗаполнено(РезультатСравнения) Тогда
						ИндексыПохожихСлов = ирОбщий.СтрРазделитьЛкс(РезультатСравнения, ",",, Ложь);
						СтрокаЛучшегоСлова = Найденные[Число(ИндексыПохожихСлов[0])];
						Прервать;
					КонецЕсли;
					Если ЗапретитьНепохожиеСлова Тогда
						МножительРейтинга = МножительРейтинга - 1;
					КонецЕсли;
				КонецЦикла;
			КонецЕсли;
			Если СтрокаЛучшегоСлова = Неопределено Тогда
				Продолжить;
			КонецЕсли;
			Если КлючИЗначение.Ключ <> КлючОсновногоНабора Тогда
				КлючПоиска1 = Новый Структура("НСлово, ТипСлова");
				КлючПоиска1.НСлово = НРег(СтрокаЛучшегоСлова.Слово);
				КлючПоиска1.ТипСлова = СтрокаЛучшегоСлова.ТипСлова;
				НоваяСтрока = ТаблицаСлов.НайтиСтроки(КлючПоиска1);
				Если НоваяСтрока.Количество() > 0 Тогда
					НоваяСтрока = НоваяСтрока[0];
				Иначе
					НоваяСтрока = ТаблицаСлов.Добавить();
					НоваяСтрока.НСлово = КлючПоиска1.НСлово;
				КонецЕсли;
				ЗаполнитьЗначенияСвойств(НоваяСтрока, СтрокаЛучшегоСлова);
				СтрокаЛучшегоСлова = НоваяСтрока;
			КонецЕсли;
			УстановитьРейтингВСтрокеСлова(СтрокаЛучшегоСлова, МножительРейтинга, МножительРейтинга > 1);
			СловоНайдено = Истина;
			Прервать;
		КонецЕсли;
	КонецЦикла;
	Возврат СловоНайдено;
КонецФункции

Процедура УстановитьРейтингВСтрокеСлова(Знач СтрокаСлова, Знач МножительРейтинга, Знач ВключатьАвтоОткрытие = Истина) Экспорт
	НовыйРетинг = СтрокаСлова.Рейтинг + МножительРейтинга * ШагРейтингаСлова();
	Если МножительРейтинга < 0 Или НовыйРетинг > СтрокаСлова.Рейтинг Тогда
		СтрокаСлова.Рейтинг = НовыйРетинг;
	КонецЕсли;
	Если Ложь
		Или мСтрокаЛучшегоСлова = Неопределено И ВключатьАвтоОткрытие И МножительРейтинга > 0
		Или мСтрокаЛучшегоСлова <> Неопределено И мСтрокаЛучшегоСлова.Рейтинг < СтрокаСлова.Рейтинг
	Тогда
		мСтрокаЛучшегоСлова = СтрокаСлова;
	КонецЕсли;
КонецПроцедуры

Функция КонстантаМаксСловПроверятьДляОжидаемогоТипа() Экспорт
	Возврат 200;
КонецФункции

Процедура ЗаполнитьСловаВНижнемРегистре()
	_РежимОтладки = Ложь;
	// 13мс на 1500 слов - в 2 раза быстрее чем иробщий.ОбновитьКопиюКолонкиВНижнемРегистреЛкс()
	Если _РежимОтладки Тогда // Можно менять на Истина в точке останова, например условием ирОбщий.Пр(_РежимОтладки, 1, 1)
		// Пассивный оригинал расположенного ниже однострочного кода. Выполняйте изменения синхронно в обоих вариантах.
		Для Каждого СтрокаСлова Из ТаблицаСлов Цикл
			СтрокаСлова.НСлово = НРег(СтрокаСлова.Слово);
		КонецЦикла;
	Иначе
		// Однострочный код использован для ускорения при разрешенной отладке. Выше расположен оригинал. Выполняйте изменения синхронно в обоих вариантах. Преобразовано консолью кода из подсистемы "Инструменты разработчика"
		Для Каждого СтрокаСлова Из ТаблицаСлов Цикл  			СтрокаСлова.НСлово = НРег(СтрокаСлова.Слово);  		КонецЦикла;  
	КонецЕсли;
КонецПроцедуры

// Меняет контекст!
//
// Параметры:
//  ВыбраннаяСтруктураТипа				 - СтрокаТаблицыЗначений, Неопределено	 - 
//  ЛиНаборЗначенийПолный	 - Булево								 - 
//  ИмяТипаСтруктуры	 - Строка - если пустое, то непосредственно литерал
// 
// Возвращаемое значение:
//   Массив, ТаблицаЗначений - 
//
Функция ЗаполнитьТаблицуВозможныхЗначенийЛитерала(Знач ВыбраннаяСтруктураТипа, ЛиНаборЗначенийПолный = Истина, Знач ИмяТипаСтруктуры = "", Знач ДобавлятьНизкоВероятные = Ложь,
		Знач ФильтроватьСлово = Неопределено) Экспорт
	Если ИмяТипаСтруктуры = "" Тогда
		КоллекцияЭлементовМД = Новый Массив;
	КонецЕсли;
	ЛиНаборЗначенийПолный = Истина;
	// Находимся внутри строкового литерала на позиции параметра
	СтрокаОписанияМетода = ВыбраннаяСтруктураТипа.СтрокаОписания;
	Если Истина
		И ИмяТипаСтруктуры = ""
		И ТипЗнч(СтрокаОписанияМетода) = Тип("СтрокаТаблицыЗначений")
		И СтрокаОписанияМетода.Владелец().Колонки.Найти("ТипСлова") <> Неопределено
		И (Ложь
			Или СтрокаОписанияМетода.ТипСлова = "Метод"
			Или СтрокаОписанияМетода.ТипСлова = "Конструктор")
	Тогда
		//! СтрокаОписанияМетода = мПлатформа.ТаблицаКонтекстов[0]
		Если СтрокаОписанияМетода.ТипСлова <> "Свойство" Тогда
			ИмяПараметра = ИмяПараметраВызоваМетода(СтрокаОписанияМетода);
			ИмяПеременнойСтруктуры = "";
			ИмяПеременнойПоляКомпоновки = "";
			Если Истина
				И мНомерПараметра = 1
				И мЭтоКонструктор
				И (Ложь
					Или мИмяМетодаВызова = "Структура"
					Или мИмяМетодаВызова = "ПолеКомпоновкиДанных"
					Или мИмяМетодаВызова = "Действие" И ИмяПараметра = "ИмяПроцедуры")
			Тогда 
				ПозицияОбрезки = ирОбщий.СтрНайтиЛкс(мТекущаяСтрокаНачало, "Новый " + мВызовМетода, Истина,,, Ложь) - 1;
				ТекущаяСтрокаНачало = мТекущаяСтрокаНачало;
				ТекущаяСтрокаКонец = мТекущаяСтрокаКонец;
				мТекущаяСтрокаНачало = Лев(мТекущаяСтрокаНачало, ПозицияОбрезки);
				мТекущаяСтрокаКонец = "";
				Если Прав(СокрП(мТекущаяСтрокаНачало), 1) = "=" Тогда
					// TODO переделать на ТекущийВызовМетода().ВыражениеПриемник
					Если мИмяМетодаВызова = "Структура" Тогда
						ИмяПеременнойСтруктуры = СокрЛП(ирОбщий.ПервыйФрагментЛкс(мТекущаяСтрокаНачало, "="));
					Иначе
						ВыражениеСлеваОтРавно = СокрЛП(ирОбщий.ПервыйФрагментЛкс(мТекущаяСтрокаНачало, "="));
						Если ЗначениеЗаполнено(ВыражениеСлеваОтРавно) Тогда
							Если Найти(ВыражениеСлеваОтРавно, ".") = 0 Тогда
								Если мИмяМетодаВызова = "ПолеКомпоновкиДанных" Тогда
									ИмяПеременнойПоляКомпоновки = ВыражениеСлеваОтРавно;
								КонецЕсли;
							Иначе
								ТаблицаТипов = ВычислитьТипЗначенияВыражения(ирОбщий.СтрокаБезПоследнегоФрагментаЛкс(ВыражениеСлеваОтРавно),,,,,, Ложь);
								Если ТаблицаТипов.Количество() > 0 Тогда
									Если ИмяПараметра = "ИмяПроцедуры" Тогда
										Если ТаблицаТипов[0].ДержательМетаданных <> Неопределено Тогда
											СтруктураТипаМодуля = мПлатформа.НоваяСтруктураТипа("Форма");
											СтруктураТипаМодуля.Метаданные = ТаблицаТипов[0].ДержательМетаданных;  
										КонецЕсли;
									Иначе
										ВыбраннаяСтруктураТипа.Метаданные = ТаблицаТипов[0].Метаданные;
									КонецЕсли;
								КонецЕсли;
							КонецЕсли;
						КонецЕсли;
					КонецЕсли;
					мТекущаяСтрокаНачало = ТекущаяСтрокаНачало;
					мТекущаяСтрокаКонец = ТекущаяСтрокаКонец;
				Иначе
					ТекущийВызовМетода(); // подменяет мИмяМетодаВызова
					мТекущаяСтрокаНачало = ТекущаяСтрокаНачало;
					мТекущаяСтрокаКонец = ТекущаяСтрокаКонец;
					Если ЗначениеЗаполнено(мВызовМетода) Тогда
						ТаблицаТиповОбрамляющегоВызова = ВычислитьТипЗначенияВыражения(мВызовМетода, мТекстДляПоискаОпределения, мПредшествующийТекст,,,, Ложь,,,,, 
								мПозицияВТексте - мПозицияТекстаДляПоискаОпределения - 1);
						Если ТаблицаТиповОбрамляющегоВызова.Количество() > 0 Тогда
							ЛучшийТип = ТаблицаТиповОбрамляющегоВызова[0];
							Если ИмяПараметра = "ИмяПроцедуры" Тогда
								Если ЛучшийТип.ДержательМетаданных <> Неопределено Тогда
									СтруктураТипаМодуля = мПлатформа.НоваяСтруктураТипа("Форма");
									СтруктураТипаМодуля.Метаданные = ЛучшийТип.ДержательМетаданных;  
								КонецЕсли;
							Иначе
								СтрокаМетода = ЛучшийТип.СтрокаОписания;
								Если ТипЗнч(СтрокаМетода) = Тип("СтрокаТаблицыЗначений") Тогда
									Если Истина
										И ИмяПараметра = "Ключи" // Структура
										И СтрокаМетода.Владелец().Колонки.Найти("ТелоБезВозвратов") <> Неопределено 
									Тогда
										КоллекцияЭлементовМД = ВозможныеТекстовыеЗначенияПараметраИзДругогоМетода(СтрокаМетода,, Ложь,, ФильтроватьСлово);
									Иначе
										Если ТаблицаТиповОбрамляющегоВызова[0].ИмяОбщегоТипа = "Массив" Тогда
											ТаблицаТиповОбрамляющегоВызова = ТаблицаТиповОбрамляющегоВызова[0].Метаданные;
										КонецЕсли;
										ЛучшийТип = ЛучшийТипИзТаблицыТипов(ТаблицаТиповОбрамляющегоВызова, 4);
										Если Истина
											И ЛучшийТип <> Неопределено 
											//И ЛучшийТип.СтрокаОписания.Владелец().Колонки.Найти("ТипСлова") <> Неопределено
											И ЛучшийТип.ИмяОбщегоТипа <> "ЭлементСпискаЗначений"
										Тогда
											ВыбраннаяСтруктураТипа.Метаданные = ЛучшийТип.Метаданные;
										КонецЕсли;
									КонецЕсли;
								КонецЕсли;
							КонецЕсли;
						КонецЕсли;
					КонецЕсли; 
				КонецЕсли;
			ИначеЕсли Истина
				И СтрокаОписанияМетода.ТипКонтекста = "Структура"
				И СтрокаОписанияМетода.Слово = "Вставить" 
				И ИмяПараметра = "Ключ"
				И СтрЧислоВхождений(мВызовМетода, ".") = 1
			Тогда
				ИмяПеременнойСтруктуры = ирОбщий.ПервыйФрагментЛкс(мВызовМетода);
			ИначеЕсли Истина
				И СтрокаОписанияМетода.ТипКонтекста = "Массив"
				И СтрокаОписанияМетода.Слово = "Добавить" 
				И СтрЧислоВхождений(мВызовМетода, ".") = 1
			Тогда
				ИмяПеременнойСтруктуры = ирОбщий.ПервыйФрагментЛкс(мВызовМетода);
			КонецЕсли;
			Если ЗначениеЗаполнено(ИмяПеременнойПоляКомпоновки) Тогда
				Вхождения = НайтиВхожденияРегВыраженияКэш(шПредИмяПрямое + "(" + шИмяСТочками + ")\.(?:(?:НайтиПоле\()|(?:(?:Левое|Правое)Значение|Поле)\s*=)\s*(" + шИмя + ")"
					,, мТекстДляПоискаОпределения, "ПолеКомпоновкиДанных");
				Для Каждого Вхождение Из Вхождения Цикл
					Если ЛиВхождениеВЗапрешенномДиапазоне(Вхождение, мПозицияВБлоке) Тогда
						Продолжить;
					КонецЕсли;
					Если Не ирОбщий.СтрокиРавныЛкс(Вхождение.SubMatches(1), ИмяПеременнойПоляКомпоновки) Тогда
						Продолжить;
					КонецЕсли;
					ТаблицаТипов = ВычислитьТипЗначенияВыражения(Вхождение.SubMatches(0),,,,,, Ложь);
					Если ТаблицаТипов.Количество() > 0 Тогда
						Для Каждого СтрокаТаблицы Из ТаблицаТипов Цикл
							Если ТипЗнч(СтрокаТаблицы.Метаданные) = Тип("КомпоновщикНастроекКомпоновкиДанных") Тогда
								ВыбраннаяСтруктураТипа.Метаданные = СтрокаТаблицы.Метаданные;
								Прервать;
							КонецЕсли;
						КонецЦикла;
					КонецЕсли;
					Прервать;
				КонецЦикла;
			КонецЕсли;
			Если СтрокаОписанияМетода.ТипКонтекста = "ПолеКомпоновкиДанных" Тогда
				КомпоновщикНастроек = Неопределено;
				Если ТипЗнч(ВыбраннаяСтруктураТипа.Метаданные) = Тип("КомпоновщикНастроекКомпоновкиДанных") Тогда
					КомпоновщикНастроек = ВыбраннаяСтруктураТипа.Метаданные;
				ИначеЕсли ТипЗнч(ВыбраннаяСтруктураТипа.Метаданные) = Тип("ДинамическийСписок") Тогда
					КомпоновщикНастроек = ВыбраннаяСтруктураТипа.Метаданные.КомпоновщикНастроек;
				КонецЕсли;
				Если КомпоновщикНастроек <> Неопределено Тогда
					РодительскоеДоступноеПоле = КомпоновщикНастроек.Настройки.ДоступныеПоляОтбора;
					Если ЗначениеЗаполнено(мРодительскийКонтекст) Тогда
						РодительскоеДоступноеПоле = РодительскоеДоступноеПоле.НайтиПоле(Новый ПолеКомпоновкиДанных(мРодительскийКонтекст));
					КонецЕсли;
					мТаблицаСловЛитерала = мПлатформа.НоваяТаблицаСлов();
					Для Каждого ДоступноеПоле Из РодительскоеДоступноеПоле.Элементы Цикл
						мПлатформа.ДобавитьВТаблицуСлов(мТаблицаСловЛитерала, ирОбщий.ПоследнийФрагментЛкс(ДоступноеПоле.Поле),, мПлатформа.ТаблицаТиповИзОписанияТипов(ДоступноеПоле.ТипЗначения),, "Метаданные");
					КонецЦикла;
				ИначеЕсли ТипЗнч(ВыбраннаяСтруктураТипа.Метаданные) = ирОбщий.ТипУправляемаяФормаЛкс() Тогда
					//! ВыбраннаяСтруктураТипа.Метаданные = 0 // ФормаКлиентскогоПриложения
					Если ирОбщий.СтрКончаетсяНаЛкс(ВыражениеСлеваОтРавно, ".Поле") Тогда
						мТаблицаСловЛитерала = мПлатформа.НоваяТаблицаСлов();
						Для Каждого ЭлементФормы Из ВыбраннаяСтруктураТипа.Метаданные.Элементы Цикл
							мПлатформа.ДобавитьВТаблицуСлов(мТаблицаСловЛитерала, ЭлементФормы.Имя,, мПлатформа.ТаблицаТиповИзЗначения(ЭлементФормы),, "Метаданные");
						КонецЦикла;
					Иначе
						КоллекцияЭлементовМД = СписокРеквизитовУправляемойФормы(ВыбраннаяСтруктураТипа.Метаданные, мРодительскийКонтекст);
					КонецЕсли;
				КонецЕсли;
			ИначеЕсли Истина
				И СтрокаОписанияМетода.ТипКонтекста = "РеквизитФормы" 
				И ИмяПараметра = "Путь"
				И ирОбщий.ЛиИмяТипаФормыЛкс(СтруктураТипаМодуля().ИмяОбщегоТипа)
			Тогда
				КоллекцияЭлементовМД = СписокРеквизитовУправляемойФормы(СтруктураТипаМодуля().Метаданные, мРодительскийКонтекст);
			ИначеЕсли Истина
				И СтрокаОписанияМетода.ТипКонтекста = "ФормаКлиентскогоПриложения" 
				И СтрокаОписанияМетода.Слово = "ПолучитьРеквизиты"
				И ИмяПараметра = "Путь"
				И ЗначениеЗаполнено(ВыбраннаяСтруктураТипа.Метаданные)
			Тогда
				КоллекцияЭлементовМД = СписокРеквизитовУправляемойФормы(ВыбраннаяСтруктураТипа.Метаданные[0].Метаданные, мРодительскийКонтекст);
			КонецЕсли;
			Если ЗначениеЗаполнено(ИмяПеременнойСтруктуры) Тогда
				КоллекцияЭлементовМД = ВозможныеТекстовыеЗначенияВыраженияИзТекущегоМетода(ИмяПеременнойСтруктуры,, СтрокаОписанияМетода.ТипКонтекста,,, ФильтроватьСлово);
			КонецЕсли;
			Если ТипЗнч(КоллекцияЭлементовМД) =  Тип("ТаблицаЗначений") Тогда
				мТаблицаСловЛитерала = КоллекцияЭлементовМД;
				КоллекцияЭлементовМД = Новый Массив;
			КонецЕсли;
		КонецЕсли;
		
		Если СтрокаОписанияМетода.Слово = "ВыгрузитьКолонку" Тогда
			МетаданныеОбъекта = ВыбраннаяСтруктураТипа.ДержательМетаданных;
		Иначе
			МетаданныеОбъекта = ВыбраннаяСтруктураТипа.Метаданные;
		КонецЕсли;
		Если Ложь
			Или мТаблицаСловЛитерала <> Неопределено
			Или (Истина
				И СтрокаОписанияМетода.ТипКонтекста = "Структура"
				И ИмяПараметра = "Ключ"
				И ТипЗнч(МетаданныеОбъекта) = Тип("ТаблицаЗначений"))
		Тогда
			//
		ИначеЕсли Истина
			И (Ложь
				Или Найти(НРег(ИмяПараметра), "ключ") > 0
				Или Найти(НРег(ИмяПараметра), "индекс") > 0 // - Удалить()
				Или Найти(НРег(ИмяПараметра), "колонк") > 0
				Или Найти(НРег(ИмяПараметра), "сортировк") > 0 // - дерево
				Или Найти(НРег(ИмяПараметра), "группировк") > 0)
			И (Ложь
				Или ТипЗнч(МетаданныеОбъекта) = Тип("ТаблицаЗначений") 
				Или ТипЗнч(МетаданныеОбъекта) = Тип("ДеревоЗначений")
				Или ТипЗнч(МетаданныеОбъекта) = Тип("РезультатЗапроса"))
			И (Ложь
				Или Не мПлатформа.мРежимПроверкиМодуля 
				Или Не ирОбщий.СтрНачинаетсяСЛкс(СтрокаОписанияМетода.ТипКонтекста, "КоллекцияКолонок")
				Или СтрокаОписанияМетода.Слово <> "Найти")
		Тогда
			КоллекцияЭлементовМД = МетаданныеОбъекта.Колонки;
		ИначеЕсли Истина
			И (Ложь
				Или Найти(НРег(ИмяПараметра), "ключ") > 0
				Или Найти(НРег(ИмяПараметра), "индекс") > 0 // - Удалить()
				Или Найти(НРег(ИмяПараметра), "колонк") > 0
				Или Найти(НРег(ИмяПараметра), "сортировк") > 0 // - дерево
				)
			И (Ложь
				Или Не мПлатформа.мРежимПроверкиМодуля
				Или (Истина
					И СтрокаОписанияМетода.Слово <> "Свойство"
					И СтрокаОписанияМетода.Слово <> "Вставить"
					И Не (Истина
						И СтрокаОписанияМетода.Слово = "Найти" 
						И Найти(СтрокаОписанияМетода.ТипКонтекста, "КоллекцияКолонок") > 0)))
			И (Ложь
				Или ТипЗнч(МетаданныеОбъекта) = Тип("Структура")
				Или Истина
					И ТипЗнч(МетаданныеОбъекта) = Тип("ОбъектМетаданных")
					//И Найти(СтрокаОписанияМетода.ТипКонтекста, "ТабличнаяЧасть") > 0 // Закомментировано по https://www.hostedredmine.com/issues/986251
						// Или СтрокаОписанияМетода.ТипКонтекста = "Структура" // конструктор
				)
		Тогда 
			Коллекция = МетаданныеОбъекта;
			Если ТипЗнч(Коллекция) = Тип("ОбъектМетаданных") Тогда
				Коллекция = Коллекция.Реквизиты;
				Если СтрокаОписанияМетода.ТипКонтекста = "ТабличнаяЧасть" тогда
					Коллекция = ирОбщий.МассивИзКоллекцииЛкс(Коллекция);
					Коллекция.Добавить(Новый Структура("Имя, Тип", "НомерСтроки", Новый ОписаниеТипов("Число")));
				КонецЕсли;
			КонецЕсли;
			КоллекцияЭлементовМД = Коллекция;
		ИначеЕсли Истина
			И ИмяПараметра = "URIПространстваИмен"
		Тогда  
			КоллекцияЭлементовМД = ирОбщий.ВыгрузитьСвойствоЛкс(ФабрикаXDTO.Пакеты, "URIПространстваИмен");
			ЛиНаборЗначенийПолный = Ложь
				Или СтрокаОписанияМетода.ТипКонтекста = "ТипДанныхXML" // конструктор
				Или СтрокаОписанияМетода.ТипКонтекста = "ФабрикаXDTO"
				Или СтрокаОписанияМетода.ТипКонтекста = "СериализаторXDTO";
		ИначеЕсли Истина
			И мЭтоКонструктор
			И мИмяМетодаВызова = "УникальныйИдентификатор"
		Тогда
			ЛиНаборЗначенийПолный = Ложь;
			КоллекцияЭлементовМД.Добавить("00000000-0000-0000-0000-000000000000");
		ИначеЕсли Истина
			И ИмяПараметра = "НаименованиеТаблицы"
			И ВыбраннаяСтруктураТипа.ИмяОбщегоТипа = "ВременнаяТаблицаЗапроса"
			И ТипЗнч(МетаданныеОбъекта) = Тип("Структура") 
		Тогда 
			МенеджерВременныхТаблиц = МетаданныеОбъекта; // см. НовыйМенеджерВременныхТаблиц
			Для Каждого ПакетЗапросов Из МенеджерВременныхТаблиц.ПакетыЗапросов Цикл
				ПодготовитьПакетЗапросов(ПакетЗапросов);
				ирОбщий.ДополнитьМассивЛкс(КоллекцияЭлементовМД, ирОбщий.ОтобратьКоллекциюЛкс(ПакетЗапросов.Структура, "Э.Представление<>""""", "Представление")); 
			КонецЦикла;
		ИначеЕсли Истина
			И ИмяПараметра = "ИмяРеквизита"
			И СтрокаОписанияМетода.Слово = "НайтиПоРеквизиту"
			И ТипЗнч(МетаданныеОбъекта) = Тип("ОбъектМетаданных")
		Тогда  
			//КоллекцияЭлементовМД = ирОбщий.ОтобратьКоллекциюЛкс(МетаданныеОбъекта.Реквизиты, "Э.Индексирование<>П1",, Метаданные.СвойстваОбъектов.Индексирование.НеИндексировать);
			КоллекцияЭлементовМД = МетаданныеОбъекта.Реквизиты;
		ИначеЕсли Истина
			И Найти(НРег(ИмяПараметра), "группировк") > 0 
			И ТипЗнч(МетаданныеОбъекта) = Тип("ПостроительЗапроса") 
		Тогда
			мПлатформа.ПодготовитьМетаданныеПостроителяЗапроса(МетаданныеОбъекта, ВыбраннаяСтруктураТипа.ДержательМетаданных);
			КоллекцияЭлементовМД = МетаданныеОбъекта.Измерения;
		ИначеЕсли Истина
			И СтрокаОписанияМетода.ТипСлова = "Конструктор" 
			И ТипЗнч(МетаданныеОбъекта) = Тип("ПостроительЗапроса") 
		Тогда
			мПлатформа.ПодготовитьМетаданныеПостроителяЗапроса(МетаданныеОбъекта, ВыбраннаяСтруктураТипа.ДержательМетаданных);
			КоллекцияЭлементовМД = МетаданныеОбъекта.ДоступныеПоля;
		ИначеЕсли Ложь
			Или ТипЗнч(МетаданныеОбъекта) = Тип("ДанныеФормыКоллекция")
		Тогда
			КоллекцияЭлементовМД = мПлатформа.ДочерниеСвойстваДанныхФормы(МетаданныеОбъекта, Истина, ВыбраннаяСтруктураТипа.ДержательМетаданных);
		ИначеЕсли Истина
			И ИмяПараметра = "ИмяРеквизита"
			И (Ложь
			    Или СтрокаОписанияМетода.Слово = "ЗначениеВРеквизитФормы"
				Или СтрокаОписанияМетода.Слово = "РеквизитФормыВЗначение")
		Тогда
			КоллекцияЭлементовМД = мПлатформа.ИменаРеквизитовФормы(МетаданныеОбъекта, "").Все;
		ИначеЕсли Истина
			И ИмяПараметра = "ИмяОбласти" 
			И ТипЗнч(МетаданныеОбъекта) = Тип("ТабличныйДокумент") 
		Тогда
			КоллекцияЭлементовМД = ирОбщий.ВыгрузитьСвойствоЛкс(МетаданныеОбъекта.Области,,, Тип("ОбластьЯчеекТабличногоДокумента"));
		ИначеЕсли Истина
			И СтрокаОписанияМетода.Слово = "ПолучитьФорму"
			И ИмяПараметра = "ИмяФормы"
		Тогда 
			//
		ИначеЕсли Истина
			И Найти(СтрокаОписанияМетода.ТипКонтекста, "<") > 0
			И ТипЗнч(МетаданныеОбъекта) = Тип("ОбъектМетаданных") 
		Тогда
			Если ИмяПараметра = "Макет" Тогда
				КоллекцияЭлементовМД = МетаданныеОбъекта.Макеты;
			ИначеЕсли ИмяПараметра = "Форма" Тогда
				КоллекцияЭлементовМД = МетаданныеОбъекта.Формы;
			ИначеЕсли ЗначениеЗаполнено(ИмяПараметра) Тогда 
				ПолноеИмяМД = МетаданныеОбъекта.ПолноеИмя();
				Если ирОбщий.ОписаниеТипаМетаданныхЛкс(ирОбщий.ПервыйФрагментЛкс(ПолноеИмяМД)).Категория = 1 Тогда
					Попытка
						// Пытаемся взять реквизиты ТЧ у нехранимого в БД объекта
						КоллекцияЭлементовМД = МетаданныеОбъекта.Реквизиты;
					Исключение
						ЛиНаборЗначенийПолный = Ложь;
					КонецПопытки;
				Иначе 
					ИмяТаблицыБД = ирКэш.ИмяТаблицыИзМетаданныхЛкс(ПолноеИмяМД);
					Если ЗначениеЗаполнено(ИмяТаблицыБД) Тогда
						КоллекцияЭлементовМД = ирОбщий.ПоляТаблицыБДЛкс(ИмяТаблицыБД);
					КонецЕсли; 
				КонецЕсли;
			КонецЕсли; 
		ИначеЕсли ИмяПараметра = "ИмяПользователяИБ" Тогда 
			ПользователиИБ = ПользователиИнформационнойБазы.ПолучитьПользователей();
			Для Каждого Пользователь Из ПользователиИБ Цикл
				КоллекцияЭлементовМД.Добавить(Пользователь.Имя);                            
			КонецЦикла;
		ИначеЕсли ИмяПараметра = "Роль" Тогда 
			КоллекцияЭлементовМД = Метаданные.Роли;
		ИначеЕсли ИмяПараметра = "ИмяПользователяИБ" Тогда 
			ПользователиИБ = ПользователиИнформационнойБазы.ПолучитьПользователей();
			Для Каждого Пользователь Из ПользователиИБ Цикл
				КоллекцияЭлементовМД.Добавить(Пользователь.Имя); 
			КонецЦикла;
		ИначеЕсли ИмяПараметра = "ОбщийМакет" Тогда 
			КоллекцияЭлементовМД = Метаданные.ОбщиеМакеты;
		ИначеЕсли Истина
			И СтрокаОписанияМетода.Слово = "ПолучитьОбщуюФорму" 
			И ИмяПараметра = "Форма"
		Тогда
			КоллекцияЭлементовМД = Метаданные.ОбщиеФормы;
		ИначеЕсли Истина
			И СтрокаОписанияМетода.Слово = "УстановитьПараметр" 
			И ИмяПараметра = "Имя"
		Тогда
			Если ТипЗнч(МетаданныеОбъекта) = Тип("ПостроительЗапроса") Тогда
				ТекстЗапроса = ТекстИмитаторовВременныхТаблиц(ВыбраннаяСтруктураТипа.ДержательМетаданных, МетаданныеОбъекта.Текст);
				КоллекцияЭлементовМД = мПлатформа.ПараметрыИзТекстаЗапроса(ТекстЗапроса, Истина);
				Для Каждого КлючИЗначение Из МетаданныеОбъекта.Параметры Цикл
					Если Истина
						И КоллекцияЭлементовМД.Свойство(КлючИЗначение.Ключ)
						И КлючИЗначение.Значение <> Неопределено
						И КлючИЗначение.Значение.Количество() > 0 
					Тогда
						КоллекцияЭлементовМД.Вставить(КлючИЗначение.Ключ, КлючИЗначение.Значение);
					КонецЕсли;
				КонецЦикла;
			КонецЕсли;
		ИначеЕсли Истина
			И СтрокаОписанияМетода.Слово = "Получить" 
			И СтрокаОписанияМетода.ТипКонтекста = "КоллекцияСвойствXDTO"
			И ИмяПараметра = "Имя" 
			И Типзнч(МетаданныеОбъекта) = Тип("ОбъектXDTO")
		Тогда
			//! МетаданныеОбъекта = 0 // ОбъектXDTO
			Для Каждого Свойство Из МетаданныеОбъекта.Свойства() Цикл
				КоллекцияЭлементовМД.Добавить(Свойство.Имя); 
			КонецЦикла;
		ИначеЕсли Истина
			И СтрокаОписанияМетода.Слово = "Тип" 
			И СтрокаОписанияМетода.ТипКонтекста = "ФабрикаXDTO"
			И ИмяПараметра = "Имя"
		Тогда  
			ИмяПространства = ВычислитьЗначениеВыражения(мПервыйФактическийПараметр, мТекстДляПоискаОпределения);
			Для Каждого Пакет Из ФабрикаXDTO.ЭкспортМоделиXDTO(ИмяПространства).package Цикл
				Для Каждого Тип Из Пакет.valueType Цикл
					КоллекцияЭлементовМД.Добавить(Тип.name);
				КонецЦикла;
				Для Каждого Тип Из Пакет.objectType Цикл
					КоллекцияЭлементовМД.Добавить(Тип.name);
				КонецЦикла;
			КонецЦикла;
		ИначеЕсли Истина
			И СтрокаОписанияМетода.Слово = "НайтиПредопределенное" 
			И СтрокаОписанияМетода.ТипКонтекста = "МенеджерРегламентныхЗаданий" 
			И ИмяПараметра = "Метаданные"
		Тогда
			КоллекцияЭлементовМД = Метаданные.РегламентныеЗадания;
		ИначеЕсли Истина
			И СтрокаОписанияМетода.Слово = "ПравоДоступа" 
			И  ИмяПараметра = "Право"
		Тогда
			КоллекцияЭлементовМД = ирОбщий.ТаблицаЗначенийИзТабличногоДокументаЛкс(мПлатформа.ПолучитьМакет("ВидыПравДоступа"));
		ИначеЕсли Истина
			И СтрокаОписанияМетода.Слово = "ЗаполнитьЗначенияСвойств" 
			И (Ложь
				Или ИмяПараметра = "СписокСвойств"
				Или ИмяПараметра = "ИсключаяСвойства")
		Тогда
			// Мультиметка00193361 Вероятно дублирование
			СтруктураТипаПараметра = ВычислитьТипЗначенияВыражения(мПервыйФактическийПараметр, мТекстДляПоискаОпределения);
			Если СтруктураТипаПараметра.Количество() > 0 Тогда
				ПараметрыЗаполнения = мПлатформа.НовыеПараметрыЗаполненияСлов("Свойство", БазовоеРасширениеКонфигурации(),,,,,,, ФильтроватьСлово);
				мТаблицаСловЛитерала = мПлатформа.ТаблицаСловИзСтруктурыТипа(СтруктураТипаПараметра[0], ПараметрыЗаполнения);
			КонецЕсли;
		ИначеЕсли Истина
			И СтрокаОписанияМетода.ТипКонтекста = "ОформлениеКомпоновкиДанных"
			И СтрокаОписанияМетода.Слово = "УстановитьЗначениеПараметра"
			И ИмяПараметра = "Параметр"
		Тогда 
			КоллекцияЭлементовМД = Новый ТаблицаЗначений;
			КоллекцияЭлементовМД.Колонки.Добавить("ВертикальноеПоложение", Новый ОписаниеТипов("ВертикальноеПоложение"));
			КоллекцияЭлементовМД.Колонки.Добавить("Видимость", Новый ОписаниеТипов("Булево"));
			КоллекцияЭлементовМД.Колонки.Добавить("ВыделятьОтрицательные", Новый ОписаниеТипов("Булево"));
			КоллекцияЭлементовМД.Колонки.Добавить("ГоризонтальноеПоложение", Новый ОписаниеТипов("ГоризонтальноеПоложение"));
			КоллекцияЭлементовМД.Колонки.Добавить("Доступность", Новый ОписаниеТипов("Булево"));
			КоллекцияЭлементовМД.Колонки.Добавить("МаксимальнаяШирина", Новый ОписаниеТипов("Число"));
			КоллекцияЭлементовМД.Колонки.Добавить("ОтметкаНезаполненного", Новый ОписаниеТипов("Булево"));
			КоллекцияЭлементовМД.Колонки.Добавить("Отображать", Новый ОписаниеТипов("Булево"));
			КоллекцияЭлементовМД.Колонки.Добавить("Размещение", Новый ОписаниеТипов("ТипРазмещенияТекстаКомпоновкиДанных"));
			КоллекцияЭлементовМД.Колонки.Добавить("Текст", Новый ОписаниеТипов("Строка"));
			КоллекцияЭлементовМД.Колонки.Добавить("ТолькоПросмотр", Новый ОписаниеТипов("Булево"));
			КоллекцияЭлементовМД.Колонки.Добавить("Формат", Новый ОписаниеТипов("Строка"));
			КоллекцияЭлементовМД.Колонки.Добавить("ЦветФона", Новый ОписаниеТипов("Цвет"));
			КоллекцияЭлементовМД.Колонки.Добавить("ЦветТекста", Новый ОписаниеТипов("Цвет"));
			КоллекцияЭлементовМД.Колонки.Добавить("Шрифт", Новый ОписаниеТипов("Шрифт"));
			КоллекцияЭлементовМД = КоллекцияЭлементовМД.Колонки;
		ИначеЕсли Истина
			И СтрокаОписанияМетода.ТипКонтекста = "ЗначенияПараметровДанныхКомпоновкиДанных"
			И СтрокаОписанияМетода.Слово = "УстановитьЗначениеПараметра"
			И ИмяПараметра = "Параметр"
		Тогда
			КомпоновщикНастроек = МетаданныеОбъекта;
			Если ТипЗнч(КомпоновщикНастроек) = Тип("КомпоновщикНастроекКомпоновкиДанных") Тогда
				ДоступныеПараметры = КомпоновщикНастроек.Настройки.ПараметрыДанных.ДоступныеПараметры;
				Если ДоступныеПараметры <> Неопределено Тогда
					КоллекцияЭлементовМД = ДоступныеПараметры.Элементы;
				КонецЕсли;
			КонецЕсли;
		ИначеЕсли Истина
			И (Ложь
				Или СтрокаОписанияМетода.Слово = "ПолучитьФункциональнуюОпцию" 
				Или СтрокаОписанияМетода.Слово = "ПолучитьФункциональнуюОпциюИнтерфейса"
				Или СтрокаОписанияМетода.Слово = "ПолучитьФункциональнуюОпциюФормы")
			И ИмяПараметра = "Имя"
		Тогда
			КоллекцияЭлементовМД = Метаданные.ФункциональныеОпции;
		ИначеЕсли Ложь
			Или ИмяПараметра = "ИмяМетода"
			Или ИмяПараметра = "ИмяПроцедуры" И СтрокаОписанияМетода.ТипКонтекста <> "Действие"
			Или ИмяПараметра = "ИмяФункции"
			Или ИмяПараметра = "ИмяОбработчика"
			Или ИмяПараметра = "Действие"
		Тогда
			Если СтруктураТипаМодуля = Неопределено Тогда
				СтруктураТипаМодуля = мПлатформа.НоваяСтруктураТипа(СтрокаОписанияМетода.ТипКонтекста);
				СтруктураТипаМодуля.Метаданные = МетаданныеОбъекта;  
			КонецЕсли;
			ТолькоЭкспотные = СтрокаОписанияМетода.ТипКонтекста = "ОписаниеОповещения";
			ЛиБезПараметров = ирОбщий.СтрКончаетсяНаЛкс(СтрокаОписанияМетода.Слово, "Ожидания");
			Если СтруктураТипаМодуля.ИмяОбщегоТипа = "Глобальный" Тогда
				мТаблицаСловЛитерала = мПлатформа.ДобавитьВТаблицуСловЭлементыГлобальныхМодулей(СтруктураТипаМодуля,, "Метод",,,,,,,, ЛиБезПараметров);
			Иначе
				Если СтрокаОписанияМетода.ТипКонтекста = "ОписаниеОповещения" Тогда
					Если мФактическиеПараметры.Количество() > 1 Тогда
						ТаблицаТиповМодуля = ВычислитьТипЗначенияВыражения(мФактическиеПараметры[1],,,,,, Ложь);
						Если ТаблицаТиповМодуля.Количество() > 0 Тогда
							СтруктураТипаМодуля = ТаблицаТиповМодуля[0];
						КонецЕсли;
					Иначе
						СтруктураТипаМодуля = мМодульМетаданных.СтруктураТипа;
					КонецЕсли;
				ИначеЕсли ирОбщий.СтрКончаетсяНаЛкс(СтрокаОписанияМетода.ТипКонтекста, "Формы") Тогда
					СтруктураТипаМодуля = мПлатформа.НоваяСтруктураТипа("ФормаКлиентскогоПриложения");
					СтруктураТипаМодуля.Метаданные = ВыбраннаяСтруктураТипа.ДержательМетаданных;
				КонецЕсли;
				Если СтруктураТипаМодуля <> Неопределено Тогда
					Модуль = мПлатформа.ПодготовитьМодульМетаданных(СтруктураТипаМодуля);
					Если Модуль <> Неопределено Тогда
						мТаблицаСловЛитерала = мПлатформа.ДобавитьВТаблицуСловЭлементыМодуляМетаданных(Модуль.СтруктураТипа,, "Метод",, Модуль,,, ТолькоЭкспотные,,,,, ЛиБезПараметров);
					Иначе
						ЛиНаборЗначенийПолный = Ложь; // Чтобы сработало заполнение полного имени метода в ДобавитьВТаблицуСловИменаМодуляИМетаданныхИТипов
					КонецЕсли;
				КонецЕсли;
			КонецЕсли;
		ИначеЕсли Истина
			И ИмяПараметра = "ИмяСобытия"
			//И СтрокаОписанияМетода.Слово <> "ЗаписьЖурналаРегистрации"
			//И СтрокаОписанияМетода.Слово <> "Оповестить"
			И СтрокаОписанияМетода.ТипКонтекста <> "Глобальный"
		Тогда
			ЭлементФормыСобытия = МетаданныеОбъекта;
			Если ТипЗнч(ЭлементФормыСобытия) = Тип("Неопределено") Тогда
				ЭлементФормыСобытия = Неопределено;
			КонецЕсли;
			ИмяОбщегоТипа = СтрокаОписанияМетода.ТипКонтекста;
			Если ИмяОбщегоТипа = "РасширениеЭлементовУправленияРасположенныхВФорме" Тогда
				ИмяОбщегоТипа = "";
			КонецЕсли;
			мТаблицаСловЛитерала = мПлатформа.НоваяТаблицаСлов();
			Для Каждого СтрокаСобытия Из ирОбщий.СобытияЭлементаФормыЛкс(ЭлементФормыСобытия, ИмяОбщегоТипа) Цикл
				СтруктураТипа = мПлатформа.НоваяСтруктураТипа("");
				СтруктураТипа.СтрокаОписания = СтрокаСобытия;
				мПлатформа.ДобавитьВТаблицуСлов(мТаблицаСловЛитерала, СтрокаСобытия.Слово, СтрокаСобытия.ТипСлова, мПлатформа.ДобавитьВТаблицуТипов(, СтруктураТипа),, "Предопределенное");
			КонецЦикла;
		ИначеЕсли Истина
			И ТипЗнч(МетаданныеОбъекта) = Тип("ПостроительЗапроса")
			И (Ложь
				Или ИмяПараметра = "ПутьКДанным"
				Или ИмяПараметра = "Описание")
		Тогда
			ИмяПараметра = "ПутьКДанным";
			ПостроительЗапроса = МетаданныеОбъекта;
			#Если Сервер И Не Сервер Тогда
				ПостроительЗапроса = Новый ПостроительЗапроса;
			#КонецЕсли 
			мПлатформа.ПодготовитьМетаданныеПостроителяЗапроса(ПостроительЗапроса, ВыбраннаяСтруктураТипа.ДержательМетаданных);
			//КоллекцияЭлементовМД = ПостроительЗапроса.ДоступныеПоля; // Опасно, т.к. коллекция динамически очищается при уничтожении родительского построителя
			КоллекцияЭлементовМД = Новый Структура;
			Для Каждого ПолеНастройки Из ПостроительЗапроса.ДоступныеПоля Цикл
				КоллекцияЭлементовМД.Вставить(ПолеНастройки.Имя, ПолеНастройки.ТипЗначения);
			КонецЦикла;
		ИначеЕсли Истина
			И ИмяПараметра = "ПутьКДанным"
			И (Ложь
				Или ТипЗнч(МетаданныеОбъекта) = Тип("НаборДанныхЗапросСхемыКомпоновкиДанных")
				Или ТипЗнч(МетаданныеОбъекта) = Тип("НаборДанныхОбъектСхемыКомпоновкиДанных")
				Или ТипЗнч(МетаданныеОбъекта) = Тип("НаборДанныхОбъединениеСхемыКомпоновкиДанных"))
		Тогда
			КоллекцияЭлементовМД = МетаданныеОбъекта.Поля;
		ИначеЕсли Истина
			И СтрокаОписанияМетода.Слово = "Найти"
			И ТипЗнч(МетаданныеОбъекта) = Тип("КоллекцияОбъектовМетаданных")
			И Не мПлатформа.мРежимПроверкиМодуля
		Тогда
			КоллекцияЭлементовМД = МетаданныеОбъекта;
		ИначеЕсли Истина
			И СтрокаОписанияМетода.Слово = "Найти"
			И ТипЗнч(ВыбраннаяСтруктураТипа.ДержательМетаданных) = ирОбщий.ТипУправляемаяФормаЛкс()
			И Не мПлатформа.мРежимПроверкиМодуля
		Тогда
			КоллекцияЭлементовМД = ВыбраннаяСтруктураТипа.ДержательМетаданных.Элементы;
		Иначе
		//Если Истина
		// Это блокирует откытие списка подсказки в ирПлатформа.НоваяСтруктураТипа("")
		//	И СтрокаОписанияМетода.ТипКонтекста <> "ТаблицаЗначений"
		//	И СтрокаОписанияМетода.ТипКонтекста <> "ДеревоЗначений"
		//	И СтрокаОписанияМетода.ТипКонтекста <> "Структура"
		//	И Найти(СтрокаОписанияМетода.ТипКонтекста, "ТабличнаяЧасть.") = 0
		//	И Найти(СтрокаОписанияМетода.ТипКонтекста, "НаборЗаписей.") = 0
		//Тогда
			ЛиНаборЗначенийПолный = Ложь;
		КонецЕсли;
		Если ЛиНаборЗначенийПолный Или Не мПлатформа.мРежимПроверкиМодуля Тогда
			ВыбраннаяСтруктураТипа.ТипЯзыка = ИмяПараметра;
		КонецЕсли;
	ИначеЕсли Истина
		И ТипЗнч(СтрокаОписанияМетода) = Тип("СтрокаТаблицыЗначений")
		И СтрокаОписанияМетода.Владелец().Колонки.Найти("ТелоБезВозвратов") <> Неопределено
	Тогда 
		// Метод модуля
		//! СтрокаОписанияМетода = мПлатформа.НоваяТаблицаМетодовМодуля()[0]
		ЛиНаборЗначенийПолный = Ложь;
		ИмяПараметра = ИмяПараметраВызоваМетода(СтрокаОписанияМетода);
		Если ЗначениеЗаполнено(ИмяПараметра) Тогда 
			ЛиНаборЗначенийПолный = Истина;
			Если Истина // БСП ЗначениеРеквизитаОбъекта
				//И ИмяТипаСтруктуры = "" // Этот метода поддерживает все типы - Строка, Массив, Структура
				И Найти(ИмяПараметра, "Реквизит") > 0
				И Найти(СтрокаОписанияМетода.Имя, "Значен") > 0
				И Найти(СтрокаОписанияМетода.Имя, "Реквизит") > 0
			Тогда
				// БСП https://www.hostedredmine.com/issues/966675
				ТаблицаТиповСсылки = ВычислитьТипЗначенияВыражения(мПервыйФактическийПараметр, мТекстДляПоискаОпределения,,,,, Ложь);
				Если ТаблицаТиповСсылки.Количество() > 0 Тогда
					Для Каждого СтруктураТипаСсылки Из ТаблицаТиповСсылки Цикл
						Если СтруктураТипаСсылки.ИмяОбщегоТипа = "Массив" Тогда
							ТаблицаТиповСсылки = мПлатформа.ТаблицаТиповЭлементовКоллекции(СтруктураТипаСсылки);
							Если ТаблицаТиповСсылки.Количество() > 0 Тогда
								СтруктураТипаСсылки = ТаблицаТиповСсылки[0];
							КонецЕсли;
						КонецЕсли;
						Если ТипЗнч(СтруктураТипаСсылки.Метаданные) = Тип("ОбъектМетаданных") Тогда
							ИмяТаблицыБД = ирКэш.ИмяТаблицыИзМетаданныхЛкс(СтруктураТипаСсылки.Метаданные.ПолноеИмя());
							Если ЗначениеЗаполнено(ИмяТаблицыБД) Тогда
								// Мультиметка81792365
								АнализаторКода = ирОбщий.НовыйАнализаторКодаЛкс(1);
								Текст = "ВЫБРАТЬ ПЕРВЫЕ 0 Т." + мКонтекст;
								Позиция = СтрДлина(Текст) + 1;
								Текст = Текст + " ИЗ " + ИмяТаблицыБД + " КАК Т";
								АнализаторКода.УстановитьТекст(Текст,,,,,, Позиция, Позиция);
								АнализаторКода.ЗаполнитьТаблицуСлов(, Ложь,, Ложь, Ложь,,, ФильтроватьСлово);
								мТаблицаСловЛитерала = мПлатформа.НоваяТаблицаСлов();
								//ирОбщий.ЗагрузитьВТаблицуЗначенийЛкс(АнализаторКода.ТаблицаСлов, мТаблицаСловЛитерала);
								Для Каждого СтрокаИсточника Из АнализаторКода.ТаблицаСлов Цикл
									ТипЗначения = СтрЗаменить(СтрокаИсточника.ТипЗначения, ".", "Ссылка.");
									мПлатформа.ДобавитьВТаблицуСлов(мТаблицаСловЛитерала, СтрокаИсточника.Слово, СтрокаИсточника.ТипСлова,, ТипЗначения, СтрокаИсточника.Определение);
								КонецЦикла;
								ИмяПараметра = "ИмяРеквизита";
							КонецЕсли; 
						КонецЕсли;
					КонецЦикла;
				КонецЕсли;
			ИначеЕсли Истина // БСП
				И ИмяТипаСтруктуры = ""
				И ИмяПараметра = "Поле" 
				И СтрокаОписанияМетода.Имя = "СообщитьПользователю" 
			Тогда 
				Форма = Неопределено;
				Если Истина
					И Не ЗначениеЗаполнено(мФактическиеПараметры[1])
					И мМодульМетаданных.СтруктураТипа <> Неопределено
					И ЛиПодробнаяСтруктураТипаУпрФормы(мМодульМетаданных.СтруктураТипа)
				Тогда
					Форма = мМодульМетаданных.СтруктураТипа.Метаданные;
				ИначеЕсли ЗначениеЗаполнено(мФактическиеПараметры[1]) Тогда 
					СтруктураТипаСсылки = ВычислитьТипЗначенияВыражения(мФактическиеПараметры[1], мТекстДляПоискаОпределения,,,,, Ложь);
					Если СтруктураТипаСсылки.Количество() > 0 Тогда
						СтруктураТипаСсылки = СтруктураТипаСсылки[0];
						Если ТипЗнч(СтруктураТипаСсылки.Метаданные) = Тип("ОбъектМетаданных") Тогда
							// Мультиметка240722_090136
							Форма = мПлатформа.ПассивнаяФормаПоИмениКэш(СтруктураТипаСсылки.Метаданные.ПолноеИмя() + ".ФормаОбъекта");
						КонецЕсли;
					КонецЕсли;
				КонецЕсли;
				Если Форма <> Неопределено Тогда
					КоллекцияЭлементовМД = СписокРеквизитовУправляемойФормы(Форма, мРодительскийКонтекст);
				КонецЕсли;
			ИначеЕсли Истина // ИР
				И ИмяТипаСтруктуры = ""
				И ИмяПараметра = "ПутьКСвойству" 
				И (Ложь
					ИЛи СтрокаОписанияМетода.Имя = "ВыгрузитьСвойствоЛкс" 
					Или СтрокаОписанияМетода.Имя = "ОтобратьКоллекциюЛкс")
			Тогда
				СтруктураТипаПараметра = ВычислитьТипЗначенияВыражения(мПервыйФактическийПараметр, мТекстДляПоискаОпределения,,,,, Ложь);
				Если СтруктураТипаПараметра.Количество() > 0 Тогда
					СтруктураТипаЭлемента = мПлатформа.ТаблицаТиповЭлементовКоллекции(СтруктураТипаПараметра[0]);
					Если ЗначениеЗаполнено(СтруктураТипаЭлемента) Тогда
						БазовоеРасширениеКонфигурации = БазовоеРасширениеКонфигурации();
						ПараметрыЗаполнения = мПлатформа.НовыеПараметрыЗаполненияСлов(, БазовоеРасширениеКонфигурации,,,,,,, ФильтроватьСлово);
						КоллекцияЭлементовМД = мПлатформа.ТаблицаСловИзСтруктурыТипа(СтруктураТипаЭлемента[0], ПараметрыЗаполнения);
						КоллекцияЭлементовМД = КоллекцияЭлементовМД.Скопировать(Новый Структура("ТипСлова", "Свойство")).ВыгрузитьКолонку("Слово");
						ВыбраннаяСтруктураТипа.ИмяОбщегоТипа = "Локальный";
					КонецЕсли;
				КонецЕсли;
			ИначеЕсли Истина // ИР
				И ИмяТипаСтруктуры = ""
				И ИмяПараметра = "Условие" 
				И СтрокаОписанияМетода.Имя = "ОтобратьКоллекциюЛкс"
			Тогда
				// TODO 
				СтруктураТипаПараметра = ВычислитьТипЗначенияВыражения(мПервыйФактическийПараметр,,,,,, Ложь);
				Если СтруктураТипаПараметра.Количество() > 0 Тогда
					// Опасно. Полная замена контекста
					ОчиститьТаблицуСловЛокальногоКонтекста();
					мЭтоТекстовыйЛитерал = Ложь;
					СтруктураТипаЭлемента = мПлатформа.ТаблицаТиповЭлементовКоллекции(СтруктураТипаПараметра[0]);
					ДобавитьСловоЛокальногоКонтекста("Э",,,,,, мПлатформа.ДобавитьВТаблицуТипов(, СтруктураТипаЭлемента));
					СмещениеНомера = 2;
					Для НомерПараметра = 1 По 3 Цикл
						Если мФактическиеПараметры.Количество() > СмещениеНомера + НомерПараметра Тогда
							СтруктураТипаПараметра = ВычислитьТипЗначенияВыражения(мФактическиеПараметры[СмещениеНомера + НомерПараметра]);
							Если СтруктураТипаПараметра.Количество() > 0 Тогда
								ДобавитьСловоЛокальногоКонтекста("П" + НомерПараметра,,,,,, мПлатформа.ДобавитьВТаблицуТипов(, СтруктураТипаПараметра));
							КонецЕсли;
						КонецЕсли;
					КонецЦикла;
					мТекстДляПоискаОпределения = "";
					мПредшествующийТекст = мТекстДляПоискаОпределения;
					мЭтоЛокальныйКонтекстТаблицыСлов = Не ЗначениеЗаполнено(мРодительскийКонтекст);
					мТаблицаТиповКонтекста = ВычислитьТипЗначенияВыражения(мРодительскийКонтекст,,, Истина,,, Ложь);
					Если мТаблицаТиповКонтекста.Количество() > 0 Тогда
						мСтруктураТипаКонтекста = мТаблицаТиповКонтекста[0];
					КонецЕсли;
				КонецЕсли;
			ИначеЕсли Истина
				И ИмяТипаСтруктуры = ""
				И ИмяПараметра = "ПолноеИмяМД"
			Тогда
				// TODO 
			Иначе
				//! СтрокаМетода = 0; // см. мПлатформа.НоваяТаблицаМетодовМодуля()[0]
				ЛиНаборЗначенийПолный = Неопределено;
				КоллекцияЭлементовМД = ВозможныеТекстовыеЗначенияПараметраИзДругогоМетода(СтрокаОписанияМетода, ЛиНаборЗначенийПолный, ИмяТипаСтруктуры, ДобавлятьНизкоВероятные, ФильтроватьСлово);
			КонецЕсли;
			Если мЭтоТекстовыйЛитерал Тогда
				ВыбраннаяСтруктураТипа.ТипЯзыка = ИмяПараметра;
			КонецЕсли;
		КонецЕсли;
	ИначеЕсли ИмяТипаСтруктуры = "" Тогда
		ЛиНаборЗначенийПолный = Ложь;
		ВыражениеСлеваОтРавно = СокрП(ирОбщий.СтрокаБезПоследнегоФрагментаЛкс(мТекущаяСтрокаНачало, """"));
		Если Прав(ВыражениеСлеваОтРавно, 1) = "=" Тогда
			ВыражениеСлеваОтРавно = СокрЛП(ирОбщий.ПервыйФрагментЛкс(мТекущаяСтрокаНачало, "="));
			ВыражениеСлеваОтРавно = СокрЛП(ирОбщий.ПоследнийФрагментЛкс(ВыражениеСлеваОтРавно, " ")); // на случай - Если Слово = ""
			ПоследнееСлово = ирОбщий.ПоследнийФрагментЛкс(ВыражениеСлеваОтРавно);
			Если Ложь
				Или ирОбщий.СтрНачинаетсяСЛкс(ПоследнееСлово, "ПутьКДанным") 
				ИЛи ирОбщий.СтрНачинаетсяСЛкс(ПоследнееСлово, "Поле") 
			Тогда
				//ТаблицаТиповСлева = ВычислитьТипЗначенияВыражения(иробщий.СтрокаБезПоследнегоФрагментаЛкс(ВыражениеСлеваОтРавно),,,,,, Ложь,,,,,,, ИмяФиктивногоСвойства());
				ТаблицаТиповСлева = ВычислитьТипЗначенияВыражения(ВыражениеСлеваОтРавно,,,,,, Ложь,,,,,,, ИмяФиктивногоСвойства());
				Если Истина
					И ТаблицаТиповСлева.Количество() > 0
					И ЛиСистемноеСлово(ТаблицаТиповСлева[0]) 
				Тогда
					СтрокаОписанияСвойства = ТаблицаТиповСлева[0].СтрокаОписания; // см. мПлатформа.ТаблицаКонтекстов[0]
					Если ирОбщий.СтрНачинаетсяСЛкс(ПоследнееСлово, "ПутьКДанным") Тогда
						Если Истина
							//И ирОбщий.СтрНачинаетсяСЛкс(СтрокаОписанияСвойства.Слово, "ПутьКДанным")
							И (Ложь
								Или СтрокаОписанияСвойства.ТипКонтекста = "ГруппаФормы"
								Или СтрокаОписанияСвойства.ТипКонтекста = "ПолеФормы"
								Или СтрокаОписанияСвойства.ТипКонтекста = "ТаблицаФормы")
						Тогда
							КоллекцияЭлементовМД = СписокРеквизитовУправляемойФормы(ТаблицаТиповСлева[0].ДержательМетаданных, мРодительскийКонтекст);
							ЛиНаборЗначенийПолный = Истина;
						КонецЕсли;
					ИначеЕсли ирОбщий.СтрНачинаетсяСЛкс(ПоследнееСлово, "Поле") Тогда
						Если СтрокаОписанияСвойства.ТипКонтекста = "СообщениеПользователю" Тогда
							// Мультиметка240722_090136
							ТаблицаТиповМодуляФормы = ТаблицаТиповОсновнойФормыОбъекта(ТаблицаТиповСлева[0].Метаданные);
							Если ТаблицаТиповМодуляФормы.Количество() Тогда
								ФормаОбъекта = ТаблицаТиповМодуляФормы[0].Метаданные;
								Если ирОбщий.ЛиФормаИлиИмитаторЛкс(ФормаОбъекта, Ложь) Тогда
									КоллекцияЭлементовМД = СписокРеквизитовУправляемойФормы(ФормаОбъекта, мРодительскийКонтекст);
								КонецЕсли;
							КонецЕсли;
							ЛиНаборЗначенийПолный = Истина;
						КонецЕсли;
					КонецЕсли;
				КонецЕсли;
			КонецЕсли;
			Если Истина
				И Не ЛиНаборЗначенийПолный 
				И Не мПлатформа.мРежимПроверкиМодуля 
				И мРодительскийКонтекст = ""
			Тогда
				КоллекцияЭлементовМД = ВозможныеТекстовыеЗначенияВыраженияИзТекущегоМетода(ВыражениеСлеваОтРавно, ЛиНаборЗначенийПолный,, Истина, ДобавлятьНизкоВероятные, ФильтроватьСлово);
				ДобавитьПростыеСловаВТаблицу(КоллекцияЭлементовМД, Истина); // Приводит к дублированию
				КоллекцияЭлементовМД = Новый Массив;
			КонецЕсли;
		КонецЕсли;
	КонецЕсли;
	Если ВыбраннаяСтруктураТипа.ТипЯзыка = "ИмяПредопределенногоЗначения" Тогда
		ЛиНаборЗначенийПолный = Истина;
		Если ЗначениеЗаполнено(мРодительскийКонтекст) Тогда
			ТаблицаТиповМетаОбъектов = ирКэш.ТипыМетаОбъектов(Ложь);
			КорневойТип = ирОбщий.ПервыйФрагментЛкс(мРодительскийКонтекст);
			Если Найти(мРодительскийКонтекст, ".") > 0 Тогда
				КоллекцияЭлементовМД.Добавить("ПустаяСсылка");
				ОбъектМД = Метаданные.НайтиПоПолномуИмени(мРодительскийКонтекст);
				Если ОбъектМД <> Неопределено Тогда
					Если ирОбщий.ЛиКорневойТипПеречисленияЛкс(КорневойТип) Тогда
						#Если Сервер И Не Сервер Тогда
							ОбъектМД = Метаданные.Перечисления.ABCКлассификация;
						#КонецЕсли
						Для Каждого ЗначениеПеречисления Из ОбъектМД.ЗначенияПеречисления Цикл
							КоллекцияЭлементовМД.Добавить(ЗначениеПеречисления.Имя);
						КонецЦикла;
					Иначе
						#Если Сервер И Не Сервер Тогда
							ОбъектМД = Метаданные.Справочники.Валюты;
						#КонецЕсли
						Если Истина
							И ирКэш.НомерВерсииПлатформыЛкс() > 803004 
							И ирОбщий.ЛиКорневойТипОбъектаСПредопределеннымЛкс(КорневойТип) 
						Тогда
							Для Каждого ИмяЭлемента Из ОбъектМД.ПолучитьИменаПредопределенных() Цикл
								КоллекцияЭлементовМД.Добавить(ИмяЭлемента);
							КонецЦикла;
						КонецЕсли; 
					КонецЕсли; 
				КонецЕсли;
			Иначе
				МножественноеИмяМД = ирОбщий.МножественноеИмяМДЛкс(КорневойТип);
				Если МножественноеИмяМД <> Неопределено Тогда
					Для Каждого МетаОбъект Из Метаданные[МножественноеИмяМД] Цикл
						КоллекцияЭлементовМД.Добавить(МетаОбъект);
					КонецЦикла;
				КонецЕсли; 
			КонецЕсли; 
		Иначе
			Для Каждого СтрокаТипаМетаОбъекта Из ирКэш.ТипыМетаОбъектов(Ложь, Ложь, Ложь) Цикл
				Если Ложь
					Или ирОбщий.ЛиКорневойТипПеречисленияЛкс(СтрокаТипаМетаОбъекта.Единственное)
					Или ирОбщий.ЛиКорневойТипОбъектаСПредопределеннымЛкс(СтрокаТипаМетаОбъекта.Единственное) 
				Тогда
					КоллекцияЭлементовМД.Добавить(СтрокаТипаМетаОбъекта.Единственное);
				КонецЕсли; 
			КонецЦикла;
		КонецЕсли;  
	ИначеЕсли ВыбраннаяСтруктураТипа.ТипЯзыка = "ПространствоБлокировки" Тогда
		ЛиНаборЗначенийПолный = Истина;
		Если ЗначениеЗаполнено(мРодительскийКонтекст) Тогда
			КорневойТип = ирОбщий.ПервыйФрагментЛкс(мРодительскийКонтекст);
			ЭтоТаблицаВнешнейБД = ирОбщий.ЛиКорневойТипВнешнегоИсточникаДанныхЛкс(КорневойТип);
			Если Истина
				И ЭтоТаблицаВнешнейБД
				И СтрЧислоВхождений(мРодительскийКонтекст, ".") = 1 
			Тогда
				КоллекцияЭлементовМД.Добавить("Таблица");
			ИначеЕсли Истина
				И ЭтоТаблицаВнешнейБД
				И СтрЧислоВхождений(мРодительскийКонтекст, ".") = 2 
			Тогда
				Для Каждого МетаОбъект Из ирКэш.ОбъектМДПоПолномуИмениЛкс(ирОбщий.СтрокаБезПоследнегоФрагментаЛкс(мРодительскийКонтекст)).Таблицы Цикл
					КоллекцияЭлементовМД.Добавить(МетаОбъект.Имя);
				КонецЦикла; 
			ИначеЕсли Найти(мРодительскийКонтекст, ".") > 0 Тогда
				Если ирОбщий.ЛиКорневойТипРегистраБДЛкс(КорневойТип) Тогда
					КоллекцияЭлементовМД.Добавить("НаборЗаписей");
				КонецЕсли; 
				Если ирОбщий.ЛиКорневойТипПоследовательностиЛкс(КорневойТип) Тогда
					КоллекцияЭлементовМД.Добавить("Записи");
				КонецЕсли; 
			Иначе
				МножественноеИмяМД = ирОбщий.МножественноеИмяМДЛкс(КорневойТип);
				Если МножественноеИмяМД <> Неопределено Тогда
					Для Каждого МетаОбъект Из Метаданные[МножественноеИмяМД] Цикл
						КоллекцияЭлементовМД.Добавить(МетаОбъект);
					КонецЦикла;
				КонецЕсли; 
			КонецЕсли; 
		Иначе
			Для Каждого СтрокаТипаМетаОбъекта Из ирКэш.ТипыМетаОбъектов(Ложь, Ложь, Ложь) Цикл
				КоллекцияЭлементовМД.Добавить(СтрокаТипаМетаОбъекта.Единственное);
			КонецЦикла;
		КонецЕсли;  
	ИначеЕсли Истина
		И ВыбраннаяСтруктураТипа.ТипЯзыка = "ПолеПространстваБлокировок" 
		И ТипЗнч(ВыбраннаяСтруктураТипа.Метаданные) = Тип("БлокировкаДанных")
	Тогда
		ЛиНаборЗначенийПолный = Истина;
		ПространствоБлокировки = ВыбраннаяСтруктураТипа.Метаданные[0].Область;
		КорневойТип = ирОбщий.ПервыйФрагментЛкс(ПространствоБлокировки);
		ОбъектМД = ирОбщий.ПолучитьМетаданныеЛкс(ПространствоБлокировки);
		ЭтоТаблицаВнешнейБД = ирОбщий.ЛиКорневойТипВнешнегоИсточникаДанныхЛкс(КорневойТип);
		Если ирОбщий.ЛиМетаданныеСсылочногоОбъектаЛкс(ОбъектМД) Тогда
			КоллекцияЭлементовМД.Добавить("Ссылка");
			Если ОбъектМД <> Неопределено Тогда
				#Если Сервер И Не Сервер Тогда
					ОбъектМД = Метаданные.Справочники.Пользователи;
				#КонецЕсли
				Для Каждого ПолеБлокировки Из ОбъектМД.ПоляБлокировкиДанных Цикл
					КоллекцияЭлементовМД.Добавить(ПолеБлокировки.Имя);
				КонецЦикла;
			КонецЕсли; 
		Иначе
			Если ОбъектМД <> Неопределено Тогда
				#Если Сервер И Не Сервер Тогда
					ОбъектМД = Метаданные.РегистрыСведений.КурсыВалют;
				#КонецЕсли
				Если Найти(ПространствоБлокировки, "." + "НаборЗаписей") > 0 Тогда
					СтруктураКлюча = ирОбщий.СтруктураКлючаТаблицыБДЛкс(ирКэш.ИмяТаблицыИзМетаданныхЛкс(ОбъектМД.ПолноеИмя()), Ложь);
				Иначе
					СтруктураКлюча = Новый Структура;
					Если ирОбщий.ЛиКорневойТипРегистраСведенийЛкс(КорневойТип) Тогда
						Если ОбъектМД.ПериодичностьРегистраСведений <> Метаданные.СвойстваОбъектов.ПериодичностьРегистраСведений.Непериодический Тогда
							СтруктураКлюча.Вставить(ирОбщий.ПеревестиСтроку("Период"));
						КонецЕсли; 
						Если ОбъектМД.РежимЗаписи = Метаданные.СвойстваОбъектов.РежимЗаписиРегистра.ПодчинениеРегистратору Тогда
							СтруктураКлюча.Вставить(ирОбщий.ПеревестиСтроку("Регистратор"));
						КонецЕсли; 
					КонецЕсли; 
					Если ирОбщий.ЛиКорневойТипРегистраРасчетаЛкс(КорневойТип) Тогда
						СтруктураКлюча.Вставить(ирОбщий.ПеревестиСтроку("ПериодРегистрации"));
						СтруктураКлюча.Вставить(ирОбщий.ПеревестиСтроку("ПериодДействия"));
					КонецЕсли; 
					Если ЭтоТаблицаВнешнейБД Тогда
						//! ОбъектМД = Метаданные.ВнешниеИсточникиДанных.Tropic.Таблицы.dbo_Dorem_Lines;
						Для Каждого ПолеКлюча Из ОбъектМД.ПоляКлюча Цикл
							СтруктураКлюча.Вставить(ПолеКлюча.Имя);
						КонецЦикла;
					Иначе
						Для Каждого Измерение Из ОбъектМД.Измерения Цикл
							СтруктураКлюча.Вставить(Измерение.Имя);
						КонецЦикла;
					КонецЕсли; 
				КонецЕсли; 
				Для Каждого КлючИЗначение Из СтруктураКлюча Цикл
					КоллекцияЭлементовМД.Добавить(КлючИЗначение.Ключ);
				КонецЦикла;
			КонецЕсли; 
		КонецЕсли; 
	ИначеЕсли Истина
		И ВыбраннаяСтруктураТипа.ТипЯзыка = "ПолеИсточника" 
		И ТипЗнч(ВыбраннаяСтруктураТипа.Метаданные) = Тип("БлокировкаДанных")
	Тогда
		ЛиНаборЗначенийПолный = Истина;
		ТаблицаТиповИсточника = ВыбраннаяСтруктураТипа.Метаданные[0].ИсточникДанных;
		Если ТаблицаТиповИсточника <> Неопределено Тогда
			ТаблицаТиповКолонок = ВычислитьТипДочернегоЭлемента(ТаблицаТиповИсточника, "Колонки", "Свойство");
			ЛучшийТип = ЛучшийТипИзТаблицыТипов(ТаблицаТиповКолонок, 4);
			Если ЛучшийТип <> Неопределено Тогда
				ПараметрыЗаполнения = мПлатформа.НовыеПараметрыЗаполненияСлов("Свойство", БазовоеРасширениеКонфигурации,,,,,,, ФильтроватьСлово);
				КоллекцияЭлементовМД = мПлатформа.ТаблицаСловИзСтруктурыТипа(ЛучшийТип, ПараметрыЗаполнения).ВыгрузитьКолонку("Слово");
			КонецЕсли;
		КонецЕсли;
	ИначеЕсли Истина
		И ирОбщий.СтрокиРавныЛкс(мИмяМетодаВызова, "COMОбъект") 
		И мНомерПараметра = 1 
		И ВыбраннаяСтруктураТипа.ТипЯзыка <> ""
	Тогда
		ЛиНаборЗначенийПолный = Истина;
		Если ИменаВсехКомКлассов = Неопределено Тогда
			Компьютер = "localhost";
			ИменаВсехКомКлассов = Новый Соответствие;
			КаталогПриложений = Новый COMОбъект("COMAdmin.COMAdminCatalog");
			КаталогПриложений.Connect(Компьютер);
			Компоненты = КаталогПриложений.GetCollection("InprocServers");
			Компоненты.Populate();
			ДобавитьCOMКлассыВСписокСлов(ИменаВсехКомКлассов, Компоненты);
			Компоненты = КаталогПриложений.GetCollection("WOWLegacyServers");
			Компоненты.Populate();
			ДобавитьCOMКлассыВСписокСлов(ИменаВсехКомКлассов, Компоненты);
			Компоненты = КаталогПриложений.GetCollection("LegacyServers");
			Компоненты.Populate();
			ДобавитьCOMКлассыВСписокСлов(ИменаВсехКомКлассов, Компоненты);
			ИменаВсехКомКлассов = ирОбщий.ВыгрузитьСвойствоЛкс(ИменаВсехКомКлассов);
		КонецЕсли; 
		КоллекцияЭлементовМД = ИменаВсехКомКлассов;
	КонецЕсли; 
	Возврат КоллекцияЭлементовМД;
КонецФункции

// Параметр берется по номеру мНомерПараметра.
// Параметры:
//    СтрокаМетода - СтрокаТаблицыЗначений, см. мМетодМодуля - 
//    ЛиНаборЗначенийПолный - Булево								  -  
//    ИмяТипаСтруктуры	 - Строка - если пустое, то непосредственно литерал
// Возвращаемое значение:
//    Массив, ТаблицаЗначений - 
Функция ВозможныеТекстовыеЗначенияПараметраИзДругогоМетода(Знач СтрокаМетода, ЛиНаборЗначенийПолный = Истина, Знач ИмяТипаСтруктуры = "", Знач ДобавлятьНизкоВероятные = Ложь,
		Знач ФильтроватьСлово = Неопределено)
	СтарыеКлючевыеПараметры = СтрокаМетода.КлючевыеПараметры;
	СтрокаМетода.КлючевыеПараметры = Новый Структура;
	ФактическиеПараметры = мФактическиеПараметры;
	ИмяПараметра = ИмяПараметраВызоваМетода(СтрокаМетода);
	ВызывающийМетод = мМетодМодуля;
	Если мРекурсивныйПуть = Неопределено Тогда
		//СтарыеКлючевыеПараметрыКорневые = ВызывающийМетод.КлючевыеПараметры;
		//ВызывающийМетод.КлючевыеПараметры = Новый Структура;
		ИнициироватьРекурсивныйПуть();
	КонецЕсли;
	СтарыйРекурсивныйПуть = ирОбщий.СкопироватьКоллекциюЛкс(мРекурсивныйПуть);
	мРекурсивныйПуть.ДобавлятьКлючевыеПараметры = Истина;
	мРекурсивныйПуть.ВычислениеРезультатаМетода = СтрокаМетода.Имя;
	мРекурсивныйПуть.ДопКлючКэша = Неопределено; // Отключаем кэш, чтобы ключевые параметры всегда находить
	ЛиНаборЗначенийПолный = Ложь;
	Если СтрокаМетода.ИмяМодуля <> мМодульМетаданных.Имя Тогда
		АнализаторКодаМодуля = мПлатформа.ПолеТекстаМодуля(СтрокаМетода.ИмяМодуля);
		АнализаторКодаМодуля.мРекурсивныйПуть = мРекурсивныйПуть; // Защита от циклической рекурсии
	Иначе 
		//АнализаторКодаМодуля = КопияКомпоненты(); // 5мс
		АнализаторКодаМодуля = ЭтотОбъект;
	КонецЕсли;
	АнализаторКодаМодуля.ЗагрузитьМетодМодуля(СтрокаМетода);
	КоллекцияЭлементовМД = АнализаторКодаМодуля.ВозможныеТекстовыеЗначенияВыраженияИзТекущегоМетода(ИмяПараметра, ЛиНаборЗначенийПолный, ИмяТипаСтруктуры,, ДобавлятьНизкоВероятные, ФильтроватьСлово); 
	// Если при вычислении обнаружены зависимости от параметров, то повторяем вычисление после расчета типов этих параметров
	КлючевыеПараметры = СтрокаМетода.КлючевыеПараметры; // Берем прямой указатель, т.к. свойство может быть перезаписано в мПлатформа.ПодготовитьТипЗначенияСловаМодуля 
	Если ЗначениеЗаполнено(КлючевыеПараметры) Тогда
		АнализаторКодаМодуля.ЗагрузитьМетодМодуля(ВызывающийМетод);
		ИндексПараметра = -1;
		ЕстьВлияющиеФактПараметры = Ложь;
		ПараметрыМетода = мПлатформа.ПараметрыМетодаМодуля(СтрокаМетода);
		Для Каждого СтрокаПараметра Из ПараметрыМетода Цикл
			Если ФактическиеПараметры.Количество() = ИндексПараметра + 1 Тогда
				Прервать;
			КонецЕсли;
			ИндексПараметра = ИндексПараметра + 1;
			Если Не КлючевыеПараметры.Свойство(СтрокаПараметра.Имя) Тогда
				Продолжить;
			КонецЕсли; 
			ВыражениеПараметра = ФактическиеПараметры[ИндексПараметра];
			Если Истина
				И ЗначениеЗаполнено(ВыражениеПараметра) 
				И СтрокаПараметра.Имя <> ИмяПараметра
			Тогда
				ТаблицаТиповПараметра = ВычислитьТипЗначенияВыражения(ВыражениеПараметра,,,,,, Ложь,,,,, мПозицияВБлоке);
				Если мПлатформа.ЛиДетальностьТиповДостаточна(ТаблицаТиповПараметра) Тогда
					КлючевыеПараметры[СтрокаПараметра.Имя] = ТаблицаТиповПараметра;
					ЕстьВлияющиеФактПараметры = Истина;
				КонецЕсли;
				КоллекцияЭлементовМД = Новый Массив;
			КонецЕсли;
		КонецЦикла;
		СтрокаМетода.КлючевыеПараметры = КлючевыеПараметры;
		Если ЕстьВлияющиеФактПараметры Тогда
			ВсеВлияющиеПараметрыВычислены = Истина;
			Для Каждого КлючИЗначение Из СтрокаМетода.КлючевыеПараметры Цикл
				Если Истина
					И КлючИЗначение.Значение = Неопределено 
					И КлючИЗначение.Ключ <> ИмяПараметра
					И ПустаяСтрока(ПараметрыМетода.Найти(НРег(КлючИЗначение.Ключ), "НИмя").Значение)
				Тогда
					ВсеВлияющиеПараметрыВычислены = Ложь;
				КонецЕсли;
			КонецЦикла;
			Если ВсеВлияющиеПараметрыВычислены Тогда
				мРекурсивныйПуть.СчетчикиВызовов.Очистить();
				мРекурсивныйПуть.ДопКлючКэша = Неопределено; // Повторно отключаем кэш, т.к. он мог быть включен в рекурсивном вызове
				мТаблицаСловЛитерала = Неопределено;
				ЛиНаборЗначенийПолный = Ложь;
				АнализаторКодаМодуля.ЗагрузитьМетодМодуля(СтрокаМетода);
				КоллекцияЭлементовМД = АнализаторКодаМодуля.ВозможныеТекстовыеЗначенияВыраженияИзТекущегоМетода(ИмяПараметра, ЛиНаборЗначенийПолный, ИмяТипаСтруктуры,, ДобавлятьНизкоВероятные, ФильтроватьСлово);
			КонецЕсли;
		КонецЕсли;
	КонецЕсли;
	Если Истина
		И ТипЗнч(КоллекцияЭлементовМД) = Тип("ТаблицаЗначений") 
		И КоллекцияЭлементовМД.Колонки.Найти("Слово") <> Неопределено
	Тогда
		мТаблицаСловЛитерала = КоллекцияЭлементовМД;
	КонецЕсли;
	СтрокаМетода.КлючевыеПараметры = СтарыеКлючевыеПараметры;
	//ВызывающийМетод.КлючевыеПараметры = СтарыеКлючевыеПараметрыКорневые;
	Если АнализаторКодаМодуля = ЭтотОбъект Тогда
		АнализаторКодаМодуля.ЗагрузитьМетодМодуля(ВызывающийМетод);
	КонецЕсли;
	мРекурсивныйПуть = СтарыйРекурсивныйПуть;
	мФактическиеПараметры = ФактическиеПараметры;
	Возврат КоллекцияЭлементовМД;
КонецФункции

Функция ДопКлючКэшаДляВычисленийВМетоде() Экспорт
	ДопКлючКэша = "";
	Если Истина
		И мМетодМодуля <> Неопределено
		И мМетодМодуля.КлючевыеПараметры <> Неопределено
	Тогда
		Для Каждого КлючИЗначение Из мМетодМодуля.КлючевыеПараметры Цикл
			Если КлючИЗначение.Значение <> Неопределено Тогда
				ДопКлючКэша = Неопределено; // Отключаем кэш
				Прервать;
			КонецЕсли;
		КонецЦикла;
	КонецЕсли;
	Возврат ДопКлючКэша;
КонецФункции

//.
// Параметры:
//    Форма -  - 
// Возвращаемое значение:
//    Массив из КолонкаТаблицыЗначений - 
Функция СписокРеквизитовУправляемойФормы(Знач Форма, Знач ПутьКРодителю = "") Экспорт
	КоллекцияЭлементовМД = Новый ТаблицаЗначений;
	ЛиДляКоллекции = Ложь;
	Если Найти(ПутьКРодителю, "[") > 0 Тогда
		ПутьКРодителю = ирОбщий.ЗаменитьРегВыражениеЛкс(ПутьКРодителю, "\[[^\]*]\]", "");
		ЛиДляКоллекции = Истина;
	КонецЕсли;
	Для Каждого КлючИЗначение Из мПлатформа.ИменаРеквизитовФормы(Форма, ПутьКРодителю, ЛиДляКоллекции).Все Цикл 
		ОписаниеТипов = КлючИЗначение.Значение;
		Если ТипЗнч(ОписаниеТипов) = Тип("ТаблицаЗначений") Тогда
			ОписаниеТипов = мПлатформа.ОписаниеТиповИзТаблицыТипов(ОписаниеТипов);
		КонецЕсли;
		КоллекцияЭлементовМД.Колонки.Добавить(КлючИЗначение.Ключ, ОписаниеТипов);
	КонецЦикла;
	КоллекцияЭлементовМД = КоллекцияЭлементовМД.Колонки;
	Возврат КоллекцияЭлементовМД;
КонецФункции

//.
// Параметры:
//    СтараяТекущаяПозиция - Неопределено - 
Процедура ПерезагрузитьКонтекстЕслиПозицияИзменилась(Знач СтараяТекущаяПозиция, Знач СтарыйМетод) Экспорт
	Если СтараяТекущаяПозиция <> мПозицияВТексте Тогда 
		ПолеТекста.УстановитьГраницыВыделения(СтараяТекущаяПозиция, СтараяТекущаяПозиция);
		КончитьОбработкуКоманды();
		РазобратьТекущийКонтекст(,, Истина,,,, СтараяТекущаяПозиция);
	Иначе
		ЗагрузитьМетодМодуля(СтарыйМетод);
	КонецЕсли;
КонецПроцедуры

// Меняет позицию каретки в поле и контекст, т.к. зовет РазобратьТекущийКонтекст(). Безопаснее вызывать через копию компоненты.
//
// Параметры:
//  ИмяПеременной						 - Строка - выражение, для которого ищем возможные значения
//  ЛиНаборЗначенийПолный	 - Булево - 
//  ИмяТипаСтруктуры	 - Строка - если пустое, то непосредственно литерал
// 
// Возвращаемое значение:
//  Массив, см. мПлатформа.НоваяТаблицаСлов() - 
//
Функция ВозможныеТекстовыеЗначенияВыраженияИзТекущегоМетода(Знач ИмяПеременной, ЛиНаборЗначенийПолный = Ложь, Знач ИмяТипаСтруктуры = "", Знач ЛиСобиратьПрисвоения = Ложь,
		Знач ДобавлятьНизкоВероятные = Ложь, Знач ФильтроватьСлово = Неопределено) Экспорт
	ИмяШаблон = ирОбщий.ТекстДляРегВыраженияЛкс(ИмяПеременной);
	БазовоеРасширениеКонфигурации = БазовоеРасширениеКонфигурации();
	Позиция0ВМетодеДо = 0;
	ЗначенияПараметра = Новый Массив;
	Если ИмяТипаСтруктуры = "" Тогда
		Если Истина
			И Не ЛиНаборЗначенийПолный 
			И (Ложь
				Или Найти(мТекстБлока, "[" + ИмяПеременной + "]") > 0 
				Или Найти(мТекстБлока, ".Свойство(" + ИмяПеременной) > 0)
		Тогда
			ВхожденияОбъектов = НайтиВхожденияРегВыраженияКэш("(" + шОбъектноеВыражение + ")(?:\[" + ИмяШаблон + "\]|\.Свойство\(\s*" + ИмяШаблон + "[,\s\)])",,, "ОбъектСЧтениемСвойства;" + ИмяПеременной);
			ПараметрыЗаполнения = Неопределено;
			Для Каждого Вхождение Из ВхожденияОбъектов Цикл
				ПозицияВхождения0 = Вхождение.FirstIndex;
				ВыражениеВладелецСвойств = Вхождение.SubMatches(0);
				ТаблицаТипов = ВычислитьТипЗначенияВыражения(ВыражениеВладелецСвойств,,,,,, Ложь,,,,, ПозицияВхождения0);
				ПодготовитьТаблицуТиповКЗаполнениюТаблицыСлов(ТаблицаТипов);
				ТаблицаСловОбъекта = Неопределено;
				Для Каждого СтруктураТипа Из ТаблицаТипов Цикл
					Если Истина
						И мПлатформа.мРежимПроверкиМодуля
						И ирОбщий.ЛиИмяТипаФормыЛкс(СтруктураТипа.ИмяОбщегоТипа, Истина) 
						И СтруктураТипа.Детальность < 5 
					Тогда
						Продолжить;
					КонецЕсли;
					Если ПараметрыЗаполнения = Неопределено Тогда
						ПараметрыЗаполнения = мПлатформа.НовыеПараметрыЗаполненияСлов("Свойство", БазовоеРасширениеКонфигурации,,,,,,, ФильтроватьСлово,,,,,, Истина);
					КонецЕсли;
					ТаблицаСловОбъекта = мПлатформа.ТаблицаСловИзСтруктурыТипа(СтруктураТипа, ПараметрыЗаполнения);
				КонецЦикла;
				Если ТаблицаСловОбъекта <> Неопределено Тогда
					ЗначенияПараметра = ИзвлечьВложенныеТипыИзТаблицыСлов(ТаблицаСловОбъекта);
					Если ЗначенияПараметра.Количество() > 0 Тогда
						ЛиНаборЗначенийПолный = Истина;
						Прервать;
					КонецЕсли;
				КонецЕсли;
			КонецЦикла;
		КонецЕсли;
		Если Истина
			И Не ЛиНаборЗначенийПолный 
			И Найти(мТекстБлока, "ЗаполнитьЗначенияСвойств(") > 0 
		Тогда
			// Мультиметка00193361 Вероятно дублирование
			ШаблонПоиска = шПредИнструкция + "ЗаполнитьЗначенияСвойств\(\s*(" + шОбъектноеВыражение + ")\s*,\s*(" + шОбъектноеВыражение + ")\s*,\s*" + ИмяШаблон + "(?=[\s,\)])";
			ВхожденияОбъектов = НайтиВхожденияРегВыраженияКэш(ШаблонПоиска,,, "ОбъектИзЗаполнитьЗначенияСвойств;" + ИмяПеременной);
			ПараметрыЗаполнения = Неопределено;
			Для Каждого Вхождение Из ВхожденияОбъектов Цикл
				ПозицияВхождения0 = Вхождение.FirstIndex;
				Для Счетчик = 0 По 1 Цикл
					ВыражениеВладелецСвойств = Вхождение.SubMatches(Счетчик*4);
					ТаблицаТипов = ВычислитьТипЗначенияВыражения(ВыражениеВладелецСвойств,,,,,, Ложь,,,,, ПозицияВхождения0);
					Если ТаблицаТипов.Количество() = 0 Тогда
						Продолжить;
					КонецЕсли;
					ТаблицаТипов.Сортировать("Детальность Убыв");
					ПодготовитьТаблицуТиповКЗаполнениюТаблицыСлов(ТаблицаТипов);
					Если ПараметрыЗаполнения = Неопределено Тогда
						ПараметрыЗаполнения = мПлатформа.НовыеПараметрыЗаполненияСлов("Свойство", БазовоеРасширениеКонфигурации,,,,,,, ФильтроватьСлово,,,,,, Истина);
					КонецЕсли;
					ПараметрыЗаполнения.ТаблицаСлов = Неопределено;
					Для СчетчикТипа = 1 По Мин(5, ТаблицаТипов.Количество()) Цикл // для ВсеЭлементыФормы нужно 5
						ЛучшийТип = ТаблицаТипов[СчетчикТипа - 1];
						ТаблицаСловОбъекта = мПлатформа.ТаблицаСловИзСтруктурыТипа(ЛучшийТип, ПараметрыЗаполнения);
						ПараметрыЗаполнения.ТаблицаСлов = ТаблицаСловОбъекта;
					КонецЦикла;
					Если ТаблицаСловОбъекта.Количество() > 1 Тогда
						ЛиНаборЗначенийПолный = Истина;
						Прервать;
					КонецЕсли;
				КонецЦикла;
				Если ЛиНаборЗначенийПолный Тогда
					ЗначенияПараметра = ИзвлечьВложенныеТипыИзТаблицыСлов(ТаблицаСловОбъекта);
					Прервать;
				КонецЕсли;
			КонецЦикла;
		КонецЕсли;
		Если Истина
			И Не ЛиНаборЗначенийПолный 
			И (Ложь
				Или Найти(мТекстБлока, "Выполнить(") > 0 
				Или Найти(мТекстБлока, "Вычислить(") > 0) 
		Тогда
			ШаблонПоиска = шПредИнструкция + "(?:Выполнить|Вычислить)\(""(" + шИмя + ")\.""\s*\+\s*" + ИмяШаблон + "\s*\+\s*""\(";
			ВхожденияОбъектов = НайтиВхожденияРегВыраженияКэш(ШаблонПоиска,,, "ДинамическийВызов;" + ИмяПеременной);
			ПараметрыЗаполнения = Неопределено;
			Для Каждого Вхождение Из ВхожденияОбъектов Цикл
				ПозицияВхождения0 = Вхождение.FirstIndex;
				ИмяПараметраОбъекта = Вхождение.SubMatches(0);
				ТаблицаТипов = ВычислитьТипЗначенияВыражения(ИмяПараметраОбъекта,,,,,, Ложь,,,,, ПозицияВхождения0);
				Если ТаблицаТипов.Количество() = 0 Тогда
					Продолжить;
				КонецЕсли;
				ЛучшийТип = ЛучшийТипИзТаблицыТипов(ТаблицаТипов);
				Если ЛучшийТип = Неопределено Тогда
					Продолжить;
				КонецЕсли;
				Если ПараметрыЗаполнения = Неопределено Тогда
					ПараметрыЗаполнения = мПлатформа.НовыеПараметрыЗаполненияСлов("Метод", БазовоеРасширениеКонфигурации);
				КонецЕсли;
				ТаблицаСловОбъекта = мПлатформа.СловаКонтекстаМетаданные(ЛучшийТип, ПараметрыЗаполнения);
				Если ТаблицаСловОбъекта.Количество() > 0 Тогда
					ЗначенияПараметра = ИзвлечьВложенныеТипыИзТаблицыСлов(ТаблицаСловОбъекта);
					ЛиНаборЗначенийПолный = Истина;
					Прервать;
				КонецЕсли;
			КонецЦикла;
		КонецЕсли;
		Если Истина
			И (Ложь
				Или ДобавлятьНизкоВероятные И Не мПлатформа.мРежимПроверкиМодуля
				Или ЛиНаборЗначенийПолный)
			И (Ложь
				Или Найти(мТекстБлока, ИмяПеременной + "=") > 0 
				Или Найти(мТекстБлока, ИмяПеременной + " =") > 0)
		Тогда
			ШаблонПоиска = шПредИмяПрямое + "(?:(?:" + ШаблонВыраженияВУсловии() + ")\s|\(|,)";
			Если ЛиСобиратьПрисвоения Тогда
				ШаблонПоиска = ШаблонПоиска + "?";
			КонецЕсли;
			ШаблонПоиска = ШаблонПоиска + "\s*" + ИмяШаблон + "\s*=\s*(" + шЛитералПрограммы + ")";
			ВхожденияОбъектов = НайтиВхожденияРегВыраженияКэш(ШаблонПоиска,,, "ЛитеральныеЗначенияПараметра;" + ИмяПеременной);
			Для Каждого Вхождение Из ВхожденияОбъектов Цикл
				ЗначениеПараметра = Вхождение.SubMatches(0);
				Если СтрДлина(ЗначениеПараметра) > 200 Тогда
					Продолжить;
				КонецЕсли;
				ЗначениеПараметра = ирОбщий.ТекстИзВстроенногоЯзыкаЛкс(ЗначениеПараметра);
				Если Ложь
					Или ПустаяСтрока(ЗначениеПараметра)
					Или (Истина
						И ЛиСобиратьПрисвоения
						// Исключаем текущий литерал
						И Вхождение.FirstIndex < мПозицияВБлоке
						И Вхождение.FirstIndex + Вхождение.Length > мПозицияВБлоке)
					Или ЗначенияПараметра.Найти(ЗначениеПараметра) <> Неопределено
				Тогда
					Продолжить;
				КонецЕсли;
				ЗначенияПараметра.Добавить(ЗначениеПараметра);
			КонецЦикла;
		КонецЕсли;
		Если ЛиНаборЗначенийПолный Тогда
			Возврат ЗначенияПараметра;
		КонецЕсли; 
	ИначеЕсли ИмяТипаСтруктуры = "Структура" Тогда 
		ГлубинаВеток = НоваяГлубинаВеток();
		ШаблонПоискаПрисвоения = "(?:" + мПлатформа.шПустоеНачалоСтроки + "|;\s*)" + ИмяПеременной + "\s*=";
		ВхожденияИсточника = НайтиВхожденияРегВыраженияКэш(ШаблонПоискаПрисвоения, ,, "Присвоение;" + ИмяПеременной);
		Для Каждого Вхождение Из ВхожденияИсточника Цикл
			Если ЛиВхождениеВЗапрешенномДиапазоне(Вхождение, мПозицияВБлоке) Тогда
				Продолжить;
			КонецЕсли;
			СчитатьГлубинуВеток(, ГлубинаВеток, Вхождение.FirstIndex, Вхождение);
			Если Истина
				И ГлубинаВеток.Альтернативная >= 0 
				И ГлубинаВеток.Необязательная <> ГлубинаВеток.Альтернативная
			Тогда
				Продолжить;
			КонецЕсли; 
			Позиция0ВМетодеДо = Вхождение.FirstIndex;
			Прервать;
		КонецЦикла;    
		Результат = Новый Массив;
		Вхождения = НайтиВхожденияРегВыраженияКэш(шПредИмяПрямое + "(?:Открыть|Получить)Форму(?:Модально)?\(\s*""([^""]+)""\s*,\s*(" + шИмя + ")",, мТекстДляПоискаОпределения, "ПараметрыФормы");
		Для Каждого Вхождение Из Вхождения Цикл
			Если ЛиВхождениеВЗапрешенномДиапазоне(Вхождение, мПозицияВБлоке, Позиция0ВМетодеДо) Тогда
				Продолжить;
			КонецЕсли;
			Если Не ирОбщий.СтрокиРавныЛкс(Вхождение.SubMatches(1), ИмяПеременной) Тогда
				Продолжить;
			КонецЕсли;
			ТаблицаТипов = ТаблицаТиповИзТекста("см. " + Вхождение.SubMatches(0) + ".Параметры");
			Если ТаблицаТипов.Количество() > 0 Тогда
				ПараметрыЗаполнения = мПлатформа.НовыеПараметрыЗаполненияСлов("Свойство", БазовоеРасширениеКонфигурации);
				Результат = мПлатформа.СловаКонтекстаМетаданные(ТаблицаТипов[0], ПараметрыЗаполнения);
			КонецЕсли;
			Возврат Результат;
		КонецЦикла;
		Если Найти(мТекстБлока, "(" + ИмяПеременной) > 0 Тогда // Для ускорения. Экономит 3мс на больших текстах
			Вхождения = НайтиВхожденияРегВыраженияКэш(шПредИмяПрямое + "(" + шИмяСТочками + ")\.(?:(?:НайтиСтроки|Выгрузить|Скопировать|НайтиСледующий|ВыбратьВерсии)|ОтборСтрок\s*=\s*Новый\s*ФиксированнаяСтруктура)\(\s*(" + шИмя + ")"
					,, мТекстДляПоискаОпределения, "ОтборПоКолонкам");
			Для Каждого Вхождение Из Вхождения Цикл
				Если ЛиВхождениеВЗапрешенномДиапазоне(Вхождение, мПозицияВБлоке, Позиция0ВМетодеДо) Тогда
					Продолжить;
				КонецЕсли;
				Если Не ирОбщий.СтрокиРавныЛкс(Вхождение.SubMatches(1), ИмяПеременной) Тогда
					Продолжить;
				КонецЕсли;
				ТаблицаТипов = ВычислитьТипЗначенияВыражения(Вхождение.SubMatches(0),,,,,, Ложь,,,,, Вхождение.FirstIndex);
				Если ТаблицаТипов.Количество() > 0 Тогда
					//Результат = мПлатформа.НоваяТаблицаСлов();
					КоллекцияЭлементовМД = Неопределено;
					ЛучшийТип = ЛучшийТипИзТаблицыТипов(ТаблицаТипов);
					Если ЛучшийТип <> Неопределено Тогда
						МетаданныеТипа = ЛучшийТип.Метаданные;
					Иначе
						МетаданныеТипа = Неопределено;  
					КонецЕсли;
					Если ТипЗнч(МетаданныеТипа) = Тип("Структура") Тогда
						КоллекцияЭлементовМД = МетаданныеТипа;
					ИначеЕсли Ложь
						Или ТипЗнч(МетаданныеТипа) = Тип("ТаблицаЗначений") 
						Или ТипЗнч(МетаданныеТипа) = Тип("ДеревоЗначений")
					Тогда
						КоллекцияЭлементовМД = МетаданныеТипа.Колонки;
					ИначеЕсли ТипЗнч(МетаданныеТипа) = Тип("ОбъектМетаданных") Тогда
						КоллекцияЭлементовМД = МетаданныеТипа.Реквизиты;
					ИначеЕсли ТипЗнч(МетаданныеТипа) = Тип("ПостроительЗапроса") Тогда
						мПлатформа.ПодготовитьМетаданныеПостроителяЗапроса(МетаданныеТипа, ТаблицаТипов[0].ДержательМетаданных);
						КоллекцияЭлементовМД = Новый Массив;
						Для Каждого ВыбранноеПоле Из МетаданныеТипа.ВыбранныеПоля Цикл
							КоллекцияЭлементовМД.Добавить(МетаданныеТипа.ДоступныеПоля.Найти(ВыбранноеПоле.ПутьКДанным));
						КонецЦикла;
					ИначеЕсли Ложь
						Или ТипЗнч(МетаданныеТипа) = Тип("ДанныеФормыКоллекция") 
						Или ТипЗнч(МетаданныеТипа) = Тип("ДанныеФормыСтруктураСКоллекцией")
					Тогда
						КоллекцияЭлементовМД = мПлатформа.ДочерниеСвойстваДанныхФормы(МетаданныеТипа, Истина, ТаблицаТипов[0].ДержательМетаданных);
					ИначеЕсли ТипЗнч(МетаданныеТипа) = Тип("ТаблицаФормы") Тогда
						ТаблицаТиповДочерняя = ВычислитьТипДочернегоЭлемента(ТаблицаТипов, "ТекущиеДанные", "Свойство");
						Если ТаблицаТиповДочерняя.Количество() > 0 Тогда
							ПараметрыЗаполнения = мПлатформа.НовыеПараметрыЗаполненияСлов("Свойство", БазовоеРасширениеКонфигурации,,,, Ложь,,, ФильтроватьСлово,,,,,, Истина);
							Результат = мПлатформа.ТаблицаСловИзСтруктурыТипа(ТаблицаТиповДочерняя[0], ПараметрыЗаполнения);
						КонецЕсли;
					ИначеЕсли Ложь
						Или ТипЗнч(МетаданныеТипа) = Тип("ДанныеФормыКоллекция") 
						Или ТипЗнч(МетаданныеТипа) = Тип("ДанныеФормыСтруктураСКоллекцией")
					Тогда
						КоллекцияЭлементовМД = мПлатформа.ДочерниеСвойстваДанныхФормы(МетаданныеТипа, Истина, ТаблицаТипов[0].ДержательМетаданных);
					ИначеЕсли Истина
						И ЛучшийТип <> Неопределено
						И ЛучшийТип.ИмяОбщегоТипа = "МенеджерИсторииДанных" 
					Тогда
						ТаблицаТиповДочерняя = ВычислитьТипДочернегоЭлемента(ТаблицаТипов, "ВыбратьВерсии", "Метод");
						Если ТаблицаТиповДочерняя.Количество() > 0 Тогда
							КоллекцияЭлементовМД = ТаблицаТиповДочерняя[0].Метаданные.Колонки;
						КонецЕсли;
					КонецЕсли;
					Если КоллекцияЭлементовМД <> Неопределено Тогда
						//ДобавитьПростыеСловаВТаблицу(КоллекцияЭлементовМД,,, Результат);
						ДобавитьПростыеСловаВТаблицу(КоллекцияЭлементовМД);
					КонецЕсли;
				КонецЕсли;
				Возврат Результат;
			КонецЦикла;
		КонецЕсли;
		Если Истина
			И Не мПлатформа.мРежимПроверкиМодуля 
			И Найти(мТекстБлока, "ЗаполнитьЗначенияСвойств(") > 0 
		Тогда
			ШаблонПоиска = шПредИнструкция + "ЗаполнитьЗначенияСвойств\(\s*(" + шОбъектноеВыражение + ")\s*,\s*(" + шОбъектноеВыражение + ")\s*(,\s*" + шОбъектноеВыражение + ")?(?=[\s,\)])";
			ВхожденияОбъектов = НайтиВхожденияРегВыраженияКэш(ШаблонПоиска,,, "ОбъектИзЗаполнитьЗначенияСвойств");
			ПараметрыЗаполнения = Неопределено;
			Для Каждого Вхождение Из ВхожденияОбъектов Цикл
				Если ЛиВхождениеВЗапрешенномДиапазоне(Вхождение, мПозицияВБлоке, Позиция0ВМетодеДо) Тогда
					Продолжить;
				КонецЕсли;
				ПозицияВхождения0 = Вхождение.FirstIndex;
				ЕстьСовпадение = Ложь;
				ВыражениеИсточник = "";
				Для Счетчик = 0 По 1 Цикл
					ВыражениеВладелецСвойств = Вхождение.SubMatches(Счетчик*4);
					Если ирОбщий.СтрокиРавныЛкс(ИмяПеременной, ВыражениеВладелецСвойств) Тогда
						ЕстьСовпадение = Истина;
					Иначе
						ВыражениеИсточник = ВыражениеВладелецСвойств;
					КонецЕсли;
				КонецЦикла;
				Если ЕстьСовпадение И ЗначениеЗаполнено(ВыражениеИсточник) Тогда
					ТаблицаТипов = ВычислитьТипЗначенияВыражения(ВыражениеИсточник,,,,,, Ложь,,,,, ПозицияВхождения0);
					Если ТаблицаТипов.Количество() > 0 Тогда
						ЛучшийТип = ЛучшийТипИзТаблицыТипов(ТаблицаТипов);
						Если ПараметрыЗаполнения = Неопределено Тогда
							ПараметрыЗаполнения = мПлатформа.НовыеПараметрыЗаполненияСлов("Свойство", БазовоеРасширениеКонфигурации,,,,,,, ФильтроватьСлово,,,,,, Истина);
						КонецЕсли;
						Результат = мПлатформа.ТаблицаСловИзСтруктурыТипа(ЛучшийТип, ПараметрыЗаполнения);
						Если Результат.Количество() > 1 Тогда
							Возврат Результат;
						КонецЕсли;
					КонецЕсли;
				КонецЕсли;
			КонецЦикла;
		КонецЕсли;
	ИначеЕсли ИмяТипаСтруктуры = "Массив" Тогда
		Если Ложь
			Или ирОбщий.СтрокиРавныЛкс(ИмяПеременной, "Поля") // ОбработкаПолученияПолейПредставления
			Или ирОбщий.СтрокиРавныЛкс(ИмяПеременной, "ПроверяемыеРеквизиты") // ОбработкаПроверкиЗаполнения, ОбработкаПроверкиЗаполненияНаСервере
			Или ирОбщий.СтрокиРавныЛкс(ИмяПеременной, "ИсключитьДанные") //ОбработкаФормированияПоВерсииИсторииДанных
		Тогда
			СтрокаПараметра = СтрокаПараметраМетодаМодуля(ИмяПеременной);
			Если СтрокаПараметра <> Неопределено Тогда
				ТаблицаТипов = ВычислитьТипПараметраМетодаМодуля(СтрокаПараметра.Владелец(), СтрокаПараметра);
				Если Истина
					И ТаблицаТипов.Количество() > 0 
					И ЛиСистемноеСлово(ТаблицаТипов[0])
				Тогда
					Если ТипЗнч(мМодульМетаданных.СтруктураТипа.Метаданные) = Тип("ОбъектМетаданных") Тогда
						ПоляТаблицы = ирОбщий.ПоляТаблицыМДЛкс(мМодульМетаданных.СтруктураТипа.Метаданные);
						Результат = мПлатформа.НоваяТаблицаСлов();
						Для Каждого ПолеТаблицы Из ПоляТаблицы Цикл
							мПлатформа.ДобавитьВТаблицуСлов(Результат, ПолеТаблицы.Имя,, мПлатформа.ТаблицаТиповИзОписанияТипов(ПолеТаблицы.ТипЗначения));
						КонецЦикла;
						Возврат Результат;
					ИначеЕсли ирОбщий.ЛиФормаИлиИмитаторЛкс(мМодульМетаданных.СтруктураТипа.Метаданные) Тогда
						РеквизитыФормы = СписокРеквизитовУправляемойФормы(мМодульМетаданных.СтруктураТипа.Метаданные, мРодительскийКонтекст);
						Результат = мПлатформа.НоваяТаблицаСлов();
						Для Каждого РеквизитФормы Из РеквизитыФормы Цикл
							мПлатформа.ДобавитьВТаблицуСлов(Результат, РеквизитФормы.Имя,, мПлатформа.ТаблицаТиповИзОписанияТипов(РеквизитФормы.ТипЗначения));
						КонецЦикла;
						Возврат Результат;
					КонецЕсли;
				КонецЕсли;
			КонецЕсли;
		КонецЕсли;
		Вхождения = НайтиВхожденияРегВыраженияКэш(шПредИмяПрямое + "Для\s+Каждого\s+(" + шИмя + ")\s+Из\s+(" + шИмя + ")",, мТекстДляПоискаОпределения, "ОбходМассива");
		Для Каждого Вхождение Из Вхождения Цикл
			Если ЛиВхождениеВЗапрешенномДиапазоне(Вхождение, мПозицияВБлоке) Тогда
				Продолжить;
			КонецЕсли;
			Если Не ирОбщий.СтрокиРавныЛкс(Вхождение.SubMatches(1), ИмяПеременной) Тогда
				Продолжить;
			КонецЕсли;
			НовыеЗначенияПараметра = ВозможныеТекстовыеЗначенияВыраженияИзТекущегоМетода(Вхождение.SubMatches(0), ЛиНаборЗначенийПолный,,, ДобавлятьНизкоВероятные, ФильтроватьСлово);
			Если НовыеЗначенияПараметра.Количество() > 0 Тогда
				Возврат НовыеЗначенияПараметра;
			КонецЕсли;
		КонецЦикла;
	КонецЕсли;
	Если мРекурсивныйПуть = Неопределено Тогда
		ИнициироватьРекурсивныйПуть();
	КонецЕсли;
	МаксВызываемыхМетодов = 4; // Для ускорения
	СчетчикиВызовов = мРекурсивныйПуть.СчетчикиВызовов;
	СчетчикиВызовов[НРег(ИмяТекущегоМетода())] = 1;
	Если СчетчикиВызовов.Количество() > МаксВызываемыхМетодов Тогда 
		// Для ускорения
		Возврат ЗначенияПараметра;
	КонецЕсли;
	ИмяФиктивногоПараметра = ИмяФиктивногоПараметра();
	ЭтоТекстовыйЛитерал = мЭтоТекстовыйЛитерал;
	ПозицияТекстаДляПоискаОпределения = мПозицияТекстаДляПоискаОпределения;
	Позиция0От = мПозицияВБлоке;
	Пока Истина Цикл
		// Мультиметка241014_185112 сделать единый список таких методов
		ВхожденияВызовов = НайтиВхожденияРегВыраженияКэш("[^" + мПлатформа.шБукваЦифра + "]((Новый\s+)?(?!(?:ТипЗнч|НРег|ВРег|Лев|Прав|Сред|СокрЛ|СокрП|СокрЛП|Найти|СтрНайти|СтрДлина|СтрРазделить|ЗначениеЗаполнено)\s*\()(" 
				+ шОбъектноеВыражение + ")\s*\(\s*(?:(?:(?:" + шПростоеВыражениеПрограммы + ")?\s*,\s*)*?))" + ИмяШаблон + "\s*[,\)]"
				+ "|\s(" + шИмя + ")\s*=\s*" + ИмяШаблон + "\s*;",,, "ПараметрМетода;" + ИмяШаблон);
		ИмяПереннойПодмены = "";
		ПозицияПодмены = 0; 
		Для Каждого Вхождение Из ВхожденияВызовов Цикл
			ПозицияВхождения0 = Вхождение.FirstIndex;
			Если Вхождение.SubMatches(11) <> Неопределено Тогда
				Если Истина
					И ПустаяСтрока(ИмяПереннойПодмены)
					И Позиция0От < ПозицияВхождения0
				Тогда
					ИмяПереннойПодмены = Вхождение.SubMatches(11);
					ПозицияПодмены = ПозицияВхождения0 + Вхождение.Length;
				КонецЕсли;
				Продолжить;
			КонецЕсли;
			ПозицияВхождения0 = ПозицияВхождения0 + 1;
			ВыражениеВызоваМетода = Вхождение.SubMatches(2); 
			Если Ложь
				ИЛи ПозицияВхождения0 < Позиция0От 
				ИЛи Позиция0ВМетодеДо > 0 И ПозицияВхождения0 > Позиция0ВМетодеДо
				Или ВыражениеВызоваМетода = Неопределено
			Тогда
				Продолжить;
			КонецЕсли;
			ПозицияСсылки = СтрДлина(Вхождение.SubMatches(0)) + 1;
			КлючКэша = НРег(ВыражениеВызоваМетода);
			Если СчетчикиВызовов[КлючКэша] = 1 Тогда  
				Продолжить;
			ИначеЕсли СчетчикиВызовов[КлючКэша] = Неопределено Тогда
				СчетчикиВызовов[КлючКэша] = 1;
			Иначе
				//СчетчикиВызовов[КлючКэша] = СчетчикиВызовов[КлючКэша] + 1;
			КонецЕсли;
			ЛиВызовКонструктора = Вхождение.SubMatches(1) <> Неопределено;
			ВыражениеВызоваМетода = ВыражениеВызоваМетода + "(" + ИмяФиктивногоПараметра + ")";
			ТаблицаТипов = ВычислитьТипЗначенияВыражения(ВыражениеВызоваМетода,,,, ЛиВызовКонструктора,, Ложь,,,,, ПозицияВхождения0);
			Если ТаблицаТипов.Количество() > 0 Тогда
				ПозицияВТексте = ПозицияТекстаДляПоискаОпределения + ПозицияВхождения0 + ПозицияСсылки;
				ПолеТекста.УстановитьГраницыВыделения(ПозицияВТексте, ПозицияВТексте);
				КончитьОбработкуКоманды();
				РазобратьТекущийКонтекст(,, Истина,,,, ПозицияВТексте); 
				Если Ложь
					Или ПустаяСтрока(мВызовМетода) // Слишком большие выражения параметров
					Или Не ирОбщий.СтрНачинаетсяСЛкс(ВыражениеВызоваМетода, мВызовМетода, Истина) // Например выражение внутри текстового литерала ирКлиент.ОписаниеОповещенияЛкс
				Тогда
					Продолжить;
				КонецЕсли;
				//ТекущийВызовМетода(); 
				
				// Номер параметра передается неявно через мНомерПараметра
				НовыеЗначенияПараметра = ЗаполнитьТаблицуВозможныхЗначенийЛитерала(ТаблицаТипов[0], ЛиНаборЗначенийПолный, ИмяТипаСтруктуры, ДобавлятьНизкоВероятные, ФильтроватьСлово);
				Если НовыеЗначенияПараметра <> Неопределено Тогда
					Если Истина
						И ИмяТипаСтруктуры = "" 
						И ТипЗнч(НовыеЗначенияПараметра) = Тип("Массив")
						И ЗначенияПараметра.Количество() > 0 
					Тогда
						ирОбщий.ДополнитьМассивЛкс(НовыеЗначенияПараметра, ЗначенияПараметра);
					КонецЕсли;
					ЗначенияПараметра = НовыеЗначенияПараметра;
				КонецЕсли;
			КонецЕсли;
			Если Ложь
				Или ЛиНаборЗначенийПолный 
				Или СчетчикиВызовов.Количество() > МаксВызываемыхМетодов 
			Тогда
				Прервать;
			КонецЕсли;
		КонецЦикла;
		Если Ложь
			Или ЛиНаборЗначенийПолный 
			Или ПустаяСтрока(ИмяПереннойПодмены)
			Или ИмяПереннойПодмены = ИмяПеременнойВозвращаемогоЗначения()
		Тогда
			Прервать;
		КонецЕсли;
		ИмяШаблон = ИмяПереннойПодмены;
		Позиция0От = ПозицияПодмены; 
	КонецЦикла;
	мЭтоТекстовыйЛитерал = ЭтоТекстовыйЛитерал;
	Если ИмяТипаСтруктуры = "" И ТипЗнч(мТаблицаСловЛитерала) = Тип("ТаблицаЗначений") Тогда
		Возврат мТаблицаСловЛитерала;
	Иначе
		Возврат ЗначенияПараметра;
	КонецЕсли;
КонецФункции

Функция ИзвлечьВложенныеТипыИзТаблицыСлов(Знач ТаблицаСловОбъекта)
	//МассивСлов = ТаблицаСловОбъекта.ВыгрузитьКолонку("Слово");
	МассивСлов = Новый Массив;
	МассивМетаданных = Новый Массив; 
	Если ЗначениеЗаполнено(ТаблицаСловОбъекта) Тогда
		ЭлементКоллекцииМД = ТаблицаСловОбъекта[0].ТаблицаТипов[0].Метаданные;
		ИмяКлюча = "";
		ИмяОписанияТипа = ИмяСвойстваОписанияТипаИзОбъекта(ЭлементКоллекцииМД, ИмяКлюча);
		Если ЗначениеЗаполнено(ИмяКлюча) Тогда
			ИмяИзМетаданных = ЭлементКоллекцииМД[ИмяКлюча];
		Иначе
			ИмяИзМетаданных = "" + ЭлементКоллекцииМД;
		КонецЕсли;
		Если ИмяИзМетаданных <> ТаблицаСловОбъекта[0].Слово Тогда
			ИмяОписанияТипа = "";
		КонецЕсли;
	КонецЕсли;
	ЕстьВложенноеОписаниеТипов = ЗначениеЗаполнено(ИмяОписанияТипа);
	Для Каждого СтрокаТаблицы Из ТаблицаСловОбъекта Цикл
		МассивСлов.Добавить(СтрокаТаблицы.Слово);
		ОписаниеСлова = СтрокаТаблицы.ТаблицаТипов[0].Метаданные;
		Если Истина
			И ОписаниеСлова <> Неопределено 
			И ЕстьВложенноеОписаниеТипов
		Тогда
			МассивМетаданных.Добавить(ОписаниеСлова);
		КонецЕсли;
	КонецЦикла;
	Если МассивСлов.Количество() = МассивМетаданных.Количество() Тогда
		Возврат МассивМетаданных;
	Иначе
		Возврат МассивСлов;
	КонецЕсли;
КонецФункции

Функция ЛучшийТипИзТаблицыТипов(Знач ТаблицаТипов, Знач МинДетальность = 3) Экспорт
	ЛучшийТип = Неопределено; // Неопределено, см. мПлатформа.НоваяСтруктураТипа()
	мПлатформа.ЛиДетальностьТиповДостаточна(ТаблицаТипов, МинДетальность, Истина, ЛучшийТип);
	Возврат ЛучшийТип;
КонецФункции

//.
// Параметры:
//    КоллекцияЭлементовМД - Струкутра, Массив, Коллекция - 
Процедура ДобавитьПростыеСловаВТаблицу(Знач КоллекцияЭлементовМД, Знач ЛиПриоритетно = Ложь, Знач Определение = "Метаданные", Знач Приемник = Неопределено)
	//Если КоллекцияЭлементовМД = Неопределено Тогда
	//	Возврат;
	//КонецЕсли;
	Если Приемник = Неопределено Тогда
		Приемник = ТаблицаСлов;
	КонецЕсли;
	ШагРейтингаСлова = ШагРейтингаСлова();
	Если КоллекцияЭлементовМД = мТаблицаСловЛитерала Тогда
		ЗаполнитьТипыЗначенийСлов(мТаблицаСловЛитерала);
		ирОбщий.ЗагрузитьВТаблицуЗначенийЛкс(КоллекцияЭлементовМД, Приемник);
	Иначе
		Если КоллекцияЭлементовМД.Количество() > 0 Тогда
			Для Каждого ЭлементКоллекцииМД Из КоллекцияЭлементовМД Цикл
				Прервать;
			КонецЦикла; 
			ИмяКлюча = "";
			ИмяОписанияТипа = ИмяСвойстваОписанияТипаИзОбъекта(ЭлементКоллекцииМД, ИмяКлюча);
		КонецЕсли;
		Если ЗначениеЗаполнено(ИмяОписанияТипа) Тогда
			мТаблицаСловЛитерала = мПлатформа.НоваяТаблицаСлов();
			мТаблицаСловЛитерала.Колонки.Слово.Заголовок = "_";
			ЗаполнятьТип = КоллекцияЭлементовМД.Количество() < МаксЧислоСловДляЗаполненияТипов();
		КонецЕсли;
		Для Каждого ЭлементКоллекцииМД Из КоллекцияЭлементовМД Цикл
			СтрокаСлова = Приемник.Добавить();
			Если Не ЗначениеЗаполнено(ИмяКлюча) Тогда
				СтрокаСлова.Слово = "" + ЭлементКоллекцииМД;
			Иначе
				СтрокаСлова.Слово = ЭлементКоллекцииМД[ИмяКлюча];
			КонецЕсли; 
			СтрокаСлова.ТипСлова = "Свойство";
			СтрокаСлова.Определение = Определение;
			Если ЛиПриоритетно Тогда
				СтрокаСлова.Рейтинг = 2 * ШагРейтингаСлова;
			КонецЕсли;
			Если ЗначениеЗаполнено(ИмяОписанияТипа) Тогда
				СтрокаСлова.ТипЗначения = "??";
				СтрокаСловаСТипом = мТаблицаСловЛитерала.Добавить();
				ЗаполнитьЗначенияСвойств(СтрокаСловаСТипом, СтрокаСлова);
				ОписаниеТипов = ЭлементКоллекцииМД[ИмяОписанияТипа];
				Если ТипЗнч(ОписаниеТипов) = Тип("ОписаниеТипов") Тогда
					СтрокаСловаСТипом.ТаблицаТипов = мПлатформа.ТаблицаТиповИзОписанияТипов(ОписаниеТипов);
				ИначеЕсли ТипЗнч(ОписаниеТипов) = Тип("ТаблицаЗначений") Тогда
					СтрокаСловаСТипом.ТаблицаТипов = ОписаниеТипов;
				КонецЕсли;
				Если Истина
					И ЗаполнятьТип 
					И СтрокаСловаСТипом.ТаблицаТипов <> Неопределено
				Тогда
					ОбновитьТипЗначенияИзТаблицыТипов(СтрокаСловаСТипом,,, Истина);
					//СтрокаСлова.МожноУточнитьТип = Ложь; // В ТЧ нет
					СтрокаСлова.ТипЗначения = СтрокаСловаСТипом.ТипЗначения;
					СтрокаСлова.ТипЗначенияИндекс = СтрокаСловаСТипом.ТипЗначенияИндекс;
				КонецЕсли;
			Иначе
				СтрокаСлова.ТипЗначения = "Строка";
				СтрокаСлова.ТипЗначенияИндекс = СтрокаСлова.ТипЗначения;
			КонецЕсли;
		КонецЦикла;
	КонецЕсли;
КонецПроцедуры

//.
// Параметры:
//    ЭлементКоллекцииМД - КлючИЗначение - 
//    выхИмяКлюча - Строка - 
// Возвращаемое значение:
//    Строка - 
Функция ИмяСвойстваОписанияТипаИзОбъекта(Знач ЭлементКоллекцииМД, выхИмяКлюча = Неопределено) Экспорт
	Попытка
		Пустышка = ЭлементКоллекцииМД.ТипЗначения;
		ИмяОписанияТипа = "ТипЗначения";
	Исключение
	КонецПопытки;
	Попытка
		Пустышка = ЭлементКоллекцииМД.Имя;
		выхИмяКлюча = "Имя";
	Исключение
	КонецПопытки;  
	Если Ложь
		Или ТипЗнч(ЭлементКоллекцииМД) = Тип("Строка")
		Или ТипЗнч(ЭлементКоллекцииМД) = Тип("ПараметрКомпоновкиДанных")
		Или ТипЗнч(ЭлементКоллекцииМД) = Тип("ПолеКомпоновкиДанных")
	Тогда
		выхИмяКлюча = "";
	ИначеЕсли Ложь
		Или ТипЗнч(ЭлементКоллекцииМД) = Тип("ДоступноеПолеКомпоновкиДанных")
		Или ТипЗнч(ЭлементКоллекцииМД) = Тип("ДоступноеПолеОтбораКомпоновкиДанных")
	Тогда
		выхИмяКлюча = "Поле";
	ИначеЕсли ТипЗнч(ЭлементКоллекцииМД) = Тип("ДоступныйПараметрКомпоновкиДанных") Тогда
		выхИмяКлюча = "Параметр";
	ИначеЕсли ТипЗнч(ЭлементКоллекцииМД) = Тип("ПолеНабораДанныхСхемыКомпоновкиДанных") Тогда
		выхИмяКлюча = "ПутьКДанным";
	ИначеЕсли ТипЗнч(ЭлементКоллекцииМД) = Тип("КлючИЗначение") Тогда
		выхИмяКлюча = "Ключ";
		ИмяОписанияТипа = "Значение";
	ИначеЕсли ТипЗнч(ЭлементКоллекцииМД) = Тип("ОбъектМетаданных") Тогда
		Попытка
			Пустышка = ЭлементКоллекцииМД.Тип;
			ИмяОписанияТипа = "Тип";
		Исключение
		КонецПопытки;
	ИначеЕсли Не ЗначениеЗаполнено(выхИмяКлюча) Тогда
		ИмяОписанияТипа = "";
	КонецЕсли;
	Возврат ИмяОписанияТипа;
КонецФункции

Функция ОтобратьМетодыДляСпискаСлов(Знач Модуль, Знач ЛиЭкспортные = Истина, Знач ЛиБезПараметров = Ложь) Экспорт
КонецФункции

// Параметр берется по номеру мНомерПараметра
// Параметры:
//   СтрокаМетода -  - 
//   ТолькоСТипомСтрока - Булево - для платформенного метода находить только параметр со строковым типом значения
//   выхТаблицаТипов -  - 
//   СтруктураТипаМетода -  - 
//   ВариантСинтаксиса -  - 
//   РассчитатьТипПараметра - Булево - разрешает долгий расчет типа параметра по вызовам метода, сбрасывает РекурсивныйПуть
// Возвращаемое значение:
//   Строка - 
Функция ИмяПараметраВызоваМетода(Знач СтрокаМетода, Знач ТолькоСТипомСтрока = Истина, выхТаблицаТипов = Неопределено, Знач СтруктураТипаМетода = Неопределено, Знач ВариантСинтаксиса = Неопределено, 
		Знач РассчитатьТипПараметра = Ложь) Экспорт
	ИмяПараметра = "";
	Если СтрокаМетода = Неопределено Тогда
		Возврат ИмяПараметра;
	КонецЕсли;
	Если СтрокаМетода.Владелец().Колонки.Найти("ТелоБезВозвратов") <> Неопределено Тогда  
		//! СтрокаМетода = 0 // см. мМетодМодуля
		ПараметрыМетодаМодуля = мПлатформа.ПараметрыМетодаМодуля(СтрокаМетода);
		Если ПараметрыМетодаМодуля <> Неопределено И ПараметрыМетодаМодуля.Количество() >= мНомерПараметра Тогда
			// TODO добавить проверку на строковый тип
			СтрокаПараметра = ПараметрыМетодаМодуля[мНомерПараметра - 1];
			ИмяПараметра = СтрокаПараметра.Имя;
			Если Не ТолькоСТипомСтрока Тогда 
				Если РассчитатьТипПараметра И СтрокаПараметра.ТаблицаТипов = Неопределено Тогда
					Если СтрокаМетода.ИмяМодуля = мМодульМетаданных.Имя Тогда
						АнализаторМодуля = ЭтотОбъект
						//ЗагрузитьМетодМодуля(СтрокаМетода);
					Иначе
						АнализаторМодуля = мПлатформа.ПолеТекстаМодуля(СтрокаМетода.ИмяМодуля);
					КонецЕсли;
					выхТаблицаТипов = АнализаторМодуля.ВычислитьТипПараметраМетодаМодуля(ПараметрыМетодаМодуля, СтрокаПараметра,, СтрокаМетода);
				Иначе
					выхТаблицаТипов = ТаблицаТиповИзПараметраМетодаМодуля(СтрокаМетода, СтрокаПараметра,, СтрокаПараметра.ПозицияСОписанием);
				КонецЕсли;
			КонецЕсли;
		КонецЕсли;
	Иначе 
		// Системный метод
		//! СтрокаМетода = 0 // см. мПлатформа.ТаблицаКонтекстов[0]
		СтрокиПараметров = мПлатформа.ПараметрыМетодаПлатформы(СтрокаМетода);
		Отбор = Новый Структура("Номер", мНомерПараметра);
		Если ВариантСинтаксиса <> Неопределено Тогда
			Отбор.Вставить("ВариантСинтаксиса", ВариантСинтаксиса);
		КонецЕсли;
		СтрокиПараметров = СтрокиПараметров.НайтиСтроки(Отбор);
		Для Каждого СтрокаПараметра Из СтрокиПараметров Цикл // Может быть несколько вариантов синтаксиса
			Если Ложь
				Или Не ТолькоСТипомСтрока
				Или Найти(СтрокаПараметра.ТипЗначения, "Строка") > 0 
				Или Истина
					// Структура - По ключам и значениям
					И СтрокаПараметра.ТипЗначения = "Произвольный"  
					И Найти(СтрокаПараметра.Описание, "Строка") > 0
			Тогда
				ИмяПараметра = ПодготовитьИмяПараметраМетодаПлатформы(СтрокаПараметра.Параметр);
				Если Не ТолькоСТипомСтрока Тогда
					ИмяТипаЗначения = СтрокаПараметра.ТипЗначения;
					Если Истина
						И Найти(ИмяТипаЗначения, "<") > 0 
						И ТипЗнч(СтруктураТипаМетода.Метаданные) = Тип("ОбъектМетаданных")
					Тогда
						ИмяТипаЗначения = ирОбщий.СтрЗаменитьЛкс(ИмяТипаЗначения, ирОбщий.ТекстМеждуМаркерамиЛкс(ИмяТипаЗначения, "<", ">",, Истина), СтруктураТипаМетода.Метаданные.Имя);
					ИначеЕсли Истина
						И ПустаяСтрока(ИмяТипаЗначения)
						И ТипЗнч(СтруктураТипаМетода.Метаданные) = Тип("ТабличноеПоле")
					Тогда
						выхТаблицаТипов = мПлатформа.ДобавитьВТаблицуТипов(выхТаблицаТипов, ВычислитьТипДочернегоЭлемента(мПлатформа.ТаблицаТиповИзЗначения(СтруктураТипаМетода.Метаданные), "ТекущаяСтрока", "Свойство"));
					КонецЕсли;
					Если ЗначениеЗаполнено(ИмяТипаЗначения) Тогда
						выхТаблицаТипов = мПлатформа.ДобавитьВТаблицуТипов(выхТаблицаТипов, ТаблицаТиповИзТекста(ИмяТипаЗначения));
					КонецЕсли;
				КонецЕсли;
				//Прервать;
			КонецЕсли; 
		КонецЦикла;
	КонецЕсли;
	Возврат ИмяПараметра;
КонецФункции

// до 5мс в больших методах и модулях
Функция КопияКомпоненты() Экспорт 
	
	КопияКопоненты = ирОбщий.НовыйАнализаторКодаЛкс();  
	ЗаполнитьЗначенияСвойств(КопияКопоненты, ЭтотОбъект);
	Возврат КопияКопоненты;

КонецФункции

// Функция - Вставить выбранное слово автодополнения
//
// Параметры:
//  СтрокаРезультата			 - 	 - 
//  ТаблицаТиповКонтекста		 - 	 - 
//  ПараметрЗакрытияПодсказки	 - 	 - 
// 
// Возвращаемое значение:
//  Булево - нужно ли сразу вызвать автоподсказку 
//
Функция ВставитьВыбранноеСловоАвтодополнения(СтрокаРезультата, ТаблицаТиповКонтекста = Неопределено, ПараметрЗакрытияПодсказки = Истина) Экспорт 

	#Если Сервер И Не Сервер Тогда
		ПолеТекста = Обработки.ирОболочкаПолеТекста.Создать();
	#КонецЕсли
	ВызватьАвтодополнениеСнова = Ложь;
	Вставка = ВставитьВыбранноеСловоГенератор(СтрокаРезультата,, ВызватьАвтодополнениеСнова, ПараметрЗакрытияПодсказки);
	//Если ЗначениеЗаполнено(Вставка) Тогда
		УстановитьПризнакМодифицированностиФормы();
		ВосстановитьГраницыВыделенияПослеКоманды();
		СохранитьСтатистикуВыбораПодсказки();
		ПолеТекста.ФиксированноеВыделениеДвумерное = Неопределено;
	//КонецЕсли;
	Возврат ВызватьАвтодополнениеСнова;
КонецФункции

//.
// Параметры:
//   СтрокаРезультата - ОбработкаТабличнаяЧастьСтрока.ирКлсПолеТекстаПрограммы.ТаблицаСлов - 
Функция ВставитьВыбранноеСловоГенератор(Знач СтрокаРезультата, Знач ДляАдаптера = Ложь, ВызватьАвтодополнениеСнова = Ложь, ПараметрЗакрытияПодсказки = Истина, ФорматироватьТекст = Ложь) Экспорт 
	Если ДляАдаптера Тогда
		УказательКаретки = "<!>";
	Иначе
		УказательКаретки = "";
	КонецЕсли;
	ФорматироватьТекст = Ложь;
	Результат = "";
	РодительИСлово = РодительИСловоСтрокиТаблицыСлов(СтрокаРезультата);
	Слово = РодительИСлово.Слово; 
	СтруктураТипаКонтекста = РодительИСлово.СтруктураТипаКонтекста;
	ОписаниеОжидаемогоТипа = РассчитатьОжидаемыйТипВыражения();
	НепечатноеНачало = ирОбщий.НепечатноеНачалоСтрокиЛкс(мТекущаяСтрокаНачало);
	Если Слово = СловоГенераторКодаЗаполненияСвойств() Тогда
		МассивВставки = Новый Массив;
		Если мЭтоТекстовыйЛитерал Тогда
			// Параметры запроса
			Для Каждого СтрокаТаблицы Из ТаблицаСлов.НайтиСтроки(Новый Структура("ТипСлова", "Свойство")) Цикл
				КонецСтроки = ");";
				Если МассивВставки.Количество() = 0 Тогда
					Строка = ""; 
					КонецСтроки = УказательКаретки + КонецСтроки;
				Иначе
					Строка = мТекущаяСтрокаНачало;
				КонецЕсли;
				МассивВставки.Добавить(Строка + СтрокаТаблицы.Слово + """, " + КонецСтроки);
			КонецЦикла;
		Иначе
			ПараметрыЗаполнения = мПлатформа.НовыеПараметрыЗаполненияСлов("Свойство", БазовоеРасширениеКонфигурации(),,,, Ложь,,,,,,,,,, Истина);
			СловаРодителя = мПлатформа.ТаблицаСловИзСтруктурыТипа(СтруктураТипаКонтекста, ПараметрыЗаполнения);
			Если СловаРодителя.Количество() Тогда
				НачалоВставляемыхСтрок = НепечатноеНачало+ мРодительскийКонтекст + ".";
				СловаРодителя.Сортировать("Слово");
				Для Каждого СтрокаТаблицы Из СловаРодителя Цикл
					КонецСтроки = ";";
					Если МассивВставки.Количество() = 0 Тогда
						Строка = ""; 
						КонецСтроки = УказательКаретки + КонецСтроки;
					Иначе
						Строка = НачалоВставляемыхСтрок;
					КонецЕсли;
					МассивВставки.Добавить(Строка + СтрокаТаблицы.Слово + " = " + КонецСтроки);
				КонецЦикла;
			КонецЕсли;
		КонецЕсли;
		Если МассивВставки.Количество() Тогда
			Результат = ирОбщий.СтрСоединитьЛкс(МассивВставки, Символы.ПС);
			ПозицияВставки = мПозицияВТексте - СтрДлина(мНачалоСлова);
			ПолеТекста.УстановитьГраницыВыделения(ПозицияВставки, ПозицияВставки);
			ПолеТекста.ВыделенныйТекст(Результат);
			мНачальнаяКолонка = мНачальнаяКолонка + СтрДлина(МассивВставки[0]) - 1;
			мКонечнаяКолонка = мНачальнаяКолонка;
		КонецЕсли;
	ИначеЕсли Слово = СловоГенераторКодаСопоставитьСвойства() Тогда
		Если мЭтоТекстовыйЛитерал Тогда
			НепечатноеНачало = НепечатноеНачало + "|";
		КонецЕсли;
		ОсновнойКонецСтроки = "";
		ПрефиксВставки = "";
		ЛиЛогическоеВыражение = Ложь
			Или мЯзыкПрограммы = 1
			Или Не ирОбщий.СтрНачинаетсяСЛкс(СокрЛ(мТекущаяСтрокаНачало), ОписаниеОжидаемогоТипа.ВыражениеПриемник);
		Если ЛиЛогическоеВыражение Тогда
			// Это логическое выражение
			НепечатноеНачало = НепечатноеНачало + Символы.Таб + "И ";
			//ПрефиксВставки = Лев(мТекущаяСтрокаНачало, Найти(мТекущаяСтрокаНачало, ОписаниеОжидаемогоТипа.ВыражениеПриемник) - 1);
			//ПрефиксВставки = ПрефиксВставки + "ИСТИНА" + Символы.ПС;
		Иначе
			ОсновнойКонецСтроки = ";";
		КонецЕсли;
		ИмяЛевогоОбъекта = ирОбщий.ПервыйФрагментЛкс(ОписаниеОжидаемогоТипа.ВыражениеПриемник);
		ТаблицаТиповЛевая = ВычислитьТипЗначенияВыражения(ИмяЛевогоОбъекта);
		ПараметрыЗаполнения = мПлатформа.НовыеПараметрыЗаполненияСлов("Свойство", БазовоеРасширениеКонфигурации(), мЯзыкПрограммы,,,,,,,,,,,,, Не ЛиЛогическоеВыражение);
		СловаЛевые = мПлатформа.ТаблицаСловИзСтруктурыТипа(ТаблицаТиповЛевая[0], ПараметрыЗаполнения);
		Если СловаЛевые.Количество() Тогда
			Для Каждого СтрокаСлова Из СловаЛевые Цикл
				ОбновитьТипЗначенияИзТаблицыТипов(СтрокаСлова,, Ложь, Истина);
			КонецЦикла;
			Для Каждого СтрокаСлова Из ТаблицаСлов.НайтиСтроки(Новый Структура("ТипСлова", "Свойство")) Цикл
				УточнитьТипЗначенияВСтрокеТаблицыСлов(СтрокаСлова,, Ложь, Истина);
			КонецЦикла;
			МассивВставки = Новый Массив;
			СловаЛевые.Сортировать("Слово");
			НаборыСлов = Новый Структура;
			НаборыСлов.Вставить("Основной", ТаблицаСлов.Выгрузить(Новый Структура("ТипСлова", "Свойство")));
			СтрокаПервогоСлова = СловаЛевые.Найти(ирОбщий.ПоследнийФрагментЛкс(ОписаниеОжидаемогоТипа.ВыражениеПриемник));
			СловаЛевые.Сдвинуть(СтрокаПервогоСлова, -СловаЛевые.Индекс(СтрокаПервогоСлова));
			Для Каждого СтрокаСловаЛевого Из СловаЛевые Цикл
				мСтрокаЛучшегоСлова = Неопределено;
				КлючПоиска = Новый Структура("Слово, ТипЗначенияИндекс", СтрокаСловаЛевого.Слово, СтрокаСловаЛевого.ТипЗначенияИндекс);
				Если Не ОбозначитьСловоСОжидаемымТипомВТаблицеСлов(КлючПоиска, НаборыСлов, "Основной") Тогда
					КлючПоиска = Новый Структура("ТипЗначенияИндекс", СтрокаСловаЛевого.ТипЗначенияИндекс);
					ОбозначитьСловоСОжидаемымТипомВТаблицеСлов(КлючПоиска, НаборыСлов, "Основной",,, СтрокаСловаЛевого.Слово);
				КонецЕсли;
				КонецСтроки = ОсновнойКонецСтроки;
				Если МассивВставки.Количество() = 0 Тогда
					Строка = "";
					КонецСтроки = УказательКаретки + КонецСтроки;
				Иначе
					Строка = НепечатноеНачало + ИмяЛевогоОбъекта + "." + СтрокаСловаЛевого.Слово + " = " + мРодительскийКонтекст + ".";
				КонецЕсли;
				ПодобранноеСлово = "";
				Если мСтрокаЛучшегоСлова <> Неопределено Тогда
					ПодобранноеСлово = мСтрокаЛучшегоСлова.Слово;
				КонецЕсли;
				МассивВставки.Добавить(Строка + ПодобранноеСлово + КонецСтроки);
			КонецЦикла;
			Если МассивВставки.Количество() > 0 Тогда
				Результат = ирОбщий.СтрСоединитьЛкс(МассивВставки, Символы.ПС);
				ПозицияВставки = мПозицияВТексте - СтрДлина(мНачалоСлова);
				ПолеТекста.УстановитьГраницыВыделения(ПозицияВставки, ПозицияВставки);
				ПолеТекста.ВыделенныйТекст(Результат);
				мНачальнаяКолонка = мНачальнаяКолонка + СтрДлина(МассивВставки[0]) - СтрДлина(КонецСтроки);
				//ПолеТекста.ЗаменитьСтроку(мНачальнаяСтрока, ПрефиксВставки + ирОбщий.СтрСоединитьЛкс(МассивВставки, Символы.ПС));
				//мНачальнаяКолонка = СтрДлина(МассивВставки[0]);
				мКонечнаяКолонка = мНачальнаяКолонка;
			КонецЕсли;
		КонецЕсли;
	ИначеЕсли Слово = СловоГенераторКодаОбходРезультатаЗапроса() Тогда
		Построитель = СтруктураТипаКонтекста.Метаданные; // ПостроительЗапроса
		ВыборкиИтогов = Построитель.Измерения;
		// Мультиметка250112_105531
		Результат = "<ВложеннаяВыборка>";
		ПредИмяВыборки = ОписаниеОжидаемогоТипа.ВыражениеПриемник;
		Для ИндексУровня = 0 По ВыборкиИтогов.Количество() Цикл
			Если ИндексУровня = ВыборкиИтогов.Количество() Тогда
				ВыражениеГруппировки = "";
				ИмяВыборки = "ВыборкаДетальные";
			Иначе
				УровеньИтогов = ВыборкиИтогов[ИндексУровня];
				ИмяКолонки = ТРег(УровеньИтогов.Имя);
				ИмяВыборки = "Выборка" + ИмяКолонки;
				ВыражениеГруппировки = """" + ИмяКолонки + """";
			КонецЕсли; 
			Если ИндексУровня = 0 Тогда
				ИмяВыборки = ПредИмяВыборки;
				СозданиеПеременной = "";
			Иначе
				СозданиеПеременной = ИмяВыборки + " = " + ПредИмяВыборки + ".";
			КонецЕсли; 
			Смещение = НепечатноеНачало + ирОбщий.СтрокаПовторомЛкс(Символы.Таб, ИндексУровня);
			ТекстУровняВложенный = СозданиеПеременной + "Выбрать(ОбходРезультатаЗапроса.ПоГруппировкам, " + ВыражениеГруппировки + ");
			|" + Смещение + "Пока " + ИмяВыборки + ".Следующий() Цикл
			|" + Смещение + "	<ВложеннаяВыборка>
			|" + Смещение + "КонецЦикла;";
			Результат = ирОбщий.СтрЗаменитьЛкс(Результат, "<ВложеннаяВыборка>", ТекстУровняВложенный);
			ПредИмяВыборки = ИмяВыборки;
		КонецЦикла;
		Результат = ирОбщий.СтрЗаменитьЛкс(Результат, "<ВложеннаяВыборка>", "<!>");
		ПозицияВставки = мПозицияВТексте - СтрДлина(мНачалоСлова);
		ПолеТекста.УстановитьГраницыВыделения(ПозицияВставки, ПозицияВставки);
		ПолеТекста.ВыделенныйТекст(ирОбщий.СтрЗаменитьЛкс(Результат, "<!>", ""));
		мНачальнаяКолонка = мНачальнаяКолонка + СтрДлина(СтрПолучитьСтроку(Результат, 1)) - 1;
		мКонечнаяКолонка = мНачальнаяКолонка;
	ИначеЕсли Слово = СловоГенераторКодаУдалитьВыбранныеЭлементы() Тогда
		АнализаторЛокальный = КопияКомпоненты();
		АнализаторЛокальный.УстановитьТекущуюПозициюВКонецТекста();
		АнализаторЛокальный.КончитьОбработкуКоманды();
		АнализаторЛокальный.ЗаполнитьТаблицуСлов(, Ложь,, Ложь, Ложь);
		Если ТаблицаСлов.НайтиСтроки(Новый Структура("Слово, ТипСлова", "Найти", "Метод")).Количество() Тогда // - "Индекс" не подходит для массива
			Результат = 
			"Для <Индекс> = 1 - <Коллекция>.Количество() По 0 Цикл // Обратный обход
			|	<Элемент> = <Коллекция>[-<Индекс>];
			|	Если <?> Тогда
			|		<Коллекция>.Удалить(-<Индекс>);
			|	КонецЕсли;
			|КонецЦикла;";
			Результат = ирОбщий.СтрЗаменитьЛкс(Результат, "<Индекс>", ирОбщий.АвтоУникальноеИмяВКоллекцииЛкс(АнализаторЛокальный.ТаблицаСлов, "Индекс", "Слово"));
		Иначе
			Результат = 
			"МассивДляУдаления = Новый Массив; 
			|Для Каждого <Элемент> Из <Коллекция> Цикл
			|	Если <?> Тогда
			|		МассивДляУдаления.Удалить(<Элемент>);
			|	КонецЕсли;
			|КонецЦикла;
			|Для Каждого <Элемент> Из МассивДляУдаления Цикл
			|	<Коллекция>.Удалить(<Элемент>);
			|КонецЦикла;";
		КонецЕсли;
		Результат = ирОбщий.СтрЗаменитьЛкс(Результат, "<Коллекция>", мРодительскийКонтекст);
		Результат = ирОбщий.СтрЗаменитьЛкс(Результат, "<Элемент>", ирОбщий.АвтоУникальноеИмяВКоллекцииЛкс(АнализаторЛокальный.ТаблицаСлов, "Элемент", "Слово"));
		ВставитьУказанныйШаблон(Результат, мНачалоКонтекста); 
		Результат = СтрЗаменить(Результат, "<?>", "<!>");
		ФорматироватьТекст = Истина;
	ИначеЕсли Слово = СловоГенераторКодаОбойтиЭлементы() Тогда
		Результат = 
		"Для Каждого <?> Из <Коллекция> Цикл
		|	
		|КонецЦикла;";
		Результат = ирОбщий.СтрЗаменитьЛкс(Результат, "<Коллекция>", мРодительскийКонтекст);
		ВставитьУказанныйШаблон(Результат, мНачалоКонтекста); 
		ВызватьАвтодополнениеСнова = Истина;
		ФорматироватьТекст = Истина;
	ИначеЕсли Ложь
		Или Слово = "Истина И"
		Или Слово = "Ложь Или"
	Тогда
		Если ирОбщий.СтрНачинаетсяСЛкс(Слово, мНачалоСлова + мКонецКонтекста) = 1 Тогда
			НеобрабатываемыйКонецСтроки = Сред(мТекущаяСтрокаКонец, СтрДлина(мКонецКонтекста) + 1);
		Иначе
			НеобрабатываемыйКонецСтроки = мТекущаяСтрокаКонец;
		КонецЕсли;
		Результат = СтрЗаменить(Слово, " ", Символы.ПС + НепечатноеНачало + Символы.Таб) + " ";
		ВтораяСтрокаВставки = СтрПолучитьСтроку(Результат, 2);
		Если Ложь
			Или ирОбщий.СтрНачинаетсяСЛкс(СокрЛ(НеобрабатываемыйКонецСтроки), "Тогда") 
			Или ирОбщий.СтрНачинаетсяСЛкс(СокрЛ(НеобрабатываемыйКонецСтроки), "Цикл") 
		Тогда
			НеобрабатываемыйКонецСтроки = Символы.ПС + НепечатноеНачало + СокрЛ(НеобрабатываемыйКонецСтроки);
		КонецЕсли;
		ЗаменаТекущейСтроки = Лев(мТекущаяСтрокаНачало, мКонечнаяКолонка - 1 - СтрДлина(мНачалоКонтекста)) + Результат + НеобрабатываемыйКонецСтроки;
		Если ПолеТекста.КоличествоСтрок() < мКонечнаяСтрока Тогда
			ПолеТекста.ДобавитьСтроку(ЗаменаТекущейСтроки);
		Иначе
			ПолеТекста.ЗаменитьСтроку(мКонечнаяСтрока, ЗаменаТекущейСтроки); // Баг платформы. Вызывает выделение всего предшествующего текста на 8.3.18
		КонецЕсли; 
		мКонечнаяКолонка = СтрДлина(ВтораяСтрокаВставки) + 1;
		мНачальнаяКолонка = мКонечнаяКолонка;
		мКонечнаяСтрока = мКонечнаяСтрока + 1;
		мНачальнаяСтрока = мКонечнаяСтрока;
	ИначеЕсли Слово = "Если Тогда" Тогда
		ВставитьУказанныйШаблон(
		"Если <?> Тогда
		|	
		|КонецЕсли;", мНачалоКонтекста);
	ИначеЕсли Слово = "Пока Цикл" Тогда
		ВставитьУказанныйШаблон(
		"Пока <?> Цикл
		|	
		|КонецЦикла;", мНачалоКонтекста);
	ИначеЕсли Слово = "Для Каждого" Тогда
		ВставитьУказанныйШаблон(
		"Для Каждого  Из <?> Цикл
		|	
		|КонецЦикла;", мНачалоКонтекста);
	ИначеЕсли Слово = "Попытка Исключение" Тогда
		ВставитьУказанныйШаблон(
		"Попытка 
		|	<?>
		|Исключение
		|КонецПопытки;", мНачалоКонтекста);
	ИначеЕсли Слово = "Функция КонецФункции" Тогда
		ВставитьУказанныйШаблон(
		"Функция <?>() Экспорт
		|	Возврат ;
		|КонецФункции", мНачалоКонтекста);
	ИначеЕсли Слово = "Процедура КонецПроцедуры" Тогда
		ВставитьУказанныйШаблон(
		"Процедура <?>() Экспорт
		|	
		|КонецПроцедуры", мНачалоКонтекста);
	ИначеЕсли Слово = "Для По" Тогда
		Результат = 
		"Для Счетчик = 1 По <?> Цикл
		|	
		|КонецЦикла;";
		Результат = ирОбщий.СтрЗаменитьЛкс(Результат, "Счетчик", ирОбщий.АвтоУникальноеИмяВКоллекцииЛкс(ТаблицаСлов, "Счетчик", "Слово"));
		ВставитьУказанныйШаблон(Результат, мНачалоКонтекста); 
		Результат = СтрЗаменить(Результат, "<?>", "<!>");
		ФорматироватьТекст = Истина;
	ИначеЕсли Слово = "НачатьТранзакцию Попытка" Тогда
		Результат = 
		"НачатьТранзакцию();
		|Попытка
		|	<?>
		|	ЗафиксироватьТранзакцию();
		|Исключение
		|	ОтменитьТранзакцию();
		|	Если ТранзакцияАктивна() Тогда
		|		ВызватьИсключение;
		|	КонецЕсли; 
		|КонецПопытки;";
		ВставитьУказанныйШаблон(Результат, мНачалоКонтекста); 
		Результат = СтрЗаменить(Результат, "<?>", "<!>");  
		ФорматироватьТекст = Истина;
	ИначеЕсли Слово = "ВЫБОР КОГДА" Тогда
		Результат = 
		"ВЫБОР 
		|	КОГДА <?> 
		|		ТОГДА 
		|	ИНАЧЕ 
		|КОНЕЦ";
		ВставитьУказанныйШаблон(Результат, мНачалоКонтекста); 
		Результат = СтрЗаменить(Результат, "<?>", "<!>");  
		ФорматироватьТекст = Истина;
	Иначе
		СтрокаНачала = "";           
		СтрокаОкончания = "";
		СмещениеКурсораВОкончании = 0;
		РодительИСлово = РодительИСловоСтрокиТаблицыСлов(СтрокаРезультата);
		Слово = РодительИСлово.Слово;
		СтруктураТипаКонтекста = РодительИСлово.СтруктураТипаКонтекста;
		Если ирОбщий.СтрНачинаетсяСЛкс(Слово, мНачалоСлова + мКонецКонтекста) = 1 Тогда
			НеобрабатываемыйКонецСтроки = Сред(мТекущаяСтрокаКонец, СтрДлина(мКонецКонтекста) + 1);
		Иначе
			НеобрабатываемыйКонецСтроки = мТекущаяСтрокаКонец;
			мРегВыражение.Pattern = "[" + шБуква + "\d]";
			Если мРегВыражение.Проверить(Лев(НеобрабатываемыйКонецСтроки, 1)) Тогда
				СтрокаОкончания = " "; 
			КонецЕсли;
		КонецЕсли;
		Если Истина
			И Не мЭтоТекстовыйЛитерал 
			И Не ЛиВнутриКомментария()
			И СтрокаРезультата.ТипСлова = "Метод" 
		Тогда
			Если Лев(мКонецКонтекста, 1) = "(" Тогда 
				НеобрабатываемыйКонецСтроки = Сред(НеобрабатываемыйКонецСтроки, 2);
			КонецЕсли;
			СтрокаОкончания = "()" + СтрокаОкончания;
			Если Истина
				И ПараметрЗакрытияПодсказки = Истина 
				И Прав(мТекущееСлово, 1) = "(" 
			Тогда 
				СтрокаОкончания = "(";
			Иначе
				Если Истина
					И ЯзыкПрограммы = 0 
					И Лев(НеобрабатываемыйКонецСтроки, 1) <> ";"
					И СтрокаРезультата.ТипЗначения = ""
					И СтрокаРезультата.Определение <> "Статистический"
				Тогда
					СтрокаОкончания = "();"
				КонецЕсли;
			КонецЕсли;
			СмещениеКурсораВОкончании = СтрДлина(СтрокаОкончания);
			Если ПараметрЗакрытияПодсказки = Истина Тогда
				ПараметрыЗаполнения = мПлатформа.НовыеПараметрыЗаполненияСлов("Метод", БазовоеРасширениеКонфигурации(), мЯзыкПрограммы,,,,, мФлагиКомпиляции, Слово, МодульМетаданныхКонтекста(СтруктураТипаКонтекста),,,
					мЭтоЛокальныйКонтекстТаблицыСлов);
				ТаблицаМетодовМодуля = мПлатформа.ТаблицаСловИзСтруктурыТипа(СтруктураТипаКонтекста, ПараметрыЗаполнения);
				Если ТаблицаМетодовМодуля.Количество() Тогда
					СтруктураТипаМетода = ТаблицаМетодовМодуля[0].ТаблицаТипов[0];
					СтрокаОписания = СтруктураТипаМетода.СтрокаОписания;
					Если Не ЛиСистемноеСлово(СтруктураТипаМетода) Тогда
						Если Ложь
							Или (Истина
								И ТипЗнч(СтрокаОписания) = Тип("COMОбъект") 
								И СтрокаОписания.Parameters.Count > 0)
							Или (Истина
								И ТипЗнч(СтрокаОписания) = Тип("СтрокаТаблицыЗначений")
								И СтрокаОписания.Параметры <> Неопределено)
						Тогда
							СмещениеКурсораВОкончании = 1;
						КонецЕсли; 
					Иначе
						НайденныеСтроки = мПлатформа.ПараметрыМетодаПлатформы(СтрокаОписания);
						Если НайденныеСтроки.Количество() > 0 Тогда 
							СмещениеКурсораВОкончании = 1;
						КонецЕсли;
					КонецЕсли;
				КонецЕсли;
			КонецЕсли;
			Если ДляАдаптера Тогда
				Если Лев(мТекущаяСтрокаКонец, 1) = "(" тогда
					СтрокаОкончания = "";
				ИначеЕсли СмещениеКурсораВОкончании = 1 Тогда
					СтрокаОкончания = СтрЗаменить(СтрокаОкончания, "()", "(" + УказательКаретки + ")");
				Иначе
					СтрокаОкончания = СтрЗаменить(СтрокаОкончания, "()", "()" + УказательКаретки);
				КонецЕсли;
			КонецЕсли;
		ИначеЕсли Истина
			И ПараметрЗакрытияПодсказки = "."
			И ЯзыкПрограммы <> 0
			И СтрокаРезультата.ТипСлова = "Свойство"
			И Найти(Слово, мПараметрыДиалектаSQL.ПрефиксПараметра) = 1
		Тогда 
			СтрокаНачала = "(";
			СтрокаОкончания = ")" + СтрокаОкончания;
			СмещениеКурсораВОкончании = 1;
		ИначеЕсли ирОбщий.СтрКончаетсяНаЛкс(Слово, " =") Тогда 
			ДлинаОбрезки = 0;
			ПервыйСимвол = Лев(НеобрабатываемыйКонецСтроки, 1);
			Если ПустаяСтрока(ПервыйСимвол) Тогда
				ДлинаОбрезки = ДлинаОбрезки + 1;
				НеобрабатываемыйКонецСтроки = СокрЛ(НеобрабатываемыйКонецСтроки);
			КонецЕсли;
			Если Лев(НеобрабатываемыйКонецСтроки, 1) = "=" Тогда
				ДлинаОбрезки = ДлинаОбрезки + 1;
			Иначе
				ДлинаОбрезки = 0;
			КонецЕсли;
			Слово = ирОбщий.СтрокаБезКонцаЛкс(Слово, ДлинаОбрезки);
		КонецЕсли;
		ОбновитьСтатистикуВыбораВСтрокеСлова(СтрокаРезультата);
		СтрокаДобавка = СтрокаНачала + Слово + СтрокаОкончания;
		Если мРодительскийКонтекст <> "" Тогда
			Если РодительИСлово.ВнутриГруппыОбщихМодулей Тогда
				мРодительскийКонтекст = СтруктураТипаКонтекста.Метаданные.Имя;
			КонецЕсли;
			Если Не ДляАдаптера Или РодительИСлово.ВнутриГруппыОбщихМодулей Тогда
				СтрокаДобавка = мРодительскийКонтекст + "." + СтрокаДобавка;
			КонецЕсли;
		КонецЕсли;
		мРодительскийКонтекст = СтрокаДобавка;
		Если ПараметрЗакрытияПодсказки <> Истина Тогда
			СтрокаДобавка = СтрокаДобавка + ПараметрЗакрытияПодсказки;
			мТекущееСлово = Слово;
			Если ПараметрЗакрытияПодсказки = "." Тогда
				Если СтрокаРезультата.Определение = "Статистический" Тогда 
					ТаблицаТиповКонтекста = ВычислитьТипЗначенияВыражения(мРодительскийКонтекст, " " + мТекстДляПоискаОпределения, мПредшествующийТекст, Истина);
				Иначе
					ТаблицаТиповКонтекста = ВычислитьТипДочернегоЭлемента(мПлатформа.ДобавитьВТаблицуТипов(, СтруктураТипаКонтекста), мТекущееСлово, СтрокаРезультата.ТипСлова);
				КонецЕсли;
				ВызватьАвтодополнениеСнова = ТаблицаТиповКонтекста.Количество() > 0;
			КонецЕсли;
		КонецЕсли; 
		Если Не ДляАдаптера И ирОбщий.СтрКончаетсяНаЛкс(мТекущаяСтрокаНачало, " =") Тогда
			СтрокаДобавка = " " + СтрокаДобавка;
		КонецЕсли;
		Если Истина
			И Слово = "Перейти"
			И СтрокаРезультата.ТипСлова = "Конструкция"
		Тогда
			СтрокаДобавка = СтрокаДобавка + " ~" + УказательКаретки;
			ВызватьАвтодополнениеСнова = Истина;
		ИначеЕсли Истина
			И СтрокаРезультата.ТипСлова = "Конструкция"
			И (Ложь
				Или Слово = "КонецЕсли"
				Или Слово = "КонецЦикла"
				Или Слово = "КонецПопытки")
		Тогда
			СтрокаДобавка = СтрокаДобавка + ";";
		ИначеЕсли Истина
			И Слово = "Тип"
			И СтрокаРезультата.ТипСлова = "Метод"
			И ирОбщий.СтрНачинаетсяСЛкс(СтрокаОкончания, "(" + УказательКаретки + ")")
		Тогда
			СтрокаДобавка = СтрЗаменить(СтрокаДобавка, "(" + УказательКаретки + ")", "(""" + УказательКаретки + """)");
			СмещениеКурсораВОкончании = СмещениеКурсораВОкончании - 1;
			ВызватьАвтодополнениеСнова = Истина;
		ИначеЕсли Истина
			И Слово = "ДАТАВРЕМЯ"
			И СтрокаРезультата.ТипСлова = "Метод"
			И мЯзыкПрограммы = 1
		Тогда
			СтрокаДобавка = СтрЗаменить(СтрокаДобавка, "(" + УказательКаретки + ")", "(1,1,1)");
		ИначеЕсли Истина
			И Слово = "НСтр"
			И СтрокаРезультата.ТипСлова = "Метод"
			И мЯзыкПрограммы = 0
		Тогда
			СтрокаДобавка = СтрЗаменить(СтрокаДобавка, "(" + УказательКаретки + ")", "(""ru='" + УказательКаретки + "'"")");
			СмещениеКурсораВОкончании = СмещениеКурсораВОкончании - 2;
		ИначеЕсли Истина
			И Слово = "Новый"
			И СтрокаРезультата.ТипСлова = "Конструкция"
		Тогда
			СтрокаДобавка = СтрокаДобавка + " " + УказательКаретки;
			ВызватьАвтодополнениеСнова = Истина;
		ИначеЕсли Истина
			И Слово = "ПодключитьОбработчикОжидания"
			И СтрокаРезультата.ТипСлова = "Метод"
		Тогда
			ДобавкаПараметров = """, 0.1, Истина";
			СтрокаДобавка = СтрЗаменить(СтрокаДобавка, "(" + УказательКаретки + ")", "(""" + УказательКаретки + ДобавкаПараметров + ")");
			СмещениеКурсораВОкончании = СмещениеКурсораВОкончании - СтрДлина(ДобавкаПараметров);
			ВызватьАвтодополнениеСнова = Истина;
		КонецЕсли;
		мТекущаяСтрокаНачало = Лев(мТекущаяСтрокаНачало, мКонечнаяКолонка - 1 - СтрДлина(мНачалоКонтекста)) + СтрокаДобавка;
		ТекущаяСтрока = мТекущаяСтрокаНачало + НеобрабатываемыйКонецСтроки;
		Если мОригинальныйТекст = "" Тогда
			ВыделенныйТекст("" + ТекущаяСтрока);
		Иначе
			Если ПолеТекста.КоличествоСтрок() < мКонечнаяСтрока Тогда
				ПолеТекста.ДобавитьСтроку(ТекущаяСтрока);
			Иначе
				ПолеТекста.ЗаменитьСтроку(мКонечнаяСтрока, ТекущаяСтрока); // Баг платформы. Вызывает выделение всего предшествующего текста на 8.3.18
			КонецЕсли; 
		КонецЕсли;
		Если ВызватьАвтодополнениеСнова Тогда
			СтрокаДобавка = СтрЗаменить(СтрокаДобавка, УказательКаретки, "<?>");
		КонецЕсли;
		Результат = СтрокаДобавка;
		мКонечнаяКолонка = мКонечнаяКолонка + СтрДлина(СтрокаДобавка) - СтрДлина(мНачалоКонтекста) - СтрДлина(СтрокаОкончания) + СмещениеКурсораВОкончании;
		мНачальнаяКолонка = мКонечнаяКолонка;
		мНачалоКонтекста = мРодительскийКонтекст + ".";
		мНачалоСлова = "";  
	КонецЕсли;
	мОткрытьСправкуПоПараметру = АвтоматическаяПодсказкаПоВызовуМетода() И СмещениеКурсораВОкончании = 1;
	Возврат Результат;
КонецФункции

//.
// Параметры:
//   СтрокаСлова - СтрокаТаблицыЗначений, ОбработкаТабличнаяЧастьСтрока.ирКлсПолеТекстаПрограммы.ТаблицаСлов - 
Процедура ОбновитьСтатистикуВыбораВСтрокеСлова(Знач СтрокаСлова)
	Если Ложь
		Или СтрокаСлова.Определение = "Локальный"
		Или СтрокаСлова.Определение = "Статистический"
		//Или СтрокаСлова.ТипСлова = "Конструкция"
		//Или ЛиБесполезноеПрисвоениеПеременной(СтрокаСлова.Слово)
		//Или ирОбщий.ЛиБулевыйЛитералЛкс(СтрокаСлова.Слово)
	Тогда
		Возврат;
	КонецЕсли;
	ТипВладелец = Неопределено; // см. мПлатформа.НоваяСтруктураТипа
	Если Истина
		И СтрокаСлова.Определение = "Предопределенный"
		И (Ложь
			Или СтрокаСлова.ТипСлова = "Конструкция"
			Или ЛиБесполезноеПрисвоениеПеременной(СтрокаСлова.Слово)
			Или ирОбщий.ЛиБулевыйЛитералЛкс(СтрокаСлова.Слово))
	Тогда
		ТипВладелец = НоваяСтруктураТипа("Глобальный");
	Иначе
		УточнитьТипЗначенияВСтрокеТаблицыСлов(СтрокаСлова, Истина,, ТипВладелец);
	КонецЕсли;
	ТипКонтекстаСтатистики = ТипКонтекстаСтатистики(ТипВладелец);
	Если ТипКонтекстаСтатистики <> Неопределено Тогда
		КлючПоиска = Новый Структура("ЯзыкПрограммы, ТипКонтекста, Слово, ЭтоМетод", ЯзыкПрограммы, ТипКонтекстаСтатистики, СтрокаСлова.Слово, СтрокаСлова.ТипСлова = "Метод");
		ТаблицаСтатистикиВыбора = мПлатформа.ТаблицаСтатистикиВыбора;
		НайденныеСтроки = ТаблицаСтатистикиВыбора.НайтиСтроки(КлючПоиска);
		Если НайденныеСтроки.Количество() > 0 Тогда
			СтрокаСтатистикиВыбора = НайденныеСтроки[0];
		Иначе
			СтрокаСтатистикиВыбора = ТаблицаСтатистикиВыбора.Добавить();
			ЗаполнитьЗначенияСвойств(СтрокаСтатистикиВыбора, КлючПоиска);
		КонецЕсли;
		СтрокаСтатистикиВыбора.Рейтинг = СтрокаСтатистикиВыбора.Рейтинг + 1;
	КонецЕсли;
КонецПроцедуры 

Функция ТипКонтекстаСтатистики(Знач СтруктураТипаКонтекста = Неопределено) Экспорт
	Если СтруктураТипаКонтекста = Неопределено Тогда
		СтруктураТипаКонтекста = мСтруктураТипаКонтекста; 
	КонецЕсли;
	ТипКонтекстаСтатистики = Неопределено;
	КонкретныйТипКонтекста = мПлатформа.ИмяТипаИзСтруктурыТипа(СтруктураТипаКонтекста);
	Если СтруктураТипаКонтекста.ИмяОбщегоТипа = "Локальный" Тогда
		ТипКонтекстаСтатистики = "Глобальный";
	ИначеЕсли Ложь
		Или СтруктураТипаКонтекста.ТипЯзыка = "ИмяТипа"
		Или СтруктураТипаКонтекста.ТипЯзыка = "ЗначениеВЗапросе"
		Или СтруктураТипаКонтекста.ТипЯзыка = "ИмяПредопределенногоЗначения"
	Тогда
		ТипКонтекстаСтатистики = мРодительскийКонтекст;
		Если Не ЗначениеЗаполнено(ТипКонтекстаСтатистики) Тогда
			ТипКонтекстаСтатистики = "<" + СтруктураТипаКонтекста.ТипЯзыка + ">";
		КонецЕсли; 
	ИначеЕсли Истина
		И Не мЭтоТекстовыйЛитерал
		//И мЯзыкПрограммы = 0 // Отключил, т.к. выше исключаются все неподходящие случаи через ТипЯзыка 
		И (Ложь
			Или Найти(КонкретныйТипКонтекста, ".") > 0
			Или Найти(КонкретныйТипКонтекста, "[") > 0)
	Тогда
		//ТипКонтекстаСтатистики = ИмяТипаКонтекста(); 
		ТипКонтекстаСтатистики = КонкретныйТипКонтекста; 
	ИначеЕсли Ложь
		Или ТаблицаСлов.Найти("Метаданные", "Определение") = Неопределено
		Или Не мЭтоТекстовыйЛитерал И СтруктураТипаКонтекста.Метаданные = Неопределено // для СправочникиМенеджер
	Тогда
		ТипКонтекстаСтатистики = ирОбщий.ПервыйФрагментЛкс(КонкретныйТипКонтекста, " ");
	КонецЕсли;
	Возврат ТипКонтекстаСтатистики;
КонецФункции 

// Вызывается из адаптера. Отладчик Visual Studio Code внутри не останавливается.
Функция Адаптер_ОбновитьСтатистикуВыбораСлова(Знач Слово, Знач ЛиМетод, Знач КлючНабораСлов) Экспорт 
	СтрокаТаблицыСлов = СтрокаСловаИзСловаИНабора(Слово, ЛиМетод, КлючНабораСлов);
	Если СтрокаТаблицыСлов <> Неопределено Тогда
		ОбновитьСтатистикуВыбораВСтрокеСлова(СтрокаТаблицыСлов);
	КонецЕсли;
КонецФункции 

// Вызывается из адаптера. Отладчик Visual Studio Code внутри не останавливается.
Функция Адаптер_ПриВыбореСтрокиАвтодополнения(Знач Слово, Знач ЛиМетод, Знач КлючНабораСлов, Знач Шаблон, ФорматироватьТекст) Экспорт 
	Если Ложь
		// Чтобы не заслонить шаблоны Турбоконфа
		Или ЛиМетод 
		Или Лев(Слово, 1) = "<"
		Или Прав(Слово, 1) = "=" 
		Или Найти(Слово, " ")
	Тогда 
		СтрокаТаблицыСлов = СтрокаСловаИзСловаИНабора(Слово, ЛиМетод, КлючНабораСлов);
		Если СтрокаТаблицыСлов <> Неопределено Тогда
			МойШаблон = ВставитьВыбранноеСловоГенератор(СтрокаТаблицыСлов, Истина,,, ФорматироватьТекст);
		КонецЕсли;
	КонецЕсли;
	Возврат МойШаблон;
КонецФункции

Функция АвтоматическаяПодсказкаПоВызовуМетода(Обновить = Ложь) Экспорт 
	Если АвтоматическаяПодсказкаПоВызовуМетода = Неопределено Или Обновить Тогда
		АвтоматическаяПодсказкаПоВызовуМетода = ирОбщий.ВосстановитьЗначениеЛкс(ИмяКласса + ".АвтоматическаяПодсказкаПоВызовуМетода") <> Ложь;
	КонецЕсли; 
	Возврат АвтоматическаяПодсказкаПоВызовуМетода;
КонецФункции

Функция АвтоматическаяПодсказкаАвтодополненияHTML(Обновить = Ложь) Экспорт
	Если АвтоматическаяПодсказкаАвтодополненияHTML = Неопределено Или Обновить Тогда
		АвтоматическаяПодсказкаАвтодополненияHTML = ирОбщий.ВосстановитьЗначениеЛкс(ИмяКласса + ".АвтоматическаяПодсказкаАвтодополненияHTML") <> Ложь;
	КонецЕсли; 
	Возврат АвтоматическаяПодсказкаАвтодополненияHTML;
КонецФункции

Функция АвтовставкаКвадратнойСкобки(Обновить = Ложь) Экспорт
	Если АвтовставкаКвадратнойСкобки = Неопределено Или Обновить Тогда
		АвтовставкаКвадратнойСкобки = ирОбщий.ВосстановитьЗначениеЛкс(ИмяКласса + ".АвтовставкаКвадратнойСкобки") = Истина;
	КонецЕсли; 
	Возврат АвтовставкаКвадратнойСкобки;
КонецФункции

Функция АвтовставкаДвойнойКавычки(Обновить = Ложь) Экспорт
	Если АвтовставкаДвойнойКавычки = Неопределено Или Обновить Тогда
		АвтовставкаДвойнойКавычки = ирОбщий.ВосстановитьЗначениеЛкс(ИмяКласса + ".АвтовставкаДвойнойКавычки") = Истина;
	КонецЕсли; 
	Возврат АвтовставкаДвойнойКавычки;
КонецФункции

Функция ГитРепозиторий() Экспорт
	ГитРепозиторий = ирОбщий.ВосстановитьЗначениеЛкс(ИмяКласса + ".ГитРепозиторий");
	Возврат ГитРепозиторий;
КонецФункции

Функция ЛиСжиматьВнутренниеПустотыВСтроке() Экспорт
	Результат = ирОбщий.ВосстановитьЗначениеЛкс(ИмяКласса + ".СжиматьВнутренниеПустотыВСтроке") = Истина;
	Возврат Результат;
КонецФункции

Функция ЛиСжиматьПустыеСтроки() Экспорт
	Результат = ирОбщий.ВосстановитьЗначениеЛкс(ИмяКласса + ".СжиматьПустыеСтроки") = Истина;
	Возврат Результат;
КонецФункции

Функция ПоказыватьВсеТипыВСпискеАвтодополненияHTML(Обновить = Ложь) Экспорт 
	Если ПоказыватьВсеТипыВСпискеАвтодополненияHTML = Неопределено Или Обновить Тогда
		ПоказыватьВсеТипыВСпискеАвтодополненияHTML = ирОбщий.ВосстановитьЗначениеЛкс(ИмяКласса + ".ПоказыватьВсеТипыВСпискеАвтодополненияHTML") = Истина;
	КонецЕсли;
	Возврат ПоказыватьВсеТипыВСпискеАвтодополненияHTML;
КонецФункции

// надо вызывать после Форма_ПриОткрытииЛкс
Функция ПредпочитатьHTMLРедакторКода(Обновить = Ложь) Экспорт 
	Если Не ирКэш.ДоступноРедакторМонакоЛкс() Тогда
		Возврат Ложь;
	КонецЕсли;
	// Пробовал https://www.hostedredmine.com/issues/984945, но слишком нестабильно 
	//Если Истина
	//	И ирОбщий.ЛиЕстьМодальныеГруппыЛкс()
	//	И (Ложь
	//		Или АвтоматическаяПодсказкаАвтодополненияHTML() 
	//		Или АвтоматическаяПодсказкаПоВызовуМетода())
	//Тогда
	//	Возврат Истина;
	//КонецЕсли;
	Если ПредпочитатьHTMLРедакторКода = Неопределено Или Обновить Тогда
		ПредпочитатьHTMLРедакторКода = ирОбщий.ВосстановитьЗначениеЛкс(ИмяКласса + ".ПредпочитатьHTMLРедакторКода") = Истина;
	КонецЕсли;
	Возврат ПредпочитатьHTMLРедакторКода;
КонецФункции

Процедура ДобавитьCOMКлассыВСписокСлов(Знач Соответствие, Знач Компоненты)
	
	Для Каждого Класс Из Компоненты Цикл
		Если Не ЗначениеЗаполнено(Класс.Name) Тогда
			Продолжить;
		КонецЕсли;
		Соответствие[Класс.Name] = 1;
	КонецЦикла;

КонецПроцедуры

// Пока не используется
Процедура ЗагрузитьВТаблицуСловИзВнутреннейТаблицыСлов(Знач ВнутренняяТаблицаСлов, Знач ВыгрузкаТаблицыСлов)
	
	Для Каждого ВнутренняяСтрокаСлова Из ВнутренняяТаблицаСлов Цикл
		НоваяСтрока = ВыгрузкаТаблицыСлов.Добавить();
		ЗаполнитьЗначенияСвойств(НоваяСтрока, ВнутренняяСтрокаСлова);
		ТаблицаТипов = ВнутренняяСтрокаСлова.ТаблицаТипов;
		Если ТаблицаТипов <> Неопределено Тогда
			ОбновитьТипЗначенияИзТаблицыТипов(НоваяСтрока);
		КонецЕсли; 
	КонецЦикла;

КонецПроцедуры
                             
Функция УточнитьТипЗначенияВСтрокеТаблицыСлов(Знач ТекущаяСтрока, Знач ВернутьСтруктуруТипа = Ложь, Знач НужноУточнитьТип = Ложь, выхТипВладелецДляСтатистикиВыбора = Неопределено) Экспорт 
	#Если Сервер И Не Сервер Тогда
		ТекущаяСтрока = ТаблицаСлов.Добавить();
	#КонецЕсли
	ТаблицаТипов = Неопределено;
	НужноУточнитьТип = Ложь
		Или НужноУточнитьТип
		Или Лев(ТекущаяСтрока.ТипЗначения, 2) = "??" 
		Или Найти(ТекущаяСтрока.ТипЗначения, "<") > 0;
	Если НужноУточнитьТип Или ВернутьСтруктуруТипа Тогда
		#Если Сервер И Не Сервер Тогда
			мПлатформа = Обработки.ирПлатформа.Создать();
		#КонецЕсли
		выхТипВладелецДляСтатистикиВыбора = мСтруктураТипаКонтекста;
		Если мТаблицаСловЛитерала <> Неопределено Тогда
			КлючПоиска = Новый Структура("Слово, ТипСлова");
			ЗаполнитьЗначенияСвойств(КлючПоиска, ТекущаяСтрока);
			Найденные = мТаблицаСловЛитерала.НайтиСтроки(КлючПоиска);
			Если Найденные.Количество() > 0 Тогда
				ТаблицаТипов = Найденные[0].ТаблицаТипов;
				Если ТекущаяСтрока.ТипСлова = "Метод" И Не ЛиСистемноеСлово(ТаблицаТипов[0]) Тогда
					СтрокаМетода = ТаблицаТипов[0].СтрокаОписания;
					ТаблицаТипов = мПлатформа.ПодготовитьТипРезультатаМетода(СтрокаМетода, СтрокаМетода.ИмяМодуля);
				КонецЕсли;
			КонецЕсли;
		ИначеЕсли Ложь
			Или ТекущаяСтрока.Определение = "Статистический" 
			Или ТекущаяСтрока.Определение = "Локальный"
		Тогда
			ТаблицаТипов = ВычислитьТипЗначенияВыражения(ТекущаяСтрока.Слово, мТекстДляПоискаОпределения,,,,,,,,,, мПозицияВБлоке - СтрДлина(мНачалоКонтекста));
		Иначе 
			РодительИСлово = РодительИСловоСтрокиТаблицыСлов(ТекущаяСтрока);
			Если ЗначениеЗаполнено(РодительИСлово.Родитель) Тогда
				ТипыКонтекста = ирОбщий.ЗначенияВМассивЛкс(РодительИСлово.СтруктураТипаКонтекста);
			Иначе
				ТипыКонтекста = мТаблицаТиповКонтекста;
			КонецЕсли;
			ПараметрыЗаполнения = мПлатформа.НовыеПараметрыЗаполненияСлов(ТекущаяСтрока.ТипСлова, БазовоеРасширениеКонфигурации(), мЯзыкПрограммы, Конфигурация,,,, мФлагиКомпиляции, РодительИСлово.Слово,,
				НужноУточнитьТип,, мЭтоЛокальныйКонтекстТаблицыСлов);
			Для Каждого СтрокаТипаКонтекста Из ТипыКонтекста Цикл
				//ОписанияСлов = мПлатформа.ТаблицаСловИзСтруктурыТипа(СтрокаТипаКонтекста, мЯзыкПрограммы, Конфигурация,,,, ТекущаяСтрока.ТипСлова, мФлагиКомпиляции, РодительИСлово.Слово,
				//	МодульМетаданныхКонтекста(СтрокаТипаКонтекста), НужноУточнитьТип,, мЭтоЛокальныйКонтекстТаблицыСлов,, БазовоеРасширениеКонфигурации());
				ПараметрыЗаполнения.МодульМетаданных = МодульМетаданныхКонтекста(СтрокаТипаКонтекста);
				ОписанияСлов = мПлатформа.ТаблицаСловИзСтруктурыТипа(СтрокаТипаКонтекста, ПараметрыЗаполнения);
				Если ОписанияСлов.Количество() > 0 Тогда
					ТаблицаТипов = ОписанияСлов[0].ТаблицаТипов; 
					выхТипВладелецДляСтатистикиВыбора = СтрокаТипаКонтекста;
					Прервать;
				КонецЕсли; 
			КонецЦикла;
		КонецЕсли; 
		Если ЗначениеЗаполнено(ТаблицаТипов) Тогда
			СтрокаОписания = ТаблицаТипов[0].СтрокаОписания;
			Если ТипЗнч(СтрокаОписания) = Тип("СтрокаТаблицыЗначений") Тогда
				КолонкиТаблицы = СтрокаОписания.Владелец().Колонки;
				Если Истина
					И мЭтоЛокальныйКонтекстТаблицыСлов
					И КолонкиТаблицы.Найти("ТипКонтекста") <> Неопределено
					И СтрокаОписания.ТипКонтекста = "Глобальный"
				Тогда
					выхТипВладелецДляСтатистикиВыбора = НоваяСтруктураТипа("Глобальный");
				ИначеЕсли Истина
					И ирОбщий.ЛиИмяТипаФормыЛкс(выхТипВладелецДляСтатистикиВыбора.ИмяОбщегоТипа, Истина, Ложь)
					И КолонкиТаблицы.Найти("ИмяМодуля") <> Неопределено
					И Найти(СтрокаОписания.ИмяМодуля, "МодульОбъекта")
				Тогда  
					выхТипВладелецДляСтатистикиВыбора = мПлатформа.МодульМетаданныхИзКэша(СтрокаОписания.ИмяМодуля).СтруктураТипа;
				КонецЕсли;
			КонецЕсли;
		КонецЕсли; 
		Если НужноУточнитьТип Тогда
			ОбновитьТипЗначенияИзТаблицыТипов(ТекущаяСтрока, ТаблицаТипов, ТекущаяСтрока.Определение <> "Метаданные", Истина);
			Если Истина
				И мМетодМодуля <> Неопределено
				И (Ложь
					Или ТекущаяСтрока.Определение = "Статистический" 
					Или ТекущаяСтрока.Определение = "Локальный")
			Тогда
				СтарыеТипы = мМетодМодуля.СтарыеТипы;
				Если СтарыеТипы = Неопределено Тогда 
					СтарыеТипы = Новый Соответствие;
					мМетодМодуля.СтарыеТипы = СтарыеТипы;
				КонецЕсли;
				Если ТекущаяСтрока.ТипЗначения <> "?" Тогда
					СтарыеТипы.Вставить(ТекущаяСтрока.НСлово, ТекущаяСтрока.ТипЗначения);
				КонецЕсли;
			КонецЕсли;
		КонецЕсли; 
	КонецЕсли;
	Возврат ТаблицаТипов;

КонецФункции

//.
// Параметры:
//    ТекущаяСтрока - ОбработкаТабличнаяЧастьСтрока.ирКлсПолеТекстаПрограммы.ТаблицаСлов - 
//    СтруктураТипаКонтекста - СтрокаТаблицыЗначений - 
//    Слово - Строка - 
// Возвращаемое значение:
//    Структура - 
Функция РодительИСловоСтрокиТаблицыСлов(Знач ТекущаяСтрока) Экспорт
	ФрагментыСлова = ирОбщий.СтрРазделитьЛкс(ТекущаяСтрока.Слово, РазделительВариантаКонтекста());
	Слово = ФрагментыСлова[0]; 
	СтруктураТипаКонтекста = мСтруктураТипаКонтекста;
	ВнутриГруппыОбщихМодулей = Ложь; 
	Родитель = "";
	Если ФрагментыСлова.Количество() > 1 Тогда
		Для Каждого СтруктураТипа Из мТаблицаТиповКонтекста Цикл
			Если Истина
				И СтруктураТипа.ИмяОбщегоТипа = "ОбщийМодуль"
				И СтруктураТипа.Метаданные.Имя = ФрагментыСлова[1] 
			Тогда 
				СтруктураТипаКонтекста = СтруктураТипа;
				ВнутриГруппыОбщихМодулей = Истина;
				Родитель = ФрагментыСлова[1];
				Прервать; 
			КонецЕсли;
		КонецЦикла;
	КонецЕсли;
	Результат = Новый Структура;
	Результат.Вставить("Слово", Слово);
	Результат.Вставить("Родитель", Родитель);
	Результат.Вставить("СтруктураТипаКонтекста", СтруктураТипаКонтекста);
	Результат.Вставить("ВнутриГруппыОбщихМодулей", ВнутриГруппыОбщихМодулей);
	Возврат Результат;
КонецФункции

// Вызывается из адаптера
Функция РазделительВариантаКонтекста() Экспорт
	Возврат мПлатформа.РазделительВариантаКонтекста();
КонецФункции

Процедура ОткрытьСписокМетодов(Знач СтрокаПоиска = "", Знач ТолькоЭтогоМодуля = Ложь) Экспорт 
	
	Если Не ЗначениеЗаполнено(СтрокаПоиска) Тогда
		//СтрокаПоиска = ирОбщий.ПервыйФрагментЛкс(мТекущееСлово, "("); // Часто вредно
	КонецЕсли;
	Если ТолькоЭтогоМодуля Тогда
		НовыйКлючСохраненияПоложенияОкна = "ОдинМодуль";
		АнализаторКода = ирКэш.ПолеТекстаМодуляЛкс(мМодульМетаданных.Имя);
	Иначе 
		АнализаторКода = ЭтотОбъект;
	КонецЕсли;  
	ФормаВыбора = АнализаторКода.ПолучитьФорму("МетодыМодулей");
	ФормаВыбора.ПараметрСтрокаПоиска = СтрокаПоиска; 
	Если Не ФормаВыбора.Открыта() Тогда
		ФормаВыбора.КлючСохраненияПоложенияОкна = НовыйКлючСохраненияПоложенияОкна;
	КонецЕсли;
	ФормаВыбора.ПараметрМодуль = мМодульМетаданных; 
	Если мМетодМодуля <> Неопределено Тогда
		ФормаВыбора.ПараметрИмяМетода = мМетодМодуля.Имя; 
	КонецЕсли;
	ФормаВыбора.Открыть();
	
КонецПроцедуры 

Функция ОткрытьПоискВызововСлова(Знач ЧтоИскать = Неопределено, Знач ИскатьНепрямые = Истина, Знач Автозапуск = Истина) Экспорт 
	
	Если ЧтоИскать = Неопределено Тогда
		КончитьОбработкуКоманды();
		РазобратьТекущийКонтекст(,,,,, Истина);
		Если ЗначениеЗаполнено(мРодительскийКонтекст) Тогда
			ТаблицаТиповРодителя = ВычислитьТипЗначенияВыражения(мРодительскийКонтекст, " " + мТекстДляПоискаОпределения, мПредшествующийТекст, Истина);
			Если ТаблицаТиповРодителя.Количество() > 0 Тогда
				СтруктураТипаРодителя = ТаблицаТиповРодителя[0];
			КонецЕсли;
		Иначе 
			СтруктураТипаРодителя = мМодульМетаданных.СтруктураТипа;
		КонецЕсли;
		ЧтоИскать = мКонтекст;
		Если Прав(мКонтекст, 1) <> "(" И ЛиВЗаголовкеМетода() Тогда
			ЧтоИскать = мМетодМодуля.Имя + "(";
			ИмяПараметра = мКонтекст;
		КонецЕсли;
	ИначеЕсли Найти(ЧтоИскать, ".") = 0 Тогда
		СтруктураТипаРодителя = мМодульМетаданных.СтруктураТипа;
	КонецЕсли; 
	Если Не ЗначениеЗаполнено(ЧтоИскать) Тогда
		Возврат Ложь;
	КонецЕсли;
	ТаблицаТиповКонтекста = ВычислитьТипЗначенияВыражения(ЧтоИскать, " " + мТекстДляПоискаОпределения, мПредшествующийТекст, Истина);
	Если ТаблицаТиповКонтекста.Количество() > 0 Тогда
		СтруктураТипаКонтекста = ТаблицаТиповКонтекста[0];
	Иначе 
		СтруктураТипаКонтекста = мПлатформа.НоваяСтруктураТипа();
	КонецЕсли;
	ПолноеИмяСлова = "";
	Если СтруктураТипаКонтекста.ТипЯзыка = "ИмяТипа" Тогда
		ПолноеИмяСлова = "Новый "; 
		Если ИскатьНепрямые = Неопределено Тогда
			ИскатьНепрямые = Ложь;
		КонецЕсли;
		Если Прав(ЧтоИскать, 1) <> "(" Тогда
			ЧтоИскать = ЧтоИскать + "(";
		КонецЕсли;
		//СтруктураТипаКонтекста = Неопределено;
	Иначе
		Если СтруктураТипаРодителя <> Неопределено Тогда 
			ПолноеИмяСлова = мПлатформа.ИмяТипаИзСтруктурыТипа(СтруктураТипаРодителя) + ".";
			Если ИскатьНепрямые = Неопределено Тогда
				ИскатьНепрямые = Ложь;
			КонецЕсли;
			//СтруктураТипаКонтекста = Неопределено;
		Иначе
			Если ирОбщий.МножественноеИмяМДЛкс(ирОбщий.ПервыйФрагментЛкс(ЧтоИскать)) <> Неопределено Тогда
				//ПолноеИмяСлова = ирОбщий.ПервыеФрагментыЛкс(ЧтоИскать,, Макс(2, СтрЧислоВхождений(ЧтоИскать, ".") - 1)) + ".";
				ПолноеИмяСлова = ирОбщий.СтрокаБезПоследнегоФрагментаЛкс(ЧтоИскать) + "."; // TODO сделать вычисление типа родителя
			КонецЕсли;
			Если ИскатьНепрямые = Неопределено Тогда
				СтрокаОписания = СтруктураТипаКонтекста.СтрокаОписания; // СтрокаТаблицыЗначений
				Если Истина
					И СтрокаОписания <> Неопределено
					И СтрокаОписания.Владелец().Колонки.Найти("ТипКонтекста") <> Неопределено
					И СтрокаОписания.ТипКонтекста = "Глобальный"
				Тогда
					ИскатьНепрямые = Ложь;
				ИначеЕсли Истина
					И мМодульМетаданных <> Неопределено
					И СтрокаОписания <> Неопределено
					И СтрокаОписания.Владелец() = мМодульМетаданных.Методы
					И Не мМетодМодуля.ЛиЭкспорт
				Тогда
					ИскатьНепрямые = Ложь;
				Иначе
					ИскатьНепрямые = Истина;
				КонецЕсли;
			КонецЕсли;
		КонецЕсли;
	КонецЕсли;
	ПолноеИмяСлова = ПолноеИмяСлова + ирОбщий.ПоследнийФрагментЛкс(ЧтоИскать);
	ПоискВызововМетода = ПолучитьФорму("ПоискВМодулях"); // Всегда новая, т.к. при открытии будет подмена основного объекта
	ПоискВызововМетода.ПараметрЧтоИскать = ПолноеИмяСлова;
	ПоискВызововМетода.ПараметрСтруктураТипаРодителя = СтруктураТипаРодителя;
	ПоискВызововМетода.ПараметрРежимПоиска = "Ссылки";
	ПоискВызововМетода.ПараметрИскатьНепрямые = ИскатьНепрямые;
	ПоискВызововМетода.ПараметрСтруктураТипаКонтекста = СтруктураТипаКонтекста;
	ПоискВызововМетода.ПараметрИмяПараметра = ИмяПараметра;
	ПоискВызововМетода.Открыть();
	Если Автозапуск Тогда
		ПоискВызововМетода.ОбновитьДанные();
	КонецЕсли;
	Возврат Истина;
	
КонецФункции

Функция ОткрытьПоискВМодулях(Знач ЧтоИскать = Неопределено, Знач Автозапуск = Истина) Экспорт 
	
	Если ЧтоИскать = Неопределено Тогда
		ЧтоИскать = ВыделенныйТекст();
		Если Истина
			И Не ЗначениеЗаполнено(ЧтоИскать) 
			И ЗначениеЗаполнено(ТекущееОбъектноеВыражение())
		Тогда
			Возврат ОткрытьПоискВызововСлова(, Истина, Автозапуск);
		КонецЕсли;
	КонецЕсли;
	ПоискВызововМетода = ПолучитьФорму("ПоискВМодулях"); // Всегда новая, т.к. при открытии будет подмена основного объекта
	ПоискВызововМетода.ПараметрЧтоИскать = ЧтоИскать;
	ПоискВызововМетода.ПараметрРежимПоиска = "Точный";
	ПоискВызововМетода.Открыть();
	Если Автозапуск и ЗначениеЗаполнено(ЧтоИскать) Тогда 
		ПоискВызововМетода.ОбновитьДанные();
	КонецЕсли;
	Возврат Истина;
	
КонецФункции 

Функция ОткрытьДеревоВызовов(Знач ЧтоИскать = Неопределено, Знач Автозапуск = Истина) Экспорт 
	
	Если мМетодМодуля = Неопределено Тогда
		Возврат Ложь;
	КонецЕсли;
	КончитьОбработкуКоманды();
	РазобратьТекущийКонтекст(,,,,, Истина);
	ПоискВызововМетода = ПолучитьФорму("ДеревоВызовов"); // Всегда новая, т.к. при открытии будет подмена основного объекта
	Если Не ЗначениеЗаполнено(мМетодМодуля.ИмяМодуля) Тогда
		мМетодМодуля.ИмяМодуля = мИмяМодуля;
	КонецЕсли;
	ПоискВызововМетода.ПараметрСтрокаМетода = мМетодМодуля;
	ПоискВызововМетода.Открыть();
	Возврат Истина;
	
КонецФункции   

Функция ОткрытьДеревоСвязейПоля(Знач ЧтоИскать = Неопределено, Знач Автозапуск = Истина) Экспорт 
	
	КончитьОбработкуКоманды();
	РазобратьТекущийКонтекст();
	ВыражениеПодходит = Ложь;
	ТекущееВыражение = ТекущееОбъектноеВыражение();
	Если Истина
		И ирОбщий.СтрКончаетсяНаЛкс(СокрП(мПредшествующийТекст), "КАК")
		И ирОбщий.ЛиИмяПеременнойЛкс(ТекущееВыражение) 
	Тогда
		ПодготовитьПакетЗапросов(мПакетЗапросов);
		ИмяТаблицы = мПакетЗапросов.Структура[мИндексЗапросаПакета].Представление;
		Если ЗначениеЗаполнено(ИмяТаблицы) Тогда
			ИндексКорневогоЗапроса = мИндексЗапросаПакета;
			ВыражениеПодходит = Истина;
		КонецЕсли;
	ИначеЕсли Найти(ТекущееВыражение, "(") = 0 Тогда
		Фрагменты = ирОбщий.СтрРазделитьЛкс(ТекущееВыражение);
		Если Фрагменты.Количество() = 2 Тогда
			ИмяТаблицы = НайтиОпределениеСлова(Фрагменты[0]);
			Если ирОбщий.ЛиИмяПеременнойЛкс(ИмяТаблицы) Тогда
				ВыражениеПодходит = Истина;
				ТекущееВыражение = Фрагменты[1];
			КонецЕсли;
		КонецЕсли;
	КонецЕсли;
	Если Не ВыражениеПодходит Тогда
		ирОбщий.СообщитьЛкс("Команду нужно вызывать на обращении к полю или на назначении псевдонима поля временной таблицы");
		Возврат Ложь;
	КонецЕсли;
	ПакетЗапросов = НовыйПакетЗапросов(мОригинальныйТекст);
	ПодготовитьПакетЗапросов(ПакетЗапросов);
	ДеревоСвязейПоля = ПолучитьФорму("ДеревоСвязейПоля"); // Всегда новая, т.к. при открытии будет подмена основного объекта
	ДеревоСвязейПоля.ПакетЗапросов = ПакетЗапросов;
	ДеревоСвязейПоля.ПараметрИмяТаблицы = ИмяТаблицы;
	ДеревоСвязейПоля.ПараметрПоле = ТекущееВыражение;
	ДеревоСвязейПоля.ПараметрИндексТекущегоЗапроса = мИндексЗапросаПакета;
	ДеревоСвязейПоля.Открыть();
	Возврат Истина;
	
КонецФункции

// Заменяет все символы табуляции в строке после первого печатного символа эквивалентным количеством пробелов.
//
// Параметры:
//  Строка       - Строка;
//
// Возвращаемое значение:
//  Строка.
//
Функция ЗаменитьТабуляцииВСтроке(Знач Строка, ЛиТекущая = Ложь)
	
	Табы = "";
	А = 1; НачалоСтроки = Истина;   
	Пока А <= СтрДлина(Строка) Цикл
		Если Сред(Строка, А, 1) <> Символы.Таб И НачалоСтроки Тогда
			// Найдем начало строки без табов 
			Табы = Лев(Строка, А-1);
			Строка = Прав(Строка, СтрДлина(Строка) - А + 1);
			НачалоСтроки = Ложь;
		ИначеЕсли Сред(Строка, А, 1) = Символы.Таб И НЕ НачалоСтроки Тогда
			// Удалим табы из строки 
			Строка = Лев(Строка, А - 1) + Лев("    ", 4 - СтрДлина(Лев(Строка, А - 1)) % 4) 
				+ Прав(Строка, СтрДлина(Строка) - А);
			Если Истина
				И ЛиТекущая
				И мКонечнаяКолонка > А
			Тогда
				мКонечнаяКолонка = мКонечнаяКолонка + 3 - СтрДлина(Лев(Строка, А - 1)) % 4;
			КонецЕсли;
		КонецЕсли;
		А = А + 1;
	КонецЦикла;
	
	Возврат Табы + Строка;
    
КонецФункции

// Заменяет все символы табуляции в каждой строке текста после первого печатного символа эквивалентным
// количеством пробелов.
//
// Параметры:
//  Нет.
//
Процедура ЗаменитьТабуляции()

	Если Ложь
		Или ПолеТекста.ТолькоПросмотр()
		Или ФормаВладелец.ТолькоПросмотр
	Тогда
		Возврат;
	КонецЕсли;
	КоличествоСтрок = ПолеТекста.КоличествоСтрок();
	Для А = 1 По КоличествоСтрок Цикл
	    Строка = ЗаменитьТабуляцииВСтроке(ПолеТекста.ПолучитьСтроку(А), (А = мКонечнаяСтрока));
	    ПолеТекста.ЗаменитьСтроку(А, Строка);
	КонецЦикла;
	УстановитьПризнакМодифицированностиФормы();
	мНачальнаяКолонка = мКонечнаяКолонка;

КонецПроцедуры

Процедура УстановитьАвтоКонтекстнаяПомощь(НовыйРежим)

	Кнопка = ирКлиент.КнопкаКоманднойПанелиЭкземпляраКомпонентыЛкс(ЭтотОбъект, "АвтоКонтекстнаяПомощь");
	Если Кнопка = Неопределено Тогда
		// Это сделано временно для работы в ссылочном режиме
		Возврат;
	КонецЕсли; 
	мАвтоКонтекстнаяПомощь = НовыйРежим;
	Если мАвтоКонтекстнаяПомощь Тогда
		ФормаВладелец.ПодключитьОбработчикОжидания("КлсПолеТекстаПрограммыАвтоОбновитьСправку", 1);
	Иначе
		ФормаВладелец.ОтключитьОбработчикОжидания("КлсПолеТекстаПрограммыАвтоОбновитьСправку");
	КонецЕсли; 
	Кнопка.Пометка = мАвтоКонтекстнаяПомощь;

КонецПроцедуры

// Удаляет все символы переноса строки из текста.
Процедура УдалитьПереносы()
	
	#Если Сервер И Не Сервер Тогда
		ПолеТекста = Обработки.ирОболочкаПолеТекста.Создать();
	#КонецЕсли
	Если Ложь
		Или ПолеТекста.ТолькоПросмотр()
		Или ФормаВладелец.ТолькоПросмотр
	Тогда
		Возврат;
	КонецЕсли;
	Текст = ПолеТекста.ПолучитьТекст();
	Текст = мПлатформа.ЗамаскироватьДирективыПрепроцессора(Текст);
	Текст = СокрЛП(Текст);
	Если Истина
		И Лев(Текст, 1) = """"
		И Лев(Текст, 2) <> """"""
	Тогда
		Текст = "|" + Сред(Текст, 2);
	КонецЕсли; 
	ОбработанныеСтроки = Новый Массив;
	Для Каждого СтрокаТекста Из ирОбщий.СтрРазделитьЛкс(Текст, Символы.ПС) Цикл
		Если Лев(СокрЛ(СтрокаТекста), 1) = "|" Тогда
			СтрокаТекста = СтрЗаменить(СтрокаТекста, """""", """");
			СтрокаТекста = СтрЗаменить(СтрокаТекста, "|", "");
		КонецЕсли;
		ОбработанныеСтроки.Добавить(СтрокаТекста);
	КонецЦикла;
	Текст = ирОбщий.СтрСоединитьЛкс(ОбработанныеСтроки, Символы.ПС);
	Если Истина
		И Прав(Текст, 1) = """"
		И Прав(Текст, 2) <> """"""
	Тогда
		Текст = Лев(Текст, СтрДлина(Текст) - 1);
	КонецЕсли; 
	Если Истина
		И Прав(Текст, 2) = """;"
		И Прав(Текст, 3) <> """"";"
	Тогда
		Текст = Лев(Текст, СтрДлина(Текст) - 2);
	КонецЕсли;
	ВыделитьВесьТекст();
	ВыделенныйТекст(Текст);
	УстановитьПризнакМодифицированностиФормы();
	
КонецПроцедуры

//.
// Параметры:
//    СтруктураТипа - см. мПлатформа.НоваяСтруктураТипа()  -  
// Возвращаемое значение:
//    ОбъектМетаданных, Неопределено - 
Функция ОбъектМДИзСтруктурыТипаМодуля(Знач СтруктураТипа) Экспорт
	ОбъектМД = СтруктураТипа.Метаданные;
	Если ТипЗнч(ОбъектМД) = Тип("Форма") Тогда
		СтруктураТипаОбъекта = мПлатформа.СтруктураТипаОбъектаОбычнойФормы(ОбъектМД);
		Если СтруктураТипаОбъекта <> Неопределено Тогда
			ОбъектМД = СтруктураТипаОбъекта.Метаданные;
		КонецЕсли;
	КонецЕсли;
	Возврат ОбъектМД;
КонецФункции 

// .
// Параметры:
//  РодительскаяСтруктураТипа	 - см. мПлатформа.НоваяСтруктураТипа() - 
//  ТаблицаТипов	 - см. мПлатформа.НоваяТаблицаТипов() - 
Функция ВычислитьРезультатМетодаШаблон(Знач РодительскаяСтруктураТипа, Знач МассивПараметров, Знач Слово = "", Знач ПредшествующийТекст = "", Знач ПозицияВМетоде = 0, Знач ТаблицаТипов = Неопределено, Знач ДляСвойства = "") 
КонецФункции

// см. ВычислитьРезультатМетодаШаблон
Функция ВычислитьОткрытьМодально(Знач РодительскаяСтруктураТипа, Знач МассивПараметров, Знач Слово = "", Знач ПредшествующийТекст = "", Знач ПозицияВМетоде = 0, Знач ТаблицаТипов = Неопределено, Знач ДляСвойства = "") 
	МодульФормы = мПлатформа.ПодготовитьМодульМетаданных(РодительскаяСтруктураТипа);
	Если МодульФормы = Неопределено Тогда
		Возврат ТаблицаТипов;
	КонецЕсли;
	АнализаторМодуля = мПлатформа.ПолеТекстаМодуля(МодульФормы);
	Если АнализаторМодуля = Неопределено Тогда
		Возврат ТаблицаТипов;
	Иначе 
		Результат = АнализаторМодуля.ВычислитьТипЗначенияЗакрытияФормы();
	КонецЕсли;
	Если Результат <> Неопределено Тогда
		Возврат Результат;
	Иначе
		Возврат ТаблицаТипов;
	КонецЕсли;
КонецФункции

Функция ВычислитьТипЗначенияЗакрытияФормы() Экспорт
	Результат = Неопределено;
	ШаблонПоиска = шПредИнструкция + ШаблонПоискаСловаЧерезЭтотОбъект("Закрыть") + "\s*\(\s*(" + шПростоеВыражениеПрограммы + ")\s*\)";
	Вхождения = НайтиВхожденияРегВыраженияКэш(ШаблонПоиска, Истина,, "Форма.Закрыть");
	Для Каждого Вхождение Из Вхождения Цикл
		ЗагрузитьМетодМодуляПоВхождениюИРазобратьКонтекст(Истина, Вхождение);
		ВыражениеЗначения = Вхождение.SubMatches(0);
		ТаблицаТиповВыражения = ВычислитьТипЗначенияВыражения(ВыражениеЗначения,,,,,, Ложь,,,,, Вхождение.FirstIndex);
		Если ТаблицаТиповВыражения.Количество() = 0 Тогда
			Продолжить;
		КонецЕсли;
		Результат = мПлатформа.ДобавитьВТаблицуТипов(Результат, ТаблицаТиповВыражения);
	КонецЦикла;
	Возврат Результат;
КонецФункции

// см. ВычислитьРезультатМетодаШаблон
Функция ВычислитьПолучитьФорму(Знач РодительскаяСтруктураТипа, Знач МассивПараметров, Знач Слово = "", Знач ПредшествующийТекст = "", Знач ПозицияВМетоде = 0, Знач ТаблицаТипов = Неопределено, Знач ДляСвойства = "") 
	//ТаблицаТипов.ЗаполнитьЗначения(, "Метаданные"); // Ломает расчет возможных значений литерала в ОбработкаОбъект.ПолучитьФорму("")
	Если МассивПараметров.Количество() = 0 Тогда
		ИмяФормы = "";
	Иначе
		ИмяФормы = ВычислитьЗначениеВыражения(МассивПараметров[0], ПредшествующийТекст,,, ПозицияВМетоде);
	КонецЕсли; 
	Если ИмяФормы = Неопределено Тогда
		//СтруктураТипа = мПлатформа.СтруктураТипаИзКонкретногоТипа(ирОбщий.ТипУправляемаяФормаЛкс());
	Иначе 
		Если Истина
			И Найти(ИмяФормы, ".") = 0
			И Найти(ИмяФормы, ":") = 0 // системная форма
		Тогда
			// Контекстное имя формы
			Если ирОбщий.СтрокиРавныЛкс("ПолучитьОбщуюФорму", Слово) Тогда
				МетаФорма = Метаданные.ОбщиеФормы.Найти(ИмяФормы);
			Иначе
				ОбъектМД = ОбъектМДИзСтруктурыТипаМодуля(РодительскаяСтруктураТипа);
				Если ТипЗнч(ОбъектМД) = Тип("Форма") Тогда
					Попытка
						ОбъектМД = ОбъектМД.Метаданные(); 
					Исключение
					КонецПопытки;
				КонецЕсли;
				Если ТипЗнч(ОбъектМД) <> Тип("ОбъектМетаданных") Тогда
					Возврат Неопределено;
				КонецЕсли;
				Если ЗначениеЗаполнено(ИмяФормы) Тогда
					МетаФорма = ОбъектМД.Формы.Найти(ИмяФормы); 
				ИначеЕсли ирОбщий.СтрокиРавныЛкс("ПолучитьФормуСписка", Слово) Тогда     
					МетаФорма = ОбъектМД.ОсновнаяФормаСписка;
				ИначеЕсли ирОбщий.СтрокиРавныЛкс("ПолучитьФормуВыбора", Слово) Тогда     
					МетаФорма = ОбъектМД.ОсновнаяФормаДляВыбора;
				Иначе
					МетаФорма = ирОбщий.ОсновнаяФормаОбъектаМДЛкс(ОбъектМД);
				КонецЕсли;
			КонецЕсли;
			Если МетаФорма = Неопределено Тогда
				Возврат Неопределено;
			КонецЕсли;
			ИмяФормы = МетаФорма.ПолноеИмя();
		ИначеЕсли Истина
			И Найти(ИмяФормы, ".Форма.") = 0
			И Найти(ИмяФормы, "ОбщаяФорма.") = 0
			И Не ирОбщий.СтрНачинаетсяСЛкс(ИмяФормы, "Отчет.") // У отчетов часто используется единая относительная форма, которая не сможет создаться по прямому имени
		Тогда
			// Относительное имя формы
			ОбъектМД = ирКэш.ОбъектМДПоПолномуИмениЛкс(ирОбщий.СтрокаБезПоследнегоФрагментаЛкс(ИмяФормы));
			Если ОбъектМД <> Неопределено Тогда
				ИмяРолиФормы = "Основная" + ирОбщий.ПоследнийФрагментЛкс(ИмяФормы);
				Попытка
					МетаФорма = ОбъектМД[ИмяРолиФормы];
				Исключение
					//
				КонецПопытки;
				// Отключено выше
				//Если Истина
				//	И МетаФорма = Неопределено
				//	И ирОбщий.СтрНачинаетсяСЛкс(ИмяФормы, "Отчет.")
				//Тогда
				//	МетаФорма = Метаданные.ОсновнаяФормаОтчета;
				//КонецЕсли;
			КонецЕсли;
			Если МетаФорма = Неопределено Тогда
				Возврат Неопределено;
			КонецЕсли;
			ИмяФормы = МетаФорма.ПолноеИмя();
		КонецЕсли;
		Если ирОбщий.СтрНачинаетсяСЛкс(ИмяФормы, "Внешн") тогда
			ФрагментыИмени = ирОбщий.СтрРазделитьЛкс(ИмяФормы);
			Если РодительскаяСтруктураТипа.ИмяОбщегоТипа = "Локальный" Тогда
				РодительскаяСтруктураТипа = мМодульМетаданных.СтруктураТипа;
			КонецЕсли;
			Если Истина
				И ирОбщий.СтрНачинаетсяСЛкс(РодительскаяСтруктураТипа.ДержательМетаданных, "Внешн")
				И ирОбщий.СтрокиРавныЛкс(РодительскаяСтруктураТипа.ДержательМетаданных.Метаданные().Имя, ФрагментыИмени[1])
			Тогда
				ИмяФормы = "Ф::" + РодительскаяСтруктураТипа.ДержательМетаданных.ИспользуемоеИмяФайла + "::" + ирОбщий.СтрокаБезПервогоФрагментаЛкс(ИмяФормы);
			КонецЕсли;
		КонецЕсли;
		ФормаИлиИмитатор = мПлатформа.ПассивнаяФормаПоИмениКэш(ИмяФормы);
		Если ФормаИлиИмитатор <> Неопределено Тогда 
			Если ТипЗнч(ФормаИлиИмитатор) = Тип("Структура") Тогда 
				СтруктураТипа = мПлатформа.СтруктураТипаИзКонкретногоТипа(ФормаИлиИмитатор.Тип);
				СтруктураТипа.Метаданные = ФормаИлиИмитатор;
			Иначе 
				Форма = ФормаИлиИмитатор;
				СтруктураТипа = мПлатформа.СтруктураТипаИзЗначения(Форма);
				Если Истина
					И МетаФорма <> Неопределено
					И МетаФорма.РасширениеКонфигурации() <> Неопределено
				Тогда
					СтруктураТипа.ДержательМетаданных = МетаФорма.РасширениеКонфигурации().Имя;
				КонецЕсли;
			КонецЕсли;
			Если ТипЗнч(Форма) = Тип("Форма") Тогда     
				СлужебныеДанныеФормы = ирОбщий.СлужебныеДанныеФормыЛкс(Форма);
				Если СлужебныеДанныеФормы <> Неопределено И Не СлужебныеДанныеФормы.Свойство("ИмяФормы") Тогда
					СлужебныеДанныеФормы.ИмяФормы = ИмяФормы;
				КонецЕсли;
			КонецЕсли;
		КонецЕсли;
	КонецЕсли;
	Если СтруктураТипа <> Неопределено Тогда
		Результат = мПлатформа.ДобавитьВТаблицуТипов(, СтруктураТипа);
	КонецЕсли;
	Возврат Результат;

КонецФункции

// см. ВычислитьРезультатМетодаШаблон
Функция ВычислитьПолучитьМакет(Знач РодительскаяСтруктураТипа, Знач МассивПараметров, Знач Слово = "", Знач ПредшествующийТекст = "", Знач ПозицияВМетоде = 0, Знач ТаблицаТипов = Неопределено, Знач ДляСвойства = "") 
	Если МассивПараметров.Количество() = 0 Тогда
		Возврат Неопределено;
	КонецЕсли;
	ИмяМакета = ВычислитьЗначениеВыражения(МассивПараметров[0], ПредшествующийТекст,,, ПозицияВМетоде);
	Если ИмяМакета = Неопределено Тогда
		Возврат Неопределено;
	КонецЕсли;
	Макет = Неопределено;
	Если ирОбщий.СтрокиРавныЛкс("ПолучитьОбщийМакет", Слово) Тогда
		МетаМакет = Метаданные.ОбщиеМакеты.Найти(ИмяМакета);
		Если МетаМакет <> Неопределено Тогда 
			Макет = ПолучитьОбщийМакет(ИмяМакета);
		КонецЕсли;  
	Иначе
		ОбъектМД = ОбъектМДИзСтруктурыТипаМодуля(РодительскаяСтруктураТипа);
		Если Ложь
			Или ТипЗнч(ОбъектМД) <> Тип("ОбъектМетаданных") 
			Или (Истина 
				// TODO Придумать как тут создать объект внешней обработки
				И РодительскаяСтруктураТипа.ДержательМетаданных = Неопределено
				И ирОбщий.СтрНачинаетсяСЛкс(РодительскаяСтруктураТипа.ИмяОбщегоТипа, "Внешн")
				И Найти(РодительскаяСтруктураТипа.ИмяОбщегоТипа, "Объект."))
		Тогда
			Возврат Неопределено;
		КонецЕсли;
		Если ЗначениеЗаполнено(ИмяМакета) Тогда
			Попытка
				Макеты = ОбъектМД.Макеты;
			Исключение
				Макеты = Новый Массив;
			КонецПопытки;
			МетаМакет = Макеты.Найти(ИмяМакета);
			Если МетаМакет <> Неопределено Тогда
				Если Истина
					И РодительскаяСтруктураТипа.ДержательМетаданных <> Неопределено
					И ТипЗнч(РодительскаяСтруктураТипа.ДержательМетаданных) <> Тип("Строка")
				Тогда
					// Внешние метаданные
					Менеджер = РодительскаяСтруктураТипа.ДержательМетаданных;
				Иначе
					Менеджер = Новый(ирОбщий.ИмяТипаИзПолногоИмениМДЛкс(ОбъектМД.ПолноеИмя(), "Менеджер")); // ОбработкаМенеджер.ирПлатформа
				КонецЕсли;
				Макет = Менеджер.ПолучитьМакет(ИмяМакета);
			КонецЕсли;
		КонецЕсли;
	КонецЕсли;
	Если МетаМакет = Неопределено Тогда
		Возврат Неопределено;
	КонецЕсли;
	СтруктураТипа = мПлатформа.СтруктураТипаИзЗначения(Макет);
	СтруктураТипа.ДержательМетаданных = МетаМакет;
	Результат = мПлатформа.ДобавитьВТаблицуТипов(, СтруктураТипа);
	Возврат Результат;

КонецФункции 

// см. ВычислитьРезультатМетодаШаблон 
Функция ВычислитьПрочитатьЗначениеJSON(Знач РодительскаяСтруктураТипа, Знач МассивПараметров, Знач Слово = "", Знач ПредшествующийТекст = "", Знач ПозицияВМетоде = 0, Знач ТаблицаТипов = Неопределено, Знач ДляСвойства = "") 
	Если МассивПараметров.Количество() = 0 Тогда
		Возврат Неопределено;
	КонецЕсли;
	ТипыСодержимого = ВычислитьТипЗначенияВыражения(МассивПараметров[0],,,,,, Ложь,,, Истина,, ПозицияВМетоде);
	Если ТипыСодержимого.Количество() > 0 Тогда
		МетаданныеТипа = ТипыСодержимого[0].Метаданные; 
		Если ТипЗнч(МетаданныеТипа) = Тип("ТаблицаЗначений") Тогда
			Возврат МетаданныеТипа;
		КонецЕсли;
	КонецЕсли;
	Если ТипЗнч(МетаданныеТипа) <> Тип("Строка") Тогда
		Возврат Неопределено;
	КонецЕсли;
	Попытка
		ДанныеИзТекста = ирОбщий.ОбъектИзСтрокиJSONЛкс(МетаданныеТипа);
	Исключение
		Возврат Неопределено;
	КонецПопытки;
	СтруктураТипа = мПлатформа.СтруктураТипаИзЗначения(ДанныеИзТекста);
	Результат = мПлатформа.ДобавитьВТаблицуТипов(, СтруктураТипа);
	Возврат Результат;

КонецФункции

// см. ВычислитьРезультатМетодаШаблон 
Функция ВычислитьФабрикаXDTOПрочитатьJSON(Знач РодительскаяСтруктураТипа, Знач МассивПараметров, Знач Слово = "", Знач ПредшествующийТекст = "", Знач ПозицияВМетоде = 0, Знач ТаблицаТипов = Неопределено, Знач ДляСвойства = "") 
	Если МассивПараметров.Количество() = 0 Тогда
		Возврат Неопределено;
	КонецЕсли;
	Текст = ВычислитьЗначениеВыражения(МассивПараметров[0], ПредшествующийТекст,,, ПозицияВМетоде);
	Если Текст = Неопределено Тогда
		Возврат Неопределено;
	КонецЕсли;
	Попытка              
		Чтение = Новый("ЧтениеJSON"); // В 8.2 нет
		Чтение.УстановитьСтроку(Текст); 
		Если РодительскаяСтруктураТипа.СтрокаОписания.ТипКонтекста = "ФабрикаXDTO" Тогда
			ДанныеИзТекста = ФабрикаXDTO.ПрочитатьJSON(Чтение);
		Иначе
			ДанныеИзТекста = СериализаторXDTO.ПрочитатьJSON(Чтение);
		КонецЕсли;
	Исключение
		Возврат Неопределено;
	КонецПопытки;
	СтруктураТипа = мПлатформа.СтруктураТипаИзЗначения(ДанныеИзТекста);
	Результат = мПлатформа.ДобавитьВТаблицуТипов(, СтруктураТипа);
	Возврат Результат;
КонецФункции 

// см. ВычислитьРезультатМетодаШаблон 
Функция ВычислитьПрочитатьJSON(Знач РодительскаяСтруктураТипа, Знач МассивПараметров, Знач Слово = "", Знач ПредшествующийТекст = "", Знач ПозицияВМетоде = 0, Знач ТаблицаТипов = Неопределено, Знач ДляСвойства = "") 
	Если МассивПараметров.Количество() > 0 Тогда
		Результат = ВычислитьПрочитатьЗначениеJSON(РодительскаяСтруктураТипа, МассивПараметров, Слово, ПредшествующийТекст, ПозицияВМетоде, ТаблицаТипов);
		Если Результат <> Неопределено Тогда
			Возврат Результат;
		КонецЕсли;
	КонецЕсли;
	Если МассивПараметров.Количество() < 2 Тогда
		ВторойПараметр = "";
	Иначе 
		ВторойПараметр = МассивПараметров[1];
	КонецЕсли;
	Если Ложь
		Или Не ЗначениеЗаполнено(ВторойПараметр)
		Или ирОбщий.СтрокиРавныЛкс(ВторойПараметр, "Ложь")
	Тогда
		ИменаТипов = "Структура";
	ИначеЕсли ирОбщий.СтрокиРавныЛкс(ВторойПараметр, "Истина") Тогда
		ИменаТипов = "Соответствие";
	Иначе
		ИменаТипов = "Структура, Соответствие";
	КонецЕсли; 
	Результат = мПлатформа.ТаблицаТиповИзОписанияТипов(Новый ОписаниеТипов(ИменаТипов));
	Возврат Результат;
КонецФункции

// см. ВычислитьРезультатМетодаШаблон 
Функция ВычислитьФабрикаXDTOСоздать(Знач РодительскаяСтруктураТипа, Знач МассивПараметров, Знач Слово = "", Знач ПредшествующийТекст = "", Знач ПозицияВМетоде = 0, Знач ТаблицаТипов = Неопределено, Знач ДляСвойства = "") 
	Если МассивПараметров.Количество() < 1 Тогда
		Возврат Неопределено;
	КонецЕсли;
	ТипОбъекта = ВычислитьЗначениеВыражения(МассивПараметров[0], ПредшествующийТекст,,, ПозицияВМетоде);
	Если ТипОбъекта = Неопределено Тогда
		Возврат Неопределено;
	КонецЕсли;
	Попытка              
		ДанныеИзТекста = ФабрикаXDTO.Создать(ТипОбъекта);
	Исключение
		Возврат Неопределено;
	КонецПопытки;
	СтруктураТипа = мПлатформа.СтруктураТипаИзЗначения(ДанныеИзТекста);
	Результат = мПлатформа.ДобавитьВТаблицуТипов(, СтруктураТипа);
	Возврат Результат;

КонецФункции

// см. ВычислитьРезультатМетодаШаблон 
Функция ВычислитьФабрикаXDTOТип(Знач РодительскаяСтруктураТипа, Знач МассивПараметров, Знач Слово = "", Знач ПредшествующийТекст = "", Знач ПозицияВМетоде = 0, Знач ТаблицаТипов = Неопределено, Знач ДляСвойства = "") 
	Если МассивПараметров.Количество() < 2 Тогда
		Возврат Неопределено;
	КонецЕсли;
	Текст1 = ВычислитьЗначениеВыражения(МассивПараметров[0], ПредшествующийТекст,,, ПозицияВМетоде);
	Если Текст1 = Неопределено Тогда
		Возврат Неопределено;
	КонецЕсли;
	Текст2 = ВычислитьЗначениеВыражения(МассивПараметров[1], ПредшествующийТекст,,, ПозицияВМетоде);
	Если Текст2 = Неопределено Тогда
		Возврат Неопределено;
	КонецЕсли;
	Попытка              
		ДанныеИзТекста = ФабрикаXDTO.Тип(Текст1, Текст2);
	Исключение
		Возврат Неопределено;
	КонецПопытки;
	СтруктураТипа = мПлатформа.СтруктураТипаИзЗначения(ДанныеИзТекста);
	СтруктураТипа.Метаданные = ДанныеИзТекста;
	Результат = мПлатформа.ДобавитьВТаблицуТипов(, СтруктураТипа);
	Возврат Результат;

КонецФункции

// см. ВычислитьРезультатМетодаШаблон 
Функция ВычислитьФабрикаXDTOПрочитатьXML(Знач РодительскаяСтруктураТипа, Знач МассивПараметров, Знач Слово = "", Знач ПредшествующийТекст = "", Знач ПозицияВМетоде = 0, Знач ТаблицаТипов = Неопределено, Знач ДляСвойства = "") 
	Если МассивПараметров.Количество() = 0 Тогда
		Возврат Неопределено;
	КонецЕсли;
	Текст = ВычислитьЗначениеВыражения(МассивПараметров[0], ПредшествующийТекст,,, ПозицияВМетоде);
	Если Текст = Неопределено Тогда
		Возврат Неопределено;
	КонецЕсли;
	Попытка              
		Чтение = Новый ЧтениеXML;
		Чтение.УстановитьСтроку(Текст);
		ДанныеИзТекста = ФабрикаXDTO.ПрочитатьXML(Чтение);
	Исключение
		Возврат Неопределено;
	КонецПопытки;
	СтруктураТипа = мПлатформа.СтруктураТипаИзЗначения(ДанныеИзТекста);
	Результат = мПлатформа.ДобавитьВТаблицуТипов(, СтруктураТипа);
	Возврат Результат;

КонецФункции

// см. ВычислитьРезультатМетодаШаблон 
Функция ВычислитьТипЗнч(Знач РодительскаяСтруктураТипа, Знач МассивПараметров, Знач Слово = "", Знач ПредшествующийТекст = "", Знач ПозицияВМетоде = 0, Знач ТаблицаТипов = Неопределено, Знач ДляСвойства = "") 
	Если МассивПараметров.Количество() = 0 Тогда
		Возврат Неопределено;
	КонецЕсли;
	ПозицияПараметраВМетоде = ПозицияВМетоде + СтрДлина(Слово) + 1;
	ТаблицаТиповВложенная = ВычислитьТипЗначенияВыражения(МассивПараметров[0], ПредшествующийТекст, ПредшествующийТекст,,,, Ложь,,,,, ПозицияПараметраВМетоде,, ИмяФиктивногоСвойства());
	ТаблицаТипов[0].Метаданные = ТаблицаТиповВложенная;
	Возврат ТаблицаТипов;
КонецФункции

// см. ВычислитьРезультатМетодаШаблон 
Функция ВычислитьПолучитьОбласть(Знач РодительскаяСтруктураТипа, Знач МассивПараметров, Знач Слово = "", Знач ПредшествующийТекст = "", Знач ПозицияВМетоде = 0, Знач ТаблицаТипов = Неопределено, Знач ДляСвойства = "") 
	Если МассивПараметров.Количество() = 0 Тогда
		Возврат Неопределено;
	КонецЕсли;
	ПервыйПараметр = МассивПараметров[0];
	ИмяОбласти = ВычислитьЗначениеВыражения(ПервыйПараметр, ПредшествующийТекст,,, ПозицияВМетоде);
	Если Ложь
		Или ИмяОбласти = Неопределено 
		Или ТипЗнч(РодительскаяСтруктураТипа.Метаданные) <> Тип("ТабличныйДокумент")
	Тогда
		Возврат Неопределено;
	КонецЕсли;  
	ТабличныйДокумент = РодительскаяСтруктураТипа.Метаданные; // ТабличныйДокумент
	Попытка
		Если ирОбщий.СтрокиРавныЛкс(Слово, "Область") Тогда
			Значение = ТабличныйДокумент.Область(ИмяОбласти);
		Иначе
			Значение = ТабличныйДокумент.ПолучитьОбласть(ИмяОбласти);
		КонецЕсли;
	Исключение
		Возврат Неопределено;
	КонецПопытки;
	СтруктураТипа = мПлатформа.СтруктураТипаИзЗначения(Значение);
	Результат = мПлатформа.ДобавитьВТаблицуТипов(, СтруктураТипа);
	Возврат Результат;

КонецФункции

// см. ВычислитьРезультатМетодаШаблон 
Функция ВычислитьРеквизитФормыВЗначение(Знач РодительскаяСтруктураТипа, Знач МассивПараметров, Знач Слово = "", Знач ПредшествующийТекст = "", Знач ПозицияВМетоде = 0, Знач ТаблицаТипов = Неопределено, Знач ДляСвойства = "") 
	Если МассивПараметров.Количество() = 0 Тогда
		Возврат Неопределено;
	КонецЕсли;
	Если Не ЛиПодробнаяСтруктураТипаУпрФормы(РодительскаяСтруктураТипа) Тогда
		Возврат Неопределено;
	КонецЕсли;
	ИмяРеквизита = ВычислитьЗначениеВыражения(МассивПараметров[0], ПредшествующийТекст,,, ПозицияВМетоде);
	Если ПустаяСтрока(ИмяРеквизита) Тогда
		Возврат Неопределено;
	КонецЕсли;      
	СлужебныеДанные = ирОбщий.СлужебныеДанныеФормыЛкс(РодительскаяСтруктураТипа.Метаданные);
	Если Истина
		И СлужебныеДанные <> Неопределено
		И СлужебныеДанные.Свойство("Реквизиты")
		И Найти(ИмяРеквизита, ".") = 0 
	Тогда 
		//! СлужебныеДанные.Вставить("Реквизиты"); // см. мПлатформа.НоваяТаблицаРеквизитовФормы()
		ОписаниеРеквизита = СлужебныеДанные.Реквизиты.Найти(НРег(ИмяРеквизита), "НИмя");
		Если ОписаниеРеквизита <> Неопределено Тогда
			Если ОписаниеРеквизита.Значение <> Неопределено Тогда
				СтруктураТипа = мПлатформа.СтруктураТипаИзЗначения(ОписаниеРеквизита.Значение);
			Иначе 
				Типы = ОписаниеРеквизита.ОписаниеТипов.Типы();
				Если Типы.Количество() = 0 Тогда
					Фрагменты = ирОбщий.СтрРазделитьЛкс(РодительскаяСтруктураТипа.Метаданные.ИмяФормы, "::"); 
					Если Истина
						И Фрагменты.Количество() > 1
						И ИмяРеквизита = "Объект" 
					Тогда
						Попытка
							МенеджерОбъекта = ирОбщий.МенеджерВнешнегоОбъектаЛкс(Фрагменты[1]); // Если в модуле внешней обработки, то можно брать РодительскаяСтруктураТипа.ДержательМетаданных
						Исключение
							МенеджерОбъекта = Неопределено;
						КонецПопытки;
						Если МенеджерОбъекта <> Неопределено Тогда
							СтруктураТипа = мПлатформа.СтруктураТипаИзЗначения(МенеджерОбъекта);
						КонецЕсли;
					КонецЕсли;
				КонецЕсли;
				Если СтруктураТипа = Неопределено Тогда
					Если Типы.Количество() = 0 Тогда
						Возврат Неопределено;
					КонецЕсли;
					СтруктураТипа = мПлатформа.СтруктураТипаИзКонкретногоТипа(Типы[0]);
				КонецЕсли;
			КонецЕсли;
		КонецЕсли;
	Иначе
		Возврат Неопределено;
	КонецЕсли;
	Результат = мПлатформа.ДобавитьВТаблицуТипов(, СтруктураТипа);
	Возврат Результат;

КонецФункции

// см. ВычислитьРезультатМетодаШаблон 
Функция ВычислитьДанныеФормыВЗначение(Знач РодительскаяСтруктураТипа, Знач МассивПараметров, Знач Слово = "", Знач ПредшествующийТекст = "", Знач ПозицияВМетоде = 0, Знач ТаблицаТипов = Неопределено, Знач ДляСвойства = "") 
	Если МассивПараметров.Количество() < 2 Тогда
		Возврат Неопределено;
	КонецЕсли;
	ТипЗначения = ВычислитьЗначениеВыражения(МассивПараметров[1], ПредшествующийТекст,,, ПозицияВМетоде);
	Если Не ЗначениеЗаполнено(ТипЗначения) Тогда
		Возврат Неопределено;
	КонецЕсли;      
	Результат = мПлатформа.ДобавитьВТаблицуТипов(, Новый ОписаниеТипов(ирОбщий.ЗначенияВМассивЛкс(ТипЗначения)));
	Возврат Результат;

КонецФункции

// см. ВычислитьРезультатМетодаШаблон 
Функция ВычислитьТип(Знач РодительскаяСтруктураТипа, Знач МассивПараметров, Знач Слово = "", Знач ПредшествующийТекст = "", Знач ПозицияВМетоде = 0, Знач ТаблицаТипов = Неопределено, Знач ДляСвойства = "") 
	Если МассивПараметров.Количество() = 0 Тогда
		Возврат ТаблицаТипов;
	КонецЕсли;
	ИмяТипа = ВычислитьЗначениеВыражения(МассивПараметров[0], ПредшествующийТекст,,, ПозицияВМетоде);
	Если Не ЗначениеЗаполнено(ИмяТипа) Тогда
		Возврат ТаблицаТипов;
	КонецЕсли;
	Попытка
		Тип = Тип(ИмяТипа);
	Исключение
		Возврат ТаблицаТипов;
	КонецПопытки;
	ТаблицаТипов[0].Метаданные = Тип;
	Возврат ТаблицаТипов;

КонецФункции

// см. ВычислитьРезультатМетодаШаблон 
Функция ВычислитьКоллекцияДобавить(Знач РодительскаяСтруктураТипа, Знач МассивПараметров, Знач Слово = "", Знач ПредшествующийТекст = "", Знач ПозицияВМетоде = 0, Знач ТаблицаТипов = Неопределено, Знач ДляСвойства = "") 
	Если МассивПараметров.Количество() = 0 Тогда
		Возврат Неопределено;
	КонецЕсли;
	Если РодительскаяСтруктураТипа.ИмяОбщегоТипа = "ВсеЭлементыФормы" Тогда
		ИндексПараметраТипа = 1;
	Иначе 
		ИндексПараметраТипа = 0;
		Если ирОбщий.СтрокиРавныЛкс(Слово, "Вставить") Тогда
			ИндексПараметраТипа = ИндексПараметраТипа + 1;
		КонецЕсли;
	КонецЕсли; 
	Если МассивПараметров.ВГраница() < ИндексПараметраТипа Тогда
		Возврат Неопределено;
	КонецЕсли;
	ПервыйПараметр = НРег(МассивПараметров[ИндексПараметраТипа]);
	Если Не ирОбщий.СтрНачинаетсяСЛкс(ПервыйПараметр, "Тип(""") Тогда
		Возврат Неопределено;
	КонецЕсли;
	ИмяТипа = ирОбщий.ТекстИзВстроенногоЯзыкаЛкс(ирОбщий.ТекстМеждуМаркерамиЛкс(ПервыйПараметр, "тип(", ")"));
	Попытка
		ТипЭлемента = Тип(ИмяТипа);
	Исключение
		Возврат Неопределено;
	КонецПопытки;
	СтруктураТипа = мПлатформа.СтруктураТипаИзКонкретногоТипа(ТипЭлемента);
	ДобавитьЕдинственныйТип(ТаблицаТипов, СтруктураТипа);
	Возврат ТаблицаТипов;

КонецФункции

// см. ВычислитьРезультатМетодаШаблон 
Функция ВычислитьБлокировкаДанныхДобавить(Знач РодительскаяСтруктураТипа, Знач МассивПараметров, Знач Слово = "", Знач ПредшествующийТекст = "", Знач ПозицияВМетоде = 0, Знач ТаблицаТипов = Неопределено, Знач ДляСвойства = "") 
	Если МассивПараметров.Количество() = 0 Тогда
		Возврат Неопределено;
	КонецЕсли;
	ПервыйПараметр = МассивПараметров[0];
	Пространство = ирОбщий.ТекстМеждуМаркерамиЛкс(ПервыйПараметр, """", """");
	БлокировкаДанных = Новый БлокировкаДанных;
	Попытка
		БлокировкаДанных.Добавить(Пространство);
	Исключение
		Возврат Неопределено;
	КонецПопытки;
	ТаблицаТипов.ЗаполнитьЗначения(БлокировкаДанных, "Метаданные");
	Возврат ТаблицаТипов;

КонецФункции 

// см. ВычислитьРезультатМетодаШаблон 
Функция ВычислитьРезультатЗапросаВыгрузить(Знач РодительскаяСтруктураТипа, Знач МассивПараметров, Знач Слово = "", Знач ПредшествующийТекст = "", Знач ПозицияВМетоде = 0, Знач ТаблицаТипов = Неопределено, Знач ДляСвойства = "") 
	Если МассивПараметров.Количество() = 0 Тогда
		ПервыйПараметр = "";
	Иначе 
		ПервыйПараметр = МассивПараметров[0];
	КонецЕсли;
	Если Ложь
		Или Не ЗначениеЗаполнено(ПервыйПараметр)
		Или ирОбщий.СтрокиРавныЛкс(ПервыйПараметр, "ОбходРезультатаЗапроса.Прямой")
	Тогда
		ИмяОбщегоТипа = "ТаблицаЗначений";
	Иначе 
		ИмяОбщегоТипа = "ДеревоЗначений";
	КонецЕсли;
	СтрокаТипа = ТаблицаТипов.Найти(ИмяОбщегоТипа, "ИмяОбщегоТипа");
	ДобавитьЕдинственныйТип(ТаблицаТипов, СтрокаТипа);
	Возврат ТаблицаТипов;

КонецФункции

// см. ВычислитьРезультатМетодаШаблон 
Функция ВычислитьСкопироватьКолонки(Знач РодительскаяСтруктураТипа, Знач МассивПараметров, Знач Слово = "", Знач ПредшествующийТекст = "", Знач ПозицияВМетоде = 0, Знач ТаблицаТипов = Неопределено, Знач ДляСвойства = "") 
	Если ирОбщий.СтрокиРавныЛкс(Слово, "Скопировать") Тогда
		НомерПараметра = 2;
	Иначе
		НомерПараметра = 1;
	КонецЕсли;
	Если МассивПараметров.Количество() < НомерПараметра Тогда
		Возврат ТаблицаТипов;
	Иначе 
		ВыражениеПараметра = МассивПараметров[НомерПараметра - 1];
	КонецЕсли;
	ИменаКолонок = "";
	Если ЗначениеЗаполнено(ВыражениеПараметра) Тогда
		ИменаКолонок = ВычислитьЗначениеВыражения(ВыражениеПараметра, ПредшествующийТекст,,, ПозицияВМетоде);
	КонецЕсли;
	МетаданныеРодителя = РодительскаяСтруктураТипа.Метаданные;
	СтрукутураТипа = мПлатформа.НоваяСтруктураТипа("ТаблицаЗначений");
	Если ТаблицаТипов.Количество() Тогда
		СтрукутураТипа.СтрокаОписания = ТаблицаТипов[0].СтрокаОписания;
	КонецЕсли;
	Если ТипЗнч(МетаданныеРодителя) = Тип("ТаблицаЗначений") Тогда
		Попытка
			СтрукутураТипа.Метаданные = МетаданныеРодителя.СкопироватьКолонки(ИменаКолонок);
		Исключение
			Возврат ТаблицаТипов;
		КонецПопытки;
	Иначе
		Если ЗначениеЗаполнено(ИменаКолонок) Тогда
			Если ТипЗнч(МетаданныеРодителя) = Тип("ОбъектМетаданных") Тогда
				СтрукутураТипа.Метаданные = мПлатформа.МетаКолонкиФункцииВыгрузитьКолонки(РодительскаяСтруктураТипа, ИменаКолонок);
			Иначе
				Попытка
					СтрукутураТипа.Метаданные = Новый Структура(ИменаКолонок);
				Исключение
					Возврат ТаблицаТипов;
				КонецПопытки;
				Если ТипЗнч(МетаданныеРодителя) = Тип("Структура") Тогда // МетаданныеРодителя может иметь значение null
					ЗаполнитьЗначенияСвойств(СтрукутураТипа.Метаданные, МетаданныеРодителя);
				КонецЕсли;
			КонецЕсли;
		ИначеЕсли ТипЗнч(МетаданныеРодителя) = Тип("Структура") Тогда
			СтрукутураТипа.Метаданные = ирОбщий.СкопироватьКоллекциюЛкс(МетаданныеРодителя);
		КонецЕсли;
	КонецЕсли;
	ДобавитьЕдинственныйТип(ТаблицаТипов, СтрукутураТипа);
	Возврат ТаблицаТипов;

КонецФункции 

// см. ВычислитьРезультатМетодаШаблон 
Функция ВычислитьТаблицаЗначенийВыгрузитьКолонку(Знач РодительскаяСтруктураТипа, Знач МассивПараметров, Знач Слово = "", Знач ПредшествующийТекст = "", Знач ПозицияВМетоде = 0, Знач ТаблицаТипов = Неопределено, Знач ДляСвойства = "") 
	Если Истина
		И ТаблицаТипов.Количество() > 0
		И ТаблицаТипов[0].Метаданные = Неопределено 
		И ТаблицаТипов[0].ДержательМетаданных <> Неопределено 
	Тогда
		Возврат ТаблицаТипов;
	КонецЕсли;
	Если РодительскаяСтруктураТипа.Метаданные <> Неопределено Тогда
		ТаблицаТипов.ЗаполнитьЗначения(РодительскаяСтруктураТипа.Метаданные, "ДержательМетаданных");
	Иначе
		ТаблицаТипов.ЗагрузитьКолонку(ТаблицаТипов.ВыгрузитьКолонку("Метаданные"), "ДержательМетаданных"); // Второй проход все затирает. Поэтому выше отсечка
	КонецЕсли;
	ТаблицаТипов.ЗаполнитьЗначения(Неопределено, "Метаданные"); // СловаКонтекстаПредопределенные() тупо переносит от родителя
	Если Ложь
		Или МассивПараметров.Количество() = 0 
		Или Не ЗначениеЗаполнено(МассивПараметров[0])
	Тогда
		Возврат ТаблицаТипов;
	КонецЕсли; 
	ПервыйПараметр = МассивПараметров[0];
	ИмяКолонки = ВычислитьЗначениеВыражения(ПервыйПараметр, ПредшествующийТекст,,, ПозицияВМетоде);
	Если Истина
		И ТипЗнч(ИмяКолонки) <> Тип("Число") 
		И ТипЗнч(ИмяКолонки) <> Тип("Строка")
	Тогда
		Возврат ТаблицаТипов;
	КонецЕсли;
	Если Истина
		И ТипЗнч(РодительскаяСтруктураТипа.Метаданные) = Тип("Структура") 
		И ТипЗнч(ИмяКолонки) = Тип("Число") 
	Тогда
		// TODO Придумать хранение позиций в структуре
		Возврат ТаблицаТипов;
	КонецЕсли;
	Если ТипЗнч(РодительскаяСтруктураТипа.Метаданные) = Тип("Структура") Тогда 
		ТаблицаТиповЭлемента = ирОбщий.СвойствоСтруктурыЛкс(РодительскаяСтруктураТипа.Метаданные, ИмяКолонки);
	ИначеЕсли ТипЗнч(РодительскаяСтруктураТипа.Метаданные) = Тип("ТаблицаЗначений") Тогда
		Колонки = РодительскаяСтруктураТипа.Метаданные.Колонки;
		Если ТипЗнч(ИмяКолонки) = Тип("Число") И ИмяКолонки >= 0 И ИмяКолонки < Колонки.Количество() Тогда
			Колонка = Колонки[ИмяКолонки];
		Иначе                                        
			Колонка = Колонки.Найти(ИмяКолонки);
		КонецЕсли;
		Если Колонка <> Неопределено Тогда
			ТаблицаТиповЭлемента = мПлатформа.ДобавитьВТаблицуТипов(, Колонка.ТипЗначения);
		КонецЕсли;
	Иначе
		//! РодительскаяСтруктураТипа.Метаданные = 0; // ОбъектМетаданныхТабличнаяЧасть
		Попытка
			Колонка = РодительскаяСтруктураТипа.Метаданные.Реквизиты[ИмяКолонки];
		Исключение
			Колонка = Неопределено;
		КонецПопытки;
		Если Колонка <> Неопределено Тогда
			ТаблицаТиповЭлемента = мПлатформа.ДобавитьВТаблицуТипов(, Колонка.Тип);
		КонецЕсли;
	КонецЕсли;
	Если Не ЗначениеЗаполнено(ТаблицаТиповЭлемента) Тогда
		Возврат ТаблицаТипов;
	КонецЕсли;
	СтруктураТипа = мПлатформа.НоваяСтруктураТипа("Массив");
	СтруктураТипа.Метаданные = ТаблицаТиповЭлемента;
	// Мультиметка240808_112012
	//ИменаТиповЭлементов = Новый СписокЗначений;
	//Для Каждого СтруктураТипаЭлемента Из ТаблицаТиповЭлемента Цикл
	//	ИмяТипаЭлемента = мПлатформа.ИмяТипаИзСтруктурыТипа(СтруктураТипаЭлемента);
	//	Если ИмяТипаЭлемента <> "?" И ИменаТиповЭлементов.НайтиПоЗначению(ИмяТипаЭлемента) = Неопределено Тогда
	//		ИменаТиповЭлементов.Добавить(ИмяТипаЭлемента);
	//	КонецЕсли;
	//КонецЦикла;
	//Если ИменаТиповЭлементов.Количество() > 0 Тогда
	//	ИменаТиповЭлементов.СортироватьПоЗначению();
	//	СтруктураТипа.ИмяОбщегоТипа = СтруктураТипа.ИмяОбщегоТипа + "[" + ирОбщий.СтрСоединитьЛкс(ИменаТиповЭлементов.ВыгрузитьЗначения()) + "]";
	//КонецЕсли;
	Результат = мПлатформа.ДобавитьВТаблицуТипов(, СтруктураТипа);
	Возврат Результат;

КонецФункции  

// см. ВычислитьРезультатМетодаШаблон 
Функция ВычислитьВременныеТаблицыЗапросаНайти(Знач РодительскаяСтруктураТипа, Знач МассивПараметров, Знач Слово = "", Знач ПредшествующийТекст = "", Знач ПозицияВМетоде = 0, Знач ТаблицаТипов = Неопределено, Знач ДляСвойства = "") 
	Если МассивПараметров.Количество() = 0 Тогда
		Возврат Неопределено;
	КонецЕсли;
	ИмяТаблицы = ВычислитьЗначениеВыражения(МассивПараметров[0], ПредшествующийТекст,,, ПозицияВМетоде);
	Если ТипЗнч(ИмяТаблицы) <> Тип("Строка") Тогда
		Возврат Неопределено;
	КонецЕсли;
	ПакетЗапросов = Неопределено;
	ПостроительЗапроса = НайтиЗапросВременнойТаблицы(ИмяТаблицы, РодительскаяСтруктураТипа.Метаданные, ПакетЗапросов);
	ТаблицаТипов[0].Метаданные = ПостроительЗапроса;
	ТаблицаТипов[0].ДержательМетаданных = ПакетЗапросов;
	Возврат ТаблицаТипов;

КонецФункции

// см. ВычислитьРезультатМетодаШаблон 
Функция ВычислитьНайтиЭлементКоллекцииЛкс(Знач РодительскаяСтруктураТипа, Знач МассивПараметров, Знач Слово = "", Знач ПредшествующийТекст = "", Знач ПозицияВМетоде = 0, Знач ТаблицаТипов = Неопределено, Знач ДляСвойства = "") 
	Если МассивПараметров.Количество() = 0 Тогда
		Возврат Неопределено;
	КонецЕсли;
	ТипыКоллекции = ВычислитьТипЗначенияВыражения(МассивПараметров[0],,,,,, Ложь,,,,, ПозицияВМетоде);
	Если ТипыКоллекции.Количество() = 0 Тогда
		Возврат Неопределено;
	КонецЕсли;
	Результат = мПлатформа.ТаблицаТиповЭлементовКоллекции(ТипыКоллекции[0],, мЯзыкПрограммы);
	Возврат Результат;

КонецФункции 

// см. ВычислитьРезультатМетодаШаблон 
Функция ВычислитьОтобратьКоллекциюЛкс(Знач РодительскаяСтруктураТипа, Знач МассивПараметров, Знач Слово = "", Знач ПредшествующийТекст = "", Знач ПозицияВМетоде = 0, Знач ТаблицаТипов = Неопределено, Знач ДляСвойства = "") 
	Если МассивПараметров.Количество() < 1 Тогда
		Возврат Неопределено;
	КонецЕсли;
	ТипыКоллекции = ВычислитьТипЗначенияВыражения(МассивПараметров[0],,,,,, Ложь,,,,, ПозицияВМетоде);  
	Если ТипыКоллекции.Количество() = 0 Тогда
		Возврат Неопределено;
	КонецЕсли;
	Если Истина
		И МассивПараметров.Количество() > 2
		И ЗначениеЗаполнено(МассивПараметров[2])
	Тогда
		// TODO поддержать параметр ПутьКСвойству
		Возврат Неопределено;
	КонецЕсли;
	ТаблицаТиповЭлементов = мПлатформа.ТаблицаТиповЭлементовКоллекции(ТипыКоллекции[0],, мЯзыкПрограммы);
	ИмяОбщегоТипа = "Массив";
	СтруктураТипа = мПлатформа.НоваяСтруктураТипа(ИмяОбщегоТипа);
	СтруктураТипа.Метаданные = ТаблицаТиповЭлементов;
	Результат = мПлатформа.ДобавитьВТаблицуТипов(, СтруктураТипа);
	Возврат Результат;

КонецФункции

// см. ВычислитьРезультатМетодаШаблон 
Функция ВычислитьСкопироватьКолонкиКоллекцииЛкс(Знач РодительскаяСтруктураТипа, Знач МассивПараметров, Знач Слово = "", Знач ПредшествующийТекст = "", Знач ПозицияВМетоде = 0, Знач ТаблицаТипов = Неопределено, Знач ДляСвойства = "") 
	Если МассивПараметров.Количество() < 1 Тогда
		Возврат Неопределено;
	КонецЕсли;
	ТипыКоллекцииИсточника = ВычислитьТипЗначенияВыражения(МассивПараметров[0],,,,,, Ложь,,,,, ПозицияВМетоде);  
	Если ТипыКоллекцииИсточника.Количество() = 0 Тогда
		Возврат Неопределено;
	КонецЕсли;
	ТипыКоллекцииИсточника.Сортировать("Детальность Убыв");
	ИмяОбщегоТипа = ТипыКоллекцииИсточника[0].ИмяОбщегоТипа;
	Если МассивПараметров.Количество() > 1 Тогда
		ТипыКоллекцииПриемника = ВычислитьТипЗначенияВыражения(МассивПараметров[1],,,,,, Ложь,,,,, ПозицияВМетоде);  
		ЛучшийТип = ЛучшийТипИзТаблицыТипов(ТипыКоллекцииПриемника);
		Если ЛучшийТип <> Неопределено Тогда
			ИмяОбщегоТипа = ЛучшийТип.ИмяОбщегоТипа;
		КонецЕсли;
	КонецЕсли;  
	СтруктураТипа = мПлатформа.НоваяСтруктураТипа(ИмяОбщегоТипа);
	ЗаполнитьЗначенияСвойств(СтруктураТипа, ТипыКоллекцииИсточника[0],, "ИмяОбщегоТипа");
	Результат = мПлатформа.ДобавитьВТаблицуТипов(ТипыКоллекцииПриемника, СтруктураТипа);
	Возврат Результат;
КонецФункции

// см. ВычислитьРезультатМетодаШаблон 
Функция ВычислитьСоздатьОбъектПоИмениМетаданныхЛкс(Знач РодительскаяСтруктураТипа, Знач МассивПараметров, Знач Слово = "", Знач ПредшествующийТекст = "", Знач ПозицияВМетоде = 0, Знач ТаблицаТипов = Неопределено, Знач ДляСвойства = "") 
	Если МассивПараметров.Количество() = 0 Тогда
		Возврат Неопределено;
	КонецЕсли;
	Текст = ВычислитьЗначениеВыражения(МассивПараметров[0], ПредшествующийТекст,,, ПозицияВМетоде);
	Попытка
		ИмяТипа = ирОбщий.ИмяТипаИзПолногоИмениМДЛкс(Текст, "Объект");
		ОписаниеТипов = Новый ОписаниеТипов(ИмяТипа);
	Исключение
		Возврат Неопределено;
	КонецПопытки;
	Результат = мПлатформа.ДобавитьВТаблицуТипов(, ОписаниеТипов);
	Возврат Результат;

КонецФункции

// см. ВычислитьРезультатМетодаШаблон 
Функция ВычислитьВычислить(Знач РодительскаяСтруктураТипа, Знач МассивПараметров, Знач Слово = "", Знач ПредшествующийТекст = "", Знач ПозицияВМетоде = 0, Знач ТаблицаТипов = Неопределено, Знач ДляСвойства = "") 
	Если МассивПараметров.Количество() = 0 Тогда
		Возврат Неопределено;
	КонецЕсли;
	Текст = ВычислитьЗначениеВыражения(МассивПараметров[0], ПредшествующийТекст,,, ПозицияВМетоде);
	Если Ложь
		Или ТипЗнч(Текст) <> Тип("Строка") 
		Или Найти(Текст, "(") > 0
	Тогда
		Возврат Неопределено;
	КонецЕсли;
	Попытка
		Значение = Вычислить(Текст);
	Исключение
		Возврат Неопределено;
	КонецПопытки;
	СтруктураТипа = мПлатформа.СтруктураТипаИзЗначения(Значение);
	Если СтруктураТипа.ИмяОбщегоТипа = "ОбщийМодуль" Тогда
		СтруктураТипа.Метаданные = Метаданные.ОбщиеМодули.Найти(Текст);
	КонецЕсли;
	Результат = мПлатформа.ДобавитьВТаблицуТипов(, СтруктураТипа);
	Возврат Результат;

КонецФункции 

// см. ВычислитьРезультатМетодаШаблон 
Функция ВычислитьПоместитьВоВременноеХранилище(Знач РодительскаяСтруктураТипа, Знач МассивПараметров, Знач Слово = "", Знач ПредшествующийТекст = "", Знач ПозицияВМетоде = 0, Знач ТаблицаТипов = Неопределено, Знач ДляСвойства = "") 
	Если МассивПараметров.Количество() = 0 Тогда
		Возврат Неопределено;
	КонецЕсли;
	ТипыСодержимого = ВычислитьТипЗначенияВыражения(МассивПараметров[0],,,,,, Ложь,,,,, ПозицияВМетоде);  
	Если ТипыСодержимого.Количество() = 0 Тогда
		Возврат Неопределено;
	КонецЕсли;
	// Возможно нужно делать таблицу типов
	ТаблицаТипов[0].Метаданные = ТипыСодержимого; // Чтобы эти метаданные сохранялись, делаем тут Мультиметка62766134
	мПлатформа.ОбновитьДетальностьСтруктурыТипа(ТаблицаТипов[0]);
	Возврат ТаблицаТипов;
КонецФункции  

// см. ВычислитьРезультатМетодаШаблон 
Функция ВычислитьПолучитьИзВременногоХранилища(Знач РодительскаяСтруктураТипа, Знач МассивПараметров, Знач Слово = "", Знач ПредшествующийТекст = "", Знач ПозицияВМетоде = 0, Знач ТаблицаТипов = Неопределено, Знач ДляСвойства = "") 
	Если МассивПараметров.Количество() = 0 Тогда
		Возврат Неопределено;
	КонецЕсли;
	ТипыУказателя = ВычислитьТипЗначенияВыражения(МассивПараметров[0],,,,,, Ложь,,,,, ПозицияВМетоде,, ДляСвойства);  
	Если ТипыУказателя.Количество() = 0 Тогда
		Возврат Неопределено;
	КонецЕсли; 
	ТипыСодержимого = ТипыУказателя[0].Метаданные; 
	Если ТипЗнч(ТипыСодержимого) <> Тип("ТаблицаЗначений") Тогда
		Возврат Неопределено;
	КонецЕсли;
	Возврат ТипыСодержимого;
КонецФункции  

// см. ВычислитьРезультатМетодаШаблон 
Функция ВычислитьНеизменяющаяСтроковаяФункция(Знач РодительскаяСтруктураТипа, Знач МассивПараметров, Знач Слово = "", Знач ПредшествующийТекст = "", Знач ПозицияВМетоде = 0, Знач ТаблицаТипов = Неопределено, Знач ДляСвойства = "") 
	Если МассивПараметров.Количество() = 0 Тогда
		Возврат Неопределено;
	КонецЕсли;
	Возврат ВычислитьТипЗначенияВыражения(МассивПараметров[0],,,,,, Ложь,,, Истина,, ПозицияВМетоде);  

КонецФункции 

// см. ВычислитьРезультатМетодаШаблон 
Функция ВычислитьОператорВыбора(Знач РодительскаяСтруктураТипа, Знач МассивПараметров, Знач Слово = "", Знач ПредшествующийТекст = "", Знач ПозицияВМетоде = 0, Знач ТаблицаТипов = Неопределено, Знач ДляСвойства = "") 
	Если МассивПараметров.Количество() < 2 Тогда
		Возврат Неопределено;
	КонецЕсли;
	Результат = Неопределено;
	Для Счетчик = 1 По Мин(2, МассивПараметров.ВГраница()) Цикл
		мПлатформа.ДобавитьВТаблицуТипов(Результат, ВычислитьТипЗначенияВыражения(МассивПараметров[Счетчик], ПредшествующийТекст, ПредшествующийТекст,,,, Ложь,,,,, ПозицияВМетоде));
	КонецЦикла;
	Возврат Результат;

КонецФункции  

// см. ВычислитьРезультатМетодаШаблон 
Функция ВычислитьПредопределенноеЗначение(Знач РодительскаяСтруктураТипа, Знач МассивПараметров, Знач Слово = "", Знач ПредшествующийТекст = "", Знач ПозицияВМетоде = 0, Знач ТаблицаТипов = Неопределено, Знач ДляСвойства = "") 
	Если МассивПараметров.Количество() = 0 Тогда
		Возврат Неопределено;
	КонецЕсли;
	ПервыйПараметр = МассивПараметров[0];
	Текст = ВычислитьЗначениеВыражения(ПервыйПараметр, ПредшествующийТекст,,, ПозицияВМетоде);
	Попытка
		Значение = ПредопределенноеЗначение(Текст);
	Исключение
		Возврат Неопределено;
	КонецПопытки;
	СтруктураТипа = мПлатформа.СтруктураТипаИзЗначения(Значение);
	Результат = мПлатформа.ДобавитьВТаблицуТипов(, СтруктураТипа);
	Возврат Результат;

КонецФункции

// см. ВычислитьРезультатМетодаШаблон 
Функция ВычислитьОбщийМодуль(Знач РодительскаяСтруктураТипа, Знач МассивПараметров, Знач Слово = "", Знач ПредшествующийТекст = "", Знач ПозицияВМетоде = 0, Знач ТаблицаТипов = Неопределено, Знач ДляСвойства = "") 
	Если МассивПараметров.Количество() = 0 Тогда
		Возврат Неопределено;
	КонецЕсли;
	ПервыйПараметр = МассивПараметров[0];
	ИмяМодуля = ВычислитьЗначениеВыражения(ПервыйПараметр, ПредшествующийТекст,,, ПозицияВМетоде);
	ОбъектМД = Метаданные.ОбщиеМодули.Найти(ИмяМодуля);
	Если ОбъектМД = Неопределено Тогда
		Возврат Неопределено;
	КонецЕсли;
	СтруктураТипа = мПлатформа.СтруктураТипаИзКонкретногоТипа(Тип("ОбщийМодуль"));
	СтруктураТипа.Метаданные = ОбъектМД;
	Результат = мПлатформа.ДобавитьВТаблицуТипов(, СтруктураТипа);
	Возврат Результат;

КонецФункции

// см. ВычислитьРезультатМетодаШаблон 
Функция ВычислитьМакетПечатнойФормыБСП(Знач РодительскаяСтруктураТипа, Знач МассивПараметров, Знач Слово = "", Знач ПредшествующийТекст = "", Знач ПозицияВМетоде = 0, Знач ТаблицаТипов = Неопределено, Знач ДляСвойства = "") 
	Если МассивПараметров.Количество() = 0 Тогда
		Возврат Неопределено;
	КонецЕсли;
	ПервыйПараметр = МассивПараметров[0];
	ИмяМакета = ВычислитьЗначениеВыражения(ПервыйПараметр, ПредшествующийТекст,,, ПозицияВМетоде);
	Попытка
		Макет = ирСервер.ВычислитьВыражение("УправлениеПечатью.МакетПечатнойФормы(""" + ИмяМакета + """)");
	Исключение
		Макет = Неопределено;
	КонецПопытки;
	Если Макет = Неопределено Тогда
		Возврат Неопределено;
	КонецЕсли;
	СтруктураТипа = мПлатформа.СтруктураТипаИзЗначения(Макет);
	Результат = мПлатформа.ДобавитьВТаблицуТипов(, СтруктураТипа);
	Возврат Результат;

КонецФункции

// см. ВычислитьРезультатМетодаШаблон 
Функция ВычислитьЗначенияРеквизитовОбъектаБСП(Знач РодительскаяСтруктураТипа, Знач МассивПараметров, Знач Слово = "", Знач ПредшествующийТекст = "", Знач ПозицияВМетоде = 0, Знач ТаблицаТипов = Неопределено, Знач ДляСвойства = "") 
	Если МассивПараметров.Количество() < 2 Тогда
		Возврат Неопределено;
	КонецЕсли;
	// TODO Сделать вычисление значений элементов структуры
	ТаблицаТиповРеквизитов = ВычислитьТипЗначенияВыражения(МассивПараметров[1], ПредшествующийТекст, ПредшествующийТекст,,,, Ложь,,, Истина,, ПозицияВМетоде);
	ИменаРеквизитов = "";
	Если ТаблицаТиповРеквизитов.Количество() > 0 Тогда
		СтруктураТипаРеквизитов = ТаблицаТиповРеквизитов[0];
		ТипЗначения = ТипЗнч(СтруктураТипаРеквизитов.Метаданные); 
		Если ТипЗначения = Тип("Строка") Тогда
			ИменаРеквизитов = СтруктураТипаРеквизитов.Метаданные;
			Попытка
				Структура = Новый Структура(ИменаРеквизитов);
			Исключение
				Структура = Неопределено;
			КонецПопытки;
		ИначеЕсли ТипЗначения = Тип("Структура") Тогда
			Структура = СтруктураТипаРеквизитов.Метаданные;
		Иначе
			Возврат Неопределено;
		КонецЕсли;
	КонецЕсли;
	ЛиОдинОбъект = Истина;
	ТипыСсылки = ВычислитьТипЗначенияВыражения(МассивПараметров[0], ПредшествующийТекст,,,,, Ложь,,,,, ПозицияВМетоде);
	Если Истина
		И ТипыСсылки.Количество() > 0 
		И ТипыСсылки[0].ИмяОбщегоТипа = "Массив"
	Тогда
		ЛиОдинОбъект = Ложь;
		ТипыСсылки = ТипыСсылки[0].Метаданные;
	КонецЕсли;
	СтруктураТипа = Неопределено;
	Если Истина
		И ЗначениеЗаполнено(ИменаРеквизитов)
		И ЗначениеЗаполнено(ТипыСсылки) 
		И ТипЗнч(ТипыСсылки[0].Метаданные) = Тип("ОбъектМетаданных") 
	Тогда
		ИмяТаблицыБД = ирКэш.ИмяТаблицыИзМетаданныхЛкс(ТипыСсылки[0].Метаданные.ПолноеИмя());
		Попытка
			ТаблицаРезультата = ирОбщий.ПустаяТаблицаЗначенийИзТекстаЗапросаЛкс("ВЫБРАТЬ ПЕРВЫЕ 0 Т." + ИменаРеквизитов + " ИЗ " + ИмяТаблицыБД + " КАК Т",,, Ложь); // Мультиметка81792365
		Исключение
			ТаблицаРезультата = Неопределено;
		КонецПопытки;
		Если ТаблицаРезультата <> Неопределено Тогда
			СтруктураТипа = мПлатформа.НоваяСтруктураТипа("Структура");
			Структура = Новый Структура;
			СтруктураТипа.Метаданные = Структура;
			Для Каждого Колонка Из ТаблицаРезультата.Колонки Цикл
				Структура.Вставить(Колонка.Имя, мПлатформа.ТаблицаТиповИзОписанияТипов(Колонка.ТипЗначения));
			КонецЦикла;
		КонецЕсли;
	КонецЕсли;
	Если СтруктураТипа = Неопределено Тогда
		СтруктураТипа = мПлатформа.СтруктураТипаИзЗначения(Структура);
	КонецЕсли;
	Если СтруктураТипа <> Неопределено Тогда
		Результат = мПлатформа.ДобавитьВТаблицуТипов(, СтруктураТипа);
	КонецЕсли;
	Если Не ЛиОдинОбъект Тогда
		СтруктураТипа = НоваяСтруктураТипа("Соответствие");
		СтруктураТипа.Метаданные = Новый Структура("Ключ, Значение", ТипыСсылки, Результат);
		Результат = мПлатформа.ДобавитьВТаблицуТипов(, СтруктураТипа);
	КонецЕсли;
	Возврат Результат;
КонецФункции 

// см. ВычислитьРезультатМетодаШаблон 
Функция ВычислитьЗначениеРеквизитаОбъектаБСП(Знач РодительскаяСтруктураТипа, Знач МассивПараметров, Знач Слово = "", Знач ПредшествующийТекст = "", Знач ПозицияВМетоде = 0, Знач ТаблицаТипов = Неопределено, Знач ДляСвойства = "") 
	Если МассивПараметров.Количество() < 2 Тогда
		Возврат Неопределено;
	КонецЕсли;
	ИмяРеквизита = ВычислитьЗначениеВыражения(МассивПараметров[1], ПредшествующийТекст,,, ПозицияВМетоде);
	Если ТипЗнч(ИмяРеквизита) <> Тип("Строка") Тогда
		Возврат Неопределено;
	КонецЕсли;
	Попытка
		Структура = Новый Структура(ИмяРеквизита);
	Исключение
		Возврат Неопределено;
	КонецПопытки;
	ТипыСсылки = ВычислитьТипЗначенияВыражения(МассивПараметров[0], ПредшествующийТекст,,,,, Ложь,,,,, ПозицияВМетоде);
	Если ТипыСсылки.Количество() = 0 Тогда
		Возврат Неопределено;
	КонецЕсли;
	Для Каждого СтрокаТипа Из ТипыСсылки Цикл
		Если ТипЗнч(СтрокаТипа.Метаданные) = Тип("ОбъектМетаданных") Тогда
			ТипСсылки = ирОбщий.ИмяТипаИзПолногоИмениМДЛкс(СтрокаТипа.Метаданные.ПолноеИмя());
			Попытка
				ПустаяСсылка = Новый (ТипСсылки);
				ЗначениеРеквизита = ПустаяСсылка[ИмяРеквизита];
				Прервать;
			Исключение
			КонецПопытки;
		КонецЕсли;
	КонецЦикла;
	СтруктураТипа = мПлатформа.СтруктураТипаИзЗначения(ЗначениеРеквизита);
	Результат = мПлатформа.ДобавитьВТаблицуТипов(, СтруктураТипа);
	Возврат Результат;

КонецФункции

// см. ВычислитьРезультатМетодаШаблон 
Функция ВычислитьСтрокаТаблицыЗначенийВСтруктуруБСП(Знач РодительскаяСтруктураТипа, Знач МассивПараметров, Знач Слово = "", Знач ПредшествующийТекст = "", Знач ПозицияВМетоде = 0, Знач ТаблицаТипов = Неопределено, Знач ДляСвойства = "") 
	Если МассивПараметров.Количество() < 1 Тогда
		Возврат Неопределено;
	КонецЕсли;
	ТаблицаТипов = ВычислитьТипЗначенияВыражения(МассивПараметров[0], ПредшествующийТекст,,,,, Ложь,,,,, ПозицияВМетоде);
	Если ТаблицаТипов.Количество() = 0 Тогда
		Возврат Неопределено;
	КонецЕсли;
	ПараметрыЗаполнения = мПлатформа.НовыеПараметрыЗаполненияСлов("Свойство", БазовоеРасширениеКонфигурации(),,,, Ложь);
	ЛучшийТип = ЛучшийТипИзТаблицыТипов(ТаблицаТипов);
	ТаблицаСвойств = мПлатформа.ТаблицаСловИзСтруктурыТипа(ЛучшийТип, ПараметрыЗаполнения);
	Структура = новый Структура;
	Для Каждого СтрокаСвойства Из ТаблицаСвойств Цикл
		Структура.Вставить(СтрокаСвойства.Слово, СтрокаСвойства.ТаблицаТипов);
	КонецЦикла;
	СтруктураТипа = мПлатформа.СтруктураТипаИзЗначения(Структура);
	Результат = мПлатформа.ДобавитьВТаблицуТипов(, СтруктураТипа);
	Возврат Результат;
КонецФункции

// см. ВычислитьРезультатМетодаШаблон 
Функция ВычислитьТаблицаЗначенийВМассивБСП(Знач РодительскаяСтруктураТипа, Знач МассивПараметров, Знач Слово = "", Знач ПредшествующийТекст = "", Знач ПозицияВМетоде = 0, Знач ТаблицаТипов = Неопределено, Знач ДляСвойства = "") 
	Если МассивПараметров.Количество() < 1 Тогда
		Возврат Неопределено;
	КонецЕсли;
	СтруктураТипа = мПлатформа.НоваяСтруктураТипа("Массив");
	СтруктураТипа.Метаданные = ВычислитьСтрокаТаблицыЗначенийВСтруктуруБСП(РодительскаяСтруктураТипа, ирОбщий.ЗначенияВМассивЛкс(МассивПараметров[0] + "[0]"));
	Результат = мПлатформа.ДобавитьВТаблицуТипов(, СтруктураТипа);
	Возврат Результат;
КонецФункции

// см. ВычислитьРезультатМетодаШаблон 
Функция ВычислитьВнешниеОбъектыСоздать(Знач РодительскаяСтруктураТипа, Знач МассивПараметров, Знач Слово = "", Знач ПредшествующийТекст = "", Знач ПозицияВМетоде = 0, Знач ТаблицаТипов = Неопределено, Знач ДляСвойства = "") 
	Если МассивПараметров.Количество() < 1 Тогда
		Возврат Неопределено;
	КонецЕсли;
	ИмяФайла = ВычислитьЗначениеВыражения(МассивПараметров[0], ПредшествующийТекст,,, ПозицияВМетоде);
	Если Не ЗначениеЗаполнено(ИмяФайла) Тогда
		Возврат Неопределено;
	КонецЕсли; 
	Попытка
		ВнешнийОбъект = ирОбщий.МенеджерВнешнегоОбъектаЛкс(ИмяФайла);
	Исключение
		Возврат Неопределено;
	КонецПопытки;
	СтруктураТипа = мПлатформа.СтруктураТипаИзЗначения(ВнешнийОбъект);
	Результат = мПлатформа.ДобавитьВТаблицуТипов(, СтруктураТипа);
	Возврат Результат;

КонецФункции    

// см. ВычислитьРезультатМетодаШаблон 
Функция ВычислитьФункцияКопированияПараметра(Знач РодительскаяСтруктураТипа, Знач МассивПараметров, Знач Слово = "", Знач ПредшествующийТекст = "", Знач ПозицияВМетоде = 0, Знач ТаблицаТипов = Неопределено, Знач ДляСвойства = "") 
	Если МассивПараметров.Количество() < 1 Тогда
		Возврат Неопределено;
	КонецЕсли;
	ТаблицаТипов = ВычислитьТипЗначенияВыражения(МассивПараметров[0], ПредшествующийТекст,,,,, Ложь,,,,, ПозицияВМетоде);
	Если ТаблицаТипов.Количество() = 0 Тогда
		Возврат Неопределено;
	КонецЕсли;
	Результат = мПлатформа.ДобавитьВТаблицуТипов(, ТаблицаТипов);
	Возврат Результат;

КонецФункции

// см. ВычислитьРезультатМетодаШаблон 
Функция ВычислитьТаблицаЗначенийИзТабличногоДокументаЛкс(Знач РодительскаяСтруктураТипа, Знач МассивПараметров, Знач Слово = "", Знач ПредшествующийТекст = "", Знач ПозицияВМетоде = 0, Знач ТаблицаТипов = Неопределено, Знач ДляСвойства = "") 
	Если МассивПараметров.Количество() = 0 Тогда
		Возврат Неопределено;
	КонецЕсли;
	ТабличныйДокумент = ВычислитьЗначениеВыражения(МассивПараметров[0], ПредшествующийТекст,,, ПозицияВМетоде); // ТабличныйДокумент
	Если ТабличныйДокумент = Неопределено Тогда
		Возврат Неопределено;
	КонецЕсли;
	ТабличныйДокумент = ТабличныйДокумент.ПолучитьОбласть(1,,1);
	Если МассивПараметров.Количество() > 1 И ЗначениеЗаполнено(МассивПараметров[1]) Тогда
		ЛиПерваяСтрокаСодержитИменаКолонок = ВычислитьЗначениеВыражения(МассивПараметров[1], ПредшествующийТекст,,, ПозицияВМетоде);
	КонецЕсли;
	Если ЛиПерваяСтрокаСодержитИменаКолонок = Неопределено Тогда
		ЛиПерваяСтрокаСодержитИменаКолонок = Истина;
	КонецЕсли;
	Попытка
		ТаблицаЗначений = ирОбщий.ТаблицаЗначенийИзТабличногоДокументаЛкс(ТабличныйДокумент, ЛиПерваяСтрокаСодержитИменаКолонок);
	Исключение
		Возврат Неопределено;
	КонецПопытки;      
	СтруктураТипа = мПлатформа.СтруктураТипаИзЗначения(ТаблицаЗначений);
	//СтруктураТипа.СтрокаОписания = ТаблицаТипов[0].СтрокаОписания;
	Результат = мПлатформа.ДобавитьВТаблицуТипов(, СтруктураТипа);
	Возврат Результат;

КонецФункции

// см. ВычислитьРезультатМетодаШаблон 
Функция ВычислитьНоваяТаблицаЗначенийЛкс(Знач РодительскаяСтруктураТипа, Знач МассивПараметров, Знач Слово = "", Знач ПредшествующийТекст = "", Знач ПозицияВМетоде = 0, Знач ТаблицаТипов = Неопределено, Знач ДляСвойства = "") 
	Если МассивПараметров.Количество() < 1 Тогда
		Возврат Неопределено;
	КонецЕсли;
	ИменаКолонок = ВычислитьЗначениеВыражения(МассивПараметров[0], ПредшествующийТекст,,, ПозицияВМетоде);
	Если ТипЗнч(ИменаКолонок) <> Тип("Строка") Тогда
		Возврат Неопределено;
	КонецЕсли;
	Попытка
		ТаблицаЗначений = ирОбщий.НоваяТаблицаЗначенийЛкс(ИменаКолонок); // Натуральное вычисление
	Исключение
		Возврат Неопределено;
	КонецПопытки;
	СтруктураТипа = мПлатформа.СтруктураТипаИзЗначения(ТаблицаЗначений);
	Результат = мПлатформа.ДобавитьВТаблицуТипов(, СтруктураТипа);
	Возврат Результат;

КонецФункции

// см. ВычислитьРезультатМетодаШаблон 
Функция ВычислитьНайтиРегВыражениеЛкс(Знач РодительскаяСтруктураТипа, Знач МассивПараметров, Знач Слово = "", Знач ПредшествующийТекст = "", Знач ПозицияВМетоде = 0, Знач ТаблицаТипов = Неопределено, Знач ДляСвойства = "") 
	Если МассивПараметров.Количество() < 3 Тогда
		Возврат ТаблицаТипов;
	КонецЕсли;
	ИменаКолонок = ВычислитьЗначениеВыражения(МассивПараметров[2], ПредшествующийТекст,,, ПозицияВМетоде);
	Если Ложь
		Или ТипЗнч(ИменаКолонок) <> Тип("Строка") 
		Или ПустаяСтрока(ИменаКолонок)
	Тогда
		Возврат ТаблицаТипов;
	КонецЕсли;
	Попытка
		ТаблицаЗначений = ирОбщий.НайтиРегВыражениеЛкс("", "_", ИменаКолонок, Ложь);
	Исключение
		Возврат ТаблицаТипов;
	КонецПопытки;
	СтруктураТипа = мПлатформа.СтруктураТипаИзЗначения(ТаблицаЗначений);
	Результат = мПлатформа.ДобавитьВТаблицуТипов(ТаблицаТипов, СтруктураТипа);
	Возврат Результат;

КонецФункции

//.
// Параметры:
//    РодительскаяСтруктураТипа - см. мПлатформа.НоваяСтруктураТипа()  -  
// Возвращаемое значение:
//     - 
Функция ЛиПодробнаяСтруктураТипаУпрФормы(РодительскаяСтруктураТипа) Экспорт
	Результат = Истина
		И ирОбщий.ЛиИмяТипаФормыЛкс(РодительскаяСтруктураТипа.ИмяОбщегоТипа) 
		И ирОбщий.ЛиФормаИлиИмитаторЛкс(РодительскаяСтруктураТипа.Метаданные, Ложь);
	Возврат Результат;
КонецФункции

// Добавляет переменную локального контекста.
//
// Параметры:
//  ИмяПеременной - Строка;
//  ДопустимыеТипы - Строка, ТаблицаЗначений;
//
Процедура ДобавитьПеременнуюЛокальногоКонтекста(ИмяПеременной, ДопустимыеТипы) Экспорт

	НоваяСтрока = ДобавитьСловоЛокальногоКонтекста(ИмяПеременной);
	Если ТипЗнч(ДопустимыеТипы) = Тип("Строка") Тогда 
		МассивСериализованныхТипов = ирОбщий.СтрРазделитьЛкс(ДопустимыеТипы, ";");
		ТаблицаТипов = НоваяСтрока.ТаблицаТипов;
		Для Каждого СериализованныйТип Из МассивСериализованныхТипов Цикл
			СтруктураТипа = мПлатформа.СтруктураТипаИзСтрокиВнутр(СериализованныйТип);
			СтруктураТипа.Вставить("СтрокаОписания", НоваяСтрока); // Циклическая ссылка СтрокаОписания
			мПлатформа.ДобавитьВТаблицуТипов(ТаблицаТипов, СтруктураТипа);
		КонецЦикла;
		НоваяСтрока.ТаблицаТипов = ТаблицаТипов;
	Иначе
		НоваяСтрока.ТаблицаТипов = ДопустимыеТипы;
	КонецЕсли; 

КонецПроцедуры

// Удаляет слово локального контекста.
//
// Параметры:
//  Слово        - Строка;
//  ТипСлова     - Строка.
//
Процедура УдалитьСловоЛокальногоКонтекста(Слово, ТипСлова) Экспорт

	КлючСтроки = Новый Структура;
	КлючСтроки.Вставить("нИмя", НРег(Слово));
	СтрокиСлова = ТаблицаЛокальногоКонтекста(ТипСлова).НайтиСтроки(КлючСтроки);
	Если СтрокиСлова.Количество() > 0 Тогда
		СтрокиСлова[0].Владелец().Удалить(СтрокиСлова[0]);
	КонецЕсли;

КонецПроцедуры

// Устанавливает доступность действий, изменяющих данные.
//
// Параметры:
//  НовыйТолькоПросмотр - Булево.
//
Процедура УстановитьТолькоПросмотр(НовыйТолькоПросмотр) Экспорт 

	ФормаКласса = ПолучитьФорму("ФормаМакет");
	КоманднаяПанельЛ = ФормаКласса.ЭлементыФормы["КоманднаяПанель" + Формат(ЯзыкПрограммы, "ЧН=")]; // КоманднаяПанель
	МассивКоллекцийКнопок = Новый Массив;
	МассивКоллекцийКнопок.Добавить(КоманднаяПанельЛ.Кнопки);
	МассивКоллекцийКнопок.Добавить(ФормаКласса.ЭлементыФормы.КоманднаяПанельОбщая.Кнопки);
	Для Каждого КнопкиМакета Из МассивКоллекцийКнопок Цикл
		Для Каждого КнопкаМакета Из КнопкиМакета Цикл
			Если КнопкаМакета.ТипКнопки <> ТипКнопкиКоманднойПанели.Действие Тогда 
				Продолжить;
			КонецЕсли;
			КонечноеИмя = ирКлиент.СформироватьИмяЭлементаУправленияЭкземпляраЛкс(ЭтотОбъект, КнопкаМакета.Имя);
			Кнопка = КоманднаяПанель.Кнопки.Найти(КонечноеИмя);
			Если Кнопка.ИзменяетДанные Тогда 
				Кнопка.Доступность = Не НовыйТолькоПросмотр;
			КонецЕсли;
		КонецЦикла;
	КонецЦикла;
	
КонецПроцедуры

Процедура ОформитьЯчейкуТипаЗначения(ОформлениеСтроки, ДанныеСтроки) Экспорт 
	
	Если Истина
		И ОформлениеСтроки.Ячейки.ТипЗначения.Видимость 
		И ЗначениеЗаполнено(ДанныеСтроки.ТипЗначения) 
		//И Найти(ДанныеСтроки.ТипЗначения, ",") = 0
	Тогда
		СтрокаИменТипов = ирОбщий.ПервыйФрагментЛкс(ДанныеСтроки.ТипЗначения, "[");
		мРегВыражение = ирКэш.ВычислительРегВыраженийЛкс();
		#Если Сервер И Не Сервер Тогда
			мРегВыражение = Обработки.ирОболочкаРегВыражение.Создать();
		#КонецЕсли
		мРегВыражение.Global = Истина;
		мРегВыражение.Pattern = "\(.*?\)";
		СтрокаИменТипов = мРегВыражение.Заменить(СтрокаИменТипов, "");
		Попытка
			ОписаниеТипов = Новый ОписаниеТипов(СтрокаИменТипов);
		Исключение
			ОписаниеТипов = Неопределено;
		КонецПопытки; 
		Если ОписаниеТипов <> Неопределено Тогда
			Типы = ОписаниеТипов.Типы();
			Если Типы.Количество() > 0 Тогда
				КартинкаТипа = ирКлиент.КартинкаТипаЛкс(Типы[0]);
				Если КартинкаТипа <> Неопределено Тогда
					ОформлениеСтроки.Ячейки.ТипЗначения.УстановитьКартинку(КартинкаТипа);
				КонецЕсли; 
			КонецЕсли; 
		КонецЕсли; 
	КонецЕсли;

КонецПроцедуры

// Выполняет шаблон текста.
//
// Параметры:
//  Нет.
//
Процедура ВыполнитьШаблонТекста()
	
	Если ПолеТекста.ТолькоПросмотр() Тогда
		Возврат;
	КонецЕсли; 
	#Если Сервер И Не Сервер Тогда
		мПлатформа = Обработки.ирПлатформа.Создать();
	#КонецЕсли
	ПрочитатьНачалоИКонецТекущейСтроки();
	//РазобратьКонтекстСтроки();
	ТаблицаШаблоновТекста = мПлатформа.ПолучитьТаблицуШаблоновТекста(ИмяКласса);
	ТекстШаблона = "";
	Если Не ЗначениеЗаполнено(ТаблицаШаблоновТекста) Тогда
		//
	Иначе
		мРегВыражение.Global = Ложь; 
		СтрокаРазделителейШаблоновТекста = ";.,:()[]";
		мРегВыражение.Pattern = "([^\s" + ирОбщий.ТекстДляРегВыраженияЛкс(СтрокаРазделителейШаблоновТекста) + "]*)$";
		Результат = мРегВыражение.НайтиВхождения(мТекущаяСтрокаНачало);
		Если Результат.Количество() > 0 Тогда
			НачалоМаркера = Результат[0].SubMatches(0);
			Если ЗначениеЗаполнено(НачалоМаркера) Тогда
				//СтрокаШаблона = ТаблицаШаблоновТекста.Найти(НРег(НачалоМаркера), "ШаблонБезКвадратныхСкобок");
				СтрокаШаблона = Неопределено;
				Для каждого ТекСтрокаШаблона Из ТаблицаШаблоновТекста Цикл
					Если ТекСтрокаШаблона.Шаблон = НРег(НачалоМаркера) Тогда
						СтрокаШаблона = ТекСтрокаШаблона;
						Прервать;
					КонецЕсли;
					МинимальнаяДлинаСовпадения = Найти(ТекСтрокаШаблона.Шаблон, "[");
					Если МинимальнаяДлинаСовпадения > 0 Тогда
						Если СтрДлина(НачалоМаркера) < МинимальнаяДлинаСовпадения - 1 Тогда
							Продолжить;
						КонецЕсли; 
						ШаблонБезСкобок = СтрЗаменить(ТекСтрокаШаблона.Шаблон, "[", "");
						ШаблонБезСкобок = СтрЗаменить(ШаблонБезСкобок, "]", "");
						Если Найти(ШаблонБезСкобок, НРег(НачалоМаркера)) = 1 Тогда
							СтрокаШаблона = ТекСтрокаШаблона;
							Прервать;
						КонецЕсли;
					КонецЕсли; 
				КонецЦикла;
				Если СтрокаШаблона = Неопределено Тогда
					НачалоМаркера = "";
				Иначе    
					ТекстШаблона = СтрокаШаблона.Замена;
				КонецЕсли; 
			КонецЕсли; 
		КонецЕсли; 
	КонецЕсли;
	Если ЗначениеЗаполнено(ТекстШаблона) Тогда
		ВставитьУказанныйШаблон(ТекстШаблона, НачалоМаркера);
		УстановитьФокус();
	КонецЕсли;

КонецПроцедуры

Процедура ВставитьУказанныйШаблон(Знач ТекстШаблона, Знач НачалоМаркера) Экспорт
	//НадежноУстановитьФокус = Ложь;
	ПоследняяПозицияКурсора = 0;
	КонечныйТекстЗамены = "";
	Если ЗначениеЗаполнено(ТекстШаблона) Тогда
		мРегВыражение.Global = Истина;
		мРегВыражение.MultiLine = Ложь;
		мРегВыражение.Pattern = "(<\?\s*(""[^""\^]*"")?(?:,\s*(" + мПлатформа.шИмя + "))?>)|(.|\r|\n)";
		Результат = мРегВыражение.НайтиВхождения(ТекстШаблона);
		КешПараметров = ирОбщий.НоваяТаблицаЗначенийЛкс("ИмяПараметра, ЗначениеПараметра");
		Для Каждого Match Из Результат Цикл
			УправляющаяКонструкция = Match.SubMatches(0);
			Если УправляющаяКонструкция = Неопределено Тогда
				КонечныйТекстЗамены = КонечныйТекстЗамены + Match.SubMatches(3);
			Иначе
				ИмяПараметраШаблона = Match.SubMatches(1);
				ТипШаблона = Match.SubMatches(2);
				Если ТипШаблона = "КонструкторОписанияТипов" Тогда
					КонечныйТекстЗамены = ТекстИзКонструктораОписанияТипов();
				ИначеЕсли ТипШаблона = "ТекстЗапроса" Тогда
					//ВызватьКонструкторЗапросов();
				ИначеЕсли ИмяПараметраШаблона <> Неопределено Тогда
					ИмяПараметраШаблона = Сред(ИмяПараметраШаблона, 2, СтрДлина(ИмяПараметраШаблона) - 2);
					ВведеннаяСтрока = "";
					Если ИмяПараметраШаблона <> "" Тогда
						СтрокаКэша = КешПараметров.Найти(ИмяПараметраШаблона, "ИмяПараметра");
						Если СтрокаКэша <> Неопределено Тогда
							ВведеннаяСтрока = СтрокаКэша.ЗначениеПараметра;
						Иначе
							СтрокаКэша = КешПараметров.Добавить();
							СтрокаКэша.ИмяПараметра = ИмяПараметраШаблона;
							//НадежноУстановитьФокус = Истина;
							ВвестиЗначение(ВведеннаяСтрока, ИмяПараметраШаблона, Тип("Строка"));
							СтрокаКэша.ЗначениеПараметра = ВведеннаяСтрока;
						КонецЕсли;
					КонецЕсли;
					КонечныйТекстЗамены = КонечныйТекстЗамены + ВведеннаяСтрока;
				Иначе
					ПоследняяПозицияКурсора = СтрДлина(КонечныйТекстЗамены) + 1;
				КонецЕсли;
			КонецЕсли;
		КонецЦикла;
	КонецЕсли;
	Если КонечныйТекстЗамены <> Неопределено Тогда
		ЗаменаТабуляции = ирОбщий.СтрокаПовторомЛкс(" ", мШиринаТабуляции);
		КонечныйТекстЗаменыТД = Новый ТекстовыйДокумент;
		КонечныйТекстЗаменыТД.УстановитьТекст(КонечныйТекстЗамены);
		лКонечнаяСтрока = 0;
		лКонечнаяКолонка = 0;
		Если ПоследняяПозицияКурсора > 0 Тогда
			мПолеТекстаВременное.УстановитьТекст(КонечныйТекстЗамены);
			Если ПоследняяПозицияКурсора <= СтрДлина(КонечныйТекстЗамены) Тогда
				мПолеТекстаВременное.УстановитьГраницыВыделения(ПоследняяПозицияКурсора, ПоследняяПозицияКурсора);
				мПолеТекстаВременное.ПолучитьГраницыВыделения(лКонечнаяСтрока, лКонечнаяКолонка, лКонечнаяСтрока, лКонечнаяКолонка);
			Иначе
				лКонечнаяСтрока = КонечныйТекстЗаменыТД.КоличествоСтрок();
				лКонечнаяКолонка = СтрДлина(КонечныйТекстЗаменыТД.ПолучитьСтроку(КонечныйТекстЗаменыТД.КоличествоСтрок())) + 1;
			КонецЕсли;
		КонецЕсли;
		ЧислоСтрокЗамены = КонечныйТекстЗаменыТД.КоличествоСтрок();
		СтрокаДобавка = КонечныйТекстЗаменыТД.ПолучитьСтроку(1);
		ДлинаНачалаСтроки = мКонечнаяКолонка - СтрДлина(НачалоМаркера) - 1;
		НачалоСтроки = Лев(мТекущаяСтрокаНачало, ДлинаНачалаСтроки);
		мТекущаяСтрокаНачало = НачалоСтроки + СтрокаДобавка;
		ТекущаяСтрока = мТекущаяСтрокаНачало;
		Если ЧислоСтрокЗамены = 1 Тогда
			ТекущаяСтрока = ТекущаяСтрока + мТекущаяСтрокаКонец;
		КонецЕсли;
		ПолеТекста.ЗаменитьСтроку(мКонечнаяСтрока, "" + ТекущаяСтрока);
		ДлинаРазвернутогоНачалаСтроки = СтрДлина(СтрЗаменить(НачалоСтроки, Символы.Таб, ЗаменаТабуляции));
		ЧислоТабуляций = ДлинаРазвернутогоНачалаСтроки / мШиринаТабуляции;
		ЧислоПробелов = ДлинаРазвернутогоНачалаСтроки % мШиринаТабуляции;
		НачалоНовойСтроки = ирОбщий.СтрокаПовторомЛкс(Символы.Таб, ЧислоТабуляций);
		НачалоНовойСтроки = НачалоНовойСтроки + ирОбщий.СтрокаПовторомЛкс(" ", ЧислоПробелов);
		Для Счетчик = 2 По ЧислоСтрокЗамены - 1 Цикл
			ТекущаяСтрокаВставки = КонечныйТекстЗаменыТД.ПолучитьСтроку(Счетчик);
			ПолеТекста.ВставитьСтроку(мКонечнаяСтрока + Счетчик - 1, НачалоНовойСтроки + ТекущаяСтрокаВставки);
		КонецЦикла;
		Если ЧислоСтрокЗамены > 1 Тогда
			ТекущаяСтрокаВставки = КонечныйТекстЗаменыТД.ПолучитьСтроку(ЧислоСтрокЗамены);
			ПолеТекста.ВставитьСтроку(мКонечнаяСтрока + ЧислоСтрокЗамены - 1, НачалоНовойСтроки + ТекущаяСтрокаВставки + мТекущаяСтрокаКонец);
		КонецЕсли;
		Если лКонечнаяСтрока > 0 Тогда
			Если лКонечнаяСтрока = 1 Тогда
				лКонечнаяКолонка = лКонечнаяКолонка + СтрДлина(НачалоСтроки);
			Иначе
				лКонечнаяКолонка = лКонечнаяКолонка + СтрДлина(НачалоНовойСтроки);
			КонецЕсли;
			лКонечнаяСтрока = лКонечнаяСтрока + мКонечнаяСтрока - 1;
			мКонечнаяКолонка = лКонечнаяКолонка;
			мКонечнаяСтрока = лКонечнаяСтрока;
		Иначе
			Если ЧислоСтрокЗамены > 0 Тогда
				мКонечнаяСтрока = мКонечнаяСтрока + ЧислоСтрокЗамены - 1;
			КонецЕсли;
			Если ЧислоСтрокЗамены > 1 Тогда
				мКонечнаяКолонка = СтрДлина(НачалоСтроки + ТекущаяСтрокаВставки) + 1;
			Иначе
				мКонечнаяКолонка = мКонечнаяКолонка + СтрДлина(КонечныйТекстЗамены) - СтрДлина(НачалоМаркера);
			КонецЕсли;
		КонецЕсли;
		мНачальнаяСтрока = мКонечнаяСтрока;
		мНачальнаяКолонка = мКонечнаяКолонка;
	КонецЕсли;
КонецПроцедуры

Функция ТекстИзКонструктораОписанияТипов()
	
	ОписаниеТипов = ирКлиент.РедактироватьОписаниеРедактируемыхТиповЛкс();
	Если ОписаниеТипов <> Неопределено Тогда
		Результат = ирОбщий.ВыражениеВстроенногоЯзыкаСозданиеОписанияТиповЛкс(ОписаниеТипов);
	КонецЕсли;
	Возврат Результат;

КонецФункции

Процедура КонструкторОписанияТипов()
	
	НовыйТекст = ТекстИзКонструктораОписанияТипов();
	Если ЗначениеЗаполнено(НовыйТекст) Тогда
		ПолеТекста.ВыделенныйТекст(НовыйТекст);
	КонецЕсли;
	
КонецПроцедуры

Процедура ОкружитьВыделенныеСтроки(Знач НачалоОкружения, Знач КонецОкружения, Знач СмещатьВправо = Истина) Экспорт 
	
	#Если Сервер И Не Сервер Тогда
		ПолеТекста = Обработки.ирОболочкаПолеТекста.Создать();
	#КонецЕсли
	НомерНачальнойСтроки = ПолучитьНомерТекущейСтроки(Истина);
	ВыделенныйТекст = ПолеТекста.ВыделенныйТекст();
	Смещение = "";
	Если СмещатьВправо Тогда
		Смещение = Символы.Таб;
	КонецЕсли;
	СмещениеПервойСтроки = Лев(ВыделенныйТекст, СтрДлина(ВыделенныйТекст) - СтрДлина(СокрЛ(ВыделенныйТекст)));
	ПолеТекста.ВставитьТекст(
	"" + СмещениеПервойСтроки + НачалоОкружения + "
	|" + Смещение + ирОбщий.ДобавитьМногострочнуюСтрокуВТекстЛкс("", ВыделенныйТекст, Смещение) + "
	|" + СмещениеПервойСтроки + КонецОкружения);
	НомерНачальнойКолонки = СтрДлина(СмещениеПервойСтроки) + 1;
	ПолеТекста.УстановитьГраницыВыделения(НомерНачальнойСтроки, НомерНачальнойКолонки, НомерНачальнойСтроки, НомерНачальнойКолонки,, ФормаВладелец);
	УстановитьПризнакМодифицированностиФормы();

КонецПроцедуры

//.
// Параметры:
//   Значение - Произвольный, ЛюбаяСсылка - 
//   ВыводитьСообщение - Булево - 
//   ПараметрыДиалектаSQL -  - 
//   Английский1С -  - 
// Возвращаемое значение:
//   Строка - 
Функция ПредставлениеЗначенияВЯзыкеЗапросов(Знач Значение, Знач ВыводитьСообщение = Ложь, Знач ПараметрыДиалектаSQL = Неопределено, Знач Английский1С = Неопределено) Экспорт
	Если Английский1С = Неопределено Тогда
		Английский1С = мАнглийский1С;
	КонецЕсли;
	Результат = "";
	ТипЗначенияПараметра = ТипЗнч(Значение);
	ОбъектМД = Метаданные.НайтиПоТипу(ТипЗначенияПараметра);
	Если ОбъектМД <> Неопределено Тогда
		КорневойТип = ирОбщий.ПервыйФрагментЛкс(ОбъектМД.ПолноеИмя());
		Если ирОбщий.ЛиКорневойТипСсылкиЛкс(КорневойТип) Тогда
			Если ирОбщий.ЛиТипСсылкиТочкиМаршрутаЛкс(ТипЗначенияПараметра) Тогда 
				Результат = "ТочкаМаршрута." + Значение.Имя;
			ИначеЕсли Значение.Пустая() Тогда
				Результат = "ПустаяСсылка";
			ИначеЕсли ирОбщий.ЛиКорневойТипПеречисленияЛкс(КорневойТип) Тогда
				Результат = XMLСтрока(Значение);
			ИначеЕсли ирОбщий.ЛиКорневойТипОбъектаСПредопределеннымЛкс(КорневойТип) Тогда
				Если Значение.Предопределенный Тогда
					Результат = ирОбщий.ПолучитьМенеджерЛкс(ОбъектМД).ПолучитьИмяПредопределенного(Значение);
				КонецЕсли;
			КонецЕсли; 
		КонецЕсли; 
	ИначеЕсли ТипЗначенияПараметра = Тип("ВидДвиженияБухгалтерии") Тогда 
		Результат = "ВидДвиженияБухгалтерии." + Значение;
	ИначеЕсли ТипЗначенияПараметра = Тип("ВидДвиженияНакопления") Тогда 
		Результат = "ВидДвиженияНакопления." + Значение;
	КонецЕсли; 
	Если ЗначениеЗаполнено(Результат) Тогда
		Если ОбъектМД <> Неопределено Тогда
			Результат = ОбъектМД.ПолноеИмя() + "." + Результат;
		КонецЕсли; 
		Результат = "ЗНАЧЕНИЕ(" + Результат + ")";
	ИначеЕсли ТипЗначенияПараметра = Тип("Неопределено") Тогда
		Результат = СловоЯзыкаЗапросов("UNDEFINED", ПараметрыДиалектаSQL, Английский1С);
	ИначеЕсли ТипЗначенияПараметра = Тип("Null") Тогда
		Результат = "NULL";
	Иначе 
		Если ПараметрыДиалектаSQL = Неопределено Тогда
			ПараметрыДиалектаSQL = мПараметрыДиалектаSQL;
		КонецЕсли;
		Если ТипЗначенияПараметра = Тип("СтандартнаяДатаНачала") Тогда
			Значение = Значение.Дата;
			ТипЗначенияПараметра = ТипЗнч(Значение);
		КонецЕсли; 
		Если ТипЗначенияПараметра = Тип("Дата") Тогда
			Если ПараметрыДиалектаSQL.Это1С Тогда
				Результат = СловоЯзыкаЗапросов("DATETIME", ПараметрыДиалектаSQL, Английский1С) + "(" + XMLСтрока(Год(Значение)) + ", " + XMLСтрока(Месяц(Значение)) + ", " + XMLСтрока(День(Значение));
				Если НачалоДня(Значение) <> Значение Тогда
					Результат = Результат + ",  " + XMLСтрока(Час(Значение)) + ", " + XMLСтрока(Минута(Значение)) + ", " + XMLСтрока(Секунда(Значение));
				КонецЕсли;
				Результат = Результат + ")";
			ИначеЕсли ирОбщий.СтрокиРавныЛкс(ПараметрыДиалектаSQL.Диалект, "WQL") Тогда
				Значение = ирОбщий.ПолучитьЛитералДатыДляWQLЛкс(Значение);
			Иначе// Если ирОбщий.СтрокиРавныЛкс(КодЯзыка, "WQL") Тогда
				Результат = "'" + Формат(Значение, "ДФ='yyyyMMdd HH:mm:ss'; ДП=") + "'";
			КонецЕсли; 
		ИначеЕсли ТипЗначенияПараметра = Тип("Число") Тогда
			Результат = XMLСтрока(Значение);
		ИначеЕсли ТипЗначенияПараметра = Тип("Булево") Тогда
			Если Значение Тогда
				Результат = СловоЯзыкаЗапросов("TRUE", ПараметрыДиалектаSQL, Английский1С);
			Иначе
				Результат = СловоЯзыкаЗапросов("FALSE", ПараметрыДиалектаSQL, Английский1С);
			КонецЕсли; 
		ИначеЕсли ТипЗначенияПараметра = Тип("Строка") Тогда
			Если ПараметрыДиалектаSQL.Это1С Тогда
				Результат = """" + СтрЗаменить(Значение, """", """""") + """";
			Иначе
				Результат = "'" + Значение + "'";
			КонецЕсли; 
		КонецЕсли; 
	КонецЕсли;
	Если Результат = "" Тогда
		Если ВыводитьСообщение Тогда
			ирОбщий.СообщитьЛкс(ирОбщий.СтрШаблонЛкс("Литеральное представление значения ""%1"" в языке запросов не предусмотрено", ирОбщий.РасширенноеПредставлениеЛкс(Значение)));
		КонецЕсли;
	КонецЕсли;
	Возврат Результат;
КонецФункции

// Внешний вызов
Функция ВычисляемыйКонтекстОтладчика() Экспорт 
	Возврат ирКлиент.ВычисляемыйКонтекстОтладчикаЛкс();
КонецФункции

Функция СловоЯзыкаЗапросов(Ключ, ПараметрыДиалектаSQL = Неопределено, Английский1С = Неопределено) Экспорт

	Если ПараметрыДиалектаSQL = Неопределено Тогда  
		ПараметрыДиалектаSQL = мПараметрыДиалектаSQL;
	КонецЕсли;
	Если Английский1С = Неопределено Тогда
		Английский1С = мАнглийский1С;
	КонецЕсли;
	Результат = Неопределено;
	Если ирОбщий.СтрокиРавныЛкс("AS", Ключ) Тогда
		Если Не ПараметрыДиалектаSQL.КАК Тогда
			Результат = "";
		КонецЕсли;
	КонецЕсли; 
	Если Результат = Неопределено Тогда
		СтрокаТерминала = мПлатформа.ТерминалыЯзыкаЗапросов().Найти(Ключ, "Ключ"); 
		Если ПараметрыДиалектаSQL <> Неопределено И ПараметрыДиалектаSQL.Это1С Тогда 
			Если СтрокаТерминала = Неопределено Тогда
				ВызватьИсключение "Не найден терминал """ + Ключ + """ языка запросов 1C";
			КонецЕсли; 
			Если Не Английский1С Тогда
				Результат = СтрокаТерминала.Русский;  
			Иначе
				Результат = СтрокаТерминала.Английский;
			КонецЕсли; 
		Иначе
			Результат = Ключ;
		КонецЕсли; 
	КонецЕсли; 
	Возврат Результат;
	
КонецФункции

// Функция - Найти выбранные таблицы в тексте запроса
//
// Параметры:
//  СтрокаЗапросаПакета		 - см. Обработка.ирКонсольЗапросов.Форма.Форма.ДеревоЗапроса.Строки[0] - 
//  НачальнаяПозицияЗапроса	 - 	 - 
//  ПолеТекстаЗапроса		 - 	 - 
// 
// Возвращаемое значение:
//   - 
//
Функция НайтиВыбранныеТаблицыВТекстеЗапроса(Знач СтрокаЗапросаПакета, Знач НачальнаяПозицияЗапроса, Знач ПолеТекстаЗапроса) Экспорт 
	СтрокаЗапросаПакета.СложныйАнализВыполнен = Истина;   
	//Шаблон = шИЗ;
	Шаблон = "((?:ИЗ|FROM)" + шРазделитель + "+" + шОписаниеТаблицы + "[\s\S]*?)(?:$|\sОБЪЕДИНИТЬ(?:\s+ВСЕ)?\s+|\sUNION(?:\s+ALL)?\s+|\sУПОРЯДОЧИТЬ\s+[^\)]*$|\sORDER\s+[^\)]*$)";
	ВхожденияИЗ = ирОбщий.НайтиРегВыражениеЛкс(СтрокаЗапросаПакета.Текст, Шаблон);
	НачальнаяПозицияЧасти = НачальнаяПозицияЗапроса;
	//! ВхожденияИЗ.Колонки.Добавить("Группа0");
	Для Каждого ВхождениеИЗ Из ВхожденияИЗ Цикл
		Если ВхожденияИЗ.Количество() > 1 Тогда 
			СтрокаЧастиОбъединения = СтрокаЗапросаПакета.Строки.Вставить(0);
			Если Истина
				И СтрокаЗапросаПакета.ТипУзла = "<CreateRoot>" 
				И СтрокаЗапросаПакета.Строки.Количество() = 1 
			Тогда
				СтрокаЧастиОбъединения.ТипУзла = "<CreateQuery>";
			Иначе
				СтрокаЧастиОбъединения.ТипУзла = "<SelectQuery>";
			КонецЕсли;
			СтрокаЧастиОбъединения.СложныйАнализВыполнен = Истина;
			СтрокаЧастиОбъединения.Порядок = -СтрокаЗапросаПакета.Строки.Количество();
			СтрокаЧастиОбъединения.Имя = "Выборка";
			КонечнаяПозицияЧасти = НачальнаяПозицияЗапроса + ВхождениеИЗ.ПозицияВхождения + СтрДлина(ВхождениеИЗ.Группа0);        
			ПолеТекстаЗапроса.УстановитьГраницыВыделения(НачальнаяПозицияЧасти, КонечнаяПозицияЧасти);
			ТекстИсточника = ПолеТекстаЗапроса.ВыделенныйТекст;
			//ТекстИсточника = Сред(СлужебноеПолеТекста.Получитьтекст(), НачальнаяПозицияЧасти, КонечнаяПозицияЧасти - НачальнаяПозицияЧасти);
			НачальнаяПозицияЧасти = НачальнаяПозицияЗапроса + ВхождениеИЗ.ПозицияВхождения + СтрДлина(ВхождениеИЗ.ТекстВхождения);
			ЗаполнитьСтрокуУпрощеннойСтруктурыЗапроса(СтрокаЧастиОбъединения, ПолеТекстаЗапроса);
		Иначе
			СтрокаЧастиОбъединения = СтрокаЗапросаПакета;
		КонецЕсли;
		Найденные = ирОбщий.НайтиРегВыражениеЛкс(ВхождениеИЗ.ТекстВхождения, шОписаниеТаблицыСЗахватом);
		//! Найденные.Колонки.Добавить("Группа0");
		//! Найденные.Колонки.Добавить("Группа4");
		Для Каждого Найденное Из Найденные Цикл
			НачальнаяПозиция = НачальнаяПозицияЗапроса + ВхождениеИЗ.ПозицияВхождения + Найденное.ПозицияВхождения;
			КонечнаяПозиция = НачальнаяПозиция + СтрДлина(Найденное.Группа0);
			Если Лев(Найденное.Группа0, 1) = "(" Тогда
				НачальнаяПозиция = НачальнаяПозиция + 1;
				КонечнаяПозиция = КонечнаяПозиция - 1;
				ТипУзла = "<FromUnion>";
			Иначе
				ТипУзла = "<TableWithName>";
			КонецЕсли; 
			ПолеТекстаЗапроса.УстановитьГраницыВыделения(НачальнаяПозиция, КонечнаяПозиция);
			ТекстИсточника = ПолеТекстаЗапроса.ВыделенныйТекст;
			//ТекстИсточника = Сред(СлужебноеПолеТекста.Получитьтекст(), НачальнаяПозиция, КонечнаяПозиция - НачальнаяПозиция);
			КорневойТипТаблицы = ирОбщий.ПервыйФрагментЛкс(СокрЛ(ТекстИсточника));
			Если Ложь
				Или Найденное.Группа4 = "ЧИСЛО" // Ложное срабатываение ВЫРАЗИТЬ ВЫБОР ... КОНЕЦ КАК ЧИСЛО
				Или ТекстИсточника = "КОНЕЦ" // Ложное срабатываение ВЫРАЗИТЬ ВЫБОР ... КОНЕЦ КАК ЧИСЛО
				Или (Истина
					// {ГДЕ (АналитикаУчета.Договор) КАК Договор}
					// ОБЪЕДИНИТЬ ВЫБРАТЬ АналитикаУчета.Партнер КАК Партнер
					И мПараметрыДиалектаSQL.Это1С
					И Найти(ТекстИсточника, ".") > 0
					И Не ирОбщий.ЛиКорневойТипТаблицыБДЛкс(КорневойТипТаблицы) 
					И Не ирОбщий.ЛиКорневойТипПеречисленияЛкс(КорневойТипТаблицы) 
					И Не ирОбщий.СтрНачинаетсяСЛкс(СокрЛ(ТекстИсточника), "ВЫБРАТЬ") 
					И Не ирОбщий.СтрНачинаетсяСЛкс(СокрЛ(ТекстИсточника), "SELECT") 
					)   
			Тогда
				Продолжить;
			КонецЕсли;
			СтрокаИсточника = СтрокаЧастиОбъединения.Строки.Вставить(0);
			СтрокаИсточника.Порядок = -СтрокаЧастиОбъединения.Строки.Количество();
			СтрокаИсточника.Имя = Найденное.Группа4;
			СтрокаИсточника.ТипУзла = ТипУзла;
			ЗаполнитьСтрокуУпрощеннойСтруктурыЗапроса(СтрокаИсточника, ПолеТекстаЗапроса);
		КонецЦикла;
	КонецЦикла;
КонецФункции
 
Процедура ЗаполнитьСтрокуУпрощеннойСтруктурыЗапроса(Знач СтрокаДерева, Знач ПолеТекстаЗапроса)
	
	лНачальнаяСтрока = 0;
	лНачальнаяКолонка = 0;
	лКонечнаяСтрока = 0;
	лКонечнаяКолонка = 0;
	ПолеТекстаЗапроса.ПолучитьГраницыВыделения(лНачальнаяСтрока, лНачальнаяКолонка, лКонечнаяСтрока, лКонечнаяКолонка);
	СтрокаДерева.Текст = ПолеТекстаЗапроса.ВыделенныйТекст;
	ГраницыДвумерные = Новый Структура();
	ГраницыДвумерные.Вставить("НачальнаяСтрока", лНачальнаяСтрока);
	ГраницыДвумерные.Вставить("НачальнаяКолонка", лНачальнаяКолонка);
	ГраницыДвумерные.Вставить("КонечнаяСтрока", лКонечнаяСтрока);
	ГраницыДвумерные.Вставить("КонечнаяКолонка", лКонечнаяКолонка);
	СтрокаДерева.СтрокаДанных = ГраницыДвумерные;

КонецПроцедуры

// Вызывается из адаптера. Отладчик Visual Studio Code внутри не останавливается.
// Скопировано от РедакторHTML_ПриАктивацииСтрокиАвтодополнения
Функция ОписаниеТекущегоСловаАвтодополнения(Знач Слово, Знач ЛиМетод = Неопределено, Знач КлючНабораСлов = "", Знач ЛиОтдельноеОписаниеАктивно = Истина, Знач ТолькоДляАвтооткрытия = Ложь) Экспорт 
	
	СтрокаСлова = СтрокаСловаИзСловаИНабора(Слово, ЛиМетод, КлючНабораСлов);
	Если СтрокаСлова = Неопределено Тогда
		Возврат Неопределено;
	КонецЕсли;
	ЕстьПараметры = Ложь;
	ЧислоРасширений = 0;
	Если СтрокаСлова <> Неопределено Тогда
		ТипВладелец = Неопределено; // см. мПлатформа.НоваяСтруктураТипа
		ТаблицаТипов = УточнитьТипЗначенияВСтрокеТаблицыСлов(СтрокаСлова, ЛиОтдельноеОписаниеАктивно,, ТипВладелец);
		СтруктураОписания = Новый Массив;
		СтрокаТипаКонтекста = мСтруктураТипаКонтекста;
		Если СтрокаТипаКонтекста.Конструктор Тогда
			ДетальноеОписаниеДляСписка = "";
		Иначе
			ДетальноеОписаниеДляСписка = СтрокаСлова.ТипЗначения;
		КонецЕсли;
		Если ЛиОтдельноеОписаниеАктивно Тогда 
			ЛучшийТип = Неопределено;
			Если ТаблицаТипов <> Неопределено Тогда
				ЛучшийТип = ЛучшийТипИзТаблицыТипов(ТаблицаТипов, 1);
			КонецЕсли;
			Если ПустаяСтрока(мРодительскийКонтекст) И СтрокаСлова.ТипСлова = "Свойство" Тогда
				// в ВычислитьТипПараметраМетодаМодуля решил не делать заполнение колонки СтрокаОписания 
				СтрокаОписания = СтрокаПараметраМетодаМодуля(СтрокаСлова.Слово);
			КонецЕсли;
			Если СтрокаОписания = Неопределено И ЛучшийТип <> Неопределено Тогда
				СтрокаОписания = ЛучшийТип.СтрокаОписания; // см. мПлатформа.НоваяТаблицаМетодовМодуля()[0]
			КонецЕсли;
			Если ЗначениеЗаполнено(ДетальноеОписаниеДляСписка) Тогда
				СтруктураОписания.Добавить("> Тип*: " + ДетальноеОписаниеДляСписка);
				мКэшОжидаемогоТипа = РассчитатьОжидаемыйТипВыражения(, Истина);
				Если мКэшОжидаемогоТипа <> Неопределено Тогда
					Если Истина
						И ЗначениеЗаполнено(мКэшОжидаемогоТипа.мНомерПараметра) 
						И ЗначениеЗаполнено(мКэшОжидаемогоТипа.ВыражениеПриемник) 
					Тогда
						СтруктураОписания.Добавить("> Параметр-приемник: " + мКэшОжидаемогоТипа.ВыражениеПриемник);
					КонецЕсли;
					ИмяОжидаемогоТипа = "";
					Если ЗначениеЗаполнено(мКэшОжидаемогоТипа.ТаблицаОжидаемыхТипов) Тогда
						ИмяОжидаемогоТипа = мПлатформа.ПредставлениеМассиваСтруктурТипов(мКэшОжидаемогоТипа.ТаблицаОжидаемыхТипов,,, Ложь);
					ИначеЕсли ЗначениеЗаполнено(мКэшОжидаемогоТипа.мИмяОжидаемогоТипа) Тогда
						ИмяОжидаемогоТипа = мКэшОжидаемогоТипа.мИмяОжидаемогоТипа;
					КонецЕсли;
					Если ЗначениеЗаполнено(ИмяОжидаемогоТипа) Тогда
						СтруктураОписания.Добавить("> Тип-приемник: " + ИмяОжидаемогоТипа);
					КонецЕсли;
				КонецЕсли;
				МетаСвойства = "";
				Если ЛучшийТип <> Неопределено Тогда
					МетаданныеТипа = ЛучшийТип.Метаданные;
					Если Ложь
						Или ТипЗнч(МетаданныеТипа) = Тип("Структура") 
						Или ЛучшийТип.ИмяОбщегоТипа = "Структура" И ТипЗнч(МетаданныеТипа) = Тип("ТаблицаЗначений") 
						Или ЛучшийТип.ИмяОбщегоТипа = "Массив"
					Тогда
						СтруктураКолонок = МетаданныеТипа;
					Иначе
						СтруктураКолонок = КолонкиКоллекцииВСтруктуру(МетаданныеТипа);
					КонецЕсли;
					Если Истина
						И ТипЗнч(СтруктураКолонок) = Тип("Структура")
						И ирОбщий.СвойствоСтруктурыЛкс(СтруктураКолонок, "Тип") <> ирОбщий.ТипУправляемаяФормаЛкс() // имитатор формы
					Тогда 
						СписокСвойств = Новый СписокЗначений;
						СписокСвойств.ЗагрузитьЗначения(ирОбщий.ВыгрузитьСвойствоЛкс(СтруктураКолонок));
						СписокСвойств.СортироватьПоЗначению();
						СтруктураОписания.Добавить("> Свойства*: " + ирОбщий.СтрСоединитьЛкс(СписокСвойств));
					ИначеЕсли Истина
						И ТипЗнч(МетаданныеТипа) = Тип("ТаблицаЗначений") 
						//! МетаданныеТипа = 0 // см. ТаблицаТипов
						И МетаданныеТипа.Колонки.Найти(мПлатформа.ИмяКолонкиФлагаТаблицыТипов()) <> Неопределено
					Тогда 
						СтруктураОписания.Добавить("> Элементы*: " + ПредставлениеМассиваСтруктурТипов(МетаданныеТипа));
					КонецЕсли;
				КонецЕсли;
			КонецЕсли; 
			Если Истина
				И ТипЗнч(СтрокаОписания) = Тип("СтрокаТаблицыЗначений")
				И СтрокаОписания.Владелец().Колонки.Найти("ЛиЭкспорт") <> Неопределено
			Тогда
				Если Истина
					И ЗначениеЗаполнено(СтрокаОписания.ТипЗначения) 
					И СтрокаСлова.ТипЗначения <> СтрокаОписания.ТипЗначения
					И Не ирОбщий.СтрНачинаетсяСЛкс(СтрокаОписания.ТипЗначения, "??")
				Тогда
					СтруктураОписания.Добавить("> Тип: " + СтрокаОписания.ТипЗначения);
				КонецЕсли;
				Если Истина
					И мПлатформа.ЛиИмяМодуляФормы(СтрокаОписания.ИмяМодуля) 
					И СтрокаОписания.ПозицияОпределения > 0
					И СтрокаСлова.ТипСлова = "Метод" 
				Тогда
					ИмяОбщегоТипа = мПлатформа.МодульМетаданныхИзКэша(СтрокаОписания.ИмяМодуля).СтруктураТипа.ИмяОбщегоТипа;
					Если ирОбщий.ЛиИмяТипаФормыЛкс(ИмяОбщегоТипа) Тогда
						ДоступностьМассив = Новый Массив;
						ДоступностьСервер = "";
						Если СтрокаОписания.БезКонтекста Тогда
							ДоступностьСервер = "СерверБезКонтекста";
						ИначеЕсли СтрокаОписания.Сервер Тогда
							ДоступностьСервер = "Сервер";
						КонецЕсли;
						Если ЗначениеЗаполнено(ДоступностьСервер) Тогда
							ДоступностьМассив.Добавить(ДоступностьСервер);
						КонецЕсли;
						Если СтрокаОписания.Клиент Тогда
							ДоступностьМассив.Добавить("Клиент");
						КонецЕсли;
						СтруктураОписания.Добавить("> Доступность: " + ирОбщий.СтрСоединитьЛкс(ДоступностьМассив));
					КонецЕсли;
					//СтруктураОписания.Добавить("> Метод модуля: " + ?(СтрокаОписания.ЛиЭкспорт, "Экспорт", "Внутр"));
				КонецЕсли;
			ИначеЕсли Истина
				И ТипЗнч(СтрокаОписания) = Тип("СтрокаТаблицыЗначений")
				И СтрокаОписания.Владелец().Колонки.Найти("Знач") <> Неопределено
			Тогда
				СтрокаПараметра = СтрокаПараметраМетодаМодуля(СтрокаСлова.НСлово);
				Если СтрокаПараметра.Знач Тогда
					НаправлениеПараметра = "Вход";
				Иначе
					НаправлениеПараметра = "Вход/Выход";
				КонецЕсли;
				СтруктураОписания.Добавить("> Параметр метода: " + НаправлениеПараметра);
			ИначеЕсли Истина
				И ЛучшийТип <> Неопределено
				И ЛучшийТип.ИмяОбщегоТипа = "ОбщийМодуль" 
			Тогда
				ОбъектМД = ЛучшийТип.Метаданные; // ОбъектМетаданныхОбщийМодуль
				Если ТипЗнч(ОбъектМД) = Тип("ОбъектМетаданных") Тогда
					СтруктураОписания.Добавить("> Кэширование: " + ОбъектМД.ПовторноеИспользованиеВозвращаемыхЗначений);
					ДоступностьМассив = Новый Массив;
					Если ОбъектМД.Сервер Тогда
						ДоступностьМассив.Добавить("Сервер");
					КонецЕсли;
					Если ОбъектМД.КлиентУправляемоеПриложение Тогда
						ДоступностьМассив.Добавить("КлиентУправляемоеПриложение");
					КонецЕсли;
					Если ОбъектМД.КлиентОбычноеПриложение Тогда
						ДоступностьМассив.Добавить("КлиентОбычноеПриложение");
					КонецЕсли;
					Если ОбъектМД.ВнешнееСоединение Тогда
						ДоступностьМассив.Добавить("ВнешнееСоединение");
					КонецЕсли;
					СтруктураОписания.Добавить("> Доступность*: " + ирОбщий.СтрСоединитьЛкс(ДоступностьМассив));
				КонецЕсли;
			КонецЕсли;
			Если мЯзыкПрограммы = 0 И Не мЭтоТекстовыйЛитерал Тогда
				Если Истина
					И ТипЗнч(СтрокаОписания) = Тип("СтрокаТаблицыЗначений")
					И СтрокаОписания.Владелец().Колонки.Найти("ТипКонтекста") <> Неопределено
					И ирОбщий.СтрНачинаетсяСЛкс(СтрокаОписания.ТипКонтекста, "Расширение")
				Тогда
					ИмяТипаВладельца = СтрокаОписания.ТипКонтекста;
				Иначе
					ИмяТипаВладельца = мПлатформа.ИмяТипаИзСтруктурыТипа(ТипВладелец);
				КонецЕсли;
				Если Ложь
					Или мАгрегатныеТипыКонтекста.Количество() > 1
					Или ИмяТипаВладельца <> мКонкретныйТипКонтекста 
				Тогда  
					СтруктураОписания.Добавить("> Владелец: " + ИмяТипаВладельца);
				КонецЕсли;
			КонецЕсли;
			Если Истина
				И ЛучшийТип <> Неопределено
				И (Ложь
					Или СтрокаТипаКонтекста.Конструктор
					Или СтрокаТипаКонтекста.ТипЯзыка = "ИмяТипа"
					Или (Истина
						И СтрокаСлова.ТипСлова <> "Метод" 
						И СтрокаСлова.ТипСлова <> "Событие"))
			Тогда
				Если Ложь
					Или СтрокаТипаКонтекста.Конструктор 
					Или СтрокаТипаКонтекста.ТипЯзыка = "ИмяТипа"
				Тогда
					Найденные = мПлатформа.ТаблицаОбщихТипов.НайтиСтроки(Новый Структура("ЯзыкПрограммы, Слово", 0, СтрокаСлова.Слово));
					Если Найденные.Количество() > 0 Тогда
						ЛучшийТип = мПлатформа.НоваяСтруктураТипа();
						ЛучшийТип.ИмяОбщегоТипа = СтрокаСлова.Слово;
						ЛучшийТип.ТипЯзыка = "ИмяТипа";
						СтрокаОписания = Найденные[0];
					КонецЕсли;
				КонецЕсли;
				Если СтрокаОписания <> Неопределено Тогда
					Если Истина
						И мЯзыкПрограммы = 1 
						И ТипЗнч(СтрокаТипаКонтекста.Метаданные) = Тип("ОбъектМетаданных")
						И СтрокаСлова.ТипСлова = "Свойство"
					Тогда 
						ИмяПоля = СтрокаСлова.Слово;
						ИмяТаблицы = мПлатформа.ИмяТипаИзСтруктурыТипа(СтрокаТипаКонтекста);
						ПоляТаблицыБД = ирКэш.ПоляТаблицыБДЛкс(ИмяТаблицы);
						НайденныеПоляБД = ирОбщий.ОтобратьКоллекциюЛкс(ПоляТаблицыБД, "НРег(Э.Имя)=П1",, НРег(ИмяПоля));
						Если Не ЗначениеЗаполнено(НайденныеПоляБД) Тогда
							// Виртуальное поле
						Иначе
							ПолеБД = НайденныеПоляБД[0]; 
							СтруктураХраненияБД = ирОбщий.СтруктураХраненияТаблицыБДЛкс(ИмяТаблицы,, СтрокаТипаКонтекста.Метаданные);
							ИндексыХранения = Новый СписокЗначений; 
							Если СтруктураХраненияБД.Количество() > 0 Тогда
								Для Каждого ИндексТаблицыБД Из СтруктураХраненияБД[0].Индексы Цикл
									Если ИндексТаблицыБД.Поля.Найти(ИмяПоля, "ИмяПоля") <> Неопределено Тогда
										ПредставлениеИндекса = ирОбщий.ПредставлениеИндексаХраненияЛкс(ИндексТаблицыБД,, СтруктураХраненияБД[0]);
										ИндексыХранения.Добавить(ИндексТаблицыБД.Поля[0].ИмяПоля <> ИмяПоля, "[" + ПредставлениеИндекса + "]");
									КонецЕсли;
								КонецЦикла;
								ИндексыХранения.СортироватьПоЗначению();
							КонецЕсли;
							Если ИндексыХранения.Количество() Тогда
								СтруктураОписания.Добавить("> Индексы: " + ирОбщий.СтрСоединитьЛкс(ИндексыХранения,,,,, "Представление"));
							КонецЕсли;
							Если Истина
								И ПолеБД.Метаданные <> Неопределено
								И СтрокаТипаКонтекста.ИмяОбщегоТипа <> "РегистрРасчета.<Имя регистра расчета>.<Имя перерасчета>"
								И СтрокаТипаКонтекста.ИмяОбщегоТипа <> "Последовательность.<Имя последовательности>"
								И ЗначениеЗаполнено(ПолеБД.Метаданные.Подсказка)
							Тогда
								СтруктураОписания.Добавить("> Подсказка: " + ПолеБД.Метаданные.Подсказка);
							КонецЕсли;
						КонецЕсли;
					КонецЕсли;
					Если ЛиСистемноеСлово(ЛучшийТип, Истина) Тогда  
						СинтаксПомощник = мПлатформа.СинтаксПомощник();
						ОписаниеСлова = СинтаксПомощник.ЗагрузитьОписаниеСвойства(ЛучшийТип.СтрокаОписания);
					Иначе
						СтрокаПеременной = СтрокаОписания; // см. мПлатформа.НоваяТаблицаПеременныхМодуля()[0]
						Если Истина
							И ТипЗнч(СтрокаПеременной) = Тип("СтрокаТаблицыЗначений")
							И СтрокаПеременной.Владелец().Колонки.Найти("ЛиЭкспорт") <> Неопределено
						Тогда
							СтруктураОписания.Добавить("> Элемент модуля: " + ?(СтрокаПеременной.ЛиЭкспорт, "Экспорт", "Внутр"));
							ОписаниеСлова = СтрокаПеременной.Описание;
						ИначеЕсли Истина
							И ТипЗнч(СтрокаПеременной) = Тип("Структура")
						Тогда
							ОписаниеСлова = СтрокаПеременной.Описание;
						КонецЕсли;
					КонецЕсли;
					Если ЗначениеЗаполнено(ОписаниеСлова) Тогда
						Если Лев(ОписаниеСлова, 1) <> ">" Тогда
							ОписаниеСлова = "> Описание: " + ОписаниеСлова;
						КонецЕсли;
						СтруктураОписания.Добавить(ОписаниеСлова);
					КонецЕсли; 
				КонецЕсли;
			КонецЕсли; 
			Если Ложь
				Или СтрокаТипаКонтекста.Конструктор
				Или СтрокаСлова.ТипСлова = "Метод" 
				Или СтрокаСлова.ТипСлова = "Событие" 
			Тогда
				Если СтрокаТипаКонтекста.Конструктор Тогда
					СтруктураТипа = мПлатформа.НоваяСтруктураТипа();
					СтруктураТипа.ИмяОбщегоТипа = "Глобальный";
					ПараметрыЗаполнения = мПлатформа.НовыеПараметрыЗаполненияСлов("Конструктор",, ЯзыкПрограммы, Конфигурация,,,,, СтрокаСлова.Слово);
					ТаблицаТипов = мПлатформа.СловаКонтекстаПредопределенные(СтруктураТипа, ПараметрыЗаполнения)[0].ТаблицаТипов;
					ЛучшийТип = ЛучшийТипИзТаблицыТипов(ТаблицаТипов, 1);
					//! ЛучшийТип.СтрокаОписания = 0 // см. мПлатформа.ТаблицаКонтекстов[0]
					СтруктураОписания.Добавить("> Конструктор: " + ЛучшийТип.СтрокаОписания.Слово);
				КонецЕсли; 
				Если ЛучшийТип <> Неопределено Тогда
					//ПараметрыМетода = мПлатформа.ПараметрыМетодаПлатформы(ЛучшийТип);
					мФактическиеПараметры.Очистить(); // Иначе будут светиться лишние параметры. Опасно
					мНомерПараметра = 0;
					СтруктураПодсказкиМетода = СтруктураПодсказкиМетода(ЛучшийТип, ТолькоДляАвтооткрытия, Истина, ЕстьПараметры);
					Если СтруктураПодсказкиМетода.Количество() > 0 Тогда
						Если СтруктураПодсказкиМетода.Количество() > 1 Тогда
							СтруктураОписания.Вставить(0, "> Варианты: " + СтруктураПодсказкиМетода.Количество());
						КонецЕсли; 
						СтруктураОписания.Вставить(0, "> Параметры: " + СтруктураПодсказкиМетода[0].label);
					КонецЕсли; 
					Если СтрокаСлова.ТипСлова = "Метод" Тогда 
						СтрокаМетода = ЛучшийТип.СтрокаОписания; // см. мПлатформа.НоваяТаблицаМетодовМодуля()[0]
						Если Истина
							И СтрокаМетода <> Неопределено
							И ТипЗнч(СтрокаМетода) = Тип("СтрокаТаблицыЗначений")
							И СтрокаМетода.Владелец().Колонки.Найти("ТелоБезВозвратов") <> Неопределено
							И СтрокаМетода.ИмяМодуля <> мПлатформа.ИмяДинамическогоМодуля()
						Тогда
							ИменаРасширений = Новый СписокЗначений;
							Для Каждого КлючИЗначение Из ирКэш.РасширенияКонфигурацииЛкс(Ложь) Цикл
								Расширение = КлючИЗначение.Ключ; 
								ИмяРасширенияМодуля = Расширение.Имя + " " + СтрокаМетода.ИмяМодуля;
								ПолеТекстаМодуля = мПлатформа.ПолеТекстаМодуля(ИмяРасширенияМодуля);
								РасширениеМетода = ПолеТекстаМодуля.мМодульМетаданных.Методы.Найти(СтрокаМетода.Имя, "РасширяемыйМетод");
								Если РасширениеМетода <> Неопределено Тогда
									ИменаРасширений.Добавить(Расширение.Имя);
								КонецЕсли;
							КонецЦикла;
							Если ИменаРасширений.Количество() > 0 Тогда
								СтруктураОписания.Добавить("> Расширения: " + ирОбщий.СтрСоединитьЛкс(ИменаРасширений));
							КонецЕсли; 
						КонецЕсли;
					КонецЕсли;
					Если СтруктураПодсказкиМетода.Количество() > 0 Тогда
						ОписаниеСлова = СтруктураПодсказкиМетода[0].documentation;
						Если ЗначениеЗаполнено(ОписаниеСлова) Тогда
							Если Лев(ОписаниеСлова, 1) <> ">" Тогда
								ОписаниеСлова = "> Описание: " + ОписаниеСлова;
							КонецЕсли;
							СтруктураОписания.Добавить(ОписаниеСлова);
						КонецЕсли; 
					КонецЕсли; 
				КонецЕсли;
			КонецЕсли;
		КонецЕсли; 
		СтруктураОписания.Добавить("> Определение: " + СтрокаСлова.Определение);
		СтруктураОписания.Добавить("> Имя: " + Слово);
		ДетальноеОписаниеОтдельное = ирОбщий.СтрСоединитьЛкс(СтруктураОписания, Символы.ПС);
	КонецЕсли;
	Результат = Новый Структура;
	Результат.Вставить("Описание", "" + ДетальноеОписаниеОтдельное);
	Результат.Вставить("Тип", ДетальноеОписаниеДляСписка);
	Результат.Вставить("ЕстьПараметры", ЕстьПараметры);
	Результат.Вставить("ЧислоРасширений", ЧислоРасширений);
	Возврат Результат;

КонецФункции

// Вызывается из адаптера
Функция ОткрытьРедакторКодаДляОтладчика(Знач ТекстПрограммы = "", Знач ТекстОшибки = "") Экспорт
	
	Если ПустаяСтрока(ТекстПрограммы) Тогда
		ТекстПрограммы = ирКлиент.ТекстИзБуфераОбменаОСЛкс();
	КонецЕсли; 
	УстановитьГраницыВыделения(мКонечнаяСтрока+1, 1, мКонечнаяСтрока+1, 1);
	КончитьОбработкуКоманды();
	ЗаполнитьТаблицуСлов(, Ложь,, Ложь, Ложь,,,, Истина);
	ФормаТекста = ирКлиент.ПолучитьФормуТекстаЛкс(ТекстПрограммы,, "ВстроенныйЯзык");
	АнализаторФрагментаКода = ирОбщий.НовыйАнализаторКодаЛкс(0);
	АнализаторФрагментаКода.ЭтоМодуль = Истина;
	АнализаторФрагментаКода.мЭтоФрагментМетода = Истина;
	АнализаторФрагментаКода.мФлагиКомпиляции = мФлагиКомпиляции;
	ЕстьПеременнаяРезультат = ТаблицаСлов.НайтиСтроки(Новый Структура("Слово, ТипСлова", "Результат", "Свойство")).Количество() > 0;
	Если Не ЕстьПеременнаяРезультат Тогда
		АнализаторФрагментаКода.ДобавитьСловоЛокальногоКонтекста("Результат", "Свойство");
	КонецЕсли;
	Для Каждого СтрокаСлова Из ТаблицаСлов Цикл
		// рекомендуется заранее вызывать расчет через РассчитатьТипыПеременных
		Если СтрокаСлова.ТипСлова = "Конструкция" Тогда
			Продолжить;
		КонецЕсли;
		Если Истина
			И СтрокаСлова.ТипСлова = "Свойство"
			И Метаданные.ОбщиеМодули.Найти(СтрокаСлова.Слово) = Неопределено
		Тогда
			ТаблицаТипов = УточнитьТипЗначенияВСтрокеТаблицыСлов(СтрокаСлова, Истина); // Самая тяжелая операция
		Иначе
			// Для ускорения
			ТаблицаТипов = Неопределено;
		КонецЕсли;
		СловоМодуля = АнализаторФрагментаКода.ДобавитьСловоЛокальногоКонтекста(СтрокаСлова.Слово, СтрокаСлова.ТипСлова,,, СтрокаСлова.ТипЗначения,, ТаблицаТипов);
	КонецЦикла;
	ФормаТекста.ПолеТекстаПрограммы = Новый Структура("ВстроенныйЯзык", АнализаторФрагментаКода);
	ФормаТекста.Заголовок = ПолноеИмяМетода();
	ТекстПрограммы = ФормаТекста.ОткрытьМодально();
	Если ПустаяСтрока(ТекстПрограммы) Тогда
		Возврат Неопределено;
	КонецЕсли;
	АнализаторФрагментаКода.ЗаполнитьЛокальныеСвойстваИМетодыПоТексту(,,,,, ТекстПрограммы,, Истина);
	ИменаПараметров = Новый Массив;
	Для Каждого Строка Из АнализаторФрагментаКода.ТаблицаСлов Цикл
		Если Истина
			И Строка.Частота > 0
			И АнализаторФрагментаКода.ТаблицаЛокальногоКонтекста().НайтиСтроки(Новый Структура("НИмя", Строка.НСлово)).Количество() 
			И (Ложь
				Или ЕстьПеременнаяРезультат
				Или Строка.НСлово <> "результат")
		Тогда
			ИменаПараметров.Добавить(Строка.Слово);
		КонецЕсли;
	КонецЦикла;
	ИменаПараметров = ирОбщий.СтрСоединитьЛкс(ИменаПараметров);
	Результат = Новый Структура;
	Результат.Вставить("Текст", СокрЛП(ТекстПрограммы));
	Результат.Вставить("ИменаПараметров", ИменаПараметров);
	Возврат Результат;
	
КонецФункции

// Вызывается из адаптера
Функция КодОчисткиПеременныхДляОтладчика() Экспорт
	
	Если мМетодМодуля = Неопределено Тогда
		НоваяПозиция = СтрДлина(мОригинальныйТекст);
	Иначе
		НоваяПозиция = мМетодМодуля.ПозицияОпределения+мМетодМодуля.ДлинаОпределения;
	КонецЕсли;
	УстановитьГраницыВыделения(НоваяПозиция, НоваяПозиция);
	КончитьОбработкуКоманды();
	ЗаполнитьТаблицуСлов(, Ложь,, Ложь, Ложь);
	ИменаПараметров = Новый Массив;  
	МаксЧислоПараметровОперировать = ирОбщий.МаксЧислоПараметровОперироватьЛкс();
	Для Каждого СтрокаСлова Из ТаблицаСлов.НайтиСтроки(Новый Структура("ТипСлова", "Свойство")) Цикл
		Если Ложь
			Или СтрокаСлова.Определение = "Статистический" 
			Или СтрокаСлова.Определение = "Локальный"
		Тогда
			ИменаПараметров.Добавить(СтрокаСлова.Слово);
		КонецЕсли;
		Если ИменаПараметров.Количество() = МаксЧислоПараметровОперировать Тогда
			// Можно вывести уведомление
			Прервать;
		КонецЕсли;
	КонецЦикла;
	ТекстПрограммы = ирОбщий.СтрСоединитьЛкс(ИменаПараметров, Символы.ПС,,, "Попытка %1=Неопределено Исключение КонецПопытки;");
	Результат = Новый Структура;
	Результат.Вставить("Текст", 
	"Попытка ОтменитьТранзакцию() Исключение КонецПопытки;
	|" + СокрЛП(ТекстПрограммы));
	Результат.Вставить("ИменаПараметров", ирОбщий.СтрСоединитьЛкс(ИменаПараметров));
	Возврат Результат;
	
КонецФункции

Процедура УстановитьТекущуюПозициюВКонецТекста() Экспорт
	УстановитьГраницыВыделения(СтрДлина(мОригинальныйТекст) + 1, СтрДлина(мОригинальныйТекст) + 1);
КонецПроцедуры

// .
// Параметры:
//   Слово - Строка, Неопределено - 
//   ЛиМетод - Булево, Неопределено - 
//   КлючНабораСлов - Строка - 
// Возвращаемое значение:
//   СтрокаТаблицыЗначений, ОбработкаТабличнаяЧастьСтрока.ирКлсПолеТекстаПрограммы.ТаблицаСлов - в случае СтрокаТаблицыЗначений колонка НСлово отсутствует!
Функция СтрокаСловаИзСловаИНабора(Знач Слово, Знач ЛиМетод, Знач КлючНабораСлов) Экспорт
	Если ЗначениеЗаполнено(КлючНабораСлов) Тогда
		ТаблицаПоиска = мНаборыСлов[КлючНабораСлов];
		Если ТаблицаПоиска = Неопределено Тогда
			Возврат Неопределено;
		КонецЕсли;
	Иначе
		ТаблицаПоиска = ТаблицаСлов;
	КонецЕсли;
	НайденныеСтроки = ТаблицаПоиска.НайтиСтроки(Новый Структура("Слово", Слово));
	Для Каждого НайденнаяСтрока Из НайденныеСтроки Цикл
		Если Ложь
			Или ЛиМетод = Неопределено
			Или НайденнаяСтрока.ТипСлова = "Метод" И ЛиМетод
			Или НайденнаяСтрока.ТипСлова <> "Метод" И Не ЛиМетод
		Тогда
			СтрокаТаблицыСлов = НайденнаяСтрока;
			Прервать;
		КонецЕсли;
	КонецЦикла;
	Возврат СтрокаТаблицыСлов;
КонецФункции
 
// Устанавливает текст модуля. В статическом модуле обновляет текст в кэше!
//
// Параметры:
//  Текст						 - Строка, Неопределено - "Неопределено" не меняет текст поля
//  Активировать				 - 	 - 
//  НачальныйТекстДляСравнения	 - 	 - 
//  СохранитьГраницыВыделения	 - 	 - 
//  ПолноеИмя	 - Строка - например Обработка.ирКонсольЗапросов.МодульОбъекта
// 
Процедура УстановитьТекст(Знач Текст = Неопределено, Знач Активировать = Ложь, Знач НачальныйТекстДляСравнения = Неопределено, Знач СохранитьГраницыВыделения = Ложь, Знач ИмяМодуляСжатое = Неопределено,
	Знач ИмяМодуля = Неопределено, Знач НовоеНачалоВыделения = 0, Знач НовоеКонецВыделения = 0) Экспорт
	
	#Если Сервер И Не Сервер Тогда
		мПлатформа = Обработки.ирПлатформа.Создать();
	#КонецЕсли
	//Если Текст = Неопределено Тогда 
	//	// Пробовал так передавать из адаптера для ускорения. Эффекта не дало.
	//	Текст = мСтарыйОригинальныйТекст; 
	//	СлужебноеПолеТекстаДолгое.УстановитьТекст(Текст);
	//КонецЕсли;
	Если Текст <> Неопределено Тогда 
		ПолеТекста.УстановитьТекст(Текст, Активировать, НачальныйТекстДляСравнения, СохранитьГраницыВыделения);
	КонецЕсли;
	Если ЗначениеЗаполнено(НовоеКонецВыделения) Тогда
		УстановитьГраницыВыделения(НовоеНачалоВыделения, НовоеКонецВыделения,,, Ложь);
	Иначе 
		НовоеКонецВыделения = мПозицияВТексте;
	КонецЕсли;
	Если мЭтоФрагментМетода Тогда
		Возврат;
	КонецЕсли;
	ОчиститьТаблицуСловЛокальногоКонтекста();
	мФлагиКомпиляции = мПлатформа.НовыеФлагиКомпиляции();
	мКорневаяТаблицаТипов = Неопределено;
	мПлатформа.ПроверитьОбновитьКэш();
	Если Истина
		И Не ЗначениеЗаполнено(ИмяМодуляСжатое) 
		И (Ложь
			Или ПустаяСтрока(ИмяМодуля)
			Или ИмяМодуля = мПлатформа.ИмяДинамическогоМодуля())
	Тогда
		ОчиститьИсториюПереходов();
		Если ИмяМодуля <> мПлатформа.ИмяДинамическогоМодуля() Тогда 
			мМодульМетаданных = Неопределено; // Чтобы пересоздался мМодульМетаданных, иначе передача текста без указания имени модуля может перезаписать чужой текст модуля в кэше
		КонецЕсли;
		ОбновитьМодульМетаданных(Текст); 
		Возврат;
	КонецЕсли;
	#Если Сервер И Не Сервер Тогда
		мПлатформа = Обработки.ирПлатформа.Создать();
	#КонецЕсли
	Если ИмяМодуля <> Неопределено И ИмяМодуляСжатое = Неопределено Тогда
		ИмяМодуляСжатое = ИмяМодуля;
		Если мПлатформа.ЛиИмяМодуляФормы(ИмяМодуляСжатое) Тогда
			ИмяМодуляСжатое = ирОбщий.СтрокаБезПоследнегоФрагментаЛкс(ИмяМодуляСжатое, ".Форма.Модуль");
			ИмяМодуляСжатое = СтрЗаменить(ИмяМодуляСжатое, ".Форма.", ".");
		КонецЕсли;
		Если ирОбщий.СтрНачинаетсяСЛкс(ИмяМодуляСжатое, "Конфигурация.") Тогда
			ИмяМодуляСжатое = СтрЗаменить(ИмяМодуляСжатое, "Конфигурация.", "");
		КонецЕсли;
		ИмяМодуляСжатое = СтрЗаменить(ИмяМодуляСжатое, " Конфигурация.", " ");
	КонецЕсли;
	Фрагменты = ирОбщий.СтрРазделитьЛкс(ИмяМодуляСжатое, "::");
	ИмяМодуля = ИмяМодуляСжатое;    
	Если Фрагменты.Количество() > 1 Тогда
		// Внешняя обработка/отчет
		ИмяФайла = Фрагменты[1];
		ТипМодуля = Фрагменты[2];
		//КлючПоиска = Новый Структура;
		//КлючПоиска.Вставить("БазовыйТип", ИмяОбщегоТипа + "Объект");
		//КлючПоиска.Вставить("ЯзыкПрограммы", 0);
		//ИмяОбщегоТипа = мПлатформа.ТаблицаОбщихТипов.НайтиСтроки(КлючПоиска)[0].Слово;
		ОшибкаКомпиляции = "";
		СтруктураТипа = мКэшМетаданныхФайлов[ИмяФайла];
		Если СтруктураТипа <> Неопределено Тогда
			МенеджерОбъекта = СтруктураТипа.ДержательМетаданных;
			Если МенеджерОбъекта <> Неопределено Тогда
				ОбъектМД = МенеджерОбъекта.Метаданные();
			КонецЕсли;
		Иначе
			Попытка
				МенеджерОбъекта = ирОбщий.МенеджерВнешнегоОбъектаЛкс(ИмяФайла);
				ОбъектМД = МенеджерОбъекта.Метаданные();
			Исключение
				ОбъектМД = Новый Структура("Имя", "Нескомпилированный");
				ОшибкаКомпиляции = ОписаниеОшибки(); // Для отладки
				Если Найти(ИмяФайла, ирКлиент.ПрефиксИмениФайлаСлужебнойВнешнейОбработкиЛкс()) = 0 Тогда
					КаталогРаспаковки = ПолучитьИмяВременногоФайла();
					СоздатьКаталог(КаталогРаспаковки);
					мПлатформа.РаспаковатьФайлВнешнейОбработки(ИмяФайла, КаталогРаспаковки);
					ТекстовыйДокумент = новый ТекстовыйДокумент;
					Для Каждого Файл Из НайтиФайлы(КаталогРаспаковки, "text.data", Истина) Цикл
						ТекстовыйДокумент.Записать(Файл.ПолноеИмя);
					КонецЦикла;
					ИмяВременногоФайла = ПолучитьИмяВременногоФайла("epf");
					мПлатформа.УпаковатьФайлВнешнейОбработки(КаталогРаспаковки, ИмяВременногоФайла);
					УдалитьФайлы(КаталогРаспаковки);
					Попытка
						МенеджерОбъекта = ирОбщий.МенеджерВнешнегоОбъектаЛкс(ИмяВременногоФайла);
						ОбъектМД = МенеджерОбъекта.Метаданные();
					Исключение
						ОшибкаКомпиляции = ОписаниеОшибки(); // Для отладки
					КонецПопытки;
				КонецЕсли;
			КонецПопытки;
		КонецЕсли;
		Если ОбъектМД <> Неопределено Тогда
			ИмяМодуля = Фрагменты[0] + "::" + ИмяФайла + "::" + ОбъектМД.Имя;
		КонецЕсли;
		Если ирОбщий.СтрокиРавныЛкс(ТипМодуля, "МодульОбъекта") Тогда
			Если ЗначениеЗаполнено(ОшибкаКомпиляции) Тогда
				СтруктураТипа = мПлатформа.НоваяСтруктураТипа("ВнешняяОбработкаОбъект.<Имя внешней обработки>");
				СтруктураТипа.Метаданные = ОбъектМД;
			Иначе
				СтруктураТипа = мПлатформа.СтруктураТипаИзЗначения(МенеджерОбъекта);
			КонецЕсли;
			ТипМодуля = "МодульОбъекта";
			ИмяМодуля = ИмяМодуля + "." + ТипМодуля;
		Иначе                      
			ИмяОбщегоТипа = "Форма";
			ИмяМодуля = ИмяМодуля + "." + "Форма" + "." + ТипМодуля;
			Форма = мПлатформа.ПассивнаяФормаПоИмениКэш(ИмяМодуля);
			ТипМодуля = "Форма.Модуль";
			ИмяМодуля = ИмяМодуля + "." + ТипМодуля;
			Если ТипЗнч(Форма) = Тип("Структура") Тогда
				СтруктураТипа = мПлатформа.СтруктураТипаИзКонкретногоТипа(Форма.Тип);
				СтруктураТипа.Метаданные = Форма;
			ИначеЕсли Форма <> Неопределено Тогда
				СтруктураТипа = мПлатформа.СтруктураТипаИзЗначения(Форма);
			Иначе
				СтруктураТипа = мПлатформа.НоваяСтруктураТипа("Форма");
				СтруктураТипа.Метаданные = ОбъектМД; 
				//ТипМодуля = ИмяМодуля;
			КонецЕсли;
		КонецЕсли;   
		СтруктураТипа.ДержательМетаданных = МенеджерОбъекта;
		Если ЗначениеЗаполнено(ОшибкаКомпиляции) Тогда
			мКэшМетаданныхФайлов[ИмяФайла] = СтруктураТипа;
			Если ТипЗнч(ОбъектМД) <> Тип("Структура") Тогда
				Сообщение = "Ошибка создания редактируемой внешней обработки на клиенте с родным модулем объекта. Поэтому создана и закэширована ее копия без модуля. "
				+ "Для отключения кэширования окружите модуль инструкцией ""#Если Сервер Тогда"" и выполните сброс памятного кэша";
				Если мПлатформа.мОчередьСообщений <> Неопределено Тогда
					мПлатформа.мОчередьСообщений.Добавить(Сообщение);
				КонецЕсли;
			КонецЕсли;
		КонецЕсли;
	Иначе 
		ИмяРасширения = Неопределено;
		ФрагментыПробела = ирОбщий.СтрРазделитьЛкс(ИмяМодуляСжатое, " ");
		Если ФрагментыПробела.Количество() > 1 Тогда 
			ИмяРасширения = ФрагментыПробела[0];
			ИмяМодуля = ФрагментыПробела[1];
		КонецЕсли;
		Фрагменты = ирОбщий.СтрРазделитьЛкс(ИмяМодуля);
		ИмяОбщегоТипа = Фрагменты[0];
		ТипМодуля = "";
		Если Фрагменты.Количество() = 1 Тогда
			ОбъектМД = Неопределено;
			ИмяОбщегоТипа = "Глобальный";
			ТипМодуля = ИмяМодуля;
			ИмяМодуля = "Конфигурация";
		ИначеЕсли Ложь
			Или ИмяОбщегоТипа = "WebСервис"
			Или ИмяОбщегоТипа = "HttpСервис"
			Или ИмяОбщегоТипа = "ОбщийМодуль"
			Или ИмяОбщегоТипа = "ОбщаяКоманда"
		Тогда
			ОбъектМД = Метаданные[ирОбщий.МножественноеИмяМДЛкс(ИмяОбщегоТипа)].Найти(Фрагменты[1]);
		ИначеЕсли ИмяОбщегоТипа = "Команда" Тогда 
			// Конфигуратор оставил нам только полный перебор, т.к. не показывает имя родительского объекта в заголовке
			Для Каждого СтрокаТипаМетаданных Из ирКэш.ТипыМетаОбъектов(, Ложь, Ложь) Цикл
				Если СтрокаТипаМетаданных.Единственное = "Перерасчет" Тогда
					Продолжить;
				КонецЕсли;
				Для Каждого ОбъектМДЦикл Из Метаданные[СтрокаТипаМетаданных.Множественное] Цикл
					#Если Сервер И Не Сервер Тогда
						ОбъектМДЦикл = Метаданные.Обработки.ирКонсольЗапросов;
					#КонецЕсли
					Попытка
						Команды = ОбъектМДЦикл.Команды;
					Исключение
						Прервать;
					КонецПопытки;
					КомандаМД = Команды.Найти(Фрагменты[1]);
					Если КомандаМД <> Неопределено Тогда
						ОбъектМД = ОбъектМДЦикл;
						Перейти ~ВыходЦикла;
					КонецЕсли;
				КонецЦикла;
			КонецЦикла;   
			~ВыходЦикла:
			Если ОбъектМД <> Неопределено Тогда
				ИмяМодуля = ОбъектМД.ПолноеИмя() + "." + ИмяМодуля;
				Если КомандаМД <> Неопределено Тогда
					ОбъектМД = КомандаМД;
				КонецЕсли;
			КонецЕсли;
		ИначеЕсли ирОбщий.СтрокиРавныЛкс(Фрагменты[0], "ОбщаяФорма") Тогда
			ИмяОбщегоТипа = "Форма"; 
			ТипМодуля = "Форма.Модуль";
			ОбъектМД = Метаданные.ОбщиеФормы.Найти(Фрагменты[1]);
		Иначе
			ТипМодуля = Фрагменты[Фрагменты.ВГраница()];
			ИмяОбщегоТипа = Фрагменты[0];
			Если ИмяОбщегоТипа = "Таблица" Тогда 
				ИмяКорневогоТипа = "ВнешнийИсточникДанных";
				ИмяОбщегоТипа = ИмяКорневогоТипа + ИмяОбщегоТипа;
				// Конфигуратор оставил нам только полный перебор, т.к. не показывает имя родительского объекта в заголовке
				Для Каждого ВнешнийИсточникДанных Из Метаданные.ВнешниеИсточникиДанных Цикл
					ОбъектМД = ВнешнийИсточникДанных.Таблицы.Найти(Фрагменты[1]);
					Если ОбъектМД <> Неопределено Тогда 
						Фрагменты.Вставить(0, ВнешнийИсточникДанных.Имя);
						Фрагменты.Вставить(0, ИмяКорневогоТипа);
						Прервать;
					КонецЕсли;
				КонецЦикла;
			КонецЕсли;
			Если ирОбщий.СтрокиРавныЛкс(ТипМодуля, "МодульОбъекта") Тогда
				Подтип = "Объект";
			ИначеЕсли ирОбщий.СтрокиРавныЛкс(ТипМодуля, "МодульМенеджера") Тогда
				Подтип = "Менеджер";
			ИначеЕсли ирОбщий.СтрокиРавныЛкс(ТипМодуля, "МодульНабораЗаписей") Тогда
				Подтип = "НаборЗаписей";
			ИначеЕсли ирОбщий.СтрокиРавныЛкс(ТипМодуля, "МодульМенеджераЗначения") Тогда
				Подтип = "МенеджерЗначения";
			Иначе 
				ТипМодуля = "Форма.Модуль";
				Подтип = "";
			КонецЕсли;
			Если ЗначениеЗаполнено(Подтип) Тогда
				Фрагменты.Удалить(Фрагменты.ВГраница());
				КлючПоиска = Новый Структура;
				КлючПоиска.Вставить("БазовыйТип", ИмяОбщегоТипа + Подтип);
				КлючПоиска.Вставить("ЯзыкПрограммы", 0);
				ИмяОбщегоТипа = мПлатформа.ТаблицаОбщихТипов.НайтиСтроки(КлючПоиска)[0].Слово;
			Иначе
				ИмяОбщегоТипа = "Форма";
				Фрагменты.Вставить(Фрагменты.ВГраница(), ИмяОбщегоТипа);
			КонецЕсли;
			ИмяМодуля = ирОбщий.СтрСоединитьЛкс(Фрагменты, ".");
			ОбъектМД = Метаданные.НайтиПоПолномуИмени(ИмяМодуля);
		КонецЕсли;
		СтруктураТипа = мПлатформа.НоваяСтруктураТипа(ИмяОбщегоТипа);
		Если ОбъектМД = Неопределено Тогда 
			Если ИмяОбщегоТипа = "Форма" Тогда 
				СтруктураТипа.Метаданные = Новый Структура("ИмяФормы", ИмяМодуля);
			ИначеЕсли ИмяМодуля = "Конфигурация" Тогда
				СтруктураТипа.Метаданные = Неопределено; // Иначе в модулях приложения будет пустым список подсказки после "Справочники."
			Иначе
				СтруктураТипа.Метаданные = ИмяМодуля; // Нужно для добавленного общего модуля
			КонецЕсли;
		КонецЕсли;
		Если ИмяОбщегоТипа = "Форма" Тогда
			Форма = мПлатформа.ПассивнаяФормаПоИмениКэш(ИмяМодуля);
			Если Форма = Неопределено Тогда
				ОбъектМД = Неопределено;
			Иначе
				ОбъектМД = Форма;
			КонецЕсли;
			Если ТипЗнч(ОбъектМД) = Тип("Структура") Тогда
				СтруктураТипа = мПлатформа.СтруктураТипаИзКонкретногоТипа(ОбъектМД.Тип);
			ИначеЕсли ТипЗнч(ОбъектМД) <> ТипЗнч(Метаданные) Тогда
				СтруктураТипа = мПлатформа.СтруктураТипаИзЗначения(ОбъектМД);
			КонецЕсли;
		КонецЕсли;
		Если ОбъектМД <> Неопределено Тогда
			СтруктураТипа.Метаданные = ОбъектМД;
		КонецЕсли;      
		Если ЗначениеЗаполнено(ТипМодуля) Тогда
			ИмяМодуля = ИмяМодуля + "." + ТипМодуля;
		КонецЕсли;
		СтруктураТипа.ДержательМетаданных = ИмяРасширения;
	КонецЕсли; 
	мМодульМетаданных = мПлатформа.ПодготовитьМодульМетаданных(СтруктураТипа, ТипМодуля,, Текст, НовоеКонецВыделения);
	Если Текст <> Неопределено И мСтарыйОригинальныйТекст <> Текст Тогда
		мСтарыйОригинальныйТекст = Текст;
		СлужебноеПолеТекстаДолгое.УстановитьТекст(Текст);
		КончитьОбработкуКоманды();
	КонецЕсли;
	мФлагиКомпиляции = ирОбщий.СкопироватьКоллекциюЛкс(мМодульМетаданных.ФлагиКомпиляции);
	Если ТипЗнч(СтруктураТипа.ДержательМетаданных) = Тип("Строка") Тогда
		ИмяМодуля = СтруктураТипа.ДержательМетаданных + " " + ИмяМодуля;
	КонецЕсли;
	Если ЗначениеЗаполнено(мИмяМодуля) И мИмяМодуля <> ИмяМодуля Тогда
		ОчиститьИсториюПереходов();
		мПлатформа.СброситьКэшиТиповВыраженийМодулей(мИмяМодуля);
	КонецЕсли;
	мИмяМодуля = ИмяМодуля;             

КонецПроцедуры

Процедура ПрочитатьТекстИзФайлаБезМетаданных(Знач ИмяФайла) Экспорт 
	ПолеТекста.Прочитать(ИмяФайла);
	мСтарыйОригинальныйТекст = ПолеТекста.ПолучитьТекст();
	мОригинальныйТекст = мСтарыйОригинальныйТекст;
КонецПроцедуры 

Процедура УстановитьТекстБезМетаданных(Знач Текст) Экспорт 
	Если Текст = мСтарыйОригинальныйТекст Тогда
		Возврат;
	КонецЕсли;
	ПолеТекста.УстановитьТекст(Текст);
	мСтарыйОригинальныйТекст = Текст;
	мОригинальныйТекст = Текст;
КонецПроцедуры

// Вызывается из адапатера.
// Возвращаемое значение:
//    Дата, Неопределено - 
Функция ДатаОбновленияСтруктурыФормыМодуля() Экспорт
	Результат = Неопределено;
	Если мМодульМетаданных <> Неопределено Тогда
		СтруктураТипа = мМодульМетаданных.СтруктураТипа;
		Если Истина
			И СтруктураТипа <> Неопределено 
			И ирОбщий.ЛиИмяТипаФормыЛкс(СтруктураТипа.ИмяОбщегоТипа) 
		Тогда 
			СлужебныеДанные = ирОбщий.СлужебныеДанныеФормыЛкс(СтруктураТипа.Метаданные);
			Если СлужебныеДанные.Тип = ирОбщий.ТипУправляемаяФормаЛкс() Тогда
				Результат = ирОбщий.СвойствоСтруктурыЛкс(СлужебныеДанные, "ДатаОбновления", Дата(1,1,1));
			КонецЕсли;
		КонецЕсли;
	КонецЕсли;
	Возврат Результат;
КонецФункции

// Вызывается из адапатера.
Функция РазмерСтатистикиВыбора() Экспорт
	Возврат мПлатформа.ТаблицаСтатистикиВыбора.Количество();
КонецФункции

Процедура ОткрытьПроверкуМодуля(ПараметрИмяМетода = "") Экспорт 
	Если Не ЗначениеЗаполнено(ПараметрИмяМетода) И мМетодМодуля <> Неопределено Тогда
		ПараметрИмяМетода = мМетодМодуля.Имя
	КонецЕсли;
	Форма = ПолучитьФорму("ОшибкиМодуля");
	Форма.ПараметрМодуль = мМодульМетаданных.Имя;
	Если ПараметрИмяМетода <> Неопределено Тогда
		Форма.ПараметрИмяМетода = ПараметрИмяМетода;
	КонецЕсли;
	Форма.Открыть();
КонецПроцедуры

// Процедура - Проверить выражения после точки
//
// Параметры:
//  ТабличноеПоле	 - ТабличноеПоле - 
//  Форма			 - 				 - 
//  ПолныйПерерасчет - 				 - 
// 
// Возвращаемое значение:
//  Булево - были ли обнаружены новые ошибки
//
Функция ПроверитьВыраженияТекста(Знач ТабличноеПоле = Неопределено, Форма = Неопределено, Знач ПолныйПерерасчет = Ложь, Знач ПроверятьВсеЛитералы = Ложь) Экспорт
	мПлатформа.СброситьКэшТиповВыраженийМодуля(мМодульМетаданных);
	ОшибкиМодуля.Очистить();
	мПлатформа.мРежимПроверкиМодуля = Истина; 
	ирКлиент.ПодключитьГлобальныйОбработчикОжиданияЛкс("ОтключитьРежимПроверкиМодуляЛкс");
	Если ПолныйПерерасчет Тогда 
		мМодульМетаданных.Методы.ЗаполнитьЗначения(Неопределено, "ЕстьОшибки");
	ИначеЕсли мМодульМетаданных.Ошибки <> Неопределено Тогда
		ОшибкиМодуля.Загрузить(мМодульМетаданных.Ошибки);
	КонецЕсли;
	мПлатформа.УдалитьОшибкиМетода(, ОшибкиМодуля);
	Если ТабличноеПоле <> Неопределено Тогда
		ТабличноеПоле.ОбновитьСтроки();
	КонецЕсли;
	ИнициироватьРекурсивныйПуть();
	КончитьОбработкуКоманды();
	РазобратьТекущийКонтекст();
	ПрочитатьНачалоИКонецТекущейСтроки("");
	ПараметрМетод = ИмяТекущегоМетода();
	НачальнаяПозицияТекущегоМетода = мПозицияТекстаДляПоискаОпределения;
	КонечнаяПозицияТекущегоМетода = мПозицияТекстаДляПоискаОпределения + СтрДлина(мТекстБлока);
	НачальноеКоличество = ОшибкиМодуля.Количество();
	СтруктураОбновленияТабличногПоля = ирКлиент.СтрукутраПервогоОбновленияТабличногоПоляЛкс();
	ВложенныеВыраженияШаблон = ирОбщий.НоваяТаблицаЗначенийЛкс("Выражение, Позиция0ВБлоке, ВызовМетода");
	мРегВыражение.Global = Истина;
	мРегВыражение.Pattern = шПроверяемоеВыражение;
	Вхождения = мРегВыражение.НайтиВхождения(мОригинальныйТекст);
	Для Этап = 1 По 2 Цикл
		Если Этап = 1 Тогда
			ДобавкаПредставления = "метода";
		Иначе 
			ДобавкаПредставления = "модуля";
		КонецЕсли;
		Индикатор = ирОбщий.ПолучитьИндикаторПроцессаЛкс(Вхождения.Количество(), "Проверка " + ДобавкаПредставления);
		ПроверитьВыраженияУровня(Вхождения, ПроверятьВсеЛитералы, ТабличноеПоле, Форма, Индикатор, КонечнаяПозицияТекущегоМетода, НачальнаяПозицияТекущегоМетода,
			СтруктураОбновленияТабличногПоля, Этап, ВложенныеВыраженияШаблон);
		ирОбщий.ОсвободитьИндикаторПроцессаЛкс();
		Если Этап = 1 И ТабличноеПоле <> Неопределено Тогда
			ТабличноеПоле.ОбновитьСтроки();
		КонецЕсли;
	КонецЦикла;
	Если ТабличноеПоле <> Неопределено И НачальноеКоличество > 0 Тогда
		ТабличноеПоле.ВыделенныеСтроки.Очистить();
		Для Счетчик = НачальноеКоличество + 1 По ОшибкиМодуля.Количество() Цикл
			ТабличноеПоле.ВыделенныеСтроки.Добавить(ОшибкиМодуля[Счетчик - 1]);
		КонецЦикла;
		Если ТабличноеПоле.ВыделенныеСтроки.Количество() > 0 Тогда
			ТабличноеПоле.ТекущаяСтрока = ТабличноеПоле.ВыделенныеСтроки[0];
		КонецЕсли;
	КонецЕсли;
	//Если Не ПолныйПерерасчет Тогда
		ОшибкиМодуля.Сортировать("Метод, Позиция");
	//КонецЕсли;
	мРекурсивныйПуть = Неопределено;
	мМодульМетаданных.Ошибки = ОшибкиМодуля.Выгрузить();
	мМодульМетаданных.Ошибки.Колонки.Удалить("Ссылка");
	мМодульМетаданных.Ошибки.Колонки.Удалить("НомерСтрокиМетода");
	мМодульМетаданных.Ошибки.Колонки.Удалить("НомерСтрокиМодуля");
	мМодульМетаданных.Методы.ЗаполнитьЗначения(Ложь, "ЕстьОшибки");
	Для Каждого Метод Из ирОбщий.РазличныеЗначенияКолонкиТаблицыЛкс(ОшибкиМодуля, "Метод") Цикл 
		СтрокаМетода = мМодульМетаданных.Методы.Найти(Метод, "Имя");
		Если СтрокаМетода <> Неопределено Тогда
			СтрокаМетода.ЕстьОшибки = Истина;
		КонецЕсли;
	КонецЦикла;
	Если Форма <> Неопределено Тогда
		Форма.КоличествоНайдено = ОшибкиМодуля.Количество();
	Иначе
		Если ОшибкиМодуля.Количество() > 0 Тогда
			ОткрытьПроверкуМодуля(ПараметрМетод); 
		КонецЕсли;
	КонецЕсли;
	Возврат НачальноеКоличество < ОшибкиМодуля.Количество();
КонецФункции

// Рекурсивная.
// Параметры:
//    ТабличноеПоле - ТабличноеПоле  -  
//    Форма - см. Обработка.ирКлсПолеТекстаПрограммы.Форма.ОшибкиМодуля -  
//    ПроверятьВсеЛитералы - Булево - 
//    ВложенныеВыраженияШаблон - ТаблицаЗначений - 
//    Вхождения - Массив из ОбработкаОбъект.ирОболочкаРегВхождение - 
//    ДлинаДобавкиОкрестности - Число - 
//    Индикатор - СтрокаТаблицыЗначений, Структура - 
//    ИнструкцияПодавленияПроверки - Строка - 
//    КонечнаяПозицияТекущегоМетода - Неопределено - 
//    НачальнаяПозицияТекущегоМетода - Неопределено - 
//    СтруктураОбновленияТабличногПоля - Структура - 
//    Этап - Число - 
Функция ПроверитьВыраженияУровня(Знач Вхождения, Знач ПроверятьВсеЛитералы = Ложь, Знач ТабличноеПоле = Неопределено, Знач Форма = Неопределено, Знач Индикатор = Неопределено,
	Знач КонечнаяПозицияТекущегоМетода = Неопределено, Знач НачальнаяПозицияТекущегоМетода = Неопределено, Знач СтруктураОбновленияТабличногПоля = Неопределено, Знач Этап = 0,
	Знач ВложенныеВыраженияШаблон, Знач СмещениеВБлоке = 0, Знач НачалоБлока = Неопределено, Знач ДлинаДобавкиОкрестности = 120) Экспорт

	ИнструкцияПодавленияНеизвестноеСлово = ИнструкцияПодавленияПроверки();
	ИнструкцияПодавленияМалоПараметров = ИнструкцияПодавленияПроверки("МалоПараметров");
	ИнструкцияПодавленияМногоПараметров = ИнструкцияПодавленияПроверки("МногоПараметров");
	Счетчик = 0;
	Если НачалоБлока = Неопределено Тогда
		НачалоБлока = мПозицияТекстаДляПоискаОпределения - 1;
	КонецЕсли;
	Для Каждого Вхождение Из Вхождения Цикл
		//МоментНачала = ирОбщий.ТекущееВремяВМиллисекундахЛкс();
		Если Этап > 0 Тогда
			// Это НЕ вложенная проверка
			ЛиВТекущемМетоде = Не ЛиВхождениеВЗапрешенномДиапазоне(Вхождение, НачальнаяПозицияТекущегоМетода, КонечнаяПозицияТекущегоМетода);
			Если Ложь
				Или Этап = 1 И Не ЛиВТекущемМетоде 
				Или Этап = 2 И ЛиВТекущемМетоде
			Тогда 
				Продолжить;
			КонецЕсли;
		КонецЕсли;
		Счетчик = Счетчик + 1;
		ВыражениеЛитерала = Вхождение.SubMatches(0);
		ВыражениеСТочкой = Вхождение.SubMatches(3);
		Если ВыражениеСТочкой = Неопределено И ВыражениеЛитерала = Неопределено Тогда
			Продолжить;
		КонецЕсли;
		Если Этап > 0 Тогда
			Если ирОбщий.ОбработатьИндикаторЛкс(Индикатор, Счетчик) Тогда 
				Если Форма <> Неопределено Тогда
					Форма.КоличествоНайдено = ОшибкиМодуля.Количество();
				КонецЕсли;
			КонецЕсли;
			ПредФрагмент = Сред(мОригинальныйТекст, Вхождение.FirstIndex - ДлинаДобавкиОкрестности, ДлинаДобавкиОкрестности);
			ПостФрагмент = Сред(мОригинальныйТекст, Вхождение.FirstIndex + Вхождение.Length, ДлинаДобавкиОкрестности); 
			Если Истина
				И Найти(ПредФрагмент, Символы.Таб + "Попытка") > 0 
				И Найти(ПостФрагмент, Символы.Таб + "Исключение") > 0
			Тогда
				// Узкие вычисления в попытке обычно подразумевают возможность обращения к неизвестному слову
				Продолжить;
			КонецЕсли;
			мФлагиПодавленияОшибок = Новый Структура;
			ПервыйПостФрагмент = ирОбщий.ПервыйФрагментЛкс(ПостФрагмент, Символы.ПС);
			Если Найти(ПервыйПостФрагмент, ИнструкцияПодавленияНеизвестноеСлово) > 0 Тогда
				мФлагиПодавленияОшибок.Вставить("НеизвестноеСлово");
			КонецЕсли; 
			ЛиВнутриНевыполнимогоКода = Истина
				И Найти(ПредФрагмент, "#Если Сервер И Не Сервер") > 0 
				И Найти(ПостФрагмент, "#КонецЕсли") > 0;
			Если Ложь
				Или ЛиВнутриНевыполнимогоКода
				Или Найти(ПервыйПостФрагмент, ИнструкцияПодавленияМалоПараметров) > 0
			Тогда
				мФлагиПодавленияОшибок.Вставить("МалоПараметров");
			КонецЕсли;
			Если Ложь
				Или ЛиВнутриНевыполнимогоКода
				Или Найти(ПервыйПостФрагмент, ИнструкцияПодавленияМногоПараметров) > 0
			Тогда
				мФлагиПодавленияОшибок.Вставить("МногоПараметров");
			КонецЕсли;
		КонецЕсли;
		ПозицияВхождения0ВМодуле = СмещениеВБлоке + Вхождение.FirstIndex + СтрДлина(Вхождение.SubMatches(1));
		Если Этап > 0 Тогда
			Если ЗагрузитьМетодМодуляПоПозиции(ПозицияВхождения0ВМодуле) Тогда
				НачалоБлока = мПозицияТекстаДляПоискаОпределения - 1;
			КонецЕсли;
			Если мМетодМодуля <> Неопределено И мМетодМодуля.ЕстьОшибки <> Неопределено Тогда
				Продолжить;
			КонецЕсли;
		Иначе
			ПозицияВхождения0ВМодуле = ПозицияВхождения0ВМодуле + НачалоБлока - 1;
		КонецЕсли;
		ПозицияВхождения0ВБлоке = ПозицияВхождения0ВМодуле - НачалоБлока + 1;
		мЭтоТекстовыйЛитерал = Ложь;
		//мТекстДляПоискаОпределения = "";
		Если ВыражениеЛитерала <> Неопределено Тогда 
			ЧислоСтрок = СтрЧислоСтрок(ВыражениеЛитерала);
			ЛиНачинаетсяСКавычки = Лев(ВыражениеЛитерала, 1) = """";
			Если Не ЛиНачинаетсяСКавычки Тогда
				ВыражениеЛитерала = СокрЛ(Сред(ВыражениеЛитерала, 2));
			КонецЕсли;
			ПоследнийСимвол = Прав(ВыражениеЛитерала, 1);
			ЛиКончаетсяНаКавычки = ПоследнийСимвол = """";
			Если Не ЛиКончаетсяНаКавычки Тогда
				ТокенПослеЛитерала = ПоследнийСимвол;
				ВыражениеЛитерала = СокрП(ирОбщий.СтрокаБезКонцаЛкс(ВыражениеЛитерала));
			Иначе
				ТокенПослеЛитерала = "";
			КонецЕсли;
			Если Истина
				И ЧислоСтрок = 1 
				И (Ложь
					Или Найти(ВыражениеЛитерала, ".") > 0 
					Или Этап = 1
					Или ПроверятьВсеЛитералы)
				//И Найти(ВыражениеЛитерала, ",") = 0
				//И Найти(ВыражениеЛитерала, " ") = 0
				И Найти(ВыражениеЛитерала, ". ") = 0
				И Найти(ВыражениеЛитерала, "%") = 0
				И ЛиНачинаетсяСКавычки
				И ЛиКончаетсяНаКавычки
				И СтрДлина(ВыражениеЛитерала) > 1
			Тогда
				ФильтроватьСлово = Неопределено;
				ТекстЛитерала = ирОбщий.ТекстИзВстроенногоЯзыкаЛкс(ВыражениеЛитерала);
				Если Найти(ТекстЛитерала, ",") > 0 Тогда
					СловаЛитерала = ирОбщий.СтрРазделитьЛкс(ТекстЛитерала, ",", Истина);
				Иначе
					СловаЛитерала = Новый Массив;
					СловаЛитерала.Добавить(ТекстЛитерала);  
					Если Найти(ТекстЛитерала, " ") = 0 Тогда
						ФильтроватьСлово = ТекстЛитерала;
					КонецЕсли;
				КонецЕсли;
				мЭтоТекстовыйЛитерал = Истина; 
				мНомерПараметра = 0;
				НетТочки = Найти(ТекстЛитерала, ".") = 0;
				Если Истина
					И НетТочки
					И ирОбщий.ЛиИмяПеременнойЛкс(ирОбщий.ПервыйФрагментЛкс(СловаЛитерала[0], " ")) // отделяем пробелом на случай Сортировать()
				Тогда
					ПолеТекста.УстановитьГраницыВыделения(ПозицияВхождения0ВМодуле + 2, ПозицияВхождения0ВМодуле + 2);
					//КончитьОбработкуКоманды();
					//РазобратьТекущийКонтекст(,, Истина,,,, ПозицияВхождения0ВМодуле + 2);
					ПолучитьГраницыВыделения();
					ПрочитатьНачалоИКонецТекущейСтроки("");
					РазобратьКонтекстСтроки(,, Истина);
				КонецЕсли;  
				ПозицияВхождения0ВБлоке = ПозицияВхождения0ВБлоке - 1;
				ТаблицаТипов = ДобавитьВозможнуюОшибкуПослеТочки(ВложенныеВыраженияШаблон, СловаЛитерала[0], ПозицияВхождения0ВБлоке, ПроверятьВсеЛитералы, НачалоБлока);
				Если Истина
					И мНомерПараметра > 0
					И НетТочки 
					И ТаблицаТипов.Количество() > 0
				Тогда
					ИмяВызывающегоМетода = ИмяТекущегоМетода();
					ВызовМетода = мВызовМетода;
					ЛиВызовСортировки = ирОбщий.СтрКончаетсяНаЛкс(НРег(ВызовМетода), "сортировать(");
					СтрокаОписания = ТаблицаТипов[0].СтрокаОписания;
					РекурсивныйПуть = мРекурсивныйПуть;
					мРекурсивныйПуть = Неопределено;
					мПозицияВТексте = ПозицияВхождения0ВМодуле + 2;
					мПозицияВБлоке = ПозицияВхождения0ВБлоке; 
					Если ТаблицаТипов[0].ТипЯзыка = "ИмяТипа" И СловаЛитерала.Количество() = 1 Тогда
						// Для ускорения
						СтрокаСлова = ТаблицаСлов.Добавить();
						СтрокаСлова.НСлово = НРег(ТаблицаТипов[0].ИмяОбщегоТипа);
					Иначе
						ЗаполнитьТаблицуСлов(ТаблицаТипов.Скопировать(), Ложь,, Ложь, Ложь,,, ФильтроватьСлово);
					КонецЕсли;
					мРекурсивныйПуть = РекурсивныйПуть;
					Если мМетодМодуля = Неопределено Тогда
						СмещениеПозицииВЛитерале = 1; // Для консоли кода
					Иначе
						СмещениеПозицииВЛитерале = 0;
					КонецЕсли;
					Для Каждого Слово Из СловаЛитерала Цикл
						Если ЛиВызовСортировки Тогда
							Слово = ирОбщий.ПервыйФрагментЛкс(Слово, " ");
						КонецЕсли;
						Если Истина
							И ТаблицаСлов.Количество() > 0
							И ТаблицаСлов.Найти(НРег(Слово), "НСлово") = Неопределено
						Тогда
							Если СловаЛитерала.Количество() > 1 Тогда
								СмещениеПозицииВЛитерале = Найти(ТекстЛитерала + ",", Слово + ",") - 1;
							КонецЕсли;
							СтрокаОшибки = ДобавитьОшибкуМодуля(ПозицияВхождения0ВБлоке + 1 + СмещениеПозицииВЛитерале);
							СтрокаОшибки.Метод = ИмяВызывающегоМетода;
							СтрокаОшибки.ВыражениеРодитель = ВызовМетода;
							Если ТипЗнч(СтрокаОписания) = Тип("СтрокаТаблицыЗначений") Тогда
								Если СтрокаОписания.Владелец().Колонки.Найти("ТипКонтекста") <> Неопределено Тогда
									Если СтрокаОписания.ТипСлова = "Метод" Тогда
										СтрокаОшибки.ТипРодителя = СтрокаОписания.ТипКонтекста + "." + СтрокаОписания.Слово + "("; 
									//Иначе
									//	СтрокаОшибки.ТипРодителя = "(" + СтрокаОписания.ТипЯзыка;
									КонецЕсли;
								Иначе 
									СтрокаОшибки.ТипРодителя = СтрокаОписания.Имя + "("; 
									Если СтрокаОписания.ИмяМодуля <> мМодульМетаданных.Имя Тогда
										СтрокаОшибки.ТипРодителя = СтрокаОписания.ИмяМодуля + "." + СтрокаОшибки.ТипРодителя;
									КонецЕсли;
								КонецЕсли;
								СтрокаОшибки.ТипРодителя = СтрокаОшибки.ТипРодителя + "<" + ИмяПараметраВызоваМетода(СтрокаОписания) + ">)";
							КонецЕсли;
							СтрокаОшибки.Слово = Слово;
							Если мМетодМодуля = Неопределено Тогда
								СтрокаОшибки.ПозицияВМетоде = СтрокаОшибки.ПозицияВМетоде - 1;
							КонецЕсли;
							СтрокаОшибки.Язык = "Литерал";
						КонецЕсли;
					КонецЦикла;
				КонецЕсли;
			ИначеЕсли Истина
				И ЧислоСтрок > 1 
				//И ирОбщий.СтрНачинаетсяСЛкс(ВыражениеЛитерала, """ВЫБРАТЬ")
			Тогда
				ТекстЛитерала = ирОбщий.ТекстИзВстроенногоЯзыкаЛкс(ВыражениеЛитерала);
				Если ирОбщий.ЛиТекстЯзыкаЗапросовЛкс(ТекстЛитерала) Тогда
					мНачальнаяПозиция0ВложенногоТекста = ПозицияВхождения0ВМодуле + 1;
					УстановитьГраницыВыделения(мНачальнаяПозиция0ВложенногоТекста, мНачальнаяПозиция0ВложенногоТекста);
					РазобратьКонтекстЗапросаВТекстовомЛитерале(ВыражениеЛитерала, ТекстЛитерала, Ложь);
					СчетчикЗапроса = 0; 
					мРегВыражение.Global = Истина;
					НадоВосстановитьМетод = Ложь;
					мРегВыражение.Pattern = шПроверяемоеВыражение;
					ВхожденияЗапроса = мРегВыражение.НайтиВхождения(Сред(ВыражениеЛитерала, 2)); // Отрезаем первую кавычку
					ИндикаторЗапроса = ирОбщий.ПолучитьИндикаторПроцессаЛкс(ВхожденияЗапроса.Количество(), "Глубокая проверка запроса " + мНачальнаяПозиция0ВложенногоТекста);
					Для Каждого ВхождениеЗапроса Из ВхожденияЗапроса Цикл
						СчетчикЗапроса = СчетчикЗапроса + 1;
						Выражение = ВхождениеЗапроса.SubMatches(3);
						Если Выражение = Неопределено Тогда
							Продолжить;
						КонецЕсли;
						ирОбщий.ОбработатьИндикаторЛкс(ИндикаторЗапроса, СчетчикЗапроса);
						НадоВосстановитьМетод = Истина;
						ПозицияВхождения0ВБлоке = ВхождениеЗапроса.FirstIndex + СтрДлина(ВхождениеЗапроса.SubMatches(1)) + 1;
						ЗагрузитьЗапросПакетаМодуляПоПозиции(,, ПозицияВхождения0ВБлоке);
						//мТекстДляПоискаОпределения = мТекстБлока; 
						ПозицияВхождения0ВБлоке = ПозицияВхождения0ВБлоке - мПозицияТекстаДляПоискаОпределения + мНачальнаяПозиция0ВложенногоТекста + 1;
						ДобавитьВозможнуюОшибкуПослеТочки(ВложенныеВыраженияШаблон, Выражение, ПозицияВхождения0ВБлоке, ПроверятьВсеЛитералы, Неопределено);
						Если ТабличноеПоле <> Неопределено Тогда
							ирКлиент.ПроверитьПервоеОбновлениеТабличногоПоляЛкс(ТабличноеПоле, СтруктураОбновленияТабличногПоля, 20);
						КонецЕсли;
					КонецЦикла;
					ирОбщий.ОсвободитьИндикаторПроцессаЛкс();
					Если Истина
						И Найти(СокрЛП(ТекстЛитерала), Символы.ПС) > 0 // В тексте должно быть более одной строки
						И (Ложь
							Или ТокенПослеЛитерала = ""
							Или ТокенПослеЛитерала = ";")
					Тогда
						АнализаторЗапросов = ирКэш.ПолеТекстаПрограммы(1);
						ИнформацияОбОшибке = АнализаторЗапросов.ПроверитьТекстИВернутьОшибку(ТекстЛитерала,,,, Истина);
						Если ИнформацияОбОшибке <> Неопределено Тогда
							НомерСтроки = 1;
							ирКлиент.ЧистоеОписаниеОшибкиЛкс(ИнформацияОбОшибке,,,,,, НомерСтроки);
							АнализаторЗапросов.УстановитьТекст(ВыражениеЛитерала);
							АнализаторЗапросов.УстановитьГраницыВыделения(НомерСтроки, 1, НомерСтроки, 1);
							ПозицияВхождения0ВБлоке = АнализаторЗапросов.ПолеТекста.ВыделениеОдномерное().Конец;
							ЗагрузитьЗапросПакетаМодуляПоПозиции(,, ПозицияВхождения0ВБлоке);
							ПозицияВхождения0ВБлоке = ПозицияВхождения0ВБлоке - мПозицияТекстаДляПоискаОпределения + мНачальнаяПозиция0ВложенногоТекста + 1;
							ОшибкаМодуля = ДобавитьОшибкуМодуля(ПозицияВхождения0ВБлоке, "Встроенная");
							ОшибкаМодуля.Комментарий = КраткоеПредставлениеОшибки(ИнформацияОбОшибке);
							ОшибкаМодуля.Язык = "Запрос";
						КонецЕсли;
					КонецЕсли;
					мЯзыкПрограммы = 0;
					мНачальнаяПозиция0ВложенногоТекста = 0;
					Если НадоВосстановитьМетод Тогда
						ЗагрузитьМетодМодуляПоПозиции(ПозицияВхождения0ВМодуле, Истина);
					КонецЕсли; 
				КонецЕсли;
			КонецЕсли; 
		Иначе
			ДобавитьВозможнуюОшибкуПослеТочки(ВложенныеВыраженияШаблон, ВыражениеСТочкой, ПозицияВхождения0ВБлоке, ПроверятьВсеЛитералы, НачалоБлока); 
			Если ТабличноеПоле <> Неопределено Тогда
				ирКлиент.ПроверитьПервоеОбновлениеТабличногоПоляЛкс(ТабличноеПоле, СтруктураОбновленияТабличногПоля, 20);
			КонецЕсли;
		КонецЕсли;
		//Длительность = ирОбщий.ТекущееВремяВМиллисекундахЛкс() - МоментНачала; // Для отладки
	КонецЦикла;
	Если Истина
		И Этап = 1  
		И Форма <> Неопределено
		И Не Форма.ВсеМодули
		И мИмяМодуля <> мПлатформа.ИмяДинамическогоМодуля() 
	Тогда
		ЧислоОшибокМетода = ОшибкиМодуля.НайтиСтроки(Новый Структура("Метод", ИмяТекущегоМетода())).Количество();
		ирОбщий.СообщитьЛкс(ирОбщий.СтрШаблонЛкс("Проверка текущего метода (%1) завершена. Найдено %2 возможных ошибок.", ИмяТекущегоМетода(), ЧислоОшибокМетода),,, Истина);
	КонецЕсли;
КонецФункции

Функция ИнструкцияПодавленияПроверки(Знач ТипОшибки = "НеизвестноеСлово", Знач Чистая = Ложь) Экспорт
	Результат = "@skip-check ";
	Если ТипОшибки = "НеизвестноеСлово" Тогда
		Результат = Результат + "unknown-method-property";
	ИначеЕсли ТипОшибки = "МногоПараметров" Тогда
		Результат = Результат + "many-actual-parameters";
	ИначеЕсли ТипОшибки = "МалоПараметров" Тогда
		Результат = Результат + "not-enough-parameters";
	КонецЕсли;
	Если Чистая Тогда
		Возврат Результат;
	Иначе 
		Возврат "//" + Результат;
	КонецЕсли;
КонецФункции 

//.
// Параметры:
//    ВложенныеВыраженияШаблон - ТаблицаЗначений - :
//      * Выражение
//      * Позиция0ВБлоке
//      * ВызовМетода
//    Выражение - Неопределено - 
//    ПозицияВхождения0ВБлоке - Число - 
//    ТаблицаРезультата - ТаблицаЗначений - 
Функция ДобавитьВозможнуюОшибкуПослеТочки(Знач ВложенныеВыраженияШаблон, Знач НайденноеВыражение, Знач Позиция0ВБлоке, Знач ПроверятьВсеЛитералы, Знач НачалоБлока) Экспорт
	ВложенныеВыражения = ВложенныеВыраженияШаблон.СкопироватьКолонки();
	мРекурсивныйПуть.ВложенныеВыражения = ВложенныеВыражения;
	мРекурсивныйПуть.ПозицииЗапроса.Очистить();
	мРекурсивныйПуть.ВходящиеВызовы.Очистить(); // Иначе будут ложные ошибки {Обработка.ирКлсПолеТекстаПрограммы.МодульОбъекта(8743:ДобавитьЕдинственныйТип,15)}: ИначеЕсли СтруктураТипа.ИмяОбщегоТипа = "ПолеФормы" Тогда
	мРекурсивныйПуть.СчетчикиВызовов.Очистить();
	ТаблицаТипов = ВычислитьТипЗначенияВыражения(НайденноеВыражение,,, Истина,,, Ложь,,,,, Позиция0ВБлоке,,, Истина);
	Для Каждого ВложенноеВыражение Из ВложенныеВыражения Цикл
		мРегВыражение.Pattern = шПроверяемоеВыражение;
		мРегВыражение.Global = Истина;
		ВложенныеВхождения = мРегВыражение.НайтиВхождения(ВложенноеВыражение.Выражение,, Истина);
		ПроверитьВыраженияУровня(ВложенныеВхождения, ПроверятьВсеЛитералы,,,,,,,, ВложенныеВыраженияШаблон, ВложенноеВыражение.Позиция0ВБлоке, НачалоБлока);
	КонецЦикла; 
	Возврат ТаблицаТипов;
КонецФункции

///////////////////
// Редактор HTML

// Процедура - Редактор HTML инициировать
//
// Параметры:
//  ПолеHTML - ПолеHTMLДокумента - 
//
Процедура РедакторHTML_Инициировать(ПолеHTML) Экспорт 
	
	#Если Сервер И Не Сервер Тогда
		мПлатформа = Обработки.ирПлатформа.Создать();
	#КонецЕсли
	ФормаКласса = мПлатформа.ПолучитьМакетКомпоненты(ЭтотОбъект);
	КнопкиМакета = ФормаКласса.ЭлементыФормы.КПРедакторHTML.Кнопки.КонтекстноеМеню.Кнопки;
	КонтекстноеМеню = ПолеHTML.КонтекстноеМеню;
	Если КонтекстноеМеню = Неопределено Тогда
		КонтекстноеМеню = ФормаВладелец.ЭлементыФормы.Добавить(Тип("КоманднаяПанель"), "КонтекстноеМеню" + ПолеHTML.Имя, Ложь);
		КонтекстноеМеню.ИсточникДействий = ПолеHTML;
		ПолеHTML.КонтекстноеМеню = КонтекстноеМеню;
	КонецЕсли;
	ирКлиент.ДобавитьКнопкиКоманднойПанелиКомпонентыЛкс(ЭтотОбъект, КнопкиМакета, КонтекстноеМеню,,, Истина);
	ПолеТекстаHTML = ирКлиент.ОболочкаПоляТекстаЛкс(ПолеHTML);
	#Если Сервер И Не Сервер Тогда
		ПолеТекстаHTML = Обработки.ирОболочкаПолеТекста.Создать();
	#КонецЕсли
	ПолеТекстаHTML.Инициировать(ФормаВладелец);
	РедакторHTML = ПолеHTML.Документ.defaultView;
	Инфо = Новый СистемнаяИнформация();
	РедакторHTML.minimap(Ложь);
	РедакторHTML.init(Инфо.ВерсияПриложения);
	Если ЯзыкПрограммы = 1 Тогда
		РедакторHTML.setLanguageMode("bsl_query");
	ИначеЕсли ЯзыкПрограммы = 2 Тогда
		РедакторHTML.setLanguageMode("dcs_query");
	КонецЕсли; 
	РедакторHTML.setOption("disableContextQueryConstructor", Истина);
	РедакторHTML.setOption("disableNativeSuggestions", Истина); // События не перестают вызываться
	РедакторHTML.setOption("disableNativeSignatures", Истина); // События не перестают вызываться
	РедакторHTML.setOption("disableNativeHovers", Истина); // События не перестают вызываться
	РедакторHTML.setOption("skipInsertSuggestionAcceptor", Истина); // Отключаем вставку точки при выборе слова из списка https://github.com/salexdv/bsl_console/issues/120#issuecomment-844372676
	РедакторHTML.setOption("skipAcceptionSelectedSuggestion", Истина); // Отключаем стандартную обработку вставки активного пункта подсказки. Практически 'СтандартнаяОбработка = Ложь'
	РедакторHTML.setOption("renderQueryDelimiters", Истина); // Разделители запросов пакета https://github.com/salexdv/bsl_console/issues/218
	РедакторHTML.setOption("generateBeforeSignatureEvent", Истина);
	РедакторHTML.setOption("generateBeforeShowSuggestEvent", Истина);
	РедакторHTML.setOption("generateSelectSuggestEvent", Истина);
	РедакторHTML.setOption("generateBeforeHoverEvent", Истина);
	РедакторHTML.setOption("generateModificationEvent", Истина);
	РедакторHTML.disableKeyBinding(2082); // CTRL(2048)+D(KEY_D=34) - CTRL+D
	РедакторHTML.disableKeyBinding(2118); // CTRL(2048)+F12(KEY_F12=70) - F12
	РедакторHTML.editor._standaloneKeybindingService.addDynamicKeybinding("-editor.action.toggleTabFocusMode"); // CTRL+M  https://www.hostedredmine.com/issues/988859
	РедакторHTML.setActiveSuggestionAcceptors("."); // По нажатию точки выполняется вставка активного слова и ввод точки // Много нежелательных срабатываний
	
КонецПроцедуры 

Процедура РедакторHTML_Уничтожить(ПолеHTML) Экспорт
	//Если ирКэш.НомерВерсииПлатформыЛкс() >= 803025 Тогда
	//	// Антибаг Аварийное завершение https://www.hostedredmine.com/issues/984781 
	//	Возврат;
	//КонецЕсли;
	//РедакторHTML = ирКлиент.ОболочкаПоляТекстаЛкс(ПолеHTML).РедакторHTML();
	//Если РедакторHTML <> Неопределено Тогда
	//	РедакторHTML.version1C = ""; // Предотвращаем повторное удаление обработчика без добавления https://www.hostedredmine.com/issues/936924
	//	ИмяОбработчика = "" + ПолеHTML.ПолучитьДействие("onclick") + "Динамический";
	//	ПолеHTML.УстановитьДействие("onclick", Неопределено);
	//	// Блокирует неоправданное обновление формы https://github.com/salexdv/bsl_console/issues/178
	//	// Не забудь отключить в ПередЗакрытием
	//	Выполнить("УдалитьОбработчик РедакторHTML.onclick, ФормаВладелец." + ИмяОбработчика); 
	//КонецЕсли;
КонецПроцедуры

Функция ДобавитьПодсказкуПоЗначениюВыражения(Знач ЗначениеВыражения = Неопределено, Знач ОбъектноеВыражение, Знач ПодсказкаМассив, СтруктураТипа = Неопределено) Экспорт 
	
	#Если Сервер И Не Сервер Тогда
		ПодсказкаМассив = Новый Массив;
	#КонецЕсли
	ЕстьОписаниеТипа = Ложь;
	Если СтруктураТипа = Неопределено Тогда
		СтруктураТипа = мПлатформа.СтруктураТипаИзЗначения(ЗначениеВыражения, ЯзыкПрограммы);
	КонецЕсли;
	ИмяТипаЗначения = мПлатформа.ИмяТипаИзСтруктурыТипа(СтруктураТипа);
	ИмяОбщегоТипа = СтруктураТипа.ИмяОбщегоТипа;
	СтрокаОбщегоТипа = мПлатформа.ТаблицаОбщихТипов.Найти(НРег(ИмяОбщегоТипа), "НСлово");
	Если СтрокаОбщегоТипа <> Неопределено Тогда
		ЕстьОписаниеТипа = ЗначениеЗаполнено(СтрокаОбщегоТипа.ПутьКОписанию);
	КонецЕсли;
	Если ИмяТипаЗначения = "Строка" Тогда
		ПодсказкаЗначения = "Знач: """ + ЗначениеВыражения + """";
	Иначе
		Если ТипЗнч(ЗначениеВыражения) = Тип("Строка") Тогда
			ПодсказкаЗначения = ЗначениеВыражения;
		Иначе
			ПодсказкаЗначения = ирОбщий.РасширенноеПредставлениеЛкс(ЗначениеВыражения,, Ложь, Истина);
		КонецЕсли; 
		Если Ложь
			Или ТипЗнч(ЗначениеВыражения) = Тип("Неопределено") 
			Или ТипЗнч(ЗначениеВыражения) = Тип("Null")
		Тогда
			ПодсказкаЗначения = "Знач: " + ПодсказкаЗначения;
		Иначе
			ПодсказкаЗначения = "[Знач](" + ОбъектноеВыражение + "): " + ПодсказкаЗначения;
		КонецЕсли; 
		Если ПодсказкаЗначения = ИмяТипаЗначения Тогда
			ПодсказкаЗначения = "";
		Иначе
			ПодсказкаЗначения = ПодсказкаЗначения + " ";
		КонецЕсли; 
		Если ЕстьОписаниеТипа Тогда
			ИмяСсылкиТипа = "_Тип" + XMLСтрока(мСтруктурыТиповПодсказкиУдержания.Количество());
			ПодсказкаЗначения = ПодсказкаЗначения + "[[" + ИмяТипаЗначения + "]](" + ИмяСсылкиТипа + ")";
			мСтруктурыТиповПодсказкиУдержания.Вставить(ИмяСсылкиТипа, СтруктураТипа);
		Иначе
			ПодсказкаЗначения = ПодсказкаЗначения + "[" + ИмяТипаЗначения + "]";
		КонецЕсли; 
	КонецЕсли; 
	ПодсказкаМассив.Добавить(ПодсказкаЗначения);
	Возврат ИмяТипаЗначения;

КонецФункции

Функция ДобавитьПодсказкуПоДопустимымТипам(Знач ИмяТипаЗначения, Знач ПодсказкаМассив, Знач ОбъектноеВыражение) Экспорт 
	
	ТаблицаТипов = ТаблицаТиповТекущегоВыражения(, Истина, Ложь,, Ложь);
	Если Истина
		И ЯзыкПрограммы = 1 
		И ТаблицаТипов.Количество() > 0
		И ТаблицаТипов[0].ИмяОбщегоТипа = "ВременнаяТаблица"
		И ТипЗнч(КонтекстВыполнения) = Тип("Запрос")
	Тогда
		ВременныйЗапрос = Новый Запрос;
		ВременныйЗапрос.МенеджерВременныхТаблиц = КонтекстВыполнения.МенеджерВременныхТаблиц;
		ИмяВременнойТаблицы = ТаблицаТипов[0].ВиртуальнаяТаблица.Выражение;
		Если ЗначениеЗаполнено(ИмяВременнойТаблицы) Тогда
			ВременныйЗапрос.Текст = "ВЫБРАТЬ КОЛИЧЕСТВО(*) ИЗ " + ИмяВременнойТаблицы;
			КоличествоСтрокВТаблице = ВременныйЗапрос.Выполнить().Выгрузить()[0][0];
			ДобавитьПодсказкуПоЗначениюВыражения(ИмяВременнойТаблицы + "(" + КоличествоСтрокВТаблице + ")", ОбъектноеВыражение, ПодсказкаМассив, ТаблицаТипов[0]);
		КонецЕсли;
	КонецЕсли; 
	ПредставлениеДопустимыхТипов = мПлатформа.ПредставлениеМассиваСтруктурТипов(ТаблицаТипов, Истина);
	Если Истина
		И ПредставлениеДопустимыхТипов <> "?"
		И ПредставлениеДопустимыхТипов <> "ОбщийМодуль"
		И ПредставлениеДопустимыхТипов <> "ВременнаяТаблица"
		И ЗначениеЗаполнено(ПредставлениеДопустимыхТипов)
		И ПредставлениеДопустимыхТипов <> ИмяТипаЗначения
	Тогда
		ИмяСсылкиТипа = "_Тип" + XMLСтрока(мСтруктурыТиповПодсказкиУдержания.Количество());
		мСтруктурыТиповПодсказкиУдержания.Вставить(ИмяСсылкиТипа, ТаблицаТипов);
		ПредставлениеДопустимыхТипов = "[Допустимые типы](" + ИмяСсылкиТипа + "): " + ПредставлениеДопустимыхТипов;
		ПодсказкаМассив.Добавить(ПредставлениеДопустимыхТипов);
	КонецЕсли;
	Если ПредставлениеДопустимыхТипов <> "ОбщийМодуль" Тогда
		ПодсказкаМассив.Добавить("[Определение](" + XMLСтрока(мКонечнаяСтрока) + "," + XMLСтрока(мКонечнаяКолонка) + ")");
	КонецЕсли; 
	Возврат ПредставлениеДопустимыхТипов;

КонецФункции

Процедура ОткрытьОписаниеТипаПоГиперссылке(Знач ИмяОбщегоТипа) Экспорт 
	
	Если Истина
		И ирОбщий.СтрНачинаетсяСЛкс(ИмяОбщегоТипа, "_Тип")
		И мСтруктурыТиповПодсказкиУдержания.Свойство(ИмяОбщегоТипа) 
	Тогда 
		СтруктураТипа = мСтруктурыТиповПодсказкиУдержания[ИмяОбщегоТипа];
		Если ТипЗнч(СтруктураТипа) = Тип("ТаблицаЗначений") Тогда
			ТаблицаДляПользователя = мПлатформа.ТаблицаТиповДляПользователя(СтруктураТипа, Ложь);
			СписокВыбора = Новый СписокЗначений;
			Для Каждого СтрокаТаблицы Из ТаблицаДляПользователя Цикл
				Если ирОбщий.СтрокиРавныЛкс(СтрокаТаблицы.Имя, "null") Тогда
					Продолжить;
				КонецЕсли; 
				СписокВыбора.Добавить(СтрокаТаблицы.СтруктураТипа, СтрокаТаблицы.Имя);
			КонецЦикла;
			СписокВыбора = ирОбщий.СвернутьСписокЗначенийПоПредставлениюЛкс(СписокВыбора);
			Если СписокВыбора.Количество() = 1 Тогда
				СтруктураТипа = СписокВыбора[0];
			Иначе
				СтруктураТипа = СписокВыбора.ВыбратьЭлемент("Выберите тип значения"); 
				Если СтруктураТипа = Неопределено Тогда
					Возврат;
				КонецЕсли; 
			КонецЕсли; 
			СтруктураТипа = СтруктураТипа.Значение; // см. мПлатформа.НоваяСтруктураТипа()
		КонецЕсли; 
		ОткрытьОпределениеСтруктурыТипа(СтруктураТипа, Истина);
	Иначе
		ирКлиент.ОткрытьОписаниеТипаПоИмениТипаЛкс(ИмяОбщегоТипа);
	КонецЕсли; 

КонецПроцедуры

// антибаг редактора https://github.com/salexdv/bsl_console/issues/78#issuecomment-836447865
Функция ЧистоеСловоСпискаПодсказкиHTML(ВыбранноеСлово) Экспорт 
	
	Возврат ирОбщий.ТекстМеждуМаркерамиЛкс(ВыбранноеСлово, "Элемент ", ",", Истина);

КонецФункции

Процедура РедакторHTML_ПередПоказомПодсказкиУдержания(Знач Событие, Знач ФункцияВычислитьВыражение = "") Экспорт 
	
	#Если Сервер И Не Сервер Тогда
		ПолеТекста = Обработки.ирОболочкаПолеТекста.Создать();
	#КонецЕсли
	НомерКолонки23 = Событие.params.column;
	НомерСтроки23 = Событие.params.line; 
	ТекущееСлово = Событие.params.word;
	мСтруктурыТиповПодсказкиУдержания = Новый Структура;
	Если ТекущееСлово = Неопределено Тогда 
		Возврат;
	КонецЕсли; 
	КончитьОбработкуКоманды();
	РедакторHTML = ПолеТекста.РедакторHTML();
	ОбъектноеВыражение = ТекущееОбъектноеВыражение(НомерСтроки23, НомерКолонки23,, Ложь);
	ПодсказкаМассив = Новый Массив;
	Если Истина
		И (Ложь
			Или Найти(ОбъектноеВыражение, "(") = 0 
			Или ирОбщий.СтрКончаетсяНаЛкс(ОбъектноеВыражение, "(") 
			Или ирОбщий.СтрНачинаетсяСЛкс(ОбъектноеВыражение, "("))
		И (Ложь
			Или ирОбщий.ЛиИмяПеременнойЛкс(Лев(ОбъектноеВыражение, 1)) 
			Или Лев(ОбъектноеВыражение, 1) = мПараметрыДиалектаSQL.ПрефиксПараметра
			Или Лев(ОбъектноеВыражение, 1) = "(")
	Тогда
		ФормаВладелец.КлсПолеТекстаПрограммыОбновитьКонтекст(ЭтотОбъект);
		ИмяТипаЗначения = "";
		Если Истина                                                                         
			И ЗначениеЗаполнено(ФункцияВычислитьВыражение)
			И (Ложь
				Или (ЯзыкПрограммы > 0 И Лев(ОбъектноеВыражение, 1) = мПараметрыДиалектаSQL.ПрефиксПараметра)
				Или (ЯзыкПрограммы = 0 И Не ирОбщий.СтрКончаетсяНаЛкс(ОбъектноеВыражение, "(")))
		Тогда
			УспехЗначения = Истина;
			ЗначениеВыражения = Вычислить("ФормаВладелец." + ФункцияВычислитьВыражение + "(ОбъектноеВыражение, УспехЗначения)");
			Если УспехЗначения Тогда
				ИмяТипаЗначения = ДобавитьПодсказкуПоЗначениюВыражения(ЗначениеВыражения, ОбъектноеВыражение, ПодсказкаМассив);
			КонецЕсли; 
		КонецЕсли; 
		ПредставлениеДопустимыхТипов = ДобавитьПодсказкуПоДопустимымТипам(ИмяТипаЗначения, ПодсказкаМассив, ОбъектноеВыражение);
	КонецЕсли; 
	КончитьОбработкуКоманды();
	СтруктураПодсказки = Новый Соответствие;
	СтруктураПодсказки.Вставить(ТекущееСлово.word, ПодсказкаМассив);
	РедакторHTML.setCustomHovers(ирОбщий.ОбъектВСтрокуJSONЛкс(СтруктураПодсказки));

КонецПроцедуры

Процедура РедакторHTML_ПередПоказомСигнатуры(НомерПараметра, ИмяМетодаОтРедактора, НомерСигнатуры, Триггер) Экспорт 
	
	Если РазрешеноСобытиеПередПоказомАвтодополнения = Ложь Или НомерСигнатуры > 0 Тогда
		// https://github.com/salexdv/bsl_console/issues/182
		РазрешеноСобытиеПередПоказомАвтодополнения = Истина;
		Возврат;
	КонецЕсли; 
	Если Триггер <> Неопределено И Не АвтоматическаяПодсказкаПоВызовуМетода() Тогда
		Возврат;
	КонецЕсли;
	#Если Сервер И Не Сервер Тогда
		ПолеТекста = Обработки.ирОболочкаПолеТекста.Создать();
	#КонецЕсли
	РедакторHTML = ПолеТекста.РедакторHTML();
	//РедакторHTML.hideSignatureList();
	Если Не ЛиДоступноОткрытиеСвободнойФормы() Тогда 
		КончитьОбработкуКоманды();
		ФормаВладелец.КлсПолеТекстаПрограммыОбновитьКонтекст(ЭтотОбъект);
		СтруктураПодсказки = СтруктураПодсказкиМетода(, Триггер <> Неопределено);
		Если СтруктураПодсказки.Количество() = 0 Тогда
			Возврат;
		КонецЕсли;
		ВариантыСинтаксиса = Новый Соответствие;
		//ВариантыСинтаксиса.Вставить(ирОбщий.ПоследнийФрагментЛкс(ИмяМетодаОтРедактора, " "), СтруктураПодсказки); // В какой то версии перестало работать после точки https://github.com/salexdv/bsl_console/issues/343
		ВариантыСинтаксиса.Вставить(ирОбщий.ПервыйФрагментЛкс(мВызовМетода, "("), СтруктураПодсказки);
		РедакторHTML.setCustomSignatures(ирОбщий.ОбъектВСтрокуJSONЛкс(ВариантыСинтаксиса));
		//РедакторHTML.enableBeforeShowSuggestEvent(Ложь);
		РедакторHTML.setOption("generateBeforeShowSuggestEvent", Ложь);
		РазрешеноСобытиеПередПоказомАвтодополнения = Ложь;
		РедакторHTML.triggerSigHelp();
		//РедакторHTML.enableBeforeShowSuggestEvent(Истина);
		РедакторHTML.setOption("generateBeforeShowSuggestEvent", Истина);
		//ИмяМетодаОтРедактора = ФормаВызовМетода.ИмяМетода;
		//НомерПараметра = мНомерПараметра - 1;
	КонецЕсли;

КонецПроцедуры

Функция СтруктураПодсказкиМетода(Знач ПараметрПостояннаяСтруктураТипа = Неопределено, Знач ТолькоДляАвтооткрытия = Истина, Знач ДляСпискаАвтодополнения = Ложь, выхЕстьПараметры = Ложь)
	
	СтруктураПодсказки = Новый Массив;
	Если мФормаВызовМетодаСкрытая = Неопределено Тогда
		мФормаВызовМетодаСкрытая = ПолучитьФорму("ВызовМетода");
	КонецЕсли;  
	ФормаВызовМетода = мФормаВызовМетодаСкрытая;
	ФормаВызовМетода.Автообновление = Ложь;
	ФормаВызовМетода.ПараметрПостояннаяСтруктураТипа = ПараметрПостояннаяСтруктураТипа;
	ФормаВызовМетода.ОбновитьИлиЗакрытьФорму(,, Истина);
	Если Не ФормаВызовМетода.НужноАвтооткрытие И ТолькоДляАвтооткрытия Тогда
		Возврат СтруктураПодсказки;
	КонецЕсли; 
	Для ИндексВарианта = 0 По ФормаВызовМетода.ВариантыСинтаксиса.Количество() - 1 Цикл
		Если Истина
			И ФормаВызовМетода.ВариантыСинтаксиса.Количество() > 1 
		Тогда
			ФормаВызовМетода.УстановитьВариантСинтаксисаПоИндексу(ИндексВарианта);
		КонецЕсли; 
		ПодсказкаСлова = Новый Структура();
		ПараметрыМетода = Новый Массив;
		КраткиеОписанияПараметров = Новый Массив;
		Для Каждого СтрокаПараметра Из ФормаВызовМетода.ТаблицаПараметров Цикл
			ЛиНеОбязательный = ФормаВызовМетода.ЛиНеОбязательныйПараметр(СтрокаПараметра);
			СтруктураПараметра = Новый Структура();
			КраткоеПредставлениеПараметра = "" 
			//+ ?(СтрокаПараметра.Знач = "Знач", "`", СтрокаПараметра.Знач) 
			+ СтрокаПараметра.Имя 
			+ ?(ЛиНеОбязательный, "?", "");
			// Мало пользы, лишние неудобства при поиске нужного параметра. Поэтому пока отключено
			//Если ЗначениеЗаполнено(СтрЗаменить(СтрокаПараметра.ТипЗначения, "?", "")) Тогда
			//	КраткоеПредставлениеПараметра = КраткоеПредставлениеПараметра + " [" + ирОбщий.ПредставлениеЗначенияСОграничениемДлиныЛкс(СокрЛП(СтрокаПараметра.ТипЗначения), 20) + "]";
			//КонецЕсли; 
			КраткиеОписанияПараметров.Добавить(КраткоеПредставлениеПараметра);
			СтруктураПараметра.Вставить("label", КраткоеПредставлениеПараметра);
			ОписаниеПараметра = 
			"Обяз.: " + ?(Не ЛиНеОбязательный, "Да", "Нет, " + СтрокаПараметра.Значение) + ";  Возвр.: " + ?(Не ЗначениеЗаполнено(СтрокаПараметра.Знач), "?", ?(СтрокаПараметра.Знач = "Знач", "Нет", "Да")) + "
			|Тип: " + ирОбщий.ПредставлениеЗначенияСОграничениемДлиныЛкс(СокрЛП(СтрокаПараметра.ТипЗначения), 200) + ".";
			Если ЗначениеЗаполнено(СтрокаПараметра.Описание) Тогда
				ОписаниеПараметра = ОписаниеПараметра + "
				|> " + СтрокаПараметра.Описание;
			КонецЕсли; 
			СтруктураПараметра.Вставить("documentation", ОписаниеПараметра);
			ПараметрыМетода.Добавить(СтруктураПараметра);
			выхЕстьПараметры = Истина;
		КонецЦикла;
		ПредставлениеМетода = "";
		Если Не ДляСпискаАвтодополнения Тогда
			ПредставлениеМетода = ПредставлениеМетода + ирОбщий.ПредставлениеЗначенияСОграничениемДлиныЛкс(ФормаВызовМетода.ИмяМетода, 13);
		КонецЕсли; 
		ПредставлениеМетода = ПредставлениеМетода + "(" + ирОбщий.СтрСоединитьЛкс(КраткиеОписанияПараметров, ", ") + ")";
		Если ЗначениеЗаполнено(ФормаВызовМетода.ТипЗначенияМетода) Тогда
			Если Не ДляСпискаАвтодополнения Тогда
				ПредставлениеМетода = ПредставлениеМетода + " [" + ирОбщий.ПредставлениеЗначенияСОграничениемДлиныЛкс(СокрЛП(ФормаВызовМетода.ТипЗначенияМетода), 15) + "]";
			КонецЕсли; 
		КонецЕсли; 
		ПодсказкаСлова.Вставить("label", ПредставлениеМетода);
		ПодсказкаСлова.Вставить("parameters", ПараметрыМетода);
		ОписаниеМетода = "";
		Если ЗначениеЗаполнено(ФормаВызовМетода.ТекущийВариант) Тогда
			ОписаниеМетода = ОписаниеМетода + "Вариант: " + ФормаВызовМетода.ТекущийВариант + "." + Символы.ПС;
		КонецЕсли;
		ОписаниеМетода = ОписаниеМетода + ФормаВызовМетода.ОписаниеМетода;
		ПодсказкаСлова.Вставить("documentation", ОписаниеМетода);
		СтруктураПодсказки.Добавить(ПодсказкаСлова);
	КонецЦикла;
	Возврат СтруктураПодсказки;

КонецФункции
 
Процедура РедакторHTML_ПередПоказомАвтодополнения(Триггер, ПоследнееВыражение, ПоследнееСлово)  Экспорт 
	
	#Если Сервер И Не Сервер Тогда
		ПолеТекста = Обработки.ирОболочкаПолеТекста.Создать();
	#КонецЕсли
	РедакторHTML = ПолеТекста.РедакторHTML();
	//РедакторHTML.hideSuggestionsList();
	ПоказатьСписок = МожноПоказатьСписокСлов(Триггер, ПоследнееВыражение, ПоследнееСлово);
	//Сообщить(Триггер);
	Если ПоказатьСписок Тогда 
		Если Триггер = "backspace" Тогда
			//РедакторHTML.enableBeforeShowSuggestEvent(Ложь);
			РедакторHTML.setOption("generateBeforeShowSuggestEvent", Ложь);
			РедакторHTML.showPreviousCustomSuggestions();
			//РедакторHTML.enableBeforeShowSuggestEvent(Истина);
			РедакторHTML.setOption("generateBeforeShowSuggestEvent", Истина);
		Иначе
			ФормаВызовМетода = ФормаВызовМетода();
			Если ФормаВызовМетода.Открыта() Тогда
				ФормаВызовМетода.Закрыть();
			КонецЕсли; 
			КончитьОбработкуКоманды();
			ФормаВладелец.КлсПолеТекстаПрограммыОбновитьКонтекст(ЭтотОбъект);
			РазобратьТекущийКонтекст(,,,,, Истина);
			Если ЯзыкПрограммы = 0 И Триггер = """" Тогда
				ПоказатьСписок = мЭтоТекстовыйЛитерал;
			//ИначеЕсли Истина
			//	И Триггер <> "space"
			//	И ЯзыкПрограммы = 1 
			//	И мЭтоОбъявлениеПсевдонима 
			//Тогда
			//	ПоказатьСписок = Ложь;
			Иначе
				ПоказатьСписок = Не (мКонтекст = "" И Триггер = ".");
			КонецЕсли; 
			Если Не ПоказатьСписок Тогда 
				Возврат;
			КонецЕсли;
			//РедакторHTML.enableSuggestActivationEvent(Истина, Истина);  // Второй параметр включает отображение типов для всех слов списка автодополнения https://github.com/salexdv/bsl_console/issues/119
			РедакторHTML.setOption("generateSuggestActivationEvent", Истина);
			РедакторHTML.setOption("alwaysDisplaySuggestDetails", Истина);
			
			УспехЗаполнения = ЗаполнитьТаблицуСлов(,,, Триггер = "space", Ложь, Триггер = "space");
			Если Истина
				И УспехЗаполнения
				И (Ложь
					Или Триггер = "space"
					Или ТаблицаСлов.Количество() > 0)
			Тогда
				СтруктураПодсказки = Новый Массив;
				КодыТиповСлов = Новый Структура;
				СоответствиеТипаСлова();
				Для Каждого СтрокаСоответствия Из мСоответствиеТиповСловHTML Цикл
					Если Не ЗначениеЗаполнено(СтрокаСоответствия.Имя) Тогда
						Продолжить;
					КонецЕсли; 
					КодыТиповСлов.Вставить(СтрокаСоответствия.Имя, СоответствиеТипаСлова(СтрокаСоответствия.Имя).Код);
				КонецЦикла; 
				Для Каждого СтрокаСлова Из ТаблицаСлов Цикл
					ПодсказкаСлова = Новый Структура();
					ПодсказкаСлова.Вставить("name", СтрокаСлова.Слово);
					//ТекстВставки = СтрокаСлова.Слово;
					//ПодсказкаСлова.Вставить("text", ТекстВставки); // Закомментировал, т.к. пользы от этого нет, а вред есть https://github.com/salexdv/bsl_console/issues/171
					ПодсказкаСлова.Вставить("kind", КодыТиповСлов[СтрокаСлова.ТипСлова]);
					ПодсказкаСлова.Вставить("detail", СтрокаСлова.ТипЗначения);
					Если СтрокаСлова.ТипСлова = "Конструкция" Тогда
						ПодсказкаСлова.Вставить("sort", "-1"); // https://www.hostedredmine.com/issues/963233
					Иначе
						ПодсказкаСлова.Вставить("sort", XMLСтрока(-СтрокаСлова.Рейтинг));
					КонецЕсли;
					ПодсказкаСлова.Вставить("detail", СтрокаСлова.ТипЗначения);
					ПодсказкаСлова.Вставить("documentation", "_"); // Нужно чтобы окно детального описания открывалось
					СтруктураПодсказки.Добавить(ПодсказкаСлова);
				КонецЦикла;
				СтрокаСпискаАвтодополненияHTML = ирОбщий.ОбъектВСтрокуJSONЛкс(СтруктураПодсказки);
				Если СтрокаСпискаАвтодополненияHTML <> Неопределено Тогда
					РедакторHTML.setOption("showSnippetsOnCustomSuggestions", мСтруктураТипаКонтекста.ИмяОбщегоТипа = "Локальный"); // Штатные сниппеты https://github.com/salexdv/bsl_console/issues/200
					РедакторHTML.setOption("generateBeforeShowSuggestEvent", Ложь);
					РедакторHTML.showCustomSuggestions(СтрокаСпискаАвтодополненияHTML);
					РедакторHTML.setOption("generateBeforeShowSuggestEvent", Истина);
				КонецЕсли; 
			КонецЕсли;
		КонецЕсли; 
	КонецЕсли; 

КонецПроцедуры

//.
// Параметры:
//    Триггер - Строка - 
//    ПоследнееВыражение - Строка - 
//    ПоследнееСлово - Строка - 
// Возвращаемое значение:
//    Булево - 
Функция МожноПоказатьСписокСлов(Триггер, ПоследнееВыражение, ПоследнееСлово) Экспорт
	Последние2Символа = Прав(ПоследнееВыражение, 2);
	ПрефиксПараметра = мПараметрыДиалектаSQL.ПрефиксПараметра;
	ОтображатьСписок = Ложь
		Или Триггер = "space"
		Или (Истина
			И АвтоматическаяПодсказкаАвтодополненияHTML()
			И (Ложь
				Или Триггер = Неопределено // ввод буквы или после выбора слова списка вводом "."
				Или Триггер = " "
				Или Триггер = "." И Последние2Символа <> ".."
				Или ЯзыкПрограммы <> 0 И Триггер = ПрефиксПараметра И Последние2Символа <> (ПрефиксПараметра + ПрефиксПараметра)
				Или ЯзыкПрограммы = 0 И Триггер = """" И Последние2Символа <> """"""
				Или ирОбщий.ЛиИмяПеременнойЛкс(Триггер) // Иначе слишком часто вызывается затратное обновление списка слов локального контекста
				Или ЯзыкПрограммы = 0 И ирОбщий.СтрокиРавныЛкс(ПоследнееСлово, "новый")
				Или ЯзыкПрограммы = 0 И ирОбщий.СтрокиРавныЛкс(ПоследнееСлово, "new")));
	Возврат ОтображатьСписок;
КонецФункции

Функция СоответствиеТипаСлова(Знач ВстроенныйТипСлова = "", Знач ИмяКлюча = "Имя")
	
	Если мСоответствиеТиповСловHTML = Неопределено Тогда
		мСоответствиеТиповСловHTML = ирОбщий.ТаблицаЗначенийИзТабличногоДокументаЛкс(ПолучитьМакет("ТипыСловHTML"));
		#Если Сервер И Не Сервер Тогда
			мСоответствиеТиповСловHTML = Новый ТаблицаЗначений;
		#КонецЕсли
		мСоответствиеТиповСловHTML.Колонки.Добавить("НКод");
		мСоответствиеТиповСловHTML.Индексы.Добавить("Имя");
		мСоответствиеТиповСловHTML.Индексы.Добавить("НКод");
		Для Каждого СтрокаТЗ Из мСоответствиеТиповСловHTML Цикл
			СтрокаТЗ.НКод = НРег(СтрокаТЗ.Код);
		КонецЦикла;
	КонецЕсли;
	НайденнаяСтрока = мСоответствиеТиповСловHTML.Найти(ВстроенныйТипСлова, ИмяКлюча);
	//Если НайденнаяСтрока = Неопределено Тогда
	//	НайденнаяСтрока = мСоответствиеТиповСловHTML[0];
	//КонецЕсли;
	Возврат НайденнаяСтрока;

КонецФункции

Процедура РедакторHTML_ПриВыбореСтрокиАвтодополнения(Триггер, ПоследнееВыражение, ВыбранноеСлово, ТипСловаHTML, ТекстВставки, ПоследнееСлово) 
	
	Если ирОбщий.СтрНачинаетсяСЛкс(Триггер, "force-") Тогда
		ПараметрЗакрытия = Прав(Триггер, 1);
		Если Найти(ПоследнееВыражение, ".") > 0 Тогда
			ВыделенныйТекст(ПараметрЗакрытия);
			Возврат;
		КонецЕсли; 
	Иначе
		ПараметрЗакрытия = Истина;
	КонецЕсли; 
	#Если Сервер И Не Сервер Тогда
		ПолеТекста = Обработки.ирОболочкаПолеТекста.Создать();
	#КонецЕсли
	РедакторHTML = ПолеТекста.РедакторHTML();
	РедакторHTML.hideSuggestionsList();
	КончитьОбработкуКоманды();
	РазобратьТекущийКонтекст(,,,,, Истина);
	ОтборСлов = Новый Структура("Слово", ЧистоеСловоСпискаПодсказкиHTML(ВыбранноеСлово));
	ТипСлова = ТипСловаИзТипаСловаHTML(ТипСловаHTML);
	Если ТипСлова = "Шаблон" Тогда
		мНачальнаяКолонка = мНачальнаяКолонка - СтрДлина(ПоследнееСлово);
		УстановитьГраницыВыделения();
		РедакторHTML.insertSnippet(ТекстВставки);
		Возврат;
	КонецЕсли; 
	Если ЗначениеЗаполнено(ТипСлова)  Тогда
		ОтборСлов.Вставить("ТипСлова", ТипСлова);
	КонецЕсли; 
	НайденныеСтроки = ТаблицаСлов.НайтиСтроки(ОтборСлов);
	Если НайденныеСтроки.Количество() = 0 Тогда
		//Возврат;
		НоваяСтрока = ТаблицаСлов.Добавить();
		НоваяСтрока.Слово = ВыбранноеСлово;
		НоваяСтрока.ТипСлова = "Свойство";
		НайденныеСтроки = ирОбщий.ЗначенияВМассивЛкс(НоваяСтрока);
	КонецЕсли; 
	СтрокаТаблицыСлов = НайденныеСтроки[0];
	ВставитьВыбранноеСловоАвтодополнения(СтрокаТаблицыСлов,, ПараметрЗакрытия);
	Если ПараметрЗакрытия = "." Тогда
		РедакторHTML.triggerSuggestions();
	КонецЕсли; 
	Если мОткрытьСправкуПоПараметру = Истина Тогда
		Если ЛиДоступноОткрытиеСвободнойФормы() Тогда 
			//ОткрытьСправкуПоПараметру(, Ложь); 
		Иначе
			РедакторHTML.triggerSigHelp();
		КонецЕсли;
	КонецЕсли; 

КонецПроцедуры

Функция ТипСловаИзТипаСловаHTML(Знач ТипСловаHTML)
	ТипСлова = СоответствиеТипаСлова(ирОбщий.ПоследнийФрагментЛкс(ТипСловаHTML, "-"), "НКод").Имя;
	Возврат ТипСлова;
КонецФункции

Функция ЛиДоступноОткрытиеСвободнойФормы() Экспорт
	
	Возврат Истина;

КонецФункции

Процедура РедакторHTML_ОбработатьСобытие(Событие) Экспорт 
	//Сообщить("Отладка. " + Событие.event);
	Попытка
		Если Событие.event = "EVENT_BEFORE_SIGNATURE" Тогда
			РедакторHTML_ПередПоказомСигнатуры(Событие.params.activeParameter, Событие.params.word, Событие.params.activeSignature, Событие.params.triggerCharacter);
		ИначеЕсли Событие.event = "EVENT_ON_SELECT_SUGGEST_ROW" Тогда
			РедакторHTML_ПриВыбореСтрокиАвтодополнения(Событие.params.trigger, Событие.params.last_expression, Событие.params.selected, Событие.params.kind, Событие.params.insert_text, Событие.params.last_word);
		ИначеЕсли Ложь
			Или Событие.event = "EVENT_ON_ACTIVATE_SUGGEST_ROW"
			Или Событие.event = "EVENT_ON_DETAIL_SUGGEST_ROW"
		Тогда
			РедакторHTML_ПриАктивацииСтрокиАвтодополнения(Событие.params.trigger, Событие.params.focused, Событие.params.row_id, Событие.params.sideDetailIsOpened, Событие.params.kind);
		ИначеЕсли Событие.event = "EVENT_BEFORE_SHOW_SUGGEST" Тогда
			РедакторHTML_ПередПоказомАвтодополнения(Событие.params.trigger, Событие.params.last_expression, Событие.params.last_word);
		КонецЕсли;
	Исключение
		// Антибаг платформы https://www.hostedredmine.com/issues/962188
		ирОбщий.СообщитьЛкс(ОписаниеОшибки());
	КонецПопытки;
КонецПроцедуры

Процедура РедакторHTML_ПриАктивацииСтрокиАвтодополнения(Знач Триггер, Знач ТекущееСлово, Знач НомерСлова, Знач ЛиОтдельноеОписаниеАктивно, Знач ТипСловаHTML) Экспорт 
	
	// Показывать надо обязательно каждый раз, т.к. редактор забывает предыдущие уточнения типа
	#Если Сервер И Не Сервер Тогда
		ПолеТекста = Обработки.ирОболочкаПолеТекста.Создать();
	#КонецЕсли
	ТипСлова = ТипСловаИзТипаСловаHTML(ТипСловаHTML);
	Если ТипСлова = "Шаблон" Тогда
		Возврат;
	КонецЕсли; 
	РедакторHTML = ПолеТекста.РедакторHTML();
	ТекущееСлово = ЧистоеСловоСпискаПодсказкиHTML(ТекущееСлово); 
	Оп = ОписаниеТекущегоСловаАвтодополнения(ТекущееСлово,,, ЛиОтдельноеОписаниеАктивно, Триггер <> Неопределено);
	Если Оп = Неопределено Тогда
		Возврат;
	КонецЕсли;
	Если ЗначениеЗаполнено(Оп.Описание) Тогда
		Если Триггер = "hover" Тогда
			РедакторHTML.setSuggestItemDetailById(НомерСлова, Оп.Тип, Оп.Описание);
		Иначе
			МаксВысотаТочек = 800;
			РедакторHTML.setActiveSuggestDetail(Оп.Тип, Оп.Описание, МаксВысотаТочек);
		КонецЕсли; 
	КонецЕсли; 

КонецПроцедуры

Процедура РедакторHTML_ОтключитьСочетанияПереключенияСигнатуры() Экспорт 
	
	#Если Сервер И Не Сервер Тогда
		ПолеТекста = Обработки.ирОболочкаПолеТекста.Создать();
	#КонецЕсли
	РедакторHTML = ПолеТекста.РедакторHTML();
	// https://github.com/salexdv/bsl_console/issues/130
	// Коды клавиш https://microsoft.github.io/monaco-editor/api/enums/monaco.keycode.html
	РедакторHTML.disableKeyBinding(512+16); // ALT(512)+ArrowUp(16)
	РедакторHTML.disableKeyBinding(512+18); // ALT(512)+ArrowDown(18)
	
КонецПроцедуры

Процедура РедакторHTML_ВключитьСочетанияПереключенияСигнатуры() Экспорт 
	
	#Если Сервер И Не Сервер Тогда
		ПолеТекста = Обработки.ирОболочкаПолеТекста.Создать();
	#КонецЕсли
	РедакторHTML = ПолеТекста.РедакторHTML();
	// https://github.com/salexdv/bsl_console/issues/130
	РедакторHTML.enableKeyBinding(528); // ALT(512)+ArrowUp(16)
	РедакторHTML.enableKeyBinding(530); // ALT(512)+ArrowDown(18)
	
КонецПроцедуры

Процедура РедакторHTML_ОбработатьКликНаГиперссылке(Событие, ФункцияПерейтиКОпределению = "", ФункцияВычислитьВыражение = "") Экспорт 
	#Если Сервер И Не Сервер Тогда
		ПолеТекста = Обработки.ирОболочкаПолеТекста.Создать();
	#КонецЕсли
	Если ПолеТекста.ОбработатьКликНаГиперссылке(Событие) Тогда 
		Возврат;
	КонецЕсли; 
	РедакторHTML = ПолеТекста.РедакторHTML();
	РедакторHTML.hideHoverList();
	ЗаголовокГиперссылки = Событие.params.label;
	ЗначениеГиперссылки = Событие.params.href;
	Если ЗаголовокГиперссылки = "Определение" Тогда
		Координаты = ирОбщий.СтрРазделитьЛкс(ЗначениеГиперссылки, ",");
		НомерСтроки = Число(Координаты[0]);
		НомерКолонки = Число(Координаты[1]);
		Если Ложь
			Или Не ЗначениеЗаполнено(ФункцияПерейтиКОпределению)
			Или Не Вычислить("ФормаВладелец." + ФункцияПерейтиКОпределению + "(НомерСтроки, НомерКолонки)") 
		Тогда 
			ПерейтиКОпределению(НомерСтроки, НомерКолонки);
		КонецЕсли; 
	ИначеЕсли ЗаголовокГиперссылки = "Знач" Тогда
		УспехВычисления = Истина;
		Если ЗначениеЗаполнено(ФункцияВычислитьВыражение) Тогда
			ЗначениеВыражения = Вычислить("ФормаВладелец." + ФункцияВычислитьВыражение + "(ЗначениеГиперссылки, УспехВычисления)");
		КонецЕсли;
		Если УспехВычисления Тогда
			ирКлиент.ОткрытьЗначениеЛкс(ЗначениеВыражения);
		КонецЕсли; 
	ИначеЕсли Ложь
		Или Лев(ЗаголовокГиперссылки, 1) = "["
		Или ЗаголовокГиперссылки = "Допустимые типы" 
	Тогда
		ОткрытьОписаниеТипаПоГиперссылке(ЗначениеГиперссылки);
	Иначе
		ОткрытьКонтекстнуюСправку(ЗначениеГиперссылки);
	КонецЕсли;
КонецПроцедуры

Процедура КомандаРедактораHTML(Команда)
	#Если Сервер И Не Сервер Тогда
		ПолеТекста = Обработки.ирОболочкаПолеТекста.Создать();
	#КонецЕсли
	РедакторHTML = ПолеТекста.РедакторHTML();
	РедакторHTML.editor.trigger("", Команда);
КонецПроцедуры

Процедура ЗаменитьВхожденияHTML()
	КомандаРедактораHTML("editor.action.changeAll");
КонецПроцедуры

Процедура СочетанияКлавишHTML()
	ирКлиент.ОткрытьТекстЛкс(ПолучитьМакет("СочетанияКлавишHTML").ПолучитьТекст(), "Сочетания клавиш HTML редактора", "Обычный", Истина, "СочетанияКлавишHTML");
КонецПроцедуры

Процедура ОткрытьКонструкторФорматнойСтроки(ФорматнаяСтрока)
	
	Конструктор = Новый КонструкторФорматнойСтроки();
	Попытка
		Конструктор.Текст = ФорматнаяСтрока;
	Исключение
		Инфо = ИнформацияОбОшибке();
		ирОбщий.СообщитьЛкс("Ошибка в тексте форматной строки:" + Символы.ПС + Инфо.Причина.Описание);
		Возврат;
	КонецПопытки;
	Если Конструктор.ОткрытьМодально() Тогда
		Результат = Конструктор.Текст;
		Результат = СтрЗаменить(Результат, "'", "");
		Результат = """" + Результат + """";
		ВыделенныйТекст(Результат);
	КонецЕсли; 
	
КонецПроцедуры

Процедура КонструкторФорматнойСтроки()
	
	ФорматнаяСтрока = ВыделитьТекстовыйЛитерал();
	ОткрытьКонструкторФорматнойСтроки(ФорматнаяСтрока);
	
КонецПроцедуры

Процедура НайтиСледующееHTML()
	
	#Если Сервер И Не Сервер Тогда
		ПолеТекста = Обработки.ирОболочкаПолеТекста.Создать();
	#КонецЕсли
	РедакторHTML = ПолеТекста.РедакторHTML();
	РедакторHTML.nextMatch();

КонецПроцедуры

Процедура НайтиПредыдущееHTML()
	
	#Если Сервер И Не Сервер Тогда
		ПолеТекста = Обработки.ирОболочкаПолеТекста.Создать();
	#КонецЕсли
	РедакторHTML = ПолеТекста.РедакторHTML();
	РедакторHTML.previousMatch();
	
КонецПроцедуры

Процедура РедакторHTML_Перерисовать() Экспорт 
	#Если Сервер И Не Сервер Тогда
		ПолеТекста = Обработки.ирОболочкаПолеТекста.Создать();
	#КонецЕсли
	//ПолеТекста.Перерисовать();
	//ОбновитьПодсказкуПоВызовуМетода();
КонецПроцедуры

Процедура ПанельРедактораКодаПриСменеСтраницы(Знач ПанельРедактора, Знач Поле1, Знач Поле2, Знач ИсходныйТекст) Экспорт 
	
	Поле2 = ирКлиент.ОболочкаПоляТекстаЛкс(Поле2);
	Если Поле2.РедакторHTML() = Неопределено Тогда
		Возврат;
	КонецЕсли;
	Поле1 = ирКлиент.ОболочкаПоляТекстаЛкс(Поле1);
	ТекущаяСтраница = ПанельРедактора.ТекущаяСтраница;
	Если ТекущаяСтраница = ПанельРедактора.Страницы.РедакторHTML Тогда
		ЭтотОбъект.ПолеТекста = Поле2;
		ПолеТекста.ЗагрузитьСостояниеИзПоляТекстаЛкс(Поле1, ИсходныйТекст);
	Иначе
		ЭтотОбъект.ПолеТекста = Поле1;
		ПолеТекста.ЗагрузитьСостояниеИзПоляТекстаЛкс(Поле2, ИсходныйТекст);
	КонецЕсли;      

КонецПроцедуры

/////////////////////////////////////////////////

#КонецЕсли

// Добавляет правило вычисления типа значения функции.
// При вызове правила вычисляется "Правило(<СтрокаАргументов>)", а оно должно вернуть ТаблицаТипов.
// Статический.
//
// Параметры:
//  Слово        - Строка;
//  ТипСлова     - Строка - "Метод", "Свойство";
//  *ТипЗначения - ОписаниеТипов, *Неопределено;
//  *Метаданные  - Произвольный, *Неопределено;
//
Процедура ДобавитьПравилоВычисленияФункции(Знач ИмяФункции, Знач Правило, Знач ТипКонтекста = "Локальный") Экспорт
	
	Если Не ЗначениеЗаполнено(ТипКонтекста) Тогда
		ТипКонтекста = "*";
	КонецЕсли;
	КлючСтроки = Новый Структура;
	КлючСтроки.Вставить("НСлово", Нрег(ИмяФункции));
	КлючСтроки.Вставить("ТипКонтекста", ТипКонтекста);
	ПравилаВычисленияФункций = мПлатформа.мПравилаВычисленияФункций;
	НайденныеСтроки = ПравилаВычисленияФункций.НайтиСтроки(КлючСтроки);
	Если НайденныеСтроки.Количество() = 0 Тогда
		НоваяСтрока = ПравилаВычисленияФункций.Добавить();
	Иначе
		НоваяСтрока = НайденныеСтроки[0];
	КонецЕсли;
	ЗаполнитьЗначенияСвойств(НоваяСтрока, КлючСтроки);
	НоваяСтрока.Правило = Правило;
	НоваяСтрока.Слово = ИмяФункции;

КонецПроцедуры

// Статический.
// Параметры:
//    ТекущееСлово - Строка - 
//    РодительскаяСтруктураТипа - ? - 
// Возвращаемое значение:
//    СтрокаТаблицыЗначений - 
Функция НайтиПравилоВычисленияФункции(Знач ИмяМетода, Знач РодительскаяСтруктураТипа, Знач ЭтоЛокальныйКонтекст = Ложь) Экспорт
	Если РодительскаяСтруктураТипа = Неопределено Тогда
		Возврат Неопределено;
	КонецЕсли;
	ПравилаВычисленияФункций = мПлатформа.мПравилаВычисленияФункций;
	Если ПравилаВычисленияФункций.Количество() = 0 Тогда
		ДобавитьПравилоВычисленияФункции("?", "ВычислитьОператорВыбора", "Глобальный");
		ДобавитьПравилоВычисленияФункции("СтрЗаменить", "ВычислитьНеизменяющаяСтроковаяФункция", "Глобальный");
		ДобавитьПравилоВычисленияФункции("СокрЛП", "ВычислитьНеизменяющаяСтроковаяФункция", "Глобальный");
		ДобавитьПравилоВычисленияФункции("СокрП", "ВычислитьНеизменяющаяСтроковаяФункция", "Глобальный");
		ДобавитьПравилоВычисленияФункции("СокрЛ", "ВычислитьНеизменяющаяСтроковаяФункция", "Глобальный");
		ДобавитьПравилоВычисленияФункции("СокрЛ", "ВычислитьНеизменяющаяСтроковаяФункция", "Глобальный");
		ДобавитьПравилоВычисленияФункции("ТипЗнч", "ВычислитьТипЗнч", "Глобальный");
		ДобавитьПравилоВычисленияФункции("Вычислить", "ВычислитьВычислить", "Глобальный");
		ДобавитьПравилоВычисленияФункции("ПоместитьВоВременноеХранилище", "ВычислитьПоместитьВоВременноеХранилище", "Глобальный");
		ДобавитьПравилоВычисленияФункции("ПолучитьИзВременногоХранилища", "ВычислитьПолучитьИзВременногоХранилища", "Глобальный");
		ДобавитьПравилоВычисленияФункции("ЗначениеИзСтрокиВнутр", "ВычислитьПолучитьИзВременногоХранилища", "Глобальный");
		ДобавитьПравилоВычисленияФункции("ЗначениеВСтрокуВнутр", "ВычислитьПоместитьВоВременноеХранилище", "Глобальный");
		ДобавитьПравилоВычисленияФункции("ЗаписатьЗначениеJSON", "ВычислитьПоместитьВоВременноеХранилище", "Глобальный");
		ДобавитьПравилоВычисленияФункции("ПредопределенноеЗначение", "ВычислитьПредопределенноеЗначение", "Глобальный");
		ДобавитьПравилоВычисленияФункции("ПолучитьФорму", "ВычислитьПолучитьФорму", "*");
		ДобавитьПравилоВычисленияФункции("ОткрытьФорму", "ВычислитьПолучитьФорму", "*");
		ДобавитьПравилоВычисленияФункции("ПолучитьФормуСписка", "ВычислитьПолучитьФорму", "*");
		ДобавитьПравилоВычисленияФункции("ПолучитьФормуВыбора", "ВычислитьПолучитьФорму", "*");
		ДобавитьПравилоВычисленияФункции("ПолучитьОбщуюФорму", "ВычислитьПолучитьФорму", "Глобальный");
		ДобавитьПравилоВычисленияФункции("ПолучитьФормуЛкс", "ВычислитьПолучитьФорму", "*");
		ДобавитьПравилоВычисленияФункции("ОткрытьМодально", "ВычислитьОткрытьМодально", "*");
		ДобавитьПравилоВычисленияФункции("ПолучитьМакет", "ВычислитьПолучитьМакет", "*");
		ДобавитьПравилоВычисленияФункции("ПолучитьОбщийМакет", "ВычислитьПолучитьМакет", "Глобальный");
		ДобавитьПравилоВычисленияФункции("Область", "ВычислитьПолучитьОбласть", "ТабличныйДокумент");
		ДобавитьПравилоВычисленияФункции("ПолучитьОбласть", "ВычислитьПолучитьОбласть", "ТабличныйДокумент");
		ДобавитьПравилоВычисленияФункции("РеквизитФормыВЗначение", "ВычислитьРеквизитФормыВЗначение", "*");
		ДобавитьПравилоВычисленияФункции("ДанныеФормыВЗначение", "ВычислитьДанныеФормыВЗначение", "Глобальный");
		ДобавитьПравилоВычисленияФункции("ПрочитатьЗначениеJSON", "ВычислитьПрочитатьЗначениеJSON", "Глобальный");
		ДобавитьПравилоВычисленияФункции("ПрочитатьXML", "ВычислитьФабрикаXDTOПрочитатьXML", "ФабрикаXDTO");
		ДобавитьПравилоВычисленияФункции("ПрочитатьJSON", "ВычислитьФабрикаXDTOПрочитатьJSON", "ФабрикаXDTO");
		ДобавитьПравилоВычисленияФункции("ПрочитатьJSON", "ВычислитьФабрикаXDTOПрочитатьJSON", "СериализаторXDTO");
		ДобавитьПравилоВычисленияФункции("ПрочитатьJSON", "ВычислитьПрочитатьJSON", "Глобальный");
		ДобавитьПравилоВычисленияФункции("Создать", "ВычислитьФабрикаXDTOСоздать", "ФабрикаXDTO");
		ДобавитьПравилоВычисленияФункции("Создать", "ВычислитьВнешниеОбъектыСоздать", "ВнешниеОтчетыМенеджер");
		ДобавитьПравилоВычисленияФункции("Создать", "ВычислитьВнешниеОбъектыСоздать", "ВнешниеОбработкиМенеджер");
		ДобавитьПравилоВычисленияФункции("Добавить", "ВычислитьБлокировкаДанныхДобавить", "БлокировкаДанных");
		ДобавитьПравилоВычисленияФункции("Тип", "ВычислитьФабрикаXDTOТип", "ФабрикаXDTO");
		ДобавитьПравилоВычисленияФункции("Тип", "ВычислитьТип", "Глобальный");
		ДобавитьПравилоВычисленияФункции("Добавить", "ВычислитьКоллекцияДобавить", "*");
		ДобавитьПравилоВычисленияФункции("Вставить", "ВычислитьКоллекцияДобавить", "*");
		ДобавитьПравилоВычисленияФункции("Найти", "ВычислитьВременныеТаблицыЗапросаНайти", "ВременныеТаблицыЗапроса");
		ДобавитьПравилоВычисленияФункции("Выгрузить", "ВычислитьРезультатЗапросаВыгрузить", "РезультатЗапроса");
		ДобавитьПравилоВычисленияФункции("Скопировать", "ВычислитьСкопироватьКолонки", "ТаблицаЗначений");
		ДобавитьПравилоВычисленияФункции("СкопироватьКолонки", "ВычислитьСкопироватьКолонки", "ТаблицаЗначений");
		ДобавитьПравилоВычисленияФункции("ВыгрузитьКолонки", "ВычислитьСкопироватьКолонки", "*");
		ДобавитьПравилоВычисленияФункции("ВыгрузитьКолонку", "ВычислитьТаблицаЗначенийВыгрузитьКолонку", "*");
		ДобавитьПравилоВычисленияФункции("ОтобратьКоллекциюЛкс", "ВычислитьОтобратьКоллекциюЛкс", "ОбщийМодуль.ирОбщий");
		ДобавитьПравилоВычисленияФункции("НайтиЭлементКоллекцииЛкс", "ВычислитьНайтиЭлементКоллекцииЛкс", "ОбщийМодуль.ирОбщий"); // Работает и без этого. Но так быстрее
		ДобавитьПравилоВычисленияФункции("СкопироватьКолонкиКоллекцииЛкс", "ВычислитьСкопироватьКолонкиКоллекцииЛкс", "ОбщийМодуль.ирОбщий");
		ДобавитьПравилоВычисленияФункции("СоздатьОбъектПоИмениМетаданныхЛкс", "ВычислитьСоздатьОбъектПоИмениМетаданныхЛкс", "ОбщийМодуль.ирОбщий");
		ДобавитьПравилоВычисленияФункции("ТаблицаЗначенийИзТабличногоДокументаЛкс", "ВычислитьТаблицаЗначенийИзТабличногоДокументаЛкс", "*");
		ДобавитьПравилоВычисленияФункции("НоваяТаблицаЗначенийЛкс", "ВычислитьНоваяТаблицаЗначенийЛкс", "ОбщийМодуль.ирОбщий"); // Можно перевести на натуральное вычисление
		ДобавитьПравилоВычисленияФункции("НайтиРегВыражениеЛкс", "ВычислитьНайтиРегВыражениеЛкс", "ОбщийМодуль.ирОбщий");
		ДобавитьПравилоВычисленияФункции("СтруктураИзСтрокиТаблицыИлиДереваИлиВыборкиЛкс", "ВычислитьСтрокаТаблицыЗначенийВСтруктуруБСП", "ОбщийМодуль.ирОбщий");
		ДобавитьПравилоВычисленияФункции("СтруктураСвойствСтрокиТаблицыИлиДереваЛкс", "ВычислитьСтрокаТаблицыЗначенийВСтруктуруБСП", "ОбщийМодуль.ирОбщий");
		                                  
		// БСП
		ДобавитьПравилоВычисленияФункции("ОбщийМодуль", "ВычислитьОбщийМодуль", "*"); // Добавил чтобы без ограничений на количество динамических вызовов считалось
		ДобавитьПравилоВычисленияФункции("ЗначенияРеквизитовОбъекта", "ВычислитьЗначенияРеквизитовОбъектаБСП", "*");
		ДобавитьПравилоВычисленияФункции("ЗначенияРеквизитовОбъектов", "ВычислитьЗначенияРеквизитовОбъектаБСП", "*");
		ДобавитьПравилоВычисленияФункции("ЗначениеРеквизитаОбъекта", "ВычислитьЗначениеРеквизитаОбъектаБСП", "*");
		ДобавитьПравилоВычисленияФункции("СкопироватьРекурсивно", "ВычислитьФункцияКопированияПараметра", "ОбщийМодуль.ОбщегоНазначения");
		ДобавитьПравилоВычисленияФункции("СтрокаТаблицыЗначенийВСтруктуру", "ВычислитьСтрокаТаблицыЗначенийВСтруктуруБСП", "ОбщийМодуль.ОбщегоНазначения");
		ДобавитьПравилоВычисленияФункции("ТаблицаЗначенийВМассив", "ВычислитьТаблицаЗначенийВМассивБСП", "ОбщийМодуль.ОбщегоНазначения");
		ДобавитьПравилоВычисленияФункции("МакетПечатнойФормы", "ВычислитьМакетПечатнойФормыБСП", "ОбщийМодуль.УправлениеПечатью");
	КонецЕсли;
	ТипКонтекста = РодительскаяСтруктураТипа.ИмяОбщегоТипа;
	Если Истина
		И ТипКонтекста = "ОбщийМодуль" 
		И ТипЗнч(РодительскаяСтруктураТипа.Метаданные) = Тип("ОбъектМетаданных")
	Тогда
		ТипКонтекста = ТипКонтекста + "." + РодительскаяСтруктураТипа.Метаданные.Имя;
	КонецЕсли;
	КлючСтроки = Новый Структура;
	КлючСтроки.Вставить("ТипКонтекста", ТипКонтекста);
	КлючСтроки.Вставить("НСлово", НРег(ИмяМетода));
	НайденныеСтроки = ПравилаВычисленияФункций.НайтиСтроки(КлючСтроки);
	Если НайденныеСтроки.Количество() = 0 И ЭтоЛокальныйКонтекст Тогда
		КлючСтроки.ТипКонтекста = "Глобальный";   
		НайденныеСтроки = ПравилаВычисленияФункций.НайтиСтроки(КлючСтроки);
	КонецЕсли;
	Если НайденныеСтроки.Количество() = 0 Тогда
		КлючСтроки.ТипКонтекста = "*";   
		НайденныеСтроки = ПравилаВычисленияФункций.НайтиСтроки(КлючСтроки);
	КонецЕсли;
	ПравилоВычисленияФункции = Неопределено;
	Если НайденныеСтроки.Количество() > 0 Тогда
		ПравилоВычисленияФункции = НайденныеСтроки[0];
	КонецЕсли;
	Возврат ПравилоВычисленияФункции;
КонецФункции

Процедура УстановитьКонфигурациюМетаданных(пКонфигурация = Неопределено, пКонтекстВыполнения = Неопределено, Знач ДиалектSQL = Неопределено, РасширенноеПолучениеМетаданныхADO = Ложь) Экспорт

	//Если ЯзыкПрограммы = 1 Тогда
		Если ДиалектSQL = Неопределено Тогда
			Если пКонфигурация <> Неопределено Тогда
				ЭтотОбъект.Конфигурация = пКонфигурация;
			Иначе
				ЭтотОбъект.Конфигурация = Неопределено;
			КонецЕсли; 
			Если Конфигурация = Неопределено Тогда
				ЭтотОбъект.мДиалектSQL = "1С";
			Иначе
				//! Конфигурация = Новый COMОбъект("ADODB.Connection");
				ЭтотОбъект.мДиалектSQL = "MSSQL"; 
				Попытка
					Пустышка = Конфигурация.Provider;  
				Исключение
					Пустышка = Неопределено;
				КонецПопытки;
				Если Пустышка <> Неопределено Тогда
					Если Конфигурация.State = 1 Тогда
						ДиалектSQL = Конфигурация.Properties("DBMS Name").Value;
					Иначе
						// Не меняем мДиалектSQL!
					КонецЕсли; 
				Иначе
					ДиалектSQL = "WQL";
				КонецЕсли; 
			КонецЕсли; 
		Иначе
			Если ирОбщий.СтрокиРавныЛкс(ДиалектSQL, "1С") Тогда
				ЭтотОбъект.Конфигурация = Неопределено;
			Иначе
				ЭтотОбъект.Конфигурация = пКонфигурация;
			КонецЕсли; 
		КонецЕсли;
		Если мДиалектыSQL = Неопределено Тогда
			Если мПлатформа.мДиалектыSQL = Неопределено Тогда
				мПлатформа.мДиалектыSQL = ирОбщий.ТаблицаЗначенийИзТабличногоДокументаЛкс(ПолучитьМакет("ДиалектыSQL"),,, Ложь, Истина);
			КонецЕсли; 
			ЭтотОбъект.мДиалектыSQL = мПлатформа.мДиалектыSQL;
		КонецЕсли; 
		Если мДиалектыSQL.Найти(ДиалектSQL, "Диалект") <> Неопределено Тогда 
			ЭтотОбъект.мДиалектSQL = ДиалектSQL;
		КонецЕсли; 
		ЭтотОбъект.мПараметрыДиалектаSQL = мДиалектыSQL.Найти(мДиалектSQL, "Диалект");
		ЭтотОбъект.мРасширенноеПолучениеМетаданныхADO = РасширенноеПолучениеМетаданныхADO = Истина;
	//Иначе
	//	Если пКонфигурация <> Неопределено Тогда
	//		ЭтотОбъект.Конфигурация = пКонфигурация;
	//	Иначе
	//		ЭтотОбъект.Конфигурация = Неопределено;
	//	КонецЕсли; 
	//КонецЕсли;
	ЭтотОбъект.КонтекстВыполнения = пКонтекстВыполнения;

КонецПроцедуры

// Очишает таблицу слов локального контекста.
//
// Параметры:
//  Нет.
//
Процедура ОчиститьТаблицуСловЛокальногоКонтекста() Экспорт
	Если Ложь
		Или мЭтоФрагментМетода
		Или мМодульМетаданных = Неопределено // Для консоли кода без режима "Модуль"
		Или мМодульМетаданных.Имя <> мПлатформа.ИмяДинамическогоМодуля()
	Тогда
		Возврат;
	КонецЕсли;
	ОчиститьТаблицуСловЛокальногоКонтекстаПоТипуСлова();
	ОчиститьТаблицуСловЛокальногоКонтекстаПоТипуСлова("Метод");
	СброситьКэшТиповВыраженийМодуля();
КонецПроцедуры

Процедура ОчиститьТаблицуСловЛокальногоКонтекстаПоТипуСлова(Знач ТипСлова = "Свойство")
	ОтборСтрок = Новый Структура("ПозицияСОписанием", 0);
	ТаблицаЛокальногоКонтекста = ТаблицаЛокальногоКонтекста(ТипСлова);
	ВыбранныеСтроки = ТаблицаЛокальногоКонтекста.НайтиСтроки(ОтборСтрок);
	Для Каждого ВыбраннаяСтрока Из ВыбранныеСтроки Цикл
		ВыбраннаяСтрока.ТаблицаТипов = Неопределено; // Мультиметка4529884 Разрываем циклические ссылки во вложенной колонке СтрокаОписания. Возможно уже не нужно. Очищает колонки в переменной СтрокаРезультата обрабочика консоли запросов
		ТаблицаЛокальногоКонтекста.Удалить(ВыбраннаяСтрока);
	КонецЦикла;
КонецПроцедуры

Функция ПроверитьТекстИВернутьОшибку(ТекстДляПроверки = Неопределено, СтартоваяСтрока = 0, СтартоваяКолонка = 0, Контекст = Неопределено, СамаяВложеннаяПричина = Ложь) Экспорт

	#Если Сервер И Не Сервер Тогда
		мПлатформа = Обработки.ирПлатформа.Создать();
	#КонецЕсли
	ТекстИнициализации = "";
	Если ЯзыкПрограммы = 0 Тогда 
		Если мМодульМетаданных <> Неопределено Тогда
			Для Каждого ЛокальноеСлово Из мМодульМетаданных.Переменные Цикл
				Если ТипТекста = "Алгоритм" Тогда
					ТекстИнициализации = ЛокальноеСлово.Имя + " = 0; " + ТекстИнициализации;
				КонецЕсли;
			КонецЦикла;
		КонецЕсли;
		Для Каждого СтрокаПараметра Из Параметры Цикл
			Если ТипТекста = "Алгоритм" И СтрокаПараметра.Вход Тогда
				ТекстИнициализации = СтрокаПараметра.Имя + " = 0; " + ТекстИнициализации;
			КонецЕсли;
		КонецЦикла;
	КонецЕсли; 

	Если ТекстДляПроверки = Неопределено Тогда
		ТекстДляПроверки = ПолеТекста.ПолучитьТекст();
		Если Истина
			И Не ЭтоМодуль 
			И мМодульМетаданных <> Неопределено 
			И мМодульМетаданных.Методы.Количество() > 0 
		Тогда
			ВызватьИсключение "Текст программы не допускает определения методов";
		КонецЕсли;
	КонецЕсли; 
	
	СтартоваяСтрока = 0;
	СтартоваяКолонка = 0;
	Если ЯзыкПрограммы = 1 Тогда
		ТекстЗапроса = ТекстДляПроверки;
		Если ТекстЗапроса <> "" Тогда
			Если ТипТекста = "Выражение" Тогда
				лКонтекстВыполнения = КонтекстВыполнения;
				лМетодВыполнения = МетодВыполнения;
				Попытка
					ИнформацияОбОшибке = мПлатформа.ВыполнитьПрограммныйКодВКонтексте(лКонтекстВыполнения, лМетодВыполнения, ТекстЗапроса, Истина);
				Исключение
					ИнформацияОбОшибке = ИнформацияОбОшибке();
				КонецПопытки;
				СтартоваяСтрока = -1;
			Иначе
				Если мДиалектSQL <> "1С" Тогда
					РезультатРазбора = Ложь;
					#Если Клиент Тогда
					РезультатРазбора = ЗагрузитьТекстВКонструктор(ТекстЗапроса);
					#КонецЕсли
					Если Не РезультатРазбора Тогда
						ИнформацияОбОшибке = 1;
					КонецЕсли; 
				Иначе
					Если ТипЗнч(КонтекстВыполнения) = Тип("Запрос") Тогда
						ПроверочныйЗапрос = Новый Запрос;
						ПроверочныйЗапрос.МенеджерВременныхТаблиц = КонтекстВыполнения.МенеджерВременныхТаблиц;
						ПроверочныйЗапрос.Текст = ТекстЗапроса;
						Попытка
							ПроверочныйЗапрос.НайтиПараметры();
						Исключение
							ИнформацияОбОшибке = ИнформацияОбОшибке();
						КонецПопытки;
					Иначе
						КонструкторЗапроса = Новый КонструкторЗапроса;
						КонструкторЗапроса.РежимКомпоновкиДанных = РежимКомпоновкиДанных;
						Попытка
							КонструкторЗапроса.Текст = ТекстЗапроса;
						Исключение
							ИнформацияОбОшибке = ИнформацияОбОшибке();
						КонецПопытки;
					КонецЕсли; 
				КонецЕсли;
			КонецЕсли; 
		КонецЕсли;
	ИначеЕсли ЯзыкПрограммы = 0 Тогда 
		ТекстДляВыполнения = ТекстИнициализации;
		Если ТипТекста = "Выражение" Тогда
			Если ТекстДляПроверки = "" Тогда
				ТекстДляПроверки = 0;
			КонецЕсли;
			ТекстДляВыполнения = ТекстДляВыполнения + "?(Истина, 0, " + Символы.ПС + ТекстДляПроверки + Символы.ПС + ")";
		Иначе
			//ТекстДляВыполнения = ТекстДляВыполнения + "Если Ложь Тогда " + Символы.ПС + ТекстДляПроверки + Символы.ПС + " КонецЕсли"; // Заменено 06.12.2011
			ТекстДляВыполнения = "Если Ложь Тогда Попытка " + ТекстДляВыполнения + Символы.ПС + ТекстДляПроверки + Символы.ПС + " Исключение КонецПопытки КонецЕсли";
		КонецЕсли;
		Если Нрег(Контекст) = Нрег("Сервер") Тогда
			лКонтекстВыполнения = ирСервер;
			лМетодВыполнения = "ВыполнитьАлгоритм";
		ИначеЕсли Контекст <> Неопределено Тогда 
			лКонтекстВыполнения = Контекст;
			лМетодВыполнения = "ВыполнитьАлгоритм";
		Иначе
			лКонтекстВыполнения = КонтекстВыполнения;
			лМетодВыполнения = МетодВыполнения;
		КонецЕсли; 
		Попытка
			ИнформацияОбОшибке = мПлатформа.ВыполнитьПрограммныйКодВКонтексте(лКонтекстВыполнения, лМетодВыполнения, ТекстДляВыполнения, Истина);
		Исключение
			ИнформацияОбОшибке = ИнформацияОбОшибке();
		КонецПопытки;
		СтартоваяСтрока = - 1;
	ИначеЕсли ЯзыкПрограммы = 2 Тогда
		лКонтекстВыполнения = КонтекстВыполнения;
		лМетодВыполнения = МетодВыполнения;
		Попытка
			ИнформацияОбОшибке = мПлатформа.ВыполнитьПрограммныйКодВКонтексте(лКонтекстВыполнения, лМетодВыполнения, ТекстДляПроверки, Истина);
		Исключение
			ИнформацияОбОшибке = ИнформацияОбОшибке();
		КонецПопытки;
	КонецЕсли;
	Если СамаяВложеннаяПричина И ИнформацияОбОшибке <> Неопределено Тогда
		#Если Сервер И Не Сервер Тогда
			ИнформацияОбОшибке = ИнформацияОбОшибке();
		#КонецЕсли
		Пока ИнформацияОбОшибке.Причина <> Неопределено Цикл
			ИнформацияОбОшибке = ИнформацияОбОшибке.Причина;
		КонецЦикла;
	КонецЕсли; 
	Возврат ИнформацияОбОшибке;

КонецФункции

// Выполняет проверку синтаксиса программного кода
//
// Параметры:
//  *СообщатьОбУспешнойПроверке - Булево, *Ложь;
//  *ТекстДляПроверки - Строка, *Неопределено - проверяемый текст (используется весь текст или этот).
//
// Возвращаемое значение:
//  Булево - Истина если нет ошибок.
//
Функция ПроверитьПрограммныйКод(СообщатьОбУспешнойПроверке = Ложь, ТекстДляПроверки = Неопределено, Контекст = Неопределено) Экспорт
	
	СтартоваяСтрока = 0;
	СтартоваяКолонка = 0;
	ИнформацияОбОшибке = ПроверитьТекстИВернутьОшибку(ТекстДляПроверки, СтартоваяСтрока, СтартоваяКолонка, Контекст);
	Если ЗначениеЗаполнено(Контекст) Тогда
		ПредставлениеКонтекста = " (Проверка " + Контекст + ")";
	КонецЕсли; 
	Если ИнформацияОбОшибке <> Неопределено Тогда
		Если ТипЗнч(ИнформацияОбОшибке) = Тип("ИнформацияОбОшибке") Тогда
			#Если Клиент Тогда
			Если ФормаВладелец <> Неопределено Тогда
				ФормаВладелец.ТекущийЭлемент = ПолеТекста.ЭлементФормы;
			КонецЕсли; 
			ирКлиент.ПоказатьОшибкуВТекстеПрограммыЛкс(ПолеТекста, СтартоваяСтрока, СтартоваяКолонка, ЯзыкПрограммы, , ИнформацияОбОшибке,, ПредставлениеКонтекста);
			#КонецЕсли
		Иначе
			// Ошибка обработана и отображена ранее
		КонецЕсли; 
	Иначе
		Если СообщатьОбУспешнойПроверке Тогда
			СообщитьОбУспешнойПроверке(ПредставлениеКонтекста);
		КонецЕсли;
	КонецЕсли;
	Успех = ИнформацияОбОшибке = Неопределено;
	Если СообщатьОбУспешнойПроверке И Успех Тогда
		#Если Клиент Тогда
		ПроверитьВыраженияТекста(,, Истина, Истина);
		#КонецЕсли
	КонецЕсли;
	Возврат Успех;
	
КонецФункции       

Процедура СообщитьОбУспешнойПроверке(Знач ПредставлениеКонтекста = "") Экспорт 
	
	ирОбщий.СообщитьСУчетомМодальностиЛкс(ирОбщий.ПредставлениеИзИдентификатораЛкс(ПолеТекста.ЭлементФормы.Имя) 
		+ ПредставлениеКонтекста + ": Синтаксических ошибок не обнаружено!");

КонецПроцедуры

Процедура СброситьРезультатРазбораПозицииВТексте()
	
	мНачалоКонтекста = "";
	мНачалоСлова = "";
	мКонецКонтекста = "";
	мРодительскийКонтекст = "";
	мКонтекст = "";
	мЭтоТекстовыйЛитерал = Ложь;
	мЭтоОбъявлениеПсевдонима = Ложь;
	мЭтоКонструктор = Ложь;
	мНомерПараметра = 0;
	мПервыйФактическийПараметр = "";
	мФактическиеПараметры = Новый Массив;
	//КончитьОбработкуКоманды(); // Нельзя, т.к. сломается вычисление в окне "Выражение"

КонецПроцедуры

Процедура ПродолжитьОбработкуКоманды() Экспорт 
	мРазбиратьКонтекст = Ложь;
КонецПроцедуры

// Вызывается в конце обработки команды.
//
// Параметры:
//  Нет.
//
Процедура КончитьОбработкуКоманды() Экспорт
	мРазбиратьКонтекст = Истина;
КонецПроцедуры

// Комментарии заливает только если в строке левее нет инструкций.
//
// Параметры:
//  Текст								 - 	 - Строка;
//  СимволЗамена						 - 	 - Строка.
//  ЗалитьСтроковыеЛитералы				 - 	 - 
//  ЗалитьУсловия						 - Булево - очень долго, вроде бы уже не применяется
//  ЗалитьКомментарииВСмешанныхСтроках	 - Булево - 
// 
// Возвращаемое значение:
//  Строка - .
//
Функция ЗалитьКомментарииИСтроковыеЛитералы(Знач Текст, СимволЗамена = " ", Знач ЗалитьСтроковыеЛитералы = Ложь, Знач ЗалитьУсловия = Ложь, Знач ЗалитьКомментарииВСмешанныхСтроках = Ложь,
	Знач ЗалитьИнструкцииПрепроцессора = Истина) Экспорт 

	Если Не ЗначениеЗаполнено(Текст) Тогда
		Возврат Текст;
	КонецЕсли;
	мРегВыражение.Global = Истина;
	мРегВыражение.Multiline = Ложь;
	
	// Количество символов в тексте меняется, но позиции строк сохраняются
	Если Ложь
		Или ЯзыкПрограммы = 1
		Или ЯзыкПрограммы = 2
	Тогда
		////мРегВыражение.Pattern = "(""" + шИмя+ "(?:\." + шИмя + ")*"")|(" + "//(:)?[^\n]*" + ")|(" + шЛитералВЗапросе   + ")|(.|\n|\r)";
		//мРегВыражение.Pattern = "(""" + шИмя+ "(?:\." + шИмя + ")*"")|(?:" + "//:([^\n]*)" + ")|(?:" + "//[^\n]*" + ")|(" + шЛитералВЗапросе + ")|(.|\n|\r)";
		мРегВыражение.Pattern = "(""" + шИмя+ "(?:\." + шИмя + ")*"")|(?:" + "//:([^\n]*)" + ")|(?:" + "//[^\n]*" + ")|(" + шЛитералВЗапросе + ")|([\s\S])";
		ШаблонЗамены = "$1$2$3$4";
	ИначеЕсли ЯзыкПрограммы = 0 Тогда
		//мРегВыражение.Pattern = "(""" + шИмя+ "(?:\." + шИмя + ")*"")|(" + "//(:)?[^\n]*" + ")|(" + шЛитералПрограммы + ")|(.|\n|\r)";
		мРегВыражение.Pattern = "(""" + шИмя + "(?:\.[" + шБуква + "\d]+)*"")" // имена ProgId от COM объектов бывают "Forms.TextBox.1"
			+ "|(""(?:" + шИмя + "\s*,\s*)*" + шИмя + """)" // создание структуры
			+ "|" + ?(ЗалитьКомментарииВСмешанныхСтроках, "", мПлатформа.шПустоеНачалоСтроки) + "//[^\n]*" // комментарии с начала строки
			+ ?(ЗалитьИнструкцииПрепроцессора, "|#[^\n]*", "") 
			;  
		ШаблонЗамены = "$1$2$3";
		Если ЗалитьСтроковыеЛитералы Тогда
			шОднострочнаяСтрокаПрограммыСКавычки = """(?:(?:"""")|[^""\n])*""?"; 
			шОднострочнаяСтрокаПрограммыСЧерты = "(?:(\n|^)\s*\|(?:(?:"""")|[^""\n])*""?)";
			//	+ шОднострочнаяСтрокаПрограммыСКавычки + "|" + шОднострочнаяСтрокаПрограммыСЧерты + "|(.|\n|\r)";
			мРегВыражение.Pattern = мРегВыражение.Pattern  + "|" + шОднострочнаяСтрокаПрограммыСКавычки + "|" + шОднострочнаяСтрокаПрограммыСЧерты + "";
			ШаблонЗамены = ШаблонЗамены + "$4";
		Иначе
			// http://www.hostedredmine.com/issues/885452
		КонецЕсли; 
		мРегВыражение.Pattern = мРегВыражение.Pattern + "|([\s\S])";
	КонецЕсли;
	ЗалитыйТекст = мРегВыражение.Заменить(Текст, ШаблонЗамены);
	
	Если Истина 
		И мЯзыкПрограммы = 0
		И ЗалитьУсловия 
		И СтрДлина(ЗалитыйТекст) < 10000 // Долго на больших текстах!
	Тогда 
		// Заливаем условия, чтобы проверка равенства в них не считалась присвоением
		// В будущем можно отказаться от этого блока и собирать все возможные типы, а потом давать юзеру выбирать.
		мРегВыражение.Pattern = "(" + шЕсли + ")|(" + шПока + ")";
		ЗалитыйТекстОригинал = ЗалитыйТекст;
		Результат = мРегВыражение.НайтиВхождения(ЗалитыйТекстОригинал,, Истина);
		ЗалитыйТекст = Новый ЗаписьXML;
		ЗалитыйТекст.УстановитьСтроку("");
		ТекущаяПозицияВОригинале = 1;
		Для Каждого Match Из Результат Цикл
			НайденныйТекст = Неопределено;
			НачалоТокена = "";
			Если Match.SubMatches(0) <> Неопределено Тогда
				НайденныйТекст = Match.SubMatches(0);
				НачалоТокена = Match.SubMatches(1);
			ИначеЕсли Match.SubMatches(3) <> Неопределено Тогда
				НайденныйТекст = Match.SubMatches(3);
				НачалоТокена = Match.SubMatches(4);
			КонецЕсли;
			ЗалитыйТекст.ЗаписатьБезОбработки(Сред(ЗалитыйТекстОригинал, ТекущаяПозицияВОригинале, Match.FirstIndex + 1 - ТекущаяПозицияВОригинале));
			ЗалитыйТекст.ЗаписатьБезОбработки(НачалоТокена + мРегВыражение.Заменить(Сред(НайденныйТекст, 1 + СтрДлина(НачалоТокена), СтрДлина(НайденныйТекст) - СтрДлина(НачалоТокена)), СимволЗамена));
			ТекущаяПозицияВОригинале = Match.FirstIndex + 1 + СтрДлина(Match.Value); 
		КонецЦикла;
		ЗалитыйТекст.ЗаписатьБезОбработки(Сред(ЗалитыйТекстОригинал, ТекущаяПозицияВОригинале));
		ЗалитыйТекст = ЗалитыйТекст.Закрыть();
	КонецЕсли; 
	Возврат ЗалитыйТекст;

КонецФункции

//.
// Параметры:
//   ОчиститьТаблицуСлов -  - 
//   ВключатьКонструкции - Булево - включать ключевые слова и для встроенного языка конструкции
//   УчитыватьРодительскийКонтекст -  - 
//   ОбновитьТекстДляАнализа -  - 
//   ВключатьГлобальныйКонтекст -  - 
//   ТекстДляАнализа -  - 
//   ТекстСинтаксическиКорректен -  - 
//   ТолькоСвойства -  - 
//   ДляЗаголовкаМетода -  - 
Процедура ЗаполнитьЛокальныеСвойстваИМетодыПоТексту(ОчиститьТаблицуСлов = Истина, Знач ВключатьКонструкции = Истина, УчитыватьРодительскийКонтекст = Ложь, ОбновитьТекстДляАнализа = Истина,
	ВключатьГлобальныйКонтекст = Ложь, Знач ТекстДляАнализа = "", Знач ТекстСинтаксическиКорректен = Ложь, Знач ТолькоСвойства = Ложь, Знач ДляЗаголовкаМетода = Ложь) Экспорт 

	#Если Сервер И Не Сервер Тогда
		мПлатформа = Обработки.ирПлатформа.Создать();
		мРегВыражение = Обработки.ирОболочкаРегВыражение.Создать();
	#КонецЕсли
	Если ирОбщий.ПроверитьПлатформаНеWindowsЛкс(, "Заполнение параметров", Истина) Тогда
		Возврат;
	КонецЕсли; 
	Если Не ЗначениеЗаполнено(ТекстДляАнализа) Тогда
		Если Ложь
			Или ОбновитьТекстДляАнализа 
			Или мТекстБезТекстовыхЛитералов = ""
		Тогда
			Если Не ЗначениеЗаполнено(мРодительскийКонтекст) Тогда
				Если ЗначениеЗаполнено(мТекстДляПоискаОпределения) Тогда
					// Так не увидим метки дальше по тексту. Поэтому будем искать их отдельно в остатке текста в конце этого метода.
					// Еще не увидим переменные дальше по тексту, но можем хотеть объявить использованную там переменную выше.
					ТекстДляАнализа = мТекстДляПоискаОпределения; 
				КонецЕсли;
			Иначе
				Если ЗначениеЗаполнено(мТекстБлока) Тогда
					ТекстДляАнализа = мТекстБлока;          
				//Иначе
				//	ТекстДляАнализа = ПолеТекста.ПолучитьТекст(); // Опасно. На больших модулях между методами срабатывает.
				КонецЕсли;
			КонецЕсли;
		КонецЕсли;
	КонецЕсли; 
	Если ЗначениеЗаполнено(ТекстДляАнализа) Тогда
		Если мЯзыкПрограммы = 1 Тогда
			ТекстДляАнализа = СокрЛ(ТекстДляАнализа);
			Если Лев(ТекстДляАнализа, 1) = "|" Тогда 
				ТекстДляАнализа = """" + Символы.ПС + ТекстДляАнализа;
			КонецЕсли;
			Если Лев(ТекстДляАнализа, 1) = """" Тогда 
				ТекстДляАнализа = ирОбщий.ТекстИзВстроенногоЯзыкаЛкс(ТекстДляАнализа); // Мультиметка9017742
			КонецЕсли;
		КонецЕсли;
		мТекстБезТекстовыхЛитералов = ЗалитьКомментарииИСтроковыеЛитералы(ТекстДляАнализа,, Истина);
	ИначеЕсли ОбновитьТекстДляАнализа Тогда 
		мТекстБезТекстовыхЛитералов = ТекстДляАнализа;
	КонецЕсли; 

	Если ОчиститьТаблицуСлов Тогда
		ТаблицаСлов.Очистить();
	ИначеЕсли ВключатьГлобальныйКонтекст Тогда 
		ВызватьИсключение "Запрещенное сочетание параметров ОчиститьТаблицуСлов и ВключатьГлобальныйКонтекст"; 
	КонецЕсли;
	Если Истина
		И ВключатьГлобальныйКонтекст 
		И (Ложь
			Или Не УчитыватьРодительскийКонтекст
			Или ПустаяСтрока(мРодительскийКонтекст))
	Тогда
		// 23мс
		СтруктураТипа = мПлатформа.НоваяСтруктураТипа();
		СтруктураТипа.ИмяОбщегоТипа = "Глобальный";
		ПараметрыЗаполнения = мПлатформа.НовыеПараметрыЗаполненияСлов(, БазовоеРасширениеКонфигурации(),, Конфигурация,, Ложь,, мФлагиКомпиляции);
		ТаблицаГлобальногоКонтекста = мПлатформа.ТаблицаСловИзСтруктурыТипа(СтруктураТипа, ПараметрыЗаполнения);
		ТаблицаСлов.Загрузить(ТаблицаГлобальногоКонтекста);
		ирОбщий.ОбновитьКопиюКолонкиВНижнемРегистреЛкс(ТаблицаСлов, "Слово", "НСлово");
		ТаблицаГлобальногоКонтекста = Неопределено;
	КонецЕсли;
	
	ЛитералыЗначения = мПлатформа.ЛитералыЗначенияВсехЯзыков1С();
	ЧастыеВстроенныеМетоды = Новый Массив;
	Если Ложь
		Или Не УчитыватьРодительскийКонтекст
		Или мРодительскийКонтекст = ""
	Тогда
		КлючевыеСловаЯзыка = Новый Массив;
		Если мЯзыкПрограммы = 0 Тогда
			Если ДляЗаголовкаМетода Тогда
				//
			Иначе
				КлючевыеСловаЯзыка = мПлатформа.КлючевыеСловаВстроенногоЯзыка().ВыгрузитьЗначения();
				КлючевыеСловаЯзыка.Добавить("Символы");
				// Мультиметка241014_185112 сделать единый список таких методов
				ЧастыеВстроенныеМетоды.Добавить("Тип");
				ЧастыеВстроенныеМетоды.Добавить("ТипЗнч");
				ЧастыеВстроенныеМетоды.Добавить("СокрЛ");
				ЧастыеВстроенныеМетоды.Добавить("СокрЛП");
				ЧастыеВстроенныеМетоды.Добавить("Найти");
				ЧастыеВстроенныеМетоды.Добавить("Лев");
				ЧастыеВстроенныеМетоды.Добавить("Нрег");
				ЧастыеВстроенныеМетоды.Добавить("Прав");
				ЧастыеВстроенныеМетоды.Добавить("Сред");
				ЧастыеВстроенныеМетоды.Добавить("СтрДлина");
				ЧастыеВстроенныеМетоды.Добавить("ПустаяСтрока");
				//ЧастыеВстроенныеМетоды.Добавить("Дата");
				//ЧастыеВстроенныеМетоды.Добавить("Число");
				//ЧастыеВстроенныеМетоды.Добавить("Мин");
				//ЧастыеВстроенныеМетоды.Добавить("Макс");
				ЧастыеВстроенныеМетоды.Добавить("ЗначениеЗаполнено");
				ЧастыеВстроенныеМетоды.Добавить("ОписаниеТипов");
				ЧастыеВстроенныеМетоды.Добавить("И");
				ЧастыеВстроенныеМетоды.Добавить("Или");
				ЧастыеВстроенныеМетоды.Добавить("Не");
			КонецЕсли;
		ИначеЕсли мЯзыкПрограммы = 1 Тогда
			ВключаяРусские = Конфигурация = Неопределено;
			КлючевыеСловаЯзыка = мПлатформа.КлючевыеСловаЯзыкаЗапросов(РежимКомпоновкиДанных, ВключаяРусские, Истина).ВыгрузитьЗначения();
		ИначеЕсли мЯзыкПрограммы = 2 Тогда
			//СписокСловЯзыка = мПлатформа.КлючевыеСловаЯзыкаЗапросов();
			КлючевыеСловаЯзыка = Новый Массив;
			КлючевыеСловаЯзыка.Добавить("РАЗЛИЧНЫЕ"); // Криво https://www.hostedredmine.com/issues/931487
		КонецЕсли;
		Если ВключатьКонструкции Тогда
			Для Каждого Слово Из КлючевыеСловаЯзыка Цикл
				НоваяСтрока = ТаблицаСлов.Добавить();
				НоваяСтрока.Слово = Слово;
				НоваяСтрока.НСлово = НРег(Слово);
				НоваяСтрока.ТипСлова = "Конструкция";
				НоваяСтрока.Определение = "Предопределенный";
			КонецЦикла;                                      
		КонецЕсли;
		//Если ВключатьЛитералы = Неопределено Тогда
		//	ВключатьЛитералы = ВключатьКонструкции;
		//КонецЕсли;
		Если Истина
			И мЯзыкПрограммы = 0 
			И (Ложь
				Или ДляЗаголовкаМетода
				Или ВключатьКонструкции)
		Тогда
			Для Каждого ЭлементСписка Из ЛитералыЗначения Цикл
				НоваяСтрока = ТаблицаСлов.Добавить();
				Слово = ЭлементСписка.Значение;
				Если мЯзыкПрограммы = 1 Тогда
					Слово = ВРег(Слово);
				КонецЕсли;
				НоваяСтрока.Слово = Слово;
				НоваяСтрока.НСлово = НРег(НоваяСтрока.Слово);
				НоваяСтрока.ТипСлова = "Свойство";
				НоваяСтрока.Определение = "Предопределенный";
				Если Ложь
					Или ЭлементСписка.Представление = "Неопределено" 
					Или ЭлементСписка.Представление = "Null" 
				Тогда 
					НоваяСтрока.ТипЗначения = ЭлементСписка.Представление;
				Иначе
					НоваяСтрока.ТипЗначения = "Булево";
				КонецЕсли;
				НоваяСтрока.ТипЗначенияИндекс = НоваяСтрока.ТипЗначения;
			КонецЦикла;
		КонецЕсли;
	КонецЕсли;
	Если ДляЗаголовкаМетода Тогда
		Возврат;
	КонецЕсли;
	Если мРодительскийКонтекст = "" И мЯзыкПрограммы = 0 Тогда
		КлючевыеСловаЯзыка.Добавить(ИмяПеременнойВозвращаемогоЗначения());
	КонецЕсли;
	
	//Поиск использованных свойств и методов данного контекста.
	мРегВыражение.Global = Истина;
	Если Ложь
		Или Не УчитыватьРодительскийКонтекст
		Или мРодительскийКонтекст = ""
	Тогда
		шЛитералыЗначения = ирОбщий.СтрСоединитьЛкс(ЛитералыЗначения.ВыгрузитьЗначения(), "|");
		шКлючевыеСлова = ирОбщий.СтрСоединитьЛкс(КлючевыеСловаЯзыка, "|") + "|" + шЛитералыЗначения;
		шИмяСвойстваНеКлючевое = шПредИмяПрямое + "(?!(?:" + шКлючевыеСлова + ")[^?:\." + шБуква + "\d])(" + шИмя + ")";
		Если ТолькоСвойства Тогда
			Шаблон = "(ъъъ)|(ъъъ)";
		Иначе
			Если ЧастыеВстроенныеМетоды.Количество() > 0 Тогда
				шИмяМетодаНеВстроенное = шПредИмяПрямое + "(?!(?:" + ирОбщий.СтрСоединитьЛкс(ЧастыеВстроенныеМетоды, "|") + ")[^?:\." + шБуква + "\d])(" + шИмя + ")";
				Шаблон = "(?:" + шИмяМетодаНеВстроенное + "(?=\s*\())|";
			Иначе
				Шаблон = "(ъъъ)";
			КонецЕсли;
			Шаблон = Шаблон + "(" + шПараметрЗапроса + ")";
		КонецЕсли;
		Шаблон = Шаблон + "|" + шИмяСвойстваНеКлючевое + "(?=(?:\.(?:" + шИмя + ")?)+|[^?:\(\." + шБуква + "\d]|$)";
		КоличествоГрупп = 3;
	Иначе
		шИмяНеКлючевое = шПредИмяПрямое + "(?:" + ирОбщий.ТекстДляРегВыраженияЛкс(мРодительскийКонтекст) + "\.(" + шИмя + ")"; 
		Если ТолькоСвойства Тогда
			Шаблон = "(ъъъ)";
		Иначе
			Шаблон = шИмяНеКлючевое + "(?=\s*\())";
		КонецЕсли;
		Шаблон = Шаблон + "|" + шИмяНеКлючевое + "(?=[^\(?:" + шБуква + "\d]|$))";
		КоличествоГрупп = 2;
	КонецЕсли;
	НаборыСлов = НаборыСлов();
	Для Каждого НаборСлов Из НаборыСлов Цикл
		ирОбщий.ОбновитьКопиюКолонкиВНижнемРегистреЛкс(НаборСлов, "Слово",,, Истина);
	КонецЦикла;
	ТаблицаСловТЗ = ТаблицаСлов.Выгрузить(, "НСлово, ТипСлова, Частота");
	ТаблицаСловТЗ.Индексы.Добавить("НСлово");
	НаборыСлов.Добавить(ТаблицаСловТЗ);
	
	Если ЯзыкПрограммы = 0 Тогда
		мРегВыражение.Pattern = "(?:" + шЛитералПрограммы + "|" + шКомментарий + "|(?:Новый|New)\s+" + шИмя + ")";
	Иначе
		мРегВыражение.Pattern = "(?:" + шЛитералПрограммы + "|" + шКомментарий + ")";
	КонецЕсли;
	ВременныйТекст = мРегВыражение.Заменить(мТекстБезТекстовыхЛитералов, "");
	мРегВыражение.Pattern = Шаблон;
	Результат = мРегВыражение.НайтиВхождения(ВременныйТекст,, Истина);
	Счетчик = 0;
	СтарыеТипы = СтарыеТипыПеременныхТекущегоМетода();
	Если мЯзыкПрограммы = 0 И Не ЗначениеЗаполнено(мРодительскийКонтекст) Тогда
		ШагРейтингаСлова = ШагРейтингаСлова();
	Иначе
		ШагРейтингаСлова = 0;
	КонецЕсли;
	_РежимОтладки = Ложь;
	Если _РежимОтладки Тогда // Можно менять на Истина в точке останова, например условием ирОбщий.Пр(_РежимОтладки, 1, 1)
		// Пассивный оригинал расположенного ниже однострочного кода. Выполняйте изменения синхронно в обоих вариантах.
		Для Каждого Match Из Результат Цикл
			Счетчик = Счетчик + 1;
			Если Счетчик = мМаксСловНаходитьВТекстеМетода Тогда
				// Обрезка контекста для ускорения
				Прервать;
			КонецЕсли;
			Группа1 = Match.SubMatches(0);
			Группа2 = Match.SubMatches(1);
			Если КоличествоГрупп = 3 Тогда
				Группа3 = Match.SubMatches(2);
			Иначе
				Группа3 = Неопределено;
			КонецЕсли; 
			Если Группа1 <> Неопределено Тогда
				Слово = Группа1;
				ТипСлова = "Метод";
			ИначеЕсли Группа2 <> Неопределено Тогда
				Слово = Группа2;
				ТипСлова = "Свойство";
			ИначеЕсли Группа3 <> Неопределено Тогда 
				Слово = Группа3;   
				ТипСлова = "Свойство";
				Если Истина
					И ОчиститьТаблицуСлов
					И ВключатьГлобальныйКонтекст
					И ЗначениеЗаполнено(ТекстДляАнализа)
					И ТекстСинтаксическиКорректен
					И (Ложь
						Или Не УчитыватьРодительскийКонтекст
						Или мРодительскийКонтекст = "")
				Тогда 
					// Подмена контекста нужна, чтобы избежать бесконечной рекурсии через вызов КонсольКода.ЗаполнитьПараметрыВыхода в режиме ЭтоМодуль
					КонтекстВыполненияПроверки = ?(мФлагиКомпиляции.Сервер, ирСервер, ирОбщий);
					// Вызов из консоли кода для заполнения выходных параметров. https://www.hostedredmine.com/issues/947841
					ИнформацияОбОшибке = ПроверитьТекстИВернутьОшибку(ТекстДляАнализа + ";Сообщить(" + Слово + ")",,, КонтекстВыполненияПроверки);
					Если Истина
						И ИнформацияОбОшибке <> Неопределено 
						И ирОбщий.СтрНайтиЛкс(ИнформацияОбОшибке.Причина.Описание, "функция",,,, Ложь) = 0
						И ирОбщий.СтрНайтиЛкс(ИнформацияОбОшибке.Причина.Описание, "function",,,, Ложь) = 0
					Тогда
						Продолжить;
					КонецЕсли;
				КонецЕсли;
			Иначе 
				Продолжить;
			КонецЕсли;
			СтруктураКлюча = Новый Структура("НСлово", НРег(Слово));
			Если ТипСлова = "Метод" Тогда
				СтруктураКлюча.Вставить("ТипСлова", ТипСлова);
			КонецЕсли;
			НоваяСтрока = Неопределено;
			Для Каждого НаборСлов Из НаборыСлов Цикл
				НайденныеСтроки = НаборСлов.НайтиСтроки(СтруктураКлюча);
				Для Каждого НайденнаяСтрока Из НайденныеСтроки Цикл
					Если Ложь
						Или ЯзыкПрограммы = 1
						Или ТипСлова = "Метод" 
						Или (Истина
							И ТипСлова <> "Метод" 
							И НайденнаяСтрока.ТипСлова <> "Метод")
					Тогда
						НоваяСтрока = НайденнаяСтрока;
						Прервать;
					КонецЕсли;
				КонецЦикла;
				Если НоваяСтрока <> Неопределено Тогда
					Прервать;
				КонецЕсли;
			КонецЦикла;
			Если НоваяСтрока = Неопределено Тогда 
				НоваяСтрока = ТаблицаСлов.Добавить();
				НоваяСтрока.Определение = "Статистический";
				НоваяСтрока.Слово = Слово;
				НоваяСтрока.НСлово = НРег(НоваяСтрока.Слово);
				НоваяСтрока.ТипСлова = ТипСлова; 
				НоваяСтрока.ТипЗначения = "??"; 
				НоваяСтрока.Рейтинг = ШагРейтингаСлова;
				СтарыйТип = СтарыеТипы[НоваяСтрока.НСлово];
				Если СтарыйТип <> Неопределено Тогда
					НоваяСтрока.ТипЗначения = НоваяСтрока.ТипЗначения + ", " + СтарыйТип;
					НоваяСтрока.ТипЗначенияИндекс = мПлатформа.ТипЗначенияИндексИзТипа(НоваяСтрока.ТипЗначения);
				КонецЕсли;
				НоваяСтрока = ТаблицаСловТЗ.Добавить();
				ЗаполнитьЗначенияСвойств(НоваяСтрока, СтруктураКлюча);
				НоваяСтрока.Частота = 1;
			ИначеЕсли НаборСлов = ТаблицаСловТЗ Тогда
				НоваяСтрока.Частота = НоваяСтрока.Частота + 1;
			КонецЕсли;
		КонецЦикла;
	Иначе
		// Однострочный код использован для ускорения при разрешенной отладке. Выше расположен оригинал. Выполняйте изменения синхронно в обоих вариантах. Преобразовано консолью кода из подсистемы "Инструменты разработчика"
		Для Каждого Match Из Результат Цикл  			Счетчик = Счетчик + 1;  			Если Счетчик = мМаксСловНаходитьВТекстеМетода Тогда    				Прервать;  			КонецЕсли;  			Группа1 = Match.SubMatches(0);  			Группа2 = Match.SubMatches(1);  			Если КоличествоГрупп = 3 Тогда  				Группа3 = Match.SubMatches(2);  			Иначе  				Группа3 = Неопределено;  			КонецЕсли;  			Если Группа1 <> Неопределено Тогда  				Слово = Группа1;  				ТипСлова = "Метод";  			ИначеЕсли Группа2 <> Неопределено Тогда  				Слово = Группа2;  				ТипСлова = "Свойство";  			ИначеЕсли Группа3 <> Неопределено Тогда  				Слово = Группа3;  				ТипСлова = "Свойство";  				Если Истина  					И ОчиститьТаблицуСлов  					И ВключатьГлобальныйКонтекст  					И ЗначениеЗаполнено(ТекстДляАнализа)  					И ТекстСинтаксическиКорректен  					И (Ложь  						Или Не УчитыватьРодительскийКонтекст  						Или мРодительскийКонтекст = "")  				Тогда    					КонтекстВыполненияПроверки = ?(мФлагиКомпиляции.Сервер, ирСервер, ирОбщий);    					ИнформацияОбОшибке = ПроверитьТекстИВернутьОшибку(ТекстДляАнализа + ";Сообщить(" + Слово + ")",,, КонтекстВыполненияПроверки);  					Если Истина  						И ИнформацияОбОшибке <> Неопределено  						И ирОбщий.СтрНайтиЛкс(ИнформацияОбОшибке.Причина.Описание, "функция",,,, Ложь) = 0  						И ирОбщий.СтрНайтиЛкс(ИнформацияОбОшибке.Причина.Описание, "function",,,, Ложь) = 0  					Тогда  						Продолжить;  					КонецЕсли;  				КонецЕсли;  			Иначе  				Продолжить;  			КонецЕсли;  			СтруктураКлюча = Новый Структура("НСлово", НРег(Слово));  			Если ТипСлова = "Метод" Тогда  				СтруктураКлюча.Вставить("ТипСлова", ТипСлова);  			КонецЕсли;  			НоваяСтрока = Неопределено;  			Для Каждого НаборСлов Из НаборыСлов Цикл  				НайденныеСтроки = НаборСлов.НайтиСтроки(СтруктураКлюча);  				Для Каждого НайденнаяСтрока Из НайденныеСтроки Цикл  					Если Ложь  						Или ЯзыкПрограммы = 1  						Или ТипСлова = "Метод"  						Или (Истина  							И ТипСлова <> "Метод"  							И НайденнаяСтрока.ТипСлова <> "Метод")  					Тогда  						НоваяСтрока = НайденнаяСтрока;  						Прервать;  					КонецЕсли;  				КонецЦикла;  				Если НоваяСтрока <> Неопределено Тогда  					Прервать;  				КонецЕсли;  			КонецЦикла;  			Если НоваяСтрока = Неопределено Тогда  				НоваяСтрока = ТаблицаСлов.Добавить();  				НоваяСтрока.Определение = "Статистический";  				НоваяСтрока.Слово = Слово;  				НоваяСтрока.НСлово = НРег(НоваяСтрока.Слово);  				НоваяСтрока.ТипСлова = ТипСлова;  				НоваяСтрока.ТипЗначения = "??";  				НоваяСтрока.Рейтинг = ШагРейтингаСлова;  				СтарыйТип = СтарыеТипы[НоваяСтрока.НСлово];  				Если СтарыйТип <> Неопределено Тогда  					НоваяСтрока.ТипЗначения = НоваяСтрока.ТипЗначения + ", " + СтарыйТип;  					НоваяСтрока.ТипЗначенияИндекс = мПлатформа.ТипЗначенияИндексИзТипа(НоваяСтрока.ТипЗначения);  				КонецЕсли;  				НоваяСтрока = ТаблицаСловТЗ.Добавить();  				ЗаполнитьЗначенияСвойств(НоваяСтрока, СтруктураКлюча);  				НоваяСтрока.Частота = 1;  			ИначеЕсли НаборСлов = ТаблицаСловТЗ Тогда  				НоваяСтрока.Частота = НоваяСтрока.Частота + 1;  			КонецЕсли;  		КонецЦикла;  
	КонецЕсли;
	Если мЯзыкПрограммы = 0 И Не ЗначениеЗаполнено(мРодительскийКонтекст) И Не ТолькоСвойства Тогда
		шМетка = "(~" + шИмя + "):";
		ГдеИскать = Сред(мТекстБлока, СтрДлина(ТекстДляАнализа));
		//ВхожденияМеток = ирОбщий.НайтиРегВыражениеЛкс(ГдеИскать, шМетка); // Чуть дольше
		мРегВыражение.Pattern = шМетка;
		ВхожденияМеток = мРегВыражение.НайтиВхождения(ГдеИскать);
		Для Каждого Вхождение Из ВхожденияМеток Цикл
			мПлатформа.ДобавитьВТаблицуСлов(ТаблицаСлов, Вхождение.SubMatches(0),,,, "Статистический", Ложь,, Истина);
		КонецЦикла;
	КонецЕсли;
	ТаблицаСлов.ЗагрузитьКолонку(ТаблицаСловТЗ.ВыгрузитьКолонку("Частота"), "Частота");

КонецПроцедуры

//.
// Возвращаемое значение:
//    Строка - 
Функция ИмяПеременнойВозвращаемогоЗначения() Экспорт
	Возврат "Воз073"; // Длина должна совпадать по длине с "Возврат" минус 1 символ для добавления "="!
КонецФункции

//.
// Возвращаемое значение:
//    Соответствие - 
Функция СтарыеТипыПеременныхТекущегоМетода() Экспорт
	СтарыеТипы = Неопределено;
	Если мМетодМодуля <> Неопределено Тогда
		СтарыеТипы = мМетодМодуля.СтарыеТипы;
	Иначе
		// TODO сделать кэш для программы модуля
	КонецЕсли;
	Если СтарыеТипы = Неопределено Тогда
		СтарыеТипы = Новый Соответствие;
		Если мМетодМодуля <> Неопределено Тогда
			мМетодМодуля.СтарыеТипы = СтарыеТипы;
		КонецЕсли;
	КонецЕсли;
	Возврат СтарыеТипы;
КонецФункции

//.
// Возвращаемое значение:
//    Массив из ТаблицаЗначений - 
Функция НаборыСлов() Экспорт
	Если мНаборыСлов <> Неопределено Тогда
		НаборыСлов = ирОбщий.ВыгрузитьСвойствоЛкс(мНаборыСлов, "Значение");
	Иначе
		НаборыСлов = Новый Массив;
	КонецЕсли;
	Возврат НаборыСлов;
КонецФункции

Функция БазовоеРасширениеКонфигурации() Экспорт
	Результат = "";
	Если мМодульМетаданных <> Неопределено Тогда
		СтруктураТипаМодуля = мМодульМетаданных.СтруктураТипа;
	КонецЕсли;
	Если СтруктураТипаМодуля <> Неопределено Тогда 
		ДержательМетаданных = СтруктураТипаМодуля.ДержательМетаданных;
		Если Истина
			И ТипЗнч(ДержательМетаданных) = Тип("Строка") 
			И ЗначениеЗаполнено(ДержательМетаданных)
		Тогда
			Результат = ДержательМетаданных;
		ИначеЕсли ирОбщий.СтрНачинаетсяСЛкс(СтруктураТипаМодуля.ИмяОбщегоТипа, "Внешн") Тогда 
			Результат = "*";
		КонецЕсли;
	КонецЕсли;
	Возврат Результат;
КонецФункции

// Процедура - Обновить тип значения из таблицы типов
//
// Параметры:
//  НоваяСтрока			 - 	 - 
//  ТаблицаТипов		 - см. мПлатформа.НоваяТаблицаТипов() - 
//  ЗаменитьСуществующий - 	 - 
//
Процедура ОбновитьТипЗначенияИзТаблицыТипов(Знач НоваяСтрока, Знач ТаблицаТипов = Null, Знач ЗаменитьСуществующий = Истина, Знач ЛиФинальныйРасчет = Ложь) Экспорт 
	
	#Если Сервер И Не Сервер Тогда
		мПлатформа = Обработки.ирПлатформа.Создать();
	#КонецЕсли
	Если ТаблицаТипов = Null Тогда
		ТаблицаТипов = НоваяСтрока.ТаблицаТипов;
	КонецЕсли;
	СтарыйТипЗначения = НоваяСтрока.ТипЗначения;
	Если Лев(СтарыйТипЗначения, 2) = "??" Тогда
		НовыйТипЗначения = мПлатформа.ПредставлениеМассиваСтруктурТипов(ТаблицаТипов);
		Если Не ЛиФинальныйРасчет Тогда 
			Если ЗначениеЗаполнено(НовыйТипЗначения) И НовыйТипЗначения <> "??" Тогда
				НоваяСтрока.ТипЗначения = "??, " + НовыйТипЗначения;
			КонецЕсли;
		ИначеЕсли Не ЗначениеЗаполнено(НовыйТипЗначения) Тогда
			НоваяСтрока.ТипЗначения = СтрЗаменить(НоваяСтрока.ТипЗначения, "??", "?"); // Оставляем старый тип, т.к. нужно для ЗначениеРеквизитаОбъекта()
		ИначеЕсли Лев(НовыйТипЗначения, 1) = "," Тогда 
			НоваяСтрока.ТипЗначения = СокрЛ(Сред(НовыйТипЗначения, 2));
		Иначе
			НоваяСтрока.ТипЗначения = НовыйТипЗначения;
		КонецЕсли; 
	ИначеЕсли Ложь
		Или ЗаменитьСуществующий
		Или Не ЗначениеЗаполнено(СтарыйТипЗначения) 
		Или Найти(СтарыйТипЗначения, "<") > 0
	Тогда 
		НоваяСтрока.ТипЗначения = мПлатформа.ПредставлениеМассиваСтруктурТипов(ТаблицаТипов);
	КонецЕсли;
	Если Ложь
		Или ТипЗнч(НоваяСтрока) <> Тип("СтрокаТаблицыЗначений")
		Или НоваяСтрока.Владелец().Колонки.Найти("ТипЗначенияИндекс") <> Неопределено 
	Тогда
		НоваяСтрока.ТипЗначенияИндекс = мПлатформа.ТипЗначенияИндексИзТипа(НоваяСтрока.ТипЗначения);
	КонецЕсли;

КонецПроцедуры

Функция СобратьКомментарийМетода(Знач ОписаниеМетода = "", Знач СтрокаРезультата = Неопределено, Знач ЗначенияПараметров = Неопределено, Знач ШиринаТекста = 180, Знач ЗаполнятьТипы = Истина) Экспорт 
	
	#Если Сервер И Не Сервер Тогда
		ЗначенияПараметров = Новый Структура;
		мПлатформа = Обработки.ирПлатформа.Создать();
	#КонецЕсли
	ПрефиксОписанияПараметра = "//   ";
	ПрефиксОписанияПараметраПродолжение = "//              ";
	КомментарийМетода = Новый Массив;
	Для Каждого Параметр Из Параметры Цикл
		ТаблицаСвойств = Неопределено;
		Если Не ЗначениеЗаполнено(Параметр.ТипЗначения) И ЗаполнятьТипы Тогда
			ЗначениеПараметра = Параметр.Значение;
			Если ЗначенияПараметров <> Неопределено И ЗначенияПараметров.Свойство(Параметр.Имя) Тогда
				ЗначениеПараметра = ЗначенияПараметров[Параметр.Имя];
			КонецЕсли;
			СтруктураТипа = мПлатформа.СтруктураТипаИзЗначения(ЗначениеПараметра);    
			ИмяОбщегоТипа = мПлатформа.ИмяТипаИзСтруктурыТипа(СтруктураТипа);
			ТаблицаЗначений = Неопределено;
			Если Ложь
				Или ТипЗнч(ЗначениеПараметра) = Тип("Структура") 
				Или ТипЗнч(ЗначениеПараметра) = Тип("ФиксированнаяСтруктура")
			Тогда
				ТаблицаСвойств = мПлатформа.ТаблицаСловИзСтруктурыТипа(СтруктураТипа, мПлатформа.НовыеПараметрыЗаполненияСлов("Свойство"));
			ИначеЕсли Ложь
				Или ТипЗнч(ЗначениеПараметра) = Тип("ТаблицаЗначений") 
				Или ТипЗнч(ЗначениеПараметра) = Тип("ДеревоЗначений")
			Тогда
				ТаблицаЗначений = ЗначениеПараметра;
			ИначеЕсли Ложь
				Или ТипЗнч(ЗначениеПараметра) = Тип("СтрокаТаблицыЗначений") 
				Или ТипЗнч(ЗначениеПараметра) = Тип("СтрокаДереваЗначений")
			Тогда
				ТаблицаЗначений = ЗначениеПараметра.Владелец();
			КонецЕсли; 
			Если ТаблицаЗначений <> Неопределено Тогда
				СтруктураТипа = мПлатформа.СтруктураТипаИзЗначения(ТаблицаЗначений);    
				//ТаблицаСвойств = мПлатформа.ТаблицаСловИзСтруктурыТипа(СтруктураТипа,,,,,, "Метод",, "Найти");
				//ТаблицаСвойств = мПлатформа.ТаблицаСловИзСтруктурыТипа(ТаблицаСвойств[0].ТаблицаТипов[0],,,,,, "Свойство");
				ТаблицаСвойств = мПлатформа.ТаблицаСловИзСтруктурыТипа(СтруктураТипа, мПлатформа.НовыеПараметрыЗаполненияСлов("Метод",,,,,,,, "Найти"));
				ТаблицаСвойств = мПлатформа.ТаблицаСловИзСтруктурыТипа(ТаблицаСвойств[0].ТаблицаТипов[0], мПлатформа.НовыеПараметрыЗаполненияСлов("Свойство"));
			КонецЕсли;
			Параметр.ТипЗначения = ИмяОбщегоТипа;
		КонецЕсли;
		ОписаниеПараметра = СобратьКомментарийПараметра(Параметр, ШиринаТекста, ПрефиксОписанияПараметра, ПрефиксОписанияПараметраПродолжение);
		КомментарийМетода.Добавить(ОписаниеПараметра);
		Если ЗначениеЗаполнено(ТаблицаСвойств) Тогда 
			КомментарийМетода[КомментарийМетода.ВГраница()] = КомментарийМетода[КомментарийМетода.ВГраница()] + ":";
			Для Каждого Свойство Из ТаблицаСвойств Цикл
				ОбновитьТипЗначенияИзТаблицыТипов(Свойство, Свойство.ТаблицаТипов);
				ТипЗначенияСвойства = Свойство.ТипЗначения;
				КомментарийСвойства = "";
				Если ЗначениеЗаполнено(Свойство.ТаблицаТипов) Тогда
					СтрокаОписания = Свойство.ТаблицаТипов[0].СтрокаОписания;
					Если ТипЗнч(СтрокаОписания) = Тип("Структура") Тогда
						КомментарийСвойства = СтрокаОписания.Описание;
					КонецЕсли;
				КонецЕсли;
				ТипЗначенияСвойства = ПрефиксОписанияПараметра + "  * " + Свойство.Слово + " - " + ТипЗначенияСвойства + " - ";
				СНовойСтроки = СтрДлина(ТипЗначенияСвойства + СтрПолучитьСтроку(КомментарийСвойства, 1)) > ШиринаТекста;
				ирОбщий.ДобавитьМногострочнуюСтрокуВТекстЛкс(ТипЗначенияСвойства, КомментарийСвойства, ПрефиксОписанияПараметраПродолжение, СНовойСтроки);
				КомментарийМетода.Добавить(ТипЗначенияСвойства);
			КонецЦикла;
		КонецЕсли;
	КонецЦикла;
	КомментарийМетода = ирОбщий.СтрСоединитьЛкс(КомментарийМетода, Символы.ПС);
	Если ЗначениеЗаполнено(КомментарийМетода) Тогда
		КомментарийМетода = "// Параметры:" + Символы.ПС + КомментарийМетода + Символы.ПС;
	КонецЕсли; 
	Если ЗначениеЗаполнено(ОписаниеМетода) Тогда
		КомментарийМетода = Сред(ирОбщий.ДобавитьМногострочнуюСтрокуВТекстЛкс(, ОписаниеМетода, "// ", Истина), 2) + Символы.ПС + КомментарийМетода;
	ИначеЕсли Ложь
		Или ЗначениеЗаполнено(КомментарийМетода) 
		Или СтрокаРезультата <> Неопределено 
	Тогда 
		КомментарийМетода = "//.
		|" + КомментарийМетода;
	КонецЕсли;
	Если СтрокаРезультата <> Неопределено Тогда
		ОписаниеРезультата = СобратьКомментарийПараметра(СтрокаРезультата, ШиринаТекста, ПрефиксОписанияПараметра, ПрефиксОписанияПараметраПродолжение, Ложь);
		КомментарийМетода = КомментарийМетода + "// Возвращаемое значение:" + Символы.ПС + ОписаниеРезультата + Символы.ПС;
	КонецЕсли;
	Если Не ЗначениеЗаполнено(КомментарийМетода) Тогда
		КомментарийМетода = "";
	КонецЕсли;
	Возврат КомментарийМетода;

КонецФункции

//.
// Параметры:
//   Параметр - ОбработкаТабличнаяЧастьСтрока.ирКлсПолеТекстаПрограммы.Параметры - 
//   ШиринаТекста - Число - 
//   ПрефиксОписанияПараметра - Строка - 
//   ПрефиксОписанияПараметраПродолжение - Строка - 
// Возвращаемое значение:
//   Строка - 
Функция СобратьКомментарийПараметра(Знач Параметр, Знач ШиринаТекста, Знач ПрефиксОписанияПараметра, Знач ПрефиксОписанияПараметраПродолжение, Знач ДобавлятьИмя = Истина) Экспорт
	ТипЗначения = Параметр.ТипЗначения;
	Комментарий = СокрЛП(Параметр.Комментарий);
	ГрязныйТип = СокрЛП(мПлатформа.ГрязныйТипИзОписанияПараметра(Комментарий));
	Если ТипЗначения = "Неопределено" Тогда
		ТипЗначения = "";
	КонецЕсли;
	Если ТипЗначения = ГрязныйТип Тогда
		Комментарий = ирОбщий.СтрокаБезПервогоФрагментаЛкс(Комментарий, ГрязныйТип);
	КонецЕсли;
	Результат = ПрефиксОписанияПараметра;
	Если ДобавлятьИмя Тогда
		Результат = Результат + Параметр.Имя + " - ";
	КонецЕсли;
	Результат = Результат + ТипЗначения + " - ";
	Если ЗначениеЗаполнено(Комментарий) Тогда
		СНовойСтроки = СтрДлина(Результат + СтрПолучитьСтроку(Комментарий, 1)) > ШиринаТекста;
		ирОбщий.ДобавитьМногострочнуюСтрокуВТекстЛкс(Результат, Комментарий, ПрефиксОписанияПараметраПродолжение, СНовойСтроки, Истина, ПрефиксОписанияПараметра);
	КонецЕсли;
	Возврат Результат;
КонецФункции

Процедура УстановитьКлиентСерверКонтекст(Знач НовыйНаСервере = Истина) Экспорт 
	мФлагиКомпиляции = мПлатформа.НовыеФлагиКомпиляции(НовыйНаСервере, Не НовыйНаСервере, Ложь);
	Если мМодульМетаданных <> Неопределено Тогда
		УстановитьФлагиКомпиляцииМодуля();
	КонецЕсли;
КонецПроцедуры

Процедура УстановитьФлагиКомпиляцииМодуля() Экспорт
	Если мФлагиКомпиляции = Неопределено Тогда
		мФлагиКомпиляции = мПлатформа.НовыеФлагиКомпиляции();
	КонецЕсли;
	мМодульМетаданных.ФлагиКомпиляции = ирОбщий.СкопироватьКоллекциюЛкс(мФлагиКомпиляции);
	Если мИмяМодуля = мПлатформа.ИмяДинамическогоМодуля() Тогда
		мФлагиКомпиляции.Вставить("Динамический");
	КонецЕсли;
КонецПроцедуры

Функция ПроверитьОписаниеФормыИзБуфераОбмена(ТекстОписания) Экспорт
	ИмяФормы = ирОбщий.ТекстМеждуМаркерамиЛкс(ТекстОписания, "},""", """", Ложь);
	Возврат Истина
		И ЗначениеЗаполнено(ИмяФормы) 
		И ирОбщий.СтрКончаетсяНаЛкс(мИмяМодуля, ИмяФормы + ".Форма.Модуль");
КонецФункции

Процедура УстановитьСлужебныеДанныеФормы(Знач Текст) Экспорт
	СлужебныеДанные = ирОбщий.СлужебныеДанныеФормыЛкс(мМодульМетаданных.СтруктураТипа.Метаданные);
	Если ТипЗнч(мМодульМетаданных.СтруктураТипа.Метаданные) = ирОбщий.ТипУправляемаяФормаЛкс() Тогда
		Форма = мМодульМетаданных.СтруктураТипа.Метаданные;
	КонецЕсли;
	Если мПлатформа.ОбновитьКэшСтруктурыФормыИзБуфера(СлужебныеДанные, Текст, мМодульМетаданных.Текст, Форма) Тогда 
		мПлатформа.СброситьКэшТиповВыраженийМодуля(мМодульМетаданных);
	Иначе
		Если Истина
			И мМодульМетаданных.СтруктураТипа.ИмяОбщегоТипа = "ФормаКлиентскогоПриложения" 
			И мМодульМетаданных.СтруктураТипа.Метаданные.Тип = Тип("Форма")
		тогда
			мМодульМетаданных.СтруктураТипа.ИмяОбщегоТипа = "Форма";
		КонецЕсли;
	КонецЕсли;
КонецПроцедуры

// Для вызова через COM
Функция ПредставлениеМассиваСтруктурТипов(ТаблицаТипов) Экспорт 
	Возврат мПлатформа.ПредставлениеМассиваСтруктурТипов(ТаблицаТипов);
КонецФункции

// Вызывается из адаптера
//
Функция ИмяТипаКонтекста() Экспорт 
	Результат = "?";
	Если мСтруктураТипаКонтекста <> Неопределено Тогда
		//Результат = мПлатформа.ИмяТипаИзСтруктурыТипа(мСтруктураТипаКонтекста);
		//Если Результат = "Локальный" Тогда 
		Если мЭтоЛокальныйКонтекстТаблицыСлов Тогда
			Если Истина
				И мМодульМетаданных <> Неопределено
				И мМодульМетаданных.СтруктураТипа <> Неопределено 
			Тогда
				Результат = мПлатформа.ИмяТипаИзСтруктурыТипа(мМодульМетаданных.СтруктураТипа);
			КонецЕсли; 
		ИначеЕсли мТаблицаТиповКонтекста.Количество() > 1 Тогда
			//Результат = Результат + ", +" + XMLСтрока(мТаблицаТиповКонтекста.Количество() - 1) + " типов";
			Результат = "" + XMLСтрока(мТаблицаТиповКонтекста.Количество()) + ": " + ПредставлениеМассиваСтруктурТипов(мТаблицаТиповКонтекста);
		ИначеЕсли ЗначениеЗаполнено(мСтруктураТипаКонтекста.ТипЯзыка) Тогда
			Результат = мСтруктураТипаКонтекста.ТипЯзыка;
		Иначе
			Результат = мПлатформа.ИмяТипаИзСтруктурыТипа(мСтруктураТипаКонтекста);
		КонецЕсли;
	Иначе 
		Пустышка = 0;
	КонецЕсли;
	Возврат Результат;
КонецФункции

Функция ЛиНуженОбъектИзКонфигуратора() Экспорт 
	Возврат мОбъектИзКонфигуратора = Неопределено;
КонецФункции

Процедура УстановитьДанныеОбъектаИзКонфигуратора(Знач КодированнаяСтрока) Экспорт 
	ДвоичныеДанные = Base64Значение(ирОбщий.ТекстМеждуМаркерамиЛкс(КодированнаяСтрока, "#base64:", "}"));
	Текст = Новый ТекстовыйДокумент;
	Текст.Прочитать(ДвоичныеДанные.ОткрытьПотокДляЧтения());
	ТекстФайла = Текст.ПолучитьТекст();
	мОбъектИзКонфигуратора = ирОбщий.ДокументDOMИзСтрокиВнутрЛкс(ТекстФайла);
	//XMLСтрока = СтрокаВнутрВХМЛТелоЛкс(ТекстФайла);
	//мОбъектИзКонфигуратора = ТекстВДокументDOMЛкс(XMLСтрока);
	
	//Выражение = "/e/e[1]/e/d[6]/text()"; // Корневые элементы
	//Выражение = "/e/e[1]/e//d[(position()=5 or position()=6) and starts-with(text(), '""') and text()!='""""']/text()"; // Все элементы
	//Выражение = "/e/e[3]/e/d[2]/text()"; // Все параметры
	////Выражение = "/e/e[4]/e/d[2]/text()"; // Все команды
	////Выражение = "/e/e[2]/e/d[3]/text()"; // Корневые реквизиты
	//Разыменователь = Новый РазыменовательПространствИменDOM(Новый Соответствие); 
	//НаборУзлов = ДокументDOM.ВычислитьВыражениеXPath(Выражение, ДокументDOM, Разыменователь, ТипРезультатаDOMXPath.Строка);
	//УзелDOM = НаборУзлов.ПолучитьСледующий();
	//Пока УзелDOM <> Неопределено Цикл
	//	Сообщить(УзелDOM.ТекстовоеСодержимое);
	//	УзелDOM = НаборУзлов.ПолучитьСледующий();
	//КонецЦикла;

КонецПроцедуры

Процедура ОбновитьМодульМетаданных(Знач Текст = Неопределено) Экспорт 
	
	#Если Сервер И Не Сервер Тогда
		мПлатформа = Обработки.ирПлатформа.Создать();
	#КонецЕсли
	Если Текст = Неопределено Тогда
		Текст = ПолеТекста.ПолучитьТекст();
	КонецЕсли; 
	СтарыйМодульМетаданных = мМодульМетаданных;
	Если мМодульМетаданных <> Неопределено И мМодульМетаданных.СтруктураТипа <> Неопределено Тогда
		мМодульМетаданных = мПлатформа.ПодготовитьМодульМетаданных(мМодульМетаданных.СтруктураТипа, ирОбщий.ПоследнийФрагментЛкс(мИмяМодуля),, Текст, мПозицияВТексте);
	Иначе
		мИмяМодуля = мПлатформа.ИмяДинамическогоМодуля();
		мМодульМетаданных = мПлатформа.МодульМетаданных(Текст,, мИмяМодуля,, мМодульМетаданных, мПозицияВТексте);
		УстановитьФлагиКомпиляцииМодуля();
	КонецЕсли;           
	Если Истина
		И СтарыйМодульМетаданных <> Неопределено
		И СтарыйМодульМетаданных <> мМодульМетаданных
		И СтарыйМодульМетаданных.Имя = мПлатформа.ИмяДинамическогоМодуля()
		И мМодульМетаданных.Имя = мПлатформа.ИмяДинамическогоМодуля()
	Тогда
		СкопироватьСпециальныеЭлементыМодуля(СтарыйМодульМетаданных.Методы, мМодульМетаданных.Методы);
		СкопироватьСпециальныеЭлементыМодуля(СтарыйМодульМетаданных.Переменные, мМодульМетаданных.Переменные);
	КонецЕсли;

КонецПроцедуры

Процедура ПодготовитьГлобальныйКонтекст() Экспорт  
	ГлобальныйКонтекст = мПлатформа.НоваяСтруктураТипа("Глобальный");
	ПараметрыЗаполнения = мПлатформа.НовыеПараметрыЗаполненияСлов(, БазовоеРасширениеКонфигурации(),,,, Ложь,, мФлагиКомпиляции);
	мПлатформа.ТаблицаСловИзСтруктурыТипа(ГлобальныйКонтекст, ПараметрыЗаполнения);
	Попытка
		Пустышка = БиблиотекаКартинок["!"]; // Путем обращения к заведомо несуществующей картинке вызываем полную загрузку кэша картинок платформой. В редких случаях встречается длительное выполнение.
	Исключение
	КонецПопытки;
КонецПроцедуры

Процедура СкопироватьСпециальныеЭлементыМодуля(СтараяКоллекцияМодуля, НоваяКоллекцияМодуля) Экспорт
	Если Истина
		И СтараяКоллекцияМодуля.Количество() > 0 
		И СтараяКоллекцияМодуля[СтараяКоллекцияМодуля.Количество() - 1].ПозицияСОписанием = 0
	Тогда
		ирОбщий.ЗагрузитьВТаблицуЗначенийЛкс(СтараяКоллекцияМодуля.Скопировать(Новый Структура("ПозицияСОписанием", 0)), НоваяКоллекцияМодуля);
	КонецЕсли;
КонецПроцедуры

Процедура ОчиститьИсториюПереходов() Экспорт 
	мИсторияПереходов = Неопределено;
КонецПроцедуры
	
Процедура ЗапомнитьИсточникПерехода() Экспорт 
	Если мИсторияПереходов = Неопределено Тогда
		мИсторияПереходов = Новый Массив;
	КонецЕсли; 
	АдресУхода = ПолеТекста.ВыделениеДвумерное();
	Если Истина
		И мИсторияПереходов.Количество() > 0 
		И ирОбщий.СравнитьЗначенияСвойствЛкс(мИсторияПереходов[0], АдресУхода) 
	Тогда
		Возврат;
	КонецЕсли;
	мИсторияПереходов.Вставить(0, АдресУхода);
КонецПроцедуры

Функция ВернутьсяИзПерехода() Экспорт 
	
	Пока Истина Цикл
		Если мИсторияПереходов = Неопределено Или мИсторияПереходов.Количество() = 0 Тогда
			Возврат Ложь;
		КонецЕсли; 
		АдресУхода = мИсторияПереходов[0];
		Если ирОбщий.СравнитьЗначенияСвойствЛкс(ПолеТекста.ВыделениеДвумерное(), АдресУхода) Тогда
			мИсторияПереходов.Удалить(0);
		Иначе
			Прервать;
		КонецЕсли;
	КонецЦикла;
	ПолеТекста.УстановитьВыделениеДвумерное(АдресУхода);
	мИсторияПереходов.Удалить(0);
	Возврат Истина;
	
КонецФункции 

// Вызывается из адаптера
Функция ТаблицаСловВJSON(Знач КлючНабораСлов = "") Экспорт 
	
	ВыгрузкаТаблицы = ТаблицаСловДляАдаптера(КлючНабораСлов);
	Возврат ирОбщий.ТаблицаЗначенийВJSONЛкс(ВыгрузкаТаблицы);
	
КонецФункции 

//.
// Параметры:
//    КлючНабораСлов - Строка - 
// Возвращаемое значение:
//     - 
Функция ТаблицаСловДляАдаптера(Знач КлючНабораСлов) Экспорт
	Если ЗначениеЗаполнено(КлючНабораСлов) Тогда
		ИменаКолонок = "ТипСлова,Слово,ТипЗначения,Определение";
		ВыгрузкаТаблицы = мНаборыСлов[КлючНабораСлов].Скопировать(, ИменаКолонок); 
		ВыгрузкаТаблицы.Колонки.Добавить("Рейтинг", Новый описаниеТипов("Число"));
	Иначе
		ИменаКолонок = "ТипСлова,Слово,ТипЗначения,Определение,Рейтинг";
		ВыгрузкаТаблицы = ТаблицаСлов.Выгрузить(, ИменаКолонок);
	КонецЕсли;
	ВыгрузкаТаблицы.Колонки.Добавить("ЛиРез");
	ВыгрузкаТаблицы.Колонки.Добавить("ЛиМетод");
	ВыгрузкаТаблицы.Колонки.Добавить("ЛиТочный");
	ВыгрузкаТаблицы.Колонки.Добавить("Тип");           
	ВыгрузкаТаблицы.Колонки.Добавить("Приоритет");  
	ШагРейтингаСлова = ШагРейтингаСлова();
	//ВыгрузкаТаблицы[ВыгрузкаТаблицы.Количество() - 1].Рейтинг = РейтингСовпаденияТипа; // Для отладки
	_РежимОтладки = Ложь;
	Если _РежимОтладки Тогда // Можно менять на Истина в точке останова, например условием ирОбщий.Пр(_РежимОтладки, 1, 1)
		// Пассивный оригинал расположенного ниже однострочного кода. Выполняйте изменения синхронно в обоих вариантах.
		Для Каждого Строка Из ВыгрузкаТаблицы Цикл 
			Строка.ЛиРез = Строка.ТипЗначения <> "";
			Строка.ЛиМетод = Строка.ТипСлова = "Метод"; 
			Строка.ЛиТочный = Строка.Определение <> "Статистический"; 
			Строка.Тип = Лев(Строка.ТипЗначения, 200);
			Строка.Приоритет = Цел(Строка.Рейтинг/ШагРейтингаСлова) * 100;
		КонецЦикла; 
	Иначе
		// Однострочный код использован для ускорения при разрешенной отладке. Выше расположен оригинал. Выполняйте изменения синхронно в обоих вариантах. Преобразовано консолью кода из подсистемы "Инструменты разработчика"
		Для Каждого Строка Из ВыгрузкаТаблицы Цикл  			Строка.ЛиРез = Строка.ТипЗначения <> "";  			Строка.ЛиМетод = Строка.ТипСлова = "Метод";  			Строка.ЛиТочный = Строка.Определение <> "Статистический";  			Строка.Тип = Лев(Строка.ТипЗначения, 200);  			Строка.Приоритет = Цел(Строка.Рейтинг/ШагРейтингаСлова) * 100;  		КонецЦикла;  
	КонецЕсли;
	ВыгрузкаТаблицы.Колонки.Удалить("ТипСлова");
	ВыгрузкаТаблицы.Колонки.Удалить("ТипЗначения");
	ВыгрузкаТаблицы.Колонки.Удалить("Рейтинг");
	Возврат ВыгрузкаТаблицы;
КонецФункции

//.
// Возвращаемое значение:
//     - 
Функция ШагРейтингаСлова() Экспорт
	Возврат 100000;
КонецФункции

Процедура СброситьКэшТиповВыраженийМодуля() Экспорт
	мПлатформа.СброситьКэшТиповВыраженийМодуля(мМодульМетаданных);
	мКэшОжидаемогоТипа = Неопределено;
	мКэшМетаданныхФайлов.Очистить();
КонецПроцедуры

// Добавляет слово локального контекста.
//
// Параметры:
//  Слово        - Строка;
//  ТипСлова     - Строка - "Метод", "Свойство";
//  *ОписаниеТипов - ОписаниеТипов, *Неопределено - ;
//  *Метаданные  - Произвольный, *Неопределено - используется, если ОписаниеТипов задан;
//  *ТаблицаСтруктурТипа - ТаблицаЗначений, *Неопределено;
//
Функция ДобавитьСловоЛокальногоКонтекста(Слово, ТипСлова = "Свойство", Знач ОписаниеТипов = Неопределено,
	пМетаданные = Неопределено, ТипЗначения = "", Значение = Неопределено, ТаблицаТипов = Неопределено, Знач ИмяОбщегоТипа = "") Экспорт
	
	КлючСтроки = Новый Структура;
	КлючСтроки.Вставить("нИмя", Нрег(Слово));
	ТаблицаЛокальногоКонтекста = ТаблицаЛокальногоКонтекста(ТипСлова);
	НайденныеСтроки = ТаблицаЛокальногоКонтекста.НайтиСтроки(КлючСтроки);
	Если НайденныеСтроки.Количество() = 0 Тогда
		НоваяСтрока = ТаблицаЛокальногоКонтекста.Добавить();
		НоваяСтрока.Имя = Слово;
		ЗаполнитьЗначенияСвойств(НоваяСтрока, КлючСтроки);
	Иначе
		НоваяСтрока = НайденныеСтроки[0];
	КонецЕсли;
	Если ТаблицаТипов = Неопределено Тогда
		ТаблицаТипов = мПлатформа.НоваяТаблицаТипов();
	КонецЕсли;
	НоваяСтрока.ТаблицаТипов = ТаблицаТипов;
	НоваяСтрока.Вычислено = Истина;
	Если ЗначениеЗаполнено(ИмяОбщегоТипа) Тогда
		СтруктураТипа = мПлатформа.НоваяСтруктураТипа(ИмяОбщегоТипа);
		СтруктураТипа.Метаданные = пМетаданные;
		мПлатформа.ДобавитьВТаблицуТипов(ТаблицаТипов, СтруктураТипа);
	КонецЕсли;
	Если Значение <> Неопределено Тогда
		СтруктураТипа = мПлатформа.СтруктураТипаИзЗначения(Значение, ЯзыкПрограммы,
			Новый Структура("СтрокаОписания, Метаданные", НоваяСтрока, пМетаданные)); // Циклическая ссылка СтрокаОписания
		мПлатформа.ДобавитьВТаблицуТипов(ТаблицаТипов, СтруктураТипа);
	КонецЕсли; 
	//Если Значение <> Неопределено Тогда
	//	Если ОписаниеТипов = Неопределено Тогда
	//		ОписаниеТипов = Новый ОписаниеТипов;
	//	КонецЕсли; 
	//	ОписаниеТипов = Новый ОписаниеТипов(ОписаниеТипов, ирОбщий.ЗначенияВМассивЛкс(ТипЗнч(Значение)));
	//КонецЕсли;
	Если ОписаниеТипов <> Неопределено Тогда
		Для Каждого Тип Из ОписаниеТипов.Типы() Цикл
			СтруктураТипа = мПлатформа.СтруктураТипаИзКонкретногоТипа(Тип, ЯзыкПрограммы,
				Новый Структура("СтрокаОписания, Метаданные", НоваяСтрока, пМетаданные)); // Циклическая ссылка СтрокаОписания
			мПлатформа.ДобавитьВТаблицуТипов(ТаблицаТипов, СтруктураТипа);
		КонецЦикла;
	КонецЕсли;
	Если Не ЗначениеЗаполнено(ТипЗначения) Тогда
		НоваяСтрока.ТипЗначения = мПлатформа.ПредставлениеМассиваСтруктурТипов(ТаблицаТипов);
	КонецЕсли;
	//СброситьКэшТиповВыраженийМодуля(); // Мешает подсказке в параметрах ОтобратьКоллекциюЛкс, т.к. там ТаблицаТипов передается
	Возврат НоваяСтрока;

КонецФункции

Функция ТаблицаЛокальногоКонтекста(Знач ТипСлова = "Свойство") Экспорт
	
	Если мМодульМетаданных = Неопределено Тогда
		ОбновитьМодульМетаданных(""); 
	КонецЕсли;
	Если ТипСлова = "Метод" Тогда
		ТаблицаЛокальногоКонтекста = мМодульМетаданных.Методы;
	Иначе
		ТаблицаЛокальногоКонтекста = мМодульМетаданных.Переменные;
	КонецЕсли; 
	Возврат ТаблицаЛокальногоКонтекста;

КонецФункции

// Не рекомендуется вызывать. Вызывается из адаптера. 
Функция ЛиТекстЯзыкаЗапросовЛкс(Знач НачалоТекста) Экспорт 
	
	Результат = ирОбщий.ЛиТекстЯзыкаЗапросовЛкс(НачалоТекста);
	Возврат Результат;

КонецФункции

// вызывается из адаптера
Функция ПрочитатьУдалитьСообщенияПользователю() Экспорт
	Если мПлатформа.мОчередьСообщений = Неопределено Тогда
		Результат = "";
	Иначе
		Результат = ирОбщий.СтрСоединитьЛкс(мПлатформа.мОчередьСообщений, Символы.ПС);
	КонецЕсли;
	мПлатформа.мОчередьСообщений = Новый Массив;
	Возврат Результат;
КонецФункции

//ирПортативный лФайл = Новый Файл(ИспользуемоеИмяФайла);
//ирПортативный ПолноеИмяФайлаБазовогоМодуля = Лев(лФайл.Путь, СтрДлина(лФайл.Путь) - СтрДлина("Модули\")) + "ирПортативный.epf";
//ирПортативный #Если Клиент Тогда
//ирПортативный 	Контейнер = Новый Структура();
//ирПортативный 	Оповестить("ирПолучитьБазовуюФорму", Контейнер);
//ирПортативный 	Если Не Контейнер.Свойство("ирПортативный", ирПортативный) Тогда
//ирПортативный 		ирПортативный = ВнешниеОбработки.ПолучитьФорму(ПолноеИмяФайлаБазовогоМодуля);
//ирПортативный 		ирПортативный.Открыть();
//ирПортативный 	КонецЕсли; 
//ирПортативный #Иначе
//ирПортативный 	ирПортативный = ВнешниеОбработки.Создать(ПолноеИмяФайлаБазовогоМодуля, Ложь); // Это будет второй экземпляр объекта
//ирПортативный #КонецЕсли
//ирПортативный ирОбщий = ирПортативный.ОбщийМодульЛкс("ирОбщий");
//ирПортативный ирКэш = ирПортативный.ОбщийМодульЛкс("ирКэш");
//ирПортативный ирСервер = ирПортативный.ОбщийМодульЛкс("ирСервер");
//ирПортативный ирКлиент = ирПортативный.ОбщийМодульЛкс("ирКлиент");

#Если Сервер И Не Сервер Тогда
	мПлатформа = Обработки.ирПлатформа.Создать();
	мРегВыражение = Обработки.ирОболочкаРегВыражение.Создать();
	мМодульМетаданных = мПлатформа.МодульМетаданных("");
	ФормаВладелец = ОткрытьФорму(); // см. Обработка.ирКлсПолеТекстаПрограммы.Форма.ФормаПример
	ИнициироватьНеинтерактивно();
	УстановитьКонфигурациюМетаданных();
	СоздатьСлужебноеПоле();    
	мНаборыСлов = Новый Соответствие; // Без этой строки со старта почему то не собирались типы вложенных значений
	мНаборыСлов.Вставить(, мПлатформа.НоваяТаблицаСлов());
#КонецЕсли
