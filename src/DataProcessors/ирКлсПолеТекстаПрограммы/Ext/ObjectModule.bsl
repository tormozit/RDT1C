//ирПортативный Перем ирПортативный Экспорт;
//ирПортативный Перем ирОбщий Экспорт;
//ирПортативный Перем ирСервер Экспорт;
//ирПортативный Перем ирКэш Экспорт;
//ирПортативный Перем ирКлиент Экспорт;

Перем ИмяКласса Экспорт;
Перем СсылочнаяФормаКласса Экспорт;
Перем ДопКнопкиКомандныхПанелей Экспорт;
Перем СоответствиеЭУ Экспорт;
Перем мФормаАвтодополнение Экспорт; 
Перем мФормаВызовМетода Экспорт; 
Перем мФормаКласса; // см. Обработка.ирКлсПолеТекстаПрограммы.Форма.ФормаМакет
Перем мКодКлавишиОткрытияАвтодополнения;

Перем мРегВыражение Экспорт;
Перем мСлужебнаяФорма Экспорт; 
Перем СлужебноеПолеТекстаДолгое Экспорт;
Перем мПолеТекстаВременное Экспорт;
Перем мПарсер;
Перем мШиринаТабуляции;
Перем мПлатформа Экспорт;
Перем мНачальнаяСтрока Экспорт; // снаружи только для чтения
Перем мНачальнаяКолонка Экспорт; // снаружи только для чтения
Перем мКонечнаяСтрока Экспорт; // снаружи только для чтения
Перем мКонечнаяКолонка Экспорт; // снаружи только для чтения
Перем мТекущаяСтрокаНачало Экспорт;
//Перем ОригинальнаяСтрока;
Перем мТекущаяСтрокаКонец;
Перем мНачалоКонтекста;
Перем мНачалоСлова;
Перем мКонецКонтекста; 
Перем мОригинальныйТекст Экспорт;
Перем мСтарыйОригинальныйТекст Экспорт;
Перем мТекстБезКомментариевИОпасныхСтрок Экспорт;
Перем мТекстБезТекстовыхЛитералов Экспорт;
Перем мТекстДляПоискаОпределения Экспорт;
Перем мТекстБлока Экспорт;
Перем мПозицияТекстаДляПоискаОпределения Экспорт;
Перем мНачальнаяПозиция0ВложенногоТекста Экспорт;
Перем мРодительскийКонтекст Экспорт;
Перем мКонтекст Экспорт;  // Содержит текст родительского контекста и полное слово в текущем контексте (в нем находится каретка). Для отладки сделан экспортным
Перем мВызовМетода Экспорт;
Перем мЭтоТекстовыйЛитерал Экспорт;
Перем мЭтоОбъявлениеПсевдонима Экспорт;
Перем мТекущееСлово;
Перем мПозицияВТексте Экспорт;
Перем мПозицияВБлоке Экспорт;
Перем мПредшествующийТекст Экспорт;
Перем мСтарыйПредшествующийТекст;
Перем мКэшОжидаемогоТипа; // см. КэшОжидаемогоТипа
Перем мНомерПараметра Экспорт;
Перем мИмяМетодаВызова Экспорт;
Перем мЭтоКонструктор Экспорт;
Перем мФактическиеПараметры Экспорт;
Перем мПервыйФактическийПараметр;
Перем мРазбиратьКонтекст;
Перем мРекурсивныйПуть Экспорт; // см. ИнициироватьРекурсивныйПуть()
Перем мАвтоКонтекстнаяПомощь Экспорт;
Перем мРасширенноеПолучениеМетаданныхADO Экспорт;
Перем мПравилаВычисленияФункций Экспорт;
Перем мПоследнийРежимВызоваСправки;
Перем мИменаОбщихТиповПоИменамКлассовCOM;
Перем мДиалектSQL Экспорт;
Перем мДиалектыSQL Экспорт;
Перем мПараметрыДиалектаSQL Экспорт; 
Перем мТерминалыЯзыкаЗапросов Экспорт;
Перем мПрефиксыПараметров Экспорт;
Перем мАнглийский1С;
Перем мМаркерСлужебногоКомментария Экспорт;
Перем мМаркерПорядкаОтладки Экспорт;
Перем мОткрытьСправкуПоПараметру Экспорт; // снаружи только для чтения
Перем мМодульМетаданных Экспорт;  // см. мПлатформа.ПодготовитьМодульМетаданных()
Перем мИмяМодуля Экспорт;
Перем мСтруктурыТиповПодсказкиУдержания;
Перем ИменаВсехКомКлассов;
Перем мКонкретныйТипКонтекста;
Перем мСтруктураТипаКонтекста Экспорт; // см. мПлатформа.НоваяСтруктураТипа()
Перем мТаблицаТиповКонтекста Экспорт; // см. мПлатформа.НоваяТаблицаТипов()
Перем мАгрегатныеТипыКонтекста Экспорт;
Перем мЭтоЛокальныйКонтекстТаблицыСлов Экспорт;
Перем мТолькоСсылочныеИменаТипов;
Перем мСоответствиеТиповСловHTML;
Перем РазрешеноСобытиеПередПоказомАвтодополнения;
Перем АвтоматическаяПодсказкаПоВызовуМетода Экспорт;
Перем АвтоматическаяПодсказкаАвтодополненияHTML Экспорт;
Перем ПоказыватьВсеТипыВСпискеАвтодополненияHTML Экспорт;
Перем ПредпочитатьHTMLРедакторКода Экспорт;
Перем мЭтоАвтоВызов;
Перем МаксСловНаходитьВТекстеМетода;
Перем мДоступныеПоляТаблиц;  
Перем мМетодМодуля Экспорт; // см. мПлатформа.НоваяТаблицаМетодовМодуля()[0]
Перем мНомерПервойСтрокиТелаМетода Экспорт;
Перем мНомерПоследнейСтрокиТелаМетода Экспорт;
Перем мИсторияПереходов;
Перем мФлагиКомпиляции Экспорт; // см. мПлатформа.НовыеФлагиКомпиляции()
Перем мКорневаяТаблицаТипов Экспорт;
Перем мОбъектИзКонфигуратора;
Перем мЯзыкПрограммы Экспорт; // Может меняться на вложенный язык в РазобратьТекущийКонтекст()
Перем мПакетЗапросов Экспорт; // см. НовыйПакетЗапросов()
Перем мИндексЗапросаПакета Экспорт; 
Перем мМенеджерВременныхТаблиц Экспорт; // см. НовыйМенеджерВременныхТаблиц()
Перем мНаборыСлов Экспорт; // Соответствие
Перем мЗаменяемыйДиапазон Экспорт;
Перем мЗамещающийФрагмент Экспорт;
Перем мСтрокаЛучшегоСлова;
Перем мИмяОжидаемогоТипа;
Перем мФлагиПодавленияОшибок; // Структура

Перем шЧисло;
Перем шЛюбой;
Перем шБуква Экспорт;
Перем шЛитералПрограммы Экспорт;
Перем шНачалоЛитералаПрограммы;
Перем шЛитералВЗапросе;
Перем шИндекс;
Перем шСкобки;
Перем шСкобкиЛенивые;
Перем шИмя;
Перем шИмяСкобки;
Перем шИмяСТочками Экспорт;
Перем шПараметрЗапроса;
Перем шПредИмяПрямое Экспорт;
Перем шПостИмяСвойства Экспорт;
Перем шПредИнструкция;
Перем шРазделитель;
Перем шНазначениеТипаПриПрисвоении;
Перем шВыражениеПрограммы Экспорт;
Перем шВыражениеЗапроса;
Перем шВызовМетодаПрограммы;
Перем шВызовМетодаЗапроса;
Перем шИЗ;
Перем шОписаниеТаблицы;
Перем шОписаниеТаблицыСЗахватом;
Перем шПока;
Перем шЕсли;
Перем шВызватьИсключение;
Перем шНачалоТокена;  
Перем шКонецТокена;
Перем шКомментарий;
Перем шПрисвоение;
Перем шПростоеВыражениеПрограммы;
Перем шПоискОписанияТаблицы;
Перем шСимволыПрефиксаПараметра;
Перем шПрефиксПараметраНеобяз;
Перем шПроверяемоеВыражение;
Перем шОбъектноеВыражение;
Перем шНачалоДок;
Перем шОбходКоллекции;

// Инициализирует экземпляр класса.
//
// Параметры:
//  *СтруктураЭкземляров - Структура, *Неопределено - содержит все объекты данного класса для данной формы;
//  пФорма       - Форма - владелец элементов управления;
//  пПолеТекстовогоДокумента - ПолеТекста;
//  *пКоманднаяПанель - КоманднаяПанель, *Неопределено - в конце которой будут размещены кнопки;
//  *пЛиЯзыкЗапросов - Булево, *Ложь - режим языка запросов, иначе внутренний язык;
//  *пМетодВыполнения - Строка, *"" - имя метода выполнения программного кода;
//  *пКонтекстВыполнения - Тип, Запрос, Произвольный, *Неопределено - контекст выполнения программного кода или текста запроса;
//  *пТипТекста  - Строка, *"Алгоритм" - "Алгоритм" или "Выражение".
//
Процедура ИнициироватьНеинтерактивно(пЯзыкПрограммы = 0, пМетодВыполнения = "", пКонтекстВыполнения = Неопределено, пТипТекста = "Алгоритм", пКонфигурация = Неопределено,
	Знач пПолеТекстовогоДокумента = Неопределено) Экспорт
	
	Если мСлужебнаяФорма = Неопределено Тогда 
		СоздатьСлужебноеПоле();
	КонецЕсли; 
	
	
	ЭтотОбъект.ЯзыкПрограммы = пЯзыкПрограммы;
	мЯзыкПрограммы = пЯзыкПрограммы;
	ЭтотОбъект.МетодВыполнения = пМетодВыполнения;
	ЭтотОбъект.ТипТекста = пТипТекста;
	#Если Клиент Тогда
		Если пПолеТекстовогоДокумента = Неопределено Тогда 
			пПолеТекстовогоДокумента = мПлатформа.НовоеСлужебноеПолеТекста(мСлужебнаяФорма, "1");
		КонецЕсли;
		ЭтотОбъект.ПолеТекста = ирКлиент.ОболочкаПоляТекстаЛкс(пПолеТекстовогоДокумента);
	#Иначе
		ЭтотОбъект.ПолеТекста = Новый ТекстовыйДокумент;
	#КонецЕсли                 
	УстановитьКонфигурациюМетаданных(пКонфигурация, пКонтекстВыполнения);
	мПрефиксыПараметров = мДиалектыSQL.Скопировать(, "ПрефиксПараметра");
	мПрефиксыПараметров.Свернуть("ПрефиксПараметра");
	мПрефиксыПараметров.ВыгрузитьКолонку(0); 
	
	Если ЯзыкПрограммы = 1 Тогда
		Если КонтекстВыполнения = Неопределено Тогда
			КонтекстВыполнения = Новый Запрос;
		КонецЕсли;
		ИнициироватьТерминалыЯзыкаЗапросов();
	КонецЕсли;
	
	Если МетодВыполнения = "" Тогда
		ЭтотОбъект.МетодВыполнения = "ВыполнитьЛокально";
	КонецЕсли;
	Попытка
		ПроверитьПрограммныйКод(, "");
	Исключение
		ирОбщий.СообщитьСУчетомМодальностиЛкс(ОписаниеОшибки());
		ирОбщий.СообщитьСУчетомМодальностиЛкс("Задан неверный контекст выполнения программы. Будет использован общий контекст выполнения");
		ЭтотОбъект.КонтекстВыполнения = ЭтотОбъект;
		ЭтотОбъект.МетодВыполнения = "ВыполнитьПрограмму";
	КонецПопытки;
	ДобавитьПравилоВычисленияФункции("Вычислить", "ВычислитьВычислить", "Локальный");
	ДобавитьПравилоВычисленияФункции("ПоместитьВоВременноеХранилище", "ВычислитьПоместитьВоВременноеХранилище", "Локальный");
	ДобавитьПравилоВычисленияФункции("ПолучитьИзВременногоХранилища", "ВычислитьПолучитьИзВременногоХранилища", "Локальный");
	ДобавитьПравилоВычисленияФункции("ЗначениеИзСтрокиВнутр", "ВычислитьПолучитьИзВременногоХранилища", "Локальный");
	ДобавитьПравилоВычисленияФункции("ЗначениеВСтрокуВнутр", "ВычислитьПоместитьВоВременноеХранилище", "Локальный");
	ДобавитьПравилоВычисленияФункции("ПредопределенноеЗначение", "ВычислитьПредопределенноеЗначение", "Локальный");
	ДобавитьПравилоВычисленияФункции("ПолучитьФорму", "ВычислитьПолучитьФорму", "*");
	ДобавитьПравилоВычисленияФункции("ОткрытьФорму", "ВычислитьПолучитьФорму", "*");
	ДобавитьПравилоВычисленияФункции("ПолучитьФормуСписка", "ВычислитьПолучитьФорму", "*");
	ДобавитьПравилоВычисленияФункции("ПолучитьФормуВыбора", "ВычислитьПолучитьФорму", "*");
	ДобавитьПравилоВычисленияФункции("ПолучитьОбщуюФорму", "ВычислитьПолучитьФорму", "Локальный");
	ДобавитьПравилоВычисленияФункции("ПолучитьФормуЛкс", "ВычислитьПолучитьФорму", "*");
	ДобавитьПравилоВычисленияФункции("ПолучитьМакет", "ВычислитьПолучитьМакет", "*");
	ДобавитьПравилоВычисленияФункции("ПолучитьОбщийМакет", "ВычислитьПолучитьМакет", "Локальный");
	ДобавитьПравилоВычисленияФункции("Область", "ВычислитьПолучитьОбласть", "ТабличныйДокумент");
	ДобавитьПравилоВычисленияФункции("ПолучитьОбласть", "ВычислитьПолучитьОбласть", "ТабличныйДокумент");
	ДобавитьПравилоВычисленияФункции("РеквизитФормыВЗначение", "ВычислитьРеквизитФормыВЗначение", "*");
	ДобавитьПравилоВычисленияФункции("ПрочитатьЗначениеJSON", "ВычислитьПрочитатьЗначениеJSON", "Локальный");
	ДобавитьПравилоВычисленияФункции("ПрочитатьXML", "ВычислитьФабрикаXDTOПрочитатьXML", "ФабрикаXDTO");
	ДобавитьПравилоВычисленияФункции("ПрочитатьJSON", "ВычислитьФабрикаXDTOПрочитатьJSON", "ФабрикаXDTO");
	ДобавитьПравилоВычисленияФункции("Создать", "ВычислитьФабрикаXDTOСоздать", "ФабрикаXDTO");
	ДобавитьПравилоВычисленияФункции("Создать", "ВычислитьВнешниеОбъектыСоздать", "ВнешниеОтчетыМенеджер");
	ДобавитьПравилоВычисленияФункции("Создать", "ВычислитьВнешниеОбъектыСоздать", "ВнешниеОбработкиМенеджер");
	ДобавитьПравилоВычисленияФункции("Тип", "ВычислитьФабрикаXDTOТип", "ФабрикаXDTO");
	ДобавитьПравилоВычисленияФункции("Добавить", "ВычислитьКоллекцияДобавить", "*");
	ДобавитьПравилоВычисленияФункции("Вставить", "ВычислитьКоллекцияДобавить", "*");
	ДобавитьПравилоВычисленияФункции("Найти", "ВычислитьВременныеТаблицыЗапросаНайти", "ВременныеТаблицыЗапроса");
	ДобавитьПравилоВычисленияФункции("Выгрузить", "ВычислитьРезультатЗапросаВыгрузить", "РезультатЗапроса");
	ДобавитьПравилоВычисленияФункции("Скопировать", "ВычислитьСкопироватьКолонки", "ТаблицаЗначений");
	ДобавитьПравилоВычисленияФункции("СкопироватьКолонки", "ВычислитьСкопироватьКолонки", "ТаблицаЗначений");
	ДобавитьПравилоВычисленияФункции("ВыгрузитьКолонку", "ВычислитьТаблицаЗначенийВыгрузитьКолонку", "*");
	ДобавитьПравилоВычисленияФункции("ОтобратьКоллекциюЛкс", "ВычислитьОтобратьКоллекциюЛкс", "ОбщийМодуль.ирОбщий");
	ДобавитьПравилоВычисленияФункции("НайтиЭлементКоллекцииЛкс", "ВычислитьНайтиЭлементКоллекцииЛкс", "ОбщийМодуль.ирОбщий"); // Работает и без этого. Но так быстрее
	ДобавитьПравилоВычисленияФункции("СкопироватьКолонкиКоллекцииЛкс", "ВычислитьСкопироватьКолонкиКоллекцииЛкс", "ОбщийМодуль.ирОбщий");
	ДобавитьПравилоВычисленияФункции("СоздатьОбъектПоИмениМетаданныхЛкс", "ВычислитьСоздатьОбъектПоИмениМетаданныхЛкс", "ОбщийМодуль.ирОбщий");
	ДобавитьПравилоВычисленияФункции("ТаблицаЗначенийИзТабличногоДокументаЛкс", "ВычислитьТаблицаЗначенийИзТабличногоДокументаЛкс", "*");
	ДобавитьПравилоВычисленияФункции("НоваяТаблицаЗначенийЛкс", "ВычислитьНоваяТаблицаЗначенийЛкс", "ОбщийМодуль.ирОбщий"); // Можно перевести на натуральное вычисление
	ДобавитьПравилоВычисленияФункции("НайтиРегВыражениеЛкс", "ВычислитьНайтиРегВыражениеЛкс", "ОбщийМодуль.ирОбщий");
	ДобавитьПравилоВычисленияФункции("СтруктураСвойствСтрокиТаблицыИлиДереваЛкс", "ВычислитьСтрокаТаблицыЗначенийВСтруктуруБСП", "ОбщийМодуль.ирОбщий");
	
	// БСП
	ДобавитьПравилоВычисленияФункции("ОбщийМодуль", "ВычислитьОбщийМодуль", "ОбщийМодуль.ОбщегоНазначения"); // Добавил чтобы без ограничений на количество динамических вызовов считалось
	ДобавитьПравилоВычисленияФункции("ЗначенияРеквизитовОбъекта", "ВычислитьЗначенияРеквизитовОбъектаБСП", "");
	ДобавитьПравилоВычисленияФункции("ЗначениеРеквизитаОбъекта", "ВычислитьЗначениеРеквизитаОбъектаБСП", "");
	ДобавитьПравилоВычисленияФункции("СкопироватьРекурсивно", "ВычислитьФункцияКопированияПараметра", "ОбщийМодуль.ОбщегоНазначения");
	ДобавитьПравилоВычисленияФункции("СтрокаТаблицыЗначенийВСтруктуру", "ВычислитьСтрокаТаблицыЗначенийВСтруктуруБСП", "ОбщийМодуль.ОбщегоНазначения");
	ДобавитьПравилоВычисленияФункции("МакетПечатнойФормы", "ВычислитьМакетПечатнойФормыБСП", "ОбщийМодуль.УправлениеПечатью");
	
КонецПроцедуры

Процедура СоздатьСлужебноеПоле() Экспорт
	мСлужебнаяФорма = мПлатформа.ПолучитьФорму("Служебная");
	СлужебноеПолеТекстаДолгое = мПлатформа.НовоеСлужебноеПолеТекста(мСлужебнаяФорма);
КонецПроцедуры

Процедура ИнициироватьТерминалыЯзыкаЗапросов() Экспорт 
	
	Если мТерминалыЯзыкаЗапросов = Неопределено Тогда
		мТерминалыЯзыкаЗапросов = Новый Соответствие;
		мТерминалыЯзыкаЗапросов = ирОбщий.ТаблицаЗначенийИзТабличногоДокументаЛкс(мПлатформа.ПолучитьМакет("ТерминалыЯзыкаЗапросов"),,,, Истина);
		мТерминалыЯзыкаЗапросов.Индексы.Добавить("Ключ");
		мТерминалыЯзыкаЗапросов.Индексы.Добавить("МожетБытьПсевдонимом, Русский");
		мТерминалыЯзыкаЗапросов.Индексы.Добавить("МожетБытьПсевдонимом, Английский");
	КонецЕсли;

КонецПроцедуры

Процедура ПроверитьИнициировать() Экспорт 
	Если Не ЗначениеЗаполнено(ТипТекста) Тогда
		ИнициироватьНеинтерактивно();
	КонецЕсли;
КонецПроцедуры

#Если Клиент Тогда

// Инициализирует экземпляр класса.
//
// Параметры:
//  *СтруктураЭкземляров - Структура, *Неопределено - содержит все объекты данного класса для данной формы;
//  пФорма       - Форма - владелец элементов управления;
//  пПолеТекстовогоДокумента - ПолеТекста;
//  *пКоманднаяПанель - КоманднаяПанель, *Неопределено - в конце которой будут размещены кнопки;
//  *пЛиЯзыкЗапросов - Булево, *Ложь - режим языка запросов, иначе внутренний язык;
//  *пМетодВыполнения - Строка, *"" - имя метода выполнения программного кода;
//  *пКонтекстВыполнения - Тип, Запрос, Произвольный, *Неопределено - контекст выполнения программного кода или текста запроса;
//  *пТипТекста  - Строка, *"Алгоритм" - "Алгоритм" или "Выражение".
//
Процедура Инициализировать(СтруктураЭкземляров = Неопределено, пФорма, пПолеТекстовогоДокумента, пКоманднаяПанель = Неопределено, пЯзыкПрограммы = 0, пМетодВыполнения = "",
	пКонтекстВыполнения = Неопределено, пТипТекста = "Алгоритм", пКонфигурация = Неопределено, НеДобавлятьКнопкиЕслиСуществуют = Ложь, Знач пЭтоЧастиныйЗапрос = Ложь) Экспорт

	#Если Сервер И Не Сервер Тогда
		мПлатформа = Обработки.ирПлатформа.Создать();
	#КонецЕсли
	мПлатформа.ПодключитьПерехватКлавиатуры();
	СсылочнаяФормаКласса = Ложь;
	КоманднаяПанель = пКоманднаяПанель;
	УстановитьФормуВладельца(пФорма); 
	ЭтотОбъект.ЭтоЧастичныйЗапрос = пЭтоЧастиныйЗапрос;
	ИнициироватьНеинтерактивно(пЯзыкПрограммы, пМетодВыполнения, пКонтекстВыполнения, пТипТекста, пКонфигурация, пПолеТекстовогоДокумента);
	
	Имя = ПолеТекста.ЭлементФормы.Имя;
	Если КоманднаяПанель = Неопределено Тогда
		КоманднаяПанель = ФормаВладелец.ЭлементыФормы.Добавить(Тип("КоманднаяПанель"), "КоманднаяПанель" + Имя, Ложь);
		ПолеТекста.ЭлементФормы.КонтекстноеМеню = КоманднаяПанель;
	КонецЕсли;
	
	мФормаКласса = мПлатформа.ПолучитьМакетКомпоненты(ЭтотОбъект); 
	КПМакета = мФормаКласса.ЭлементыФормы["КоманднаяПанель" + Формат(ЯзыкПрограммы, "ЧН=")]; // КоманднаяПанель
	КнопкиМакета = КПМакета.Кнопки;
	Если ЯзыкПрограммы = 1 Тогда
		КнопкаИсследоватьСхемуЗапроса = КнопкиМакета.Найти("ИсследоватьСхемуЗапроса");
		КнопкаФорматировать = КнопкиМакета.Найти("Форматировать");
		КнопкаВставитьИзБуфераОбменаВесьТекст = КнопкиМакета.Найти("ВставитьИзБуфераОбменаВесьТекст");
		КнопкаКопироватьВБуферОбменаВесьТекст = КнопкиМакета.Найти("КопироватьВБуферОбменаВесьТекст");
		КнопкиМакета = ирОбщий.МассивИзКоллекцииЛкс(КнопкиМакета);
		Если Не ирКэш.ДоступноСхемаЗапросаЛкс() Или ЭтоЧастичныйЗапрос Тогда
			КнопкиМакета.Удалить(КнопкиМакета.Найти(КнопкаИсследоватьСхемуЗапроса));
		КонецЕсли;
		Если ЭтоЧастичныйЗапрос Тогда
			КнопкиМакета.Удалить(КнопкиМакета.Найти(КнопкаФорматировать));
			КнопкиМакета.Удалить(КнопкиМакета.Найти(КнопкаВставитьИзБуфераОбменаВесьТекст));
			КнопкиМакета.Удалить(КнопкиМакета.Найти(КнопкаКопироватьВБуферОбменаВесьТекст));
		КонецЕсли;
	КонецЕсли;
	ирКлиент.ДобавитьКнопкиКоманднойПанелиКомпонентыЛкс(ЭтотОбъект, КнопкиМакета, КоманднаяПанель,,, НеДобавлятьКнопкиЕслиСуществуют);
	
	КнопкиМакета = мФормаКласса.ЭлементыФормы.КоманднаяПанельОбщая.Кнопки;
	Если пКоманднаяПанель = Неопределено Тогда
		КнопкаУстановитьФокус = КнопкиМакета.Найти("УстановитьФокус");
		КнопкиМакета = ирОбщий.МассивИзКоллекцииЛкс(КнопкиМакета);
		КнопкиМакета.Удалить(КнопкиМакета.Найти(КнопкаУстановитьФокус));
	КонецЕсли;
	ирКлиент.ДобавитьКнопкиКоманднойПанелиКомпонентыЛкс(ЭтотОбъект, КнопкиМакета, КоманднаяПанель,,, НеДобавлятьКнопкиЕслиСуществуют);
	
	Попытка
		ФормаВладелец.ПодключитьОбработчикОжидания("КлсПолеТекстаПрограммыАвтоОбновитьСправку", 100);;
		ФормаВладелец.ОтключитьОбработчикОжидания("КлсПолеТекстаПрограммыАвтоОбновитьСправку");
	Исключение
		//КоманднаяПанель.Кнопки.Удалить(ирКлиент.КнопкаКоманднойПанелиЭкземпляраКомпонентыЛкс(ЭтотОбъект, "АвтоКонтекстнаяПомощь"));
		Кнопка = ирКлиент.КнопкаКоманднойПанелиЭкземпляраКомпонентыЛкс(ЭтотОбъект, "АвтоКонтекстнаяПомощь");
		Кнопка.Доступность = Ложь;
	КонецПопытки;
	
	//ФайлШаблоновТекста = ирОбщий.ВосстановитьЗначениеЛкс(ИмяКласса + ".ФайлШаблоновТекста");
	//Если Ложь
	//	Или ТипЗнч(ФайлШаблоновТекста) <> Тип("Строка")
	//	Или ФайлШаблоновТекста = ""
	//Тогда
	//	КнопкаВыполнитьШаблон = ирКлиент.КнопкаКоманднойПанелиЭкземпляраКомпонентыЛкс(ЭтотОбъект, "ВыполнитьШаблон");
	//	КнопкаВыполнитьШаблон.Доступность = Ложь;
	//	КнопкаВыполнитьШаблон.СочетаниеКлавиш = Новый СочетаниеКлавиш(Клавиша.Нет); // Чтобы освободить сочетание клавиш
	//КонецЕсли; 
	
	Если СтруктураЭкземляров <> Неопределено Тогда
		СтруктураЭкземляров.Вставить(Имя, ЭтотОбъект);
	КонецЕсли;
	
КонецПроцедуры

Процедура УстановитьФормуВладельца(пФорма) Экспорт

	ФормаВладелец = пФорма;

КонецПроцедуры

// Освобождает ресурсы занятые экземпляром класса.
// Самое главное - очистить ссылки на формы и объекты БД.
//
// Параметры:
//  Нет.
//
Процедура Уничтожить() Экспорт

	Для Каждого Реквизит Из Метаданные().Реквизиты Цикл
		ЭтотОбъект[Реквизит.Имя] = Неопределено;
	КонецЦикла;
	Если мФормаВызовМетода <> Неопределено Тогда
		ЭтотОбъект.мФормаВызовМетода.ВладелецФормы = Неопределено;
	КонецЕсли; 
	ЭтотОбъект.мФормаВызовМетода = Неопределено;
	Если ЭтотОбъект.мФормаАвтодополнение <> Неопределено Тогда
		ЭтотОбъект.мФормаАвтодополнение.ВладелецФормы = Неопределено;
	КонецЕсли; 
	ЭтотОбъект.мФормаАвтодополнение = Неопределено;
	ОчиститьТаблицуСловЛокальногоКонтекста();
	СохранитьСтатистикуВыбораПодсказки();

КонецПроцедуры

Процедура СохранитьСтатистикуВыбораПодсказки() Экспорт 
	
	ирОбщий.СохранитьЗначениеЛкс("ирПлатформа.ТаблицаСтатистикиВыбора", мПлатформа.ТаблицаСтатистикиВыбора);

КонецПроцедуры

Процедура ВнешнееСобытиеОбъекта(Источник, Событие, Данные) Экспорт 
	
	Если Источник <> "KeyboardHook" Тогда
		Возврат;
	КонецЕсли; 
	Если Ложь
		Или ФормаВладелец = Неопределено 
		Или Не ирКлиент.Форма_ВводДоступенЛкс(ФормаВладелец) // Для поля HTML это затратно
	Тогда
		Возврат;
	КонецЕсли;
	ирКлиент.Форма_ВнешнееСобытиеЛкс(ФормаВладелец, Источник, Событие, Данные);
	//Формат строки данные:
	//Первые 5 символов десятичное число в котором закодированы двоичные данные
	//биты 0-7 - виртуальный код клавиши (http://msdn.microsoft.com/en-us/library/dd375731%28v=VS.85%29.aspx)
	//бит 08 - 1 = нажата расширенная клавиша
	//бит 09 - 1 = Правый alt
	//бит 10 - 1 = Левый alt
	//бит 11 - 1 = Правый ctrl
	//бит 12 - 1 = Левый ctrl
	//бит 13 - 1 = Правый shift
	//бит 14 - 1 = Левый shift
	//
	//6 символ и возможно следующие символы могут быть или не быть (максимальное количество 10)
	//Это результат интерпретации клавиши с учетом языковой раскладки. (http://msdn.microsoft.com/en-us/library/ms646320%28v=VS.85%29.aspx)
	//
	ПолученноеЧисло	= Лев(Данные,5);
	ПолученноеЧисло	= Число(ПолученноеЧисло);
	ВиртуальнаяКлавиша	= ПолученноеЧисло % 256;
	ПолученноеЧисло		= ПолученноеЧисло - ВиртуальнаяКлавиша;
	РасширеннаяКлавиша	= ПолученноеЧисло % 512;
	ПолученноеЧисло		= ПолученноеЧисло - РасширеннаяКлавиша;
	ПравыйАльт	= ПолученноеЧисло % 1024;
	ПолученноеЧисло		= ПолученноеЧисло - ПравыйАльт;
	ЛевыйАльт	= ПолученноеЧисло % 2048;
	ПолученноеЧисло		= ПолученноеЧисло - ЛевыйАльт;
	ПравыйСонтрол	= ПолученноеЧисло % 4096;
	ПолученноеЧисло		= ПолученноеЧисло - ПравыйСонтрол;
	ЛевыйСонтрол	= ПолученноеЧисло % 8192;
	ПолученноеЧисло		= ПолученноеЧисло - ЛевыйСонтрол;
	ПравыйШифт	= ПолученноеЧисло % 16384;
	ПолученноеЧисло		= ПолученноеЧисло - ПравыйШифт;
	ЛевыйШифт	= ПолученноеЧисло;
	Если СтрДлина(Данные) > 5 Тогда
		Символ = Сред(Данные, 6);
	Иначе
		Символ = "";
	КонецЕсли;
	КодыКлавиш = ирКэш.КодыКлавишЛкс();
	Если ФормаВладелец.ТекущийЭлемент = ПолеТекста.ЭлементФормы Тогда
		Если Ложь
			Или Найти(Данные, КодыКлавиш["CTRL+ALT+Space"]) = 1
		Тогда
			#Если Сервер И Не Сервер Тогда
				ОткрытьАвтодополнение();
			#КонецЕсли
			ВыполнитьКоманду("ОткрытьАвтодополнение", Данные);
		ИначеЕсли Найти(Данные, КодыКлавиш["ALT+F2"]) = 1 Тогда
			// Антибаг платформы 8.3.19+ не обновляются пометки закладок
			ирКлиент.ОткрытьИЗакрытьПустуюФормуЛкс();
		ИначеЕсли Найти(Данные, КодыКлавиш["CTRL+[-]"]) = 1 Тогда
			#Если Сервер И Не Сервер Тогда
				ВернутьсяИзПерехода();
			#КонецЕсли
			ВыполнитьКоманду("ВернутьсяИзПерехода", Данные);
		ИначеЕсли Ложь
			Или Найти(Данные, КодыКлавиш["CTRL"]) = 1 // Мультиметка00452941 Так будет много лишних точек
			Или Найти(Данные, КодыКлавиш["CTRL+ALT+P"]) = 1 
			Или Найти(Данные, КодыКлавиш["CTRL+F3"]) = 1
			Или Найти(Данные, КодыКлавиш["CTRL+F"]) = 1
			Или Найти(Данные, КодыКлавиш["CTRL+G"]) = 1
			Или Найти(Данные, КодыКлавиш["F3"]) = 1
		Тогда 
			// Запоминание срабатывает после системной обработки сочетания!
			ЗапомнитьИсточникПерехода();
		ИначеЕсли Ложь
			Или Найти(Данные, КодыКлавиш["CTRL+C"]) = 1
			Или Найти(Данные, КодыКлавиш["CTRL+V"]) = 1 
		Тогда 
			// Мультиметка00452941 Удаляем избыточные точки истории
			УдалитьПоследнийПереходИзИстории();
		КонецЕсли; 
		Если Ложь
			Или ЛиДоступноОткрытиеСвободнойФормы()
			Или ТипЗнч(ПолеТекста.ЭлементФормы) = Тип("ПолеТекстовогоДокумента")
		Тогда
			// Подсказка по вызову метода
			ФормаВызовМетода = ФормаВызовМетода();
			БылаОткрыта = ФормаВызовМетода.Открыта();
			Если Ложь
				Или Найти(Данные, КодыКлавиш["CTRL+SHIFT+Space"]) = 1
			Тогда
				ВыполнитьКоманду("ПодсказатьПараметр");
			КонецЕсли; 
			Если Истина
				И Не БылаОткрыта
				И ЛиДоступноОткрытиеСвободнойФормы()
				И (Ложь
					Или Символ = "(" 
					Или Символ = ",")
				И АвтоматическаяПодсказкаПоВызовуМетода()
			Тогда
				ВыполнитьКоманду("ПодсказатьПараметрАвто");
			КонецЕсли;
			Если БылаОткрыта Тогда
				ОбновитьПодсказкуПоВызовуМетода();
			КонецЕсли; 
			Если Ложь
				Или Найти(Данные, КодыКлавиш["ALT+Up"]) = 1
				Или Найти(Данные, КодыКлавиш["ALT+Down"]) = 1
				//Или Найти(Данные, КодыКлавиш["CTRL+Up"]) = 1
				//Или Найти(Данные, КодыКлавиш["CTRL+Down"]) = 1
				Или Найти(Данные, КодыКлавиш["Esc"]) = 1 // Работает только в поле HTML документа. В остальных местах платформа делает полный перехват 
			Тогда  
				ФормаВызовМетода.ВнешнееСобытие(Источник, Событие, Данные);      
			КонецЕсли; 
			
			ПриНажатииКлавишиАвтодополнение(Источник, Событие, Данные, Символ);
			//_РежимОтладки = Ложь;  
			//Если _РежимОтладки Тогда // ирОбщий.Пр(_РежимОтладки,1,1)
				//Сообщить(Данные);
			//КонецЕсли;
		КонецЕсли; 
	КонецЕсли;

КонецПроцедуры

//.
// Параметры:
//    Источник - ? - 
//    Событие - ? - 
//    Данные - ? - 
//    КодыКлавиш - Соответствие - 
//    Символ - Строка - 
Процедура ПриНажатииКлавишиАвтодополнение(Источник, Событие, Данные, Символ) Экспорт
	Если ТипЗнч(ПолеТекста.ЭлементФормы) <> Тип("ПолеТекстовогоДокумента") Тогда 
		Возврат;
	КонецЕсли;  
	КодыКлавиш = ирКэш.КодыКлавишЛкс();
	ФормаАвтодополнение = ФормаАвтодополнение();
	БылаОткрыта = ФормаАвтодополнение.Открыта();
	Если БылаОткрыта Тогда 
    	Если Ложь
			Или Найти(Данные, КодыКлавиш["Enter"]) = 1
			Или Найти(Данные, КодыКлавиш["Up"]) = 1
			Или Найти(Данные, КодыКлавиш["Down"]) = 1
			Или Найти(Данные, КодыКлавиш["PgUp"]) = 1
			Или Найти(Данные, КодыКлавиш["PgDown"]) = 1
			Или Найти(Данные, КодыКлавиш["CTRL+F1"]) = 1
		Тогда
			Если ПолеТекста.ФиксированноеВыделениеДвумерное = Неопределено Тогда 
				ВыделениеДвумерное = ПолеТекста.ВыделениеДвумерное();
				ВыделениеДвумерное.НачальнаяКолонка = мНачальнаяКолонка;
				ВыделениеДвумерное.НачальнаяСтрока = мНачальнаяСтрока;
				ВыделениеДвумерное.КонечнаяКолонка = мКонечнаяКолонка;
				ВыделениеДвумерное.КонечнаяСтрока = мКонечнаяСтрока;
				ПолеТекста.ФиксированноеВыделениеДвумерное = ВыделениеДвумерное;
			КонецЕсли;
			ТекущаяСтрока = ФормаАвтодополнение.ЭлементыФормы.ТаблицаСлов.ТекущаяСтрока; 
			Если Истина
				И Найти(Данные, КодыКлавиш["Enter"]) = 1
				И ТекущаяСтрока <> Неопределено
				И ТекущаяСтрока.Слово = мКонтекст
				И (Ложь
					Или мКонтекст = "Тогда"
					Или мКонтекст = "Иначе"
					Или мКонтекст = "Цикл"
					Или мКонтекст = "Попытка"
					Или мКонтекст = "Исключение"
					Или мКонтекст = "КонецПроцедуры"
					Или мКонтекст = "КонецФункции")
			Тогда
				ФормаАвтодополнение.Закрыть();
			Иначе 
				ПолеТекста.УстановитьВыделениеДвумерное(ПолеТекста.ФиксированноеВыделениеДвумерное);
				// Подстраховка
				ПараметрыОбработчика = Новый Структура("ПолеТекста, Текст", ПолеТекста, ПолеТекста.ПолучитьТекст());
				ирКлиент.ПодключитьОбработчикОжиданияСПараметрамиЛкс("ирКлиент.АктивироватьЭлементФормыОтложенноЛкс", ПараметрыОбработчика,,, Ложь);
				Если Найти(Данные, КодыКлавиш["Enter"]) = 1 Тогда
					// Отменим вставленный перенос строки
					ВыделениеДвумерное = ПолеТекста.ВыделениеДвумерное();
					НоваяСтрока = ПолеТекста.ПолучитьСтроку(мКонечнаяСтрока + 1);
					ПолеТекста.УдалитьСтроку(мКонечнаяСтрока + 1);
					ПолеТекста.ЗаменитьСтроку(мКонечнаяСтрока, ПолеТекста.ПолучитьСтроку(мКонечнаяСтрока) + Сред(НоваяСтрока, ВыделениеДвумерное.НачальнаяКолонка));
				КонецЕсли;
				ФормаАвтодополнение.ВнешнееСобытие(Источник, Событие, Данные);
			КонецЕсли;
			Возврат;
		КонецЕсли;
	КонецЕсли;
	ПолеТекста.ФиксированноеВыделениеДвумерное = Неопределено;
	СтарыйКонтекст = мРодительскийКонтекст;
	Если Ложь
		//Или Найти(Данные, КодыКлавиш["CTRL+Space"]) = 1 
		Или Найти(Данные, КодыКлавиш["Tab"]) = 1
		Или Найти(Данные, КодыКлавиш["Space"]) = 1
		Или Найти(Данные, КодыКлавиш["Enter"]) = 1
	Тогда
		// Чтобы закрылась форма
		СтарыйКонтекст = Null;
	КонецЕсли;
	ПолучитьГраницыВыделения();
	ПрочитатьНачалоИКонецТекущейСтроки();
	Если Истина
		И ЯзыкПрограммы = 0
		И Найти(Данные, КодыКлавиш["Enter"]) = 1 
		И ирОбщий.ЛиВнутриТекстовогоЛитералаЛкс(ПолеТекста.ПолучитьСтроку(мКонечнаяСтрока - 1))
		И Лев(СокрЛ(ПолеТекста.ПолучитьСтроку(мКонечнаяСтрока)), 1) <> "|"
	Тогда
		ПолеТекста.ВыделенныйТекст("|");
	КонецЕсли;
	Если Истина
		И ЛиДоступноОткрытиеСвободнойФормы()
		И АвтоматическаяПодсказкаАвтодополненияHTML()
	Тогда 
		РазобратьКонтекстСтроки();
		Последние2Символа = Прав(мТекущаяСтрокаНачало, 2);
		ЛиВнутриКомментария = ЛиВнутриКомментария();
		//ПоказатьСписок = МожноПоказатьСписокСлов(Символ, мТекущаяСтрокаНачало, мТекущееСлово);
		//Сообщить(Данные);
		//ЕстьПодходящееПрисвоение = Ложь;
		//Если Символ = "=" И Последние2Символа <> "==" Тогда
		//	ЗаполнитьТаблицуСлов(,, ЕстьПодходящееПрисвоение);
		//КонецЕсли;
		Если Ложь
			Или Истина
				И Не БылаОткрыта 
				//И Не (ЯзыкПрограммы = 1 И мЭтоОбъявлениеПсевдонима)
				И (Ложь
					Или ирОбщий.СтрНачинаетсяСЛкс(Данные, "00") // Без модификаторов
					//Или ирОбщий.СтрНачинаетсяСЛкс(Данные, "1") // Зажат шифт, но сюда попадают и нажатия с CTRL
					)
				И Не ЛиВнутриКомментария
				//И ирОбщий.НайтиРегВыражениеЛкс(Символ, "[" + шБуква + "]").Количество() > 0 
				И ирОбщий.ЛиБукваЛкс(Символ) 
			//Или ирОбщий.СтрКончаетсяНаЛкс(мТекущаяСтрокаНачало, "см. ") И ЛиВнутриКомментария И ЯзыкПрограммы = 0 // Только этого условия недостаточно
			Или Символ = "&" И Последние2Символа <> "&&" И ЯзыкПрограммы = 1
			Или Символ = "~" И Последние2Символа <> "~~" И ЯзыкПрограммы = 0
			Или Символ = "#" И Последние2Символа <> "##" И ЯзыкПрограммы = 0
			Или Символ = "." И Последние2Символа <> ".." 
			//Или ЕстьПодходящееПрисвоение
			Или Символ = "=" И Последние2Символа <> "==" 
			Или Символ = " " И ирОбщий.СтрКончаетсяНаЛкс(СокрП(мТекущаяСтрокаНачало), "Новый") И ЯзыкПрограммы = 0
			Или Символ = """" И Последние2Символа <> """""" И ирОбщий.ЛиВнутриТекстовогоЛитералаЛкс(мТекущаяСтрокаНачало) И ЯзыкПрограммы = 0
		Тогда
			//ВыполнитьКоманду("ОткрытьАвтодополнение", Данные, Ложь);
			мКодКлавишиОткрытияАвтодополнения = Данные;
			ирКлиент.ПодключитьОбработчикОжиданияОповещенияЛкс(ирКлиент.ОписаниеОповещенияЛкс("ОткрытьАвтодополнениеБезФокуса", ЭтотОбъект));
			СтарыйКонтекст = мРодительскийКонтекст;
		КонецЕсли;
	КонецЕсли;
	Если Ложь
		Или Найти(Данные, КодыКлавиш["CTRL"]) = 1
		Или Найти(Данные, КодыКлавиш["Up"]) = 1
		Или Найти(Данные, КодыКлавиш["Down"]) = 1
		Или Найти(Данные, КодыКлавиш["PgUp"]) = 1
		Или Найти(Данные, КодыКлавиш["PgDown"]) = 1
	Тогда
		//  
	ИначеЕсли ФормаАвтодополнение.Открыта() Тогда  
		Если мКодКлавишиОткрытияАвтодополнения = Неопределено Тогда
			РазобратьКонтекстСтроки();
		КонецЕсли;
		//ПредпоследнееСлово = ""; // TODO
		//ПоказатьСписок = МожноПоказатьСписокСлов(Символ, мТекущаяСтрокаНачало, ПредпоследнееСлово);
		Если Ложь
			Или СтарыйКонтекст <> мРодительскийКонтекст 
			Или Прав(мКонтекст, 1) = ")"
			Или (Истина
				И Не ЗначениеЗаполнено(мКонтекст) 
				И Не мЭтоТекстовыйЛитерал 
				И Не ирОбщий.СтрКончаетсяНаЛкс(СокрП(мТекущаяСтрокаНачало), "=")
				И Не ирОбщий.ЛиВнутриПрепроцессораЛкс(мТекущаяСтрокаНачало))
		Тогда
			ФормаАвтодополнение.Закрыть();
			Возврат;
		КонецЕсли;
		ОбновитьФормуАвтодополнения(Данные);
	КонецЕсли; 
КонецПроцедуры

//.
// Параметры:
//    Данные - ?  -  
//    КодыКлавиш - Соответствие - 
//    ФормаАвтодополнение - Форма[Обработка.ирКлсПолеТекстаПрограммы.Форма.АвтодополнениеCOM] - 
Процедура ОбновитьФормуАвтодополнения(Данные) Экспорт
	КодыКлавиш = ирКэш.КодыКлавишЛкс();
	ФормаАвтодополнение = ФормаАвтодополнение();
	БылЗаполненФильтр = ЗначениеЗаполнено(ФормаАвтодополнение.ЭлементыФормы.ПолеОтбораПоПодстроке.Значение);
	ФормаАвтодополнение.ТекущееСлово = мНачалоСлова;
	ФормаАвтодополнение.НачальноеЗначениеВыбора = мСтрокаЛучшегоСлова;
	ФормаАвтодополнение.ОжидаемыйТип = мИмяОжидаемогоТипа;
	ФормаАвтодополнение.ЛиОбработкаСобытия = Истина; 
	ФормаАвтодополнение.ЭлементыФормы.ПолеОтбораПоПодстроке.Значение = мНачалоСлова;
	Если Найти(Данные, КодыКлавиш["CTRL+Space"]) = 1 И БылЗаполненФильтр Тогда
		ФормаАвтодополнение.ПереброситьВведеннуюСтроку();
	КонецЕсли;
	ФормаАвтодополнение.ЛиОбработкаСобытия = Ложь; 
	ФормаАвтодополнение.ПриИзмененииОтбора();
КонецПроцедуры

Процедура ОткрытьАвтодополнениеБезФокуса() Экспорт
	ВыполнитьКоманду("ОткрытьАвтодополнение", мКодКлавишиОткрытияАвтодополнения, Ложь);
	мКодКлавишиОткрытияАвтодополнения = Неопределено;
	ОбновитьФормуАвтодополнения(мКодКлавишиОткрытияАвтодополнения);
КонецПроцедуры

Функция ЛиВнутриКомментария() Экспорт
	Возврат ирОбщий.ЛиВнутриКомментарияЛкс(мТекущаяСтрокаНачало);
КонецФункции

Процедура ОбновитьПодсказкуПоВызовуМетода()
	
	ФормаВызовМетода = ФормаВызовМетода(Истина);
	Если Не ФормаВызовМетода.Открыта() Или Не ФормаВызовМетода.Автообновление Тогда
		Возврат;
	КонецЕсли; 
	//Если Форма.Открыта() Тогда
		ФормаВызовМетода.ОбновитьИлиЗакрытьФорму(, Истина);
	//КонецЕсли;

КонецПроцедуры

Функция ЛиМожноЗакрытьФорму() Экспорт 
	Результат = Истина;
	ФормаВызовМетода = ФормаВызовМетода();
	Если ФормаВызовМетода.Открыта() Тогда
		ФормаВызовМетода.Закрыть();
		Результат = Ложь;
	КонецЕсли; 
	ФормаАвтодополнение = ФормаАвтодополнение();
	Если ФормаАвтодополнение.Открыта() Тогда
		ФормаАвтодополнение.Закрыть();
		Результат = Ложь;
	КонецЕсли; 
	Возврат Результат;
КонецФункции

Функция ФормаВызовМетода(Знач ОчиститьПараметры = Ложь) Экспорт 
	
	Если мФормаВызовМетода = Неопределено Тогда
		мФормаВызовМетода = ПолучитьФорму("ВызовМетода", ФормаВладелец);
	КонецЕсли;  
	Если ОчиститьПараметры Тогда
		мФормаВызовМетода.ПараметрПостояннаяСтруктураТипа = Неопределено; 
	КонецЕсли;
	Возврат мФормаВызовМетода;

КонецФункции 

// Процедура - Открыть прикрепленную форму вызова метода
//
// Параметры:
//  СтруктураТипаКонтекста	 - 	 - 
//  ЭтаФорма				 - Форма - 
//
Процедура ОткрытьПрикрепленнуюФормуВызоваМетода(Знач СтруктураТипаКонтекста, Знач ЭтаФорма = Неопределено) Экспорт 
	
	ТаблицаВладелец = СтруктураТипаКонтекста.СтрокаОписания.Владелец();
	#Если Сервер И Не Сервер Тогда
		ТаблицаВладелец = Новый ТаблицаЗначений;
	#КонецЕсли  
	Если Истина
		И ЭтаФорма <> Неопределено
		И Не ЭтаФорма.ВводДоступен()
		И ирКэш.ЛиСеансТолстогоКлиентаУПЛкс()
	Тогда
		// Иначе нажатия клавиш могу прийти в другое окно
		Возврат;
	КонецЕсли;
	ФормаВызовМетода = ПолучитьФорму("ВызовМетода", ЭтаФорма, "Прикрепленное");    
	Если Не ФормаВызовМетода.Открыта() Тогда
		ФормаВызовМетода.СоединяемоеОкно = Истина;
		ФормаВызовМетода.КлючСохраненияПоложенияОкна = ФормаВызовМетода.КлючУникальности;
		ФормаВызовМетода.СостояниеОкна = ВариантСостоянияОкна.Прикрепленное;
		ФормаВызовМетода.ПоложениеПрикрепленногоОкна = ВариантПрикрепленияОкна.Низ;
	КонецЕсли; 
	ФормаВызовМетода.ПараметрПостояннаяСтруктураТипа = СтруктураТипаКонтекста;
	Если ФормаВызовМетода.Открыта() Тогда
		ФормаВызовМетода.ОбновитьИлиЗакрытьФорму();
	Иначе
		ФормаВызовМетода.Открыть();
	КонецЕсли;

КонецПроцедуры
	
// Получает номер текущей строки в тексте (по конечной границе выделения).
//
// Параметры:
//  Нет.
//
// Возвращаемое значение:
//  Число.
//
Функция ПолучитьНомерТекущейСтроки(Начальной = Ложь) Экспорт

	Если ПолеТекста <> Неопределено Тогда
		ПолеТекста.ПолучитьГраницыВыделения(мНачальнаяСтрока, мНачальнаяКолонка, мКонечнаяСтрока, мКонечнаяКолонка);
		Если Начальной Тогда
			Возврат мНачальнаяСтрока;
		Иначе
			Возврат мКонечнаяСтрока;
		КонецЕсли; 
	Иначе
		Возврат Неопределено;
	КонецЕсли; 

КонецФункции // ПолучитьНомерТекущейСтроки()

// Получает текущее объектное выражение (на котором установлен курсор).
//
// Параметры:
//  Нет.
//
// Возвращаемое значение:
//  Строка - объектное выражение, в котором находится курсов.
//
Функция ТекущееОбъектноеВыражение(НомерСтроки = 0, НомерКолонки = 0, выхЕстьТочкаСправа = Ложь, КончитьОбработкуКоманды = Истина, Знач ЭтоПродолжениеОбработки = Ложь) Экспорт

	Если ирОбщий.ПроверитьПлатформаНеWindowsЛкс(,, Истина) Тогда
		Возврат Неопределено;
	КонецЕсли; 
	мПлатформа.ИнициацияОписанияМетодовИСвойств();
	Если ЭтоПродолжениеОбработки Тогда
		ПродолжитьОбработкуКоманды();
	Иначе
		КончитьОбработкуКоманды();
	КонецЕсли;
	Если НомерСтроки > ПолеТекста.КоличествоСтрок() Тогда
		Возврат Неопределено;
	КонецЕсли;
	РазобратьТекущийКонтекст(, выхЕстьТочкаСправа,, НомерСтроки, НомерКолонки, Истина);
	Если КончитьОбработкуКоманды Тогда
		КончитьОбработкуКоманды();
	КонецЕсли; 
	Если мЭтоТекстовыйЛитерал Тогда
		мКонтекст = "";
	КонецЕсли; 
	Возврат мКонтекст;

КонецФункции

// Получает текущее контекст параметра. 
//
// Параметры:
//  Нет.
//
// Возвращаемое значение:
//  Структура -
//    "ОбъектноеВыражение"
//    "НомерПараметра"
//
Функция ПолучитьТекущийКонтекстПараметра() Экспорт

	КончитьОбработкуКоманды();
	РазобратьТекущийКонтекст(,, Истина,,, Истина);
	КончитьОбработкуКоманды();
	СтруктураРезультата = Новый Структура;
	СтруктураРезультата.Вставить("ОбъектноеВыражение", мВызовМетода);
	СтруктураРезультата.Вставить("ПервыйПараметр", мПервыйФактическийПараметр);
	СтруктураРезультата.Вставить("НомерПараметра", мНомерПараметра);
	Возврат СтруктураРезультата;

КонецФункции

// Разбирает вызов метода и выделяет в тексте заданный параметр. Учитывает границы текущего метода!
//
// Параметры:
//  Нет.
//
Функция ТекущийВызовМетода(Знач НомерПараметраДляВыделения = 0) Экспорт 

	мРегВыражение.Global = Истина;
	мКонтекст = "";
	//мОригинальныйТекст = ПолеТекста.ПолучитьТекст();
	//СлужебноеПолеТекстаДолгое.УстановитьТекст(мОригинальныйТекст);
	ПредшествующийТекст = "";
	СледующийТекст = "";
	НачальнаяПозиция = 1;
	МаксЧислоПредшествующихСтрок = 15; // Чтобы снизить вероятность зацикливания при вычислении рег.выражения
	Если мКонечнаяСтрока > 1 Тогда
		НомерПервойСтроки = Макс(1, мКонечнаяСтрока - МаксЧислоПредшествующихСтрок - 1);
		Если мНомерПервойСтрокиТелаМетода <> Неопределено И мМетодМодуля <> Неопределено Тогда
			НомерПервойСтроки = Макс(мНомерПервойСтрокиТелаМетода, НомерПервойСтроки);
			Если мНомерПервойСтрокиТелаМетода > мКонечнаяСтрока Тогда
				Если мНомерПервойСтрокиТелаМетода - 10 < мКонечнаяСтрока Тогда
					НомерПервойСтроки = мКонечнаяСтрока;
				Иначе
					ВызватьИсключение "Внутренняя ошибка"; // Сюда приводит нас опасная техника подмены и восстановления текущего контекста в ЗаполнитьТаблицуСловДляТекстовогоЛитерала()
				КонецЕсли;
			КонецЕсли;
		КонецЕсли;
		СлужебноеПолеТекстаДолгое.УстановитьГраницыВыделения(НомерПервойСтроки, 1, мКонечнаяСтрока - 1, 333);
		ПредшествующийТекст = СлужебноеПолеТекстаДолгое.ВыделенныйТекст;
		Если НомерПараметраДляВыделения > 0 Тогда
			СлужебноеПолеТекстаДолгое.УстановитьГраницыВыделения(1, 1, НомерПервойСтроки, 1);
			НачальнаяПозиция = 1 + СтрДлина(СлужебноеПолеТекстаДолгое.ВыделенныйТекст);
		КонецЕсли;
	КонецЕсли;
	Если ЯзыкПрограммы = 0 Тогда
		мРегВыражение.Pattern = мПлатформа.шПустоеНачалоСтроки + "(?!\|)[^\n]*;";
		Вхождения = мРегВыражение.НайтиВхождения(ПредшествующийТекст);
		Для Индекс = 1 - Вхождения.Количество() По 0 Цикл // Обратный обход
			Вхождение = Вхождения[-Индекс];
			Если Не ирОбщий.ЛиВнутриТекстовогоЛитералаЛкс(Вхождение.Value) Тогда
				ПредшествующийТекст = Сред(ПредшествующийТекст, Вхождение.FirstIndex + Вхождение.Length + 1);
				Прервать;
			КонецЕсли;
		КонецЦикла;
	КонецЕсли;
	
	МаксЧислоСтрокАнализировать = 30; 
	МаксНомерСтроки = Мин(СлужебноеПолеТекстаДолгое.КоличествоСтрок(), мКонечнаяСтрока + МаксЧислоСтрокАнализировать);
	Если Истина
		И МаксНомерСтроки > 0
		И МаксНомерСтроки <= СлужебноеПолеТекстаДолгое.КоличествоСтрок() 
	Тогда
		СлужебноеПолеТекстаДолгое.УстановитьГраницыВыделения(мКонечнаяСтрока + 1, 1, МаксНомерСтроки, 333);
		СледующийТекст = СлужебноеПолеТекстаДолгое.ВыделенныйТекст;
	КонецЕсли;
	
	ТекстДоКурсора = ПредшествующийТекст + мТекущаяСтрокаНачало; // Так почему то иногда возникало смещение на 1 символ
	//ТекстДоКурсора = ЗалитьКомментарииИСтроковыеЛитералы(ТекстДоКурсора); Нельзя, т.к. нужна позиция результата
	ТекстПослеКурсора = мТекущаяСтрокаКонец + Символы.ПС + СледующийТекст;
	ТекстПослеКурсора = ЗалитьКомментарииИСтроковыеЛитералы(ТекстПослеКурсора); // Защита от больших откатов https://www.hostedredmine.com/issues/967498
	Если мЭтоТекстовыйЛитерал Тогда
		//ТекстДоКурсора = ТекстДоКурсора + """";
		ТекстПослеКурсора = """" + ТекстПослеКурсора;
		Если ирОбщий.ЛиВнутриТекстовогоЛитералаЛкс(ТекстПослеКурсора) Тогда
			ТекстПослеКурсора = ТекстПослеКурсора + """";
		КонецЕсли;
	ИначеЕсли Прав(ТекстДоКурсора, 1) = "." Тогда
		ТекстДоКурсора = ТекстДоКурсора + "ф";
	КонецЕсли; 
	Если мЯзыкПрограммы = 0 Тогда
		ШаблонПараметра = "(?:" + шВыражениеПрограммы + ")?" + шРазделитель + "*";
	Иначе
		ШаблонПараметра = "(?:" + шВыражениеЗапроса   + ")?" + шРазделитель + "*";
	КонецЕсли;
	мРегВыражение.Global = Ложь;
	мРегВыражение.MultiLine = Ложь;
	мРегВыражение.Pattern = "^(?:" + ШаблонПараметра + ",)*" + ШаблонПараметра + "\)";
	Результат = мРегВыражение.НайтиВхождения(ТекстПослеКурсора);
	Если Результат.Количество() > 0 Тогда
		//КонецВыражения = Лев(ТекстПослеКурсора, Результат[0].Length);
		КонецВыражения = Результат[0].Value;
		Если мЭтоТекстовыйЛитерал Тогда
			КонецВыражения = Сред(КонецВыражения, 2);
		КонецЕсли;
	КонецЕсли;  
	
	мРегВыражение.Global = Ложь;
	мРегВыражение.MultiLine = Ложь;
	Если мЯзыкПрограммы = 1 Тогда
		мРегВыражение.Pattern = шВызовМетодаЗапроса + "$";
	Иначе 
		мРегВыражение.Pattern = шВызовМетодаПрограммы + "$";
	КонецЕсли;
	ТекстГдеИскать = ТекстДоКурсора + ирОбщий.СтрокаБезКонцаЛкс(КонецВыражения) + ","; // Добавляем запятую
	Результат = мРегВыражение.НайтиВхождения(ТекстГдеИскать);
	мФактическиеПараметры = Новый Массив;
	Если Результат.Количество() = 0 Тогда
		Возврат Неопределено;
	КонецЕсли;
	ПоследнееВхождение = Результат[0];
	мВызовМетода = ПоследнееВхождение.SubMatches(2) + "(";
	ТекстПараметров = ПоследнееВхождение.SubMatches(6) + ПоследнееВхождение.SubMatches(15);
	НачальнаяПозиция = НачальнаяПозиция + ПоследнееВхождение.FirstIndex + СтрДлина(ПоследнееВхождение.SubMatches(0)) + СтрДлина(мВызовМетода);
	мЭтоКонструктор = ЗначениеЗаполнено(ПоследнееВхождение.SubMatches(1));
	мРегВыражение.Global = Истина;
	Если мЯзыкПрограммы = 0 Тогда
		ШаблонПараметра = "(" + шВыражениеПрограммы + ")?" ;
	Иначе
		ШаблонПараметра = "(" + шВыражениеЗапроса   + ")?";
	КонецЕсли;
	мРегВыражение.Pattern = ШаблонПараметра + шРазделитель + "*,";
	Результат = мРегВыражение.НайтиВхождения(ТекстПараметров + ""","); // Добавляем кавычку на случай незакрытого строкового литерала
	ЛокальнаяПозицияКурсора = СтрДлина(ТекстПараметров) + 1 - СтрДлина(КонецВыражения);
	Счетчик = 0;
	Для Каждого Вхождение Из Результат Цикл
		Счетчик = Счетчик + 1;
		ПозицияВхождения = Вхождение.FirstIndex;
		Если Истина
			И (ПозицияВхождения + 1) <= ЛокальнаяПозицияКурсора 
			И (ПозицияВхождения + Вхождение.Length + 1) >= ЛокальнаяПозицияКурсора 
		Тогда
			мНомерПараметра = Счетчик;
		КонецЕсли;
		ТекстПараметра = СокрЛП(Вхождение.SubMatches(0));
		Если Истина
			И Счетчик = Результат.ВГраница()
			И Лев(ТекстПараметра, 1) <> """" 
			И Прав(ТекстПараметра, 1) = """" 
		Тогда
			ТекстПараметра = ирОбщий.СтрокаБезКонцаЛкс(ТекстПараметра);
		КонецЕсли;
		ТекстПараметра = СокрЛП(ТекстПараметра);
		мФактическиеПараметры.Добавить(ТекстПараметра);
		Если НомерПараметраДляВыделения = Счетчик Тогда
			ПолеТекста.УстановитьГраницыВыделения(НачальнаяПозиция + Вхождение.FirstIndex, НачальнаяПозиция + Вхождение.FirstIndex + СтрДлина(Вхождение.SubMatches(0)));
			мНомерПараметра = НомерПараметраДляВыделения;    
			ЛокальнаяПозицияКурсора = 0;
			Если ФормаВладелец <> Неопределено Тогда
				ФормаВладелец.Активизировать();
			КонецЕсли;
		КонецЕсли;
	КонецЦикла;
	Если мФактическиеПараметры.Количество() > 0 Тогда
		мПервыйФактическийПараметр = мФактическиеПараметры[0];
	КонецЕсли;
	Если Истина
		И мФактическиеПараметры.Количество() > 1
		И мФактическиеПараметры[мФактическиеПараметры.ВГраница()] = "" 
	Тогда
		мФактическиеПараметры.Удалить(мФактическиеПараметры.ВГраница());
	КонецЕсли; 
	мИмяМетодаВызова = ирОбщий.ПервыйФрагментЛкс(ирОбщий.ПоследнийФрагментЛкс(мВызовМетода), "(");
	СтруктураРезультата = Новый Структура;
	СтруктураРезультата.Вставить("ОбъектноеВыражение", мВызовМетода);
	СтруктураРезультата.Вставить("ОригинальныйТекст", Лев(ПоследнееВхождение.Value, СтрДлина(ПоследнееВхождение.Value) - 1) + ")");
	СтруктураРезультата.Вставить("МассивПараметров", мФактическиеПараметры);
	СтруктураРезультата.Вставить("НомерПараметра", мНомерПараметра);
	СтруктураРезультата.Вставить("ЭтоКонструктор", мЭтоКонструктор);
	Возврат СтруктураРезультата;

КонецФункции

// Разбирает контекст метода.
//
// Параметры:
//  Нет.
//
Функция УстановитьТекущийКонтекстМетода(НовыйТекст) Экспорт

	#Если Сервер И Не Сервер Тогда
		ПолеТекста = Обработки.ирОболочкаПолеТекста.Создать();
	#КонецЕсли
	ПолеТекста.УстановитьГраницыВыделения(мНачальнаяСтрока, мНачальнаяКолонка, мКонечнаяСтрока, мКонечнаяКолонка);
	ВыделенныйТекст(НовыйТекст);
	ПолеТекста.УстановитьГраницыВыделения(мНачальнаяСтрока, мНачальнаяКолонка, мНачальнаяСтрока, мНачальнаяКолонка,, ФормаВладелец);

КонецФункции

// Разбирает контекст УК.
//
// Параметры:
//  Нет.
//
Функция ПолучитьТекущийКонтекстУК() Экспорт

	мПлатформа.ИнициацияОписанияМетодовИСвойств();
	ПолеТекста.ПолучитьГраницыВыделения(мНачальнаяСтрока, мНачальнаяКолонка, мКонечнаяСтрока, мКонечнаяКолонка);
	мРегВыражение.Global = Истина;
	ПрочитатьНачалоИКонецТекущейСтроки();
	РазобратьКонтекстСтроки();
	ИмяСтруктурыПараметров = "";
	
	мОригинальныйТекст = ПолеТекста.ПолучитьТекст();
	//СлужебноеПолеТекстаДолгое.УстановитьТекст(мОригинальныйТекст);
	мПредшествующийТекст = "";
	СледующийТекст = "";
	Если мКонечнаяСтрока > 1 Тогда
		СлужебноеПолеТекстаДолгое.УстановитьГраницыВыделения(1, 1, мКонечнаяСтрока - 1, 333);
		мПредшествующийТекст = СлужебноеПолеТекстаДолгое.ВыделенныйТекст;
	КонецЕсли; 
	МаксНомерСтроки = Мин(СлужебноеПолеТекстаДолгое.КоличествоСтрок(), мКонечнаяСтрока + 100);
	Если Истина
		И МаксНомерСтроки > 0
		И МаксНомерСтроки <= СлужебноеПолеТекстаДолгое.КоличествоСтрок() 
	Тогда
		СлужебноеПолеТекстаДолгое.УстановитьГраницыВыделения(мКонечнаяСтрока + 1, 1, МаксНомерСтроки, 333);
		СледующийТекст = СлужебноеПолеТекстаДолгое.ВыделенныйТекст;
	КонецЕсли;
	ТекстДоКурсора = мПредшествующийТекст + Символы.ПС + мТекущаяСтрокаНачало;
	ТекстПослеКурсора = мТекущаяСтрокаКонец + Символы.ПС + СледующийТекст;
	
	ШаблонУК = "(" + шИмя + ")" + шРазделитель + "*=" + шРазделитель + "*УК\((" + шИмя + ")\)";
	мРегВыражение.Global = Ложь;
	мРегВыражение.MultiLine = Ложь;
	мРегВыражение.Pattern = "^" + "(" + шРазделитель + "*)" + ШаблонУК;
	Результат = мРегВыражение.НайтиВхождения(мТекущаяСтрокаНачало + ТекстПослеКурсора);
	Если Результат.Количество() > 0 Тогда
		Смещение = Результат[0].SubMatches(0);
		ИмяСтруктурыПараметров = Результат[0].SubMatches(1);
		МассивПараметров = Новый Массив;
		МассивПараметров.Добавить(Результат[0].SubMatches(2));
	Иначе
		Возврат Неопределено;
	КонецЕсли;
	
	ШаблонПараметра = шРазделитель + "*" + ИмяСтруктурыПараметров + "\.(" + шИмя + ")" + шРазделитель + "*=" 
		+ шРазделитель + "*(" + шВыражениеПрограммы + ")?" + шРазделитель + "*" + ";";
	мРегВыражение.Pattern = "^" + "(" + шРазделитель + "*)" + ШаблонУК + ";" + "((?:" + ШаблонПараметра  + шРазделитель + "*" + ")*)";
	Результат = мРегВыражение.НайтиВхождения(мТекущаяСтрокаНачало + ТекстПослеКурсора);
	Если Результат.Количество() > 0 Тогда
		ПолныйТекстВыражения = Результат[0].Value;
	Иначе
		Возврат Неопределено;
	КонецЕсли;
	
	//RegExp.Global = Ложь;
	мРегВыражение.MultiLine = Ложь;
	мРегВыражение.Pattern = ШаблонУК + ";" + "((?:" + ШаблонПараметра  + шРазделитель + "*" + ")*)$";
	Результат = мРегВыражение.НайтиВхождения(мПредшествующийТекст + ПолныйТекстВыражения);
	СтруктураПараметров = Новый Структура;
	Если Результат.Количество() > 0 Тогда
		ПоследнееВхождение = Результат[Результат.Количество() - 1];
		Попытка
			СлужебноеПолеТекстаДолгое.УстановитьГраницыВыделения(ПоследнееВхождение.FirstIndex + 1, 
				ПоследнееВхождение.FirstIndex + 1 + ПоследнееВхождение.Length);
		Исключение
			СлужебноеПолеТекстаДолгое.УстановитьГраницыВыделения(ПоследнееВхождение.FirstIndex + 1, 
				ПоследнееВхождение.FirstIndex + 1 + ПоследнееВхождение.Length - 1); // -1 надо делать из-за бага платформы (она не дает выделить последний символ в тексте)
		КонецПопытки;
		СлужебноеПолеТекстаДолгое.ПолучитьГраницыВыделения(мНачальнаяСтрока, мНачальнаяКолонка, мКонечнаяСтрока, мКонечнаяКолонка);
		//ИмяСтруктурыПараметров = Результат[0].SubMatches(0);
		ТекстПараметров = ПоследнееВхождение.SubMatches(2);
		мРегВыражение.Global = Истина;
		мРегВыражение.Pattern = ШаблонПараметра;
		Результат = мРегВыражение.НайтиВхождения(ТекстПараметров);
		//ЛокальнаяПозицияКурсора = СтрДлина(ТекстПараметров) - СтрДлина(ПолныйТекстВыражения);
		Счетчик = 0;
		Для Каждого Вхождение Из Результат Цикл
			Счетчик = Счетчик + 1;
			//Если Истина
			//	И (Вхождение.FirstIndex + 1) <= ЛокальнаяПозицияКурсора 
			//	И (Вхождение.FirstIndex + Вхождение.Length + 1) >= ЛокальнаяПозицияКурсора 
			//Тогда
			//	мНомерПараметра = Счетчик;
			//КонецЕсли;
			СтруктураПараметров.Вставить(СокрЛП(Вхождение.SubMatches(0)), СокрЛП(Вхождение.SubMatches(1)));
		КонецЦикла;
		СтруктураРезультата = Новый Структура;
		СтруктураРезультата.Вставить("ИмяСтруктурыПараметров", ИмяСтруктурыПараметров);
		СтруктураРезультата.Вставить("МассивПараметров", МассивПараметров);
		СтруктураРезультата.Вставить("ОригинальныйТекст", ПоследнееВхождение.Value);
		СтруктураРезультата.Вставить("Смещение", Смещение);
		СтруктураРезультата.Вставить("СтруктураПараметров", СтруктураПараметров);
		СтруктураРезультата.Вставить("НомерПараметра", мНомерПараметра);
		Возврат СтруктураРезультата;
	Иначе
		Возврат Неопределено;
	КонецЕсли;

КонецФункции

// Находит первое вхождение слова в тексте. Если слово найдено, устанавливается выделение и фокус.
//
// Параметры:
//  СтрокаПоиска			 - 	 - 
//  СловоЦеликом	 - Булево, "Переменная" - 
//  ПолеТекста	 - 	 - 
// 
// Возвращаемое значение:
//   - Булево - была ли найдена и выделена строка
//
Функция НайтиПоказатьСловоВТексте(СтрокаПоиска, Знач СловоЦеликомИлиШаблон = Истина, ПолеТекста = Неопределено, УстановитьФокус = Ложь, ИскатьСНачала = Ложь, Знач ИскатьСНачалаЕслиНеНайдено = Ложь,
	Знач НачалоОбласти = Неопределено, Знач КонецОбласти = Неопределено) Экспорт 
	
	Если ПолеТекста = Неопределено Тогда
		ПолеТекста = ЭтотОбъект.ПолеТекста;
	КонецЕсли;
	Если СловоЦеликомИлиШаблон = "Переменная" Тогда
		СловоЦеликомИлиШаблон = ШаблонШаблонаПоискаСлова();
	КонецЕсли;
	Если УстановитьФокус Тогда
		ЗапомнитьИсточникПерехода();
	КонецЕсли;
	Результат = ирКлиент.НайтиПоказатьФрагментВПолеТекстаЛкс(ФормаВладелец, ПолеТекста, СтрокаПоиска, СловоЦеликомИлиШаблон, ИскатьСНачала,,, НачалоОбласти, КонецОбласти, ИскатьСНачалаЕслиНеНайдено);
	Если УстановитьФокус Тогда
		УстановитьФокус();
	КонецЕсли; 
	Возврат Результат; 
	
КонецФункции

Функция ШаблонШаблонаПоискаСлова(Знач ЛиМетод = Ложь, Знач МожноЧерезЭтотОбъект = Ложь) Экспорт 
	
	Шаблон = "#Слово#";
	Если МожноЧерезЭтотОбъект Тогда
		Шаблон = ШаблонПоискаСловаЧерезЭтотОбъект(Шаблон);
	КонецЕсли;
	Шаблон = шЛитералПрограммы + "|(?:Новый|New)\s*#Слово#|(^|[^_a-zа-яё0-9"".])(" + Шаблон + ")\s*";
	Если ЛиМетод Тогда
		Возврат Шаблон + "\(";
	Иначе
		Возврат Шаблон + "($|[^_a-zа-яё0-9\(])";
	КонецЕсли;

КонецФункции

// Вставляет в текущую позицию поля текстового документа ссылку на объект БД.
//
// Параметры:
//  ЗначенияСвойствНового - Структура - если параметр будет добавлен, то к его строке будут применены эти значения свойств;
//  <Параметр2>  - <Тип.Вид> - <описание параметра>
//                 <продолжение описания параметра>.
//
// Возвращаемое значение:
//               - <Тип.Вид> - <описание значения>
//                 <продолжение описания значения>;
//  <Значение2>  - <Тип.Вид> - <описание значения>
//                 <продолжение описания значения>.
//
Функция ВставитьСсылкуНаОбъектБД(ТабличноеПолеПараметров, ИмяКолонкиИмени = "Имя", ИмяКолонкиЗначения = "Значение", ИмяСтруктурыПараметров = "",
	ОбновитьКопиюСвойстваВНижнемРегистре = Ложь, НачальноеЗначениеВыбора = Неопределено, РазрешитьВыбор = Истина, ВставитьВТекст = Истина) Экспорт

	ТаблицаПараметров = ТабличноеПолеПараметров.Значение;
	ТекущееОбъектноеВыражение = ТекущееОбъектноеВыражение();
	
	Если Истина
		И РазрешитьВыбор
		И НачальноеЗначениеВыбора = Неопределено
		И ВставитьВТекст
	Тогда
		Если Ложь
			Или ЯзыкПрограммы = 0
			Или Лев(ТекущееОбъектноеВыражение, 1) = "&" 
		Тогда
			ИмяПараметра = ТекущееОбъектноеВыражение;
			Если ЯзыкПрограммы = 1 Тогда
				ИмяПараметра = Сред(ИмяПараметра, 2);
			Иначе
				Если Истина
					И Не ПустаяСтрока(ИмяСтруктурыПараметров)
					И Найти(НРег(ИмяПараметра), НРег(ИмяСтруктурыПараметров) + ".") = 1 
				Тогда
					ИмяПараметра = Сред(ИмяПараметра, СтрДлина(ИмяСтруктурыПараметров) + 2);
				КонецЕсли; 
			КонецЕсли; 
			СтрокаНайденногоПараметра = ТаблицаПараметров.Найти(ИмяПараметра, ИмяКолонкиИмени);
			Если СтрокаНайденногоПараметра <> Неопределено Тогда
				Ответ = Вопрос("Использовать тип и значение выделенного в тексте параметра?", РежимДиалогаВопрос.ДаНет);
				Если Ответ = КодВозвратаДиалога.Да Тогда
					ЗначениеПараметра = СтрокаНайденногоПараметра[ИмяКолонкиЗначения];
					Если ирОбщий.ЛиСсылкаНаОбъектБДЛкс(ЗначениеПараметра, Ложь) Тогда
						НачальноеЗначениеВыбора = ЗначениеПараметра;
					КонецЕсли;
				КонецЕсли;
			КонецЕсли;
		КонецЕсли; 
	КонецЕсли; 
	//Если ЗначениеЗаполнено(НачальноеЗначениеВыбора) Тогда
	Если НачальноеЗначениеВыбора <> Неопределено Тогда
		ТипСсылки = ТипЗнч(НачальноеЗначениеВыбора);
		Если Не ирОбщий.ЛиТипСсылкиБДЛкс(ТипСсылки, Ложь) Тогда
			Возврат Неопределено;
		КонецЕсли; 
	КонецЕсли;
	Если РазрешитьВыбор Тогда
		ВыделитьТекущееОбъектноеВыражение();
	КонецЕсли; 
	
	Если ТипСсылки = Неопределено И Не ЗначениеЗаполнено(ТекущееОбъектноеВыражение) Тогда
		СтруктураТипаКонтекста = ПолучитьСтруктуруТипаСправаОтРавно();
		Если СтруктураТипаКонтекста <> Неопределено Тогда
			Если ТипЗнч(СтруктураТипаКонтекста.Метаданные) = Тип("ОбъектМетаданных") Тогда
				ТипСсылки = Тип(ирОбщий.ИмяТипаИзПолногоИмениМДЛкс(СтруктураТипаКонтекста.Метаданные.ПолноеИмя()));
			КонецЕсли; 
		КонецЕсли;
	КонецЕсли;
	
	Если РазрешитьВыбор И ТипСсылки = Неопределено Тогда
		ПараметрыВыбораМетаданных = Новый Структура;
		ПараметрыВыбораМетаданных.Вставить("ОтображатьСсылочныеОбъекты", Истина);
		ПараметрыВыбораМетаданных.Вставить("ОтображатьПеречисления", Истина);
		ПараметрыВыбораМетаданных.Вставить("ОтображатьВнешниеИсточникиДанных", Истина);
		ФормаВыбора = ирКлиент.ПолучитьФормуВыбораОбъектаМетаданныхСтруктуройЛкс(ФормаВладелец,,, ПараметрыВыбораМетаданных);
		Результат = ФормаВыбора.ОткрытьМодально();
		Если Результат = Неопределено Тогда
			Возврат Неопределено;
		КонецЕсли;
		ТипСсылки = Тип(ирОбщий.ИмяТипаИзПолногоИмениМДЛкс(Результат.ПолноеИмяОбъекта));
	КонецЕсли;
	
	Если НачальноеЗначениеВыбора = Неопределено Тогда
		НачальноеЗначениеВыбора = Новый (ТипСсылки);
	КонецЕсли;
	
	Если РазрешитьВыбор Тогда
		ЗначениеПараметра = ирКлиент.ВыбратьСсылкуЛкс(ТипСсылки, НачальноеЗначениеВыбора);
		УстановитьФокус();
	Иначе
		ЗначениеПараметра = НачальноеЗначениеВыбора;
	КонецЕсли; 
	Если ЗначениеПараметра = Неопределено Тогда
		Возврат Неопределено;
	КонецЕсли;
	Если ТабличноеПолеПараметров.ИзменяетДанные Тогда
		ФормаВладелец.Модифицированность = Истина;
	КонецЕсли; 
	
	СтрокаПараметра = ирОбщий.НайтиДобавитьПараметрСсылкуВТаблицуЛкс(ТаблицаПараметров, ИмяКолонкиИмени, ИмяКолонкиЗначения, ЗначениеПараметра,, ОбновитьКопиюСвойстваВНижнемРегистре);
	Если ВставитьВТекст Тогда
		ТекстВставки = СтрокаПараметра[ИмяКолонкиИмени];
		Если Ложь
			Или ЯзыкПрограммы = 1
			Или ЯзыкПрограммы = 2
		Тогда
			ТекстВставки = "&" + ТекстВставки;
		КонецЕсли;
		Если ЯзыкПрограммы = 0 Тогда
			Если Не ПустаяСтрока(ИмяСтруктурыПараметров) Тогда
				ТекстВставки = ИмяСтруктурыПараметров + "." + ТекстВставки;
			КонецЕсли; 
		КонецЕсли;
		ВыделенныйТекст(ТекстВставки);
	КонецЕсли; 
	Возврат СтрокаПараметра;

КонецФункции

// Обрабатывает нажатие на кнопки
//
// Параметры:
//  Кнопка - Кнопка.
//
// Возвращаемое значение:
//  Булево - результат проверки.
//
Функция Нажатие(Кнопка, ОбновитьКонтекст = Ложь) Экспорт
	
	Перем Результат;
	Команда = ирОбщий.ПоследнийФрагментЛкс(Кнопка.Имя, "_");
	Если Команда = "АвтоКонтекстнаяПомощь" Тогда
	    УстановитьАвтоКонтекстнаяПомощь(Не Кнопка.Пометка);
	КонецЕсли;
	Результат = ВыполнитьКоманду(Команда,, ОбновитьКонтекст);
	Возврат Результат;
	
КонецФункции

Функция ВыполнитьКоманду(Знач Команда, Знач КодКлавиши = "", ОбновитьКонтекст = Истина)
	
	Если ОбновитьКонтекст Тогда
		КончитьОбработкуКоманды();
		ФормаВладелец.КлсПолеТекстаПрограммыОбновитьКонтекст(ЭтотОбъект);
	КонецЕсли;
	Результат = Неопределено;
	КнопкиМакета0 = мФормаКласса.ЭлементыФормы.КоманднаяПанель0.Кнопки; // Встроенный язык  
	КнопкиМакета1 = мФормаКласса.ЭлементыФормы.КоманднаяПанель1.Кнопки; // Язык запросов
	КнопкиМакета2 = мФормаКласса.ЭлементыФормы.КоманднаяПанель2.Кнопки;
	КнопкиМакетаОбщие = мФормаКласса.ЭлементыФормы.КоманднаяПанельОбщая.Кнопки;
	мПлатформа.ПроверитьОбновитьКэш();
	Попытка
		мПлатформа.ИнициацияОписанияМетодовИСвойств();
		ПолучитьГраницыВыделения();
		мОткрытьСправкуПоПараметру = Ложь;
		Если Команда = КнопкиМакетаОбщие.ПодменюПолеПрограммы.Кнопки.ОткрытьАвтодополнение.Имя Тогда
			ОткрытьАвтодополнение(КодКлавиши, Не ЗначениеЗаполнено(КодКлавиши));
		ИначеЕсли Команда = КнопкиМакета0.СписокМетодов.Имя Тогда
			ОткрытьСписокМетодов();
		//ИначеЕсли Команда = КнопкиМакета0.СсылкиНаСлово.Имя Тогда
		//	ОткрытьПоискВызововСлова();
		ИначеЕсли Команда = КнопкиМакета0.НайтиВМодулях.Имя Тогда
			ОткрытьПоискВМодулях();
		ИначеЕсли Команда = КнопкиМакетаОбщие.ПодменюПолеПрограммы.Кнопки.ЗаменитьТабуляции.Имя Тогда
			ЗаменитьТабуляции();
		ИначеЕсли Команда = КнопкиМакетаОбщие.ПодменюПолеПрограммы.Кнопки.ВыделитьСлово.Имя Тогда
			// В платформе есть аналогичная системная команда, но для HTML редактора нужна.
			ВыделитьТекущееСлово();
		ИначеЕсли Команда = КнопкиМакета0.ПереименоватьСлово.Имя Тогда
			Если мЯзыкПрограммы = 0 Тогда
				ПереименоватьСлово();
			КонецЕсли;
		ИначеЕсли Команда = КнопкиМакета0.СписокМетодов.Имя Тогда
			//
		ИначеЕсли Команда = КнопкиМакета0.ВыделитьМетод.Имя Тогда
			ВыделитьМетод();
		ИначеЕсли Команда = КнопкиМакетаОбщие.СравнитьТекст.Имя Тогда
			ЗапомнитьДляСравнения();
		ИначеЕсли Команда = КнопкиМакета1.УдалитьПереносы.Имя Тогда
			УдалитьПереносы();
		ИначеЕсли Команда = КнопкиМакета1.КонструкторЗапросов1С.Имя Тогда
			Результат = ВызватьКонструкторЗапросов(Ложь);
		ИначеЕсли Команда = КнопкиМакета1.КонструкторЗапросовИР.Имя Тогда
			Результат = ВызватьКонструкторЗапросов(Истина);
		ИначеЕсли Команда = КнопкиМакета0.КонструкторЗапросов.Имя Тогда
			Результат = ВызватьКонструкторЗапросов();
		ИначеЕсли Команда = КнопкиМакета1.КонсольЗапросов.Имя Тогда
			Результат = РедактироватьВКонсолиЗапросов();
		ИначеЕсли Команда = КнопкиМакета0.КонсольКода.Имя Тогда
			Результат = РедактироватьВКонсолиКода();
		ИначеЕсли Команда = КнопкиМакета1.ВставитьИзБуфераОбменаВесьТекст.Имя Тогда
			ирКлиент.УстановитьТекстСОткатомЛкс(ПолеТекста, ирКлиент.ТекстИзБуфераОбменаОСЛкс());
		ИначеЕсли Команда = КнопкиМакета1.КопироватьВБуферОбменаВесьТекст.Имя Тогда
			ирКлиент.ТекстВБуферОбменаОСЛкс(ПолеТекста.ПолучитьТекст(), ?(ЯзыкПрограммы = 0, "ВстроенныйЯзык", "ЯзыкЗапросов"));
		ИначеЕсли Команда = КнопкиМакета1.КопироватьВБуферОбменаТекстВВидеКода.Имя Тогда
			КопироватьВБуферОбменаТекстВВидеКода(); 
		ИначеЕсли Команда = КнопкиМакета1.Закомментировать.Имя Тогда
			Закомментировать();
		ИначеЕсли Команда = КнопкиМакета1.Раскомментировать.Имя Тогда
			Раскомментировать();
		ИначеЕсли Команда = КнопкиМакета0.РедакторСтроковогоЛитерала.Имя Тогда
			Результат = ОткрытьРедакторСтроковогоЛитерала();
		ИначеЕсли Команда = КнопкиМакета1.ИсследоватьСхемуЗапроса.Имя Тогда
			Если ПроверитьПрограммныйКод() Тогда 
				СхемаЗапроса = Вычислить("Новый схемаЗапроса");
				#Если Сервер И Не Сервер Тогда
					СхемаЗапроса = Новый СхемаЗапроса;
				#КонецЕсли
				Если ирКэш.НомерВерсииПлатформыЛкс() >= 803014 Тогда
					СхемаЗапроса.РежимКомпоновкиДанных = РежимКомпоновкиДанных;
				КонецЕсли;
				СхемаЗапроса.УстановитьТекстЗапроса(ПолеТекста.ПолучитьТекст());
				ирОбщий.ИсследоватьЛкс(СхемаЗапроса);
			КонецЕсли;
		ИначеЕсли Команда = КнопкиМакетаОбщие.ПерейтиКОпределению.Имя Тогда
			ПерейтиКОпределению();
			Результат = мТекущееСлово;
		ИначеЕсли Команда = КнопкиМакета0.ПерейтиВНачалоБлока.Имя Тогда
			ПерейтиВНачалоБлока();
		ИначеЕсли Команда = КнопкиМакетаОбщие.Проверить.Имя Тогда
			ПроверитьПрограммныйКод(Истина);
		ИначеЕсли Команда = КнопкиМакетаОбщие.УстановитьФокус.Имя Тогда
			УстановитьФокус();
		ИначеЕсли ЯзыкПрограммы = 1 И Команда = КнопкиМакета1.Форматировать.Имя Тогда
			ФорматироватьТекстЯзыкаЗапросов();
		ИначеЕсли ЯзыкПрограммы = 0 И Команда = КнопкиМакета0.Форматировать.Имя Тогда
			ФорматироватьТекстВстроенногоЯзыка();
		ИначеЕсли Команда = КнопкиМакета0.Выполнить.Имя Тогда
			ВыполнитьПрограммныйКод();
		ИначеЕсли Команда = КнопкиМакетаОбщие.КонтекстныйСинтаксПомощник.Имя Тогда
			мПоследнийРежимВызоваСправки = Команда;
			ОткрытьКонтекстнуюСправку(, ФормаВладелец);
		//ИначеЕсли Команда = КнопкиМакетаОбщие.СинтаксПомощник.Имя Тогда
		//	_ОткрытьСправкуПоЯзыкуПрограммы();
		ИначеЕсли Команда = КнопкиМакетаОбщие.ПодсказатьПараметр.Имя Тогда
			мПоследнийРежимВызоваСправки = Команда;
			ОткрытьСправкуПоПараметру();
		ИначеЕсли Команда = КнопкиМакетаОбщие.ВернутьсяИзПерехода.Имя Тогда
			ВернутьсяИзПерехода();
		ИначеЕсли Команда = КнопкиМакета0.КонструкторОписанияТипов.Имя Тогда
			КонструкторОписанияТипов();
		ИначеЕсли Команда = КнопкиМакетаОбщие.ПодменюПолеПрограммы.Кнопки.Настройка.Имя Тогда
			ПолучитьФорму("ФормаНастройки", ФормаВладелец).Открыть(); 
			
		// Бескнопочные команды
		ИначеЕсли Команда = "ПодсказатьПараметрАвто" Тогда 
			#Если ТолстыйКлиентОбычноеПриложение Тогда
				Если ФормаВладелец.ТекущийЭлемент = ПолеТекста.ЭлементФормы Тогда
					ОткрытьСправкуПоПараметру(, Ложь);
				КонецЕсли; 
			#КонецЕсли
		ИначеЕсли Команда = КнопкиМакетаОбщие.ПодменюПолеПрограммы.Кнопки.ВыполнитьШаблон.Имя Тогда
			ВыполнитьШаблонТекста();
		ИначеЕсли Команда = "НайтиСледующееHTML" Тогда
			НайтиСледующееHTML();
		ИначеЕсли Команда = "НайтиПредыдущееHTML" Тогда
			НайтиПредыдущееHTML();
		ИначеЕсли Команда = "ЗаменитьВхожденияHTML" Тогда
			ЗаменитьВхожденияHTML();
		ИначеЕсли Команда = "СочетанияКлавишHTML" Тогда
			СочетанияКлавишHTML();
		ИначеЕсли Команда = "КонструкторФорматнойСтроки" Тогда
			КонструкторФорматнойСтроки();
		КонецЕсли;
		
		Если Ложь
			Или Команда = "ВыделитьСлово"
			Или Команда = "Форматировать"
			Или Команда = "ВыполнитьШаблон"
			Или Команда = "ОткрытьАвтодополнение"
			Или Команда = "ПодсказатьПараметрАвто"
			Или Команда = "ЗаменитьТабуляции"
			Или Команда = "УдалитьПереносы"
			Или Команда = "ПерейтиКОпределению"
			Или Команда = "КонструкторЗапросов1С"
			Или Команда = "КонструкторЗапросовИР"
			Или Команда = "КонструкторЗапросов"
			Или Команда = "РедакторСтроковогоЛитерала"
		Тогда
			Если Результат <> Ложь Тогда 
				ВосстановитьГраницыВыделенияПослеКоманды();
			КонецЕсли;
		КонецЕсли;
	Исключение
		КончитьОбработкуКоманды();
		ВосстановитьФокусВвода();
		ВызватьИсключение;
	КонецПопытки;
	КончитьОбработкуКоманды();
	ВосстановитьФокусВвода();
	Возврат Результат;

КонецФункции

Функция ЗапомнитьДляСравнения(Знач РазрешитьВопросы = Истина) Экспорт
	ВариантСинтаксисаСравнителя = Неопределено;
	Если ЯзыкПрограммы = 0 Тогда
		ВариантСинтаксисаСравнителя = "ВстроенныйЯзык";
	ИначеЕсли ЯзыкПрограммы = 1 Тогда
		ВариантСинтаксисаСравнителя = "ЯзыкЗапросов";
	ИначеЕсли ЯзыкПрограммы = 2 Тогда
		ВариантСинтаксисаСравнителя = "ЯзыкКомпоновки";
	КонецЕсли; 
	Возврат ирКлиент.ЗапомнитьСодержимоеЭлементаФормыДляСравненияЛкс(ФормаВладелец, ПолеТекста, ВариантСинтаксисаСравнителя, РазрешитьВопросы);
КонецФункции

Процедура ВосстановитьГраницыВыделенияПослеКоманды()
	
	УстановитьГраницыВыделения();
	Если мОткрытьСправкуПоПараметру И ЛиДоступноОткрытиеСвободнойФормы() Тогда
		// Антибаг 8.3.19+ https://www.hostedredmine.com/issues/956304
		//ОткрытьСправкуПоПараметру(, Ложь);
		ФормаПодсказкаПоПараметрам = ФормаВызовМетода();
		ФормаПодсказкаПоПараметрам.ПодключитьОбработчикОжидания("ОткрытьОтложенно", 0.1, Истина);
	КонецЕсли;

КонецПроцедуры  

Процедура ПолучитьГраницыВыделения() Экспорт
	ПолеТекста.ПолучитьГраницыВыделения(мНачальнаяСтрока, мНачальнаяКолонка, мКонечнаяСтрока, мКонечнаяКолонка);
КонецПроцедуры

Процедура УстановитьГраницыВыделения(Знач НачальнаяСтрокаИлиПозиция = Неопределено, Знач НачальнаяКолонкаИлиКонечнаяПозиция = Неопределено, Знач КонечнаяСтрока = Неопределено, Знач КонечнаяКолонка = Неопределено,
	Знач ОшибкаПриВыходеЗаКонец = Истина) Экспорт 
	
	#Если Сервер И Не Сервер Тогда
		ПолеТекста = Обработки.ирОболочкаПолеТекста.Создать();
	#КонецЕсли
	Если НачальнаяСтрокаИлиПозиция = Неопределено Тогда
		НачальнаяСтрокаИлиПозиция = мНачальнаяСтрока;
		НачальнаяКолонкаИлиКонечнаяПозиция = мНачальнаяКолонка;
		КонечнаяСтрока = мКонечнаяСтрока;
		КонечнаяКолонка = мКонечнаяКолонка;
	КонецЕсли;
	//Структура = ПолеТекста.ВыделениеДвумерное();
	//Если Ложь
	//	// Экономная установка для подавления угасания мигания каретки из-за антибага платформы https://www.hostedredmine.com/issues/936432
	//	// Но баг платформы ЗаменитьСтроку() вызывает фактическое выделение всего предшествующего текста иногда без возможности получить настоящие границы выделения на 8.3.18 https://www.hostedredmine.com/issues/936821
	//	Или Структура.НачальнаяСтрока <> мНачальнаяСтрока 
	//	Или Структура.НачальнаяКолонка <> мНачальнаяКолонка 
	//	Или Структура.КонечнаяСтрока <> мКонечнаяСтрока 
	//	Или Структура.КонечнаяКолонка <> мКонечнаяКолонка 
	//Тогда
		ПолеТекста.УстановитьГраницыВыделения(НачальнаяСтрокаИлиПозиция, НачальнаяКолонкаИлиКонечнаяПозиция, КонечнаяСтрока, КонечнаяКолонка,, ФормаВладелец, ОшибкаПриВыходеЗаКонец);
	//КонецЕсли; 

КонецПроцедуры

Функция ФорматироватьТекстЯзыкаЗапросов() Экспорт
	
	ВыделениеДвумерное = ПолеТекста.ВыделениеДвумерное();
	ВыделенныйТекст = ВыделенныйТекст();
	ТолькоВыделенныйТекст = СтрДлина(ВыделенныйТекст) > 10;
	Если ТолькоВыделенныйТекст Тогда
		ТекстЗапроса = ВыделенныйТекст;
	Иначе
		ТекстЗапроса = ПолеТекста.ПолучитьТекст();
	КонецЕсли;
	КонструкторЗапроса = ПолучитьФорму("КонструкторЗапроса");
	КонструкторЗапроса.ВосстановитьНастройкиФормы();
	Результат = Ложь;
	Попытка
		Если ЗагрузитьТекстВКонструктор(ТекстЗапроса, КонструкторЗапроса) Тогда 
			НовыйТекст = КонструкторЗапроса.СобратьПолныйТекст(, Истина); 
			Если Не ТолькоВыделенныйТекст Тогда
				ВыделитьВесьТекст();
			КонецЕсли;
			мЗаменяемыйДиапазон = ПолеТекста.ВыделениеОдномерное();
			ЗаменитьВыделенныйТекстЗапросаСоСнятиемВыделения(НовыйТекст);
			мЗамещающийФрагмент = НовыйТекст;
			Результат = Истина;
		КонецЕсли;
		ПолеТекста.УстановитьВыделениеДвумерное(ВыделениеДвумерное);
		ПолучитьГраницыВыделения();
	Исключение
		Сообщить(КраткоеПредставлениеОшибки(ИнформацияОбОшибке()));
	КонецПопытки; 
	Возврат Результат;

КонецФункции

Функция ФорматироватьТекстВстроенногоЯзыка(Знач МожноВесьТекст = Истина, Знач БазовыйУровень = Неопределено) Экспорт 
	
	ВыделенныйТекст = ВыделенныйТекст();
	НачальнаяСтрока = мНачальнаяСтрока;
	КонечнаяСтрока = мКонечнаяСтрока;
	Если ПустаяСтрока(ВыделенныйТекст) Тогда
		Если Не МожноВесьТекст Тогда
			Возврат Ложь;
		КонецЕсли;
		ВыделитьВесьТекст();
		НачальнаяСтрока = 1;
		КонечнаяСтрока = ПолеТекста.КоличествоСтрок() + 1;
	КонецЕсли; 
	УстановитьГраницыВыделения(НачальнаяСтрока, 1, КонечнаяСтрока + ?(мКонечнаяКолонка = 1, 0, 1), 1); // Выделяем полные строки
	Если ФормаВладелец = Неопределено Тогда
		мЗаменяемыйДиапазон = ПолеТекста.ВыделениеОдномерное();
	КонецЕсли;
	ВыделенныйТекст = ВыделенныйТекст();
	НовыйТекст = СтроитьДеревоПрограммныхСкобок(ВыделенныйТекст, НачальнаяСтрока,,, БазовыйУровень);
	//НовыйТекст = ирОбщий.СтрокаБезКонцаЛкс(НовыйТекст);
	ПолеТекста.ВставитьТекст(НовыйТекст, Ложь); 
	Если ФормаВладелец = Неопределено Тогда
		мЗамещающийФрагмент = НовыйТекст;
	КонецЕсли;
	Возврат Истина;

КонецФункции

// .
// Параметры:
//  ВыделенныйТекст			 - Строка - 
//  НачальнаяСтрока			 - Число - 
//  ПозицияДляСбораРодителей - Число - начиная с 1
//  выхРодителиПозиции		 - см. РодителиПозицииВТексте() - 
//  БазовыйУровень			 - Число - 
// 
// Возвращаемое значение:
//  Строка - 
//
Функция СтроитьДеревоПрограммныхСкобок(Знач ВыделенныйТекст = "", Знач НачальнаяСтрока = 1, Знач ПозицияДляСбораРодителей = 0, выхРодителиПозиции = Неопределено, Знач БазовыйУровень = Неопределено,
	Знач ТолькоПервый = Ложь) Экспорт
	
	Если Не ЗначениеЗаполнено(ВыделенныйТекст) Тогда
		ВыделенныйТекст = ОпределениеМетодаБезОписания();
	КонецЕсли;     
	ЧислоПробеловВТабуляции = 4;
	ТекстДокумент = Новый ТекстовыйДокумент;
	ТекстДокумент.УстановитьТекст(ВыделенныйТекст);
	ГруппыКлючевыхСлов = Новый Массив;
	// * - означает любая строка
	ГруппыКлючевыхСлов.Добавить("#?(Если|ИначеЕсли|Для|Пока)*(Тогда|Цикл),#?Иначе,#?(КонецЕсли|КонецЦикла)");
	СтроитьКарту = ПозицияДляСбораРодителей > 0;
	Если ТолькоПервый Или Не СтроитьКарту Тогда 
		ГруппыКлючевыхСлов.Добавить("(?:Процедура|Функция|Попытка)*,Исключение,(?:КонецПроцедуры|КонецФункции|КонецПопытки)");
		//ГруппыКлючевыхСлов.Добавить("(?:Процедура|Функция|Попытка)*\),Исключение,(?:КонецПроцедуры|КонецФункции|КонецПопытки)");
	КонецЕсли;
	Если СтроитьКарту Тогда
		ОткрытыеСкобки = Новый СписокЗначений;  
		ПредУровеньСтроки = 0;
		ПредУровеньВыражения = 0;
		ПредСтрока = Неопределено;
		ПредСловоНайдено = Истина;
		Если ТипЗнч(выхРодителиПозиции) <> Тип("ТаблицаЗначений") Тогда
			выхРодителиПозиции = РодителиПозицииВТексте();
		КонецЕсли;
	КонецЕсли;    
	УровеньИнструкции = 0;
	УровеньВыражения = 0;
	УровеньНачалаУсловия = 0; 
	ПозицияНачалаСтроки = 0;
	ВхожденияКэш = ирКэш.ВычислительРегВыраженийЛкс().НоваяТаблицаВхождений();
	ПерваяСтрока = ПолеТекста.ПолучитьСтроку(Макс(1, НачальнаяСтрока - 1));
	СмещениеПервойСтроки = Лев(ПерваяСтрока, СтрДлина(ПерваяСтрока) - СтрДлина(СокрЛ(ПерваяСтрока)));
	СмещениеПервойСтроки = СтрЗаменить(СмещениеПервойСтроки, Символы.Таб, ирОбщий.СтрокаПовторомЛкс(" ", ЧислоПробеловВТабуляции));
	Если БазовыйУровень = Неопределено Тогда
		БазовыйУровень = Цел(СтрДлина(СмещениеПервойСтроки) / ЧислоПробеловВТабуляции);
	КонецЕсли;
	Если НачальнаяСтрока > 1 Тогда
		ТекстДокумент.ВставитьСтроку(1, ПерваяСтрока);
	КонецЕсли;
	Для СчетчикСтроки = 1 По ТекстДокумент.КоличествоСтрок() Цикл
		СтрокаТекста = ТекстДокумент.ПолучитьСтроку(СчетчикСтроки);
		Если Истина
			И Лев(СокрЛ(СтрокаТекста), 1) = "~" 
			И Прав(СокрП(СтрокаТекста), 1) = ":"
		Тогда 
			// Метка
			ТекстДокумент.ЗаменитьСтроку(СчетчикСтроки, СокрЛ(СтрокаТекста));
			Продолжить;
		КонецЕсли;
		СтрокаТекстаДоКомментария = ЗалитьКомментарииИСтроковыеЛитералы(СтрокаТекста,, Истина,, Истина);
		СмещениеУровня = 0;
		СмещениеСледующегоУровня = Неопределено;
		СловоНайдено = НайтиКлючевыеСловаФорматирования(СтрокаТекстаДоКомментария, ГруппыКлючевыхСлов, УровеньИнструкции, УровеньВыражения, УровеньНачалаУсловия, СмещениеСледующегоУровня, ВхожденияКэш);
		Если СчетчикСтроки > 1 Тогда
			Если Не СловоНайдено Тогда
				СмещениеУровня = УровеньВыражения;
			КонецЕсли; 
			УровеньСтроки = БазовыйУровень + УровеньИнструкции + СмещениеУровня;
			ТекстДокумент.ЗаменитьСтроку(СчетчикСтроки, ирОбщий.СтрокаПовторомЛкс(Символы.Таб, УровеньСтроки) + СокрЛ(СтрокаТекста));
			Если СтроитьКарту Тогда
				//Если ПредУровеньВыражения = 0 Тогда
				Если УровеньСтроки > ПредУровеньСтроки Тогда
					ОткрытыеСкобки.Добавить(ПозицияНачалаСтроки - СтрДлина(ПредСтрока) - 1, ПредСтрока);
				ИначеЕсли Истина
					И УровеньСтроки < ПредУровеньСтроки 
					И ОткрытыеСкобки.Количество() > 0 // 0 в заголовке метода 
				Тогда
					ОписаниеОбласти = ОткрытыеСкобки[ОткрытыеСкобки.Количество() - 1];
					ПозицияНачала = ОписаниеОбласти.Значение;
					ПозицияКонца = ПозицияНачалаСтроки; 
					//ПозицияКонца = ПозицияКонца + СтрДлина(СтрокаТекста);  
					Если Истина
						И ПозицияНачала + СтрДлина(ОписаниеОбласти.Значение) < ПозицияДляСбораРодителей
						И ПозицияКонца > ПозицияДляСбораРодителей 
						И ПредУровеньВыражения = 0
					Тогда
						Родитель = выхРодителиПозиции.Добавить();
						Родитель.Область = ОписаниеОбласти.Представление;
						Родитель.ПозицияНачала = ПозицияНачала;
						Родитель.ПозицияКонца = ПозицияКонца + 1;
						Если ТолькоПервый Тогда
							Прервать;
						КонецЕсли;
					КонецЕсли;
					ОткрытыеСкобки.Удалить(ОткрытыеСкобки.Количество() - 1);
				КонецЕсли;
				//КонецЕсли;
				ПредУровеньСтроки = УровеньСтроки;
				ПредУровеньВыражения = УровеньВыражения;
			КонецЕсли;
		Иначе
			Если СловоНайдено Тогда
				УровеньИнструкции = 0;
			КонецЕсли;
			Если НачальнаяСтрока = 1 Тогда
				ТекстДокумент.ЗаменитьСтроку(СчетчикСтроки, ирОбщий.СтрокаПовторомЛкс(Символы.Таб, БазовыйУровень) + СокрЛ(СтрокаТекста));
			КонецЕсли;
		КонецЕсли;
		УровеньИнструкции = УровеньИнструкции + СмещениеСледующегоУровня;
		ПозицияНачалаСтроки = ПозицияНачалаСтроки + СтрДлина(СтрокаТекста + Символы.ПС);
		ПредСтрока = СтрокаТекста;
		Если ПустаяСтрока(СтрокаТекстаДоКомментария) Тогда
			Продолжить;
		КонецЕсли;
		Если Не СловоНайдено Тогда 
			СтрокаБезЛитералов = СокрЛП(ЗалитьКомментарииИСтроковыеЛитералы(СтрокаТекстаДоКомментария,, Истина,, Истина));
			Если Прав(СтрокаБезЛитералов, 1) = ";" Тогда 
				НовыйУровеньВыражения = 0;
			Иначе
				НовыйУровеньВыражения = УровеньВыражения;
				Если НовыйУровеньВыражения = 0 Тогда
					НовыйУровеньВыражения = 1;
				КонецЕсли;
				НовыйУровеньВыражения = НовыйУровеньВыражения + СтрЧислоВхождений(СтрокаБезЛитералов, "(") - СтрЧислоВхождений(СтрокаБезЛитералов, ")");
			КонецЕсли;
			УровеньВыражения = НовыйУровеньВыражения;
		КонецЕсли;
	КонецЦикла;
	Если НачальнаяСтрока > 1 Тогда
		ТекстДокумент.УдалитьСтроку(1);
	КонецЕсли;
	НовыйТекст = ТекстДокумент.ПолучитьТекст();
	Возврат НовыйТекст;
КонецФункции

//.
// Возвращаемое значение:
//    ТаблицаЗначений, Неопределено - 
Функция РодителиПозицииВТексте() Экспорт
	выхРодителиПозиции = Новый ТаблицаЗначений;
	выхРодителиПозиции.Колонки.Добавить("Область");
	выхРодителиПозиции.Колонки.Добавить("ПозицияНачала"); // Начиная с 0. Начало последней строки шапки области
	выхРодителиПозиции.Колонки.Добавить("ПозицияКонца"); // Начиная с 0
	Возврат выхРодителиПозиции;
КонецФункции

//.
// Параметры:
//    СтрокаТекстаДоКомментария - Строка, Неопределено - 
//    ГруппыКлючевыхСлов - Массив[Строка] - 
//    УровеньНачалаУсловия - Число - 
//    ВхожденияКэш - ТаблицаЗначений - 
//    СмещениеСледующегоУровня - Число - 
// Возвращаемое значение:
//    Булево - 
Функция НайтиКлючевыеСловаФорматирования(Знач СтрокаТекстаДоКомментария, Знач ГруппыКлючевыхСлов, УровеньИнструкции = 0, УровеньВыражения = 0,  УровеньНачалаУсловия = 0, 
	СмещениеСледующегоУровня = Неопределено, ВхожденияКэш = Неопределено) Экспорт
	
	СмещениеСледующегоУровня = 0; 
	СловоНайдено = Ложь;
	НайденоНадежно = Ложь;
	Для Каждого ГруппаКлючевыхСлов Из ГруппыКлючевыхСлов Цикл
		СловаГруппы = ирОбщий.СтрРазделитьЛкс(ГруппаКлючевыхСлов, ",", Истина);
		ШаблонКонцаКонструкции = СловаГруппы[СловаГруппы.ВГраница()];
		Если ирОбщий.НайтиРегВыражениеЛкс(СтрокаТекстаДоКомментария, мПлатформа.шПустоеНачалоСтроки + ШаблонКонцаКонструкции + "(?=//|\s*;|\s*$)",,,,,,,,, ВхожденияКэш).Количество() > 0 Тогда
			УровеньИнструкции = УровеньИнструкции - 1;
			СловоНайдено = Истина;
		Иначе 
			Для ИндексСлова = 0 По СловаГруппы.ВГраница() - 1 Цикл
				Слово = СловаГруппы[ИндексСлова];
				Если Найти(Слово, "*") = 0 Тогда
					Если ирОбщий.НайтиРегВыражениеЛкс(СтрокаТекстаДоКомментария, мПлатформа.шПустоеНачалоСтроки + Слово + "(?=//|\s*$)",,,,,,,,, ВхожденияКэш).Количество() > 0 Тогда
						УровеньИнструкции = УровеньИнструкции - 1;
						СловоНайдено = Истина; 
						СмещениеСледующегоУровня = 1;
						УровеньВыражения = 0;
					КонецЕсли;
				Иначе 
					ФрагментыСлова = ирОбщий.СтрРазделитьЛкс(Слово, "*");
					Если ЗначениеЗаполнено(ФрагментыСлова[1]) И ирОбщий.НайтиРегВыражениеЛкс(СтрокаТекстаДоКомментария, мПлатформа.шПустоеНачалоСтроки + ФрагментыСлова[1] + "(?=//|\s*$)",,,,,,,,, ВхожденияКэш).Количество() > 0 Тогда
						// Конец условия на отдельной строке
						УровеньИнструкции = УровеньНачалаУсловия;
						СловоНайдено = Истина; 
						СмещениеСледующегоУровня = 1;
						УровеньВыражения = 0;
					Иначе
						ЧислоНачалУсловия = ирОбщий.НайтиРегВыражениеЛкс(СтрокаТекстаДоКомментария, мПлатформа.шПустоеНачалоСтроки + ФрагментыСлова[0] + "(?=//|\s|$)",,,,,,,,, ВхожденияКэш).Количество();
						ПервоеСлово = "";
						Если Истина
							И ЧислоНачалУсловия > 0
							И ВхожденияКэш[0].Подгруппы.Количество() > 0
						Тогда
							ПервоеСлово = ВхожденияКэш[0].Подгруппы[0];
						КонецЕсли;
						НужноИскатьКонецКонструкции = Ложь;
						//Если ФрагментыСлова[1] = "\)" Тогда
						Если ЗначениеЗаполнено(ФрагментыСлова[1]) Тогда
							Вхождения = ирОбщий.НайтиРегВыражениеЛкс(СтрокаТекстаДоКомментария, шПредИмяПрямое + ФрагментыСлова[1] + "(?=//|\s|$)([^\n]*)",,,,,,,,, ВхожденияКэш);
							ЧислоКонцовУсловия = Вхождения.Количество();
							Если ЧислоКонцовУсловия > 0 Тогда
								КонецСтроки = Вхождения[Вхождения.Количество()-1].Подгруппы[0];
								НужноИскатьКонецКонструкции = ЗначениеЗаполнено(КонецСтроки) И Не ирОбщий.СтрНачинаетсяСЛкс(СокрЛ(КонецСтроки), "//");
							КонецЕсли;
						Иначе
							ЧислоКонцовУсловия = ЧислоНачалУсловия;
						КонецЕсли;
						Если ИндексСлова > 0 Или ПервоеСлово = "ИначеЕсли" Тогда
							УровеньИнструкции = УровеньИнструкции - 1;
						КонецЕсли;
						Если ЧислоНачалУсловия > ЧислоКонцовУсловия Тогда
							УровеньВыражения = 1;
							СловоНайдено = Истина;
							УровеньНачалаУсловия = УровеньИнструкции;
						КонецЕсли;
						Если ЧислоКонцовУсловия > 0 Тогда
							УровеньВыражения = 0;
							СловоНайдено = Истина;
							НайденоНадежно = ЧислоНачалУсловия >= ЧислоКонцовУсловия;
							Если Ложь
								Или Не НужноИскатьКонецКонструкции
								Или ирОбщий.НайтиРегВыражениеЛкс(СтрокаТекстаДоКомментария, шПредИмяПрямое + ШаблонКонцаКонструкции + "(?=//|\s*;|\s*$)",,,,,,,,, ВхожденияКэш).Количество() = 0 
							Тогда
								СмещениеСледующегоУровня = 1;
							КонецЕсли;
						КонецЕсли;
					КонецЕсли;
				КонецЕсли;
				Если СловоНайдено И НайденоНадежно Тогда
					Прервать;
				КонецЕсли;
			КонецЦикла;
		КонецЕсли;
		Если СловоНайдено И НайденоНадежно Тогда
			Прервать;
		КонецЕсли;
	КонецЦикла;
	Возврат СловоНайдено;
КонецФункции

Функция ВыделенныйТекст(Знач НовыйТекст = Неопределено) Экспорт 
	
	#Если Сервер И Не Сервер Тогда
		ПолеТекста = Обработки.ирОболочкаПолеТекста.Создать();
	#КонецЕсли
	Результат = ПолеТекста.ВыделенныйТекст(НовыйТекст);
	Если НовыйТекст <> Неопределено Тогда
		ПослеУстановкиВыделенногоМногострочногоТекста();
	КонецЕсли; 
	Возврат Результат;

КонецФункции

Процедура ДобавитьВТекстЗапросаОтборыПоСтрокеРезультата(ТекущаяСтрокаРезультата, ИменаПолей = Неопределено) Экспорт 
	ТекстЗапроса = ПолеТекста.ПолучитьТекст();
	КонструкторЗапроса = ПолучитьФорму("КонструкторЗапроса");
	КонструкторЗапроса.ВосстановитьНастройкиФормы();
	Если КонструкторЗапроса.ЗагрузитьТекстВКонструктор(ТекстЗапроса, КонструкторЗапроса) Тогда
		КонструкторЗапроса.ЗагрузитьПоследнийЗапрос();
		КонструкторЗапроса.ДобавитьОтборыПоСтрокеРезультата(ТекущаяСтрокаРезультата,, ИменаПолей);
		ВыделитьВесьТекст();
		ВыделенныйТекст(КонструкторЗапроса.СобратьПолныйТекст(, Истина));
		КонструкторЗапроса.ЗагрузитьПараметрыВОбъект();
		ПослеУстановкиВыделенногоМногострочногоТекста();
	КонецЕсли;
КонецПроцедуры

Процедура ВыделитьВесьТекст(ПолеТекста = Неопределено) Экспорт 
	
	Если ПолеТекста = Неопределено Тогда
		ПолеТекста = ЭтотОбъект.ПолеТекста;
	КонецЕсли; 
	КоличествоСтрок = ПолеТекста.КоличествоСтрок();
	#Если Сервер И Не Сервер Тогда
		ПолеТекста = Обработки.ирОболочкаПолеТекста.Создать();
	#КонецЕсли
	ПолеТекста.УстановитьГраницыВыделения(1, 1, Макс(1, КоличествоСтрок), СтрДлина(ПолеТекста.ПолучитьСтроку(КоличествоСтрок) + 1),, ФормаВладелец);

КонецПроцедуры

Процедура ПослеУстановкиВыделенногоМногострочногоТекста()
	
	Перем НачСтрока, НачКолонка, КонСтрока, КонКолонка;
	#Если Сервер И Не Сервер Тогда
		ПолеТекста = Обработки.ирОболочкаПолеТекста.Создать();
	#КонецЕсли
	Если ФормаВладелец = Неопределено Тогда
		Возврат;
	КонецЕсли; 
	Если ТипЗнч(ПолеТекста.ЭлементФормы) = Тип("ПолеТекстовогоДокумента") Тогда
		
		// Антибаг платформы https://partners.v8.1c.ru/forum/topic/1860281 , http://www.hostedredmine.com/issues/840411
		ПолеТекста.ПолучитьГраницыВыделения(НачСтрока, НачКолонка, КонСтрока, КонКолонка);
		ПолеТекста.УстановитьГраницыВыделения(1, 1, 1, 1);
		ПолеТекста.ЭлементФормы.ВыделенныйТекст = "";
		ПолеТекста.УстановитьГраницыВыделения(НачСтрока, НачКолонка, КонСтрока, КонКолонка,, ФормаВладелец);
		
		УстановитьПризнакМодифицированностиФормы();
	КонецЕсли; 

КонецПроцедуры

// Устанавливает фокус на связанное поле текста программы
Процедура УстановитьФокус(Знач Мягко = Ложь) Экспорт 

	#Если Сервер И Не Сервер Тогда
		ПолеТекста = Обработки.ирОболочкаПолеТекста.Создать();
	#КонецЕсли
	Если ФормаВладелец = Неопределено Тогда
		Возврат;
	КонецЕсли;
	ирОбщий.ПрисвоитьЕслиНеРавноЛкс(ФормаВладелец.ТекущийЭлемент, ПолеТекста.ЭлементФормы); // Условно меняем для ускорения
	Если Не Мягко Тогда
		ВосстановитьФокусВвода();
	КонецЕсли;

КонецПроцедуры

// https://www.hostedredmine.com/issues/931798 и куча похожих
Процедура ВосстановитьФокусВвода()
	
	Если Истина
		И ФормаВладелец <> Неопределено
		И ТипЗнч(ФормаВладелец.ТекущийЭлемент) = Тип("ПолеHTMLДокумента") 
	Тогда
		// https://github.com/salexdv/bsl_console/issues/122
		//ПолеТекста.РедакторHTML().focus();
		//ПолеТекста.РедакторHTML().editor.focus();
		ирКлиент.УстановитьФокусВводаФормеЛкс();
	КонецЕсли;

КонецПроцедуры

Процедура АвтоОбновитьСправку() Экспорт 
	
	Если Ложь
		Или Не ирКлиент.Форма_ВводДоступенЛкс(ФормаВладелец) 
		Или ФормаВладелец.ТекущийЭлемент <> ПолеТекста.ЭлементФормы
	Тогда
		Возврат;
	КонецЕсли; 
	Если мПоследнийРежимВызоваСправки = Неопределено Тогда
		Возврат;
	КонецЕсли; 
	мЭтоАвтоВызов = Истина;
	Кнопка = ирКлиент.КнопкаКоманднойПанелиЭкземпляраКомпонентыЛкс(ЭтотОбъект, мПоследнийРежимВызоваСправки); 
	Нажатие(Кнопка);
	ФормаВладелец.Активизировать();
	мЭтоАвтоВызов = Ложь;
	
КонецПроцедуры

Функция ПолучитьВыделенныйИлиВесьТекст() Экспорт 

	НовыйТекстЗапроса = ВыделенныйТекст();
	Если ПустаяСтрока(НовыйТекстЗапроса) Тогда
		НовыйТекстЗапроса = ПолеТекста.ПолучитьТекст();
	КонецЕсли; 
	Возврат НовыйТекстЗапроса;

КонецФункции

// <Описание процедуры>
//
// Параметры:
//  <Параметр1>  - <Тип.Вид> - <описание параметра>
//                 <продолжение описания параметра>;
//  <Параметр2>  - <Тип.Вид> - <описание параметра>
//                 <продолжение описания параметра>.
//
Процедура КопироватьВБуферОбменаТекстВВидеКода() Экспорт

	Текст = ПолучитьВыделенныйИлиВесьТекст();
	ЛиВыделенВесьТекст = Текст = ПолеТекста.ПолучитьТекст();
	Если Прав(Текст, 1) <> Символы.ПС Тогда
		Текст = Текст + Символы.ПС;
	КонецЕсли; 
	Текст = ирОбщий.ТекстВВыражениеВстроенногоЯзыкаЛкс(Текст);
	Если ЛиВыделенВесьТекст Тогда
		ИменованныеЗапросы = мПлатформа.СтруктураРезультатаПакетногоЗапроса(Текст);
		Текст = Текст + ";" + Символы.ПС;
		Для Каждого КлючИЗначение Из ИменованныеЗапросы Цикл
			Текст = Текст + "Индекс_" + КлючИЗначение.Ключ + " = " + XMLСтрока(КлючИЗначение.Значение) + ";" + Символы.ПС;
		КонецЦикла;
	Иначе
		Текст = "|" + ирОбщий.УдалитьВнешниеСкобкиВыраженияЛкс(Текст, """", Символы.ПС + "|""");
	КонецЕсли; 
	ирКлиент.ТекстВБуферОбменаОСЛкс(Текст);

КонецПроцедуры

Процедура Закомментировать(Знач Префикс = "") Экспорт

	#Если Сервер И Не Сервер Тогда
	    ПолеТекста = Новый ТекстовыйДокумент;
	#КонецЕсли
	ПолучитьГраницыВыделения();
	ПерваяСтрока = мНачальнаяСтрока;
	ПерваяКолонка = мНачальнаяКолонка;
	ПоследняяСтрока = мКонечнаяСтрока;
	ПоследняяКолонка = мКонечнаяКолонка;
	КоличествоСтрок = ирОбщий.СтрЧислоСтрокЛкс(ПолеТекста.ПолучитьТекст());  
	ВыделенныйФрагмент = "";
	ДлинаПоследнейСтроки = 0;
	Если ПоследняяКолонка = 1 Тогда 
		ПоследняяСтрока = ПоследняяСтрока - 1;
	КонецЕсли;
	Если ПерваяСтрока >= ПоследняяСтрока И ПоследняяКолонка = 1 Тогда 
		ПоследняяКолонка = Макс(1, СтрДлина(ПолеТекста.ПолучитьСтроку(ПерваяСтрока)));
		ПоследняяСтрока = ПерваяСтрока;
	КонецЕсли;
	Маркер = "//" + Префикс;
	Для НомерСтроки = 1 По КоличествоСтрок Цикл
		Фрагмент = ПолеТекста.ПолучитьСтроку(НомерСтроки);
		Если НомерСтроки >= ПерваяСтрока И НомерСтроки <= ПоследняяСтрока Тогда
			Если НомерСтроки = ПерваяСтрока Тогда 
				ВыделенныйФрагмент = ВыделенныйФрагмент + Маркер + Фрагмент;
			Иначе
				ВыделенныйФрагмент = ВыделенныйФрагмент + Символы.ПС + Маркер + Фрагмент;
			КонецЕсли;
			Если НомерСтроки = ПоследняяСтрока Тогда 
				ДлинаПоследнейСтроки = СтрДлина(Фрагмент) + 3;
			КонецЕсли;
		КонецЕсли;
	КонецЦикла;
	ЗаменитьФрагментТекстаВПоле(ПолеТекста, ВыделенныйФрагмент, ДлинаПоследнейСтроки, ПерваяСтрока, ПоследняяСтрока, ПоследняяКолонка);

КонецПроцедуры  

Процедура Раскомментировать(Знач Префикс = "") Экспорт

	#Если Сервер И Не Сервер Тогда
		ПолеТекста = Обработки.ирОболочкаПолеТекста.Создать();
	#КонецЕсли
	ПолучитьГраницыВыделения();
	ПерваяСтрока = мНачальнаяСтрока;
	ПерваяКолонка = мНачальнаяКолонка;
	ПоследняяСтрока = мКонечнаяСтрока;
	ПоследняяКолонка = мКонечнаяКолонка;
	КоличествоСтрок = ирОбщий.СтрЧислоСтрокЛкс(ПолеТекста.ПолучитьТекст());  
	ВыделенныйФрагмент = "";
	ДлинаПоследнейСтроки = ПоследняяКолонка;
	Если ПоследняяКолонка = 1 Тогда 
		ПоследняяСтрока = ПоследняяСтрока - 1;
	КонецЕсли;
	Если ПерваяСтрока >= ПоследняяСтрока И ПоследняяКолонка = 1 Тогда 
		ПоследняяКолонка = СтрДлина(ПолеТекста.ПолучитьСтроку(ПерваяСтрока));
		ПоследняяСтрока = ПерваяСтрока;
	КонецЕсли;
	Маркер = "//" + Префикс;
	Для НомерСтроки = 1 По КоличествоСтрок Цикл
		Фрагмент = ПолеТекста.ПолучитьСтроку(НомерСтроки);
		Если НомерСтроки >= ПерваяСтрока И НомерСтроки <= ПоследняяСтрока Тогда
			Если ирОбщий.СтрНачинаетсяСЛкс(СокрЛ(Фрагмент), Маркер) Тогда
				Позиция = Найти(Фрагмент, Маркер);
				Фрагмент = Лев(Фрагмент, Позиция - 1) + Сред(Фрагмент, Позиция + СтрДлина(Маркер));
			КонецЕсли;
			Если НомерСтроки = ПерваяСтрока Тогда 
				ВыделенныйФрагмент = ВыделенныйФрагмент + Фрагмент;
			Иначе
				ВыделенныйФрагмент = ВыделенныйФрагмент + Символы.ПС + Фрагмент;
			КонецЕсли;
			Если НомерСтроки = ПоследняяСтрока Тогда 
				ДлинаПоследнейСтроки = СтрДлина(Фрагмент) + 3;
			КонецЕсли;
		КонецЕсли;
	КонецЦикла;
	ЗаменитьФрагментТекстаВПоле(ПолеТекста, ВыделенныйФрагмент, ДлинаПоследнейСтроки, ПерваяСтрока, ПоследняяСтрока, ПоследняяКолонка);
	
КонецПроцедуры

Процедура УдалитьЛевыеТабуляции(ЧислоШагов = 1) Экспорт

	#Если Сервер И Не Сервер Тогда
		ПолеТекста = Обработки.ирОболочкаПолеТекста.Создать();
	#КонецЕсли
	КоличествоСтрок = ирОбщий.СтрЧислоСтрокЛкс(ПолеТекста.ПолучитьТекст());  
	ПерваяСтрока = 1;
	ПерваяКолонка = 1;
	ПоследняяСтрока = КоличествоСтрок;
	ПоследняяКолонка = 50;
	ВыделенныйФрагмент = "";
	ДлинаПоследнейСтроки = ПоследняяКолонка;
	Если ПоследняяКолонка = 1 Тогда 
		ПоследняяСтрока = ПоследняяСтрока - 1;
	КонецЕсли;
	Если ПерваяСтрока >= ПоследняяСтрока И ПоследняяКолонка = 1 Тогда 
		ПоследняяКолонка = СтрДлина(ПолеТекста.ПолучитьСтроку(ПерваяСтрока));
		ПоследняяСтрока = ПерваяСтрока;
	КонецЕсли;
	Маркер = Символы.Таб;
	УдаляемыйФрагмент = "";
	Для Счетчик = 1 По ЧислоШагов Цикл
		УдаляемыйФрагмент = УдаляемыйФрагмент + Маркер;
	КонецЦикла;
	Для НомерСтроки = 1 По КоличествоСтрок Цикл
		Фрагмент = ПолеТекста.ПолучитьСтроку(НомерСтроки);
		Если НомерСтроки >= ПерваяСтрока И НомерСтроки <= ПоследняяСтрока Тогда
			Если ирОбщий.СтрНачинаетсяСЛкс(Фрагмент, УдаляемыйФрагмент) Тогда
				Фрагмент = Сред(Фрагмент, СтрДлина(УдаляемыйФрагмент) + 1);
			КонецЕсли;
			Если НомерСтроки = ПерваяСтрока Тогда 
				ВыделенныйФрагмент = ВыделенныйФрагмент + Фрагмент;
			Иначе
				ВыделенныйФрагмент = ВыделенныйФрагмент + Символы.ПС + Фрагмент;
			КонецЕсли;
			Если НомерСтроки = ПоследняяСтрока Тогда 
				ДлинаПоследнейСтроки = СтрДлина(Фрагмент) + СтрДлина(УдаляемыйФрагмент) + 1;
			КонецЕсли;
		КонецЕсли;
	КонецЦикла;
	ЗаменитьФрагментТекстаВПоле(ПолеТекста, ВыделенныйФрагмент, ДлинаПоследнейСтроки, ПерваяСтрока, ПоследняяСтрока, ПоследняяКолонка);

КонецПроцедуры

Процедура ЗаменитьФрагментТекстаВПоле(Знач ПолеТекста, Знач ВыделенныйФрагмент, Знач ДлинаПоследнейСтроки, Знач ПерваяСтрока, Знач ПоследняяСтрока, Знач ПоследняяКолонка)
	
	#Если Сервер И Не Сервер Тогда
		ПолеТекста = Обработки.ирОболочкаПолеТекста.Создать();
	#КонецЕсли
	Если ПоследняяКолонка = 1 Тогда 
		ПоследняяСтрока = ПоследняяСтрока + 1;
		ДлинаПоследнейСтроки = 1;
		ВыделенныйФрагмент =  ВыделенныйФрагмент + Символы.ПС;
	КонецЕсли;
	ПолеТекста.УстановитьГраницыВыделения(ПерваяСтрока, 1, ПоследняяСтрока, ДлинаПоследнейСтроки);
	ЧислоПереносовСтрокНачальное = СтрЧислоСтрок(ВыделенныйТекст() + "й") - 1;
	Если ЧислоПереносовСтрокНачальное > ПоследняяСтрока - ПерваяСтрока Тогда
		// https://www.hostedredmine.com/issues/925662
		Для Счетчик = 1 По Мин(2, ДлинаПоследнейСтроки - 1) Цикл 
			ДлинаПоследнейСтрокиБезПереноса = ДлинаПоследнейСтроки - Счетчик;
			ПолеТекста.УстановитьГраницыВыделения(ПерваяСтрока, 1, ПоследняяСтрока, ДлинаПоследнейСтрокиБезПереноса);
			Если СтрЧислоСтрок(ВыделенныйТекст() + "й") - 1 < ЧислоПереносовСтрокНачальное Тогда
				Прервать;
			КонецЕсли; 
		КонецЦикла;
	КонецЕсли; 
	ВыделенныйТекст(ВыделенныйФрагмент);
	ПолеТекста.УстановитьГраницыВыделения(ПерваяСтрока, 1, ПоследняяСтрока, ДлинаПоследнейСтроки,, ФормаВладелец);
	УстановитьПризнакМодифицированностиФормы();

КонецПроцедуры 

Процедура ПрочитатьНачалоИКонецТекущейСтроки(Знач ОригинальнаяСтрока = "", Знач НомерПозиции = 0) Экспорт
	СброситьРезультатРазбораПозицииВТексте();   
	Если Не ЗначениеЗаполнено(ОригинальнаяСтрока) Тогда
		//ОригинальнаяСтрока = СокрП(ПолеТекста.ПолучитьСтроку(мКонечнаяСтрока));
		ОригинальнаяСтрока = ПолеТекста.ПолучитьСтроку(мКонечнаяСтрока);
	КонецЕсли;
	Если НомерПозиции = 0 Тогда
		НомерПозиции = мКонечнаяКолонка;
	КонецЕсли;
	Для Счетчик = 0 По НомерПозиции - СтрДлина(ОригинальнаяСтрока) - 2 Цикл
		ОригинальнаяСтрока = ОригинальнаяСтрока + " ";
	КонецЦикла;
	мТекущаяСтрокаНачало = Лев(ОригинальнаяСтрока, НомерПозиции - 1);
	мТекущаяСтрокаКонец = Сред(ОригинальнаяСтрока, НомерПозиции);
	мЭтоТекстовыйЛитерал = ирОбщий.ЛиВнутриТекстовогоЛитералаЛкс(мТекущаяСтрокаНачало);
КонецПроцедуры

Процедура РазобратьКонтекстСтроки(Знач ВзятьЛевоеОтРавенства = Ложь, выхЕстьТочкаСправа = Ложь, Знач КакВызовМетода = Ложь) Экспорт
	мВызовМетода = "";
	Если Ложь
		Или КакВызовМетода = Истина
		Или Истина
			И КакВызовМетода = Неопределено 
			И мЭтоТекстовыйЛитерал 
	Тогда
		ТекущийВызовМетода();
	КонецЕсли; 
	мЭтоОбъявлениеПсевдонима = Ложь;
	мРегВыражение.Global = Ложь;
		
	// Начало контекста 
	СтрокаШаблона = шПредИмяПрямое + "(";
	Если Ложь
		Или мЯзыкПрограммы = 1
		Или мЯзыкПрограммы = 2
	Тогда
		СтрокаШаблона = "(?:" + шРазделитель + "+(КАК|AS|(?:ПОМЕСТИТЬ|INTO(?:" + шРазделитель + "+TABLE)?))" + шРазделитель + "*)?" + СтрокаШаблона + шПрефиксПараметраНеобяз + "(?:" + шИмя + ")?";
	Иначе
		СтрокаШаблона = "()" + СтрокаШаблона + шПрефиксПараметраНеобяз + "(?:" + шИмя + ")?"; 
	КонецЕсли;
	СтрокаШаблона = СтрокаШаблона + шСкобки + "?" + "((\.(" + шИмя + ")" + шСкобки + "?)|" + шИндекс + ")*\.?)?"; 
	Если ВзятьЛевоеОтРавенства Тогда
		СтрокаШаблона = СтрокаШаблона + "(" + шРазделитель + "*(?==|<>)[=<> \t]*(?=[=<> \t])(?:" + шРазделитель + "*Новый(?=[ \t]))?" + СтрокаШаблона + ")";  // Такой сложный прием нужен для для обработки беспробельной операции, например "А=Б"
	КонецЕсли;
	СтрокаШаблона = СтрокаШаблона + "$";
	мРегВыражение.Pattern = СтрокаШаблона;
	Результат = мРегВыражение.НайтиВхождения(мТекущаяСтрокаНачало);
	Если Результат.Количество() > 0 Тогда
		ПервоеВхождение = Результат[0];
		Если ВзятьЛевоеОтРавенства Тогда
			мПозицияВТексте = мПозицияВТексте - СтрДлина(ПервоеВхождение.SubMatches(8)); // Опасно
		КонецЕсли;
		мНачалоКонтекста = "" + ПервоеВхождение.SubMatches(1);
		мЭтоОбъявлениеПсевдонима = ЗначениеЗаполнено(ПервоеВхождение.SubMatches(0)) И Найти(мНачалоКонтекста, ".") = 0;
	КонецЕсли;
	
	// Конец контекста
	мРегВыражение.Global = Ложь;
	Если Не ВзятьЛевоеОтРавенства Тогда
		мРегВыражение.Pattern = "([" + шБуква + "\d]*\(?)(\.)?";
		Результат = мРегВыражение.НайтиВхождения(мТекущаяСтрокаКонец);
		Если Результат.Количество() > 0 Тогда
			мКонецКонтекста = Результат[0].SubMatches(0);
			выхЕстьТочкаСправа = Результат[0].SubMatches(1) <> Неопределено;
		КонецЕсли;
	КонецЕсли; 

	СтрокаШаблона = шПрефиксПараметраНеобяз + "(?:" + шИмя + ")?"; 
	СтрокаШаблона = "(?:((?:" + шИмяСкобки + "?" + "(?:(?:\." + шИмяСкобки + "?)|" + шИндекс + ")*))\.)?(" + СтрокаШаблона + ")?$";
	// Родительский контекст по позиции курсора
	мРегВыражение.Pattern = СтрокаШаблона;
	Результат = мРегВыражение.НайтиВхождения(мНачалоКонтекста);
	Если Результат.Количество() > 0 Тогда
		ПервоеВхождение = Результат[0];
		Если ПервоеВхождение.SubMatches(0) <> Неопределено Тогда 
			мРодительскийКонтекст = ПервоеВхождение.SubMatches(0);
		КонецЕсли;
		Если ПервоеВхождение.SubMatches(4) <> Неопределено Тогда 
			мНачалоСлова = ПервоеВхождение.SubMatches(4);
		КонецЕсли;
	КонецЕсли;
	мТекущееСлово = мНачалоСлова + ирОбщий.ПервыйФрагментЛкс(мКонецКонтекста);
	мКонтекст = мНачалоКонтекста + мКонецКонтекста;
КонецПроцедуры

// Замена операторов внешнего перехода https://partners.v8.1c.ru/forum/t/1849050/m/1849050
Функция ЗаменитьОператорыВнешнегоПерехода(Знач Текст = Неопределено, выхТипыВнешнихПереходов, выхЗаглушкаВозврата = "", выхИмяПараметраТипаВыхода = "") Экспорт 
	
	Перем ИмяМетода;
	#Если Сервер И Не Сервер Тогда
		ПолеТекста = Обработки.ирОболочкаПолеТекста.Создать();
	#КонецЕсли
	УникальнаяСтрока = "1092383289";
	Если Не ЗначениеЗаполнено(выхЗаглушкаВозврата) Тогда
		выхЗаглушкаВозврата = "Возврат" + УникальнаяСтрока + "=0";
	КонецЕсли; 
	Если Не ЗначениеЗаполнено(выхИмяПараметраТипаВыхода) Тогда
		выхИмяПараметраТипаВыхода = "ТипВыхода";
	КонецЕсли; 
	Если Текст <> Неопределено Тогда
		ПолеТекста.УстановитьТекст(Текст);
	КонецЕсли; 
	Если выхТипыВнешнихПереходов = Неопределено Тогда
		выхТипыВнешнихПереходов = Новый Структура;
	КонецЕсли; 
	СтартоваяСтрока = 0;
	Пока Истина Цикл
		ИнформацияОбОшибке = ПроверитьТекстИВернутьОшибку(, СтартоваяСтрока,,, Истина);
		Если ИнформацияОбОшибке = Неопределено Тогда
			Прервать;
		КонецЕсли; 
		#Если Сервер И Не Сервер Тогда
			ИнформацияОбОшибке = ИнформацияОбОшибке();
		#КонецЕсли
		ОписаниеОшибки = ИнформацияОбОшибке.Описание;
		Если Найти(ОписаниеОшибки, "Оператор Прервать") > 0 Тогда
			ИмяОператора = "Прервать";
		ИначеЕсли Найти(ОписаниеОшибки, "Оператор Продолжить") > 0 Тогда
			ИмяОператора = "Продолжить";
		ИначеЕсли Найти(ОписаниеОшибки, "Оператор Возврат") > 0 Тогда
			ИмяОператора = "Возврат";
		//ИначеЕсли Найти(ОписаниеОшибки, "Оператор Перейти") > 0 Тогда
		//	ИмяОператора = "Перейти"; // TODO
		Иначе
			Прервать;
		КонецЕсли; 
		КоординатыОшибки = КоординатыОшибки(ИнформацияОбОшибке, СтартоваяСтрока);
		выхТипыВнешнихПереходов.Вставить(ИмяОператора);
		
		// Выделяем вхождение имени оператора в ПолеТекста
		ПолеТекста.УстановитьГраницыВыделения(1, 1, КоординатыОшибки.НомерСтроки, КоординатыОшибки.НомерКолонки);
		ТекстовыйДокумент = Новый ТекстовыйДокумент;
		ТекстовыйДокумент.УстановитьТекст(СокрП(ВыделенныйТекст()));
		КоличествоСтрок = ТекстовыйДокумент.КоличествоСтрок();
		ДлинаПоследнейСтроки = СтрДлина(ТекстовыйДокумент.ПолучитьСтроку(КоличествоСтрок) + 1);
		ПолеТекста.УстановитьГраницыВыделения(Макс(1, КоличествоСтрок), ДлинаПоследнейСтроки - СтрДлина(ИмяОператора), Макс(1, КоличествоСтрок), ДлинаПоследнейСтроки);
		
		ВыделенныйТекст(выхИмяПараметраТипаВыхода + " = """ + ИмяОператора + """; " + выхЗаглушкаВозврата);
		Если ИмяОператора = "Возврат" Тогда
			ИнформацияОбОшибке = ПроверитьТекстИВернутьОшибку(, СтартоваяСтрока,,, Истина);
			Если ИнформацияОбОшибке <> Неопределено Тогда
				#Если Сервер И Не Сервер Тогда
					ИнформацияОбОшибке = ИнформацияОбОшибке();
				#КонецЕсли
				ОписаниеОшибки = ИнформацияОбОшибке.Описание;
				КоординатыОшибкиПосле = КоординатыОшибки(ИнформацияОбОшибке, СтартоваяСтрока);
				Если КоординатыОшибкиПосле.НомерСтроки = КоординатыОшибки.НомерСтроки Тогда
					ВыделенныйТекст("=");
				КонецЕсли; 
			КонецЕсли; 
		КонецЕсли; 
	КонецЦикла;
	Текст = ПолеТекста.ПолучитьТекст();
	Возврат Текст;

КонецФункции

Функция КоординатыОшибки(Знач ИнформацияОбОшибке, Знач СтартоваяСтрока = 0) Экспорт 
	
	КоординатыОшибки = Новый Структура("НомерСтроки, НомерКолонки");
	мРегВыражение.Pattern = "{[^\(]*\(([^\)]+)\)}";
	ТекстКоординат = мРегВыражение.НайтиВхождения(ИнформацияОбОшибке.Описание)[0].SubMatches(0);  
	Фрагменты = ирОбщий.СтрРазделитьЛкс(ТекстКоординат, ",", Истина);
	КоординатыОшибки.НомерСтроки = Число(Фрагменты[0]) + СтартоваяСтрока;
	КоординатыОшибки.НомерКолонки = Число(Фрагменты[1]);
	Возврат КоординатыОшибки;

КонецФункции

Процедура ВыделитьТекущееСлово() Экспорт 

	#Если Сервер И Не Сервер Тогда
		ПолеТекста = Обработки.ирОболочкаПолеТекста.Создать();
	#КонецЕсли
	ТекущееОбъектноеВыражение();
	мНачальнаяКолонка = мКонечнаяКолонка - СтрДлина(мНачалоКонтекста);
	Если Не ПустаяСтрока(мРодительскийКонтекст) Тогда
		мНачальнаяКолонка = мНачальнаяКолонка + СтрДлина(мРодительскийКонтекст) + 1;
	КонецЕсли;
	мКонечнаяКолонка = мКонечнаяКолонка + СтрДлина(мКонецКонтекста);
	Если Прав(мКонецКонтекста, 1) = "(" Тогда
		мКонечнаяКолонка = мКонечнаяКолонка - 1;
	КонецЕсли;
	ПолеТекста.УстановитьГраницыВыделения(мНачальнаяСтрока, мНачальнаяКолонка, мКонечнаяСтрока, мКонечнаяКолонка,, ФормаВладелец);

КонецПроцедуры  

// Функция - Переименовать слово
// 
// Возвращаемое значение:
//   Булево - Истина если переименование выполнено.
//
Функция ПереименоватьСлово(Знач РазрешитьОткрыватьОкна = Истина) Экспорт 

	Форма = ПолучитьФорму("ПереименоватьСлово");
	Форма.РазрешитьОткрыватьОкна = РазрешитьОткрыватьОкна;
	РезультатФормы = Форма.ОткрытьМодально();
	Возврат РезультатФормы;

КонецФункции

// Функция - Выделить метод
//
// Параметры:
//  Параметры			 - см. Обработка.ирКонсольКода.Форма.Форма.Параметры - 
//  ИмяВременногоМодуля	 - 	 - 
// 
// Возвращаемое значение:
//   - 
//
Функция ВыделитьМетод(Знач Параметры = Неопределено, Знач ИмяВременногоМодуля = "") Экспорт 
	Перем НачСтрока, НачКолонка, КонСтрока, КонКолонка;

	Если ирОбщий.ПроверитьПлатформаНеWindowsЛкс(,, Истина) Тогда 
		Возврат Ложь;
	КонецЕсли; 
	#Если Сервер И Не Сервер Тогда
		мПлатформа = Обработки.ирПлатформа.Создать();
		ПолеТекста = Обработки.ирОболочкаПолеТекста.Создать();
	#КонецЕсли
	мПлатформа.ИнициацияОписанияМетодовИСвойств();
	КончитьОбработкуКоманды();
	РазобратьТекущийКонтекст(,, Истина);  
	АнализаторКода = ирОбщий.НовыйАнализаторКодаЛкс();
	#Если Сервер И Не Сервер Тогда
		АнализаторКода = Обработки.ирКлсПолеТекстаПрограммы.Создать();
		ПараметрыВходаАлгоритма = Новый Структура;
	#КонецЕсли
	АнализаторКода.ИнициироватьНеинтерактивно();
	АнализаторКода.мФлагиКомпиляции = мФлагиКомпиляции;
	АнализаторКода.ЭтоМодуль = Истина;
	НомераПервойСтрокиТела = 1;
	АнализаторКода.УстановитьТекст(ТелоМетода(мМетодМодуля, НомераПервойСтрокиТела));
	//НевидимоеПолеТекста.мМодульМетаданных = мМодульМетаданных;
	СмещениеНомеровСтрок = НомераПервойСтрокиТела - 1;
	Если Не ЗначениеЗаполнено(ВыделенныйТекст()) Тогда
		УстановитьГраницыВыделения(мНомерПервойСтрокиТелаМетода, 1, мНомерПоследнейСтрокиТелаМетода + 1, 1);
	КонецЕсли;
	Если Параметры = Неопределено Тогда
		Параметры = ЭтотОбъект.Параметры;
	КонецЕсли;
	ПолеТекста.ПолучитьГраницыВыделения(НачСтрока, НачКолонка, КонСтрока, КонКолонка);
	Если КонСтрока - СмещениеНомеровСтрок < 1 Или НачСтрока - СмещениеНомеровСтрок < 1 Тогда
		Возврат Ложь;
	КонецЕсли;
	АнализаторКода.ПолеТекста.УстановитьГраницыВыделения(НачСтрока - СмещениеНомеровСтрок, НачКолонка, КонСтрока - СмещениеНомеровСтрок, КонКолонка);
	ТекстНовогоМетода = АнализаторКода.ПолеТекста.ВыделенныйТекст();
	Если Не ЗначениеЗаполнено(ТекстНовогоМетода) Тогда
		Возврат Ложь;
	КонецЕсли;
	ОчиститьСообщения();
	ТекстСмещения = ирОбщий.ПервыеНепечатныеСимволыПервойНепустойСтрокиЛкс(ТекстНовогоМетода);
	//ФормаВладелец.Модифицированность = Истина;
	АнализаторКода.ПолеТекста.УстановитьГраницыВыделения(1, 1, НачСтрока - СмещениеНомеровСтрок, НачКолонка);
	ТекстДо = АнализаторКода.ПолеТекста.ВыделенныйТекст();
	АнализаторКода.ПолеТекста.УстановитьГраницыВыделения(КонСтрока - СмещениеНомеровСтрок, КонКолонка, Макс(1, АнализаторКода.ПолеТекста.КоличествоСтрок()), 300);
	ТекстПосле = АнализаторКода.ПолеТекста.ВыделенныйТекст();
	АнализаторКода.ПолеТекста.УстановитьГраницыВыделения(НачСтрока - СмещениеНомеровСтрок, НачКолонка, КонСтрока - СмещениеНомеровСтрок, КонКолонка);
	ФормаНовогоМетода = АнализаторКода.ПолучитьФорму("ВыделениеМетода", ФормаВладелец);
	ЛиКорректныйФрагмент = Истина; 
	ЗаглушкаВозврата = "";
	ИмяПараметраТипаВыхода = "";
	ИмяПеременнойЗаглушки = "Пустышка845234571";
	Разделитель = Символы.ПС + "//Разделитель" + "87г9234" + Символы.ПС;
	ТекстДоИПосле = АнализаторКода.ЗаменитьОператорыВнешнегоПерехода(ТекстДо + Разделитель + ТекстПосле, , ЗаглушкаВозврата, ИмяПараметраТипаВыхода);
	Фрагменты = ирОбщий.СтрРазделитьЛкс(ТекстДоИПосле, Разделитель);
	ТекстДо = Фрагменты[0];
	ТекстПосле = Фрагменты[1];
	ПараметрыМетодаМодуля = мПлатформа.ПараметрыМетодаМодуля(мМетодМодуля);
	Если ПараметрыМетодаМодуля <> Неопределено Тогда
		ВыходныеПараметрыМатеринскогоМетода = ирОбщий.ВыгрузитьСвойствоЛкс(ПараметрыМетодаМодуля,, Новый Структура("Знач", Ложь));
		ТекстПосле = ТекстПосле + Символы.ПС + ирОбщий.СтрСоединитьЛкс(ВыходныеПараметрыМатеринскогоМетода, "",,, ";_=%1 ");
		ВходныеПараметрыМатеринскогоМетода = ирОбщий.ВыгрузитьСвойствоЛкс(ПараметрыМетодаМодуля);
		ТекстДо = ирОбщий.СтрСоединитьЛкс(ВходныеПараметрыМатеринскогоМетода, "",,, "; %1=0 ;") + Символы.ПС + ТекстДо;
	КонецЕсли;
	
	СтруктураПараметровКода = Новый Структура; 
	МетаОбщиеМодули = Метаданные.ОбщиеМодули;
	ТипыВнешнихПереходов = Новый Структура;
	ТекстНовогоМетода = АнализаторКода.ЗаменитьОператорыВнешнегоПерехода(ТекстНовогоМетода, ТипыВнешнихПереходов, ЗаглушкаВозврата, ИмяПараметраТипаВыхода);
	Если ТипыВнешнихПереходов.Количество() > 0 Тогда
		СтрокаПараметра = ФормаНовогоМетода.ТаблицаПараметров.Добавить();
		СтрокаПараметра.Имя = ИмяПараметраТипаВыхода;
		ирОбщий.ОбновитьКопиюСвойстваВНижнемРегистреЛкс(СтрокаПараметра);
		СтрокаПараметра.Вход = Ложь;
		СтрокаПараметра.Выход = Истина;
		СтрокаПараметра.ТипЗначения = "Строка";
		СтрокаПараметра.Комментарий = "Служебный параметр для перехода после вызова метода";
	КонецЕсли;
	
	ПараметрыИзАлгоритма(ТекстДо + ТекстНовогоМетода + ТекстПосле, АнализаторКода, ЛиКорректныйФрагмент,, Истина);
	Если Не ЛиКорректныйФрагмент Тогда
		Возврат "Ошибка";
	КонецЕсли; 
	
	// Добавим переменные, которые не определены в выделенном фрагменте текста, как входные параметры
	ПараметрыВходаАлгоритма = ПараметрыИзАлгоритма(ТекстНовогоМетода, АнализаторКода, ЛиКорректныйФрагмент,,, Ложь);
	ЗаглушкаТекстаМетода = "";  
	ПоследнийСимволДо = Прав(СокрП(ТекстДо), 1); // Для ускорения
	ЭтоВыражение = Ложь
		Или Не ЛиКорректныйФрагмент 
		Или мНомерПараметра > 0 
		Или ПоследнийСимволДо = "="
		Или ПоследнийСимволДо = "+";
	Если Не ЭтоВыражение Тогда
		ТекстПроверкиВыражения = ТекстДо + Символы.ПС + "Если 1=1 Тогда" + Символы.ПС + ТекстНовогоМетода + Символы.ПС + "КонецЕсли;" + Символы.ПС + ТекстПосле;
		ПараметрыИзАлгоритма(ТекстПроверкиВыражения, АнализаторКода, ЛиКорректныйФрагмент);
	КонецЕсли; 
	Если Не ЛиКорректныйФрагмент Тогда
		// Выделено выражение
		ЭтоВыражение = Истина;
		ЗаглушкаТекстаМетода = "0";
		ПараметрыВходаАлгоритма = ПараметрыИзАлгоритма("ми7ва7в9вц3ая = " + ТекстНовогоМетода, АнализаторКода, ЛиКорректныйФрагмент);
		Если Не ЛиКорректныйФрагмент Тогда
			ирОбщий.СообщитьЛкс("Выделенный фрагмент не является набором целых инструкций или выражением");
			Возврат "Ошибка";
		КонецЕсли; 
	КонецЕсли; 
	АнализаторКода.УстановитьТекст(ТекстДо);
	ФормаНовогоМетода.ТекстСмещения = ТекстСмещения;
	Для Каждого КлючИЗначение Из ПараметрыВходаАлгоритма Цикл
		СтрокаПараметра = ФормаНовогоМетода.ТаблицаПараметров.Добавить();
		СтрокаПараметра.Имя = КлючИЗначение.Ключ;
		ирОбщий.ОбновитьКопиюСвойстваВНижнемРегистреЛкс(СтрокаПараметра);
		СтрокаПараметра.Вход = Истина; 
		Если ЛиПервоеПрисвоениеСамозависимо(ТекстПосле, СтрокаПараметра.Имя) Тогда
			СтрокаПараметра.Выход = Истина;
		КонецЕсли;

		// TODO сделать более универсальное экранирование конструктора "Новый <ИмяПеременной>"
		Пока АнализаторКода.НайтиПоказатьСловоВТексте("Новый " + КлючИЗначение.Ключ) Цикл
			АнализаторКода.ПолеТекста.ВыделенныйТекст(ИмяПеременнойЗаглушки);
		КонецЦикла;
		Пока АнализаторКода.НайтиПоказатьСловоВТексте(КлючИЗначение.Ключ) Цикл
			АнализаторКода.ПолеТекста.ВыделенныйТекст(ИмяПеременнойЗаглушки);
		КонецЦикла;
	КонецЦикла;
	ТекстДоПереименованный = АнализаторКода.ПолеТекста.ПолучитьТекст();
	
	// Добавим внутренние переменные, чтобы пользователь мог включить их передачу на выход
	АнализаторКода.УстановитьТекст(ТекстНовогоМетода);
	АнализаторКода.РазобратьТекущийКонтекст();
	АнализаторКода.ЗаполнитьЛокальныеСвойстваИМетодыПоТексту(,,,, Истина,,, Истина);
	ЛокальныеПеременныеНовогоМетода = АнализаторКода.ТаблицаСлов.Выгрузить(Новый Структура("ТипСлова, Определение", "Свойство", "Статистический"));
	АнализаторКода.УстановитьТекст(ТекстДо);
	АнализаторКода.РазобратьТекущийКонтекст();
	АнализаторКода.ЗаполнитьЛокальныеСвойстваИМетодыПоТексту(,,,, Истина,,, Истина);
	ЛокальныеПеременныеДо = АнализаторКода.ТаблицаСлов.Выгрузить(Новый Структура("ТипСлова, Определение", "Свойство", "Статистический"));
	АнализаторКода.УстановитьТекст(ТекстПосле);
	АнализаторКода.РазобратьТекущийКонтекст();
	АнализаторКода.ЗаполнитьЛокальныеСвойстваИМетодыПоТексту(,,,, Истина,,, Истина);
	ЛокальныеПеременныеПосле = АнализаторКода.ТаблицаСлов.Выгрузить(Новый Структура("ТипСлова, Определение", "Свойство", "Статистический"));
	Для Каждого СтрокаПеременной Из ЛокальныеПеременныеНовогоМетода Цикл
		Если Ложь
			Или мФлагиКомпиляции.Сервер И МетаОбщиеМодули.Найти(СтрокаПеременной.НСлово) <> Неопределено
			Или ирОбщий.СтрокиРавныЛкс(СтрокаПеременной.НСлово, ирОбщий.ПервыйФрагментЛкс(ЗаглушкаВозврата, "=", Ложь))
			Или ирОбщий.СтрокиРавныЛкс(СтрокаПеременной.НСлово, ИмяПараметраТипаВыхода)
		Тогда
			Продолжить; 
		КонецЕсли; 
		СтрокаПараметра = ФормаНовогоМетода.ТаблицаПараметров.Найти(СтрокаПеременной.НСлово, "НИмя");
		Если СтрокаПараметра = Неопределено Тогда
			СтрокаПараметра = ФормаНовогоМетода.ТаблицаПараметров.Добавить();
			СтрокаПараметра.Имя = СтрокаПеременной.Слово;
			ирОбщий.ОбновитьКопиюСвойстваВНижнемРегистреЛкс(СтрокаПараметра);
			Если ЛокальныеПеременныеДо.Найти(СтрокаПеременной.НСлово, "НСлово") <> Неопределено Тогда 
				Если ЛиПервоеПрисвоениеСамозависимо(ТекстНовогоМетода, СтрокаПеременной.Слово) Тогда
					СтрокаПараметра.Вход = Истина;
				КонецЕсли;
			КонецЕсли;
		КонецЕсли;
		СтрокаПараметра.Выход = ЛокальныеПеременныеПосле.Найти(СтрокаПеременной.НСлово, "НСлово") <> Неопределено;
	КонецЦикла;
	
	// Добавим переменные, которые не определены начиная с первой выделеной строки и до конца текста, как свозные параметры
	ПараметрыСквозныеАлгоритма = ПараметрыИзАлгоритма(ТекстДоПереименованный + ТекстНовогоМетода + ТекстПосле, АнализаторКода, ЛиКорректныйФрагмент, ИмяПеременнойЗаглушки); 
	Если Не ЛиКорректныйФрагмент Тогда
		Возврат "Ошибка";
	КонецЕсли;  
	#Если Сервер И Не Сервер Тогда
		ПараметрыСквозныеАлгоритма = Новый Структура;
	#КонецЕсли
	Для Каждого КлючИЗначение Из ПараметрыСквозныеАлгоритма Цикл
		СтрокаПараметра = ФормаНовогоМетода.ТаблицаПараметров.Найти(НРег(КлючИЗначение.Ключ), "НИмя");
		Если СтрокаПараметра = Неопределено Тогда
			СтрокаПараметра = ФормаНовогоМетода.ТаблицаПараметров.Добавить();
			СтрокаПараметра.Имя = КлючИЗначение.Ключ;
			ирОбщий.ОбновитьКопиюСвойстваВНижнемРегистреЛкс(СтрокаПараметра);
		КонецЕсли; 
		СтрокаПараметра.Вход = Истина;
		//СтрокаПараметра.Выход = Истина;
	КонецЦикла;
	
	// Добавим переменные, которые не определены в следующем тексте, как параметры выхода
	ПараметрыВыходаАлгоритма = ПараметрыИзАлгоритма(ТекстДоПереименованный + ЗаглушкаТекстаМетода + ТекстПосле, АнализаторКода,, ИмяПеременнойЗаглушки);
	#Если Сервер И Не Сервер Тогда
		ПараметрыВыходаАлгоритма = Новый Структура;
	#КонецЕсли
	ТаблицаЛокальногоКонтекста = мПлатформа.ТаблицаСловИзСтруктурыТипа(СтруктураТипаМодуля(),,,,,, "Свойство", мФлагиКомпиляции,,,,, Истина,, БазовоеРасширениеКонфигурации());
	ирОбщий.ОбновитьКопиюКолонкиВНижнемРегистреЛкс(ТаблицаЛокальногоКонтекста, "Слово"); 
	//! ТаблицаЛокальногоКонтекста.Колонки.Добавить("НСлово")
	ИмяРезультатаВыражения = ирОбщий.АвтоУникальноеИмяВКоллекцииЛкс(ТаблицаЛокальногоКонтекста, "Результат", "Слово");
	Если ЭтоВыражение Тогда
		ПараметрыВыходаАлгоритма.Вставить(ИмяРезультатаВыражения);
	КонецЕсли; 
	Для Каждого КлючИЗначение Из ПараметрыВыходаАлгоритма Цикл
		СтрокаПараметра = ФормаНовогоМетода.ТаблицаПараметров.Найти(НРег(КлючИЗначение.Ключ), "НИмя");
		Если СтрокаПараметра = Неопределено Тогда
			СтрокаПараметра = ФормаНовогоМетода.ТаблицаПараметров.Добавить();
			СтрокаПараметра.Имя = КлючИЗначение.Ключ;
			ирОбщий.ОбновитьКопиюСвойстваВНижнемРегистреЛкс(СтрокаПараметра);
		КонецЕсли; 
		СтрокаПараметра.Выход = Истина;
		СтрокаПараметра.ВыходОбязательно = Истина;
	КонецЦикла; 

	// Удалим переменные, которые не определены в оригнальном тексте
	ПараметрыВыходаЛожные = ПараметрыИзАлгоритма(ТекстДо + ТекстНовогоМетода + ТекстПосле, АнализаторКода,,,, Ложь);
	#Если Сервер И Не Сервер Тогда
		ПараметрыВыходаЛожные = Новый Структура;
	#КонецЕсли
	Для Каждого КлючИЗначение Из ПараметрыВыходаЛожные Цикл
		Если ПараметрыВходаАлгоритма.Свойство(КлючИЗначение.Ключ) Тогда
			Продолжить;
		КонецЕсли; 
		СтрокаПараметра = ФормаНовогоМетода.ТаблицаПараметров.Найти(НРег(КлючИЗначение.Ключ), "НИмя");
		Если СтрокаПараметра <> Неопределено Тогда
			ФормаНовогоМетода.ТаблицаПараметров.Удалить(СтрокаПараметра);
		КонецЕсли; 
	КонецЦикла;
	
	Для Каждого СтрокаПараметра Из ФормаНовогоМетода.ТаблицаПараметров Цикл
		СтрокаПараметра.Обязательный = СтрокаПараметра.Вход; 
		СтрокаПараметра.Позиция = 200;
		
		// Параметры исходного метода
		ПараметрМетода = Неопределено;
		//ПараметрыМетодаМодуля = мПлатформа.ПараметрыМетодаМодуля(мМетодМодуля);
		Если ПараметрыМетодаМодуля <> Неопределено Тогда
			ПараметрМетода = ПараметрыМетодаМодуля.Найти(НРег(СтрокаПараметра.Имя), "НИмя");
			Если ПараметрМетода <> Неопределено Тогда
				СтрокаПараметра.Комментарий = ПараметрМетода.Описание;
				СтрокаПараметра.Позиция = ПараметрыМетодаМодуля.Индекс(ПараметрМетода);
				СтрокаПараметра.ТипЗначения = ПараметрМетода.ТипЗначения;
				Если ЗначениеЗаполнено(ПараметрМетода.Значение) Тогда
					СтрокаПараметра.Значение = Вычислить(ПараметрМетода.Значение);
				КонецЕсли;
			КонецЕсли;
		КонецЕсли;
		//Если Не СтрокаПараметра.Вход Тогда 
			Вхождения = ирОбщий.НайтиРегВыражениеЛкс(ТекстПосле, шПредИмяПрямое + СтрокаПараметра.Имя + "[^" + шБуква + "\d](из\s+)?",, Ложь);
			Если Вхождения.Количество() > 0 И ЗначениеЗаполнено(Вхождения[0].Подгруппы[0]) Тогда
				// Первое использование после является созданием итератора
				СтрокаПараметра.Выход = Ложь;
			КонецЕсли;
		//КонецЕсли;
		
		Если ПараметрМетода = Неопределено Тогда
			СтрокаПараметра.СвойствоМодуля = ТаблицаЛокальногоКонтекста.Найти(НРег(СтрокаПараметра.НИмя), "НСлово") <> Неопределено; 
			Если СтрокаПараметра.СвойствоМодуля Тогда
				СтрокаПараметра.Вход = Ложь;
				СтрокаПараметра.Выход = Ложь;
				СтрокаПараметра.ВыходОбязательно = Ложь;
			КонецЕсли;
			// Динамический локальный контекст (например консоль кода)
			СтрокаЭтогоАлгоритмаПараметры = Параметры.Найти(НРег(СтрокаПараметра.Имя), "НИмя");
			Если Истина
				И СтрокаЭтогоАлгоритмаПараметры <> Неопределено 
				И (Ложь
					Или мМетодМодуля = Неопределено
					Или СтрокаЭтогоАлгоритмаПараметры.Модуль)
			Тогда
				СтрокаПараметра.Комментарий = СтрокаЭтогоАлгоритмаПараметры.Комментарий;
				СтрокаПараметра.Позиция = СтрокаЭтогоАлгоритмаПараметры.Позиция + 100;
				СтрокаПараметра.ТипЗначения = СтрокаЭтогоАлгоритмаПараметры.ИмяТипаЗначения;
				СтрокаПараметра.СвойствоМодуля = СтрокаЭтогоАлгоритмаПараметры.Модуль;
				ТипЗначения = ТипЗнч(СтрокаЭтогоАлгоритмаПараметры.Значение);
				Если Ложь
					Или ТипЗначения = Тип("Строка") И СтрДлина(СтрокаЭтогоАлгоритмаПараметры.Значение) < 100
					Или ТипЗначения = Тип("Число")
					Или ТипЗначения = Тип("Булево")
					Или ТипЗначения = Тип("Неопределено")
					Или ТипЗначения = Тип("Null")
				Тогда
					СтрокаПараметра.Значение = СтрокаЭтогоАлгоритмаПараметры.Значение;
				КонецЕсли; 
				Если СтрокаПараметра.Значение <> Неопределено Тогда
					СтрокаПараметра.Обязательный = Ложь;
				КонецЕсли; 
			КонецЕсли;
		КонецЕсли;    
		
		Если Истина
			И Не ЗначениеЗаполнено(СтрокаПараметра.ТипЗначения) 
			И (Ложь
				Или СтрокаПараметра.Вход
				Или СтрокаПараметра.Выход
				Или ФормаНовогоМетода.ТаблицаПараметров.Количество() < 10)
		Тогда
			// Очень долго при большом числе параметров
			ТаблицаТипов = ВычислитьТипЗначенияВыражения(СтрокаПараметра.Имя, ТекстДо + ТекстНовогоМетода);
			СтрокаПараметра.ТипЗначения = мПлатформа.ПредставлениеМассиваСтруктурТипов(ТаблицаТипов);
		КонецЕсли; 
	КонецЦикла;
	//ЗаменаЗаглушки = Символы.ПС + ТекстСмещения + "Возврат";
	Если ЭтоВыражение Тогда
		ТекстНовогоМетода = Символы.Таб + ИмяРезультатаВыражения + " = " + ТекстНовогоМетода + "
		|;";   
	ИначеЕсли СтрЧислоСтрок(СокрЛП(ТекстНовогоМетода)) = 1 Тогда 
		Присвоения = ирОбщий.НайтиРегВыражениеЛкс(ТекстНовогоМетода, "^\s*(" + шИмя + ")\s*=");
		Если Присвоения.Количество() > 0 Тогда
			ИмяНовогоМетода = Присвоения[0].Подгруппы[0];
		КонецЕсли;
	КонецЕсли; 
	ЗаменаЗаглушкиВозврата = "Возврат";
	ТекстНовогоМетода = СтрЗаменить(ТекстНовогоМетода, ЗаглушкаВозврата + "=", ЗаменаЗаглушкиВозврата);
	ЗаменаЗаглушкиВозврата = ЗаменаЗаглушкиВозврата + " Неопределено";
	ТекстНовогоМетода = СтрЗаменить(ТекстНовогоМетода, ЗаглушкаВозврата, ЗаменаЗаглушкиВозврата);
	Если мМетодМодуля <> Неопределено Тогда
		Если Не ЗначениеЗаполнено(ИмяНовогоМетода) Тогда
			ИмяНовогоМетода = ирОбщий.АвтоУникальноеИмяВКоллекцииЛкс(мМодульМетаданных.Методы, мМетодМодуля.Имя);
		КонецЕсли;
		ФормаНовогоМетода.ЛиАсинх = мМетодМодуля.ЛиАсинх;
		ФормаНовогоМетода.ДирективаКомлиляции = Сред(мМетодМодуля.Аннотация, 2);
	КонецЕсли;
	Если Не ЗначениеЗаполнено(ИмяНовогоМетода) Тогда
		ИмяНовогоМетода = ИмяВременногоМодуля;
	КонецЕсли;
	ФормаНовогоМетода.Имя = ИмяНовогоМетода;
	ФормаНовогоМетода.ЭлементыФормы.ПолеТела.УстановитьТекст(ТекстНовогоМетода);
	ФормаНовогоМетода.РежимВыбора = Истина;
	ФормаНовогоМетода.ТекстДо = ТекстДо;
	ФормаНовогоМетода.ТекстПосле = ТекстПосле;
	ФормаНовогоМетода.ЭтоВыражение = ЭтоВыражение;
	ФормаНовогоМетода.ИмяПараметраТипаВыхода = ИмяПараметраТипаВыхода;
	ФормаНовогоМетода.ТипыВнешнихПереходов = ТипыВнешнихПереходов;
	РезультатФормы = ФормаНовогоМетода.ОткрытьМодально();
	Если РезультатФормы = Неопределено Тогда
		Возврат Ложь;
	КонецЕсли;
	Если Ложь
		Или ФормаВладелец <> Неопределено И ФормаВладелец.ТолькоПросмотр 
		Или ПолеТекста.ТолькоПросмотр() 
	Тогда
		ирКлиент.ОткрытьТекстЛкс(ФормаНовогоМетода.ПолноеОпределение, "Метод " + ФормаНовогоМетода.Имя, "ВстроенныйЯзык");
		ирОбщий.СообщитьЛкс("Поле текста недоступно для изменения.");
		Возврат Ложь;
	КонецЕсли;
	СтруктураВыделения = ПолеТекста.ВыделениеДвумерное();
	Если мМетодМодуля <> Неопределено Тогда
		ПолеТекста.ВставитьСтроку(мНомерПоследнейСтрокиТелаМетода + 2, Символы.ПС + ФормаНовогоМетода.ПолноеОпределение); 
	КонецЕсли;
	ПолеТекста.УстановитьВыделениеДвумерное(СтруктураВыделения);
	ПолучитьГраницыВыделения();
	ВыделенныйТекст(ФормаНовогоМетода.ТекстВставки);
	Если мМетодМодуля = Неопределено Тогда
		ПолеТекста.ВставитьСтроку(мНомерПервойСтрокиТелаМетода, ФормаНовогоМетода.ПолноеОпределение + Символы.ПС); 
	КонецЕсли;
	Если ФормаВладелец = Неопределено Тогда
		мЗаменяемыйДиапазон = Новый Структура("Начало, Конец");
		Если мМетодМодуля <> Неопределено Тогда
			ИндексМетода = мМодульМетаданных.Методы.Индекс(мМетодМодуля);
			мЗаменяемыйДиапазон.Начало = мМетодМодуля.ПозицияОпределения;
			мЗаменяемыйДиапазон.Конец = мМетодМодуля.ПозицияОпределения + мМетодМодуля.ДлинаОпределения; 
		Иначе 
			ИндексМетода = Неопределено;
			мЗаменяемыйДиапазон.Начало = мМодульМетаданных.ПозицияПрограммы;
			мЗаменяемыйДиапазон.Конец = СтрДлина(мОригинальныйТекст); 
		КонецЕсли;
		РазобратьТекущийКонтекст();
		Если ИндексМетода <> Неопределено Тогда
			Начало = мМодульМетаданных.Методы[ИндексМетода].ПозицияОпределения;  
			СтрокаМетода = мМодульМетаданных.Методы[ИндексМетода + 1];
			Конец = СтрокаМетода.ПозицияОпределения + СтрокаМетода.ДлинаОпределения;
			мЗамещающийФрагмент = Сред(мОригинальныйТекст, Начало, Конец - Начало);
		Иначе 
			мЗамещающийФрагмент = Символы.ПС + Сред(мОригинальныйТекст, мМодульМетаданных.Методы[мМодульМетаданных.Методы.Количество() - 1].ПозицияСОписанием);
		КонецЕсли;
		//ПолеТекста.УстановитьГраницыВыделения(ПозицияНачала, ПозицияКонца);
		Возврат ФормаНовогоМетода.ПолноеОпределение;
	КонецЕсли;
	Возврат Истина;

КонецФункции

// Проверка на самозависимое присвоение, например Ф = Ф + 1
// Параметры:
//    ТекстПрограммы - Строка - 
//    Переменная - Строка - 
// Возвращаемое значение:
//    Число - 
Функция ЛиПервоеПрисвоениеСамозависимо(Знач ТекстПрограммы, Знач Переменная) Экспорт
	ПервоеПрисвоение = ирОбщий.НайтиРегВыражениеЛкс(ТекстПрограммы, шПредИмяПрямое + Переменная + "\s*(?==)(?:(" + шПредИмяПрямое + Переменная + "(?!\())|[^;])*?" + шКонецИнструкции(),, Ложь);
	Результат = ПервоеПрисвоение.Количество() > 0 И ЗначениеЗаполнено(ПервоеПрисвоение[0].Подгруппы[0]);
	Возврат Результат;
КонецФункции

//.
// Возвращаемое значение:
//     - 
Функция шКонецИнструкции() Экспорт
	Возврат "(?:;|$|(?:" + мПлатформа.шПустоеНачалоСтроки + "(?:Иначе|ИначеЕсли|КонецЕсли|КонецЦикла|Исключение|КонецПопытки|КонецФункции|КонецПроцедуры)))";
КонецФункции

Функция СтруктураТипаМодуля()
	
	СтруктураТипаМодуля = мМодульМетаданных.СтруктураТипа;
	Если СтруктураТипаМодуля = Неопределено Тогда
		СтруктураТипаМодуля = мПлатформа.СтруктураТипаИзКонкретногоТипа(Тип("ОбщийМодуль"));
	КонецЕсли;
	Возврат СтруктураТипаМодуля;

КонецФункции

Функция ЗаменитьВозвратыНаПерейтиВТекстеМетода(Знач Текст = Неопределено, Знач ИмяПеременнойРезультата = "Результат", Знач ДобавлятьПереносыСтрок = Ложь, Знач ИмяМетки = "Конец", Знач ВставитьМетку = Ложь) Экспорт
	
	Если Текст = Неопределено Тогда
		Текст = ПолеТекста.ПолучитьТекст();
	КонецЕсли;
	РегВыражение = мРегВыражение;
	РегВыражение.Global = Истина;
	РегВыражение.MultiLine = Ложь;
	
	// Шаблон тут можно улучшить
	РегВыражение.Pattern = "((?:^|\n|\r)(?:\t| )*(?:" + шНачалоДок + "\s*)?)Возврат(?=[\t\n\r\( ])(\s*(?:" + шЛитералПрограммы + "|[^\n\r;])+)($|\n|\r|;)";
	Если ДобавлятьПереносыСтрок Тогда
		Разделитель = Символы.ПС + "$1";
	Иначе
		Разделитель = " ";
	КонецЕсли;
	ЗаменитьНа = "$1" + ИмяПеременнойРезультата + "=$2";
	Если ИмяМетки <> Неопределено Тогда
		ЗаменитьНа = ЗаменитьНа + ";" + Разделитель + "Перейти ~" + ИмяМетки;
	КонецЕсли;
	ЗаменитьНа = ЗаменитьНа + "$3";
	Текст = РегВыражение.Заменить(Текст, ЗаменитьНа);
	Если ИмяМетки <> Неопределено Тогда
		РегВыражение.Pattern = "((?:^|\n|\r)(?:\t| )*)Возврат(?:\t| )*($|\n|\r|;)";
		Текст = РегВыражение.Заменить(Текст, "$1Перейти ~" + ИмяМетки + "$2");
	КонецЕсли;
	Если ВставитьМетку Тогда
		Текст = Текст + "
		|;
		|~" + ИмяМетки + ":";
	КонецЕсли;
	Возврат Текст;
	
КонецФункции

Функция ПараметрыИзАлгоритма(Знач ТекстДляПроверки, Знач НевидимоеПолеПрограммы, выхКорректныйФрагмент = Истина, Знач ИгнорироватьПеременную = "", Знач ПоказыватьСтрокуОшибки = Ложь, Знач ВыводитьОшибку = Истина) Экспорт 
	
	#Если Сервер И Не Сервер Тогда
		НевидимоеПолеПрограммы = Обработки.ирКлсПолеТекстаПрограммы.Создать();
		мПлатформа = Обработки.ирПлатформа.Создать();
	#КонецЕсли
	СтруктураПараметровКода = Новый Структура;
	МетаОбщиеМодули = Метаданные.ОбщиеМодули;
	мСмещениеНомеровСтрок = 0; 
	ТекстДляПроверки = ЗаменитьВозвратыНаПерейтиВТекстеМетода(ТекстДляПроверки,,, "КонецСлужебный", Истина);
	ТекстДляПроверки = мПлатформа.ЗамаскироватьДирективыПрепроцессора(ТекстДляПроверки, Ложь);
	ТекстДляПроверки = УдалитьЖдатьВТекстеМетода(ТекстДляПроверки); 
	НевидимоеПолеПрограммы.УстановитьТекст(ТекстДляПроверки);
	Пока Истина Цикл
		ИнформацияОбОшибке = НевидимоеПолеПрограммы.ПроверитьТекстИВернутьОшибку(, мСмещениеНомеровСтрок, , , Истина);
		НеопределенныйМетод = мПлатформа.ИмяНеопределенногоМетодаИзИнформацииОбОшибке(ИнформацияОбОшибке);
		Если НеопределенныйМетод <> Неопределено Тогда
			КоординатыОшибки = НевидимоеПолеПрограммы.КоординатыОшибки(ИнформацияОбОшибке, мСмещениеНомеровСтрок);
			НачальнаяКолонка = КоординатыОшибки.НомерКолонки;
			НевидимоеПолеПрограммы.ПолеТекста.УстановитьГраницыВыделения(КоординатыОшибки.НомерСтроки, НачальнаяКолонка, КоординатыОшибки.НомерСтроки, НачальнаяКолонка);
			НевидимоеПолеПрограммы.ПолеТекста.ВыделенныйТекст("ирОбщий.");
			Продолжить;
		КонецЕсли; 
		НеопределеннаяПеременная = мПлатформа.ИмяНеопределеннойПеременнойИзИнформацииОбОшибке(ИнформацияОбОшибке);
		Если Не ЗначениеЗаполнено(НеопределеннаяПеременная) Тогда
			выхКорректныйФрагмент = ИнформацияОбОшибке = Неопределено;
			Если Не выхКорректныйФрагмент И ВыводитьОшибку Тогда
				// Сообщим ошибку
				Если ПоказыватьСтрокуОшибки Тогда 
					Если ФормаВладелец <> Неопределено Тогда
						ФормаВладелец.ТекущийЭлемент = ПолеТекста.ЭлементФормы;
					КонецЕсли;
					ирКлиент.ПоказатьОшибкуВТекстеПрограммыЛкс(ПолеТекста, мСмещениеНомеровСтрок,,,, ИнформацияОбОшибке);
				Иначе
					НевидимоеПолеПрограммы.ПроверитьПрограммныйКод();
				КонецЕсли; 
			КонецЕсли; 
			Прервать;
		КонецЕсли;
		Если мФлагиКомпиляции.Сервер И МетаОбщиеМодули.Найти(НеопределеннаяПеременная) <> Неопределено Тогда
			//
		Иначе
			Если Ложь
				Или Не ЗначениеЗаполнено(ИгнорироватьПеременную) 
				Или Не ирОбщий.СтрокиРавныЛкс(ИгнорироватьПеременную, НеопределеннаяПеременная) 
			Тогда
				СтруктураПараметровКода.Вставить(НеопределеннаяПеременная);
			КонецЕсли; 
		КонецЕсли; 
		НевидимоеПолеПрограммы.ПолеТекста.ВставитьСтроку(1, НеопределеннаяПеременная + "=0;");
		мСмещениеНомеровСтрок = мСмещениеНомеровСтрок + 1;
	КонецЦикла;
	Возврат СтруктураПараметровКода;

КонецФункции

Функция УдалитьЖдатьВТекстеМетода(Знач Текст, выхЕстьВхождения = Ложь) Экспорт
	
	мРегВыражение.Global = Истина;
	мРегВыражение.MultiLine = Ложь;
	мРегВыражение.Pattern = "((?:^|\n)[^\n\|\""]*)(Ждать)($|\s)";
	НовыйТекст = мРегВыражение.Заменить(Текст, "$1$3");
	выхЕстьВхождения = НовыйТекст <> Текст;
	Возврат НовыйТекст;
	
КонецФункции

Процедура ВыделитьТекущееОбъектноеВыражение() Экспорт 

	#Если Сервер И Не Сервер Тогда
		ПолеТекста = Обработки.ирОболочкаПолеТекста.Создать();
	#КонецЕсли
	ТекущееОбъектноеВыражение();
	мНачальнаяКолонка = мКонечнаяКолонка - СтрДлина(мНачалоКонтекста);
	мКонечнаяКолонка = мКонечнаяКолонка + СтрДлина(мКонецКонтекста);
	Если Прав(мКонецКонтекста, 1) = "(" Тогда
		мКонечнаяКолонка = мКонечнаяКолонка - 1;
	КонецЕсли;
	ПолеТекста.УстановитьГраницыВыделения(мНачальнаяСтрока, мНачальнаяКолонка, мКонечнаяСтрока, мКонечнаяКолонка,, ФормаВладелец);

КонецПроцедуры

// Получает путь к описанию заданного контекста.
//
// Параметры:
//  ПутьКСлову   - Строка;
//  *СтрокаОписания - СтрокаТаблицыЗначений - возвращаемая строка описания;
//  *ВключатьПутьКОписаниюТипаЗначения - Булево, *Неопределено - признак добавления в список выбора тип значения слова.
//
Функция НайтиПоказатьСправкуПоСлову(Знач ПутьКСлову, ВключатьПутьКОписаниюТипаЗначения = Ложь, выхФормаВыбора = Неопределено, РазрешитьАнализИмениТипа = Истина,
	ВладелецФормы = Неопределено) Экспорт

	#Если Сервер И Не Сервер Тогда
		мПлатформа = Обработки.ирПлатформа.Создать();
	#КонецЕсли
	ТаблицаТиповКонтекста = ВычислитьТипЗначенияВыражения(ПутьКСлову, " " + мТекстДляПоискаОпределения, мПредшествующийТекст, РазрешитьАнализИмениТипа, мЭтоКонструктор);
	Если ТаблицаТиповКонтекста.Количество() = 0 Тогда
		Возврат Неопределено;
	КонецЕсли;
	СтруктураТипаКонтекста = ТаблицаТиповКонтекста[0];
	Результат = НайтиПоказатьСправкуПоСтруктуреТипа(ПутьКСлову, СтруктураТипаКонтекста, ВключатьПутьКОписаниюТипаЗначения, выхФормаВыбора, ВладелецФормы, ТаблицаТиповКонтекста);
	Возврат Результат;

КонецФункции

Функция НайтиПоказатьСправкуПоСтруктуреТипа(Знач ПутьКСлову, Знач СтруктураТипа, ВключатьПутьКОписаниюТипаЗначения = Ложь, выхФормаВыбора = Неопределено, ВладелецФормы = Неопределено,
	Знач ТаблицаТиповКонтекста = Неопределено, Знач НомерПараметра = Неопределено) Экспорт 
	
	Если НомерПараметра = Неопределено Тогда
		НомерПараметра = мНомерПараметра;
	КонецЕсли;
	Если Истина
		И ТипЗнч(СтруктураТипа.СтрокаОписания) <> Тип("СтрокаТаблицыЗначений")
		И ТипЗнч(СтруктураТипа.Метаданные) = Тип("COMОбъект") 
	Тогда
		Если НомерПараметра > 0 Тогда
			Возврат Неопределено;
		КонецЕсли; 
		МетаданныеСлова = СтруктураТипа.Метаданные;
		ИмяТипа = мПлатформа.ПолноеИмяТипаCOMОбъекта(МетаданныеСлова);
		Попытка
			Пустышка = МетаданныеСлова.Path_;
		Исключение
			Пустышка = Неопределено;
		КонецПопытки;
		Слово = ирОбщий.ПоследнийФрагментЛкс(ПутьКСлову, ".", Ложь);
		Если Прав(ПутьКСлову, 1) = "(" Тогда
			Слово = СтрЗаменить(Слово, "(", "");
		КонецЕсли; 
		Если Пустышка <> Неопределено Тогда
			// WMI
			ИмяКлассаWMI = МетаданныеСлова.Path_.Class;
			Если ЗначениеЗаполнено(Слово) Тогда
				ОписаниеСлова = ирОбщий.ДокументацияСвойстваWMIЛкс(ИмяКлассаWMI, Слово);
				Если ЗначениеЗаполнено(ОписаниеСлова) Тогда
					ТекстовыйДокумент = Новый ТекстовыйДокумент;
					ТекстовыйДокумент.УстановитьТекст(ОписаниеСлова);
					ТекстовыйДокумент.Показать(ИмяКласса + "." + Слово);
					Возврат Истина;
				КонецЕсли; 
			КонецЕсли;
		Иначе
			ЗапуститьПриложение("http://google.com/search?q=" + ирОбщий.ПервыйФрагментЛкс(ИмяТипа, " ") + "+" + Слово);
			Возврат Истина;
		КонецЕсли; 
	Иначе
		Если ВладелецФормы <> Неопределено И СтруктураТипа.СтрокаОписания <> Неопределено Тогда
			ТаблицаВладелец = СтруктураТипа.СтрокаОписания.Владелец();
			#Если Сервер И Не Сервер Тогда
				ТаблицаВладелец = Новый ТаблицаЗначений;
			#КонецЕсли
			Если ТаблицаВладелец.Колонки.Найти("ЛиЭкспорт") <> Неопределено Тогда
				ФормаВызовМетода = ФормаВызовМетода();
				ФормаВызовМетода.ПараметрПостояннаяСтруктураТипа = СтруктураТипа;
				БылаОткрыта = ФормаВызовМетода.Открыта();
				Если ЛиДоступноОткрытиеСвободнойФормы() Тогда 
					ОткрытьПодсказкуПоВызовуМетодаПассивно(ФормаВызовМетода, Ложь);
					ФормаВызовМетода.Автообновление = Ложь;
					Если Не БылаОткрыта Тогда
						ирКлиент.Форма_АктивироватьОткрытьЛкс(ФормаВладелец);
					КонецЕсли; 
				Иначе
					ФормаВызовМетода.ОткрытьМодально();
				КонецЕсли;
				Возврат ФормаВызовМетода;
			КонецЕсли; 
		КонецЕсли; 
		Если СтруктураТипа.ТипЯзыка = "ИмяТипа" Тогда 
			ВключатьПутьКОписаниюТипаЗначения = Истина;
		КонецЕсли; 
		Слово = ирОбщий.ПоследнийФрагментЛкс(ПутьКСлову);
		// Возможные роли слова без учета вычисленного контекста
		ТаблицаСтруктурВозможныхТиповКонтекста = ирКлиент.НайтиВозможныеСтрокиОписанияСловаВСинтаксПомощникеЛкс(Слово, ЯзыкПрограммы);
		Если ТаблицаТиповКонтекста = Неопределено Тогда
			ТаблицаТиповКонтекста = Новый Массив;
			ТаблицаТиповКонтекста.Добавить(СтруктураТипа);
		КонецЕсли; 
		СтруктураЦикла = Новый Соответствие;
		СтруктураЦикла.Вставить("1.Предсказанные:", ТаблицаТиповКонтекста);
		СтруктураЦикла.Вставить("2.Возможные:", ТаблицаСтруктурВозможныхТиповКонтекста);
		#Если Сервер И Не Сервер Тогда
			мПлатформа = Обработки.ирПлатформа.Создать();
		#КонецЕсли
		Если ВладелецФормы = Неопределено Тогда
			ВладелецФормы = ФормаВладелец;
		КонецЕсли; 
		мПлатформа.ВыбратьСтрокуОписанияИзМассиваСтруктурТипов(СтруктураЦикла, ВключатьПутьКОписаниюТипаЗначения, ВладелецФормы, Слово, НомерПараметра,, выхФормаВыбора, мФактическиеПараметры.Количество());
		Возврат выхФормаВыбора;
	КонецЕсли;
	Возврат Неопределено;

КонецФункции

// Открывает контекстную справку по текущему слову или его типу.
//
// Параметры:
//  *ПутьКСлову - Строка, *"" - используется для получения дочерних слов относительно текущего контекста.
//
Функция ОткрытьКонтекстнуюСправку(ПутьКСлову = "", ВладелецФормы = Неопределено) Экспорт
	
	//Если ирОбщий.ПроверитьПлатформаНеWindowsЛкс(,, Истина) Тогда
	//	Возврат;
	//КонецЕсли; 
	//КончитьОбработкуКоманды();
	РазобратьТекущийКонтекст(,,,,, Истина);
	РазрешитьАнализИмениТипа = Не ЗначениеЗаполнено(ПутьКСлову);
	Если РазрешитьАнализИмениТипа Тогда 
		ПутьКСлову = мТекущееСлово;
	КонецЕсли;
	Если Найти(ПутьКСлову, ".") > 0 Тогда
		ЧистоеСлово = ирОбщий.ПоследнийФрагментЛкс(ПутьКСлову);
	ИначеЕсли мРодительскийКонтекст <> ""  Тогда
		ЧистоеСлово = ПутьКСлову;
		ПутьКСлову = мРодительскийКонтекст + "." + ПутьКСлову;
	Иначе 
		ЧистоеСлово = ПутьКСлову;
	КонецЕсли;
	Если НайтиПоказатьСправкуПоСлову(ПутьКСлову,,, РазрешитьАнализИмениТипа, ВладелецФормы) = Неопределено Тогда 
		Если ЗначениеЗаполнено(ЧистоеСлово) Тогда
			НайтиПоказатьСправкуПоСтруктуреТипа(ЧистоеСлово, мПлатформа.НоваяСтруктураТипа(),,, ВладелецФормы);
		КонецЕсли;
	КонецЕсли;
	
КонецФункции 

Процедура _ОткрытьСправкуПоЯзыкуПрограммы() Экспорт 

	//Если ирОбщий.ПроверитьПлатформаНеWindowsЛкс() Тогда
	//	Возврат;
	//КонецЕсли; 
	Если ЯзыкПрограммы = 0 Тогда
		Книга = "shcntx_ru";
	ИначеЕсли ЯзыкПрограммы = 1 Тогда
		Книга = "shquery_ru";
	ИначеЕсли ЯзыкПрограммы = 2 Тогда
		Книга = "dcsui_ru";
	КонецЕсли;
	ФормаСправка = ирКлиент.ПолучитьФормуЛкс("Обработка.ирСинтаксПомощник.Форма", , ФормаВладелец);
	ФормаСправка.ТекущаяСтраницаУстановлена = Истина;
	ФормаСправка.ОткрытьАдрес("//" + Книга);

КонецПроцедуры

// Открывает контекстную справку по текущему параметру метода.
//
// Параметры:
//  *ПутьКСлову - Строка, *"" - используется для получения дочерних слов относительно текущего контекста.
//
Процедура ОткрытьСправкуПоПараметру(ПутьКСлову = "", ОткрыватьСинтаксПомощник = Истина) Экспорт
	
	//Если ирОбщий.ПроверитьПлатформаНеWindowsЛкс(,, Истина) Тогда
	//	Возврат;
	//КонецЕсли; 
	РазобратьТекущийКонтекст(,, Истина,,, Истина);
	Если ПутьКСлову = "" Тогда
		ПутьКСлову = мВызовМетода;
	КонецЕсли;
	// Если раскомментировать, то при вызове через мОткрытьСправкуПоПараметру не будет открываться окно 
	//Если Не ЗначениеЗаполнено(ПутьКСлову) Тогда
	//	Возврат;
	//КонецЕсли; 
	Если ОткрыватьСинтаксПомощник И ирКэш.ЛиПлатформаWindowsЛкс() Тогда
		ФормаСинтаксПомощникаДо = Неопределено;
		ФормаСинтаксПомощникаПосле = Неопределено;
		Если Не ЛиДоступноОткрытиеСвободнойФормы() Тогда 
			ФормаСинтаксПомощникаДо = ирКлиент.ПолучитьФормуЛкс("Обработка.ирСинтаксПомощник.Форма");
		КонецЕсли; 
		НайтиПоказатьСправкуПоСлову(ПутьКСлову,, ФормаСинтаксПомощникаПосле);
	КонецЕсли;
	ФормаПодсказкаПоПараметрам = ФормаВызовМетода(Истина);
	Если Не ФормаПодсказкаПоПараметрам.Открыта() И ЗначениеЗаполнено(мИмяМетодаВызова) Тогда
		ФормаПодсказкаПоПараметрам.ЗапомнитьПозициюКаретки();
	КонецЕсли; 
	Если ЛиДоступноОткрытиеСвободнойФормы() Тогда 
		Если Ложь
			Или ОткрыватьСинтаксПомощник
			Или Не ФормаПодсказкаПоПараметрам.Открыта() 
		Тогда 
			ОткрытьПодсказкуПоВызовуМетодаПассивно(ФормаПодсказкаПоПараметрам);
		КонецЕсли; 
	Иначе
		Если Истина
			И Не мЭтоАвтоВызов
			И ФормаСинтаксПомощникаДо <> Неопределено
			И ФормаСинтаксПомощникаДо.Открыта() = ФормаСинтаксПомощникаПосле.Открыта()
		Тогда
			ФормаПодсказкаПоПараметрам.ОткрытьМодально();
		КонецЕсли; 
	КонецЕсли;
	
КонецПроцедуры

Процедура ОткрытьПодсказкуПоВызовуМетодаПассивно(Знач ФормаПодсказкаПоПараметрам, Знач Автообновление = Истина)
	
	ФормаПодсказкаПоПараметрам.Автообновление = Автообновление;
	ФормаПодсказкаПоПараметрам.Открыть();
	ФормаПодсказкаПоПараметрам.Обновить(); // Нужно для ускорения срабатывания установки позиции окна и для 8.2, т.к. там форма форкус получает после завершения ПриОткрытии и только после этого сработает установка позиции окна
	//ирКлиент.УстановитьФокусВводаФормеЛкс(); Не помогает восстановить мигание каретки
	
КонецПроцедуры

Функция УдалитьКомментарии(Текст) Экспорт 
	
	мРегВыражение.Global = Истина;
	мРегВыражение.Multiline = Ложь;
	
	Если Ложь
		Или ЯзыкПрограммы = 1
		Или ЯзыкПрограммы = 2
	Тогда
		// Не проверено
		мРегВыражение.Pattern = "(?:(?://[^\n]*" + ")|(" + шЛитералВЗапросе + ")|([\s\S])";
		ШаблонЗамены = "$1$2$3$4";
	ИначеЕсли ЯзыкПрограммы = 0 Тогда
		шОднострочнаяСтрокаПрограммыСКавычки = """(?:(?:"""")|[^""\n])*""?"; 
		шОднострочнаяСтрокаПрограммыСЧерты = "\n\s*\|(?:(?:"""")|[^""\n])*""?";
		мРегВыражение.Pattern = "//[^\n]*|" + "(" + "#[^\n]*" + ")|(" + шОднострочнаяСтрокаПрограммыСКавычки + ")|(" + шОднострочнаяСтрокаПрограммыСЧерты + ")|([\s\S])";
		ШаблонЗамены = "$1$2$3$4";
	КонецЕсли;
	Результат = мРегВыражение.Заменить(Текст, ШаблонЗамены);
	Возврат Результат;
	
КонецФункции

// Меняет RegExp!
Функция ЭтоРусскийВариантТекстаЗапроса(Текст) Экспорт 
	
	ТекстБезКомментариев = СокрЛП(ЗалитьКомментарииИСтроковыеЛитералы(Текст));
	мРегВыражение.Pattern = "[А-ЯЁ]";
	ЭтоРусскийЯзык = мРегВыражение.Проверить(Лев(ТекстБезКомментариев, 1));
	Возврат ЭтоРусскийЯзык;

КонецФункции

// Добавляет/заменяет/удаляет оператор ПОМЕСТИТЬ в запросе.
// Это неточный метод, основанный на regexp.
//
// Параметры:
//  ТекстЗапроса - Строка;
//  *ИмяВременнойТаблицы - Строка - если пустое, то оператор удаляется.
//
// Возвращаемое значение:
//  Строка - исправленный текст запроса.
//
Функция ИзменитьОператорПоместитьЗапроса(ТекстЗапроса, ИмяВременнойТаблицы = "") Экспорт 

	ЭтоРусскийЯзык = ЭтоРусскийВариантТекстаЗапроса(ТекстЗапроса); // Меняет RegExp!
	мРегВыражение.Global = Истина;
	ШаблонПОМЕСТИТЬИЗ = "(" + шЛитералВЗапросе + ")|(?:(" + шРазделитель + ")+(" + "(?:ПОМЕСТИТЬ|INTO(?:" + шРазделитель + "+TABLE)?)" + шРазделитель + "+" + шИмя + шРазделитель + "+)"
		+ "|((?:ИЗ|FROM|ГДЕ|WHERE|СГРУППИРОВАТЬ|GROUP|УПОРЯДОЧИТЬ|ORDER|ИМЕЮЩИЕ|HAVING|ОБЪЕДИНИТЬ|UNION)" + шРазделитель + "+))|(.|\r|\n)";
	мРегВыражение.Pattern = ШаблонПОМЕСТИТЬИЗ;
	Если ЗначениеЗаполнено(ИмяВременнойТаблицы) Тогда
		Если ЭтоРусскийЯзык Тогда
			ТерминПоместить = "ПОМЕСТИТЬ";
		Иначе
			ТерминПоместить = "INTO";
		КонецЕсли; 
		Результат = мРегВыражение.НайтиВхождения(ТекстЗапроса);
		Текст = "";
		ПредложениеДобавлено = Ложь;
		Для Каждого Match Из Результат Цикл
			Если Ложь
				Или ПредложениеДобавлено
				Или Match.SubMatches(0) <> Неопределено
				Или Match.SubMatches(4) <> Неопределено
			Тогда
				Текст = Текст + Match.Value;
			Иначе
				Текст = Текст + "
				|" + ТерминПоместить + "
				|	" + ИмяВременнойТаблицы;
				Если Match.SubMatches(3) <> 0 Тогда // Видимо здесь ошибка
					Текст = Текст + Символы.ПС + Match.SubMatches(3);
				КонецЕсли;
				ПредложениеДобавлено = Истина;
			КонецЕсли;
		КонецЦикла;
		Если Не ПредложениеДобавлено Тогда
			Текст = Текст + "
			|" + ТерминПоместить + "
			|	" + ИмяВременнойТаблицы;
		КонецЕсли;
	Иначе
		Текст = мРегВыражение.Заменить(ТекстЗапроса, "$1$2$4$5");
	КонецЕсли; 
	Возврат Текст;

КонецФункции

Функция ШаблонЗапросаДопускаетВстройкуВРодительскийЗапрос(Текст) Экспорт 
	
	мРегВыражение.Global = Ложь;
	мРегВыражение.Pattern = шРазделитель + "*(?:ВЫБРАТЬ|SELECT)(?:" + шРазделитель + "+)\*(?:" + шРазделитель + "+)(?:ИЗ|FROM)(?:" + шРазделитель + "+(?:КАК|AS)?(?:" + шРазделитель + "+" + шИмя + "))" + шРазделитель + "*";
	Результат = мРегВыражение.Проверить(Текст);
	Возврат Результат;

КонецФункции

Функция ПолучитьКомментарийИзТокеновЯзыкаЗапросов(Токен1, Токен2 = Неопределено, выхИмяЗапросаИзКомментария = "", выхИмяЧастиОбъединенияИзКомментария = "") Экспорт 
	
	Массив = Новый Массив();
	Если Токен1 <> Неопределено И Токен1.Name = "Comment" Тогда
		Массив.Добавить(Токен1);
	КонецЕсли; 
	Если Токен2 <> Неопределено И Токен2.Name = "Comment" Тогда
		Массив.Добавить(Токен2);
	КонецЕсли; 
	ТекстКомментария = "";
	Для Каждого Токен Из Массив Цикл
		ТекстТокена = ПолучитьТекстИзТокена(Токен);
		РазобратьКомментарий(ТекстКомментария, выхИмяЗапросаИзКомментария, выхИмяЧастиОбъединенияИзКомментария);
	КонецЦикла;
	Возврат ТекстКомментария;
	
КонецФункции

Процедура РазобратьКомментарий(ТекстКомментария, выхИмяЗапросаИзКомментария = Неопределено, выхИмяЧастиОбъединенияИзКомментария = Неопределено, выхПорядокОтладки = Неопределено) Экспорт 
	
	ЧистыйКомментарий = "";
	ТекстовыйДокумент = Новый ТекстовыйДокумент;
	ТекстовыйДокумент.УстановитьТекст(ТекстКомментария);
	Для Счетчик = 1 По ТекстовыйДокумент.КоличествоСтрок() Цикл
		СтрокаТекста = ТекстовыйДокумент.ПолучитьСтроку(Счетчик);
		Если ПустаяСтрока(СтрокаТекста) Тогда
			Продолжить;
		КонецЕсли; 
		//Если Счетчик = 1 Тогда 
			Если Найти(СтрокаТекста, мПараметрыДиалектаSQL.СтрочныйКомментарий) = 1 Тогда 
				СтрокаТекста = Сред(СтрокаТекста, СтрДлина(мПараметрыДиалектаSQL.СтрочныйКомментарий) + 1);
			КонецЕсли; 
			Если Найти(СтрокаТекста, мМаркерСлужебногоКомментария) = 1 Тогда 
				Продолжить;
			КонецЕсли; 
			Если Найти(СтрокаТекста, мПлатформа.мМаркерИмениЗапросаПакета) = 1 Тогда 
				ИмяЗапросаИзКомментария = ирОбщий.ТекстМеждуМаркерамиЛкс(СтрокаТекста, мПлатформа.мМаркерИмениЗапросаПакета, " ");
				Если ирОбщий.ЛиИмяПеременнойЛкс(ИмяЗапросаИзКомментария) Тогда
					выхИмяЗапросаИзКомментария = ИмяЗапросаИзКомментария;
				КонецЕсли; 
				// Пропускаем служебные комментарии
				Продолжить;
			КонецЕсли; 
			Если Найти(СтрокаТекста, мПлатформа.мМаркерИмениЧастиОбъединения) = 1 Тогда 
				ИмяЧастиОбъединенияИзКомментария = ирОбщий.ТекстМеждуМаркерамиЛкс(СтрокаТекста, мПлатформа.мМаркерИмениЧастиОбъединения, " ");
				Если ирОбщий.ЛиИмяПеременнойЛкс(ИмяЧастиОбъединенияИзКомментария) Тогда
					выхИмяЧастиОбъединенияИзКомментария = ИмяЧастиОбъединенияИзКомментария;
				КонецЕсли; 
				// Пропускаем служебные комментарии
				Продолжить;
			КонецЕсли; 
			СтрокаТекста = СокрЛ(СтрокаТекста);
			Если ирОбщий.СтрНачинаетсяСЛкс(СтрокаТекста, мМаркерПорядкаОтладки) = 1 Тогда 
				выхПорядокОтладки = Сред(СтрокаТекста, СтрДлина(мМаркерПорядкаОтладки) + 1);
				// Пропускаем служебные комментарии
				Продолжить;
			КонецЕсли; 
		//КонецЕсли; 
		Если ЧистыйКомментарий <> "" Тогда
			ЧистыйКомментарий = ЧистыйКомментарий + Символы.ПС;
		КонецЕсли; 
		ЧистыйКомментарий = ЧистыйКомментарий + СтрокаТекста;
	КонецЦикла;
	ТекстКомментария = ЧистыйКомментарий;

КонецПроцедуры

// Разбирает текущий контекст по составляющим.
//
// Параметры:
//  ВзятьЛевоеОтРавенства				 - Булево - 
//  выхЕстьТочкаСправа				 - Булево - 
//  КакВызовМетода					 - Булево, Неопределено	 - если равен Неопределено, то трактуется как Истина в случае если внутри строкового литерала
//  НомерСтроки						 - Число - если не передано, то считывается из ПолеТекста
//  НомерКолонки					 - Число - если не передано, то считывается из ПолеТекста 
//  ПереходитьВоВложенныйКонтекст	 - Булево - переключаться в контекст вложенного текста строкового литерала (например языка запросов)
//  ПозицияВТексте					 - Число - передается для ускорения, т.е. дополнительно к переданным или установленным НомерСтроки/мКонечнаяСтроки И НомерКолонки/мКонечнаяКолонка
//
Процедура РазобратьТекущийКонтекст(Знач ВзятьЛевоеОтРавенства = Ложь, выхЕстьТочкаСправа = Ложь, Знач КакВызовМетода = Неопределено, Знач НомерСтроки = 0, Знач НомерКолонки = 0,
	Знач ПереходитьВоВложенныйКонтекст = Ложь, Знач ПозицияВТексте = 0) Экспорт 

	#Если Сервер И Не Сервер Тогда
		мПлатформа = Обработки.ирПлатформа.Создать();
	#КонецЕсли
	мОригинальныйТекст = ПолеТекста.ПолучитьТекст();
	ОригинальныйТекстИзменен = мСтарыйОригинальныйТекст <> мОригинальныйТекст;
	Если Истина 
		И Не мРазбиратьКонтекст 
		И Не ОригинальныйТекстИзменен
		И (Ложь
			Или ПозицияВТексте = 0 
			Или мПозицияВТексте = ПозицияВТексте)
	Тогда 
		Возврат;
	КонецЕсли;
	мПлатформа.ИнициацияОписанияМетодовИСвойств();
	Если Не ЗначениеЗаполнено(НомерСтроки) Тогда
		//Если ЗначениеЗаполнено(ПозицияВТексте) Тогда
		//	ПолеТекста.УстановитьГраницыВыделения(ПозицияВТексте, ПозицияВТексте); // Нельзя так делать, т.к. потеряем выделение в тексте литерала при вызове из РазобратьКонтекстЗапросаВТекстовомЛитерале
		//КонецЕсли;
		ПолучитьГраницыВыделения();
	Иначе
		мНачальнаяСтрока = НомерСтроки;
		мКонечнаяСтрока = НомерСтроки;
	    мНачальнаяКолонка = НомерКолонки;
		мКонечнаяКолонка = НомерКолонки;
	КонецЕсли; 
	Если ОригинальныйТекстИзменен Тогда
		СлужебноеПолеТекстаДолгое.УстановитьТекст(мОригинальныйТекст);
	КонецЕсли;   
	Если ЗначениеЗаполнено(ПозицияВТексте) Тогда
		мПозицияВТексте = ПозицияВТексте;
	Иначе 
		СлужебноеПолеТекстаДолгое.УстановитьГраницыВыделения(1, 1, мКонечнаяСтрока, мКонечнаяКолонка);
		мПозицияВТексте = СтрДлина(СлужебноеПолеТекстаДолгое.ВыделенныйТекст) + 1; // Долго 5мс TODO написать свой расчет позиции
	КонецЕсли;
	мПозицияТекстаДляПоискаОпределения = 0; // В режиме встроенного языка - начиная с 1. В режиме языка запросов - начинается с 0.
	мПредшествующийТекст = "";
	мТекстДляПоискаОпределения = "";  
	мТекстБлока = "";
	мТекстБезТекстовыхЛитералов = "";
	мПакетЗапросов = НовыйПакетЗапросов();
	мИндексЗапросаПакета = Неопределено;
	мНомерПервойСтрокиТелаМетода = 1;
	мНомерПоследнейСтрокиТелаМетода = Неопределено;
	ТекстПакетаЗапросов = мОригинальныйТекст;
	мЯзыкПрограммы = ЯзыкПрограммы;
	мНачальнаяПозиция0ВложенногоТекста = 0;
	НомерПервойСтрокиБлока = 1;
	ПрочитатьНачалоИКонецТекущейСтроки();
	ЧислоСтрокВБлоке = 0; 
	Если ЯзыкПрограммы = 0 И ОригинальныйТекстИзменен Тогда 
		ОбновитьМодульМетаданных(мОригинальныйТекст); 
	КонецЕсли;
	мМетодМодуля = Неопределено;
	Если ЯзыкПрограммы = 0 Тогда
		мМетодМодуля = мМодульМетаданных.ТекущийМетод; // Для ускорения поиска нового текущего метода берем сначала старый
		Если мМетодМодуля <> Неопределено Тогда 
			Если мМодульМетаданных.Методы.Индекс(мМетодМодуля) = -1 Тогда
				мМетодМодуля = Неопределено;
			КонецЕсли;
		КонецЕсли;
		ЗагрузитьМетодМодуляПоПозиции(мПозицияВТексте, Истина); // устанавливает мМетодМодуля
	КонецЕсли;
	Если Истина
		И ПереходитьВоВложенныйКонтекст 
		И (Ложь
			Или ирОбщий.ЛиВнутриНепервойСтрокиТекстовогоЛитералаЛкс(мТекущаяСтрокаНачало) // Первую строку литерала игнорируем для ускорения
			Или Найти(мТекущаяСтрокаНачало, ".Текст = ""ВЫБРАТЬ") > 0 И мЭтоТекстовыйЛитерал)
	Тогда
		ВыражениеЛитерала = "";
		ТекстЛитерала = ВыделитьТекстовыйЛитерал(СлужебноеПолеТекстаДолгое, мНачальнаяПозиция0ВложенногоТекста,, Ложь, ВыражениеЛитерала);
		Если ирОбщий.ЛиТекстЯзыкаЗапросовЛкс(ТекстЛитерала) Тогда
			СлужебноеПолеТекстаДолгое.ПолучитьГраницыВыделения(НомерПервойСтрокиБлока, 0, 0, 0);
			РазобратьКонтекстЗапросаВТекстовомЛитерале(ВыражениеЛитерала, ТекстЛитерала);
		КонецЕсли;
	КонецЕсли;
	Если мЯзыкПрограммы = 0 Тогда
		ЧислоСтрокВБлоке = ирОбщий.СтрЧислоСтрокЛкс(мТекстБлока);
		мНомерПервойСтрокиТелаМетода = СтрЧислоСтрок(Лев(мОригинальныйТекст, мПозицияТекстаДляПоискаОпределения) + "й"); // Мультиметка882366123
		мНомерПоследнейСтрокиТелаМетода = мНомерПервойСтрокиТелаМетода + ЧислоСтрокВБлоке - 1;
		НомерТекущейСтрокиВБлоке = мКонечнаяСтрока - мНомерПервойСтрокиТелаМетода + 1;
	Иначе
		ЧислоСтрокВБлоке = ЗагрузитьЗапросПакетаМодуляПоПозиции(ТекстПакетаЗапросов, НомерПервойСтрокиБлока);
		НомерТекущейСтрокиВБлоке = мКонечнаяСтрока - (НомерПервойСтрокиБлока - ЧислоСтрокВБлоке) +  1;
	КонецЕсли; 
	РазобратьКонтекстСтроки(ВзятьЛевоеОтРавенства, выхЕстьТочкаСправа, КакВызовМетода);
	мТекстДляПоискаОпределения = мТекстБлока;
	Если НомерТекущейСтрокиВБлоке > 1 Тогда
		мПолеТекстаВременное.УстановитьТекст(мТекстБлока);                              
		мПолеТекстаВременное.УстановитьГраницыВыделения(1, 1, НомерТекущейСтрокиВБлоке - 1, 333);
		мПредшествующийТекст = мПолеТекстаВременное.ВыделенныйТекст;
	Иначе 
		мПредшествующийТекст = "";
	КонецЕсли;
	Если мЯзыкПрограммы = 0 Тогда
		мТекстДляПоискаОпределения = мПредшествующийТекст;
	КонецЕсли;

	мПозицияВБлоке = мПозицияВТексте - мПозицияТекстаДляПоискаОпределения - 1;
	//мПредшествующийТекст = мПредшествующийТекст + Лев(мТекущаяСтрокаНачало, СтрДлина(мТекущаяСтрокаНачало) - СтрДлина(мНачалоКонтекста));
	мПредшествующийТекст = Лев(мТекстБлока, мПозицияВБлоке - СтрДлина(мНачалоКонтекста)); // мПозицияВТексте учитывает ВзятьЛевоеОтРавенства, поэтому опираемся на нее
	мПредшествующийТекст = Прав(мПредшествующийТекст, 500); // Обрезка для ускорения
	мСтарыйОригинальныйТекст = мОригинальныйТекст;
	Если мМодульМетаданных <> Неопределено Тогда
		мМодульМетаданных.ТекущийМетод = мМетодМодуля;
	КонецЕсли;
	ПродолжитьОбработкуКоманды();

КонецПроцедуры

// .
//
// Параметры:
//  ТекстПакетаЗапросов		 - Строка - в случае вложенного контекста передается выражение литерала
//  НомерПервойСтрокиБлока	 - Число, Неопределено	 - если передано, то ищется позиция по мНачальнаяСтрока
//  Позиция0ВЛитерале			 - Число, Неопределено	 - если передано, то ищется по этой позиции
// 
// Возвращаемое значение:
//   Число, Неопределено - если передано НомерПервойСтрокиБлока, то число строк в блоке
//
Функция ЗагрузитьЗапросПакетаМодуляПоПозиции(Знач ТекстПакетаЗапросов = "", НомерПервойСтрокиБлока = Неопределено, Позиция0ВЛитерале = Неопределено) Экспорт
	ИскатьЗапросПакета = Истина;
	Если мПакетЗапросов.ТекстыЗапросов = Неопределено Тогда
		мПакетЗапросов.Позиции0Запросов = Новый Массив;
		мПакетЗапросов.ТекстыЗапросов = мПлатформа.РазбитьГрубоТекстПакетногоЗапросаНаЗапросы(ТекстПакетаЗапросов, мПозицияВТексте - мНачальнаяПозиция0ВложенногоТекста, мПакетЗапросов.Позиции0Запросов);
	КонецЕсли;
	Если Позиция0ВЛитерале <> Неопределено И мИндексЗапросаПакета <> Неопределено Тогда
		мТекстБлока = мПакетЗапросов.ТекстыЗапросов[мИндексЗапросаПакета];
		мПозицияТекстаДляПоискаОпределения = мПакетЗапросов.Позиции0Запросов[мИндексЗапросаПакета];
		Если Истина
			И мПозицияТекстаДляПоискаОпределения < Позиция0ВЛитерале 
			И мПозицияТекстаДляПоискаОпределения + СтрДлина(мТекстБлока) >= Позиция0ВЛитерале 
		Тогда
			ИскатьЗапросПакета = Ложь;
		КонецЕсли; 
	КонецЕсли;
	Если ИскатьЗапросПакета Тогда
		Для мИндексЗапросаПакета = 0 По мПакетЗапросов.ТекстыЗапросов.ВГраница() Цикл
			мТекстБлока = мПакетЗапросов.ТекстыЗапросов[мИндексЗапросаПакета];
			мПозицияТекстаДляПоискаОпределения = мПакетЗапросов.Позиции0Запросов[мИндексЗапросаПакета];
			Если НомерПервойСтрокиБлока <> Неопределено Тогда
				ЧислоСтрокВБлоке = ирОбщий.СтрЧислоСтрокЛкс(мТекстБлока) - 1;
				НомерПервойСтрокиБлока = НомерПервойСтрокиБлока + ЧислоСтрокВБлоке;
				Если НомерПервойСтрокиБлока >= мНачальнаяСтрока Тогда
					Прервать;
				КонецЕсли;  
			Иначе 
				Если мПозицияТекстаДляПоискаОпределения + СтрДлина(мТекстБлока) >= Позиция0ВЛитерале Тогда
					Прервать;
				КонецЕсли; 
			КонецЕсли;
		КонецЦикла;
	КонецЕсли;
	мПозицияТекстаДляПоискаОпределения = мНачальнаяПозиция0ВложенногоТекста + мПозицияТекстаДляПоискаОпределения; // Теперь это позиция в модуле
	Возврат ЧислоСтрокВБлоке;
КонецФункции

// .
//
// Параметры:
//  ВыражениеЛитерала			 - Строка - например, "Выбрать1"
//  ТекстЛитерала				 - Строка - например, ВЫбрать 1
//  БратьЧастьДоТекущейПозиции	 - Булево - 
//
Процедура РазобратьКонтекстЗапросаВТекстовомЛитерале(Знач ВыражениеЛитерала, Знач ТекстЛитерала, Знач БратьЧастьДоТекущейПозиции = Истина) Экспорт
	мЭтоТекстовыйЛитерал = Ложь;
	мЯзыкПрограммы = 1;
	мМенеджерВременныхТаблиц = Неопределено;
	НачальнаяПозицияПредТекста = мНачальнаяПозиция0ВложенногоТекста - 100;
	ТекстДоЛитерала = Сред(мОригинальныйТекст, НачальнаяПозицияПредТекста, Мин(0, НачальнаяПозицияПредТекста) + 100); // не более 100 символов перед литералом
	КопияАнализатора = КопияКомпоненты();
	КопияАнализатора.РазобратьТекущийКонтекст(,,,,, Ложь, мНачальнаяПозиция0ВложенногоТекста); 
	мРегВыражение.Global = Ложь;
	мРегВыражение.Pattern = шПредИмяПрямое + "(" + шИмяСТочками + ")\.Текст\s*=\s*$";
	Вхождения = мРегВыражение.НайтиВхождения(ТекстДоЛитерала);
	Если Вхождения.Количество() > 0 Тогда
		ПеременнаяЗапроса = Вхождения[0].Submatches(0);
		ПозицияКонцаПрисвоения = КопияАнализатора.мПозицияВБлоке + СтрДлина(ВыражениеЛитерала) + 2;
		ОстатокТекстаБлока = Сред(мТекстБлока, ПозицияКонцаПрисвоения);
		ПозицияВыполнить = ирОбщий.НайтиРегВыражениеЛкс(ОстатокТекстаБлока, шПредИмяПрямое + ПеременнаяЗапроса + "\.Выполнить",, Ложь);
		Если ПозицияВыполнить.Количество() > 0 Тогда
			ПозицияВыполнить = ПозицияКонцаПрисвоения + ПозицияВыполнить[0].ПозицияВхождения;
		Иначе             
			//ПозицияВыполнить = КопияАнализатора.мПозицияВБлоке + 1;
			ПозицияВыполнить = 0;
		КонецЕсли;
		// Меняет границы выделения в нашем СлужебноеПолеТекстаДолгое! TODO избавиться от повторного извлечения текста запроса
		ТаблицаТиповЗапроса = КопияАнализатора.ВычислитьТипЗначенияВыражения(ПеременнаяЗапроса,,,,,,,,,,, ПозицияВыполнить); 
		Если Истина
			И ТаблицаТиповЗапроса.Количество() > 0
			И ТипЗнч(ТаблицаТиповЗапроса[0].ДержательМетаданных) = Тип("Структура") 
		Тогда
			мМенеджерВременныхТаблиц = ТаблицаТиповЗапроса[0].ДержательМетаданных;
			мПакетЗапросов.Параметры = ТаблицаТиповЗапроса[0].Метаданные.Параметры;
		КонецЕсли;
	КонецЕсли;
	Если мМенеджерВременныхТаблиц = Неопределено Тогда
		мМенеджерВременныхТаблиц = НовыйМенеджерВременныхТаблиц();
		мМенеджерВременныхТаблиц.ПакетыЗапросов.Добавить(мПакетЗапросов);
	КонецЕсли;
	мИндексЗапросаПакета = 0;
	мПакетЗапросов.КоординатыТекста = КопияАнализатора.НовыеКоординатыВыражения(ВыражениеЛитерала, мНачальнаяПозиция0ВложенногоТекста - КопияАнализатора.мПозицияТекстаДляПоискаОпределения);
	мПакетЗапросов.Позиции0Запросов = Новый Массив;
	Если БратьЧастьДоТекущейПозиции Тогда
		ПозицияКурсора = мПозицияВТексте - мНачальнаяПозиция0ВложенногоТекста;
	Иначе 
		ПозицияКурсора = Неопределено;
	КонецЕсли;
	мПакетЗапросов.ТекстыЗапросов = мПлатформа.РазбитьГрубоТекстПакетногоЗапросаНаЗапросы(ВыражениеЛитерала, ПозицияКурсора, мПакетЗапросов.Позиции0Запросов);
КонецПроцедуры

// Функция - Новый пакет запросов
//
// Параметры:
//  Текст			 - 	 - 
//  КоординатыТекста - см. НовыеКоординатыВыражения - 
// 
// Возвращаемое значение:
//   - 
Функция НовыйПакетЗапросов(Знач Текст = Неопределено, Знач КоординатыТекста = Неопределено) Экспорт
	Результат = Новый Структура("Тип, ТекстыЗапросов, Структура, Позиции0Запросов, Параметры");
	Результат.Вставить("Тип", "ПакетЗапросов");
	Результат.Вставить("Текст", Текст);
	Результат.Вставить("КоординатыТекста", КоординатыТекста);
	Результат.Вставить("Параметры", Новый Структура);
	//!Результат.Вставить("ТекстыЗапросов", Новый Массив);
	//!Результат.Вставить("Позиции0Запросов", Новый Массив); // Начиная с 0
	//!Результат.Вставить("Структура", Новый СписокЗначений);
	Возврат Результат;
КонецФункции

// Функция - Загрузить метод модуля по позиции
//
// Параметры:
//  ПозицияВТексте	 - Число - начиная с 1
// 
// Возвращаемое значение:
//   Булево - загружен ли другой метод
//
Функция ЗагрузитьМетодМодуляПоПозиции(Знач ПозицияВТексте1, Знач ПерезагрузитьТекущий = Ложь) Экспорт 
	
	НовыйМетодМодуля = Неопределено; 
	Если Истина
		И мЯзыкПрограммы = 0
		И мМетодМодуля <> Неопределено
		И мМетодМодуля.ПозицияСОписанием <= ПозицияВТексте1 
		И мМетодМодуля.ПозицияСОписанием + мМетодМодуля.ДлинаСОписанием >= ПозицияВТексте1
	Тогда
		// Не вышли за пределы текущего метода   
		Если ПерезагрузитьТекущий Тогда
			НовыйМетодМодуля = мМетодМодуля;
			мМетодМодуля = Неопределено;
		Иначе 
			Возврат Ложь;
		КонецЕсли;
	КонецЕсли;
	Если НовыйМетодМодуля = Неопределено Тогда
		_РежимОтладки = Ложь;
		Если _РежимОтладки Тогда // Можно менять на Истина в точке останова, например условием ирОбщий.Пр(_РежимОтладки, 1, 1)
			// Пассивный оригинал расположенного ниже однострочного кода. Выполняйте изменения синхронно в обоих вариантах.
			Для Каждого СтрокаМетода Из мМодульМетаданных.Методы Цикл
				Если Истина 
					И СтрокаМетода.ПозицияСОписанием <> 0
					И СтрокаМетода.ПозицияСОписанием <= ПозицияВТексте1 
					И СтрокаМетода.ПозицияСОписанием + СтрокаМетода.ДлинаСОписанием >= ПозицияВТексте1       
				Тогда
					НовыйМетодМодуля = СтрокаМетода;
					Прервать;
				КонецЕсли;  
			КонецЦикла;         
		Иначе
			// Однострочный код использован для ускорения при разрешенной отладке. Выше расположен оригинал. Выполняйте изменения синхронно в обоих вариантах. Преобразовано консолью кода из подсистемы "Инструменты разработчика"
			Для Каждого СтрокаМетода Из мМодульМетаданных.Методы Цикл  			Если Истина  				И СтрокаМетода.ПозицияСОписанием <> 0  				И СтрокаМетода.ПозицияСОписанием <= ПозицияВТексте1  				И СтрокаМетода.ПозицияСОписанием + СтрокаМетода.ДлинаСОписанием >= ПозицияВТексте1  			Тогда  				НовыйМетодМодуля = СтрокаМетода;  				Прервать;  			КонецЕсли;  		КонецЦикла;  
		КонецЕсли;
	КонецЕсли;
	Результат = ЗагрузитьМетодМодуля(НовыйМетодМодуля);
	Возврат Результат;

КонецФункции

Функция ЗагрузитьМетодМодуля(Знач НовыйМетодМодуля, Знач БезВозвратов = Истина) Экспорт 
	
	мТекстБлока = ТелоМетода(НовыйМетодМодуля,, БезВозвратов); // Переустанавливаем текст блока всегда на случай, если вызвано после подмены возвратов в теле
	Если НовыйМетодМодуля = мМетодМодуля И НовыйМетодМодуля <> Неопределено Тогда
		Возврат Ложь;
	КонецЕсли;
	мМетодМодуля = НовыйМетодМодуля;
	Если мМетодМодуля <> Неопределено Тогда
		мФлагиКомпиляции = ирОбщий.СкопироватьКоллекциюЛкс(мМодульМетаданных.ФлагиКомпиляции);
		мФлагиКомпиляции.Сервер                      = мМетодМодуля.Сервер И мФлагиКомпиляции.Сервер;     
		мФлагиКомпиляции.КлиентУправляемоеПриложение = мМетодМодуля.Клиент И мФлагиКомпиляции.КлиентУправляемоеПриложение;
		мФлагиКомпиляции.КлиентОбычноеПриложение     = мМетодМодуля.Клиент И мФлагиКомпиляции.КлиентОбычноеПриложение;  
		мФлагиКомпиляции.БезКонтекста = мМетодМодуля.БезКонтекста;
		мПозицияТекстаДляПоискаОпределения = мМетодМодуля.ПозицияТела;       
	Иначе
		мПозицияТекстаДляПоискаОпределения = мМодульМетаданных.ПозицияПрограммы - 1; // -1, чтобы проверки литералов работали 
	КонецЕсли;
	мНомерПервойСтрокиТелаМетода = Неопределено;
	Возврат Истина;

КонецФункции

// Перед вызовом нужно разобрать контекст
Функция ТелоМетода(МетодМодуля, выхНомерПервойСтрокиТела = 1, Знач БезВозвратов = Истина, _выхНачальнаяПозиция = 0) Экспорт 
	выхНомерПервойСтрокиТела = мНомерПервойСтрокиТелаМетода;
	Если МетодМодуля <> Неопределено Тогда  
		выхНачальнаяПозиция = МетодМодуля.ПозицияТела; 
		Если выхНачальнаяПозиция = 0 Тогда
			Результат = "";
		ИначеЕсли Ложь
			Или МетодМодуля.ТелоБезВозвратов <> Неопределено
			Или БезВозвратов И МетодМодуля.ТипЗначения <> Неопределено 
		Тогда
			Результат = МетодМодуля.ТелоБезВозвратов;
			Если Результат = Неопределено Тогда
				ИмяПеременной = ИмяПеременнойВозвращаемогоЗначения();
				Результат = Сред(мОригинальныйТекст, выхНачальнаяПозиция + 1, МетодМодуля.ДлинаТела); // Мультиметка38422941
				Результат = ЗаменитьВозвратыНаПерейтиВТекстеМетода(Результат, ИмяПеременной,, Неопределено); // Замена без смещения позиций!
				МетодМодуля.ТелоБезВозвратов = Результат;
			КонецЕсли;
		Иначе 
			Результат = Сред(мОригинальныйТекст, выхНачальнаяПозиция + 1, МетодМодуля.ДлинаТела); // Мультиметка38422941
		КонецЕсли;
	ИначеЕсли мМодульМетаданных <> Неопределено Тогда 
		выхНачальнаяПозиция = мМодульМетаданных.ПозицияПрограммы;
		Если Сред(Результат, выхНачальнаяПозиция, 1) = Символы.ПС Тогда
			// Мультиметка882366123 +1 нужно для случая, когда программа начинается с пустой строки - тогда мНомерПервойСтрокиТелаМетода будет на 1 больше
			выхНачальнаяПозиция = выхНачальнаяПозиция + 1;
		КонецЕсли;
		Результат = Сред(мОригинальныйТекст, выхНачальнаяПозиция);
	Иначе
		Результат = мОригинальныйТекст;
	КонецЕсли; 
	Возврат Результат;
КонецФункции  

//.
// Возвращаемое значение:
//    Строка - 
Функция ИмяПеременнойВозвращаемогоЗначения() Экспорт
	Возврат "Воз073"; // Длина должна совпадать с "Возврат" минус 1 символ для добавления "="!
КонецФункции

// Сначала нужно разобрать контекст
Функция ОпределениеАктивногоМетодаСОписанием(СмещениеНомераМетода = 0) Экспорт 
	Если мМетодМодуля <> Неопределено Тогда
		Если СмещениеНомераМетода = 0 Тогда
			Результат = ТекстМетодаСОписанием(мМетодМодуля);
		Иначе
			СледующийМетодМодуля = мМодульМетаданных.Методы[мМодульМетаданных.Методы.Индекс(мМетодМодуля) + СмещениеНомераМетода];
			Результат = ТекстМетодаСОписанием(СледующийМетодМодуля);
		КонецЕсли;
	Иначе
		Результат = ТелоМетода(Неопределено);
	КонецЕсли; 
	Возврат Результат;
КонецФункции

//.
// Параметры:
//    МетодМодуля - ?, ? - 
// Возвращаемое значение:
//    Строка - 
Функция ТекстМетодаСОписанием(МетодМодуля) Экспорт
	Результат = Сред(мОригинальныйТекст, МетодМодуля.ПозицияСОписанием, МетодМодуля.ДлинаСОписанием);
	Возврат Результат;
КонецФункции   

// Сначала нужно разобрать контекст
Функция ОпределениеМетодаБезОписания(МетодМодуля = Неопределено) Экспорт 
	Если МетодМодуля = Неопределено Тогда
		МетодМодуля = мМетодМодуля;
	КонецЕсли;
	Если мМетодМодуля <> Неопределено Тогда
		Результат = Сред(мОригинальныйТекст, мМетодМодуля.ПозицияОпределения, мМетодМодуля.ДлинаОпределения);
		Результат = ирОбщий.ЗаменитьРегВыражениеЛкс(Результат, "^\n*", "", Ложь);
		Возврат Результат;
	Иначе
		Возврат мОригинальныйТекст;
	КонецЕсли; 
КонецФункции

// Выполняет программу на внутреннем языке.
//
// Параметры:
//  Нет.
//
// Возвращаемое значение:
//  Булево - безошибочность выполнения кода.
//
Функция ВыполнитьПрограммныйКод(Знач ЛиСинтаксическийКонтроль = Ложь, выхИнформацияОбОшибке = Неопределено, Знач ТекстДляВыполнения = "") Экспорт
	
	#Если Сервер И Не Сервер Тогда
		мПлатформа = Обработки.ирПлатформа.Создать();
	#КонецЕсли
	Если Не ЗначениеЗаполнено(ТекстДляВыполнения) Тогда
		ТекстДляВыполнения = ПолеТекста.ПолучитьТекст();
	КонецЕсли;
	Попытка
		мПлатформа.ВыполнитьПрограммныйКодВКонтексте(КонтекстВыполнения, МетодВыполнения, ТекстДляВыполнения, ЛиСинтаксическийКонтроль);
		Возврат Истина;
	Исключение
		выхИнформацияОбОшибке = ИнформацияОбОшибке();
		Если Не ЛиСинтаксическийКонтроль Тогда
			// Баг платформы. Зависает приложение, если пытаемся установить выделение на невидимой странице.
			ФормаВладелец.ТекущийЭлемент = ПолеТекста.ЭлементФормы;
			
			ирКлиент.ПоказатьОшибкуВТекстеПрограммыЛкс(ПолеТекста,,,,, выхИнформацияОбОшибке); 
		КонецЕсли;
		Возврат Ложь;
	КонецПопытки;

КонецФункции

Функция ЗаполнитьДоступныеТаблицыWQL() Экспорт

	////Если мДоступныеТаблицыПолучены Тогда
	////	Возврат Неопределено;
	////КонецЕсли; 
	////ЭтотОбъект.мДоступныеТаблицыПолучены = Истина;
	//ДоступныеТаблицы.Очистить();
	ОчиститьДоступныеНеВременныеТаблицы();
	Если Конфигурация = Неопределено Тогда
		Возврат Неопределено;
	КонецЕсли; 
	Состояние("Подготовка метаданных...");
	wbemFlagUseAmendedQualifiers = 131072; //&H20000
	КоллекцияКлассов = Конфигурация.SubclassesOf(, wbemFlagUseAmendedQualifiers);
	ВидимостьКолонкиСхема = Ложь;
	ВидимостьКолонкиОписание = Ложь;
	Индикатор = ирОбщий.ПолучитьИндикаторПроцессаЛкс(КоллекцияКлассов.Count, "Получаем метаданные");
	Для Каждого ЭлементКоллекции Из КоллекцияКлассов Цикл
		ирОбщий.ОбработатьИндикаторЛкс(Индикатор);
		СтрокаТаблицы = ДоступныеТаблицы.Добавить();
		СтрокаТаблицы.Имя = ЭлементКоллекции.Path_.Class;
		//СтрокаТаблицы.Схема = СтрокаТЗ.TABLE_SCHEMA;
		//СтрокаТаблицы.Тип = СтрокаТЗ.TABLE_TYPE;
		СтрокаТаблицы.Описание = ирОбщий.ПолучитьОписаниеЭлементаWMIЛкс(ЭлементКоллекции);
		ПолноИмя = СтрокаТаблицы.Имя;
		Если ЗначениеЗаполнено(СтрокаТаблицы.Схема) Тогда
			ПолноИмя = СтрокаТаблицы.Схема + "." + ПолноИмя;
		КонецЕсли;
		СтрокаТаблицы.ПолноеИмя = ПолноИмя;
		СтрокаТаблицы.НПолноеИмя = НРег(СтрокаТаблицы.ПолноеИмя);
		ВидимостьКолонкиСхема = ВидимостьКолонкиСхема Или ЗначениеЗаполнено(СтрокаТаблицы.Схема);
		ВидимостьКолонкиОписание = ВидимостьКолонкиСхема Или ЗначениеЗаполнено(СтрокаТаблицы.Описание);
	КонецЦикла;
	ирОбщий.ОсвободитьИндикаторПроцессаЛкс();
	Возврат Неопределено;

КонецФункции

Функция ЗаполнитьДоступныеТаблицыADO() Экспорт

	////Если мДоступныеТаблицыПолучены Тогда
	////	Возврат Неопределено;
	////КонецЕсли; 
	////мДоступныеТаблицыПолучены = Истина;
	//ДоступныеТаблицы.Очистить();
	ОчиститьДоступныеНеВременныеТаблицы();
	Если Ложь
		Или Конфигурация = Неопределено 
		Или Конфигурация.State = 0
	Тогда
		Возврат Неопределено;
	КонецЕсли; 
	Состояние("Подготовка метаданных...");
	Если Не мРасширенноеПолучениеМетаданныхADO Тогда
		Фильтры = Новый Массив();
		Фильтры.Добавить(); // TABLE_CATALOG
		Фильтры.Добавить(); // TABLE_SCHEMA
		Фильтры.Добавить(); // TABLE_NAME
		Если Не мРасширенноеПолучениеМетаданныхADO Тогда
			Фильтры.Добавить("TABLE"); // TABLE_TYPE
		КонецЕсли; 
		Фильтры = Новый COMSafeArray(Фильтры, "VT_VARIANT");
		ОписаниеТаблицRecordSet = Конфигурация.OpenSchema(20, Фильтры); //adSchemaTables // Может выполняться долго (oracle)
	Иначе
		ОписаниеТаблицRecordSet = Конфигурация.OpenSchema(20); //adSchemaTables // Может выполняться долго (oracle)
	КонецЕсли; 
	ОписаниеТаблицТЗ = ирОбщий.РезультатЗапросаADOВТаблицуЗначенийОбщийЛкс(ОписаниеТаблицRecordSet);
	//! ОписаниеТаблицТЗ.Колонки.Добавить("TABLE_TYPE");
	//! ОписаниеТаблицТЗ.Колонки.Добавить("DESCRIPTION");
	//! ОписаниеТаблицТЗ.Колонки.Добавить("TABLE_SCHEMA");
	//! ОписаниеТаблицТЗ.Колонки.Добавить("TABLE_NAME");
	Если ирКэш.РежимОтладкиЛкс() Тогда 
		// Пассивный оригинал расположенного ниже однострочного кода. Выполняйте изменения синхронно в обоих вариантах.
		Для Каждого СтрокаТЗ Из ОписаниеТаблицТЗ Цикл
			ТипТаблицы = СтрокаТЗ.TABLE_TYPE;
			Если Истина
				И Не ирОбщий.СтрокиРавныЛкс(ТипТаблицы, "table")
				И Не ирОбщий.СтрокиРавныЛкс(ТипТаблицы, "view")
			Тогда
				Продолжить;
			КонецЕсли; 
			СтрокаТаблицы = ДоступныеТаблицы.Добавить();
			СтрокаТаблицы.Имя = СтрокаТЗ.TABLE_NAME;
			СтрокаТаблицы.Схема = СтрокаТЗ.TABLE_SCHEMA;
			СтрокаТаблицы.Тип = ТипТаблицы;
			СтрокаТаблицы.Описание = СтрокаТЗ.DESCRIPTION;
			ПолноеИмяДоступнойТаблицы = ПолноеИмяДоступнойТаблицы(СтрокаТаблицы.Имя, СтрокаТаблицы.Схема);
			СтрокаТаблицы.ПолноеИмя = ПолноеИмяДоступнойТаблицы;
			СтрокаТаблицы.НПолноеИмя = НРег(ПолноеИмяДоступнойТаблицы);
		КонецЦикла;
	Иначе
		// Однострочный код использован для ускорения. Выше расположен оригинал. Выполняйте изменения синхронно в обоих вариантах. Преобразовано консолью кода из подсистемы "Инструменты разработчика" (http://devtool1c.ucoz.ru)
		Для Каждого СтрокаТЗ Из ОписаниеТаблицТЗ Цикл  		ТипТаблицы = СтрокаТЗ.TABLE_TYPE;  		Если Истина  			И Не ирОбщий.СтрокиРавныЛкс(ТипТаблицы, "table")  			И Не ирОбщий.СтрокиРавныЛкс(ТипТаблицы, "view")  		Тогда  			Продолжить;  		КонецЕсли;  		СтрокаТаблицы = ДоступныеТаблицы.Добавить();  		СтрокаТаблицы.Имя = СтрокаТЗ.TABLE_NAME;  		СтрокаТаблицы.Схема = СтрокаТЗ.TABLE_SCHEMA;  		СтрокаТаблицы.Тип = ТипТаблицы;  		СтрокаТаблицы.Описание = СтрокаТЗ.DESCRIPTION;  		ПолноеИмяДоступнойТаблицы = ПолноеИмяДоступнойТаблицы(СтрокаТаблицы.Имя, СтрокаТаблицы.Схема);  		СтрокаТаблицы.ПолноеИмя = ПолноеИмяДоступнойТаблицы;  		СтрокаТаблицы.НПолноеИмя = НРег(ПолноеИмяДоступнойТаблицы);  	КонецЦикла;  
	КонецЕсли; 
	Возврат Неопределено;

КонецФункции

Функция ПолучитьИмяТаблицыADO(Знач ИмяИсходное)  
	
	Если Лев(ИмяИсходное, 1) <> "[" Тогда
		ИмяИсходное = "[" + ИмяИсходное + "]";  
	КонецЕсли;  
	Возврат ИмяИсходное;
	
 КонецФункции

Процедура ОбновитьВычисляемыеДоступныеВременныеТаблицы() Экспорт 
	ОчиститьДоступныеВременныеТаблицы(); 
	Если мМенеджерВременныхТаблиц <> Неопределено Тогда
		Для Каждого ПакетЗапросов Из мМенеджерВременныхТаблиц.ПакетыЗапросов Цикл // см. НовыйПакетЗапросов()
			ПодготовитьПакетЗапросов(ПакетЗапросов);
			Для Каждого ЭлементСписка Из ПакетЗапросов.Структура Цикл
				Если ЗначениеЗаполнено(ЭлементСписка.Представление) Тогда
					НайтиДобавитьДоступнуюВременнуюТаблицу(ЭлементСписка.Представление);
				КонецЕсли;
			КонецЦикла;
			Для Каждого КлючИЗначение Из ПакетЗапросов.Параметры Цикл
				ЗначениеПараметра = мПлатформа.ПодготовитьЗначениеПараметраЗапроса(КлючИЗначение.Значение);
				Если ТипЗнч(ЗначениеПараметра) = Тип("ТаблицаЗначений") Тогда
					НайтиДобавитьДоступнуюВременнуюТаблицу("&" + КлючИЗначение.Ключ);
				КонецЕсли;
				Если ТипЗнч(КонтекстВыполнения) = Тип("Запрос") Тогда   
					КонтекстВыполнения.Параметры.Вставить(КлючИЗначение.Ключ, ЗначениеПараметра);
				КонецЕсли;
			КонецЦикла;
		КонецЦикла;
	КонецЕсли;
КонецПроцедуры
 
Функция НайтиДобавитьДоступнуюВременнуюТаблицу(Знач ЛюбоеИмяТаблицы, ПородившийЗапрос = Неопределено, выхБылиДобавления = Ложь, ИсточникДанных1С = Неопределено) Экспорт
	
	ПолноеИмяТаблицы = ПолноеИмяДоступнойТаблицы(ЛюбоеИмяТаблицы);
	КраткоеИмяТаблицы = КраткоеИмяВременнойТаблицы(ЛюбоеИмяТаблицы);
	Если Лев(ЛюбоеИмяТаблицы, 1) = "&" Тогда
		Тип = "Параметр";
		КраткоеИмяТаблицы = Сред(КраткоеИмяТаблицы, 2);
	Иначе
		Тип = "ВременнаяТаблица";
	КонецЕсли;
	ПолноеИмяТаблицы = ПолноеИмяВременнойТаблицы(ПолноеИмяТаблицы, ИсточникДанных1С);
	СтрокаДоступнойТаблицы = ДоступныеТаблицы.Найти(НРег(ПолноеИмяТаблицы), "НПолноеИмя");
	Если СтрокаДоступнойТаблицы = Неопределено Тогда
		СтрокаДоступнойТаблицы = ДоступныеТаблицы.Добавить();
		СтрокаДоступнойТаблицы.Имя = КраткоеИмяТаблицы;
		СтрокаДоступнойТаблицы.ПолноеИмя = ПолноеИмяТаблицы;
		СтрокаДоступнойТаблицы.Схема = ИсточникДанных1С;
		ирОбщий.ОбновитьКопиюСвойстваВНижнемРегистреЛкс(СтрокаДоступнойТаблицы, "ПолноеИмя");
		СтрокаДоступнойТаблицы.Тип = Тип;
		СтрокаДоступнойТаблицы.ЕстьДоступ = Истина;
		выхБылиДобавления = Истина;
	КонецЕсли;
	Если ПородившийЗапрос <> Неопределено Тогда
		Для Каждого СтараяСтрока Из ДоступныеТаблицы.НайтиСтроки(Новый Структура("ПородившийЗапрос", ПородившийЗапрос)) Цикл
			Если СтараяСтрока = СтрокаДоступнойТаблицы Тогда
				Продолжить;
			КонецЕсли; 
			ДоступныеТаблицы.Удалить(СтараяСтрока);
		КонецЦикла;
		СтрокаДоступнойТаблицы.ПородившийЗапрос = ПородившийЗапрос;
	КонецЕсли; 
	Возврат СтрокаДоступнойТаблицы;
	
КонецФункции

Функция ПолноеИмяДоступнойТаблицы(Знач ИмяДоступнойТаблицы, ИмяСхемы = Неопределено) Экспорт 
	
	Если Истина
		И Найти(ИмяДоступнойТаблицы, ".") = 0 
		И мПараметрыДиалектаSQL.Диалект <> "1С" 
		И мПараметрыДиалектаSQL.Диалект <> "WQL"
	Тогда
		ИмяДоступнойТаблицы = ПолучитьИмяТаблицыADO(ИмяДоступнойТаблицы); 
		Если ИмяСхемы = Неопределено И ДоступныеТаблицы.Количество() > 0 Тогда
			ИмяСхемы = ДоступныеТаблицы[0].Схема;
		КонецЕсли;
		Если ЗначениеЗаполнено(ИмяСхемы) Тогда
			ИмяДоступнойТаблицы = ИмяСхемы + "." + ИмяДоступнойТаблицы;
		КонецЕсли; 
	КонецЕсли; 
	Возврат ИмяДоступнойТаблицы;

КонецФункции

Функция ДоступнаяТаблицаПоИмениВыбранной(Знач ПолноеИмя) Экспорт 
	
	ПолноеИмяДоступнойТаблицы = ПолноеИмяДоступнойТаблицы(ПолноеИмя);
	СтрокаДоступнойТаблицы = ДоступныеТаблицы.Найти(НРег(ПолноеИмяДоступнойТаблицы), "НПолноеИмя");
	Возврат СтрокаДоступнойТаблицы;

КонецФункции

Функция ЭтоПараметрПериодичность1С(Знач СтрокаПараметраТаблицы, Знач ДиалектSQL = "") Экспорт 

	Если ДиалектSQL = "" Тогда
		ДиалектSQL = мДиалектSQL;
	КонецЕсли;
	Результат = Истина
		И Найти(НРег(СтрокаПараметраТаблицы.Имя), "периодичность") = 1
		И ирОбщий.СтрокиРавныЛкс(ДиалектSQL, "1С");
	Возврат Результат;

КонецФункции

Функция ПоляДоступнойТаблицы(Знач СтрокаДоступнойТаблицы, Знач ПараметрыТаблицы = Неопределено, Знач ДиалектSQL = "", Знач ПородившийЗапрос = Неопределено) Экспорт 
	
	Если ДиалектSQL = "" Тогда
		ДиалектSQL = мДиалектSQL;
	КонецЕсли;
	ПолноеИмяТаблицы = СтрокаДоступнойТаблицы.ПолноеИмя;
	ИспользоватьКэширование = Истина
		И СтрокаДоступнойТаблицы.Тип <> "ВременнаяТаблица"
		И СтрокаДоступнойТаблицы.Тип <> "Параметр"
		И ТипЗнч(Конфигурация) <> Тип("ОбъектМетаданныхКонфигурация");
	Если ИспользоватьКэширование Тогда 
		ТаблицаПолей = мДоступныеПоляТаблиц[ПолноеИмяТаблицы];
		Если ТаблицаПолей <> Неопределено Тогда
			Возврат ТаблицаПолей;
		КонецЕсли; 
	КонецЕсли; 
	ТаблицаПолей = Новый ТаблицаЗначений;
	ТаблицаПолей.Колонки.Добавить("Имя", Новый ОписаниеТипов("Строка"));
	ТаблицаПолей.Колонки.Добавить("ТипЗначения", Новый ОписаниеТипов("ОписаниеТипов"));
	ТаблицаПолей.Колонки.Добавить("Метаданные");
	Если СтрокаДоступнойТаблицы.Тип = "ВременнаяТаблица" Тогда
		КолонкиРезультата = Новый Массив();
		Если ПородившийЗапрос <> Неопределено Тогда
			//КолонкиРезультата = ПородившийЗапрос.ЧастиОбъединения[0].ВыбранныеПоля;
			КолонкиРезультата = ПородившийЗапрос.ПоляОбъединения;
		ИначеЕсли мМенеджерВременныхТаблиц <> Неопределено Тогда
			Построитель = НайтиЗапросВременнойТаблицы(ПолноеИмяТаблицы);
			Если Построитель <> Неопределено Тогда
				КолонкиРезультата = мПлатформа.ПустаяТаблицаЗначенийИзПостроителя(Построитель).Колонки;
			КонецЕсли;
		Иначе
			ТекстЗапроса = "SELECT * FROM " + ПолноеИмяТаблицы + " WHERE 1=0";
			Если ТипЗнч(КонтекстВыполнения) = Тип("Запрос") Тогда
				ВременныйЗапрос = Новый Запрос;
				ВременныйЗапрос.МенеджерВременныхТаблиц = КонтекстВыполнения.МенеджерВременныхТаблиц;
				ВременныйЗапрос.Текст = ТекстЗапроса;
				РезультатВременногоЗапроса = Неопределено;
				Попытка
					РезультатВременногоЗапроса = ВременныйЗапрос.Выполнить();
				Исключение
				КонецПопытки;
				Если РезультатВременногоЗапроса <> Неопределено Тогда
					КолонкиРезультата = РезультатВременногоЗапроса.Выгрузить();
					КолонкиРезультата = ирОбщий.ТаблицаСКолонкамиБезТипаNullЛкс(КолонкиРезультата, Ложь);
					КолонкиРезультата = КолонкиРезультата.Колонки;
				КонецЕсли;
			ИначеЕсли ирОбщий.СтрокиРавныЛкс(ДиалектSQL, "WQL") Тогда
				//
			Иначе // ADO
				Попытка
					РезультатВременногоЗапроса = Конфигурация.Execute(ТекстЗапроса);
				Исключение  
					ОписаниеОшибки = ОписаниеОшибки();
				КонецПопытки;
				Если РезультатВременногоЗапроса <> Неопределено Тогда
					РезультатТаблица = Новый ТаблицаЗначений;
					ирОбщий.ПолучитьКолонкиRecordsetADOЛкс(РезультатТаблица, РезультатВременногоЗапроса, Истина);
					КолонкиРезультата = РезультатТаблица.Колонки;
				КонецЕсли; 
			КонецЕсли; 
		КонецЕсли; 
		Для Каждого ВыбранноеПоле Из КолонкиРезультата Цикл
			Если ВыбранноеПоле.Имя = "" Тогда
				ВызватьИсключение "Не определены имена полей таблицы """ + ПолноеИмяТаблицы + """";
			КонецЕсли; 
			СтрокаПоля = ТаблицаПолей.Добавить();
			СтрокаПоля.Имя = ВыбранноеПоле.Имя;
			СтрокаПоля.ТипЗначения = ВыбранноеПоле.ТипЗначения;
		КонецЦикла;
	ИначеЕсли СтрокаДоступнойТаблицы.Тип = "Параметр" Тогда
		КолонкиРезультата = Новый Массив();
		ТаблицаПараметр = Неопределено;
		Если Истина
			И ТипЗнч(КонтекстВыполнения) = Тип("Запрос")
			//! КонтекстВыполнения = Новый Запрос;
			И КонтекстВыполнения.Параметры.Свойство(СтрокаДоступнойТаблицы.Имя, ТаблицаПараметр) 
		Тогда 
			Попытка
				КолонкиРезультата = ТаблицаПараметр.Колонки;
			Исключение
				// TODO Табличная часть
			КонецПопытки;
		КонецЕсли;
		Для Каждого ВыбранноеПоле Из КолонкиРезультата Цикл
			СтрокаПоля = ТаблицаПолей.Добавить();
			СтрокаПоля.Имя = ВыбранноеПоле.Имя;
			СтрокаПоля.ТипЗначения = ВыбранноеПоле.ТипЗначения;
		КонецЦикла;
	ИначеЕсли ТипЗнч(Конфигурация) = Тип("ОбъектМетаданныхКонфигурация") Тогда
		ИндексПараметраПериодичность = Неопределено;
		ОпределениеПараметраПериодичность = "";
		Если ПараметрыТаблицы <> Неопределено Тогда
			Для ИндексПараметра = 0 По ПараметрыТаблицы.Количество() - 1 Цикл
				СтрокаПараметраТаблицы = ПараметрыТаблицы[ИндексПараметра];
				Если ЭтоПараметрПериодичность1С(СтрокаПараметраТаблицы) Тогда
					ИндексПараметраПериодичность = ИндексПараметра;
					ОпределениеПараметраПериодичность = СтрокаПараметраТаблицы.Определение;
					Прервать;
				КонецЕсли; 
			КонецЦикла;
		КонецЕсли; 
		ПоляТаблицыБД = ирОбщий.ПоляТаблицыМДЛкс(ПолноеИмяТаблицы,, ИндексПараметраПериодичность, ОпределениеПараметраПериодичность, Ложь);
		Если ПоляТаблицыБД <> Неопределено Тогда
			_РежимОтладки = Ложь;
			Если _РежимОтладки Тогда // Можно менять на Истина в точке останова, например условием ирОбщий.Пр(_РежимОтладки, 1, 1)
				// Пассивный оригинал расположенного ниже однострочного кода. Выполняйте изменения синхронно в обоих вариантах.
				Для Каждого ПолеТаблицыБД Из ПоляТаблицыБД Цикл
					//Если ПолеТаблицыБД.ТипЗначения.СодержитТип(Тип("ТаблицаЗначений")) Тогда
					//	Продолжить;
					//КонецЕсли;
					СтрокаПоля = ТаблицаПолей.Добавить();
					СтрокаПоля.Имя = ПолеТаблицыБД.Имя;
					СтрокаПоля.ТипЗначения = ПолеТаблицыБД.ТипЗначения;
					СтрокаПоля.Метаданные = ПолеТаблицыБД.Метаданные;
				КонецЦикла;
			Иначе
				// Однострочный код использован для ускорения при разрешенной отладке. Выше расположен оригинал. Выполняйте изменения синхронно в обоих вариантах. Преобразовано консолью кода из подсистемы "Инструменты разработчика"
				Для Каждого ПолеТаблицыБД Из ПоляТаблицыБД Цикл        				СтрокаПоля = ТаблицаПолей.Добавить();  				СтрокаПоля.Имя = ПолеТаблицыБД.Имя;  				СтрокаПоля.ТипЗначения = ПолеТаблицыБД.ТипЗначения;  				СтрокаПоля.Метаданные = ПолеТаблицыБД.Метаданные;  			КонецЦикла;  
			КонецЕсли;
			ирОбщий.ДополнитьТаблицуПолейТаблицыБДВиртуальнымиПолямиЛкс(ТаблицаПолей, СтрокаДоступнойТаблицы, Истина);
		КонецЕсли;
	Иначе
		СтрокаДоступнойТаблицы = ДоступнаяТаблицаПоИмениВыбранной(ПолноеИмяТаблицы);
		Если ирОбщий.СтрокиРавныЛкс(ДиалектSQL, "WQL") Тогда
			wbemFlagUseAmendedQualifiers = 131072; //&H20000
			ОписаниеКласса = Конфигурация.Get(СтрокаДоступнойТаблицы.Имя, wbemFlagUseAmendedQualifiers); 
			ТаблицаКласса = Новый ТаблицаЗначений;
			МассивКоллекцийСвойств = Новый Массив();
			МассивКоллекцийСвойств.Добавить(ОписаниеКласса.Properties_);
			//Если СобиратьСистемныеСвойстваWMI Тогда
			//	МассивКоллекцийСвойств.Добавить(ОписаниеКласса.SystemProperties_);
			//КонецЕсли; 
			Для Каждого КоллекцияСвойств Из МассивКоллекцийСвойств Цикл
				Для Каждого Свойство Из КоллекцияСвойств Цикл
					ИмяТипа = ирОбщий.ИмяТипаИзКвалификаторовWMIЛкс(Свойство);
					Попытка
						ОписаниеТипов = Новый ОписаниеТипов(ИмяТипа,,,, Новый КвалификаторыСтроки(1024)); // Доделать распознавание типов
					Исключение
						ОписаниеТипов = Новый ОписаниеТипов();
					КонецПопытки;
					ПредставлениеСвойства = ирОбщий.ПолучитьОписаниеЭлементаWMIЛкс(Свойство, "DisplayName");
					ТаблицаКласса.Колонки.Добавить(, ОписаниеТипов, ПредставлениеСвойства);
					СтрокаПоля = ТаблицаПолей.Добавить();
					СтрокаПоля.Имя = Свойство.Name;
					СтрокаПоля.ТипЗначения = ОписаниеТипов;
					//СтрокаПоля.Описание = ПредставлениеСвойства;
				КонецЦикла;
			КонецЦикла;
		Иначе // ADO
			Фильтры = Новый Массив();
			Фильтры.Добавить(); //TABLE_CATALOG
			Если ЗначениеЗаполнено(СтрокаДоступнойТаблицы.Схема) Тогда //TABLE_SCHEMA
				Фильтры.Добавить(СтрокаДоступнойТаблицы.Схема);
			Иначе
				Фильтры.Добавить(Неопределено);
			КонецЕсли; 
			Фильтры.Добавить(СтрокаДоступнойТаблицы.Имя); // TABLE_NAME
			Фильтры = Новый COMSafeArray(Фильтры, "VT_VARIANT");
			Состояние("Запрашиваем поля " + ПолноеИмяТаблицы + "...");
			ОписаниеПолейRecordSet = Конфигурация.OpenSchema(4, Фильтры); //adSchemaColumns
			ADOUtils = мПлатформа.ПолучитьADOUtils();
			Если ADOUtils <> Неопределено Тогда
				ОписаниеПолейТЗ = ADOUtils.ADORecordsetToValueTable(ОписаниеПолейRecordSet);
				Для Каждого СтрокаТЗ Из ОписаниеПолейТЗ Цикл
					СтрокаПоля = ТаблицаПолей.Добавить();
					СтрокаПоля.Имя = СтрокаТЗ.COLUMN_NAME;
					ЧисловаяРазрядность = СтрокаТЗ.NUMERIC_SCALE;
					ДлинаТипа = СтрокаТЗ.CHARACTER_MAXIMUM_LENGTH;
					ЧисловаяТочность = СтрокаТЗ.NUMERIC_PRECISION;
					НомерТипа = СтрокаТЗ.DATA_TYPE;
					FieldADO = ирОбщий.FieldADOЛкс(СтрокаПоля.Имя, НомерТипа, ДлинаТипа, ЧисловаяТочность, ЧисловаяРазрядность);
					СтрокаПоля.ТипЗначения = ирОбщий.FieldADO_ПолучитьТип1CЛкс(FieldADO, Истина);
				КонецЦикла;
			Иначе
				Пока Не ОписаниеПолейRecordSet.EOF() Цикл
					СтрокаПоля = ТаблицаПолей.Добавить();
					СтрокаПоля.Имя = ОписаниеПолейRecordSet.Fields("COLUMN_NAME").Value;
					ЧисловаяРазрядность = ОписаниеПолейRecordSet.Fields("NUMERIC_SCALE").Value; 
					ДлинаТипа = ОписаниеПолейRecordSet.Fields("CHARACTER_MAXIMUM_LENGTH").Value;
					ЧисловаяТочность = ОписаниеПолейRecordSet.Fields("NUMERIC_PRECISION").Value;
					НомерТипа = ОписаниеПолейRecordSet.Fields("DATA_TYPE").Value;
					FieldADO = ирОбщий.FieldADOЛкс(СтрокаПоля.Имя, НомерТипа, ДлинаТипа, ЧисловаяТочность, ЧисловаяРазрядность);
					СтрокаПоля.ТипЗначения = ирОбщий.FieldADO_ПолучитьТип1CЛкс(FieldADO, Истина);
					ОписаниеПолейRecordSet.MoveNext();
				КонецЦикла;
			КонецЕсли; 
		КонецЕсли; 
		Состояние();
	КонецЕсли; 
	Если ИспользоватьКэширование Тогда
		мДоступныеПоляТаблиц[ПолноеИмяТаблицы] = ТаблицаПолей;
	КонецЕсли; 
	Возврат ТаблицаПолей;
	
КонецФункции

Функция ПолноеИмяВременнойТаблицы(Знач КраткоеИмяТаблицы, Знач ИсточникДанных1С = Неопределено) Экспорт 
	
	Результат = КраткоеИмяТаблицы;
	Если Истина
		И Найти(КраткоеИмяТаблицы, ".") = 0
		И мПараметрыДиалектаSQL.Диалект = "1С"
		И ЗначениеЗаполнено(ИсточникДанных1С) 
		И ИсточникДанных1С <> "<Локальный>"
	Тогда
		Результат = "ВнешнийИсточникДанных." + ИсточникДанных1С + ".ВременнаяТаблица." + Результат;
	КонецЕсли;
	Возврат Результат;

КонецФункции

Функция КраткоеИмяВременнойТаблицы(ЛюбоеИмяТаблицы) Экспорт 
	Результат = ЛюбоеИмяТаблицы;
	Если Истина
		И мПараметрыДиалектаSQL.Диалект = "1С"
		И Найти(Результат, ".") > 0
	Тогда
		Результат = ирОбщий.ПоследнийФрагментЛкс(Результат);
	КонецЕсли;
	Возврат Результат;
КонецФункции

Процедура ОчиститьДоступныеВременныеТаблицы(ТаблицаДоступныхТаблиц = Неопределено) Экспорт

	Если ТаблицаДоступныхТаблиц = Неопределено Тогда
		ТаблицаДоступныхТаблиц = ДоступныеТаблицы;
	КонецЕсли;
	ирОбщий.УдалитьСтрокиТаблицыИлиДереваПоЗначениюВКолонкеЛкс(ТаблицаДоступныхТаблиц, "Тип", "ВременнаяТаблица");
	
КонецПроцедуры

Процедура ОчиститьДоступныеНеВременныеТаблицы() Экспорт

	ДоступныеВременныеТаблицы = ДоступныеТаблицы.Выгрузить(Новый Структура("Тип", "ВременнаяТаблица"));
	ДоступныеТаблицы.Очистить();
	ДоступныеТаблицы.Загрузить(ДоступныеВременныеТаблицы);
	
КонецПроцедуры

Функция ПрефиксПараметра() Экспорт
	
	Возврат мПараметрыДиалектаSQL.ПрефиксПараметра;
	
КонецФункции

// Вызывает конструктор запросов и передает ему текст из текстового поля.
//
// Параметры:
//  Нет.
//
Функция ВызватьКонструкторЗапросов(Знач ИспользуемСобственныйКонструктор = Неопределено) Экспорт

	Если ирОбщий.ПроверитьПлатформаНеWindowsЛкс(,, Истина) Тогда
		Возврат Ложь;
	КонецЕсли; 
	#Если Сервер И Не Сервер Тогда
		мПлатформа = Обработки.ирПлатформа.Создать();
	#КонецЕсли
	РежимТолькоПросмотр = Ложь
		Или ПолеТекста.ТолькоПросмотр()
		Или ФормаВладелец.ТолькоПросмотр;
	Если РежимТолькоПросмотр Тогда
		Ответ = Вопрос("Текст запроса не может быть изменен. Открыть конструктор без возможности применения изменений?",
			РежимДиалогаВопрос.ОКОтмена);
		Если Ответ = КодВозвратаДиалога.Отмена Тогда
			Возврат Ложь;
		КонецЕсли;
	КонецЕсли;
	Если Не ирКэш.ЛиПлатформаWindowsЛкс() Тогда
		ИспользуемСобственныйКонструктор = Ложь
	КонецЕсли; 
	ПредпочитаюСобственныйКонструкторЗапроса = Ложь;
	Если ИспользуемСобственныйКонструктор = Неопределено Тогда
		ПредпочитаюСобственныйКонструкторЗапроса = ирОбщий.ВосстановитьЗначениеЛкс(ИмяКласса + ".ПредпочитаюСобственныйКонструкторЗапроса");
		Если ПредпочитаюСобственныйКонструкторЗапроса = Неопределено Тогда
			Ответ = Вопрос("Подсистема имеет собственный конструктор запроса. Приоритет его использования задается в настройках компоненты ""Контекстная подсказка"".
			|Хотите установить приоритет его использования?", РежимДиалогаВопрос.ДаНет);
			ПредпочитаюСобственныйКонструкторЗапроса = Ответ = КодВозвратаДиалога.Да;
			ирОбщий.СохранитьЗначениеЛкс(ИмяКласса + ".ПредпочитаюСобственныйКонструкторЗапроса", ПредпочитаюСобственныйКонструкторЗапроса);
		КонецЕсли; 
	КонецЕсли; 
	ИспользуемСобственныйКонструктор = Ложь
		Или ИспользуемСобственныйКонструктор = Истина
		Или мДиалектSQL <> "1С"
		Или ПредпочитаюСобственныйКонструкторЗапроса;
	Если ИспользуемСобственныйКонструктор Тогда
		Если ЯзыкПрограммы = 1 Тогда
			КопияКомпоненты = ЭтотОбъект;
			Если мМенеджерВременныхТаблиц <> Неопределено Тогда
				ОбновитьВычисляемыеДоступныеВременныеТаблицы();
			КонецЕсли;
		Иначе 
			КопияКомпоненты = КопияКомпоненты(); // чтобы не испортилось содержимое СлужебноеПолеТекстаДолгое этой компоненты
			КопияКомпоненты.СоздатьСлужебноеПоле();
			КопияКомпоненты.ОбновитьВычисляемыеДоступныеВременныеТаблицы();
		КонецЕсли;
		КонструкторЗапроса = КопияКомпоненты.ПолучитьФорму("КонструкторЗапроса");
		КонструкторЗапроса.Конфигурация = Конфигурация; 
	Иначе
		КонструкторЗапроса = Новый КонструкторЗапроса;
	КонецЕсли; 
	//ОбрамитьСобранныйТекстСкобками = Ложь;
	Если ЯзыкПрограммы = 1 Тогда
		Если СтрДлина(СокрЛП(ВыделенныйТекст())) < 6 И Не ЭтоЧастичныйЗапрос Тогда 
			ТекстЗапроса = ПолеТекста.ПолучитьТекст();
			НачальнаяСтрокаЗапроса = 0; 
			НачальнаяКолонкаЗапроса = 0;
		Иначе
			ТекстЗапроса = ВыделенныйТекст();
			//Если Не ЗначениеЗаполнено(ТекстЗапроса) И ЭтоЧастичныйЗапрос Тогда
			//	ТекстЗапроса = "ВЫБРАТЬ 1";
			//	ОбрамитьСобранныйТекстСкобками = Истина;
			//КонецЕсли; 
			НачальнаяСтрокаЗапроса = мНачальнаяСтрока - 1; 
			НачальнаяКолонкаЗапроса = мНачальнаяКолонка - 1;
		КонецЕсли;
		КонструкторЗапроса.РежимКомпоновкиДанных = РежимКомпоновкиДанных;
		//КонструкторЗапроса.АвтодобавлениеПредставлений = Истина;
		МассивВременныхТаблиц = Новый Массив;
		Если Не ПустаяСтрока(ТекстЗапроса) Тогда
			Если Истина
				И ТипЗнч(КонтекстВыполнения) = Тип("Запрос") 
				И Не ИспользуемСобственныйКонструктор
			Тогда
				СтарыйТекстЗапроса = ТекстЗапроса;
				ИнформацияОбОшибке = ПроверитьТекстИВернутьОшибку(ТекстЗапроса);
				Попытка
					ТекстЗапроса = мПлатформа.ЗамаскироватьВременныеТаблицы(КонтекстВыполнения, ТекстЗапроса, МассивВременныхТаблиц);
				Исключение
					ФормаВладелец.ТекущийЭлемент = ПолеТекста.ЭлементФормы;
					ирКлиент.ПоказатьОшибкуВТекстеПрограммыЛкс(ПолеТекста, , , Истина,, ИнформацияОбОшибке());
					Возврат Ложь;
				КонецПопытки;
				НоваяИнформацияОбОшибке = ПроверитьТекстИВернутьОшибку(ТекстЗапроса);
				Если Истина
					И НоваяИнформацияОбОшибке <> Неопределено
					И ИнформацияОбОшибке = Неопределено
					И Найти(ирОбщий.ПодробноеПредставлениеОшибкиЛкс(НоваяИнформацияОбОшибке), "Ожидается псевдоним запроса") > 0 
				Тогда
					// Сюда попадаем, когда у временной таблицы нет псевдонима
					ирОбщий.СообщитьСУчетомМодальностиЛкс("В запросе присутствуют временные таблицы без псевдонимов. "
						+ "Для максимальной функциональности рекомендуется задать каждой временной таблице псевдоним",, СтатусСообщения.Внимание);
					МассивВременныхТаблиц = Новый Массив;
					ТекстЗапроса = СтарыйТекстЗапроса;
                КонецЕсли; 
			КонецЕсли;
		КонецЕсли;
	Иначе
		// Мультиметка77248851
		РазобратьТекущийКонтекст();
		ТекстПоля = ПолеТекста.ПолучитьТекст();
		мРегВыражение.Global = Истина;
		мРегВыражение.MultiLine = Ложь;
		мРегВыражение.Pattern = шЛитералПрограммы;
		Результат = мРегВыражение.НайтиВхождения(ТекстПоля);
		Успех = Ложь;
		Для Каждого Вхождение Из Результат Цикл
			ПозицияВхождения = Вхождение.FirstIndex;
			Если Истина
				И (ПозицияВхождения + 1) <= мПозицияВТексте 
				И (ПозицияВхождения + Вхождение.Length) >= мПозицияВТексте 
			Тогда
				ПолеТекста.УстановитьГраницыВыделения(ПозицияВхождения + 1, ПозицияВхождения + 1 + Вхождение.Length);
				Успех = Истина;
				Прервать;
			КонецЕсли;
		КонецЦикла;
		
		ПолеТекста.ПолучитьГраницыВыделения(НачальнаяСтрокаЗапроса, НачальнаяКолонкаЗапроса, , );
		НачальнаяСтрокаЗапроса = НачальнаяСтрокаЗапроса - 1; 
		НачальнаяКолонкаЗапроса = НачальнаяСтрокаЗапроса - 1;
		Если Успех Тогда
			ТекстЗапроса = ВыделенныйТекст();
			Если Прав(ТекстЗапроса, 1) <> """" Тогда
				ТекстЗапроса = ТекстЗапроса + """";
			КонецЕсли; 
			ТекстЗапроса = Вычислить(ТекстЗапроса);
			ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "|", "");
		Иначе
			ТекстЗапроса = "";
		КонецЕсли;
	КонецЕсли;
	Если ИспользуемСобственныйКонструктор Тогда
		Парсер = мПлатформа.мПолучитьПарсер("ГрамматикаЯзыкаЗапросов");
		Если Парсер = Неопределено Тогда
			ирОбщий.СообщитьСУчетомМодальностиЛкс("Компонента анализа текста запроса не подключена");
			Возврат Ложь;
		КонецЕсли; 
	КонецЕсли; 
	Если Не ПустаяСтрока(ТекстЗапроса) Тогда
		Если ИспользуемСобственныйКонструктор Тогда
			РезультатРазбора = ЗагрузитьТекстВКонструктор(ТекстЗапроса, КонструкторЗапроса,, мДиалектSQL,, НачальнаяСтрокаЗапроса);
			Если Не РезультатРазбора Тогда
				Возврат Ложь;
			КонецЕсли; 
		Иначе
			СтруктуруРезультатаПакетногоЗапроса = мПлатформа.СтруктураРезультатаПакетногоЗапроса(ТекстЗапроса);
			Если СтруктуруРезультатаПакетногоЗапроса.Количество() > 0 Тогда
				Ответ = Вопрос("В комментариях обнаружены имена запросов. Стандартный конструктор запросов их удалит. Продолжить?", РежимДиалогаВопрос.ОКОтмена);
				Если Ответ <> КодВозвратаДиалога.ОК Тогда
					Возврат Ложь;
				КонецЕсли;
			КонецЕсли; 
			Попытка
				КонструкторЗапроса.Текст = ТекстЗапроса;
			Исключение
				ФормаВладелец.ТекущийЭлемент = ПолеТекста.ЭлементФормы;
				ирКлиент.ПоказатьОшибкуВТекстеПрограммыЛкс(ПолеТекста, НачальнаяСтрокаЗапроса, НачальнаяКолонкаЗапроса, Истина,, ИнформацияОбОшибке());
				Возврат Ложь;
			КонецПопытки;
		КонецЕсли; 
	Иначе
		Если ИспользуемСобственныйКонструктор Тогда
			//КонструкторЗапроса.УстановитьДиалектSQL(мДиалектSQL);
			КонструкторЗапроса.УстановитьДанные();  
		КонецЕсли; 
	КонецЕсли;
	РезультатФормы = КонструкторЗапроса.ОткрытьМодально();
	Если РезультатФормы = Истина Тогда
		Если Не РежимТолькоПросмотр Тогда
			НовыйТекстЗапроса = КонструкторЗапроса.Текст;
			Если Истина
				И ТипЗнч(Конфигурация) = Тип("ОбъектМетаданныхКонфигурация")
				И ТипЗнч(КонтекстВыполнения) = Тип("Запрос") 
			Тогда
				НовыйТекстЗапроса = мПлатформа.РазмаскироватьВременныеТаблицы(НовыйТекстЗапроса, МассивВременныхТаблиц);
			КонецЕсли;
			Если ЯзыкПрограммы = 1 Тогда
				Если Не ЭтоЧастичныйЗапрос И НачальнаяСтрокаЗапроса = 0 Тогда 
					ВыделитьВесьТекст();
				КонецЕсли; 
				//Если ОбрамитьСобранныйТекстСкобками Тогда
				//	НовыйТекстЗапроса = "(" + НовыйТекстЗапроса + ")";
				//КонецЕсли; 
				Если ИспользуемСобственныйКонструктор Тогда
					ЗаменитьВыделенныйТекстЗапросаСоСнятиемВыделения(НовыйТекстЗапроса, КонструкторЗапроса.мНомерТекущейСтрокиВСобранномТексте);
				Иначе
					ВыделенныйТекст(НовыйТекстЗапроса);
				КонецЕсли; 
				ПослеУстановкиВыделенногоМногострочногоТекста();
			Иначе
				НовыйТекстЗапроса = ирОбщий.ТекстВВыражениеВстроенногоЯзыкаЛкс(НовыйТекстЗапроса);
				ЧислоСтрокЗамены = СтрЧислоСтрок(НовыйТекстЗапроса);
				ТекстовыйДокумент = Новый ТекстовыйДокумент;
				ТекстовыйДокумент.УстановитьТекст(НовыйТекстЗапроса);
				СдвинутыйТекст = ТекстовыйДокумент.ПолучитьСтроку(1);
				ЗаменаТабуляции = ирОбщий.СтрокаПовторомЛкс(" ", мШиринаТабуляции);
				ТекстНачальнойСтроки = ПолеТекста.ПолучитьСтроку(мНачальнаяСтрока);
				ДлинаНачалаСтроки = СтрДлина(ТекстНачальнойСтроки) - СтрДлина(СокрЛ(ТекстНачальнойСтроки));
				НачалоСтроки = Лев(ТекстНачальнойСтроки, ДлинаНачалаСтроки);
				ДлинаРазвернутогоНачалаСтроки = СтрДлина(СтрЗаменить(НачалоСтроки, Символы.Таб, ЗаменаТабуляции));
				ЧислоТабуляций = ДлинаРазвернутогоНачалаСтроки / мШиринаТабуляции;
				ЧислоПробелов  = ДлинаРазвернутогоНачалаСтроки % мШиринаТабуляции;
				НачалоНовойСтроки = ирОбщий.СтрокаПовторомЛкс(Символы.Таб, ЧислоТабуляций);
				НачалоНовойСтроки = НачалоНовойСтроки + ирОбщий.СтрокаПовторомЛкс(" ", ЧислоПробелов);
				Для Счетчик = 2 По ЧислоСтрокЗамены Цикл
					ТекущаяСтрокаВставки = ТекстовыйДокумент.ПолучитьСтроку(Счетчик);
					СдвинутыйТекст = СдвинутыйТекст + Символы.ПС + НачалоНовойСтроки + ТекущаяСтрокаВставки;
				КонецЦикла;
				ВыделенныйТекст(СдвинутыйТекст);
				ПослеУстановкиВыделенногоМногострочногоТекста();
			КонецЕсли;
			Возврат Истина;
		КонецЕсли;
	КонецЕсли;
	Возврат Ложь;

КонецФункции

Функция РедактироватьВКонсолиЗапросов() Экспорт

	#Если Сервер И Не Сервер Тогда
		мПлатформа = Обработки.ирПлатформа.Создать();
	#КонецЕсли
	РежимТолькоПросмотр = Ложь
		Или ПолеТекста.ТолькоПросмотр()
		Или ФормаВладелец.ТолькоПросмотр;
	Если РежимТолькоПросмотр Тогда
		Ответ = Вопрос("Текст запроса не может быть изменен. Открыть консоль без возможности применения изменений?",
			РежимДиалогаВопрос.ОКОтмена);
		Если Ответ = КодВозвратаДиалога.Отмена Тогда
			Возврат Ложь;
		КонецЕсли;
	КонецЕсли;
	Текст = ПолеТекста.ПолучитьТекст();
	ВыделениеДвумерное = ПолеТекста.ВыделениеДвумерное();
	ПараметрыДляКонсоли = Новый ТаблицаЗначений;
	ПараметрыДляКонсоли.Колонки.Добавить("ИмяПараметра");
	ПараметрыДляКонсоли.Колонки.Добавить("Значение");
	ПараметрыДляКонсоли.Колонки.Добавить("ТипЗначения");
	Если Истина
		И мМенеджерВременныхТаблиц <> Неопределено
		И мМенеджерВременныхТаблиц.ПакетыЗапросов.Количество() > 0 
	Тогда
		ИмяКолонкиФлагаВнутриТаблицы = мПлатформа.ИмяКолонкиФлагаВнутриТаблицы();
		ПакетЗапросов = мМенеджерВременныхТаблиц.ПакетыЗапросов[мМенеджерВременныхТаблиц.ПакетыЗапросов.ВГраница()];
		Для Каждого КлючИЗначение Из ПакетЗапросов.Параметры Цикл
			СтрокаПараметра = ПараметрыДляКонсоли.Добавить();
			СтрокаПараметра.ИмяПараметра = КлючИЗначение.Ключ;
			ОписаниеТипов = Неопределено; // ОписаниеТипов
			ЗначениеПараметра = мПлатформа.ПодготовитьЗначениеПараметраЗапроса(КлючИЗначение.Значение, ОписаниеТипов);
			СтрокаПараметра.ТипЗначения = ОписаниеТипов;
			СтрокаПараметра.Значение = ЗначениеПараметра;
		КонецЦикла;
	КонецЕсли;
	Если Истина
		И мПлатформа.РедактироватьЗапрос(Текст, ПараметрыДляКонсоли,,,, ВыделениеДвумерное) 
		И Не РежимТолькоПросмотр 
	Тогда
		ВыделитьВесьТекст();
		ВыделенныйТекст(Текст);
		ПолеТекста.УстановитьВыделениеДвумерное(ВыделениеДвумерное);
		ПослеУстановкиВыделенногоМногострочногоТекста();
		Возврат Истина;
	КонецЕсли;
	Возврат Ложь;

КонецФункции

Функция РедактироватьВКонсолиКода() Экспорт

	РежимТолькоПросмотр = Ложь
		Или ПолеТекста.ТолькоПросмотр()
		Или ФормаВладелец.ТолькоПросмотр;
	Если РежимТолькоПросмотр Тогда
		Ответ = Вопрос("Текст запроса не может быть изменен. Открыть консоль без возможности применения изменений?",
			РежимДиалогаВопрос.ОКОтмена);
		Если Ответ = КодВозвратаДиалога.Отмена Тогда
			Возврат Ложь;
		КонецЕсли;
	КонецЕсли;
	ФормаКонсоли = ирКлиент.ПолучитьФормуЛкс("Обработка.ирКонсольКода.Форма", , , Новый УникальныйИдентификатор);
	ФормаКонсоли.мРежимРедактора = Истина;
	ФормаКонсоли.ПараметрТекст = ПолеТекста.ПолучитьТекст();
	Если Истина
		И ФормаКонсоли.ОткрытьМодально() <> Неопределено 
		И Не РежимТолькоПросмотр 
	Тогда
		ВыделитьВесьТекст();
		ВыделенныйТекст(ФормаКонсоли.РезультатФормы.Текст);
		ПослеУстановкиВыделенногоМногострочногоТекста();
		Возврат Истина;
	КонецЕсли;
	Возврат Ложь;

КонецФункции

Процедура ЗаменитьВыделенныйТекстЗапросаСоСнятиемВыделения(Знач НовыйТекстЗапроса, Знач НомерТекущейСтрокиВСобранномТексте = 0)
	
	ПолучитьНомерТекущейСтроки();
	ВыделенныйТекст(НовыйТекстЗапроса);
	мНачальнаяСтрока = мНачальнаяСтрока + НомерТекущейСтрокиВСобранномТексте; 
	мНачальнаяКолонка = 1;
	мКонечнаяСтрока = мНачальнаяСтрока;
	мКонечнаяКолонка = мНачальнаяКолонка;

КонецПроцедуры

Процедура ПоказатьТекущиеКоординаты(ПолеТекста, СтартоваяСтрокаДляОтображенияОшибок = 0)

	#Если Сервер И Не Сервер Тогда
		ПолеТекста = Обработки.ирОболочкаПолеТекста.Создать();
	#КонецЕсли
	Если ФормаВладелец = Неопределено Тогда
		Возврат;
	КонецЕсли;
	// Антибаг платформы 8.1 . Терялся фокус
	ФормаВладелец.ТекущийЭлемент = ПолеТекста.ЭлементФормы;
	ПолеТекста.ПоказатьОшибку(мПарсер.CurrentLineNumber() + СтартоваяСтрокаДляОтображенияОшибок, мПарсер.CurrentColumnNumber(), ФормаВладелец);

КонецПроцедуры

Функция ПолучитьКоординатыВТекстеЗапроса(ПолеТекста, СтартоваяСтрокаДляОтображенияОшибок = 0)
	
	НомерСтроки = СтартоваяСтрокаДляОтображенияОшибок + мПарсер.CurrentLineNumber();
	Результат = "";
	Если ПолеТекста <> Неопределено Тогда
		Результат = Результат + ирОбщий.ПредставлениеИзИдентификатораЛкс(ПолеТекста.ЭлементФормы.Имя) + ": ";
	КонецЕсли; 
	Результат = Результат + "Строка " + НомерСтроки + ": {(" + НомерСтроки + "," + мПарсер.CurrentColumnNumber() + ")}: ";
	Возврат Результат;
		
КонецФункции

Функция ПолучитьСтрокуОжидаемыхТокенов()

	СтрокаОжидаемыхТокенов = "";
	Для й = 0 по мПарсер.TokenCount() - 1 Цикл
		Токен = мПарсер.Tokens(й);
		СтрокаОжидаемыхТокенов = СтрокаОжидаемыхТокенов + ", " + Токен.Text;
	КонецЦикла;
	Возврат Сред(СтрокаОжидаемыхТокенов, 3);

КонецФункции

Функция _ПолучитьГраничныйТерминалПравила(Данные, ИндексГраницы = 0, ЗахватыватьКрайниеКомментарии = Ложь) Экспорт

	КоличествоТокенов = Данные.TokenCount;
	Для Сч1 = 1 По КоличествоТокенов Цикл
		Если ИндексГраницы = 1 Тогда
			УзелКандидат = Данные.Tokens(КоличествоТокенов - Сч1);
		Иначе
			УзелКандидат = Данные.Tokens(Сч1 - 1);
		КонецЕсли; 
		Если ТипЗнч(УзелКандидат.Data) = Тип("Строка") Тогда
			Если ЗахватыватьКрайниеКомментарии И ИндексГраницы = 1 И УзелКандидат.EndNoise <> Неопределено Тогда
				Возврат УзелКандидат.EndNoise;
			ИначеЕсли ЗахватыватьКрайниеКомментарии И ИндексГраницы = 0 И УзелКандидат.BeginNoise <> Неопределено Тогда
				Возврат УзелКандидат.BeginNoise;
			Иначе
				Возврат УзелКандидат;
			КонецЕсли; 
		ИначеЕсли ТипЗнч(УзелКандидат.Data) = Тип("COMОбъект") Тогда 
			Если УзелКандидат.Data.TokenCount > 0 Тогда 
				УзелСнизу = _ПолучитьГраничныйТерминалПравила(УзелКандидат.Data, ИндексГраницы, ЗахватыватьКрайниеКомментарии);
				Если УзелСнизу <> Неопределено Тогда
					Возврат УзелСнизу;
				КонецЕсли; 
			КонецЕсли;
		КонецЕсли;
	КонецЦикла;
	Возврат Неопределено;

КонецФункции

Функция ПолучитьТекстИзТокена(Токен, выхНачальнаяСтрока = 0, выхНачальнаяКолонка = 0, выхКонечнаяСтрока = 0, выхКонечнаяКолонка = 0, Знач СлужебноеПолеТекста = Неопределено) Экспорт

	Если Токен = Неопределено Тогда
		Возврат "";
	КонецЕсли; 
	НачальныйТокен = Токен.GetBorderToken(0);
	Если НачальныйТокен = Неопределено Тогда
		Возврат "";
	КонецЕсли; 
	выхНачальнаяКолонка = НачальныйТокен.ColumnNumber;
	выхНачальнаяСтрока = НачальныйТокен.LineNumber;
	КонечныйТокен = Токен.GetBorderToken(1);
	Если КонечныйТокен = Неопределено Тогда
		Возврат "";
	КонецЕсли; 
	выхКонечнаяКолонка = КонечныйТокен.ColumnNumber + СтрДлина(КонечныйТокен.Data);
	выхКонечнаяСтрока = КонечныйТокен.LineNumber + СтрЧислоСтрок(КонечныйТокен.Data) - 1; 
	Если СлужебноеПолеТекста = Неопределено Тогда
		СлужебноеПолеТекста = СлужебноеПолеТекстаДолгое;
	КонецЕсли;
	СлужебноеПолеТекста.УстановитьГраницыВыделения(выхНачальнаяСтрока, выхНачальнаяКолонка, выхКонечнаяСтрока, выхКонечнаяКолонка);
	ТекстОпределения = СлужебноеПолеТекста.ВыделенныйТекст;
	ТекстОпределения = СокрЛП(ТекстОпределения);
	Возврат ТекстОпределения;

КонецФункции

Функция _ПолучитьТекстИзДанныхТокена(ДанныеТокена, выхНачальнаяСтрока = 0, выхНачальнаяКолонка = 0, выхКонечнаяСтрока = 0, выхКонечнаяКолонка = 0) Экспорт

	НачальныйТокен = _ПолучитьГраничныйТерминалПравила(ДанныеТокена, 0);
	Если НачальныйТокен = Неопределено Тогда
		Возврат "";
	КонецЕсли; 
	выхНачальнаяКолонка = НачальныйТокен.ColumnNumber;
	выхНачальнаяСтрока = НачальныйТокен.LineNumber;
	КонечныйТокен = _ПолучитьГраничныйТерминалПравила(ДанныеТокена, 1);
	Если КонечныйТокен = Неопределено Тогда
		Возврат "";
	КонецЕсли; 
	выхКонечнаяКолонка = КонечныйТокен.ColumnNumber + СтрДлина(КонечныйТокен.Data);
	выхКонечнаяСтрока = КонечныйТокен.LineNumber + СтрЧислоСтрок(КонечныйТокен.Data) - 1;
	СлужебноеПолеТекстаДолгое.УстановитьГраницыВыделения(выхНачальнаяСтрока, выхНачальнаяКолонка, выхКонечнаяСтрока, выхКонечнаяКолонка);
	ТекстОпределения = СлужебноеПолеТекстаДолгое.ВыделенныйТекст;
	ТекстОпределения = СокрЛП(ТекстОпределения);
	Возврат ТекстОпределения;

КонецФункции

Функция ЗагрузитьТекстВКонструктор(ТекстЗапроса = Неопределено, Знач КонструкторЗапроса = Неопределено, Знач СокращенноеДерево = Ложь, ДиалектSQL = Неопределено,
	ИменованныеПараметры = Неопределено, СтартоваяСтрокаДляОтображенияОшибок = 0) Экспорт
	
	Если ТекстЗапроса = Неопределено Тогда
		ТекстЗапроса = ПолеТекста.ПолучитьТекст();
	КонецЕсли;
	Если КонструкторЗапроса <> Неопределено Тогда
		КонструкторЗапроса.УстановитьДиалектSQL(ДиалектSQL, ИменованныеПараметры);
	КонецЕсли; 
	ТаблицаКомментариев = Неопределено;
	БылиПотери = Неопределено;
	НачальныйТокен = РазобратьТекстЗапроса(ТекстЗапроса, СокращенноеДерево,,, Истина, ТаблицаКомментариев, БылиПотери, СтартоваяСтрокаДляОтображенияОшибок);
	Если Истина
		И НачальныйТокен <> Неопределено
		И КонструкторЗапроса <> Неопределено 
	Тогда
		КонструкторЗапроса.СлужебноеПолеТекстаДолгое.УстановитьТекст(ТекстЗапроса);
		Если ДиалектSQL = Неопределено Тогда
			ДиалектSQL = мДиалектSQL;
		КонецЕсли; 
		КонструкторЗапроса.ЗапросыПакета.Очистить();
		КонструкторЗапроса.УстановитьДанные(НачальныйТокен, ТаблицаКомментариев, БылиПотери,, ПолучитьНомерТекущейСтроки());
	КонецЕсли;
	Возврат НачальныйТокен <> Неопределено;
	
КонецФункции

// Возвращает начальный токен (Структура) построенной структуры запроса.
//
// Параметры:
//  ТекстЗапроса						 - 	 - 
//  СокращенноеДерево					 - 	 - 
//  ОбновлятьСостояние					 - 	 - 
//  пПолеТекста							 - ОбработкаОбъект.ирПолеТекста, Неопределено, Null - при Неопределено будет использоваться связанное поле, при Null поле не будет использоваться
//  СообщатьОПропущенныхТерминалах		 - 	 - 
//  выхТаблицаКомментариев				 - 	 - 
//  выхБылиПотери						 - 	 - 
//  СтартоваяСтрокаДляОтображенияОшибок	 - 	 - 
// 
// Возвращаемое значение:
//   - 
//
Функция РазобратьТекстЗапроса(ТекстЗапроса, СокращенноеДерево = Ложь, ОбновлятьСостояние = Истина, Знач пПолеТекста = Неопределено, СообщатьОПропущенныхТерминалах = Ложь, выхТаблицаКомментариев = Неопределено,
	выхБылиПотери = Неопределено, СтартоваяСтрокаДляОтображенияОшибок = 0, Знач ПоказыватьОшибки = Истина) Экспорт 

	#Если Сервер И Не Сервер Тогда
	    мПлатформа = Обработки.ирПлатформа.Создать();
	#КонецЕсли
	мПарсер = мПлатформа.мПолучитьПарсер("ГрамматикаЯзыкаЗапросов");
	Если мПарсер = Неопределено Тогда
		Возврат Неопределено;
	КонецЕсли;
	Если пПолеТекста = Null Тогда
		пПолеТекста = Неопределено;
	ИначеЕсли пПолеТекста = Неопределено Тогда
		пПолеТекста = ПолеТекста;
	Иначе
		пПолеТекста = ирКлиент.ОболочкаПоляТекстаЛкс(пПолеТекста);
	КонецЕсли; 
	Если ОбновлятьСостояние Тогда
		ирОбщий.СостояниеЛкс("Синтаксический разбор...");
	КонецЕсли; 
	выхТаблицаКомментариев = Новый ТаблицаЗначений;
	выхТаблицаКомментариев.Колонки.Добавить("Позиция", Новый ОписаниеТипов("Число"));
	выхТаблицаКомментариев.Колонки.Добавить("Текст", Новый ОписаниеТипов("Строка"));
	выхТаблицаКомментариев.Колонки.Добавить("ЭтоРасширение", Новый ОписаниеТипов("Булево"));
	gpMsgTokenRead			= 1;
	gpMsgReduction			= 2;
	gpMsgAccept				= 3;
	gpMsgNotLoadedError		= 4;
	gpMsgLexicalError		= 5;
	gpMsgSyntaxError 		= 6;
	gpMsgCommentError		= 7;
	gpMsgInternalError		= 8;
	gpMsgCommentBlockRead	= 9;
	gpMsgCommentLineRead	= 10;
	мПарсер.OpenTextString(ТекстЗапроса + Символы.ПС);
	Закончили = Ложь;
	//ПоследниеТокены = Новый Массив();
	ПоследнееПравилоНеКомментарий = Неопределено;
	TrimReductions = СокращенноеДерево;
	мПарсер.TrimReductions = СокращенноеДерево; // Была Истина
	Пока Не Закончили Цикл 
		ОбработкаПрерыванияПользователя();
		Ответ = мПарсер.Parse();
		Если Истина
			И СокращенноеДерево
			И TrimReductions <> Истина 
		Тогда
			мПарсер.TrimReductions = Истина;
			TrimReductions = Истина;
		КонецЕсли; 
		Если Ложь
			Или Ответ = gpMsgLexicalError 
			Или (Истина // Хотя Builder в этом случае диагностирует лексическую ошибку, этот парсер почему то бесконечно выдает статус 7
				И Ответ = 7 
				И мПарсер.CurrentReduction = Неопределено)
		Тогда
			мПарсер.PopInputToken();
			Закончили = Истина;
			Если ПоказыватьОшибки Тогда
				КоординатыВТекстеЗапроса = ПолучитьКоординатыВТекстеЗапроса(пПолеТекста, СтартоваяСтрокаДляОтображенияОшибок);
				ирОбщий.СообщитьСУчетомМодальностиЛкс(КоординатыВТекстеЗапроса + "Лексическая ошибка!",, СтатусСообщения.Важное);
				Если пПолеТекста <> Неопределено Тогда
					ПоказатьТекущиеКоординаты(пПолеТекста, СтартоваяСтрокаДляОтображенияОшибок);
				КонецЕсли;
			КонецЕсли;
		ИначеЕсли Ответ = gpMsgSyntaxError Тогда
			ТекущийТокен = мПарсер.CurrentToken;
			Если Истина
				И ТекущийТокен.Kind = 1 
				И (Ложь
					Или ТекущийТокен.Name = "MultiCommentLine"
					//Или ТекущийТокен.Name = "ExtensionBlock"
					Или ТекущийТокен.Name = "CommentBlock")
			Тогда
				Если СообщатьОПропущенныхТерминалах Тогда
					КоординатыВТекстеЗапроса = ПолучитьКоординатыВТекстеЗапроса(пПолеТекста, СтартоваяСтрокаДляОтображенияОшибок);
					ирОбщий.СообщитьСУчетомМодальностиЛкс(КоординатыВТекстеЗапроса + "Проигнорирован комментарий """ 
						+ СокрЛП(ТекущийТокен.Data) + """"
						//+ ", ожидается: " + ПолучитьСтрокуОжидаемыхТокенов()
						, , СтатусСообщения.Внимание);
				КонецЕсли; 
				мПарсер.PopInputToken();
			Иначе
				Закончили = Истина;
				Если ПоказыватьОшибки Тогда
					КоординатыВТекстеЗапроса = ПолучитьКоординатыВТекстеЗапроса(пПолеТекста, СтартоваяСтрокаДляОтображенияОшибок);
					ТекстОшибки = КоординатыВТекстеЗапроса + "Синтаксическая ошибка """ 
						+ ТекущийТокен.Data + """"
						+ ", ожидается: " + ПолучитьСтрокуОжидаемыхТокенов();
					ирОбщий.СообщитьСУчетомМодальностиЛкс(ТекстОшибки,, СтатусСообщения.Важное);
					Если пПолеТекста <> Неопределено Тогда
						ПоказатьТекущиеКоординаты(пПолеТекста, СтартоваяСтрокаДляОтображенияОшибок);
					КонецЕсли;
				КонецЕсли;
			КонецЕсли; 
		ИначеЕсли Ответ = gpMsgReduction Тогда
			Если СокращенноеДерево Тогда
				//ИмяПравила = мПарсер.CurrentReduction.ParentRule.RuleNonterminal.Name;
				ИмяПравила = мПарсер.CurrentRuleName();
				Если Ложь // Есть сомнения, что это работает как задумано
					Или ИмяПравила = "Table" 
					Или ИмяПравила = "TableName"
				Тогда
					мПарсер.TrimReductions = Ложь;
					TrimReductions = Ложь;
				КонецЕсли; 
			КонецЕсли; 
		ИначеЕсли Ответ = gpMsgAccept Тогда
			Закончили = Истина;
		ИначеЕсли Ответ = gpMsgCommentError Тогда
		ИначеЕсли Ответ = gpMsgTokenRead Тогда
			Если мПарсер.IsCurrentTokenComment() Тогда
				// Храним 2 последних токена
				ТекущийТокен = мПарсер.CurrentToken;
				ПрочитатьКомментарий(выхТаблицаКомментариев, ТекущийТокен, пПолеТекста, СообщатьОПропущенныхТерминалах, СтартоваяСтрокаДляОтображенияОшибок);
			КонецЕсли; 
		ИначеЕсли Ответ = gpMsgInternalError Тогда
			Закончили = Истина;
		ИначеЕсли Ответ = gpMsgNotLoadedError Тогда
			Закончили = Истина;
		КонецЕсли;
	КонецЦикла;
	Если ОбновлятьСостояние Тогда
		ирОбщий.СостояниеЛкс("");
	КонецЕсли; 
	Если Ответ = gpMsgAccept Тогда
		НачальныйТокен = Новый Структура("Data, LineNumber, ColumnNumber, Name, Kind",, 0, 0, "", 0);
		НачальныйТокен.Data = мПарсер.CurrentReduction; // Reduction {GoldParserForNet.Parser} - Почему то TypeLib не сам видит этот тип
		Возврат НачальныйТокен;
	Иначе
		Возврат Неопределено;
	КонецЕсли; 

КонецФункции

Процедура ПрочитатьКомментарий(Знач выхТаблицаКомментариев, Знач ТекущийТокен, Знач пПолеТекста, Знач СообщатьОПропущенныхТерминалах, Знач СтартоваяСтрокаДляОтображенияОшибок)
	
	ТекстКомментария = СокрЛП(ТекущийТокен.Data);
	МаркерХАРАКТЕРИСТИКИ = "ХАРАКТЕРИСТИКИ";
	ЭтоРасширение = Ложь;
	Если Лев(ТекстКомментария, 1) = "{" Тогда
		ТекстКомментария = Сред(ТекстКомментария, 2, СтрДлина(ТекстКомментария) - 2);
		ЭтоРасширение = мПараметрыДиалектаSQL.Это1С;
	ИначеЕсли Лев(ТекстКомментария, 2) = "//" Тогда
		ТекстКомментария = Сред(ТекстКомментария, 3);
	ИначеЕсли Лев(ТекстКомментария, 2) = "/*" Тогда
		ТекстКомментария = Сред(ТекстКомментария, 3, СтрДлина(ТекстКомментария) - 4);
	КонецЕсли; 
	Если ЭтоРасширение И Лев(ТекстКомментария, СтрДлина(МаркерХАРАКТЕРИСТИКИ)) = МаркерХАРАКТЕРИСТИКИ Тогда
		выхБылиПотери = Истина;
		Если СообщатьОПропущенныхТерминалах Тогда
			КоординатыВТекстеЗапроса = ПолучитьКоординатыВТекстеЗапроса(пПолеТекста, СтартоваяСтрокаДляОтображенияОшибок);
			ирОбщий.СообщитьСУчетомМодальностиЛкс(КоординатыВТекстеЗапроса + "Проигнорирован комментарий """ 
			+ СокрЛП(ТекущийТокен.Data) + """"
			//+ ", ожидается: " + ПолучитьСтрокуОжидаемыхТокенов()
			, , СтатусСообщения.Внимание);
		КонецЕсли; 
	ИначеЕсли ЗначениеЗаполнено(ТекстКомментария) Тогда 
		СтрокаРасширения = выхТаблицаКомментариев.Добавить();
		СтрокаРасширения.ЭтоРасширение = ЭтоРасширение;
		СтрокаРасширения.Позиция = ПолучитьОтносительнуюПозициюТокена(ТекущийТокен);
		СтрокаРасширения.Текст = ТекстКомментария; // Убираем крайние фигурные скобки
	КонецЕсли;

КонецПроцедуры

Функция ПолучитьОтносительнуюПозициюТокена(Токен) Экспорт 
	
	Результат = Токен.LineNumber * 1000 + Токен.ColumnNumber;
	Возврат Результат;
	
КонецФункции

// Вызывает конструктор запросов и передает ему текст из текстового поля.
// 
// Возвращаемое значение:
//   Булево - признак изменения текста
//
Функция ОткрытьРедакторСтроковогоЛитерала() Экспорт

	Если ирОбщий.ПроверитьПлатформаНеWindowsЛкс(,, Истина) Тогда
		Возврат Ложь;
	КонецЕсли; 
	РежимТолькоПросмотр = Ложь
		Или ПолеТекста.ТолькоПросмотр()
		Или ФормаВладелец <> Неопределено И ФормаВладелец.ТолькоПросмотр;
	Если РежимТолькоПросмотр Тогда
		Ответ = Вопрос("Текст не может быть изменен. Открыть редактор без возможности сохранения измений?",
			РежимДиалогаВопрос.ОКОтмена);
		Если Ответ = КодВозвратаДиалога.Отмена Тогда
			Возврат Ложь;
		КонецЕсли;
	КонецЕсли; 
	#Если Сервер И Не Сервер Тогда
		ПолеТекста = Обработки.ирОболочкаПолеТекста.Создать();
	#КонецЕсли
	РазобратьТекущийКонтекст(,,,,, Истина);
	ФормаРедактора = мПлатформа.ПолучитьФорму("Текст", , Новый УникальныйИдентификатор);
	ПараметрГраницыВыделения = ПолеТекста.ВыделениеДвумерное();
	ФормаРедактора.ПараметрГраницыВыделения = ПараметрГраницыВыделения;
	ТекстСтроковогоЛитерала = ВыделитьТекстовыйЛитерал(,,,,, Ложь);
	СмещениеКолонки = Найти(ПолеТекста.ПолучитьСтроку(ПараметрГраницыВыделения.НачальнаяСтрока), "|");
	Если СмещениеКолонки > 0 Тогда
		ПараметрГраницыВыделения.НачальнаяКолонка = Макс(1, ПараметрГраницыВыделения.НачальнаяКолонка - СмещениеКолонки);
		ПараметрГраницыВыделения.КонечнаяКолонка = Макс(1, ПараметрГраницыВыделения.КонечнаяКолонка - СмещениеКолонки);
	КонецЕсли;
	ГраницыЛитерала = ПолеТекста.ВыделениеДвумерное();
	Если ФормаВладелец = Неопределено Тогда
		мЗаменяемыйДиапазон = ПолеТекста.ВыделениеОдномерное();
	КонецЕсли;
	ПараметрГраницыВыделения.НачальнаяСтрока = ПараметрГраницыВыделения.НачальнаяСтрока - ГраницыЛитерала.НачальнаяСтрока + 1;
	ПараметрГраницыВыделения.КонечнаяСтрока = ПараметрГраницыВыделения.КонечнаяСтрока - ГраницыЛитерала.НачальнаяСтрока + 1;
	ФормаРедактора.НачальноеЗначениеВыбора = ТекстСтроковогоЛитерала;
	Если ПустаяСтрока(ТекстСтроковогоЛитерала) Тогда
		ФормаРедактора.ВариантПросмотра = "ЯзыкЗапросов";
	КонецЕсли;
	ФормаРедактора.мМенеджерВременныхТаблиц = мМенеджерВременныхТаблиц;
	ТекстИзменен = Ложь;
	Если ФормаРедактора.ОткрытьМодально() <> Неопределено Тогда
		Если Не РежимТолькоПросмотр Тогда
			НовыйТекст = ФормаРедактора.Текст; 
			Если НовыйТекст = ТекстСтроковогоЛитерала Тогда
				// Для TuboConf
			Иначе
				НовыйТекст = ирОбщий.ТекстВВыражениеВстроенногоЯзыкаЛкс(НовыйТекст);
				ЗаменаТабуляции = ирОбщий.СтрокаПовторомЛкс(" ", мШиринаТабуляции);
				ТекстНачальнойСтроки = ПолеТекста.ПолучитьСтроку(мНачальнаяСтрока);
				ДлинаНачалаСтроки = СтрДлина(ТекстНачальнойСтроки) - СтрДлина(СокрЛ(ТекстНачальнойСтроки));
				НачалоСтроки = Лев(ТекстНачальнойСтроки, ДлинаНачалаСтроки);
				ДлинаРазвернутогоНачалаСтроки = СтрДлина(СтрЗаменить(НачалоСтроки, Символы.Таб, ЗаменаТабуляции));
				ЧислоТабуляций = ДлинаРазвернутогоНачалаСтроки / мШиринаТабуляции;
				ЧислоПробелов  = ДлинаРазвернутогоНачалаСтроки % мШиринаТабуляции;
				НачалоНовойСтроки = ирОбщий.СтрокаПовторомЛкс(Символы.Таб, ЧислоТабуляций);
				НачалоНовойСтроки = НачалоНовойСтроки + ирОбщий.СтрокаПовторомЛкс(" ", ЧислоПробелов);
				НовыйТекст = СтрЗаменить(НовыйТекст, Символы.ПС, Символы.ПС + НачалоНовойСтроки);
				ВыделенныйТекст(НовыйТекст);
				ГраницыВыделенияНовые = ФормаРедактора.ПараметрГраницыВыделения;
				мНачальнаяСтрока = ГраницыВыделенияНовые.НачальнаяСтрока + ГраницыЛитерала.НачальнаяСтрока - 1;
				мКонечнаяСтрока = ГраницыВыделенияНовые.КонечнаяСтрока + ГраницыЛитерала.НачальнаяСтрока - 1;
				мНачальнаяКолонка = ГраницыВыделенияНовые.НачальнаяКолонка;
				мКонечнаяКолонка = ГраницыВыделенияНовые.КонечнаяКолонка;
				ТекстИзменен = Истина;
				Если ФормаВладелец = Неопределено Тогда
					мЗамещающийФрагмент = НовыйТекст;
				КонецЕсли;
			КонецЕсли;
		КонецЕсли;
	КонецЕсли;
	УстановитьГраницыВыделения();
	Возврат ТекстИзменен;

КонецФункции

Функция ОткрытьМодульВГите() Экспорт
	ПапкаГита = ГитРепозиторий();
	Если Не ЗначениеЗаполнено(ПапкаГита) Тогда
		ирКлиент.ОткрытьНастройкиПоляТекстаПрограммыНаЗаднемПланеЛкс("Укажите ""Гит репозиторий"" в открывшейся форме настроек");
		Возврат Ложь;
	КонецЕсли;
	ЛиМножественное = Истина;
	Фрагменты = ирОбщий.СтрРазделитьЛкс(мИмяМодуля);
	ИмяФайлаМодуляВГите = "src";
	Разделитель = ирОбщий.РазделительПутиКФайлуЛкс();
	ПроверочныйФайл = Новый Файл(ПапкаГита + Разделитель + ИмяФайлаМодуляВГите + Разделитель + "Configuration.xml");
	ЭтоЕДТ = Не ПроверочныйФайл.Существует();
	ЭтоФорма = Ложь;
	Если Фрагменты.Количество() = 1 Тогда
		ИмяФайлаМодуляВГите = "Ext" + Разделитель + Фрагменты[0];
	Иначе
		Для Индекс = 0 По Фрагменты.Количество() / 2 - 1 Цикл
			ИмяРус = Фрагменты[Индекс * 2];
			ИмяАнг = ирОбщий.ПеревестиИзРусскогоВАнглийскийЛкс(ИмяРус);
			Если ЛиМножественное Тогда
				ИмяАнг = ИмяАнг + "s"; 
			КонецЕсли;
			Если ИмяАнг = Неопределено Тогда
				ИмяАнг = ИмяРус;
			КонецЕсли;
			Если Не ПустаяСтрока(ИмяФайлаМодуляВГите) Тогда
				ИмяФайлаМодуляВГите = ИмяФайлаМодуляВГите + Разделитель;
			КонецЕсли;
			ИмяФайлаМодуляВГите = ИмяФайлаМодуляВГите + ИмяАнг;
			ИмяФайлаМодуляВГите = ИмяФайлаМодуляВГите + Разделитель + Фрагменты[Индекс * 2 + 1];
			Если Истина
				И Фрагменты[Индекс * 2 + 2] = "Форма" 
				И Фрагменты[Индекс * 2 + 3] = "Модуль" 
			Тогда
				ЭтоФорма = Истина;
				Прервать;
			КонецЕсли;
		КонецЦикла; 
	КонецЕсли;
	ИмяСвойстваАнг = Фрагменты[Фрагменты.ВГраница()];
	ИмяАнг = ирОбщий.ПеревестиИзРусскогоВАнглийскийЛкс(ИмяСвойстваАнг);
	Если ИмяАнг <> Неопределено Тогда
		ИмяСвойстваАнг = ИмяАнг;                                
	КонецЕсли;
	Если Не ЭтоЕДТ Тогда
		ИмяФайлаМодуляВГите = ИмяФайлаМодуляВГите + Разделитель + "Ext";
		Если ЭтоФорма Тогда
			ИмяФайлаМодуляВГите = ИмяФайлаМодуляВГите + Разделитель + "Form";
		КонецЕсли;
	КонецЕсли;
	ИмяФайлаМодуляВГите = ПапкаГита + Разделитель + ИмяФайлаМодуляВГите + Разделитель + ИмяСвойстваАнг + ".bsl"; 
	ДопПараметры = "";
	//КопироватьФайл(мПлатформа.ФайлМодуляИзИмениМодуля(мИмяМодуля).ПолноеИмя, ИмяФайлаМодуляВГите); // Затираем файл в рабочем каталоге!
	//ДопПараметры = "-n"; // Всегда новое приложежние, т.к. будем туда вставлять текст и потому нужно чтобы оно сразу активировало свое окно
	ирОбщий.ЗапуститьСкрытоеПриложениеИДождатьсяЗавершенияЛкс("code -g """+ ИмяФайлаМодуляВГите +""":"+XMLСтрока(мНачальнаяСтрока) + " " + ДопПараметры);
	Возврат Истина;
КонецФункции

// По текущей позиции, которая хранится в переменной мПозицияВТексте
Функция ВыделитьТекстовыйЛитерал(Знач ПолеТекстаЛ = Неопределено, выхНачальнаяПозиция0 = 0, выхКонечнаяПозиция0 = 0, Знач РазбиратьКонтекст = Истина, выхВыражение = "",
	Знач РазрешитьПотерюКомментариев = Истина) Экспорт 
	
	#Если Сервер И Не Сервер Тогда
		ПолеТекста = Обработки.ирОболочкаПолеТекста.Создать();
	#КонецЕсли
	Если РазбиратьКонтекст Тогда
		РазобратьТекущийКонтекст();
	КонецЕсли;
	Если ПолеТекстаЛ = Неопределено Тогда
		ПолеТекстаЛ = ПолеТекста;
	Иначе
		ПолеТекстаЛ = ирКлиент.ОболочкаПоляТекстаЛкс(ПолеТекстаЛ);
	КонецЕсли;
	// Мультиметка77248851
	ТекстПоля = ПолеТекстаЛ.ПолучитьТекст();
	мРегВыражение.Global = Истина;
	мРегВыражение.MultiLine = Ложь;
	мРегВыражение.Pattern = шЛитералПрограммы;
	Результат = мРегВыражение.НайтиВхождения(ТекстПоля);
	Успех = Ложь;
	Для Каждого Вхождение Из Результат Цикл
		ПозицияВхождения = Вхождение.FirstIndex;
		Если Истина
			И (ПозицияВхождения + 1) <= мПозицияВТексте 
			И (ПозицияВхождения + Вхождение.Length) >= мПозицияВТексте 
		Тогда
			ПолеТекстаЛ.УстановитьГраницыВыделения(ПозицияВхождения + 1, ПозицияВхождения + 1 + Вхождение.Length,, ФормаВладелец);
			Успех = Истина;
			выхНачальнаяПозиция0 = ПозицияВхождения;
			выхКонечнаяПозиция0 = ПозицияВхождения + Вхождение.Length;
			Прервать;
		КонецЕсли;
	КонецЦикла;
	Если Успех Тогда
		выхВыражение = ПолеТекстаЛ.ВыделенныйТекст();
		ТекстСтроковогоЛитерала = ирОбщий.ТекстИзВстроенногоЯзыкаЛкс(выхВыражение, РазрешитьПотерюКомментариев);
	Иначе
		ТекстСтроковогоЛитерала = Неопределено;
	КонецЕсли;
	Возврат ТекстСтроковогоЛитерала;

КонецФункции

// Осуществляет переход к определению контекста.
//
// Параметры:
//  Нет.
//
Функция ПерейтиКОпределению(НомерСтроки = 0, НомерКолонки = 0, РазрешитьДиалоги = Истина) Экспорт 
	
	#Если Сервер И Не Сервер Тогда
		ПолеТекста = Обработки.ирОболочкаПолеТекста.Создать();
	#КонецЕсли
	Если ирОбщий.ПроверитьПлатформаНеWindowsЛкс(,, Истина) Тогда
		Возврат Неопределено;
	КонецЕсли;
	РазобратьТекущийКонтекст(,,, НомерСтроки, НомерКолонки, Истина);
	Если ПустаяСтрока(мКонтекст) Тогда
		Возврат Неопределено;
	КонецЕсли;
	Результат = Новый СписокЗначений;
	ПоследнееВхождение = Неопределено;
	ПоследнееОпределение = Неопределено;
	НайтиОпределениеСлова(мКонтекст, ПоследнееОпределение, ПоследнееВхождение);
	Если мЯзыкПрограммы = 0 Тогда 
		Если Истина
			И ПоследнееВхождение <> Неопределено  
			И Не ирОбщий.СтрКончаетсяНаЛкс(мКонтекст, "(")
		Тогда
			ВыделениеДвумерное = ВыделениеДвумерноеИзПозиции(мПозицияТекстаДляПоискаОпределения + ПоследнееВхождение.FirstIndex + Найти(ПоследнееВхождение.Value, ПоследнееОпределение) - 1 + 1);
			Результат.Добавить(СсылкаСтрокиМодуля(ВыделениеДвумерное.НачальнаяСтрока,, ВыделениеДвумерное.НачальнаяКолонка), "Локальный"); 
		КонецЕсли;
		Если мЭтоТекстовыйЛитерал Тогда
			ЗаполнитьТаблицуСлов();
			СтрокаСлова = ТаблицаСлов.Найти(мКонтекст);
			Если Истина
				И СтрокаСлова <> Неопределено
				И мТаблицаТиповКонтекста[0].СтрокаОписания <> Неопределено
				И мТаблицаТиповКонтекста[0].СтрокаОписания.ТипКонтекста = "ВременныеТаблицыЗапроса"
			Тогда
				ИмяТаблицы = СтрокаСлова.Слово;
				ПакетЗапросов = Неопределено; // см. НовыйПакетЗапросов()
				ИндексЗапроса = Неопределено;
				НайтиЗапросВременнойТаблицы(ИмяТаблицы, мТаблицаТиповКонтекста[0].Метаданные, мТаблицаТиповКонтекста[0].ДержательМетаданных, ИндексЗапроса); 
				Если ИндексЗапроса <> Неопределено Тогда
					ДобавитьПереходыИзСтруктурыТипаВСписокВыбора(мТаблицаТиповКонтекста[0], Результат,, Истина);
				КонецЕсли;
			КонецЕсли;
		КонецЕсли;
		ТаблицаТипов = Неопределено; 
		СтруктураСловаОбъекта = Неопределено;
		Если Ложь
			Или мЭтоТекстовыйЛитерал
			Или ЛиВнутриКомментария()
		Тогда
			ФрагментыИмени = ирОбщий.СтрРазделитьЛкс(мКонтекст);
			Если ФрагментыИмени.Количество() > 1 Тогда
				Если ирОбщий.ЛиКорневойТипМетаданныхЛкс(ФрагментыИмени[0]) Тогда
					ИмяТипаМетаданных = ФрагментыИмени[ФрагментыИмени.ВГраница() - 1];
					Если ирОбщий.СтрокиРавныЛкс(ИмяТипаМетаданных, "ОбщаяФорма") Тогда
						ИмяТипаМетаданных = "Форма";
					КонецЕсли;
					Результат.Добавить(мКонтекст, ИмяТипаМетаданных + " " + ФрагментыИмени[ФрагментыИмени.ВГраница()],, ирКэш.КартинкаПоИмениЛкс("ирМетаданные")); 
					//ИмяМД = мКонтекст;
					//Если Метаданные.НайтиПоПолномуИмени(ИмяМД) = Неопределено Тогда
					//	ИмяМД = ирОбщий.СтрокаБезПоследнегоФрагментаЛкс(ИмяМД);
					//КонецЕсли;
					//Если Метаданные.НайтиПоПолномуИмени(ИмяМД) <> Неопределено Тогда
					//	Если РазрешитьДиалоги Тогда
					//		ирКлиент.ОткрытьОбъектМетаданныхЛкс(ИмяМД);
					//		Возврат Истина;
					//	//Иначе
					//	//	Результат.Добавить(ИмяМД, "Метаданные " + ИмяМД,, ирКэш.КартинкаПоИмениЛкс("ирМетаданные")); 
					//	КонецЕсли;
					//КонецЕсли;
				КонецЕсли;
				ЧастиИмени = ЧастиПолногоИмениЭлементаФормы(мКонтекст);
				Если ЧастиИмени <> Неопределено Тогда
					Форма = ирКлиент.ПассивнаяФормаПоИмениЛкс(ЧастиИмени.ИмяФормы);
					Если Форма <> Неопределено Тогда
						СтруктураСловаОбъекта = ВычислитьСловоФормыПоПолномуИмени(мКонтекст);
					КонецЕсли; 
				КонецЕсли;
			КонецЕсли;
			Если РазрешитьДиалоги Тогда
				Если СтруктураСловаОбъекта <> Неопределено Тогда 
					Если Прав(мКонтекст, 1) = "(" Тогда
						Если СтруктураСловаОбъекта.СтрокаОписания.ПозицияТела > 0 Тогда
							ирКлиент.ОткрытьМетодМодуляПоОпределениюЛкс(СтруктураСловаОбъекта.СтрокаОписания);
						КонецЕсли;
					Иначе 
						Форма.Открыть();
						ирКлиент.НачатьОтслеживаниеФормыЛкс(Форма);
						Если ЧастиИмени.ИмяФормы <> мКонтекст Тогда 
							Если СтруктураСловаОбъекта <> Неопределено Тогда
								Попытка
									Форма.ТекущийЭлемент = Форма.Элементы[СтруктураСловаОбъекта.Метаданные.Имя];
								Исключение
								КонецПопытки;
								Попытка
									Форма.ТекущийЭлемент = Форма.ЭлементыФормы[СтруктураСловаОбъекта.Метаданные.Имя];
								Исключение
								КонецПопытки;
							КонецЕсли;
						КонецЕсли;
					КонецЕсли;
					Возврат Истина;
				КонецЕсли;
				Если Ложь
					Или Найти(мКонтекст, ".Реквизит.") > 0
					Или Найти(мКонтекст, ".Измерение.") > 0
					Или Найти(мКонтекст, ".Ресурс.") > 0
				Тогда
					ОписаниеТаблицы = ирОбщий.ОписаниеТаблицыБДЛкс(ирОбщий.ПервыеФрагментыЛкс(мКонтекст));
					Если ОписаниеТаблицы <> Неопределено Тогда
						Форма = ирКлиент.ОткрытьКолонкуБДЛкс(ирОбщий.ПервыеФрагментыЛкс(мКонтекст), ирОбщий.ПоследнийФрагментЛкс(мКонтекст));
						Если Форма <> Неопределено Тогда
							Форма.Открыть();
							Возврат Истина;
						КонецЕсли;
					КонецЕсли;
				КонецЕсли;
				КорневоеСловоБД = "БД.";
				Если ирОбщий.СтрНачинаетсяСЛкс(мКонтекст, КорневоеСловоБД) Тогда
					ИмяКолонки = Сред(мКонтекст, СтрДлина(КорневоеСловоБД) + 1);
					Форма = ирКлиент.ОткрытьКолонкуБДЛкс(ИмяКолонки);
					Если Форма <> Неопределено Тогда
						Форма.Открыть();
						Возврат Истина;
					КонецЕсли;
				КонецЕсли;
			КонецЕсли;
			Если Истина
				И СтруктураСловаОбъекта = Неопределено
				И Найти(мКонтекст, "Объект.") > 0 
			Тогда
				ТаблицаТипов = ТаблицаТиповИзТекста("см. " + мКонтекст);
				Если ТаблицаТипов.Количество() > 0 Тогда
					СтруктураСловаОбъекта = ТаблицаТипов[0];
				КонецЕсли;
			КонецЕсли;
			Если СтруктураСловаОбъекта <> Неопределено Тогда 
				ДобавитьПереходыИзСтруктурыТипаВСписокВыбора(СтруктураСловаОбъекта, Результат);
			КонецЕсли;
			ИмяМетода = ирОбщий.ПервыйФрагментЛкс(мКонтекст, "(");
			Если ирОбщий.ЛиИмяПеременнойЛкс(ИмяМетода) Тогда
				МетодМодуля = мПлатформа.СтрокаМетодаМодуляПоИмени(мМодульМетаданных, ИмяМетода);
				Если МетодМодуля <> Неопределено И МетодМодуля.ПозицияТела <> 0 Тогда
					ПерейтиКОпределениюЛокальногоМетода(МетодМодуля);
					Возврат Истина;
				КонецЕсли;
			КонецЕсли;
			Если Истина
				И СтрЧислоВхождений(мКонтекст, ".") = 1 
				И Найти(мКонтекст, "(") = 0 
				И Метаданные.ОбщиеМодули.Найти(ирОбщий.ПервыйФрагментЛкс(мКонтекст)) <> Неопределено
			Тогда 
				Если Истина
					И мМодульМетаданных <> Неопределено 
					И ирОбщий.СтрНачинаетсяСЛкс(мИмяМодуля, "ОбщийМодуль." + ФрагментыИмени[0]) 
				Тогда 
					МетодМодуля = мПлатформа.СтрокаМетодаМодуляПоИмени(мМодульМетаданных, ФрагментыИмени[1]);
					Если МетодМодуля <> Неопределено Тогда
						ПерейтиКОпределениюЛокальногоМетода(МетодМодуля);
						Возврат Истина;
					КонецЕсли;
				КонецЕсли;
				АнализаторКода = ирОбщий.НовыйАнализаторКодаЛкс();
				АнализаторКода.ИнициироватьНеинтерактивно();
				ТаблицаТипов = АнализаторКода.ВычислитьТипЗначенияВыражения(мКонтекст + "(");
			КонецЕсли;
		КонецЕсли;
		ТаблицаТиповРодителя = ВычислитьТипЗначенияВыражения(мРодительскийКонтекст, мТекстДляПоискаОпределения, мПредшествующийТекст, Истина);
		Если ТаблицаТипов = Неопределено Тогда
			ПараметрыМетода = мПлатформа.ПараметрыМетодаМодуля(мМетодМодуля);
			Если ПараметрыМетода <> Неопределено Тогда
				СтрокаПараметра = ПараметрыМетода.Найти(НРег(мКонтекст), "НИмя");
				Если СтрокаПараметра <> Неопределено Тогда
					ПерейтиКОпределениюЛокальногоМетода(мМетодМодуля, СтрокаПараметра.Имя);
					Возврат Истина;
				КонецЕсли;
			КонецЕсли;
			СтрокаПеременной = мМодульМетаданных.Переменные.Найти(НРег(мКонтекст), "НИмя");
			Если СтрокаПеременной <> Неопределено Тогда
				Если СтрокаПеременной.ПозицияСОписанием <> 0 Тогда
					ПолеТекста.УстановитьГраницыВыделения(СтрокаПеременной.ПозицияСОписанием, СтрокаПеременной.ПозицияСОписанием,,,, ФормаВладелец);
					ВыделитьДиапазонОдномерныйДляПользователя(СтрокаПеременной.ПозицияСОписанием, СтрокаПеременной.ПозицияСОписанием + СтрДлина("Перем " + СтрокаПеременной.Имя));
				КонецЕсли;
				Возврат Истина;
			КонецЕсли;
			ТаблицаТипов = ВычислитьТипЗначенияВыражения(мКонтекст, мТекстДляПоискаОпределения, мПредшествующийТекст, Истина); // Если включить РазрешитьАнализИмениТипа, то для ПолучитьФорму("Справочник.Мо<>й") будет вычислять форму
			//ТаблицаТипов = ВычислитьТипЗначенияВыражения(мКонтекст, мТекстДляПоискаОпределения, мПредшествующийТекст, Ложь);
			Если Истина
				//И Прав(мКонтекст, 1) <> "("  
				И (Ложь
					Или мЭтоТекстовыйЛитерал
					Или ЛиВнутриКомментария())
				И (Ложь
					Или ТаблицаТипов.Количество() = 0
					Или (Истина
						И ТаблицаТипов[0].Детальность = 0
						И ТаблицаТипов[0].СтрокаОписания = Неопределено))
			Тогда
				ТаблицаТипов = ТаблицаТиповИзПолногоИмениМетодаИлиПараметра(мКонтекст);
			КонецЕсли;
		КонецЕсли;
		Если ТаблицаТипов <> Неопределено Тогда
			СтруктураТипаРодителя = Неопределено;
			Если ТаблицаТиповРодителя.Количество() > 0 Тогда
				СтруктураТипаРодителя = ТаблицаТиповРодителя[0];
			КонецЕсли;
			Для Каждого СтруктураТипа Из ТаблицаТипов Цикл
				ДобавитьПереходыИзСтруктурыТипаВСписокВыбора(СтруктураТипа, Результат, СтруктураТипаРодителя);
			КонецЦикла;
		КонецЕсли;
		Если Ложь
			Или ирОбщий.СтрКончаетсяНаЛкс(мПредшествующийТекст, "&Вместо(""") 
			Или ирОбщий.СтрКончаетсяНаЛкс(мПредшествующийТекст, "&После(""")
			Или ирОбщий.СтрКончаетсяНаЛкс(мПредшествующийТекст, "&Перед(""")
			Или ирОбщий.СтрКончаетсяНаЛкс(мПредшествующийТекст, "&Around(""") 
			Или ирОбщий.СтрКончаетсяНаЛкс(мПредшествующийТекст, "&After(""")
			Или ирОбщий.СтрКончаетсяНаЛкс(мПредшествующийТекст, "&Before(""")
		Тогда
			Результат.Очистить(); // Удаляем непрямую ссылку
			Результат.Добавить(, "Метод прямой",, ирКэш.КартинкаПоИмениЛкс("ирМетодыМодуля"));
		КонецЕсли;
		ИменаМД = ирОбщий.ИменаМетаданныхИзОписанияТиповЛкс(мКонтекст);
		Для Каждого ЭлементСписка Из ИменаМД Цикл
			ДобавитьТипДанныхВСписокПереходов(ЭлементСписка.Значение, Результат);
		КонецЦикла; 
		ВхожденияГиперСсылок = ирОбщий.НайтиРегВыражениеЛкс(мТекущаяСтрокаНачало + мТекущаяСтрокаКонец, мПлатформа.шГиперСсылка);
		Для Каждого Вхождение Из ВхожденияГиперСсылок Цикл
			Если Истина
				И СтрДлина(мТекущаяСтрокаНачало) >= Вхождение.ПозицияВхождения
				И СтрДлина(мТекущаяСтрокаНачало) <= Вхождение.ПозицияВхождения + Вхождение.ДлинаВхождения
			Тогда
				Результат.Добавить(Вхождение.ТекстВхождения, "ГиперСсылка",, ирКэш.КартинкаПоИмениЛкс("ирHttp"));
				Прервать;
			КонецЕсли;
		КонецЦикла;
		Результат.СортироватьПоПредставлению();
		Если РазрешитьДиалоги Тогда
			ВыбратьПереход(Результат);
		Иначе
			Если Результат.Количество() = 0 Тогда
				СтруктураСсылки = ирОбщий.СтруктураСсылкиСтрокиМодуляЛкс(мТекущаяСтрокаНачало);
				Если СтруктураСсылки <> Неопределено Тогда
					Результат.Добавить(СтруктураСсылки.ТекстСсылки); 
				КонецЕсли;
			КонецЕсли;
		КонецЕсли;
	ИначеЕсли мЯзыкПрограммы = 1 Тогда 
		Если ПоследнееВхождение <> Неопределено Тогда
			ЗапомнитьИсточникПерехода();
			Если ирОбщий.СтрКончаетсяНаЛкс(мКонтекст, "(") И мЯзыкПрограммы = 0 Тогда
				НачальнаяПозицияОпределения = 0;
			Иначе
				НачальнаяПозицияОпределения = мПозицияТекстаДляПоискаОпределения;
			КонецЕсли;
			НачальнаяПозицияОпределения = НачальнаяПозицияОпределения + ПоследнееВхождение.FirstIndex + Найти(ПоследнееВхождение.Value, ПоследнееОпределение);
			КонечнаяПозицияОпределения = НачальнаяПозицияОпределения + СтрДлина(ПоследнееОпределение);
			ВыделитьДиапазонОдномерныйДляПользователя(НачальнаяПозицияОпределения, КонечнаяПозицияОпределения);
			Результат = Истина;
		Иначе 
			ОписаниеТаблицыБД = ирОбщий.ОписаниеТаблицыБДЛкс(мКонтекст);
			Если ОписаниеТаблицыБД <> Неопределено Тогда
				ирКлиент.ОткрытьОбъектМетаданныхЛкс(ОписаниеТаблицыБД.ПолноеИмяМД);
				Результат = ОписаниеТаблицыБД.ПолноеИмяМД;
			Иначе
				ТаблицаТиповКонтекста = ВычислитьТипЗначенияВыражения(мРодительскийКонтекст, " " + мТекстДляПоискаОпределения, мПредшествующийТекст, Истина);
				Если ТаблицаТиповКонтекста.Количество() > 0 Тогда
					СтруктураТипаКонтекста = ТаблицаТиповКонтекста[0];
					ИмяТаблицы = мПлатформа.ИмяТипаИзСтруктурыТипа(СтруктураТипаКонтекста);
					ОписаниеТаблицыБД = ирОбщий.ОписаниеТаблицыБДЛкс(ИмяТаблицы);
					Если ОписаниеТаблицыБД <> Неопределено Тогда
						Если ОписаниеТаблицыБД.Тип = "ВиртуальнаяТаблица" Тогда
							ИмяТаблицы = ирОбщий.СтрокаБезПоследнегоФрагментаЛкс(ИмяТаблицы);
						КонецЕсли;
						ФормаКолонки = ирКлиент.ОткрытьКолонкуБДЛкс(ИмяТаблицы, мТекущееСлово);
						Если ФормаКолонки <> Неопределено Тогда
							Результат = ИмяТаблицы + "." + ФормаКолонки.РолиПоля + "." + мТекущееСлово;
							Если Не РазрешитьДиалоги Тогда
								ФормаКолонки.Закрыть();
							КонецЕсли;
						КонецЕсли;
					КонецЕсли;
				КонецЕсли;
			КонецЕсли;
		КонецЕсли;
	КонецЕсли;
	Если Истина
		И Не РазрешитьДиалоги
		И ТипЗнч(Результат) = Тип("СписокЗначений")
		И Результат.Количество() = 0 
	Тогда 
		//Результат.Добавить(мКонтекст); // Вредно, т.к. Турбоконф будет несколько секунд думать на непонятной ссылке
		Результат.Добавить("*"); 
	КонецЕсли;
	Возврат Результат;

КонецФункции

// Вызывается из адаптера
Функция ПерейтиВНачалоБлока() Экспорт
	КончитьОбработкуКоманды();
	ЗапомнитьИсточникПерехода();
	РазобратьТекущийКонтекст(,, Ложь);
	НоваяПозиция0ВМодуле = Неопределено;
	Результат = Ложь;
	Если мЭтоТекстовыйЛитерал Тогда
		ВыделитьТекстовыйЛитерал(, НоваяПозиция0ВМодуле);
	Иначе 
		СмещениеНачалаТела = 0;
		Если мМетодМодуля <> Неопределено Тогда
			СмещениеНачалаТела = мМетодМодуля.ПозицияТела - мМетодМодуля.ПозицияОпределения;
		КонецЕсли;
		Области = Неопределено; // см. РодителиПозицииВТексте()
		СтроитьДеревоПрограммныхСкобок(,, СмещениеНачалаТела + мПозицияВБлоке, Области,, Истина);
		Если Области = Неопределено Тогда
			// не метод
			Возврат Результат;
		КонецЕсли;
		СтрокаОбласти = Области.Добавить();
		СтрокаОбласти.Область = "<Метод>";
		СтрокаОбласти.ПозицияНачала = 1;
		НоваяПозиция0ВМодуле = Области[0].ПозицияНачала + мПозицияТекстаДляПоискаОпределения - СмещениеНачалаТела;
		НачалоСтроки = Сред(мОригинальныйТекст, НоваяПозиция0ВМодуле + 1, 200);
		НоваяПозиция0ВМодуле = НоваяПозиция0ВМодуле + СтрДлина(НачалоСтроки) - СтрДлина(СокрЛ(НачалоСтроки)); // Отрезаем лидирующие непечатные
	КонецЕсли;
	Если НоваяПозиция0ВМодуле <> Неопределено Тогда
		УстановитьГраницыВыделения(НоваяПозиция0ВМодуле + 1, НоваяПозиция0ВМодуле + 1);
		Результат = Истина;
	КонецЕсли;
	Возврат Результат;
КонецФункции

//.
// Параметры:
//    МетодМодуля - ? - 
Процедура ПерейтиКОпределениюЛокальногоМетода(МетодМодуля, Знач ИмяПараметра = "", Знач СмещениеСтрокиМетода = 0, Знач НомерКолонки = 1) Экспорт
	Если МетодМодуля.ПозицияТела = 0 Тогда
		Возврат;
	КонецЕсли; 
	//Если Истина
	//	И мПозицияВТексте >= МетодМодуля.ПозицияОпределения 
	//	И мПозицияВТексте < МетодМодуля.ПозицияОпределения 
	//Тогда
	//	НоваяПозиция = мПозицияВТексте;
	//КонецЕсли;
	РазобратьТекущийКонтекст();
	ЗапомнитьИсточникПерехода();
	Если Не ЗначениеЗаполнено(ИмяПараметра) Тогда
		НомерПервойСтрокиОпределенияМетода = НомерСтрокиИзПозиции(МетодМодуля.ПозицияОпределения);
		ВыделитьСтрокуВПолеТекста(НомерПервойСтрокиОпределенияМетода + СмещениеСтрокиМетода, НомерКолонки);
	Иначе
		Если ЛиВЗаголовкеМетода(МетодМодуля) Тогда
			НачалоОбласти = МетодМодуля.ПозицияСОписанием;
			КонецОбласти = МетодМодуля.ПозицияОпределения;
			ШаблонПоиска = "(" + мПлатформа.шПустоеНачалоСтроки + "//\s+)(#Слово#)(\s+-)";
		Иначе
			НачалоОбласти = МетодМодуля.ПозицияОпределения;
			КонецОбласти = МетодМодуля.ПозицияТела;
			ШаблонПоиска = "([\(,]\s*(?:Знач\s+)?)(#Слово#)(\s*[\),=])";
		КонецЕсли;
		Успех = ирКлиент.НайтиПоказатьФрагментВПолеТекстаЛкс(ФормаВладелец, ПолеТекста, ИмяПараметра, ШаблонПоиска, Истина,,, НачалоОбласти, КонецОбласти);
		Если Успех Тогда
			УстановитьФокус();
		КонецЕсли;
		ПолучитьГраницыВыделения();
	КонецЕсли;
КонецПроцедуры

//.
// Параметры:
//    МетодМодуля - ? - 
// Возвращаемое значение:
//    ? - 
Функция ЛиВЗаголовкеМетода(МетодМодуля = Неопределено) Экспорт
	Если МетодМодуля = Неопределено Тогда
		МетодМодуля = мМетодМодуля;
	КонецЕсли;
	Результат = Истина
		И МетодМодуля <> Неопределено
		И мПозицияВТексте < МетодМодуля.ПозицияТела 
		И мПозицияВТексте > МетодМодуля.ПозицияОпределения;
	Возврат Результат;
КонецФункции

Процедура ВыделитьДиапазонОдномерныйДляПользователя(Знач НачальнаяПозицияОпределения, Знач КонечнаяПозицияОпределения)
	
	СлужебноеПолеТекстаДолгое.УстановитьГраницыВыделения(НачальнаяПозицияОпределения, КонечнаяПозицияОпределения);
	СлужебноеПолеТекстаДолгое.ПолучитьГраницыВыделения(мНачальнаяСтрока, мНачальнаяКолонка, мКонечнаяСтрока, мКонечнаяКолонка); // Там текст без комментариев и опасных строковых литералов
	ПолеТекста.УстановитьГраницыВыделения(мНачальнаяСтрока, мНачальнаяКолонка, мКонечнаяСтрока, мКонечнаяКолонка,, ФормаВладелец); // Для ТуброКонфа

КонецПроцедуры

Процедура ОткрытьОпределениеСтруктурыТипа(Знач СтруктураТипа, Знач ЭтоОбщийТип = Ложь, Знач ИмяПараметраМетода = "") Экспорт 
	СписокВыбора = ДобавитьПереходыИзСтруктурыТипаВСписокВыбора(СтруктураТипа,,,, Истина);
	ВыбратьПереход(СписокВыбора, ЭтоОбщийТип, ИмяПараметраМетода);
КонецПроцедуры

//.
// Параметры:
//    СписокВыбора - Булево, СписокЗначений - 
//    ЭтоОбщийТип - Булево - 
//    ИмяПараметраМетода - Строка - применяется если выбрана НЕ строковая ссылка
Процедура ВыбратьПереход(Знач СписокВыбора, Знач ЭтоОбщийТип = Ложь, Знач ИмяПараметраМетода = "") Экспорт
	Если СписокВыбора.Количество() = 0 Тогда
		Возврат;
	ИначеЕсли СписокВыбора.Количество() > 1 Тогда 
		РезультатВыбора = ирКлиент.ВыбратьЭлементСпискаЗначенийЛкс(СписокВыбора,,, "Выберите переход",, Истина);
		Если РезультатВыбора = Неопределено Тогда
			Возврат;
		КонецЕсли;
	Иначе 
		РезультатВыбора = СписокВыбора[0];
	КонецЕсли;
	СтруктураСсылки = Неопределено;
	Если ТипЗнч(РезультатВыбора.Значение) = Тип("Строка") Тогда 
		СтруктураСсылки = ирОбщий.СтруктураСсылкиСтрокиМодуляЛкс(РезультатВыбора.Значение);
	КонецЕсли;
	Если СтруктураСсылки <> Неопределено Тогда
		ПерейтиПоСсылкеСтрокиМодуля(РезультатВыбора.Значение, Ложь);
	ИначеЕсли ирОбщий.ЛиСсылкаНаОбъектБДЛкс(РезультатВыбора.Значение) Тогда 
		ирКлиент.ОткрытьЗначениеЛкс(РезультатВыбора.Значение);
		//ирКлиент.ОткрытьСсылкуВРедактореОбъектаБДЛкс(РезультатВыбора.Значение);
	ИначеЕсли ирОбщий.СтрНачинаетсяСЛкс(РезультатВыбора.Представление, "Метод ") Тогда 
		ирКлиент.ОткрытьМетодМодуляПоОпределениюЛкс(РезультатВыбора.Значение, ИмяПараметраМетода, ЭтотОбъект);
	ИначеЕсли РезультатВыбора.Представление = "ГиперСсылка" Тогда 
		ЗапуститьПриложение(РезультатВыбора.Значение);
	ИначеЕсли ирОбщий.СтрНачинаетсяСЛкс(РезультатВыбора.Представление, "Справка") Тогда
		СтруктураТипа = РезультатВыбора.Значение;
		Если ЭтоОбщийТип Тогда
			ПутьКСлову = СтруктураТипа.ИмяОбщегоТипа;
		Иначе
			ПутьКСлову = мКонтекст;
		КонецЕсли;  
		НайтиПоказатьСправкуПоСтруктуреТипа(ПутьКСлову, СтруктураТипа);
	Иначе
		ПолноеИмяМД = ирОбщий.ПоследнийФрагментЛкс(РезультатВыбора.Значение, " ");
		Если ирОбщий.МножественноеИмяМДЛкс(ирОбщий.ПервыйФрагментЛкс(ПолноеИмяМД,, Ложь)) <> Неопределено Тогда 
			Если ирОбщий.СтрНачинаетсяСЛкс(РезультатВыбора.Представление, "Картинка") Тогда
				ирКлиент.ОткрытьЗначениеЛкс(БиблиотекаКартинок[ирОбщий.ПоследнийФрагментЛкс(ПолноеИмяМД)]);
			ИначеЕсли ирОбщий.СтрНачинаетсяСЛкс(РезультатВыбора.Представление, "Форма") Тогда
				ирКлиент.ПассивнаяФормаПоИмениЛкс(ПолноеИмяМД).Открыть();
			ИначеЕсли ирОбщий.СтрНачинаетсяСЛкс(РезультатВыбора.Представление, "Макет") Тогда
				ОбъектМД = Метаданные.НайтиПоПолномуИмени(ПолноеИмяМД);
				Макет = ирОбщий.ПолучитьМенеджерЛкс(ОбъектМД.Родитель()).ПолучитьМакет(ирОбщий.ПоследнийФрагментЛкс(ПолноеИмяМД));
				ирКлиент.ОткрытьЗначениеЛкс(Макет);
			Иначе 
				ирКлиент.ОткрытьОбъектМетаданныхЛкс(ПолноеИмяМД);
			КонецЕсли; 
		КонецЕсли;
	КонецЕсли;
КонецПроцедуры

//.
// Параметры:
//    СсылкаСтрокиМодуля - Строка - 
//    ТолькоЛокально - Булево - 
Функция ПерейтиПоСсылкеСтрокиМодуля(Знач СсылкаСтрокиМодуля, Знач ТолькоЛокально = Истина) Экспорт
	ЗапомнитьИсточникПерехода();
	Если ТипЗнч(СсылкаСтрокиМодуля) = Тип("Строка") Тогда
		СтруктураСсылки = ирОбщий.СтруктураСсылкиСтрокиМодуляЛкс(СсылкаСтрокиМодуля);
	КонецЕсли;         
	Если СтруктураСсылки = Неопределено Тогда
		Возврат Ложь;
	КонецЕсли; 
	Если СтруктураСсылки.Модуль = мМодульМетаданных.Имя Тогда
		ПозицияБлока = Неопределено;
		Если СтруктураСсылки.Метод = мПлатформа.ИмяМетодаИнициация() Тогда
			ПозицияБлока = мМодульМетаданных.ПозицияПрограммы;
			НомерСтроки = ирОбщий.СтрЧислоСтрокЛкс(Лев(мОригинальныйТекст, ПозицияБлока - 1)) + СтруктураСсылки.СмещениеСтрокиМетода - 1;
			ВыделитьСтрокуВПолеТекста(НомерСтроки, СтруктураСсылки.НомерКолонки);
		ИначеЕсли ЗначениеЗаполнено(СтруктураСсылки.Метод) Тогда 
			СтрокаМетода = мПлатформа.СтрокаМетодаМодуляПоИмени(мМодульМетаданных, СтруктураСсылки.Метод);
			Если СтрокаМетода <> Неопределено Тогда
				ПозицияБлока = СтрокаМетода.ПозицияТела;
				Если ПозицияБлока <> Неопределено Тогда
					ПерейтиКОпределениюЛокальногоМетода(СтрокаМетода, СтруктураСсылки.ПараметрМетода, СтруктураСсылки.СмещениеСтрокиМетода, СтруктураСсылки.НомерКолонки);
				КонецЕсли;
			КонецЕсли;
		КонецЕсли;
		Если ПозицияБлока = Неопределено Тогда
			ВыделитьСтрокуВПолеТекста(СтруктураСсылки.НомерСтроки, СтруктураСсылки.НомерКолонки);
		КонецЕсли;
		Возврат Истина;
	ИначеЕсли Не ТолькоЛокально Тогда 
		Если ЗначениеЗаполнено(СтруктураСсылки.Метод) Тогда
			Модуль = мПлатформа.МодульМетаданныхИзКэша(СтруктураСсылки.Модуль); 
			Если Модуль = Неопределено Тогда
				ВызватьИсключение "Некорректное имя модуля """ + СтруктураСсылки.Модуль + """";
			КонецЕсли;
			СтрокаМетода = мПлатформа.СтрокаМетодаМодуляПоИмени(Модуль, СтруктураСсылки.Метод);
			ирКлиент.ОткрытьМетодМодуляПоОпределениюЛкс(СтрокаМетода, СтруктураСсылки.ПараметрМетода,, СтруктураСсылки.СмещениеСтрокиМетода, СтруктураСсылки.НомерКолонки);
		Иначе 
			Если Не ирКлиент.ОткрытьСсылкуСтрокиМодуляЛкс(СсылкаСтрокиМодуля) Тогда 
				Если СтруктураСсылки.Модуль = мПлатформа.ИмяДинамическогоМодуля() Тогда 
					ФормаВладелец.Активизировать();
					ПолеТекстаЛ = ПолеТекста;
				Иначе
					ПолеТекстаЛ = ирКлиент.ОткрытьПолеТекстаМодуляКонфигурацииЛкс(СтруктураСсылки.Модуль).ПолеТекста;
				КонецЕсли;
				ПолеТекстаЛ.УстановитьГраницыВыделения(СтруктураСсылки.НомерСтроки, 1, СтруктураСсылки.НомерСтроки, 200, Истина);
			КонецЕсли;
		КонецЕсли;
	КонецЕсли;
	Возврат Ложь;
КонецФункции

//.
// Параметры:
//    НомерСтроки - Число - 
Процедура ВыделитьСтрокуВПолеТекста(Знач НомерСтроки, Знач НомерКолонки = 1) Экспорт
	УстановитьГраницыВыделения(НомерСтроки, НомерКолонки, НомерСтроки, НомерКолонки);
	ВыделитьТекущееСлово();
	Если СтрДлина(ВыделенныйТекст()) = 0 Тогда
		УстановитьГраницыВыделения(НомерСтроки, НомерКолонки, НомерСтроки, НомерКолонки + 1);
	КонецЕсли;
	ПолучитьГраницыВыделения();
КонецПроцедуры

// Процедура - Загрузить модуль метаданных
//
// Параметры:
//  Модуль	 - см. ОбработкаОбъект.ирПлатформа.МодульМетаданных() - 
//
Процедура ЗагрузитьМодульМетаданных(Модуль) Экспорт 
	мМодульМетаданных = Модуль;
	Если Модуль.Текст = Неопределено Тогда
		Модуль.Текст = мОригинальныйТекст;
	Иначе
		УстановитьТекстБезМетаданных(Модуль.Текст);
	КонецЕсли;
КонецПроцедуры

Функция ДобавитьПереходыИзСтруктурыТипаВСписокВыбора(Знач СтруктураТипа, Знач СписокВыбора = Неопределено, Знач СтруктураТипаРодителя = Неопределено, Знач ИскатьСозданиеТаблицы = Ложь,
	Знач ДобавлятьСправку = Ложь)
	
	Если СписокВыбора = Неопределено Тогда
		СписокВыбора = Новый СписокЗначений;
	КонецЕсли;
	Если Истина
		И ТипЗнч(СтруктураТипа.ДержательМетаданных) = Тип("Структура") 
		И (Ложь
			Или СтруктураТипа.ДержательМетаданных.Тип = Тип("МенеджерВременныхТаблиц") 
			Или СтруктураТипа.ДержательМетаданных.Тип = "ПакетЗапросов")
	Тогда 
		Если СтруктураТипа.ДержательМетаданных.Тип = Тип("МенеджерВременныхТаблиц") Тогда 
			МенеджерВременныхТаблиц = СтруктураТипа.ДержательМетаданных; // см. НовыйМенеджерВременныхТаблиц()
			Если МенеджерВременныхТаблиц.ПакетыЗапросов.Количество() > 0 Тогда
				ПакетЗапросов = МенеджерВременныхТаблиц.ПакетыЗапросов[МенеджерВременныхТаблиц.ПакетыЗапросов.ВГраница()];
			Иначе
				ПакетЗапросов = НовыйПакетЗапросов();
			КонецЕсли;
		Иначе
			// Колонка результата запроса
			ПакетЗапросов = СтруктураТипа.ДержательМетаданных; // см. НовыйПакетЗапросов()
		КонецЕсли;
		КоординатыТекстаЗапроса = ПакетЗапросов.КоординатыТекста; 
		Если КоординатыТекстаЗапроса <> Неопределено Тогда
			АнализаторКода = мПлатформа.ПолеТекстаМодуля(КоординатыТекстаЗапроса.Модуль);   
			АнализаторКода.мЯзыкПрограммы = 1; 
			АнализаторКода.ЗагрузитьМодульМетаданных(КоординатыТекстаЗапроса.Модуль);
			АнализаторКода.ЗагрузитьМетодМодуля(КоординатыТекстаЗапроса.Метод);
			НачальнаяПозицияПоиска = КоординатыТекстаЗапроса.Позиция0ВБлоке + 1;
			//АнализаторКода.мТекстДляПоискаОпределения = Сред(АнализаторКода.мТекстБлока, НачальнаяПозицияПоиска, КоординатыТекстаЗапроса.ДлинаТекста); // Полный текст
			АнализаторКода.мТекстДляПоискаОпределения = ПакетЗапросов.Текст;
			Позиции0Запросов = Новый Массив;
			ТекстыЗапросов = мПлатформа.РазбитьГрубоТекстПакетногоЗапросаНаЗапросы(АнализаторКода.мТекстДляПоискаОпределения,, Позиции0Запросов);
			Если ПакетЗапросов.Свойство("ИндексВПакете") Тогда
				//! ПакетЗапросов.Вставить("ИндексВПакете")
				ИндексВПакете = ПакетЗапросов.ИндексВПакете;
			Иначе 
				ИндексВПакете = ТекстыЗапросов.ВГраница();
			КонецЕсли;
			НачальнаяПозицияПоиска = НачальнаяПозицияПоиска + Позиции0Запросов[ИндексВПакете];
			АнализаторКода.мТекстДляПоискаОпределения = Сред(АнализаторКода.мТекстБлока, НачальнаяПозицияПоиска, СтрДлина(ТекстыЗапросов[ИндексВПакете]));
			ПоследнееВхождение = Неопределено;
			ПозицияВМетоде = НачальнаяПозицияПоиска; 
			Если ИскатьСозданиеТаблицы Тогда
				ПозицияВЛитерале = ирОбщий.НайтиРегВыражениеЛкс(АнализаторКода.мТекстДляПоискаОпределения, "ПОМЕСТИТЬ\s+" + ирОбщий.ПодготовитьТекстДляРегВыраженияЛкс(мТекущееСлово),, Ложь);
				Если ПозицияВЛитерале.Количество() > 0 Тогда
					ПозицияВМетоде = НачальнаяПозицияПоиска + ПозицияВЛитерале[0].ПозицияВхождения;
				КонецЕсли;
			Иначе 
				АнализаторКода.НайтиОпределениеСлова(мТекущееСлово,, ПоследнееВхождение);
				Если ПоследнееВхождение <> Неопределено Тогда
					ПозицияВМетоде = -1 + НачальнаяПозицияПоиска + ПоследнееВхождение.FirstIndex + ирОбщий.СтрНайтиЛкс(ПоследнееВхождение.Value, мТекущееСлово, Истина,,, Ложь);
				КонецЕсли;
			КонецЕсли;
			мПолеТекстаВременное.УстановитьТекст(АнализаторКода.мТекстБлока);
			мПолеТекстаВременное.УстановитьГраницыВыделения(ПозицияВМетоде, ПозицияВМетоде);
			НомерСтрокиМетода = 0;
			НомерКолонкиМетода = 0;
			мПолеТекстаВременное.ПолучитьГраницыВыделения(НомерСтрокиМетода, НомерКолонкиМетода, НомерСтрокиМетода, НомерКолонкиМетода);
			Если КоординатыТекстаЗапроса.Метод <> Неопределено Тогда
				ИмяМетода = КоординатыТекстаЗапроса.Метод.Имя;
			Иначе 
				ИмяМетода = мПлатформа.ИмяМетодаИнициация(); // Нужно в консоли кода при ЭтоМодуль=Ложь
				//ИмяМетода = "";
			КонецЕсли;
			КлючПерехода = ирОбщий.СсылкаСтрокиМодуляЛкс(КоординатыТекстаЗапроса.Модуль.Имя,, ИмяМетода, НомерСтрокиМетода,, НомерКолонкиМетода);
			Если СписокВыбора.НайтиПоЗначению(КлючПерехода) = Неопределено Тогда
				СписокВыбора.Добавить(КлючПерехода, "Запрос",, ирКэш.КартинкаПоИмениЛкс("ирЗапрос"));
			КонецЕсли;
		КонецЕсли;
	КонецЕсли;
	Если СтруктураТипа.СтрокаОписания <> Неопределено Тогда 
		ТаблицаВладелец = СтруктураТипа.СтрокаОписания.Владелец();
		#Если Сервер И Не Сервер Тогда
			ТаблицаВладелец = Новый ТаблицаЗначений;
		#КонецЕсли                           
		Если ТаблицаВладелец.Колонки.Найти("ЛиЭкспорт") <> Неопределено Тогда
			СтрокаСловаМодуля = СтруктураТипа.СтрокаОписания; // см. мМетодМодуля
			Если СтрокаСловаМодуля.Имя = "<>" И Не ПустаяСтрока(мРодительскийКонтекст) Тогда
				ВиртуальныйМетод = СтрокаСловаМодуля.Владелец().Добавить();
				ЗаполнитьЗначенияСвойств(ВиртуальныйМетод, СтрокаСловаМодуля);
				ВиртуальныйМетод.Имя = ирОбщий.ПервыйФрагментЛкс(мТекущееСлово, "(");
				ирОбщий.ОбновитьКопиюСвойстваВНижнемРегистреЛкс(ВиртуальныйМетод);
				СтрокаСловаМодуля = ВиртуальныйМетод;
			КонецЕсли;
			Если СтрокаСловаМодуля.Имя <> "<>" Тогда
				ДобавитьПереходНаСловоМодуляВСписокВыбора(СтрокаСловаМодуля, СписокВыбора);
				Если Найти(мТекущееСлово, "(") > 0 Тогда
					Для Каждого КлючИЗначение Из ирКэш.РасширенияКонфигурацииЛкс(Ложь) Цикл
						Расширение = КлючИЗначение.Ключ;
						ИмяРасширенияМодуля = Расширение.Имя + " " + СтрокаСловаМодуля.ИмяМодуля;
						ПолеТекстаМодуля = мПлатформа.ПолеТекстаМодуля(ИмяРасширенияМодуля);
						РасширениеМетода = ПолеТекстаМодуля.мМодульМетаданных.Методы.Найти(СтрокаСловаМодуля.Имя, "РасширяемыйМетод");
						Если РасширениеМетода <> Неопределено Тогда
							РасширениеМетода.ИмяМодуля = ИмяРасширенияМодуля;
							ДобавитьПереходНаСловоМодуляВСписокВыбора(РасширениеМетода, СписокВыбора, Расширение.Имя);
						КонецЕсли;
					КонецЦикла;
				КонецЕсли;
			КонецЕсли;
		ИначеЕсли ТаблицаВладелец.Колонки.Найти("Знач") <> Неопределено Тогда
			СтрокаПараметра = СтруктураТипа.СтрокаОписания; // см. мПлатформа.ПараметрыМетодаМодуля()[0]
			КлючПерехода = ирОбщий.СсылкаСтрокиМодуляЛкс(СтрокаПараметра.ИмяМодуля,, СтрокаПараметра.ИмяМетода,,,, СтрокаПараметра.Имя); // Колонки ИмяМодуля и ИмяМодуля добавляются тут Мультиметка4819233927 
			Если СписокВыбора.НайтиПоЗначению(КлючПерехода) = Неопределено Тогда
				СписокВыбора.Добавить(КлючПерехода, "Параметр метода",, ирКэш.КартинкаПоИмениЛкс("ирПараметрыМетода"));
			КонецЕсли;
		ИначеЕсли ТаблицаВладелец.Колонки.Найти("Значение") <> Неопределено Тогда
			СтрокаПоляБД = СтруктураТипа.СтрокаОписания; // см. Обработка.ирКонсольКода.Форма.Форма.Параметры[0]
			Если Истина
				И ирОбщий.ЛиСсылкаНаОбъектБДЛкс(СтрокаПоляБД.Значение)
				И ЗначениеЗаполнено(СтрокаПоляБД.Значение) 
			Тогда 
				КлючПерехода = СтрокаПоляБД.Значение;
				Если СписокВыбора.НайтиПоЗначению(КлючПерехода) = Неопределено Тогда
					СписокВыбора.Добавить(КлючПерехода, "Объект БД",, ирКэш.КартинкаПоИмениЛкс("ирСсылка"));
				КонецЕсли;
			КонецЕсли;
		ИначеЕсли Истина
			И ТаблицаВладелец.Колонки.Найти("ТипЗначения") <> Неопределено 
			И СтруктураТипа.СтрокаОписания.ТипЗначения = "Картинка"
			И ТипЗнч(СтруктураТипа.Метаданные) = Тип("ОбъектМетаданных")
		Тогда    
			КлючПерехода = СтруктураТипа.Метаданные.ПолноеИмя();  
			Если СписокВыбора.НайтиПоЗначению(КлючПерехода) = Неопределено Тогда
				СписокВыбора.Добавить(КлючПерехода, "Картинка " + СтруктураТипа.Метаданные.Имя,, ирКэш.КартинкаПоИмениЛкс("Картинка"));
			КонецЕсли;
		ИначеЕсли ТаблицаВладелец.Колонки.Найти("ТипКонтекста") <> Неопределено Тогда    
			ИмяТипа = "";
			ПрефиксИмениКоллекции = "";
			Если ТипЗнч(СтруктураТипа.Метаданные) = Тип("ОбъектМетаданных") Тогда 
				Если СтруктураТипа.СтрокаОписания.Слово = "ПолучитьМакет" Тогда
					ИмяТипа = "Макет";
					Картинка = ирКэш.КартинкаПоИмениЛкс("ирМакетКонфигурации");
				ИначеЕсли СтруктураТипа.СтрокаОписания.Слово = "ПолучитьФорму" Тогда
					ИмяТипа = "Форма";
					Картинка = ирКэш.КартинкаПоИмениЛкс("ирФорма"); 
				КонецЕсли;
			ИначеЕсли СтруктураТипа.СтрокаОписания.Слово = "ПолучитьОбщийМакет" Тогда
				ПрефиксИмениКоллекции = "Общие";
				ИмяТипа = "Макет";
				Картинка = ирКэш.КартинкаПоИмениЛкс("ирМакетКонфигурации");
			ИначеЕсли СтруктураТипа.СтрокаОписания.Слово = "ПолучитьОбщуюФорму" Тогда
				ПрефиксИмениКоллекции = "Общие";
				ИмяТипа = "Форма";
				Картинка = ирКэш.КартинкаПоИмениЛкс("ирФорма");
			КонецЕсли;
			Если ЗначениеЗаполнено(ИмяТипа) Тогда
				ОбъектМД = СтруктураТипа.Метаданные[ПрефиксИмениКоллекции + ирОбщий.МножественноеИмяМДЛкс(ИмяТипа)].Найти(мКонтекст); // см. Метаданные.Обработки.ирПлатформа
				Если ОбъектМД <> Неопределено Тогда
					КлючПерехода = ирОбщий.ПолноеИмяМДСРасширениемЛкс(ОбъектМД);
					Если СписокВыбора.НайтиПоЗначению(КлючПерехода) = Неопределено Тогда
						СписокВыбора.Добавить(КлючПерехода, ИмяТипа + " " + СтруктураТипа.Метаданные.Имя,, Картинка); 
					КонецЕсли;
				КонецЕсли;
			КонецЕсли;
			Если СтруктураТипаРодителя <> Неопределено Тогда
				ИмяТипа = "";
				Если ТипЗнч(СтруктураТипаРодителя.Метаданные) = Тип("ОбъектМетаданных") Тогда 
					Если СтруктураТипа.СтрокаОписания.Слово = "<Имя реквизита>" Тогда
						ИмяТипа = "Реквизит";
						Картинка = ирКэш.КартинкаПоИмениЛкс("ирРеквизит");
					ИначеЕсли СтруктураТипа.СтрокаОписания.Слово = "<Имя табличной части>" Тогда
						ИмяТипа = "ТабличнаяЧасть";
						Картинка = ирКэш.КартинкаПоИмениЛкс("ирТабличнаяЧасть");
					КонецЕсли;
				КонецЕсли;
				Если ЗначениеЗаполнено(ИмяТипа) Тогда
					ОбъектМД = СтруктураТипаРодителя.Метаданные[ПрефиксИмениКоллекции + ирОбщий.МножественноеИмяМДЛкс(ИмяТипа)].Найти(мТекущееСлово); // см. Метаданные.Обработки.ирПлатформа
					Если ОбъектМД <> Неопределено Тогда
						КлючПерехода = ирОбщий.ПолноеИмяМДСРасширениемЛкс(ОбъектМД);
						Если СписокВыбора.НайтиПоЗначению(КлючПерехода) = Неопределено Тогда
							СписокВыбора.Добавить(КлючПерехода, ИмяТипа + " " + мТекущееСлово,, Картинка);
						КонецЕсли;
					КонецЕсли;
				КонецЕсли;
			КонецЕсли;
		КонецЕсли;                                                        
	КонецЕсли; 
	Если ирОбщий.ЛиФормаИлиИмитаторЛкс(СтруктураТипа.ДержательМетаданных) Тогда
		КлючПерехода = ирОбщий.ПолноеИмяФормыЛкс(СтруктураТипа.ДержательМетаданных);
		Попытка
			ИмяЭлементаФормы = СтруктураТипа.Метаданные.Имя;
		Исключение
			ИмяЭлементаФормы = Неопределено;
		КонецПопытки;
		Если ИмяЭлементаФормы <> Неопределено Тогда
			Если ирОбщий.ЛиФормаИлиИмитаторЛкс(СтруктураТипа.ДержательМетаданных, Ложь) Тогда
				КлючПерехода = КлючПерехода + ".Элементы." + ИмяЭлементаФормы;
			Иначе 
				Если Истина
					И СтруктураТипа.ИмяОбщегоТипа <> "КнопкаКоманднойПанели"
					И СтруктураТипа.ИмяОбщегоТипа <> "КолонкаТабличногоПоля"
				Тогда
					КлючПерехода = КлючПерехода + ".ЭлементыФормы." + ИмяЭлементаФормы;
				КонецЕсли;
			КонецЕсли;
		КонецЕсли;
		Если СписокВыбора.НайтиПоЗначению(КлючПерехода) = Неопределено Тогда
			СписокВыбора.Добавить(КлючПерехода, "Форма",, ирКэш.КартинкаПоИмениЛкс("ирФорма"));
		КонецЕсли;
	КонецЕсли;       
	Если ТипЗнч(СтруктураТипа.Метаданные) = Тип("ОбъектМетаданных") Тогда
		КлючПерехода = ирОбщий.ПолноеИмяМДСРасширениемЛкс(СтруктураТипа.Метаданные);
		ДобавитьТипДанныхВСписокПереходов(КлючПерехода, СписокВыбора);
	КонецЕсли;
	Если ДобавлятьСправку Тогда
		СписокВыбора.Добавить(СтруктураТипа, "Справка",, ирКэш.КартинкаПоИмениЛкс("ирСинтаксПомощник")); // для кликов на типах в подсказке удержания HTML. Могут появляться дубли
	КонецЕсли;
	Возврат СписокВыбора;

КонецФункции

// .
//
// Параметры:
//  СтрокаМетода	 - СтрокаТаблицыЗначений - 
//  ИмяМодуля		 - Строка - надо передавать, т.к. атрибут строки метода заполнен не всегда, см. мПлатформа.ТаблицаТиповСловаМодуля()
//  СписокВыбора	 - Булево, СписокЗначений	 - 
//  ИмяРасширения	 - 							 - 
// 
// Возвращаемое значение:
//  Строка - 
//
Функция ДобавитьПереходНаСловоМодуляВСписокВыбора(Знач СтрокаСловаМодуля, Знач СписокВыбора, Знач ИмяРасширения = "") Экспорт
	КлючПерехода = ирКлиент.СсылкаСловаМодуляИзСтрокиСловаЛкс(СтрокаСловаМодуля);
	Если СтрокаСловаМодуля.Владелец().Колонки.Найти("ПозицияТела") <> Неопределено Тогда
		Представление = "Метод";
	Иначе 
		//Если СтрокаСловаМодуля.ПозицияОпределения = 0 Тогда // Наверное это невозможно
		//	Представление = "Реквизит";
		//Иначе 
			Представление = "Переменная";
		//КонецЕсли;
	КонецЕсли;
	Если СписокВыбора.НайтиПоЗначению(КлючПерехода) = Неопределено Тогда
		Если Представление = "Метод" Тогда
			Если ЗначениеЗаполнено(ИмяРасширения) Тогда
				ДобавкаПредставления = " " + ИмяРасширения;
			КонецЕсли;
			Картинка = ирКэш.КартинкаПоИмениЛкс("ирМетодыМодуля");
			Если Истина
				И Не ЗначениеЗаполнено(ИмяРасширения)
				И Найти(мРодительскийКонтекст, "(") = 0
				И Не ЛиВнутриКомментария()
				И Не мЭтоТекстовыйЛитерал
				И Не ирОбщий.ЛиВнутриПрепроцессораЛкс(мТекущаяСтрокаНачало)
				И (Ложь
					Или Метаданные.ОбщиеМодули.Найти(мРодительскийКонтекст) <> Неопределено 
					Или ирОбщий.ЕдинственноеИмяМДЛкс(ирОбщий.ПервыйФрагментЛкс(мРодительскийКонтекст)) <> Неопределено)
			Тогда
				СписокВыбора.Добавить(КлючПерехода, Представление + " прямой" + ДобавкаПредставления,, Картинка);
			Иначе  
				СписокВыбора.Добавить(КлючПерехода, Представление + " непрямой" + ДобавкаПредставления,, Картинка);
			КонецЕсли;
		Иначе 
			СписокВыбора.Добавить(КлючПерехода, Представление,, Картинка);
		КонецЕсли;
	КонецЕсли;
	Возврат КлючПерехода;
КонецФункции

Функция ПредставлениеЯзыкаВыражения() Экспорт 
	Если ЛиВнутриКомментария() Тогда 
		Результат = "Комментарий";
	ИначеЕсли мЯзыкПрограммы = 1 Тогда 
		Результат = "Запрос";
	ИначеЕсли мЭтоТекстовыйЛитерал Тогда 
		Результат = "Литерал";
	Иначе
		Результат = "Обычный";
	КонецЕсли;
	Возврат Результат;
КонецФункции

//.
// Параметры:
//    КлючПерехода - Строка - 
//    СписокВыбора - Булево, СписокЗначений - 
Функция ДобавитьТипДанныхВСписокПереходов(Знач КлючПерехода, Знач СписокВыбора = Неопределено) Экспорт
	Если СписокВыбора = Неопределено Тогда
		СписокВыбора = Новый СписокЗначений;
	КонецЕсли;
	Если СписокВыбора.НайтиПоЗначению(КлючПерехода) = Неопределено Тогда
		СписокВыбора.Добавить(КлючПерехода, "я Тип " + ирОбщий.ПоследнийФрагментЛкс(КлючПерехода, " "),, ирКэш.КартинкаПоИмениЛкс("ирМетаданные"));
	КонецЕсли;
	Возврат СписокВыбора;
КонецФункции

// Перед вызовом можно установить свойство мНачальнаяСтрока например через ПолучитьГраницыВыделения()
Функция СсылкаСтрокиМодуля(Знач НомерСтроки = 0, Знач Расширенная = Истина, Знач НомерКолонки = 0) Экспорт 
	ИмяМетода = "";
	Если Не ЗначениеЗаполнено(НомерСтроки) Тогда
		НомерСтроки = мНачальнаяСтрока;
	КонецЕсли;
	Если мМетодМодуля <> Неопределено Тогда
		ИмяМетода = мМетодМодуля.Имя;
		СмещениеСтрокиМетода = НомерСтроки - НомерСтрокиИзПозиции(мМетодМодуля.ПозицияОпределения);
	КонецЕсли;      
	Результат = ирОбщий.СсылкаСтрокиМодуляЛкс(мИмяМодуля, НомерСтроки, ИмяМетода, СмещениеСтрокиМетода, ПолеТекста.ПолучитьСтроку(НомерСтроки), НомерКолонки,, Расширенная);
	Возврат Результат;
КонецФункции

// Вызывается из адаптера
// Параметры:
//    Позиция - Число - начиная с 1
// Возвращаемое значение:
//    Число - 
Функция НомерСтрокиИзПозиции(ПозицияВМодуле) Экспорт
	НомерСтроки = ВыделениеДвумерноеИзПозиции(ПозицияВМодуле).КонечнаяСтрока;
	Возврат НомерСтроки;
КонецФункции

// Вызывается из адаптера
Функция ИмяТекущегоМетода() Экспорт 
	Если мМетодМодуля = Неопределено Тогда
		ИмяМетода = мПлатформа.ИмяМетодаИнициация();
	Иначе
		ИмяМетода = мМетодМодуля.Имя;
	КонецЕсли;
	Возврат ИмяМетода
КонецФункции

Функция ВыделениеДвумерноеИзПозиции(ПозицияВМодуле) Экспорт
	ОболочкаПоля = ирКлиент.ОболочкаПоляТекстаЛкс(СлужебноеПолеТекстаДолгое);
	Если ПозицияВМодуле = Неопределено Тогда
		Результат = ОболочкаПоля.НоваяСтруктураДвумерногоВыделения();
	Иначе 
		ОболочкаПоля.УстановитьГраницыВыделения(ПозицияВМодуле, ПозицияВМодуле);
		Результат = ОболочкаПоля.ВыделениеДвумерное();
	КонецЕсли;
	Возврат Результат;
КонецФункции

// Ищем в мТекстДляПоискаОпределения
Функция НайтиОпределениеСлова(Слово, ПоследнееОпределение = Неопределено, ПоследнееВхождение = Неопределено, выхПозицияУжеВОпределении = Ложь) Экспорт 
	                                 
	ПоследнееОпределение = Неопределено;
	Если мЯзыкПрограммы = 1 Тогда 
		ФрагментыСлова = ирОбщий.СтрРазделитьЛкс(Слово);
		Если ФрагментыСлова.Количество() < 3 Тогда
			ПсевдонимТаблицыИлиПоля = ФрагментыСлова[0];
			мРегВыражение.Global = Истина; 
			//мТекстДляПоискаОпределения = СтрЗаменить(мТекстДляПоискаОпределения, Символы.ПС + "|", Символы.ПС + " ");
			Если ЯзыкПрограммы = 0 Тогда
				мТекстДляПоискаОпределения = ЗалитьРазметкуТекстовогоЛитералаСохраняяПозиции(мТекстДляПоискаОпределения);
			КонецЕсли;
			мРегВыражение.Pattern = СтрЗаменить(шПоискОписанияТаблицы, "#Идентификатор#", ирОбщий.ПодготовитьТекстДляРегВыраженияЛкс(ПсевдонимТаблицыИлиПоля));
			ЛиНайденоИмяДоступнойТаблицы = Ложь;
			РезультатТекста = мРегВыражение.НайтиВхождения(мТекстДляПоискаОпределения);
			Если РезультатТекста.Количество() = 0 Тогда
				// Ищем явный псевдоним поля
				мРегВыражение.Pattern = "(ъъъ)?(ъъъ)?(\s*)?(" + шВыражениеЗапроса + ")?\s(?:КАК|AS)\s*" + ирОбщий.ПодготовитьТекстДляРегВыраженияЛкс(ПсевдонимТаблицыИлиПоля);
				РезультатТекста = мРегВыражение.НайтиВхождения(мТекстДляПоискаОпределения);
				Если РезультатТекста.Количество() = 0 Тогда
					// Ищем неявный псевдоним поля
					мРегВыражение.Pattern = "(ъъъ)?(ъъъ)?(\s*)?(" + шВыражениеЗапроса + "\s*\.\s*" + ирОбщий.ПодготовитьТекстДляРегВыраженияЛкс(ПсевдонимТаблицыИлиПоля) + ")\s*(?:,|ПОМЕСТИТЬ|INTO|ИЗ|FROM)";
					РезультатТекста = мРегВыражение.НайтиВхождения(мТекстДляПоискаОпределения);
					Если РезультатТекста.Количество() = 0 Тогда
						ПоследнееВхождение = Неопределено;
						ПоследнееОпределение = ПсевдонимТаблицыИлиПоля;
						ЛиНайденоИмяДоступнойТаблицы = Истина;
					КонецЕсли;
				КонецЕсли;
			КонецЕсли; 
			Если РезультатТекста.Количество() > 0 Тогда
				ПоследнееВхождение = РезультатТекста[0];
				НачалоЧасти = 0;
				Если мПозицияВТексте <> Неопределено Тогда
					мРегВыражение.Global = Ложь; 
					мРегВыражение.Pattern = "\sУПОРЯДОЧИТЬ\s|\ИТОГИ\s";
					Если мРегВыражение.НайтиВхождения(Лев(мТекстДляПоискаОпределения, мПозицияВБлоке)).Количество() = 0 Тогда
						НачалоЧасти = НачалоЧастиОбъединенияЗапроса(мТекстДляПоискаОпределения, мПозицияВБлоке);
						Для Каждого Вхождение Из РезультатТекста Цикл
							Если Вхождение.FirstIndex > НачалоЧасти Тогда
								ПоследнееВхождение = Вхождение;
								Прервать;
							КонецЕсли;
						КонецЦикла;
					КонецЕсли;
				КонецЕсли;
				ПоследнееОпределение = ПоследнееВхождение.SubMatches(3);
				Если Истина
					И ФрагментыСлова.Количество() = 1
					И мПозицияВТексте <> Неопределено
					И ПоследнееВхождение.FirstIndex > НачалоЧасти
					И ПоследнееВхождение.FirstIndex + 1 <= мПозицияВТексте 
					И ПоследнееВхождение.FirstIndex + 1 + СтрДлина(Слово) >= мПозицияВБлоке
				Тогда
					// Для вызова из консоли запросов в ведущей структуре запроса
					выхПозицияУжеВОпределении = Истина;
				КонецЕсли;
			КонецЕсли;
			ПакетЗапросов = Неопределено; // см. НовыйПакетЗапросов()
			ИндексЗапроса = Неопределено;
			НайтиЗапросВременнойТаблицы(ПоследнееОпределение,, ПакетЗапросов, ИндексЗапроса);
			Если ИндексЗапроса <> Неопределено Тогда
				Если ФрагментыСлова.Количество() = 2 Тогда
					Если Ложь
						Или ЯзыкПрограммы = 1
						Или ПакетЗапросов.КоординатыТекста.Модуль = мМодульМетаданных 
					Тогда
						ЗагрузитьЗапросПакетаПоИндексу(ПакетЗапросов, ИндексЗапроса);
						Возврат НайтиОпределениеСлова(ФрагментыСлова[1], ПоследнееОпределение, ПоследнееВхождение);
					КонецЕсли;
				Иначе 
					Если ПоследнееВхождение <> Неопределено Тогда
						лНачальнаяСтрока = 0;
						лНачальнаяКолонка = 0;
						лКонечнаяСтрока = 0;
						лКонечнаяКолонка = 0;
						НачальнаяПозицияВхождения = мПозицияТекстаДляПоискаОпределения + ПоследнееВхождение.FirstIndex + 1;
						СлужебноеПолеТекстаДолгое.УстановитьГраницыВыделения(НачальнаяПозицияВхождения, НачальнаяПозицияВхождения + СтрДлина(ПоследнееОпределение));
						СлужебноеПолеТекстаДолгое.ПолучитьГраницыВыделения(лНачальнаяСтрока, лНачальнаяКолонка, лКонечнаяСтрока, лКонечнаяКолонка);
						ЛиНайденоИмяДоступнойТаблицы = Истина
							И лНачальнаяСтрока = мНачальнаяСтрока И лНачальнаяКолонка <= мНачальнаяКолонка 
							И лКонечнаяСтрока = мКонечнаяСтрока И лКонечнаяКолонка >= мКонечнаяКолонка;
					КонецЕсли;
					Если Истина
						И ЛиНайденоИмяДоступнойТаблицы
						И (Ложь
							Или ЯзыкПрограммы = 1
							Или ПакетЗапросов.КоординатыТекста.Модуль = мМодульМетаданных)
					Тогда 
						ЗагрузитьЗапросПакетаПоИндексу(ПакетЗапросов, ИндексЗапроса);
						мРегВыражение.Global = Ложь;
						ШаблонСозданияТаблицы = "(?:" + шРазделитель + "|\|)+" + "(?:ПОМЕСТИТЬ|INTO(?:" + шРазделитель + "+TABLE)?)" + шРазделитель + "+(#Идентификатор#)" + шРазделитель;
						мРегВыражение.Pattern = СтрЗаменить(ШаблонСозданияТаблицы, "#Идентификатор#", ирОбщий.ПодготовитьТекстДляРегВыраженияЛкс(ПоследнееОпределение));
						РезультатТекста = мРегВыражение.НайтиВхождения(мТекстДляПоискаОпределения);
						Если РезультатТекста.Количество() > 0 Тогда
							ПоследнееОпределение = РезультатТекста[0].SubMatches(0);
							ПоследнееВхождение = ирОбщий.СоздатьОбъектПоИмениМетаданныхЛкс("Обработка.ирОболочкаРегВхождение");
							ЗаполнитьЗначенияСвойств(ПоследнееВхождение, РезультатТекста[0],, "SubMatches"); // Создаем неполноценный объект ради изменения свойства FirstIndex
							//ПоследнееВхождение.FirstIndex = ПоследнееВхождение.FirstIndex - мПозицияТекстаДляПоискаОпределения;
						КонецЕсли; 
					КонецЕсли;
				КонецЕсли;
			Иначе
				Если ФрагментыСлова.Количество() = 2 Или ПоследнееВхождение = Неопределено Тогда
					ПоследнееВхождение = Неопределено;
					ПоследнееОпределение = Неопределено;
				КонецЕсли;
			КонецЕсли;
		Иначе
			МаркерЗначение = "ЗНАЧЕНИЕ(";
			Если Прав(мПредшествующийТекст, СтрДлина(МаркерЗначение)) = МаркерЗначение Тогда
				мРегВыражение.Global = Ложь;
				мРегВыражение.Pattern = шИмя;
				Если мРегВыражение.Проверить(Слово) Тогда 
					Попытка
						ПредопределенноеЗначение = ПредопределенноеЗначение(Слово);
					Исключение
						ПредопределенноеЗначение = Неопределено;
					КонецПопытки; 
					Если ПредопределенноеЗначение <> Неопределено Тогда
						ОткрытьЗначение(ПредопределенноеЗначение);
					КонецЕсли; 
				КонецЕсли; 
			КонецЕсли; 
		КонецЕсли;
	Иначе
		мРегВыражение.Global = Истина;
		ЭкранированноеСлово = ирОбщий.ПодготовитьТекстДляРегВыраженияЛкс(ирОбщий.ПервыйФрагментЛкс(Слово, "("));
		Если ирОбщий.СтрКончаетсяНаЛкс(Слово, "(") Тогда
			// Ищем определение метода в тексте модуля
			мРегВыражение.Pattern = ирОбщий.СтрЗаменитьЛкс(мПлатформа.ШаблоныДляАнализаВстроенногоЯзыка().ОписаниеМетодаЧистое, шИмя, ЭкранированноеСлово);
			РезультатТекста = мРегВыражение.НайтиВхождения(мОригинальныйТекст);
		ИначеЕсли Лев(Слово, 1) = "~" Тогда 
			мРегВыражение.Pattern = мПлатформа.шПустоеНачалоСтроки + "(" + Слово + ":)";
			РезультатТекста = мРегВыражение.НайтиВхождения(мТекстДляПоискаОпределения);
		ИначеЕсли Ложь
			Или ирОбщий.СтрокиРавныЛкс(Слово, "Продолжить") 
			Или ирОбщий.СтрокиРавныЛкс(Слово, "Прервать") 
		Тогда
			РезультатТекста = Новый Массив;
			ГлубинаЦикла = 0;
			мРегВыражение.Pattern = мПлатформа.шПустоеНачалоСтроки + "(?:(Пока|Для)[^\n]*\s(Цикл)|КонецЦикла)";
			ВхожденияЕсли = мРегВыражение.НайтиВхождения(Лев(мТекстДляПоискаОпределения, мПозицияВТексте));
			Для ИндексВхожденияЕсли = -ВхожденияЕсли.ВГраница() По 0 Цикл
				ВхождениеЦикла = ВхожденияЕсли[-ИндексВхожденияЕсли];
				Токен = НРег(ВхождениеЦикла.SubMatches(1));
				Если Токен = "цикл" Тогда
					ГлубинаЦикла = ГлубинаЦикла + 1;
					Если ГлубинаЦикла > 0 Тогда
						РезультатТекста = ирОбщий.ЗначенияВМассивЛкс(ВхождениеЦикла);
						Прервать;
					КонецЕсли;
				Иначе
					ГлубинаЦикла = ГлубинаЦикла - 1;
				КонецЕсли;
			КонецЦикла;
		Иначе
			мРегВыражение.Pattern = шПредИмяПрямое + ЭкранированноеСлово + "(" + шПрисвоение + "|" + шОбходКоллекции + ")";
			РезультатТекста = мРегВыражение.НайтиВхождения(мТекстДляПоискаОпределения);
		КонецЕсли;
		Если РезультатТекста.Количество() > 0 Тогда
			ПоследнееВхождение = РезультатТекста[РезультатТекста.Количество() - 1];
			ПоследнееОпределение = ПоследнееВхождение.SubMatches(0);
			//Если ПоследнееВхождение.SubMatches(1) <> Неопределено Тогда
			//	// Это присвоение
			//	ПоследнееОпределение = ПоследнееВхождение.SubMatches(1);
			//Иначе
			//	// Это обход коллекции
			//	ПоследнееОпределение = ПоследнееВхождение.SubMatches(20);
			//КонецЕсли;
		КонецЕсли;
	КонецЕсли;
	Возврат ПоследнееОпределение;

КонецФункции

//.
// Возвращаемое значение:
//    Строка - 
Функция ЗалитьРазметкуТекстовогоЛитералаСохраняяПозиции(Знач Текст = "") Экспорт
	Если Не ЗначениеЗаполнено(Текст) Тогда
		Текст = мТекстДляПоискаОпределения;
	КонецЕсли;
	Если Лев(Текст, 1) = """" Тогда
		Текст = " " + Сред(Текст, 2);
	КонецЕсли; 
	Если Прав(Текст, 1) = """" Тогда
		Текст = Лев(Текст, СтрДлина(Текст) - 1) + " ";
	КонецЕсли;
	Текст = СтрЗаменить(Текст, "|", " ");
	Возврат Текст;
КонецФункции

// .
// Параметры:
//  ИмяТаблицы		 - 	 - 
//  ПакетЗапросов	 - см. НовыйПакетЗапросов() - 
// 
// Возвращаемое значение:
//  Число - 
//
Функция НайтиИндексЗапросаСозданияВременнойТаблицы(Знач ИмяТаблицы, Знач ПакетЗапросов = Неопределено) Экспорт
	Если ПакетЗапросов = Неопределено Тогда
		ПакетЗапросов = мПакетЗапросов;
	КонецЕсли;
	Если ПакетЗапросов = Неопределено Тогда
		Возврат Неопределено;
	КонецЕсли;
	ПодготовитьПакетЗапросов(ПакетЗапросов);
	СтруктураПакета = ПакетЗапросов.Структура;
	ЭлементСписка = СтруктураПакета.НайтиПоЗначению(НРег(ИмяТаблицы));
	Если ЭлементСписка <> Неопределено Тогда
		ИндексЗапроса = СтруктураПакета.Индекс(ЭлементСписка);
		ПакетЗапросов.Вставить("ИндексВПакете", ИндексЗапроса);
	КонецЕсли;
	Возврат ИндексЗапроса;
КонецФункции

//.
// Параметры:
//    ПакетЗапросов - , Структура - 
Процедура ПодготовитьПакетЗапросов(Знач ПакетЗапросов) Экспорт
	Если ПакетЗапросов.Структура = Неопределено Тогда
		Если ПакетЗапросов.ТекстыЗапросов = Неопределено Тогда
			ПакетЗапросов.ТекстыЗапросов = мПлатформа.РазбитьГрубоТекстПакетногоЗапросаНаЗапросы(ПакетЗапросов.Текст,, ПакетЗапросов.Позиции0Запросов);
		КонецЕсли;
		ПакетЗапросов.Структура = мПлатформа.СоздаваемыеВременныеТаблицыПакетаЗапросов(ПакетЗапросов.ТекстыЗапросов);
	КонецЕсли;
КонецПроцедуры

//.
// Параметры:
//    ИндексЗапроса - Число, Неопределено - 
Процедура ЗагрузитьЗапросПакетаПоИндексу(Знач ПакетЗапросов, Знач ИндексЗапроса) Экспорт
	мТекстБлока = ПакетЗапросов.ТекстыЗапросов[ИндексЗапроса];
	мТекстДляПоискаОпределения = мТекстБлока; 
	мПозицияТекстаДляПоискаОпределения = ПакетЗапросов.Позиции0Запросов[ИндексЗапроса]; // В режиме языка запросов мПозицияТекстаДляПоискаОпределения начинается с 0
	Если ПакетЗапросов.КоординатыТекста <> Неопределено Тогда
		Позиция0Блока = ?(ПакетЗапросов.КоординатыТекста.Метод <> Неопределено, ПакетЗапросов.КоординатыТекста.Метод.ПозицияТела, 1);
		мПозицияТекстаДляПоискаОпределения = мПозицияТекстаДляПоискаОпределения + Позиция0Блока + ПакетЗапросов.КоординатыТекста.Позиция0ВБлоке;
	КонецЕсли;
КонецПроцедуры

// Вычисляет массив структур типа дочернего контекста.
//
// Параметры:
//  РодительскиеСтрутурыТипа - см. мПлатформа.НоваяТаблицаТипов - родительских структур типа;
//  ТекущееСлово - Строка - дочернеее слово;
//  ТипСлова     - Строка - тип слова;
//  *ТекущийИндекс - Строка, *Неопределено - выражение в квадратных скобках;
//  *ТекущиеАргументы - Строка, *"" - аргументы метода;
//  *ПредшествующийТекст - Строка, *"" - текст для поиска определения таблицы в режиме языка запросов.
//
// Возвращаемое значение:
//  МассивСтрутурТипа - Массив - дочерних структур типа.
//
Функция ВычислитьТипДочернегоЭлемента(Знач РодительскиеСтрутурыТипа, Знач ТекущееСлово, Знач ТипСлова, Знач ТекущийИндекс = Неопределено, Знач ТекущиеАргументы = "", Знач ПредшествующийТекст = "",
	Знач ПолныйАнализСоставаТипов = Истина, выхЛиПеременнаяМодуля = Ложь, Знач ПозицияВМетоде = 0, ТаблицаТипов = Неопределено, Знач ДляСвойства = "", Знач ЗапретВычисленияВМодуле = Ложь) Экспорт 

	#Если Сервер И Не Сервер Тогда
		мПлатформа = Обработки.ирПлатформа.Создать(); 
		ПолеТекста = Обработки.ирОболочкаПолеТекста.Создать();
	#КонецЕсли  
	Если мРекурсивныйПуть = Неопределено Тогда
		ИнициироватьРекурсивныйПуть();
	КонецЕсли;
	ТаблицаСвойствТипа = мПлатформа.НоваяТаблицаСлов(); // Ускорение
	Если ТаблицаТипов = Неопределено Тогда
		ТаблицаТипов = мПлатформа.НоваяТаблицаТипов(); 
	КонецЕсли;  
	//ЛиЭтоКонструкторСтруктуры = Истина
	//	И ТипСлова = "Конструктор"
	//	И ирОбщий.СтрокиРавныЛкс(ТекущееСлово, "Структура");
	СчетчикТипов = 0;
	ПараметрыИсходящегоВызова = Неопределено;
	ЛиВместеСЛокальнымКонтекстом = Ложь;
	ЕстьПроизвольныйТип = Ложь;
	НаследоватьОбрезку = ЗначениеЗаполнено(ТекущийИндекс);
	ЗапретитьВычислятьТипыМетодовМодулей = Истина  
		И ТипСлова = "Метод"
		И ТекущиеАргументы = "(" + ИмяОтключенияЛишнихВычислений() + ")";
	РазрешитьВытеснять = Не мПлатформа.мРежимПроверкиМодуля Или ТипСлова <> "Метод";
	БазовоеРасширениеКонфигурации = БазовоеРасширениеКонфигурации();
	Для Каждого РодительскаяСтруктураТипа Из РодительскиеСтрутурыТипа Цикл
		СчетчикТипов = СчетчикТипов + 1;
		Если Истина
			И Не ПолныйАнализСоставаТипов
			И СчетчикТипов > 50
		Тогда 
			Прервать;
		КонецЕсли; 
		Если РодительскаяСтруктураТипа.ИмяОбщегоТипа = "НеизвестныйКонтекст" Тогда
			Продолжить;
		КонецЕсли;
		Если РодительскаяСтруктураТипа.ИмяОбщегоТипа = "Произвольный" Тогда
			ЕстьПроизвольныйТип = Истина;
		КонецЕсли;
		ВиртуальнаяТаблица = Неопределено;
		ТаблицаТиповПоПравилу = Неопределено;
		МетаданныеРодителя = РодительскаяСтруктураТипа.Метаданные;
		ЭтоЛокальныйКонтекст = РодительскаяСтруктураТипа.ИмяОбщегоТипа = "Локальный";  // Всегда идет первым
		Если ЭтоЛокальныйКонтекст Тогда
			ЛиВместеСЛокальнымКонтекстом = Истина; // Используется на следующих проходах цикла!
		КонецЕсли;
		Если Истина  
			И ЗначениеЗаполнено(ТекущийИндекс)
			И РодительскаяСтруктураТипа.ИмяОбщегоТипа = "ВременныеТаблицыЗапроса" 
			И ТипЗнч(РодительскаяСтруктураТипа.Метаданные) = Тип("Структура")
		Тогда
			ИмяВременнойТаблицы = ВычислитьЗначениеВыражения(ТекущееСлово,,,, ПозицияВМетоде);
			ПостроительЗапроса = НайтиЗапросВременнойТаблицы(ИмяВременнойТаблицы, РодительскаяСтруктураТипа.Метаданные); 
			Если ПостроительЗапроса <> Неопределено Тогда
				СтруктраТипа = мПлатформа.НоваяСтруктураТипа("ВременнаяТаблицаЗапроса");
				СтруктраТипа.Метаданные = ПостроительЗапроса;
				СтруктраТипа.ДержательМетаданных = РодительскаяСтруктураТипа.ДержательМетаданных;
				мПлатформа.ДобавитьВТаблицуТипов(ТаблицаТипов, СтруктраТипа);
				Прервать;
			КонецЕсли;
        КонецЕсли;
		Если Не ЗначениеЗаполнено(ТекущийИндекс) Тогда
			Если Истина
				И ЭтоЛокальныйКонтекст
				И ТипСлова = "Свойство"
			Тогда
				ПараметрыМетода = мПлатформа.ПараметрыМетодаМодуля(мМетодМодуля);
				Если ПараметрыМетода <> Неопределено Тогда
					СтрокаПараметраМетода = ПараметрыМетода.Найти(НРег(ТекущееСлово), "НИмя");
					Если СтрокаПараметраМетода <> Неопределено Тогда
						ТаблицаТиповИсточник = Неопределено;
						Если Истина
							И мМетодМодуля.КлючевыеПараметры <> Неопределено
							И мМетодМодуля.КлючевыеПараметры.Свойство(ТекущееСлово, ТаблицаТиповИсточник) 
						Тогда
							Если ТаблицаТиповИсточник <> Неопределено Тогда
								мПлатформа.ДобавитьВТаблицуТипов(ТаблицаТипов, ТаблицаТиповИсточник);
								Прервать;
							КонецЕсли;
						КонецЕсли;
						ТаблицаТиповПараметра = ВычислитьТипПараметраМетодаМодуля(ПараметрыМетода, СтрокаПараметраМетода, ДляСвойства); 
						мПлатформа.ДобавитьВТаблицуТипов(ТаблицаТипов, ТаблицаТиповПараметра); 
						Прервать;
					КонецЕсли;
				КонецЕсли;
			КонецЕсли;
			Если мЯзыкПрограммы = 1 Тогда
				Если ЗначениеЗаполнено(мРодительскийКонтекст) Тогда
					ВиртуальнаяТаблица = Новый Структура("Выражение, НомерСтроки");
					ВиртуальнаяТаблица.Выражение = "." + ТекущееСлово; // Тут мы пока не уверены, это обращение к полю или виртуальной таблице
					Если ЗначениеЗаполнено(ТекущиеАргументы) Тогда
						//ВиртуальнаяТаблица.Выражение = ВиртуальнаяТаблица.Выражение + "." + ТекущиеАргументы;  // Кажется это было сделано умышленно
						ВиртуальнаяТаблица.Выражение = ВиртуальнаяТаблица.Выражение + ТекущиеАргументы; // https://www.hostedredmine.com/issues/958394
					КонецЕсли;
					ВиртуальнаяТаблица.НомерСтроки = СтрЧислоСтрок(ПредшествующийТекст);
				КонецЕсли;
				Если ЭтоЛокальныйКонтекст Тогда  
					Если Лев(ТекущееСлово, 1) = "&" Тогда 
						ТаблицаТиповТаблицыПараметра = Неопределено;
						Если Истина
							И мПакетЗапросов <> Неопределено
							И мПакетЗапросов.Свойство("Параметры")
							И мПакетЗапросов.Параметры.Свойство(Сред(ТекущееСлово, 2), ТаблицаТиповТаблицыПараметра) 
							И ТаблицаТиповТаблицыПараметра <> Неопределено
						Тогда 
							СтруктраТипа = мПлатформа.НоваяСтруктураТипа("ВременнаяТаблица");
							СтруктраТипа.Метаданные = ТаблицаТиповТаблицыПараметра[0].Метаданные;
							мПлатформа.ДобавитьВТаблицуТипов(ТаблицаТипов, СтруктраТипа);
							Прервать;
						КонецЕсли;    
					ИначеЕсли ирОбщий.СтрокиРавныЛкс(ТекущееСлово, "ЗНАЧЕНИЕ") Тогда
						ИмяМД = ирОбщий.ПервыеФрагментыЛкс(ТекстБезКрайнихСимволов(ТекущиеАргументы));
						ОбъектМД = Метаданные.НайтиПоПолномуИмени(ИмяМД);
						Если ОбъектМД <> Неопределено Тогда
							СтруктраТипа = мПлатформа.СтруктураТипаИзКонкретногоТипа(Тип(ирОбщий.ИмяТипаИзПолногоИмениМДЛкс(ИмяМД)));
							мПлатформа.ДобавитьВТаблицуТипов(ТаблицаТипов, СтруктраТипа);
						КонецЕсли;
					Иначе
						ПостроительЗапроса = НайтиЗапросВременнойТаблицы(ТекущееСлово, РодительскаяСтруктураТипа.ДержательМетаданных);
						Если ПостроительЗапроса <> Неопределено Тогда
							СтруктраТипа = мПлатформа.НоваяСтруктураТипа("ВременнаяТаблица");
							СтруктраТипа.Метаданные = ПостроительЗапроса;
							СтруктраТипа.ДержательМетаданных = РодительскаяСтруктураТипа.ДержательМетаданных;   
							мПлатформа.ДобавитьВТаблицуТипов(ТаблицаТипов, СтруктраТипа);
							Прервать;
						КонецЕсли;
					КонецЕсли;
				КонецЕсли;
			КонецЕсли;
		КонецЕсли;
		ТаблицаСвойствТипа.Очистить();
		ЛиПредопределенное = Ложь;
		Если Не ЗначениеЗаполнено(ТекущийИндекс) Тогда
			мПлатформа.СловаКонтекстаПредопределенные(РодительскаяСтруктураТипа, ТекущееСлово, ТипСлова, ВиртуальнаяТаблица, мЯзыкПрограммы, Конфигурация,, мФлагиКомпиляции, ТаблицаСвойствТипа, ЭтоЛокальныйКонтекст);
			Если ТаблицаСвойствТипа.Количество() > 0 Тогда
				ЛиПредопределенное = Истина;
				МаксКоличествоВариантов = 5;
				КоличествоВариантов = 0;
				Для Каждого СтрокаСлова Из ТаблицаСвойствТипа Цикл
					//Если Истина
					//	И ЛиЭтоКонструкторСтруктуры
					//	И СтрокаСлова.ТаблицаТипов[0].СтрокаОписания.Слово <> "По ключам и значениям"
					//Тогда
					//	Продолжить;
					//КонецЕсли;
					ТаблицаТиповВарианта = СтрокаСлова.ТаблицаТипов;
					мПлатформа.ДобавитьВТаблицуТипов(ТаблицаТипов, ТаблицаТиповВарианта,, РазрешитьВытеснять);
					Если Истина
						//И ТипЗнч(РодительскаяСтруктураТипа.Метаданные) = Тип("Структура")
						//И ТипЗнч(РодительскаяСтруктураТипа.Метаданные) = Тип("ПостроительЗапроса")
						И ТаблицаТиповВарианта[0].Метаданные = РодительскаяСтруктураТипа.Метаданные 
					Тогда
						НаследоватьОбрезку = Истина;
					КонецЕсли;
					КоличествоВариантов = КоличествоВариантов + 1;
					Если КоличествоВариантов >= МаксКоличествоВариантов Тогда
						Прервать;
					КонецЕсли; 
				КонецЦикла;
				Пока Истина
					И ТаблицаТипов.Количество() > 1
					И ТаблицаТипов[0].СтрокаОписания <> Неопределено
					И ТаблицаТипов[0].СтрокаОписания.Владелец().Колонки.Найти("ТипКонтекста") <> Неопределено
					И ТаблицаТипов[0].СтрокаОписания.ТипКонтекста = "Глобальный" 
					И ТаблицаТипов[ТаблицаТипов.Количество() - 1].СтрокаОписания <> Неопределено
					И ТаблицаТипов[ТаблицаТипов.Количество() - 1].СтрокаОписания.Владелец().Колонки.Найти("ТипКонтекста") <> Неопределено
					И ТаблицаТипов[ТаблицаТипов.Количество() - 1].СтрокаОписания.ТипКонтекста <> "Глобальный" 
				Цикл 
					// Удаляем перегрузку метода глобального контекста методом объекта
					// Например ОбработкаОбъект.ПолучитьФорму(), Форма.ПодключитьОбработчикОжидания()
					ТаблицаТипов.Удалить(0);
				КонецЦикла;
				Если Истина
					И РодительскаяСтруктураТипа.ИмяОбщегоТипа = "БлокировкаДанных" 
					И ТипСлова = "Метод" 
					И ТекущееСлово = "Добавить" 
				Тогда
					ТаблицаТипов.ЗаполнитьЗначения(ирОбщий.ТекстМеждуМаркерамиЛкс(ТекущиеАргументы, """", """"), "Метаданные");
				КонецЕсли; 
			ИначеЕсли Истина
				И ЗначениеЗаполнено(РодительскаяСтруктураТипа.ТипЯзыка) 
				И РодительскаяСтруктураТипа.ИмяОбщегоТипа = "Строка" 
			Тогда 
				ЗаполнитьЗначенияСвойств(ТаблицаТипов.Добавить(), РодительскаяСтруктураТипа); 
				Продолжить;
			КонецЕсли;
			Если ТипСлова = "Метод" Тогда
				// Ищем правило вычисления
				ПравилоВычисленияФункции = НайтиПравилоВычисленияФункции(ТекущееСлово, РодительскаяСтруктураТипа);
				Если ПравилоВычисленияФункции <> Неопределено Тогда 
					Если ПараметрыИсходящегоВызова = Неопределено Тогда
						ПараметрыИсходящегоВызова = РазобратьФактическиеПараметрыВызова(ТекущиеАргументы);
					КонецЕсли;
					//Попытка
					мРекурсивныйПуть.ДобавлятьКлючевыеПараметры = Истина; // Для Вычислить()
					ТаблицаТиповПоПравилу = Вычислить(ПравилоВычисленияФункции.Правило + "(РодительскаяСтруктураТипа, ПараметрыИсходящегоВызова, ТекущееСлово, ПредшествующийТекст, ПозицияВМетоде, ТаблицаТипов)"); // см. мПлатформа.НоваяТаблицаТипов()
					мРекурсивныйПуть.ДобавлятьКлючевыеПараметры = Ложь;
					Если Истина
						И ТаблицаТиповПоПравилу <> Неопределено 
						И ТаблицаТиповПоПравилу.Количество() > 0
						И ТаблицаТипов <> ТаблицаТиповПоПравилу
					Тогда 
						// Перенес ниже
					Иначе 
						ТаблицаТиповПоПравилу = Неопределено;
					КонецЕсли;
				КонецЕсли;
			КонецЕсли;
			Если ЛиПредопределенное И ТаблицаТиповПоПравилу = Неопределено Тогда
				Продолжить;
			КонецЕсли;
		КонецЕсли;
		СтрокаОписанияМетода = Неопределено;
		Если Не ЛиПредопределенное Тогда
			Если ЗапретВычисленияВМодуле И ТипСлова = "Свойство" Тогда
				выхЛиПеременнаяМодуля = Истина;
			КонецЕсли;
			Если Истина
				И ЭтоЛокальныйКонтекст 
				И мМодульМетаданных <> Неопределено 
				И Не ЗапретВычисленияВМодуле
			Тогда
				СтруктураКлюча = Новый Структура("НИмя", Нрег(ТекущееСлово));
				НайденныеСтроки = ТаблицаЛокальногоКонтекста(ТипСлова).НайтиСтроки(СтруктураКлюча);
				Если НайденныеСтроки.Количество() > 0 Тогда
					// Это локальный метод или свойство модуля
					СтрокаСлова = НайденныеСтроки[0];
					Если ТаблицаТиповПоПравилу <> Неопределено Тогда
						СтрокаОписанияМетода = СтрокаСлова; 
					Иначе
						Если мЯзыкПрограммы <> 1 Тогда
							ПолеТекстаПрограммыВызова = КопияКомпоненты();
							Если ТипСлова = "Метод" Тогда
								ТаблицаТиповСловаМодуля = мПлатформа.ПодготовитьТипРезультатаМетода(СтрокаСлова, мМодульМетаданных, ПолеТекстаПрограммыВызова,, ДляСвойства); // TODO Переделать на СловаМетаданные(), чтобы видеть методы расширяемого модуля
							Иначе
								выхЛиПеременнаяМодуля = мМодульМетаданных.Имя <> мПлатформа.ИмяДинамическогоМодуля(); 
								ТаблицаТиповСловаМодуля = мПлатформа.ПодготовитьТипЗначенияПеременнойМодуля(СтрокаСлова, мМодульМетаданных, ПолеТекстаПрограммыВызова, ДляСвойства); 
							КонецЕсли;  
						КонецЕсли;
						ТаблицаТиповСловаМодуля = мПлатформа.ТаблицаТиповСловаМодуля(СтрокаСлова, мМодульМетаданных, ТаблицаТиповСловаМодуля);
						Если Истина
							И ЗначениеЗаполнено(ТекущиеАргументы) 
							И ТипСлова = "Метод" 
						Тогда
							ТаблицаТиповМетода = ВычислитьТипФункцииСФактПараметрами(СтрокаСлова, ТекущиеАргументы, ПредшествующийТекст, ПолныйАнализСоставаТипов, ПараметрыИсходящегоВызова,
								ПолеТекстаПрограммыВызова, ДляСвойства);
							Если ТаблицаТиповМетода <> Неопределено Тогда
								ТаблицаТиповСловаМодуля = ТаблицаТиповМетода;
							КонецЕсли;
						КонецЕсли;
						мПлатформа.ДобавитьВТаблицуТипов(ТаблицаТипов, ТаблицаТиповСловаМодуля);  
						Если Ложь
							Или ТипСлова = "Метод" 
							Или мПлатформа.ЛиДетальностьТиповДостаточна(ТаблицаТипов, 4) // 4 нужно чтобы ТаблицаЗначений без метаданных от реквизита обычной формы не выходила сразу и дальше в нее добавилась натуральная таблица
						Тогда
							Прервать; 
						КонецЕсли;
						// Продолжаем вычисление, чтобы в модуле обычной формы переменная модуля ее объекта могла расчитаться по модулю объекта
						Продолжить;
					КонецЕсли;
				КонецЕсли;
			КонецЕсли;
			ТаблицаСвойствТипа.Очистить();
			Если Истина
				И СтрокаОписанияМетода = Неопределено
				И (Ложь
					Или Не ЭтоЛокальныйКонтекст 
					Или Не ЗапретВычисленияВМодуле)
			Тогда
				Если Ложь
					Или ТаблицаТиповПоПравилу <> Неопределено
					Или ЗапретитьВычислятьТипыМетодовМодулей
				Тогда
					ВычислятьТипыМетодовМодулей = Ложь;
				Иначе
					ВычислятьТипыМетодовМодулей = Неопределено;
				КонецЕсли;
				мПлатформа.СловаКонтекстаМетаданные(РодительскаяСтруктураТипа, ТекущееСлово, ТипСлова,, мЯзыкПрограммы, ТекущийИндекс,,, мФлагиКомпиляции,
					МодульМетаданныхКонтекста(РодительскаяСтруктураТипа), ТаблицаСвойствТипа, ВычислятьТипыМетодовМодулей, ЭтоЛокальныйКонтекст, ЛиВместеСЛокальнымКонтекстом, БазовоеРасширениеКонфигурации, ДляСвойства);
			Иначе 
				// была бесконечная рекурсия при анализе этого модуля из-за вычисления Обработка.ирКонсольЗапросов.Форма.ДеревоЗапроса
			КонецЕсли;
			Если ТаблицаСвойствТипа.Количество() > 0 Тогда
				Для Каждого СтрокаСлова Из ТаблицаСвойствТипа Цикл
					ТаблицаТиповИсточник = СтрокаСлова.ТаблицаТипов;
					Если ТаблицаТиповИсточник = Неопределено Тогда
						Продолжить;
					КонецЕсли;
					Если ТаблицаТиповПоПравилу <> Неопределено Тогда
						Если ТаблицаТиповИсточник.Количество() > 0 Тогда
							СтрокаОписанияМетода = ТаблицаТиповИсточник[0].СтрокаОписания;
						КонецЕсли;
						Прервать;
					КонецЕсли;
					Если Ложь 
						Или Найти(СтрокаСлова.Слово, "<") = 0
						Или ТаблицаТипов.Количество() = 0
						Или Найти(ТаблицаТипов[0].ИмяОбщегоТипа, "<") > 0
					Тогда
						Если ТаблицаТиповИсточник.Количество() > 0 Тогда
							СтрокаОписания = ТаблицаТиповИсточник[0].СтрокаОписания; 
							Если Истина
								И ЗначениеЗаполнено(ТекущиеАргументы)
								И ТипСлова = "Метод"
								И ТипЗнч(СтрокаОписания) = Тип("СтрокаТаблицыЗначений")
								И СтрокаОписания.Владелец().Колонки.Найти("ЛиЭкспорт") <> Неопределено
							Тогда 
								ТаблицаТиповМетода = ВычислитьТипФункцииСФактПараметрами(СтрокаОписания, ТекущиеАргументы, ПредшествующийТекст, ПолныйАнализСоставаТипов, ПараметрыИсходящегоВызова,, ДляСвойства);
								Если ТаблицаТиповМетода <> Неопределено Тогда
									ТаблицаТиповИсточник = ТаблицаТиповМетода;
								КонецЕсли;
							КонецЕсли;
							Если Найти(СтрокаСлова.Слово, "<") > 0 Тогда
								НаследоватьОбрезку = Истина;
							КонецЕсли;
							мПлатформа.ДобавитьВТаблицуТипов(ТаблицаТипов, ТаблицаТиповИсточник,, РазрешитьВытеснять);
						КонецЕсли;
					КонецЕсли; 
				КонецЦикла;
				//Если ТаблицаТиповПоПравилу = Неопределено Тогда
				//	Продолжить;
				//КонецЕсли;
			КонецЕсли;
		КонецЕсли;
		Если ТаблицаТиповПоПравилу <> Неопределено Тогда
			Если СтрокаОписанияМетода <> Неопределено Тогда
				ТаблицаТиповПоПравилу.ЗаполнитьЗначения(СтрокаОписанияМетода, "СтрокаОписания");
			КонецЕсли;
			ТаблицаТипов.Очистить();
			мПлатформа.ДобавитьВТаблицуТипов(ТаблицаТипов, ТаблицаТиповПоПравилу);
			Прервать;
		КонецЕсли;
	КонецЦикла;
	Если Истина
		И НаследоватьОбрезку
		И РодительскиеСтрутурыТипа.Колонки.Метаданные.Заголовок <> "" 
	Тогда
		ТаблицаТипов.Колонки.Метаданные.Заголовок = ЗаголовокФлагОбрезкиГлубины();
	КонецЕсли;
	Если Истина
		И ТаблицаТиповСловаМодуля <> Неопределено 
		И ТаблицаТипов.Количество() > 1 
	Тогда
		СтрокаПустогоТипа = ТаблицаТипов.Найти("", "ИмяОбщегоТипа");
		Если СтрокаПустогоТипа <> Неопределено Тогда
			ТаблицаТипов.Удалить(СтрокаПустогоТипа);
		КонецЕсли;
	КонецЕсли;
	Если Истина
		И ЕстьПроизвольныйТип
		И ТаблицаТипов.Количество() = 0
	Тогда
		// Чтобы не обнаруживалась ошибка проверкой модуля
		СтруктраТипа = мПлатформа.НоваяСтруктураТипа("Произвольный");
		мПлатформа.ДобавитьВТаблицуТипов(ТаблицаТипов, СтруктраТипа);
	КонецЕсли;
	Возврат ТаблицаТипов;
КонецФункции

//.
// Параметры:
//    ТекущееСлово - Строка - 
//    МенеджерВременныхТаблиц - см. НовыйМенеджерВременныхТаблиц() - 
//    ПакетЗапросовТекущий - Структура - 
// Возвращаемое значение:
//    ПостроительЗапроса, Неопределено - 
Функция НайтиЗапросВременнойТаблицы(Знач ТекущееСлово, Знач МенеджерВременныхТаблиц = Неопределено, выхПакетЗапросовТекущий = Неопределено, выхИндексЗапроса = Неопределено) Экспорт
	Если ЯзыкПрограммы = 0 И ТипЗнч(МенеджерВременныхТаблиц) <> Тип("Структура") Тогда
		МенеджерВременныхТаблиц = мМенеджерВременныхТаблиц;
	КонецЕсли;
	ПостроительЗапроса = Неопределено;                                     
	Если МенеджерВременныхТаблиц = Неопределено Тогда
		выхПакетЗапросовТекущий = мПакетЗапросов;
		выхИндексЗапроса = НайтиИндексЗапросаСозданияВременнойТаблицы(ТекущееСлово, выхПакетЗапросовТекущий);
	Иначе 
		Если выхИндексЗапроса = Неопределено И ТипЗнч(МенеджерВременныхТаблиц) = Тип("Структура") Тогда
			ПакетыЗапросов = МенеджерВременныхТаблиц.ПакетыЗапросов;
			Для Индекс = 1 - ПакетыЗапросов.Количество() По 0 Цикл // Обратный обход
				ПакетЗапросовЦикл = ПакетыЗапросов[-Индекс];
				выхИндексЗапроса = НайтиИндексЗапросаСозданияВременнойТаблицы(ТекущееСлово, ПакетЗапросовЦикл);
				Если выхИндексЗапроса <> Неопределено Тогда
					выхПакетЗапросовТекущий = ПакетЗапросовЦикл;
					Прервать;
				КонецЕсли;
			КонецЦикла;
		КонецЕсли;
	КонецЕсли;
	Если выхИндексЗапроса <> Неопределено Тогда
		ПостроительЗапроса = мПлатформа.ПостроительПакетаЗапросовДоИндекса(выхПакетЗапросовТекущий.ТекстыЗапросов, выхИндексЗапроса, выхПакетЗапросовТекущий.Параметры, ТекущееСлово);
		Если Истина
			И ПостроительЗапроса <> Неопределено 
			И ПостроительЗапроса.ВыбранныеПоля.Количество() = 0 
		Тогда
			ПостроительЗапроса = Неопределено;
		Иначе 
			//ирОбщий.СкопироватьКоллекциюЛкс(выхПакетЗапросовТекущий.Параметры, ПостроительЗапроса.Параметры); // Вроде пока не нужно
		КонецЕсли;
	КонецЕсли;
	Возврат ПостроительЗапроса;
КонецФункции

//.
// Параметры:
//    ПараметрыМетода - ТаблицаЗначений - 
//    СтрокаПараметраМетода - СтрокаТаблицыЗначений - 
//    ДляСвойства - Строка - 
Функция ВычислитьТипПараметраМетодаМодуля(Знач ПараметрыМетода, Знач СтрокаПараметраМетода, Знач ДляСвойства = "")
	Если Ложь
		Или Не СтрокаПараметраМетода.Вычислено
		Или ЛиТаблицаТиповКэшНеГотова(СтрокаПараметраМетода.ТаблицаТипов, ДляСвойства) 
	Тогда
		Если Ложь
			Или Не ЗначениеЗаполнено(ДляСвойства) 
			//Или мПлатформа.мРежимПроверкиМодуля
		Тогда
			СтрокаПараметраМетода.Вычислено = Истина;
		КонецЕсли;
	ИначеЕсли Ложь 
		Или ДляСвойства = ИмяФиктивногоСвойства()
		Или СтрокаПараметраМетода.ТаблицаТипов.Колонки.Метаданные.Заголовок = ""
	Тогда
		Возврат СтрокаПараметраМетода.ТаблицаТипов; // Попадание в кэш параметра
	КонецЕсли;
	
	//Если мРекурсивныйПуть = Неопределено Тогда
	//	ИнициироватьРекурсивныйПуть();
	//КонецЕсли;
	ПройденныеВызовы = мРекурсивныйПуть.ВходящиеВызовы;
	Если ЗначениеЗаполнено(ДляСвойства) Тогда
		ТаблицаТипов = мПлатформа.НоваяТаблицаТипов();
	Иначе
		Если СтрокаПараметраМетода.ТаблицаТипов = Неопределено Тогда
			СтрокаПараметраМетода.ТаблицаТипов = мПлатформа.НоваяТаблицаТипов();
		КонецЕсли;
		ТаблицаТипов = СтрокаПараметраМетода.ТаблицаТипов;
	КонецЕсли;
	Если мМодульМетаданных.СтруктураТипа <> Неопределено Тогда
		// События формы
		ФормаМодуля = мМодульМетаданных.СтруктураТипа.Метаданные;
		Если Истина
			И мПлатформа.ЛиИмяМодуляФормы(мМодульМетаданных.Имя)
			И ирОбщий.ЛиФормаИлиИмитаторЛкс(ФормаМодуля) 
		Тогда
			СтрокаОбработчика = Неопределено;
			ВсеОбработчикиСобытий = ирОбщий.ВсеОбработчикиСобытийФормаЛкс(ФормаМодуля, Истина);
			Если ВсеОбработчикиСобытий <> Неопределено Тогда
				СтрокаОбработчика = ВсеОбработчикиСобытий.Найти(НРег(мМетодМодуля.Имя), "НОбработчик");
			КонецЕсли;
			Если СтрокаОбработчика = Неопределено Тогда 
				ВсеСобытия = ирОбщий.СобытияЭлементаФормыЛкс(ФормаМодуля);
				Если ирОбщий.НайтиЭлементКоллекцииЛкс(ВсеСобытия, "НСлово", НРег(мМетодМодуля.Имя)) <> Неопределено Тогда
					мПлатформа.ДобавитьОтсутствиеЭлементаФормы(ФормаМодуля, "Событие:" + мМетодМодуля.Имя);
				КонецЕсли;
			Иначе
				ЭлементФормы = Неопределено;
				ПараметрыСобытия = мПлатформа.ПараметрыМетодаПлатформы(СтрокаОбработчика.СтрокаОписания);
				Если ЗначениеЗаполнено(СтрокаОбработчика.Имя) Тогда
					СтрокаПараметраЭлемент = ПараметрыСобытия.Вставить(0);
					СтрокаПараметраЭлемент.Слово = "Элемент";
					Если ТипЗнч(ФормаМодуля) = Тип("Форма") Тогда
						Попытка
							ЭлементФормы = Вычислить("ФормаМодуля.ЭлементыФормы." + СтрокаОбработчика.Имя);
						Исключение
						КонецПопытки;
					ИначеЕсли ТипЗнч(ФормаМодуля) = Тип("УправляемаяФорма") Тогда
						// Нельзя использовать Найти(), т.к. возможен имитатор формы
						Попытка
							ЭлементФормы = ФормаМодуля.Элементы[СтрокаОбработчика.Имя];
						Исключение 
						КонецПопытки;
					КонецЕсли;
				КонецЕсли;
				ЗаполнитьОписанияПараметровИзСобытия(СтрокаОбработчика.СтрокаОписания, ПараметрыСобытия);
				Если ЭлементФормы <> Неопределено Тогда
					Если ирОбщий.СтрокиРавныЛкс(СтрокаПараметраМетода.Имя, "Элемент") Тогда 
						Если ТипЗнч(ЭлементФормы) = Тип("Структура") Тогда
							СтрукутраТипаЭлемента = мПлатформа.СтруктураТипаИзКонкретногоТипа(ЭлементФормы.Тип);   
							СтрукутраТипаЭлемента.Метаданные = ЭлементФормы;
						Иначе 
							СтрукутраТипаЭлемента = мПлатформа.СтруктураТипаИзЗначения(ЭлементФормы);
						КонецЕсли;
						СтрукутраТипаЭлемента.ДержательМетаданных = ФормаМодуля;
						мПлатформа.ДобавитьВТаблицуТипов(ТаблицаТипов, СтрукутраТипаЭлемента);
						Возврат ТаблицаТипов;
					ИначеЕсли Истина                         
						И ПараметрыМетода[0].Имя = "Элемент"
						И (Ложь
							Или СтрокаПараметраМетода.Имя = "ВыбраннаяСтрока"
							Или СтрокаПараметраМетода.Имя = "Родитель"
							Или СтрокаПараметраМетода.Имя = "ДанныеСтроки")
						И ТипЗнч(ФормаМодуля) = Тип("Форма")
					Тогда 
						ТаблицаДочернихСлов = мПлатформа.СловаКонтекстаПредопределенные(мПлатформа.СтруктураТипаИзЗначения(ЭлементФормы), "ТекущиеДанные", "Свойство");
						мПлатформа.ДобавитьВТаблицуТипов(ТаблицаТипов, ТаблицаДочернихСлов[0].ТаблицаТипов);
						Возврат ТаблицаТипов;
					ИначеЕсли Истина                         
						И ПараметрыМетода[0].Имя = "Элемент"
						И ТипЗнч(ФормаМодуля) = Тип("Форма")
					Тогда
						Попытка
							Тип = Тип(СтрокаПараметраМетода.ТипЗначения);
						Исключение
							Тип = Неопределено;
						КонецПопытки;
						Если Тип <> Неопределено Тогда
							мПлатформа.ДобавитьВТаблицуТипов(ТаблицаТипов, мПлатформа.СтруктураТипаИзКонкретногоТипа(Тип,, Новый Структура("Метаданные, ДержательМетаданных", ЭлементФормы, ФормаМодуля)));
						КонецЕсли;
						Возврат ТаблицаТипов;
					КонецЕсли; 
				Иначе 
					Если СтрокаПараметраМетода.Имя = "ТекущийОбъект" Тогда 
						КлючОсновногоОбъекта = ирОбщий.КлючОсновногоОбъектаФормыЛкс(ФормаМодуля);                    
						СтруктураТипа = мПлатформа.СтруктураТипаИзЗначения(КлючОсновногоОбъекта);
						СтруктураТипа.ИмяОбщегоТипа = СтрЗаменить(СтруктураТипа.ИмяОбщегоТипа, "Ссылка.", "Объект.");
						мПлатформа.ДобавитьВТаблицуТипов(ТаблицаТипов, СтруктураТипа);
					КонецЕсли;
				КонецЕсли;
			КонецЕсли; 
		КонецЕсли;
		// Подсказка по параметрам обработчиков методов Http-сервисов
		Если Истина
			И ирОбщий.СтрНачинаетсяСЛкс(мМодульМетаданных.Имя, "HTTPСервис.")
			И ПараметрыМетода.Индекс(СтрокаПараметраМетода) = 0
			И ТипЗнч(мМодульМетаданных.СтруктураТипа.Метаданные) = Тип("ОбъектМетаданных")
		Тогда
			ОбъектМД = мМодульМетаданных.СтруктураТипа.Метаданные; // ОбъектМетаданныхHTTPСервис
			Для Каждого Шаблон Из ОбъектМД.ШаблоныURL Цикл
				Если ирОбщий.НайтиЭлементКоллекцииЛкс(Шаблон.Методы, "Обработчик", мМетодМодуля.Имя) <> Неопределено Тогда 
					мПлатформа.ДобавитьВТаблицуТипов(ТаблицаТипов, мПлатформа.СтруктураТипаИзКонкретногоТипа(Тип("HTTPЗапрос")));
				КонецЕсли;
			КонецЦикла;
		КонецЕсли;
		// Подсказка по параметрам обработчиков модуля команды
		Если Истина
			И ирОбщий.СтрКончаетсяНаЛкс(мМодульМетаданных.Имя, ".МодульКоманды")
			И мМетодМодуля.Имя = "ОбработкаКоманды"
			И ТипЗнч(мМодульМетаданных.СтруктураТипа.Метаданные) = Тип("ОбъектМетаданных")
		Тогда
			ОбъектМД = мМодульМетаданных.СтруктураТипа.Метаданные; // ОбъектМетаданныхКоманда
			Если ПараметрыМетода.Индекс(СтрокаПараметраМетода) = 0 Тогда
				мПлатформа.ДобавитьВТаблицуТипов(ТаблицаТипов, ОбъектМД.ТипПараметраКоманды);
				Если ОбъектМД.РежимИспользованияПараметра = РежимИспользованияПараметраКоманды.Множественный Тогда
					СтруктураТипа = мПлатформа.НоваяСтруктураТипа("Массив" + "[" + ПредставлениеМассиваСтруктурТипов(ТаблицаТипов) + "]");
					СтруктураТипа.Метаданные = Метаданные;
					ТаблицаТипов.Очистить();
					мПлатформа.ДобавитьВТаблицуТипов(ТаблицаТипов, СтруктураТипа);
				КонецЕсли;
			КонецЕсли;
			СобытияМодуля = ирКэш.СобытияПоИмениОбщегоТипаЛкс("МодульКоманды");
			ЗаполнитьОписанияПараметровИзСобытия(СобытияМодуля[0]);
		КонецЕсли;
		// Подсказка по параметрам обработчиков с фиксированными именами
		Если Ложь
			Или ирОбщий.СтрКончаетсяНаЛкс(мМодульМетаданных.Имя, ".МодульКоманды") 
			Или ирОбщий.СтрКончаетсяНаЛкс(мМодульМетаданных.Имя, ".МодульМенеджера") 
			Или ирОбщий.СтрКончаетсяНаЛкс(мМодульМетаданных.Имя, ".МодульОбъекта")
			Или ирОбщий.СтрКончаетсяНаЛкс(мМодульМетаданных.Имя, ".МодульНабораЗаписей")
			Или ирОбщий.СтрКончаетсяНаЛкс(мМодульМетаданных.Имя, ".МодульМенеджераЗначения")
			Или ирОбщий.СтрКончаетсяНаЛкс(мМодульМетаданных.Имя, ".МодульУправляемогоПриложения")
			Или ирОбщий.СтрКончаетсяНаЛкс(мМодульМетаданных.Имя, ".МодульОбычногоПриложения")
			Или ирОбщий.СтрКончаетсяНаЛкс(мМодульМетаданных.Имя, ".МодульСеанса")
		Тогда
			СобытияМодуля = ирКэш.СобытияПоИмениОбщегоТипаЛкс(мМодульМетаданных.СтруктураТипа.ИмяОбщегоТипа);
			СтрокаСобытия = ирОбщий.НайтиЭлементКоллекцииЛкс(СобытияМодуля, "НСлово", НРег(мМетодМодуля.Имя));
			Если СтрокаСобытия <> Неопределено Тогда 
				ЗаполнитьОписанияПараметровИзСобытия(СтрокаСобытия);
				Если Истина
					И СтрокаСобытия.Слово = "ОбработкаПолученияДанныхВыбора" 
					И СтрокаПараметраМетода.Имя = "Параметры"
				Тогда
					СтруктураТипа = мПлатформа.НоваяСтруктураТипа("Структура");
					СтруктураТипа.Метаданные = Новый Структура("СтрокаПоиска, Отбор, ВыборГруппИЭлементов, СпособПоискаСтроки, ПолнотекстовыйПоиск, РежимПолученияДанныхВыбора");
					мПлатформа.ДобавитьВТаблицуТипов(ТаблицаТипов, СтруктураТипа);
				КонецЕсли;
			КонецЕсли;
		КонецЕсли;
		// Подсказка по параметру "Источник" обработчиков подписок на события
		Если Истина
			И СтрокаПараметраМетода.Имя = "Источник"
			И ирОбщий.СтрНачинаетсяСЛкс(мМодульМетаданных.Имя, "ОбщийМодуль.")
			И ТипЗнч(мМодульМетаданных.СтруктураТипа.Метаданные) = Тип("ОбъектМетаданных")
		Тогда
			ОбъектМД = мМодульМетаданных.СтруктураТипа.Метаданные; // ОбъектМетаданныхОбщийМодуль
			ИмяМодуля = ОбъектМД.Имя; 
			Для Каждого ПодпискаНаСобытие Из Метаданные.ПодпискиНаСобытия Цикл
				Если ирОбщий.СтрокиРавныЛкс(ПодпискаНаСобытие.Обработчик, ИмяМодуля + "." + мМетодМодуля.Имя) Тогда 
					мПлатформа.ДобавитьВТаблицуТипов(ТаблицаТипов, ПодпискаНаСобытие.Источник);
				КонецЕсли;
			КонецЦикла;
		КонецЕсли; 
	КонецЕсли; 
	
	// Тип из комментария
	ТипЗначения = СтрокаПараметраМетода.ТипЗначения;
	Если ПустаяСтрока(ТипЗначения) Тогда
		ТипЗначения = ирОбщий.ПервыйФрагментЛкс(СтрокаПараметраМетода.Описание, ":");
	КонецЕсли;
	Если ЗначениеЗаполнено(ТипЗначения) Тогда 
		ТипЗначения = СокрЛП(ТипЗначения);
		ТаблицаТиповНазначенных = ТаблицаТиповИзТекста(ТипЗначения, СтрокаПараметраМетода.Описание,, ДляСвойства);
		мПлатформа.ДобавитьВТаблицуТипов(ТаблицаТипов, ТаблицаТиповНазначенных);  
		Если мПлатформа.ЛиДетальностьТиповДостаточна(ТаблицаТипов, 4, Истина) Тогда 
			Перейти ~Выход;
		КонецЕсли;
		Если ТаблицаТипов.Количество() > 0 Тогда
			ИмяОбщегоТипа = ТаблицаТипов[0].ИмяОбщегоТипа;
			Если Ложь
				// TODO переделать на мМассивТиповСМетаданными
				Или ИмяОбщегоТипа = "ТаблицаЗначений"
				Или ИмяОбщегоТипа = "ДеревоЗначений"
				Или ИмяОбщегоТипа = "СтрокаТаблицыЗначений"
				Или ИмяОбщегоТипа = "СтрокаДереваЗначений"
				Или ИмяОбщегоТипа = "ВыборкаИзРезультатаЗапроса"
				Или ИмяОбщегоТипа = "Структура"
				Или ИмяОбщегоТипа = "ФиксированнаяСтруктура"
				Или ИмяОбщегоТипа = "Соответствие"
				Или ИмяОбщегоТипа = "ФиксированноеСоответствие"
				Или ИмяОбщегоТипа = "СписокЗначений"
				Или ИмяОбщегоТипа = "Массив"
				Или ИмяОбщегоТипа = "Запрос"
				Или ИмяОбщегоТипа = "РезультатЗапроса"
				Или ИмяОбщегоТипа = "ПостроительЗапроса"
				Или ИмяОбщегоТипа = "ПостроительОтчета"
				Или ИмяОбщегоТипа = "МенеджерВременныхТаблиц"
				Или ИмяОбщегоТипа = "Отбор"
				Или ИмяОбщегоТипа = "ДанныеФормыСтруктура"
				Или ИмяОбщегоТипа = "ДанныеФормыСтруктураСКоллекцией"
				Или ИмяОбщегоТипа = "ДанныеФормыКоллекция"
				Или ИмяОбщегоТипа = "ДанныеФормыКоллекцияЭлементовДерева"
				Или ИмяОбщегоТипа = "ДанныеФормыДерево"
				Или ИмяОбщегоТипа = "ДанныеФормыЭлементКоллекции"
				Или ИмяОбщегоТипа = "ДанныеФормыЭлементДерева"
				Или ИмяОбщегоТипа = "Форма"
				Или ИмяОбщегоТипа = "ТабличноеПоле"
				Или ИмяОбщегоТипа = "КоманднаяПанель"
				Или ИмяОбщегоТипа = "ФормаКлиентскогоПриложения"
				Или ИмяОбщегоТипа = "УправляемаяФорма"
				Или ИмяОбщегоТипа = "ДекорацияФормы"
				Или ИмяОбщегоТипа = "ГруппаФормы"
				Или ИмяОбщегоТипа = "ПолеФормы"
				Или ИмяОбщегоТипа = "ТаблицаФормы"
				Или ИмяОбщегоТипа = "Произвольный"
			Тогда
				//
			Иначе 
				Перейти ~Выход;
			КонецЕсли;
		КонецЕсли;
	КонецЕсли;
	
	// Анализ локальных вызовов
	Если Не ирОбщий.СтрокиРавныЛкс(ТипЗначения, "Произвольный") Тогда
		ПолеТекстаПрограммыВызова = Неопределено;
		МинДетальность = 3;
		МаксЧислоВызовов = 3;
		СчетчикВызовов = 0;
		ИндексПараметра = ПараметрыМетода.Индекс(СтрокаПараметраМетода);       
		ШаблонПараметра = "(" + шВыражениеПрограммы + ")?" + шРазделитель + "*(?:$|,|\))";
		ПрямыеВызовыМетодов = мМодульМетаданных.ПрямыеВызовыМетодов;
		Если ПрямыеВызовыМетодов = Неопределено Тогда
			ПрямыеВызовыМетодов = мПлатформа.НовыйИндексПоискаВызововСловаВМодуле(мМодульМетаданных);
			ЗаполнитьИндексПоискаВызововМетодовВМодуле(ПрямыеВызовыМетодов, мОригинальныйТекст);
			мМодульМетаданных.ПрямыеВызовыМетодов = ПрямыеВызовыМетодов;
			ирОбщий.ДобавитьИндексВТаблицуЛкс(ПрямыеВызовыМетодов.Вызовы, "НомерСлова");
			ПрямыеВызовыМетодов.Вызовы.Колонки.Добавить("ПараметрыВызова"); // Строка, Массив 
			ПрямыеВызовыМетодов.Вызовы.Колонки.Добавить("ТекстВхождения"); // Строка               
			ПрямыеВызовыМетодов.Вызовы.Колонки.Добавить("Метод"); // Строка       
			Если ПрямыеВызовыМетодов.Оповещения <> Неопределено Тогда
				ирОбщий.ДобавитьИндексВТаблицуЛкс(ПрямыеВызовыМетодов.Оповещения, "НомерСлова");
				ПрямыеВызовыМетодов.Оповещения.Колонки.Добавить("Метод"); // Строка
			КонецЕсли;
		Иначе
			мПлатформа.ВыполнитьОтложенноеОбновлениеВызововСловМодуля(мМодульМетаданных);
		КонецЕсли;
		ОтфильтрованныеВхождения = Новый Массив; 
		НомерМетодаВИндексе = Неопределено;
		Если ПрямыеВызовыМетодов.СтруктураСлов.Свойство(мМетодМодуля.Имя, НомерМетодаВИндексе) Тогда 
			ВхожденияВызова = ПрямыеВызовыМетодов.Вызовы.НайтиСтроки(Новый Структура("НомерСлова", НомерМетодаВИндексе));
			ВГраница = ВхожденияВызова.Количество() - 1;
			Для Счетчик = 0 По ВГраница Цикл
				// Идем с краев к середине модуля, чтобы увеличить вероятность найти выгодный вызов
				Индекс = Цел(Счетчик/2);
				Если Счетчик % 2 = 0 Тогда
					Индекс = ВГраница - Индекс;
				КонецЕсли;
				ВхождениеВызова = ВхожденияВызова[Индекс];
				ЛиПодходящее = Истина;
				Если Истина
					И ВхождениеВызова.ПозицияВхождения > мМетодМодуля.ПозицияОпределения 
					И ВхождениеВызова.ПозицияВхождения < мМетодМодуля.ПозицияТела
				Тогда
					// В области заголовка определения текущего метода
					ЛиПодходящее = Ложь;
				КонецЕсли;
				ПараметрыВызова = ВхождениеВызова.ПараметрыВызова;
				Если ПараметрыВызова = Неопределено Тогда
					Если ВхождениеВызова.ТекстВхождения = Неопределено Тогда
						ВхождениеВызова.ТекстВхождения = Сред(мОригинальныйТекст, ВхождениеВызова.ПозицияВхождения + 1, ВхождениеВызова.ДлинаВхождения);
					КонецЕсли;
					ПараметрыВызова = Сред(ВхождениеВызова.ТекстВхождения, Найти(Сред(ВхождениеВызова.ТекстВхождения, 2), "(") + 2);
					ВхождениеВызова.ПараметрыВызова = ПараметрыВызова;
				КонецЕсли;
				Если ТипЗнч(ПараметрыВызова) = Тип("Строка") Тогда
					// Грубая проверка, что не указан фактический параметр
					Если Ложь
						Или ПараметрыВызова = ")" // Нельзя отрезать этот символ, т.к. далее вызывается СтрокаБезКонцаЛкс
						Или ИндексПараметра > СтрЧислоВхождений(ПараметрыВызова, ",") 
					Тогда
						ЛиПодходящее = Ложь;
					КонецЕсли;
				Иначе 
					ЛиПодходящее = ПараметрыВызова.Количество() > ИндексПараметра; 
				КонецЕсли;
				Если ЛиПодходящее Тогда
					ОтфильтрованныеВхождения.Добавить(ВхождениеВызова);
					Если ОтфильтрованныеВхождения.Количество() >= МаксЧислоВызовов * 3 Тогда
						Прервать;
					КонецЕсли;
				КонецЕсли;
			КонецЦикла;
		КонецЕсли;
		Для Каждого ВхождениеВызова Из ОтфильтрованныеВхождения Цикл
			ПараметрыВызова = ВхождениеВызова.ПараметрыВызова;
			Если ТипЗнч(ПараметрыВызова) = Тип("Строка") Тогда
				ПараметрыВызова = ирОбщий.НайтиРегВыражениеЛкс(ВхождениеВызова.ПараметрыВызова, ШаблонПараметра,,,,,, Истина, мРегВыражение); // Передаем РегВыражение для ускорения
				ВхождениеВызова.ПараметрыВызова = ПараметрыВызова;
			КонецЕсли;
			#Если Сервер И Не Сервер Тогда
				ПараметрыВызова = Обработки.ирПлатформа.Создать().ВхожденияРегВыражения;
			#КонецЕсли
			// Точная проверка, что указан нужный фактический параметр
			Если ПараметрыВызова.Количество() > ИндексПараметра Тогда
				ВхождениеПараметра = ПараметрыВызова[ИндексПараметра];
				ФактическийПараметр = СокрЛП(ирОбщий.СтрокаБезКонцаЛкс(ВхождениеПараметра.ТекстВхождения));
				Если ЛиБесполезноеПрисвоениеПеременной(ФактическийПараметр) Тогда
					Если ЗначениеЗаполнено(ФактическийПараметр) Тогда
						мПлатформа.ДобавитьВТаблицуТипов(ТаблицаТипов, мПлатформа.НоваяСтруктураТипа(ФактическийПараметр));
					КонецЕсли;
					Продолжить;
				ИначеЕсли ЛиБулевыйЛитерал(ФактическийПараметр) Тогда
					мПлатформа.ДобавитьВТаблицуТипов(ТаблицаТипов, мПлатформа.НоваяСтруктураТипа("Булево"));
				Иначе
					Если ПолеТекстаПрограммыВызова = Неопределено Тогда
						ПолеТекстаПрограммыВызова = КопияКомпоненты();
					КонецЕсли;
					#Если Сервер И Не Сервер Тогда
						ПолеТекстаПрограммыВызова = Обработки.ирКлсПолеТекстаПрограммы.Создать();
					#КонецЕсли 
					//! ЗагрузитьМетодМодуляПоПозицииИРазобратьКонтекст(ВхождениеВызова.ПозицияВхождения,, ВхождениеВызова);
					НачальнаяПозицияБлока = ПолеТекстаПрограммыВызова.ЗагрузитьМетодМодуляПоПозицииИРазобратьКонтекст(ВхождениеВызова.ПозицияВхождения,, ВхождениеВызова);
					Если ПолеТекстаПрограммыВызова.мМетодМодуля = Неопределено Тогда
						ИмяВызывающегоМетода = мПлатформа.ИмяМетодаИнициация();
					Иначе
						ИмяВызывающегоМетода = ПолеТекстаПрограммыВызова.мМетодМодуля.Имя;
						Если Истина
							И ОтфильтрованныеВхождения.Найти(ВхождениеВызова) < ОтфильтрованныеВхождения.Количество() - 1 
							И (Ложь
								Или ПолеТекстаПрограммыВызова.мМетодМодуля.ДлинаОпределения > 20000 // Для ускорения. Для Обработка.ирКлсПолеТекстаПрограммы.Форма.КонструкторЗапроса.ЗаполнитьПоТокену() нужно 20000
								Или ИмяВызывающегоМетода = мМетодМодуля.Имя)
						Тогда
							// Пропускаем прямую рекурсию и большие методы, кроме последнего
							Продолжить;
						КонецЕсли;
					КонецЕсли;
					КлючВызова = ИмяВызывающегоМетода + "-" + мМетодМодуля.Имя + "-" + СтрокаПараметраМетода.Имя + "-" + ДляСвойства;
					Если ПройденныеВызовы[КлючВызова] = Неопределено Тогда 
						ПройденныеВызовы[КлючВызова] = 1; // Таким образом мы не более одного вызова из каждого ключа проверяем
						ТаблицаТиповИсточник = ПолеТекстаПрограммыВызова.ВычислитьТипЗначенияВыражения(ФактическийПараметр,,,,,, Ложь,,,,, ВхождениеВызова.ПозицияВхождения - 1 - НачальнаяПозицияБлока,, ДляСвойства);
						Если мПлатформа.ЛиДетальностьТиповДостаточна(ТаблицаТиповИсточник, 1) Тогда 
							мПлатформа.ДобавитьВТаблицуТипов(ТаблицаТипов, ТаблицаТиповИсточник);
							Если мПлатформа.ЛиДетальностьТиповДостаточна(ТаблицаТиповИсточник, МинДетальность) Тогда
								Прервать; 
							КонецЕсли;
						КонецЕсли;
						СчетчикВызовов = СчетчикВызовов + 1;
						Если МаксЧислоВызовов = СчетчикВызовов Тогда
							Прервать;
						КонецЕсли;
					КонецЕсли;
				КонецЕсли;
			КонецЕсли;
		КонецЦикла;
		Если Истина
			И мМетодМодуля.Клиент
			И ИндексПараметра = 1 // Было 0 (иногда нужно) 
			И ПараметрыМетода.Количество() = 2 
			И ПрямыеВызовыМетодов.Оповещения <> Неопределено
		Тогда
			ВхожденияВызова = ПрямыеВызовыМетодов.Оповещения.НайтиСтроки(Новый Структура("НомерСлова", НомерМетодаВИндексе));
			Для Каждого ВхождениеВызова Из ВхожденияВызова Цикл
				Если ПолеТекстаПрограммыВызова = Неопределено Тогда
					ПолеТекстаПрограммыВызова = КопияКомпоненты();
				КонецЕсли;
				#Если Сервер И Не Сервер Тогда
					ПолеТекстаПрограммыВызова = Обработки.ирКлсПолеТекстаПрограммы.Создать();
				#КонецЕсли 
				НачальнаяПозицияБлока = ПолеТекстаПрограммыВызова.ЗагрузитьМетодМодуляПоПозицииИРазобратьКонтекст(ВхождениеВызова.ПозицияВхождения,, ВхождениеВызова);
				ТаблицаТиповИсточник = ПолеТекстаПрограммыВызова.ВычислитьТипЗначенияВыражения(ВхождениеВызова.Параметр,,,,,, Ложь,,,,, ВхождениеВызова.ПозицияВхождения - 1 - НачальнаяПозицияБлока,, ДляСвойства);
				Если мПлатформа.ЛиДетальностьТиповДостаточна(ТаблицаТиповИсточник, 1) Тогда 
					мПлатформа.ДобавитьВТаблицуТипов(ТаблицаТипов, ТаблицаТиповИсточник);
					Если мПлатформа.ЛиДетальностьТиповДостаточна(ТаблицаТиповИсточник, МинДетальность) Тогда
						Прервать;
					КонецЕсли;
				КонецЕсли;
			КонецЦикла;
		КонецЕсли;
	КонецЕсли;
~Выход:
	// Ключевым является обязательный параметр составного типа или типа с собственными метаданными
	ЛиКлючевойПараметр = Истина
		И мРекурсивныйПуть.ВычислениеРезультатаМетода = мМетодМодуля.Имя 
		И мРекурсивныйПуть.ДобавлятьКлючевыеПараметры; // Для Вычислить()
	Если Истина
		И Не ЛиКлючевойПараметр 
		//И ПустаяСтрока(СтрокаПараметраМетода.Значение) 
	Тогда 
		ЛиКлючевойПараметр = Ложь
			Или ТаблицаТипов.Количество() - ТаблицаТипов.НайтиСтроки(Новый Структура("ИмяОбщегоТипа", "Неопределено")).Количество() > 1 
			Или ТаблицаТипов.Найти("Произвольный", "ИмяОбщегоТипа") <> Неопределено
			Или (Истина
				И ТаблицаТипов.Найти("Строка", "ИмяОбщегоТипа") <> Неопределено
				И Найти(мТекстБлока, "Новый Структура(" + СтрокаПараметраМетода.Имя) > 0); 
		Если Не ЛиКлючевойПараметр Тогда
			Для Каждого СтрокаТипа Из ТаблицаТипов Цикл
				Попытка
					Тип = Тип(СтрокаТипа.ИмяОбщегоТипа);
				Исключение 
					Продолжить;
				КонецПопытки;  
				ЛиКлючевойПараметр = мПлатформа.мМассивТиповСМетаданными.Найти(Тип) <> Неопределено;
				Если ЛиКлючевойПараметр Тогда
					Прервать;
				КонецЕсли;
			КонецЦикла;
		КонецЕсли;
	КонецЕсли;
	Если ЛиКлючевойПараметр Тогда       
		ПравилоВычисленияФункции = НайтиПравилоВычисленияФункции(мМетодМодуля.Имя, мМодульМетаданных.СтруктураТипа);
		Если ПравилоВычисленияФункции = Неопределено Тогда
			КлючевыеПараметры = мМетодМодуля.КлючевыеПараметры;
			Если КлючевыеПараметры = Неопределено Тогда
				КлючевыеПараметры = Новый Структура;
				мМетодМодуля.КлючевыеПараметры = КлючевыеПараметры;
			КонецЕсли; 
			КлючевыеПараметры.Вставить(СтрокаПараметраМетода.Имя); 
		КонецЕсли;
	КонецЕсли;
	Возврат ТаблицаТипов;
КонецФункции

//.
// Параметры:
//    ПрямыеВызовыМетодов - Структура - 
//    ТекстБлока - Неопределено - 
Процедура ЗаполнитьИндексПоискаВызововМетодовВМодуле(Знач ПрямыеВызовыМетодов, Знач ТекстБлока, Знач Смещение = 0) Экспорт
	ШаблонОповещения = "";
	Если ПрямыеВызовыМетодов.Оповещения <> Неопределено Тогда
		// Добавляет 7мс на каждые 10к строк
		ШаблонОповещения = шПредИмяПрямое + "Новый\s+ОписаниеОповещения\s*\(\s*""(" + шИмя + ")""\s*,\s*(?:ЭтотОбъект|ЭтаФорма)\s*,\s*(" + шПростоеВыражениеПрограммы + ")";
	КонецЕсли;
	мПлатформа.ЗаполнитьИндексПоискаВызововСловаВМодуле(ПрямыеВызовыМетодов, ТекстБлока, ШаблонПрямогоВызоваСлова("(" + шИмя + ")",, Истина), ШаблонОповещения,, Смещение);
КонецПроцедуры

//.
// Параметры:
//    МетодМодуля - см. мМодульМетаданных.Методы.Добавить() -
//    ТекущиеАргументы - Строка - 
//    ПредшествующийТекст - Строка, Строка - 
//    ПолныйАнализСоставаТипов - Булево - 
//    ПараметрыИсходящегоВызова - Массив - 
Функция ВычислитьТипФункцииСФактПараметрами(Знач МетодМодуля, Знач ТекущиеАргументы, Знач ПредшествующийТекст, Знач ПолныйАнализСоставаТипов, Знач ПараметрыИсходящегоВызова,
	Знач ПолеТекстаПрограммыВызова = Неопределено, Знач ДляСвойства = "")
	
	Если Ложь
		Или МетодМодуля.КлючевыеПараметры = Неопределено 
		Или ТекущиеАргументы = "(" + ИмяОтключенияЛишнихВычислений() + ")"
	Тогда
		Возврат Неопределено;
	КонецЕсли;
	СчетчикиВызовов = мРекурсивныйПуть.СчетчикиВызовов; 
	КлючСчетчика = МетодМодуля.ИмяМодуля + "." + МетодМодуля.Имя;
	СчетчикВызовов = СчетчикиВызовов[КлючСчетчика];
	Если СчетчикВызовов = Неопределено Тогда
		СчетчикВызовов = 0;
	КонецЕсли;
	Если СчетчикВызовов > 0 Тогда
		// Для ускорения
		Возврат Неопределено;
	КонецЕсли;
	СчетчикВызовов = СчетчикВызовов + 1;
	СчетчикиВызовов[КлючСчетчика] = СчетчикВызовов;
	Если ПолеТекстаПрограммыВызова = Неопределено И мМодульМетаданных.Имя = МетодМодуля.ИмяМодуля Тогда
		ПолеТекстаПрограммыВызова = КопияКомпоненты();
	КонецЕсли;
	Если ПараметрыИсходящегоВызова = Неопределено Тогда
		ПараметрыИсходящегоВызова = РазобратьФактическиеПараметрыВызова(ТекущиеАргументы);
	КонецЕсли;
	ПараметрыМетода = мПлатформа.ПараметрыМетодаМодуля(МетодМодуля);
	ФактическиеПараметры = Новый Структура;
	Для Каждого КлючИЗначение Из МетодМодуля.КлючевыеПараметры Цикл 
		Если КлючИЗначение.Значение <> Неопределено Тогда
			// Защита от рекурсии. СчетчикВызовов не поможет, т.к. очищается при рекурсии в анализуемом коде.
			Возврат Неопределено;
		КонецЕсли;
		СтрокаПараметра = ПараметрыМетода.Найти(НРег(КлючИЗначение.Ключ), "НИмя");
		ИндексПараметра = ПараметрыМетода.Индекс(СтрокаПараметра);
		Если ПараметрыИсходящегоВызова.ВГраница() < ИндексПараметра Тогда
			ВыражениеПараметра = "";  
		Иначе 
			ВыражениеПараметра = ПараметрыИсходящегоВызова[ИндексПараметра];
		КонецЕсли;
		Если Не ЗначениеЗаполнено(ВыражениеПараметра) Тогда
			Продолжить;
		КонецЕсли;
		ТаблицаТиповПараметра = ВычислитьТипЗначенияВыражения(ВыражениеПараметра, ПредшествующийТекст,,,, ПолныйАнализСоставаТипов, Ложь,,, Истина,,,, ДляСвойства);
		Если Не мПлатформа.ЛиДетальностьТиповДостаточна(ТаблицаТиповПараметра, 1) Тогда 
			Продолжить;
		КонецЕсли;
		ФактическиеПараметры.Вставить(КлючИЗначение.Ключ, ТаблицаТиповПараметра);
	КонецЦикла;
	Если ФактическиеПараметры.Количество() = 0 Тогда
		Возврат Неопределено;
	КонецЕсли;
	МетодМодуля.КлючевыеПараметры = ФактическиеПараметры;
	ТаблицаТиповИсточник = мПлатформа.ПодготовитьТипРезультатаМетода(МетодМодуля, МетодМодуля.ИмяМодуля, ПолеТекстаПрограммыВызова, Истина, ДляСвойства);
	МетодМодуля.КлючевыеПараметры = ирОбщий.СкопироватьСтруктуруБезЗначенийЛкс(МетодМодуля.КлючевыеПараметры);
	Возврат ТаблицаТиповИсточник;
КонецФункции

//.
// Параметры:
//    ТекущиеАргументы - Строка - должна начинаться с "(" и кончаться на ")"
// Возвращаемое значение:
//    Массив - 
Функция РазобратьФактическиеПараметрыВызова(Знач ТекущиеАргументы) Экспорт
	ТекущиеАргументы = ТекстБезКрайнихСимволов(ТекущиеАргументы);
	МассивПараметров = Новый Массив;
	Если Найти(ТекущиеАргументы, ",") = 0 Тогда
		ОдинПараметр = СокрЛП(ТекущиеАргументы);
		Если ЗначениеЗаполнено(ОдинПараметр) Тогда
			МассивПараметров.Добавить(ОдинПараметр);
		КонецЕсли;
	Иначе 
		мРегВыражение.Global = Истина;
		Если мЯзыкПрограммы = 0 Тогда
			мРегВыражение.Pattern = "(" + шВыражениеПрограммы + ")?" + шРазделитель + "*,";
		Иначе
			мРегВыражение.Pattern = "(" + шВыражениеЗапроса   + ")?" + шРазделитель + "*,";
		КонецЕсли;
		Результат = мРегВыражение.НайтиВхождения(ТекущиеАргументы + ",",, Истина);
		Для Каждого Вхождение Из Результат Цикл
			МассивПараметров.Добавить(СокрЛП(Вхождение.SubMatches(0)));
		КонецЦикла;
	КонецЕсли;
	Возврат МассивПараметров;
КонецФункции

Функция ТекстБезКрайнихСимволов(Знач ТекущиеАргументы)
	
	Возврат Сред(ТекущиеАргументы, 2, СтрДлина(ТекущиеАргументы) - 2);

КонецФункции

//.
// Параметры:
//    СтрокаСобытия - ? - 
//    ПараметрыСобытия - ? - 
Процедура ЗаполнитьОписанияПараметровИзСобытия(СтрокаСобытия, Знач ПараметрыСобытия = Неопределено) Экспорт
	Если Истина
		И мМетодМодуля.Параметры.Количество() > 0 
		и Не ЗначениеЗаполнено(мМетодМодуля.Параметры[0].ТипЗначения)
	Тогда
		Если ПараметрыСобытия = Неопределено Тогда   
			ПараметрыСобытия = мПлатформа.ПараметрыМетодаПлатформы(СтрокаСобытия);
		КонецЕсли;
		мМетодМодуля.Описание = СтрокаСобытия.Описание;
		// TODO перенести в мПлатформа.ПараметрыМетодаМодуля()
		ИндексПараметра = 0;
		МаксИндекс = мМетодМодуля.Параметры.Количество() - 1;
		Для Каждого СтрокаПараметра Из ПараметрыСобытия Цикл
			Если МаксИндекс < ИндексПараметра Тогда
				Прервать;
			КонецЕсли;
			СтрокаПараметраЦикл = мМетодМодуля.Параметры[ИндексПараметра];
			СтрокаПараметраЦикл.ТипЗначения = СтрокаПараметра.ТипЗначения;
			СтрокаПараметраЦикл.Описание = СтрокаПараметра.Описание;
			ИндексПараметра = ИндексПараметра + 1;
		КонецЦикла;
	КонецЕсли;
КонецПроцедуры
 
Функция ШаблонПрямогоВызоваСлова(Знач ИмяВызова, Знач ТипСлова = "Метод", Знач ЛиШаблон = Ложь) Экспорт 
	
	Если Лев(ИмяВызова, 1) = "." Тогда
		Начало = "(?:" + шИмяСТочками + ")?";
	ИначеЕсли ТипСлова = "Конструктор" Тогда
		Начало = шПредИмяПрямое + "Новый\s+";
	Иначе
		// Начало = "(?:[^" + мПлатформа.шБуква + "\d\.\s]|^|[^\.\s]\s+)" // Более строгий, но медленный
		Начало = шПредИмяПрямое;
	КонецЕсли;
	Если Не ЛиШаблон Тогда
		ИмяВызова = ирОбщий.ПодготовитьТекстДляРегВыраженияЛкс(ИмяВызова);
	КонецЕсли;
	ШаблонВызова = Начало + ИмяВызова;
	Если ТипСлова = "Свойство" Тогда
		ШаблонВызова = ШаблонВызова + шПостИмяСвойства; 
	Иначе 
		ШаблонВызова = ШаблонВызова + "\s*\(((?:(?:" + шВыражениеПрограммы + ")?" + шРазделитель + "*(?=[,\)])|,)*)\)";
	КонецЕсли;
	Возврат ШаблонВызова;

КонецФункции

Функция МодульМетаданныхКонтекста(Знач РодительскаяСтрутураТипа)
	
	Если РодительскаяСтрутураТипа.ИмяОбщегоТипа = "Локальный" Тогда
		МодульМетаданных = мМодульМетаданных;
	Иначе
		МодульМетаданных = Неопределено;
	КонецЕсли;
	Возврат МодульМетаданных;

КонецФункции

// Определяет тип значения слова в режиме внутреннего языка.
//
// Параметры:
//  Выражение					 - Строка		 - 
//  ТекстДляПоискаОпределения	 - Строка		 - где ищем определение;
//  ПредшествующийТекст			 - 				 - 
//  РазрешитьАнализИмениТипа	 - 				 - 
//  ЭтоВызовКонструктора		 - Булево - передается когда выражение конструктора передано без слова "Новый"
//  ПолныйАнализСоставаТипов	 - 				 - 
//  ЛиКорневойВызов				 - 				 - 
//  ГлобальныйПоискВМодуле		 - 				 - 
//  ТаблицаТиповОтРодителя		 - 				 - 
//  ВычислитьЗначение			 - 				 - 
//  Позиция0ВМетодеОт			 - 				 - 
//  Позиция0ВМетодеДо			 - 				 - 
//  ДопКлючКэша					 - 				 - Применяется при ЛиКорневойВызов Или мРекурсивныйПуть = Неопределено. Значение Неопределено отключает кэш выражений.
//  ДляСвойства					 - Строка - путь к свойству, например "ПервыйБлок.Начало"
//  СобиратьОшибки				 - Булево		 - 
//  ВсеПрисвоения				 - СписокЗначений, Неопределено	 - 
// 
// Возвращаемое значение:
//  см. мПлатформа.НоваяТаблицаТипов()
//
Функция ВычислитьТипЗначенияВыражения(Знач Выражение = "", Знач ТекстДляПоискаОпределения = "", Знач ПредшествующийТекст = "", Знач РазрешитьАнализИмениТипа = Ложь,
	Знач ЭтоВызовКонструктора = Ложь, ПолныйАнализСоставаТипов = Истина, Знач ЛиКорневойВызов = Истина, Знач ГлобальныйПоискВМодуле = Ложь, Знач ТаблицаТиповОтРодителя = Неопределено, Знач ВычислитьЗначение = Ложь,
	Знач Позиция0ВМетодеОт = 0, Знач Позиция0ВМетодеДо = 0, Знач ДопКлючКэша = "", Знач ДляСвойства = "", СобиратьОшибки = Ложь, ВсеПрисвоения = Неопределено, Знач ЛиПолноеВыражение = Истина) Экспорт
	
	#Если Сервер И Не Сервер Тогда
		мПлатформа = Обработки.ирПлатформа.Создать();
		мРегВыражение = Обработки.ирОболочкаРегВыражение.Создать();
	#КонецЕсли  
	Если ЛиКорневойВызов Или мРекурсивныйПуть = Неопределено Тогда
		ИнициироватьРекурсивныйПуть(Выражение, ДопКлючКэша);
	КонецЕсли;
	//Если мПлатформа.мРежимПроверкиМодуля Тогда
	//	ДляСвойства = ""; // При включенной строке проверка этого модуля 100с, а при отключенной 88с
	//КонецЕсли;
	ГлобальныйПоискВМодулеВход = ГлобальныйПоискВМодуле;
	Если ГлобальныйПоискВМодуле Тогда
		СтарыйМетод = мМетодМодуля;
		Если СтрДлина(мОригинальныйТекст) > 100000 Тогда
			// В больших модулях глобальный поиск типа делаем только в блоке инициации модуля
			ЗагрузитьМетодМодуля(Неопределено);
			ГлобальныйПоискВМодуле = Ложь; 
			ТекстДляПоиска = мМодульМетаданных.ТекстПоискаОпределенияСловМодуля;
			Если ТекстДляПоиска = Неопределено Тогда
				ИменаМетодов = Новый Структура;
				ИменаМетодов.Вставить("ПриСозданииНаСервере");
				ИменаМетодов.Вставить("ПриОткрытии");
				ВхожденияВызова = ирОбщий.НайтиРегВыражениеЛкс(мТекстБлока, мПлатформа.шПустоеНачалоСтроки + "(?:" + шНачалоДок + "\s*)?(" + шИмя + ")\(\)",,,,,, Истина, мРегВыражение); // Передаем РегВыражение для ускорения
				Если ВхожденияВызова.Количество() > 0 Тогда
					Для Каждого ВхождениеВызова Из ВхожденияВызова Цикл
						ИменаМетодов.Вставить(ВхождениеВызова.Подгруппы.Submatches(0));
					КонецЦикла;
				КонецЕсли;
				ТелаМетодов = Новый Массив;
				Для Каждого КлючИЗначение Из ИменаМетодов Цикл
					СтрокаМетода = мМодульМетаданных.Методы.Найти(НРег(КлючИЗначение.Ключ), "НИмя");
					Если СтрокаМетода <> Неопределено Тогда
						ТелаМетодов.Добавить(ТелоМетода(СтрокаМетода));
					КонецЕсли;
				КонецЦикла;
				Если ТелаМетодов.Количество() > 0 Тогда
					ТелаМетодов.Вставить(0, мТекстБлока);
					ТекстДляПоиска = ирОбщий.СтрСоединитьЛкс(ТелаМетодов, Символы.ПС);
				Иначе 
					ТекстДляПоиска = мТекстБлока;
				КонецЕсли;
				мМодульМетаданных.ТекстПоискаОпределенияСловМодуля = ТекстДляПоиска;
			КонецЕсли;
			мТекстБлока = ТекстДляПоиска;
		Иначе 
			ТекстДляПоискаОпределения = мОригинальныйТекст;
		КонецЕсли;
	КонецЕсли;
	Если Не ГлобальныйПоискВМодуле Тогда 
		Если Не ЗначениеЗаполнено(ТекстДляПоискаОпределения) Тогда
			Если мЯзыкПрограммы = 1 Тогда
				ТекстДляПоискаОпределения = мТекстБлока;
			Иначе
				ТекстДляПоискаОпределения = ДиапазонТекстаДляПоиска(мТекстБлока, Позиция0ВМетодеОт, Позиция0ВМетодеДо);
			КонецЕсли;
		КонецЕсли;
		Если Не ЗначениеЗаполнено(ПредшествующийТекст) Тогда
			Если РазрешитьАнализИмениТипа И ЗначениеЗаполнено(Позиция0ВМетодеДо) Тогда
				ПредшествующийТекст = Лев(мТекстБлока, Позиция0ВМетодеДо);
			Иначе 
				ПредшествующийТекст = ТекстДляПоискаОпределения;
			КонецЕсли;
		КонецЕсли;
		Если Не ЗначениеЗаполнено(Позиция0ВМетодеДо) Тогда
			Позиция0ВМетодеДо = СтрДлина(ТекстДляПоискаОпределения);
		КонецЕсли;
		Если мЯзыкПрограммы <> ЯзыкПрограммы Тогда
			// TODO Сделать более универсально. Возможно надо сразу при разборе мТекстБлока очищать от символов разметки с сохранением позиций
			ТекстДляПоискаОпределения = СтрЗаменить(ТекстДляПоискаОпределения, "|", " "); 
			Если Прав(ТекстДляПоискаОпределения, 1) = """" Тогда
				ТекстДляПоискаОпределения = ирОбщий.СтрокаБезКонцаЛкс(ТекстДляПоискаОпределения);
			КонецЕсли;
		КонецЕсли;
	КонецЕсли;
	Если ТаблицаТиповОтРодителя <> Неопределено Тогда
		ТаблицаТипов = ТаблицаТиповОтРодителя;
	Иначе 
		ТаблицаТипов = мПлатформа.НоваяТаблицаТипов();
	КонецЕсли;
	СтруктураТипа = НоваяСтруктураТипа();
	Если РазрешитьАнализИмениТипа Тогда
		ПредшествующийТекстКонец = Прав(ПредшествующийТекст, 200);
		Если мЯзыкПрограммы = 1 Тогда
			мТолькоСсылочныеИменаТипов = Истина;
			мРегВыражение.Global = Истина;
			мРегВыражение.Pattern = шПредИмяПрямое + "(?:ССЫЛКА|REFS)" + шРазделитель + "+$";
			Вхождения = мРегВыражение.НайтиВхождения(ПредшествующийТекстКонец);
			Если Вхождения.Количество() > 0 Тогда
				СтруктураТипа.ТипЯзыка = "ИмяТипа";
			КонецЕсли;
			//RegExp.Pattern = шПредИмяПрямое + "(?:ВЫРАЗИТЬ|CAST)" + шРазделитель + "*\(" + шВыражениеЗапроса + шРазделитель + "+(?:КАК|AS)" + шРазделитель + "+$"; // Привязка к концу вызывала катастрофическое шагание назад
			мРегВыражение.Pattern = шПредИмяПрямое + "(?:ВЫРАЗИТЬ|CAST)" + шРазделитель + "*\(" + шВыражениеЗапроса + шРазделитель + "+(?:КАК|AS)" + шРазделитель + "+"; // 08.02.2023
			Вхождения = мРегВыражение.НайтиВхождения(ПредшествующийТекстКонец, Истина);
			Если Истина
				И Вхождения.Количество() > 0 
				И ПустаяСтрока(Сред(ПредшествующийТекстКонец, Вхождения[0].FirstIndex + Вхождения[0].Length)) // 08.02.2023
			Тогда
				СтруктураТипа.ТипЯзыка = "ИмяТипа";
				мТолькоСсылочныеИменаТипов = Ложь;
			КонецЕсли;
			мРегВыражение.Pattern = шПредИмяПрямое + "(?:ТИП|TYPE)" + шРазделитель + "*\(" + шРазделитель + "*$";
			Вхождения = мРегВыражение.НайтиВхождения(ПредшествующийТекстКонец);
			Если Вхождения.Количество() > 0 Тогда
				СтруктураТипа.ТипЯзыка = "ИмяТипа";
				мТолькоСсылочныеИменаТипов = Ложь;
			КонецЕсли;
			мРегВыражение.Pattern = шПредИмяПрямое + "(?:ЗНАЧЕНИЕ|VALUE)" + шРазделитель + "*\(" + шРазделитель + "*$";
			Вхождения = мРегВыражение.НайтиВхождения(ПредшествующийТекстКонец);
			Если Вхождения.Количество() > 0 Тогда
				СтруктураТипа.ТипЯзыка = "ЗначениеВЗапросе";
			КонецЕсли;
		Иначе
			мРегВыражение.Global = Истина;
			мРегВыражение.Pattern = шПредИмяПрямое + "(?:Новый|New)" + шРазделитель + "+$";
			Вхождения = мРегВыражение.НайтиВхождения(ПредшествующийТекстКонец);
			Если Вхождения.Количество() > 0 Тогда
				СтруктураТипа.Вставить("Конструктор", Истина);
				СтруктураТипа.ТипЯзыка = "ИмяТипа";
			КонецЕсли;
			мРегВыражение.Pattern = шПредИмяПрямое + "(?:Новый|New)" + шРазделитель + "*\(" + шРазделитель + "*""$";
			Вхождения = мРегВыражение.НайтиВхождения(ПредшествующийТекстКонец);
			Если Вхождения.Количество() > 0 Тогда
				// Активная следующая строка блокирует недокументированные возможности.
				//СтруктураТипа.Вставить("Конструктор", Истина);
				СтруктураТипа.ТипЯзыка = "ИмяТипа";
			КонецЕсли;
			мРегВыражение.Pattern = шПредИмяПрямое + "Тип" + шРазделитель + "*\(" + шРазделитель + "*""$";
			Вхождения = мРегВыражение.НайтиВхождения(ПредшествующийТекстКонец);
			Если Вхождения.Количество() > 0 Тогда
				СтруктураТипа.ТипЯзыка = "ИмяТипа";
			КонецЕсли;
			мРегВыражение.Pattern = шПредИмяПрямое + "(?:Новый|New)" + шРазделитель + "*ОписаниеТипов\(" + шРазделитель + "*""[^""]*$";
			Вхождения = мРегВыражение.НайтиВхождения(ПредшествующийТекстКонец);
			Если Вхождения.Количество() > 0 Тогда
				СтруктураТипа.ТипЯзыка = "ИмяТипа";
			КонецЕсли;
		КонецЕсли;
		Если Ложь
			Или СтруктураТипа.ТипЯзыка = "ИмяТипа"
			Или СтруктураТипа.ТипЯзыка = "ЗначениеВЗапросе"
		Тогда
			СтруктураТипа.ИмяОбщегоТипа = "";
		Иначе
			РазрешитьАнализИмениТипа = Ложь;
			Если мЭтоТекстовыйЛитерал Тогда
				ИмяОтключенияЛишнихВычислений = ИмяОтключенияЛишнихВычислений();
				ТаблицаТипов = ВычислитьТипЗначенияВыражения(мВызовМетода + ИмяОтключенияЛишнихВычислений + ")", ТекстДляПоискаОпределения, ПредшествующийТекст,, мЭтоКонструктор, ПолныйАнализСоставаТипов,
					Ложь,,,,, Позиция0ВМетодеДо,, ДляСвойства); // ИмяФиктивногоСвойства() нельзя всегда передавать, т.к. Запрос.УстановитьПараметр("") не будет собирать данные. Вместо этого теперь подавляем лишние вычисления через ИмяОтключенияЛишнихВычислений 
				Возврат ТаблицаТипов;
			КонецЕсли; 
		КонецЕсли;
	КонецЕсли;
	Если Ложь
		Или Выражение = Неопределено
		Или Выражение = ""
	Тогда
		Если СтруктураТипа.ИмяОбщегоТипа = "НеизвестныйКонтекст" Тогда
			СтруктураТипа.ИмяОбщегоТипа = "Локальный"; // Приватные свойства + глобальный контекст
			мПлатформа.ДобавитьВТаблицуТипов(ТаблицаТипов, СтруктураТипа);
			Если мМодульМетаданных <> Неопределено И мМодульМетаданных.СтруктураТипа <> Неопределено Тогда
				мПлатформа.ДобавитьВТаблицуТипов(ТаблицаТипов, мМодульМетаданных.СтруктураТипа);
			КонецЕсли;
		КонецЕсли;
	ИначеЕсли Нрег(Выражение) = "неопределено" Тогда
		СтруктураТипа.ИмяОбщегоТипа = "Неопределено";
	ИначеЕсли Лев(Выражение, 1) = """" Тогда
		СтруктураТипа.ИмяОбщегоТипа = "Строка";
		Если ВычислитьЗначение И Прав(Выражение, 1) = """" Тогда 
			СтруктураТипа.Метаданные = ирОбщий.ТекстИзВстроенногоЯзыкаЛкс(Выражение);
			//Если СтрДлина(СтруктураТипа.Метаданные) > 50 Тогда // Для сбора текстов запроса нужно обязательно возвращать координаты
				СтруктураТипа.ДержательМетаданных = НовыеКоординатыВыражения(Выражение, Позиция0ВМетодеДо);
			//КонецЕсли;
		КонецЕсли;
	ИначеЕсли Ложь
		Или ирОбщий.ЛиЦифраЛкс(Лев(Выражение, 1)) 
	Тогда
		СтруктураТипа.ИмяОбщегоТипа = "Число";
		Если ВычислитьЗначение Тогда 
			Попытка
				СтруктураТипа.Метаданные = Число(Выражение);
			Исключение
			КонецПопытки;
		КонецЕсли;
	ИначеЕсли Ложь
		Или ЛиБулевыйЛитерал(Выражение, СтруктураТипа.Метаданные) 
		Или (Истина
			И Найти(Выражение, "(") = 0 
			И Найти(Выражение, "[") = 0 
			И (Ложь
				Или Найти(Выражение, ">") > 0 
				Или Найти(Выражение, "=") > 0))
	Тогда
		СтруктураТипа.ИмяОбщегоТипа = "Булево";
	ИначеЕсли мЯзыкПрограммы = 0 И ирОбщий.СтрНачинаетсяСЛкс(Выражение, "?(") Тогда
		ПараметрыВызова = РазобратьФактическиеПараметрыВызова(Сред(Выражение, 2));
		Для Счетчик = 1 По Мин(2, ПараметрыВызова.ВГраница()) Цикл
			мПлатформа.ДобавитьВТаблицуТипов(ТаблицаТипов, ВычислитьТипЗначенияВыражения(ПараметрыВызова[Счетчик], ТекстДляПоискаОпределения, ПредшествующийТекст,,,, Ложь,,,,,
				Позиция0ВМетодеДо,, ДляСвойства, СобиратьОшибки));
		КонецЦикла;
	Иначе                        
		ВычислениеРазрешено = Истина;
		ЛиВиртПрисвоение = Ложь;    
		ЛиПеременнаяРезультата = Выражение = ИмяПеременнойВозвращаемогоЗначения();
		ТекущееСлово = Выражение;
		ДляСвойстваВверх = Неопределено;
		ТекущийИндекс = Неопределено;
		ТекущиеАргументы = Неопределено;
		Если мЯзыкПрограммы = 1 И Лев(Выражение, 1) = "&" Тогда
			РодительскийКонтекст = "";
			ТекущееСлово = Выражение;
		Иначе
			Если ирОбщий.СтрНачинаетсяСЛкс(Выражение, "Новый ") Тогда
				// Для ускорения
				ЛиВиртПрисвоение = Истина;
				ЭтоВызовКонструктора = Истина;
			ИначеЕсли Ложь
				//Или Выражение = ИмяПеременнойВозвращаемогоЗначения() // Наверно не даст ускорения
				Или Найти(Выражение, ".") = 0 И ирОбщий.ЛиИмяПеременнойЛкс(Выражение) 
			Тогда
				// Для ускорения
				ТипСлова = "Свойство";
				РодительскийКонтекст = "";
			Иначе                     
				КэшРазбораВыражений = мПлатформа.мКэшРазбораВыражений;
				Если мПлатформа.мКэшРазбораВыражений = Неопределено Тогда 
					КэшРазбораВыражений = Новый Соответствие;
					мПлатформа.мКэшРазбораВыражений = КэшРазбораВыражений;
				КонецЕсли;
				КлючКэшаРазбора = НРег(Выражение);
				Вхождения = КэшРазбораВыражений[КлючКэшаРазбора];  
				Если Вхождения = Неопределено Тогда  
					мРегВыражение.Global = Ложь;
					мРегВыражение.Pattern = "(((\.(" + шИмя + "|\?|)" + шСкобки + "?)|" + шИндекс + ")*)" +
						              "((\.(" + шИмя + "|\?|)" + шСкобкиЛенивые + "?)|" + шИндекс + ")$";  // Возможно нужно заменить на шИмяСкобкиЛенивые
					Вхождения = мРегВыражение.НайтиВхождения("." + Выражение);
					КэшРазбораВыражений[КлючКэшаРазбора] = Вхождения;
				КонецЕсли;
				Если Вхождения.Количество() > 0 Тогда 
					ТипСлова = "Свойство";
					Вхождение = Вхождения[0];
					РодительскийКонтекст = Сред(Вхождение.SubMatches(0), 2);
					ТекущееСлово = Вхождение.SubMatches(8);
					ТекущийИндекс = Вхождение.SubMatches(10);
					ТекущиеАргументы = Вхождение.SubMatches(9);
					Если ТекущийИндекс <> Неопределено Тогда
						ТекущееСлово = Сред(ТекущийИндекс, 2, СтрДлина(ТекущийИндекс) - 2); // Здесь могут прийти выражения, не отвечающие требованиям к имени переменной
						//Если Не ирОбщий.ЛиИмяПеременнойЛкс(ТекущееСлово) Тогда 
						//КонецЕсли;
					КонецЕсли;
				Иначе
					ЛиВиртПрисвоение = Истина;
				КонецЕсли;
			КонецЕсли;
		КонецЕсли; 
		Если мЯзыкПрограммы = 1 Тогда
			ТипСлова = Неопределено; // Нельзя указывать конкретный тип, т.к. в этом языке несколько нужных типов
		ИначеЕсли ЗначениеЗаполнено(ТекущееСлово) Тогда 
			ТипСлова = "Свойство";
			Если Истина
				И ТекущиеАргументы <> Неопределено
				И СтруктураТипа.ТипЯзыка <> "ИмяТипа"
			Тогда
				// Это метод или функция
				Если ЭтоВызовКонструктора Тогда
					ТипСлова = "Конструктор";
				Иначе
					ТипСлова = "Метод";
				КонецЕсли; 
			КонецЕсли;
		Иначе
			ВычислениеРазрешено = Ложь;
		КонецЕсли;
		Если ВычислениеРазрешено Тогда
			// Кэш проверяем в первую очередь!
			КлючВыраженияСПозицией = "";
			ЛиПолнаяТаблицаТипов = Истина;
			СобиратьВсеПрисвоения = ВсеПрисвоения <> Неопределено;
			Если Истина
				И мРекурсивныйПуть.ДопКлючКэша <> Неопределено  
				И Не СобиратьВсеПрисвоения
				И мМодульМетаданных <> Неопределено
				И ЛиПолноеВыражение
			Тогда
				Если ЯзыкПрограммы = 0 Тогда
					Если мМетодМодуля <> Неопределено Тогда 
						ТипыВыраженийМетода = мМетодМодуля.ТипыВыражений;
						Если ТипыВыраженийМетода = Неопределено Тогда 
							ТипыВыраженийМетода = Новый Соответствие;
							мМетодМодуля.ТипыВыражений = ТипыВыраженийМетода;
						КонецЕсли;
					Иначе
						ТипыВыраженийМетода = мМодульМетаданных.ТипыВыраженийПрограммы;
					КонецЕсли;
				Иначе 
					ТипыВыраженийМетода = мРекурсивныйПуть.ТипыВыраженийЗапроса;
				КонецЕсли;
				БазовыйКлючВыражения = мРекурсивныйПуть.ДопКлючКэша + ";" + ГлобальныйПоискВМодулеВход + ";" + XMLСтрока(Позиция0ВМетодеДо) + ";" + Лев(Выражение, 200); 
				КлючВыраженияСПозицией = "0;" + БазовыйКлючВыражения; // Случай НЕ обрезаемых метаданных
				// Жесткая обрезка по глубине сделана для конструктора запроса "0.ЧастиОбъединения.0.СвязиТаблиц.Строки.0.Таблица.ВложенныйПакет.0.ЧастиОбъединения"
				// Опасно! Такая обрезка может приводить к использованию структур обрезанных на большей глубине чем требуется
				КлючВыраженияСПозициейИСвойством = "1;" + БазовыйКлючВыражения + ";" + ирОбщий.ПервыеФрагментыЛкс(ДляСвойства,, 8); // Случай обрезаемых метаданных по глубине или ширине 
				ТаблицаТиповКэш = ТипыВыраженийМетода[КлючВыраженияСПозицией]; // см. мПлатформа.НоваяТаблицаТипов()
				Если Истина
					И ТаблицаТиповКэш = Неопределено 
					И ЗначениеЗаполнено(ДляСвойства)
					//И Не мПлатформа.мРежимПроверкиМодуля
				Тогда
					ТаблицаТиповКэш = ТипыВыраженийМетода[КлючВыраженияСПозициейИСвойством]; // см. мПлатформа.НоваяТаблицаТипов()
				КонецЕсли;
				Если ТаблицаТиповКэш <> Неопределено Тогда
					////ТаблицаТипов = ТаблицаТиповКэш; // Если раскомментировать, то проверка модуля ирКлсПолеТекстаПрограммы уходит в бесконечную рекурсию
					//Если ЛиТаблицаТиповКэшНеГотова(ТаблицаТиповКэш, ДляСвойства) Тогда
					//	// TODO защита от бесконечной рекурсии
					//	Пустышка = 0; // Для отладки
					//Иначе 
						ТаблицаТипов = ТаблицаТиповКэш; // Попадание в кэш выражения
						Перейти ~Возврат;
					//КонецЕсли;
				КонецЕсли;
				//Если ЗначениеЗаполнено(ЛиПолноеВыражение) Тогда
					ТипыВыраженийМетода.Вставить(КлючВыраженияСПозицией, ТаблицаТипов);
				//КонецЕсли;
			КонецЕсли;
			
			ТаблицаТиповРодителя = новый Массив;
			Если Истина
				И Не ЛиВиртПрисвоение
				И Не ЛиПеременнаяРезультата
				И (Ложь
					Или ТаблицаТиповОтРодителя = Неопределено 
					Или Найти(Выражение, ".") = 0)  
			Тогда
				Если Истина
					И ПустаяСтрока(РодительскийКонтекст) 
					И СтруктураТипа.ТипЯзыка = ""
					И мКорневаяТаблицаТипов <> Неопределено 
				Тогда
					ТаблицаТиповРодителя = мКорневаяТаблицаТипов; 
				Иначе
					ЛиЭлементКоллекции = Истина
						И мЯзыкПрограммы = 0
						И (Ложь
							Или ЗначениеЗаполнено(ТекущийИндекс) 
							Или ТипСлова = "Метод" И ирОбщий.СтрокиРавныЛкс(ТекущееСлово, "Получить") // Опасно
							);
					Если Истина
						И ЗначениеЗаполнено(РодительскийКонтекст) 
						И ТипСлова = "Свойство" 
						И ПустаяСтрока(ТекущийИндекс) 
					Тогда
						Если ЗначениеЗаполнено(ДляСвойства) Тогда
							ДляСвойстваВверх = ТекущееСлово + "." + ДляСвойства;
						Иначе
							ДляСвойстваВверх = ТекущееСлово;
						КонецЕсли;
					ИначеЕсли Истина
						И ТипСлова = "Метод" 
						И ДляСвойства <> ИмяФиктивногоСвойства()
						И Не ЛиЭлементКоллекции
					Тогда
						Если ДляСвойства = "Значение" Тогда
							ДляСвойстваВверх = "0"; // Для ЭлементСпискаЗначений или КлючИЗначение
						Иначе
							ДляСвойстваВверх = "";
						КонецЕсли;
					Иначе
						ДляСвойстваВверх = ДляСвойства;
					КонецЕсли;
					Если ЛиЭлементКоллекции Тогда 
						// TODO передавать конкретное имя когда оно есть
						Если ЗначениеЗаполнено(ДляСвойстваВверх) Тогда
							ДляСвойстваВверх = "0." + ДляСвойстваВверх; 
						Иначе
							ДляСвойстваВверх = "0";
						КонецЕсли;
					КонецЕсли;
					ТаблицаТиповРодителя = ВычислитьТипЗначенияВыражения(РодительскийКонтекст, ТекстДляПоискаОпределения, ПредшествующийТекст, РазрешитьАнализИмениТипа,, ПолныйАнализСоставаТипов, Ложь,,,,,
						Позиция0ВМетодеДо,, ДляСвойстваВверх, СобиратьОшибки,, Ложь);
					Если Истина
						И ПустаяСтрока(РодительскийКонтекст) 
						И СтруктураТипа.ТипЯзыка = ""
						И мКорневаяТаблицаТипов = Неопределено 
					Тогда
						мКорневаяТаблицаТипов = ТаблицаТиповРодителя;
					КонецЕсли;
				КонецЕсли; 
			КонецЕсли;
			ЛиПеременнаяМодуля = Ложь;
			Если ТаблицаТиповРодителя.Количество() > 0 Тогда
				Если ЗначениеЗаполнено(ТекущийИндекс) Тогда
					Если ТаблицаТиповРодителя[0].ИмяОбщегоТипа = "Массив[РезультатЗапроса]" Тогда
						КопияКомпоненты = КопияКомпоненты();
						КопияКомпоненты.ЗаполнитьЛокальныеСвойстваИМетодыПоТексту(, Ложь,,,, ТекущееСлово,, Истина);
						ПеременныеВыражения = Новый Структура;
						Для Каждого СтрокаСлова Из КопияКомпоненты.ТаблицаСлов Цикл
							ЗначениеПеременной = Неопределено;
							ТаблицаСтруктурТипа = ВычислитьТипЗначенияВыражения(СтрокаСлова.Слово, ПредшествующийТекст, ПредшествующийТекст,,,, Ложь,,, Истина,, Позиция0ВМетодеДо);
							Если ТаблицаСтруктурТипа.Количество() > 0 Тогда
								ЗначениеПеременной = ТаблицаСтруктурТипа[0].Метаданные;
								Если ТипЗнч(ЗначениеПеременной) = Тип("ПостроительЗапроса") Тогда
									ЗначениеПеременной = мПлатформа.РазбитьГрубоТекстПакетногоЗапросаНаЗапросы(ЗначениеПеременной.Текст);
								КонецЕсли;
							КонецЕсли;
							ПеременныеВыражения.Вставить(СтрокаСлова.Слово, ЗначениеПеременной);
						КонецЦикла;
						Алгоритм = ирОбщий.СтрСоединитьЛкс(ирОбщий.ВыгрузитьСвойствоЛкс(ПеременныеВыражения),,,, "%1=_АлгоритмОбъект.%1;" + Символы.ПС)
							+ "Результат = " + ТекущееСлово;
						ТекущееСлово = "";
						ЗначениеВыражения = Неопределено;
						Попытка
							ЗначениеВыражения = ирОбщий.ВыполнитьАлгоритм(Алгоритм, ПеременныеВыражения);
							ТекущееСлово = XMLСтрока(ЗначениеВыражения);
						Исключение
						КонецПопытки;
					Иначе 
						Если Истина
							И Найти(ТекущийИндекс, "-") = 0
							И Найти(ТекущийИндекс, "+") = 0
							И Найти(ТекущийИндекс, ",") = 0
						Тогда
							// Такие вычисления могут быть неоправданно затратными, особенно если ТекущийИндекс содержит ".".
							ЗначениеИндекса = ВычислитьЗначениеВыражения(ТекстБезКрайнихСимволов(ТекущийИндекс),,, Позиция0ВМетодеОт, Позиция0ВМетодеДо);
							Если ТипЗнч(ЗначениеИндекса) = Тип("Строка") Тогда
								ТекущееСлово = """" + ЗначениеИндекса + """";
							КонецЕсли;
						КонецЕсли;
					КонецЕсли;
				КонецЕсли;
				ВычислитьТипДочернегоЭлемента(ТаблицаТиповРодителя, ТекущееСлово, ТипСлова, ТекущийИндекс, ТекущиеАргументы, ПредшествующийТекст, ПолныйАнализСоставаТипов, ЛиПеременнаяМодуля,
					Позиция0ВМетодеДо, ТаблицаТипов, ДляСвойства, ГлобальныйПоискВМодулеВход);
			КонецЕсли;
			Если мЯзыкПрограммы = 1 Тогда
				Если Истина
					И РодительскийКонтекст = ""
					И СтруктураТипа.ТипЯзыка = "" 
				Тогда
					Если ЗначениеЗаполнено(ТекущееСлово) Тогда
						НачалоЧасти = НачалоЧастиОбъединенияЗапроса(ТекстДляПоискаОпределения, Позиция0ВМетодеДо);
						мРегВыражение.Global = Ложь;
						мРегВыражение.Pattern = СтрЗаменить(шПоискОписанияТаблицы, "#Идентификатор#", ирОбщий.ПодготовитьТекстДляРегВыраженияЛкс(ТекущееСлово));
						РезультатТекста = мРегВыражение.НайтиВхождения(Сред(ТекстДляПоискаОпределения, НачалоЧасти + 1));
						Если РезультатТекста.Количество() > 0 Тогда
							ПоследнееВхождение = РезультатТекста[0];
							ПозицияВхождения0 = НачалоЧасти + ПоследнееВхождение.FirstIndex;
							СледРекурсии = мРекурсивныйПуть.ПозицииЗапроса.Найти(ПозицияВхождения0);
							Если СледРекурсии = Неопределено Тогда
								мРекурсивныйПуть.ПозицииЗапроса.Добавить(ПозицияВхождения0);
								ПрисвоенныйКонтекст = ПоследнееВхождение.SubMatches(3);
								Если Лев(ПрисвоенныйКонтекст, 1) = "(" Тогда
									ТекстыЗапросов = ирОбщий.СкопироватьКоллекциюЛкс(мПакетЗапросов.ТекстыЗапросов);
									ПрисвоенныйКонтекст = ТекстБезКрайнихСимволов(ПрисвоенныйКонтекст);
									Если Лев(ТекстыЗапросов[0], 1) = """" Тогда
										ПрисвоенныйКонтекст = "|" + Сред(ирОбщий.ТекстВВыражениеВстроенногоЯзыкаЛкс(ПрисвоенныйКонтекст), 2);
									КонецЕсли;
									ТекстыЗапросов[мИндексЗапросаПакета] = ПрисвоенныйКонтекст;
									СтруктураТипа = мПлатформа.НоваяСтруктураТипа("ВременнаяТаблица");  // TODO переделать на новый тип ВложенныйЗапрос
									СтруктураТипа.Метаданные = мПлатформа.ПостроительПакетаЗапросовДоИндекса(ТекстыЗапросов, мИндексЗапросаПакета, мПакетЗапросов.Параметры);
									мПлатформа.ДобавитьВТаблицуТипов(ТаблицаТипов, СтруктураТипа); 
								ИначеЕсли ПрисвоенныйКонтекст <> Выражение Тогда
									ТаблицаПрисвоенныхТипов = ВычислитьТипЗначенияВыражения(ПрисвоенныйКонтекст, ТекстДляПоискаОпределения,
										Лев(ТекстДляПоискаОпределения, ПозицияВхождения0 - 1),,, ПолныйАнализСоставаТипов, Ложь,,,,, ПозицияВхождения0,,, СобиратьОшибки);
									мПлатформа.ДобавитьВТаблицуТипов(ТаблицаТипов, ТаблицаПрисвоенныхТипов); 
								КонецЕсли;
							КонецЕсли;
						КонецЕсли;
					КонецЕсли;
					Если ЗначениеЗаполнено(ТекущиеАргументы) Тогда
						//Если Не ЗначениеЗаполнено(ТекущееСлово) Тогда
						//	ТекущееСлово = ирОбщий.УдалитьВнешниеСкобкиВыраженияЛкс(ТекущиеАргументы);
						//КонецЕсли;
						Если ирОбщий.СтрокиРавныЛкс(ТекущееСлово, "Выразить") Тогда
							//ТекущиеАргументы = ирОбщий.ТекстМеждуМаркерамиЛкс(ТекущиеАргументы, "(", ")", Ложь, Истина);
							мРегВыражение.Pattern = шРазделитель + "(?:КАК|AS)" + шРазделитель + "+(" + шИмяСТочками + ")";
							Вхождения = мРегВыражение.НайтиВхождения(ТекущиеАргументы);
							Если Вхождения.Количество() > 0 Тогда
								ИмяТипаВыражения = Вхождения[Вхождения.Количество() - 1].Submatches(0);
								Если Найти(ИмяТипаВыражения, ".") > 0 Тогда
									ИмяТипаВыражения = ирОбщий.ИмяТипаИзПолногоИмениМДЛкс(ИмяТипаВыражения);
								КонецЕсли; 
								СтруктураТипа = мПлатформа.СтруктураТипаИзКонкретногоТипа(Тип(ИмяТипаВыражения));
								СтруктураТипа.ИмяОбщегоТипа = СтрЗаменить(СтруктураТипа.ИмяОбщегоТипа, ирОбщий.ПеревестиСтроку("Ссылка") + ".", ".");
								мПлатформа.ДобавитьВТаблицуТипов(ТаблицаТипов, СтруктураТипа);
							КонецЕсли; 
						КонецЕсли; 
					КонецЕсли; 
				КонецЕсли;
			ИначеЕсли Истина
				И ЗначениеЗаполнено(ТекущееСлово) 
				И ТипСлова = "Свойство" 
				И СтруктураТипа.ТипЯзыка = "" 
				И ЗначениеЗаполнено(ТекстДляПоискаОпределения)
			Тогда  
				Если ТаблицаТиповРодителя.Количество() > 0 Тогда
					МетаданныеРодителя = ТаблицаТиповРодителя[0].Метаданные;
				Иначе 
					МетаданныеРодителя = Неопределено;
				КонецЕсли;                          
				ЭтоФактическийТип = Истина
					И РодительскийКонтекст = ""
					И мМетодМодуля <> Неопределено  
					И мМетодМодуля.КлючевыеПараметры <> Неопределено
					И ирОбщий.ЛиИмяПеременнойЛкс(Выражение)
					И мМетодМодуля.КлючевыеПараметры.Свойство(Выражение)
					И мМетодМодуля.КлючевыеПараметры[Выражение] <> Неопределено;
				Если Ложь
					Или (Истина
						И ТипЗнч(МетаданныеРодителя) = Тип("ПостроительЗапроса")
						И ТекущееСлово = "МенеджерВременныхТаблиц")
					Или (Истина
						И МетаданныеРодителя <> Неопределено
						И ТаблицаТипов.Количество() = 1
						И (Ложь
							Или ТаблицаТипов[0].ИмяОбщегоТипа = "ОбщийМодуль"
							//Или ТипЗнч(МетаданныеРодителя) = Тип("ТаблицаЗначений")
							Или ТипЗнч(МетаданныеРодителя) = Тип("ДанныеФормыКоллекция")
							Или ТипЗнч(МетаданныеРодителя) = Тип("ДанныеФормыСтруктураСКоллекцией")
							//Или ЭтоФактическийТип // Нужно для СкопироватьКоллекциюЛкс(). Вредно для вычисления результата РодительЭлементаУправляемойФормыЛкс()
							))              
				Тогда
					// Считаем что тип уже достаточно точно вычислен. Отсекаем малополезное обогащение типов
				Иначе
					// Обогощаем присвоенными типами
					ПроверятьТипЧерезЕсли = Ложь;
					Если ЛиВиртПрисвоение Тогда
						// = Новый ...
						ИмяВиртПеременной = "ВиртВыражение294";
						ЧислоГруппВШаблонеВыражения = 0;
						мРегВыражение.Pattern = ШаблонНазначенияТипаВыражению(ИмяВиртПеременной, ПроверятьТипЧерезЕсли);
						ТекстДляПоискаОпределения = ИмяВиртПеременной + "=" + Выражение;
						Вхождения = мРегВыражение.НайтиВхождения(ТекстДляПоискаОпределения);
						Если Вхождения.Количество() > 0 Тогда
							яяя = Новый Массив;
							яяя.Добавить(Новый Структура("Вхождение", Вхождения[0]));
							Вхождения = яяя;
						КонецЕсли;
						Выражение = ИмяВиртПеременной;
						КэшПоискаМетода = Неопределено;
					Иначе 
						ШаблонПоиска = "(" + шОбъектноеВыражение + ")";
						ЧислоГруппВШаблонеВыражения = 4;
						Если Истина
							И ПустаяСтрока(РодительскийКонтекст)
							И мМодульМетаданных <> Неопределено
							И мМодульМетаданных.СтруктураТипа <> Неопределено
							И мМодульМетаданных.СтруктураТипа.ИмяОбщегоТипа <> "ОбщийМодуль"
						Тогда
							ШаблонПоиска = ШаблонПоискаСловаЧерезЭтотОбъект(ШаблонПоиска);
						КонецЕсли;
						ШаблонПоиска = ШаблонНазначенияТипаВыражению("(?!ТипЗнч\()" + ШаблонПоиска, Истина);
						КлючКэшаПоиска = Нрег("НазначениеТипа");
						Вхождения = НайтиВхожденияРегВыраженияКэш(ШаблонПоиска, ГлобальныйПоискВМодуле, ТекстДляПоискаОпределения, КлючКэшаПоиска, КэшПоискаМетода);
						ВыражениеНРег = НРег(Выражение);
						ИндексВторойГруппы = ЧислоГруппВШаблонеВыражения + 24;
						Если ТипЗнч(Вхождения) <> Тип("ТаблицаЗначений") Тогда
							ТаблицаВхождений = Новый ТаблицаЗначений;
							ТаблицаВхождений.Колонки.Добавить("ВыражениеНрег");
							ТаблицаВхождений.Колонки.Добавить("Вхождение");
							_РежимОтладки = Ложь;
							Если _РежимОтладки Тогда // Можно менять на Истина в точке останова, например условием ирОбщий.Пр(_РежимОтладки, 1, 1)
								// Пассивный оригинал расположенного ниже однострочного кода. Выполняйте изменения синхронно в обоих вариантах.
								Для Каждого Вхождение Из Вхождения Цикл
									СтрокаВхождения = ТаблицаВхождений.Добавить();
									СтрокаВхождения.Вхождение = Вхождение;
									ВыражениеВхождения = Вхождение.SubMatches(1);
									Если ВыражениеВхождения = Неопределено Тогда
										ВыражениеВхождения = Вхождение.SubMatches(ИндексВторойГруппы);
									КонецЕсли;
									СтрокаВхождения.ВыражениеНрег = НРег(ВыражениеВхождения);
								КонецЦикла; 
							Иначе
								// Однострочный код использован для ускорения при разрешенной отладке. Выше расположен оригинал. Выполняйте изменения синхронно в обоих вариантах. Преобразовано консолью кода из подсистемы "Инструменты разработчика"
								Для Каждого Вхождение Из Вхождения Цикл  								СтрокаВхождения = ТаблицаВхождений.Добавить();  								СтрокаВхождения.Вхождение = Вхождение;  								ВыражениеВхождения = Вхождение.SubMatches(1);  								Если ВыражениеВхождения = Неопределено Тогда  									ВыражениеВхождения = Вхождение.SubMatches(ИндексВторойГруппы);  								КонецЕсли;  								СтрокаВхождения.ВыражениеНрег = НРег(ВыражениеВхождения);  							КонецЦикла;  
							КонецЕсли;
							ТаблицаВхождений.Индексы.Добавить("ВыражениеНрег");
							Вхождения = ТаблицаВхождений;
							Если КэшПоискаМетода <> Неопределено Тогда
								КэшПоискаМетода[КлючКэшаПоиска] = Вхождения;
							КонецЕсли;
						КонецЕсли;
						Вхождения = Вхождения.НайтиСтроки(Новый Структура("ВыражениеНрег", ВыражениеНРег));
						ПроверятьТипЧерезЕсли = Истина
							И Не СобиратьВсеПрисвоения
							И Не ГлобальныйПоискВМодуле
							И Найти(Выражение, "(") = 0
							И Не ЛиПеременнаяРезультата;
					КонецЕсли; 
					ЛиТипЧерезЕслиНазначен = Ложь;
					Если Вхождения.Количество() > 0 Тогда
						СтруктураМоноТипа = Неопределено;
						ОтборПоПроизвольномуИмениТипа = Новый Структура("ИмяОбщегоТипа", "Произвольный");
						НачальнаяПозицияБлока = 0;
						ГлубинаВеток = НоваяГлубинаВеток(Позиция0ВМетодеДо);
						ЧислоПроверенныхВариантов = 0;
						ЛиУстановкаЗначения = Ложь;
						ИндексВхождения = Вхождения.Количество();
						Пока ИндексВхождения > 0 Цикл 
							ИндексВхождения = ИндексВхождения - 1;
							ПоследнееВхождение = Вхождения[ИндексВхождения].Вхождение;
							//Если Истина
							//	И НРег(ПоследнееВхождение.SubMatches(1)) <> ВыражениеНРег
							//	И (Ложь
							//		Или Не ПроверятьТипЧерезЕсли 
							//		Или НРег(ПоследнееВхождение.SubMatches(ИндексВторойГруппы)) <> ВыражениеНРег)
							//Тогда
							//	Продолжить;
							//КонецЕсли;
							Если Истина
								И Не ЛиВиртПрисвоение 
								И ЛиВхождениеВЗапрешенномДиапазоне(ПоследнееВхождение, Позиция0ВМетодеОт, Позиция0ВМетодеДо, ЛиКорневойВызов) 
							Тогда
								Продолжить;
							КонецЕсли;
							Если ЛиВиртПрисвоение Тогда
								ПозицияВхождения0 = Позиция0ВМетодеДо;
							Иначе
								ПозицияВхождения0 = ПоследнееВхождение.FirstIndex; 
								Если ГлобальныйПоискВМодуле Тогда 
									НачальнаяПозицияБлока = ЗагрузитьМетодМодуляПоПозицииИРазобратьКонтекст(ПозицияВхождения0);
								КонецЕсли;
								ПозицияВхождения0 = ПозицияВхождения0 - 1 - НачальнаяПозицияБлока;
							КонецЕсли;
							ТекстПроверкиВеток = СчитатьГлубинуВеток(ТекстДляПоискаОпределения, ГлубинаВеток, ПозицияВхождения0, ПоследнееВхождение);
							Если Ложь
								Или (Истина
									И ГлубинаВеток.Альтернативная >= 0 
									И ГлубинаВеток.Необязательная <> ГлубинаВеток.Альтернативная)
								Или (Истина
									// Нужно для СкопироватьКоллекциюЛкс()
									И ЭтоФактическийТип 
									И ГлубинаВеток.Необязательная <> Неопределено // для вычисления результата РодительЭлементаУправляемойФормыЛкс()
									)
							Тогда
								Продолжить;
							КонецЕсли; 
							ПрисвоенныйТип = ПоследнееВхождение.SubMatches(ЧислоГруппВШаблонеВыражения + 23);
							Если ПрисвоенныйТип <> Неопределено Тогда 
								Если Лев(ПрисвоенныйТип, 1) = "@" Тогда 
									Если мПлатформа.мРежимПроверкиМодуля Тогда 
										Если ПрисвоенныйТип = ИнструкцияПодавленияПроверки(, Истина) Тогда
											СтруктураМоноТипа = мПлатформа.НоваяСтруктураТипа("Произвольный");
											ДобавитьЕдинственныйТип(ТаблицаТипов, СтруктураМоноТипа);
											Прервать;
										КонецЕсли;
									КонецЕсли;
								ИначеЕсли Истина
									И Найти(ПрисвоенныйТип, "=") = 0
									И Найти(ПрисвоенныйТип, ";") = 0
									И Найти(ПрисвоенныйТип, """") = 0
									И Не СобиратьВсеПрисвоения
								Тогда
									// Назначение типа в комментарии
									ТекстДоВхождения = Сред(ТекстДляПоискаОпределения, НачальнаяПозицияБлока, ПозицияВхождения0 + 2); // МультиМетка8294218
									ТаблицаТиповИзКомментария = ТаблицаТиповИзТекста(ирОбщий.ПервыйФрагментЛкс(ПрисвоенныйТип, "-"),, ТекстДоВхождения, ДляСвойства);
									Если ТаблицаТиповИзКомментария.Количество() > 0 Тогда
										//ТекстПослеВхождения = Сред(ТекстДляПоискаОпределения, ПозицияВхождения0, Позиция0ВМетодеДо - ПозицияВхождения0);
										Если ЛиПеременнаяРезультата И ТаблицаТиповИзКомментария.Количество() > 1 Тогда
											ТаблицаТипов.Очистить();
											мПлатформа.ДобавитьВТаблицуТипов(ТаблицаТипов, ТаблицаТиповИзКомментария);
											Прервать;
										КонецЕсли;
										Если Истина
											И ЧислоПроверенныхВариантов = 0
											И СтруктураМоноТипа = Неопределено
											И ГлубинаВеток.Необязательная = Неопределено
											И мПлатформа.ЛиДетальностьТиповДостаточна(ТаблицаТиповИзКомментария,, Истина, СтруктураМоноТипа)
										Тогда
											ДобавитьЕдинственныйТип(ТаблицаТипов, СтруктураМоноТипа, ЭтоФактическийТип);
										Иначе 
											мПлатформа.ДобавитьВТаблицуТипов(ТаблицаТипов, ТаблицаТиповИзКомментария);
										КонецЕсли;
										Если мПлатформа.ЛиДетальностьТиповДостаточна(ТаблицаТипов, 4) Тогда
											Прервать;
										КонецЕсли;
									КонецЕсли;
								КонецЕсли;
							КонецЕсли;
							ЭтоПрисвоение = ПоследнееВхождение.SubMatches(ЧислоГруппВШаблонеВыражения + 2) <> Неопределено;
							Если ЭтоПрисвоение И Не СобиратьВсеПрисвоения Тогда
								ПрисвоенныйКонтекст = ПоследнееВхождение.SubMatches(ЧислоГруппВШаблонеВыражения + 3);
								Если ЛиБесполезноеПрисвоениеПеременной(ПрисвоенныйКонтекст) Тогда  
									Если ЗначениеЗаполнено(ПрисвоенныйКонтекст) Тогда
										мПлатформа.ДобавитьВТаблицуТипов(ТаблицаТипов, мПлатформа.НоваяСтруктураТипа(ПрисвоенныйКонтекст));
									КонецЕсли;
									Продолжить;
								КонецЕсли;
								Если ирОбщий.СтрокиРавныЛкс(Выражение, ПрисвоенныйКонтекст) Тогда 
									// TODO описать когда такое случается
									Продолжить;
								КонецЕсли;
							КонецЕсли;
							Если ПроверятьТипЧерезЕсли И Не ЛиУстановкаЗначения Тогда 
								ПрисвоенныйТипЕсли = ПоследнееВхождение.SubMatches(ЧислоГруппВШаблонеВыражения*2 + 24);
								Если ПрисвоенныйТипЕсли <> Неопределено Тогда
									// Теперь делаем это выше
									//Если ЭтоФактическийТип Тогда
									//	ЛиТипЧерезЕслиНазначен = Истина;
									//КонецЕсли;
									Если Не ЛиТипЧерезЕслиНазначен Тогда
										//ПрименитьТип = МожноПрименитьПрисвоениеТипаИзЕсли(ТекстПроверкиВеток, ГлубинаВеток.Необязательная);
										ПрименитьТип = МожноПрименитьПрисвоениеТипаИзЕсли(ТекстДляПоискаОпределения, Позиция0ВМетодеДо, ПоследнееВхождение, ПозицияВхождения0, ГлубинаВеток.Необязательная);
										Если ПрименитьТип Тогда 
											//ЛиТипЧерезЕслиНазначен = Истина;
											Тип = Неопределено;
											Если Найти(ПрисвоенныйТипЕсли, """") > 0 Тогда 
												ИмяТипа = ирОбщий.ТекстМеждуМаркерамиЛкс(ПрисвоенныйТипЕсли, """", """");
												Попытка
													Тип = Тип(ИмяТипа);
												Исключение
												КонецПопытки;
												//Иначе 
												//	Тип = ВычислитьЗначениеВыражения(ПрисвоенныйТипЕсли, ПредшествующийТекст,,, ПозицияВхождения0);
											КонецЕсли; 
											Если ТипЗнч(Тип) = Тип("Тип") Тогда 
												Если Тип = Тип("ОбъектМетаданных") Тогда
													СтруктураМоноТипа = мПлатформа.НоваяСтруктураТипа("ОбъектМетаданных");
												Иначе 
													СтруктураМоноТипа = мПлатформа.СтруктураТипаИзКонкретногоТипа(Тип);
													Если СтруктураМоноТипа.ИмяОбщегоТипа = "НеизвестныйКонтекст" Тогда
														// Например тупиковый устаревший ПолеТабличногоДокументаФормы Или ОсновнойЭлементФормы
														СтруктураМоноТипа = Неопределено;
													КонецЕсли;
												КонецЕсли;   
												Если СтруктураМоноТипа <> Неопределено Тогда
													//Если ирОбщий.СтрНачинаетсяСЛкс(СокрЛ(ПоследнееВхождение.Value), "Или ") Тогда  
													//	мПлатформа.ДобавитьВТаблицуТипов(ТаблицаТипов, СтруктураМоноТипа);
													//	СтруктураМоноТипа = Неопределено;
													//Иначе 
														ЛиТипЧерезЕслиНазначен = ДобавитьЕдинственныйТип(ТаблицаТипов, СтруктураМоноТипа, ЭтоФактическийТип);
													//КонецЕсли;
												КонецЕсли;
											КонецЕсли;
										КонецЕсли;
									КонецЕсли;
									Продолжить;
								КонецЕсли;
							КонецЕсли;
							// Если включено, то ускоряет, но иногда отрезает дополнительные типы, отображаемые в списке автодополнения
							//Если Истина
							//	И ДляСвойства = ИмяФиктивногоСвойства()
							//	И мПлатформа.ЛиДетальностьТиповДостаточна(ТаблицаТипов)
							//Тогда
							//	ТаблицаТипов.Колонки.Метаданные.Заголовок = ЗаголовокФлагОбрезкиГлубины();
							//	Прервать;
							//КонецЕсли;
							Если Истина
								И ЛиПеременнаяМодуля 
								И Не ЛиКорневойВызов 
								И Не СобиратьВсеПрисвоения 
								И мПлатформа.ЛиДетальностьТиповДостаточна(ТаблицаТипов)
							Тогда
								// Для ускорения
								Перейти ~Возврат;
							КонецЕсли;
							ПервыйСимвол = Лев(ПоследнееВхождение.Value, 1);
							Если ВычислитьЗначение И Лев(ПрисвоенныйКонтекст, 1) = """" Тогда
								СмещениеПозиции = Найти(ПоследнееВхождение.Value, Лев(ПрисвоенныйКонтекст, 10));
							ИначеЕсли ПервыйСимвол = ";" Тогда
								// TODO Нужно этот начальный фрагмент прямо в регулярном выражении захватывать и брать его длину
								СмещениеПозиции = 2; 
							ИначеЕсли ПервыйСимвол = Символы.ПС Тогда
								// TODO Нужно этот начальный фрагмент прямо в регулярном выражении захватывать и брать его длину
								СмещениеПозиции = 1;
							Иначе
								// Для ускорения
								СмещениеПозиции = 0;
							КонецЕсли;
							ПозицияВхождения0 = ПозицияВхождения0 + СмещениеПозиции;
							ЛиУстановкаЗначения = Истина;
							ЧислоПроверенныхВариантов = ЧислоПроверенныхВариантов + 1;
							Если ЭтоПрисвоение Тогда
								СловоНовый = НРег(ПоследнееВхождение.SubMatches(ЧислоГруппВШаблонеВыражения + 4));
								Если СловоНовый = Нрег("Новый") Или СловоНовый = Нрег("New") Тогда
									Если ПоследнееВхождение.SubMatches(ЧислоГруппВШаблонеВыражения + 5) <> Неопределено Тогда 
										ИмяТипа = ПоследнееВхождение.SubMatches(ЧислоГруппВШаблонеВыражения + 5);
									ИначеЕсли ПоследнееВхождение.SubMatches(ЧислоГруппВШаблонеВыражения + 6) <> Неопределено Тогда 
										ИмяТипа = ПоследнееВхождение.SubMatches(ЧислоГруппВШаблонеВыражения + 6);
										ИмяТипа = ирОбщий.ТекстИзВстроенногоЯзыкаЛкс(ИмяТипа);
									Иначе
										ИмяТипа = Неопределено;
									КонецЕсли;
									Если ЗначениеЗаполнено(ИмяТипа) Тогда
										Попытка
											ТипНового = Тип(ИмяТипа);
										Исключение
											ТипНового = Неопределено;
											СтруктураТипа.ИмяОбщегоТипа = ИмяТипа; // Имя внешней компоненты, например AddIn.T1CDLib.DB1CD
										КонецПопытки; 
										Если Истина
											И ТипНового = Тип("COMОбъект")
											И ПоследнееВхождение.SubMatches(ЧислоГруппВШаблонеВыражения + 6) <> Неопределено 
										Тогда
											ПолноеИмяОсновногоКлассаCOM = ВычислитьЗначениеВыражения(ПоследнееВхождение.SubMatches(ЧислоГруппВШаблонеВыражения + 6),,, Позиция0ВМетодеОт, ПозицияВхождения0);
											СтруктураКОМТипа = мИменаОбщихТиповПоИменамКлассовCOM[ПолноеИмяОсновногоКлассаCOM];
											Если СтруктураКОМТипа = Неопределено Тогда
												СтруктураКОМТипа = Новый Структура;
												МетаданныеСлова = мПлатформа.ПолучитьОбразецCOMОбъекта(ПолноеИмяОсновногоКлассаCOM); // При этом может открыться форма Automation-сервера например RegexBuddy так делает
												Если МетаданныеСлова = Неопределено Тогда
													ИмяОсновногоКлассаCOM = ирОбщий.ПоследнийФрагментЛкс(ПолноеИмяОсновногоКлассаCOM);
													ИмяОбщегоТипа = ИмяОсновногоКлассаCOM + " {" + ПолноеИмяОсновногоКлассаCOM + "}";
												Иначе
													ИмяОбщегоТипа = мПлатформа.ПолноеИмяТипаCOMОбъекта(МетаданныеСлова, ПолноеИмяОсновногоКлассаCOM);
													Если ирОбщий.СтрокиРавныЛкс(ИмяОбщегоТипа, "COMОбъект") Тогда
														ИмяОсновногоКлассаCOM = ирОбщий.ПоследнийФрагментЛкс(ПолноеИмяОсновногоКлассаCOM);
														ИмяОбщегоТипа = ИмяОсновногоКлассаCOM + " {" + ПолноеИмяОсновногоКлассаCOM + "}";
													КонецЕсли; 
													СтруктураКОМТипа.Вставить("Метаданные", МетаданныеСлова);
												КонецЕсли; 
												СтруктураКОМТипа.Вставить("ИмяОбщегоТипа", ИмяОбщегоТипа); 
												мИменаОбщихТиповПоИменамКлассовCOM[ПолноеИмяОсновногоКлассаCOM] = СтруктураКОМТипа;
											КонецЕсли; 
											ЗаполнитьЗначенияСвойств(СтруктураТипа, СтруктураКОМТипа); 
										ИначеЕсли ТипНового <> Неопределено Тогда
											СтруктураТипа = мПлатформа.СтруктураТипаИзКонкретногоТипа(ТипНового, мЯзыкПрограммы);
											Если Ложь
												Или ТипНового = Тип("Запрос") 
												Или ТипНового = Тип("ПостроительЗапроса") 
											Тогда 
												ПервыйФактПараметр = ПоследнееВхождение.SubMatches(ЧислоГруппВШаблонеВыражения + 6);
												Если ПервыйФактПараметр <> Неопределено Тогда 
													КоординатыТекста = Неопределено; // см. НовыеКоординатыВыражения()
													ТекстПакета = ВычислитьЗначениеВыражения(ПервыйФактПараметр,,, Позиция0ВМетодеОт, ПозицияВхождения0, КоординатыТекста);
													Если КоординатыТекста <> Неопределено Тогда
														СтруктураТипа.ДержательМетаданных = НовыйМенеджерВременныхТаблиц(Ложь);
														СтруктураТипа.ДержательМетаданных.ПакетыЗапросов.Добавить(НовыйПакетЗапросов(КоординатыТекста.Выражение, КоординатыТекста));  
														СтруктураТипа.Метаданные = мПлатформа.ПостроительЗапросаИзТекстаДляТипа(ТекстПакета);
													КонецЕсли;
												КонецЕсли;
											ИначеЕсли ТипНового = Тип("МенеджерВременныхТаблиц") Тогда
												Если Истина
													И ТаблицаТиповРодителя.Количество() > 0
													И ТаблицаТиповРодителя[0].ИмяОбщегоТипа = "Запрос"
													И ТипЗнч(ТаблицаТиповРодителя[0].ДержательМетаданных) = Тип("Структура")
													И ТаблицаТиповРодителя[0].ДержательМетаданных.Активен
													И ирОбщий.СтрокиРавныЛкс(ТекущееСлово, "МенеджерВременныхТаблиц")
												Тогда
													// Опасно
												Иначе
													СтруктураТипа.Метаданные = НовыйМенеджерВременныхТаблиц(Истина);
													СтруктураТипа.ДержательМетаданных = НовыеКоординатыВыражения(ПрисвоенныйКонтекст, ПозицияВхождения0);
												КонецЕсли;
											ИначеЕсли ТипНового = Тип("ОписаниеИсточникаДанных") Тогда
												ПервыйФактПараметр = ПоследнееВхождение.SubMatches(ЧислоГруппВШаблонеВыражения + 6);
												Если ПервыйФактПараметр <> Неопределено Тогда
													ТаблицаТиповПараметра = ВычислитьТипЗначенияВыражения(ПервыйФактПараметр,,,,,, Ложь,,, Истина, Позиция0ВМетодеОт, ПозицияВхождения0);
													Если мПлатформа.ЛиДетальностьТиповДостаточна(ТаблицаТиповПараметра, 4) Тогда
														СтруктураТипа.Метаданные = ТаблицаТиповПараметра;
													КонецЕсли;
												КонецЕсли;
											ИначеЕсли ТипНового = Тип("ИсточникДоступныхНастроекКомпоновкиДанных") Тогда
												ПервыйФактПараметр = ПоследнееВхождение.SubMatches(ЧислоГруппВШаблонеВыражения + 6);
												Если ПервыйФактПараметр <> Неопределено Тогда
													СхемаКомпоновки = ВычислитьЗначениеВыражения(ПервыйФактПараметр,,, Позиция0ВМетодеОт, ПозицияВхождения0);
													Если СхемаКомпоновки <> Неопределено Тогда
														СтруктураТипа.Метаданные = СхемаКомпоновки;
													КонецЕсли;
												КонецЕсли;
											ИначеЕсли ТипНового = Тип("ОписаниеТипов") Тогда
												ПервыйФактПараметр = ПоследнееВхождение.SubMatches(ЧислоГруппВШаблонеВыражения + 6);
												Если ПервыйФактПараметр <> Неопределено Тогда
													ИменаТипов = ВычислитьЗначениеВыражения(ПервыйФактПараметр,,, Позиция0ВМетодеОт, ПозицияВхождения0);
													Если ЗначениеЗаполнено(ИменаТипов) Тогда
														Попытка
															СтруктураТипа.Метаданные = Новый ОписаниеТипов(ИменаТипов);
														Исключение
														КонецПопытки;
													КонецЕсли;
												КонецЕсли;
											ИначеЕсли Ложь
												Или ТипНового = Тип("Структура") 
												Или ТипНового = Тип("ФиксированнаяСтруктура") 
											Тогда                                                
												ПервыйФактПараметр = ПоследнееВхождение.SubMatches(ЧислоГруппВШаблонеВыражения + 6);
												Если ПервыйФактПараметр <> Неопределено Тогда
													ТаблицаТиповПараметра = ВычислитьТипЗначенияВыражения(ПервыйФактПараметр,,,,,, Ложь,,, Истина, Позиция0ВМетодеОт, ПозицияВхождения0);
													ИменаСвойств = "";
													ЛучшийТип = ЛучшийТипИзТаблицыТипов(ТаблицаТиповПараметра);
													Если ЛучшийТип <> Неопределено Тогда
														Если ТипЗнч(ЛучшийТип.Метаданные) = Тип("Структура") Тогда
															СтруктураТипа.Метаданные = ЛучшийТип.Метаданные;
														ИначеЕсли ТипЗнч(ЛучшийТип.Метаданные) = Тип("Строка") Тогда
															ИменаСвойств = ЛучшийТип.Метаданные;
															Если ЗначениеЗаполнено(ИменаСвойств) Тогда
																Попытка
																	СтруктураТипа.Метаданные = Новый Структура(ИменаСвойств);
																Исключение
																	ИменаСвойств = "";
																КонецПопытки; 
															КонецЕсли;
														КонецЕсли;
													КонецЕсли;
													Если ЗначениеЗаполнено(ИменаСвойств) Тогда
														ИменаСвойств = ирОбщий.СтрРазделитьЛкс(ИменаСвойств, ",", Истина,,, Истина);
														ПараметрыКонструктора = Сред(ПоследнееВхождение.Value, Найти(ПоследнееВхождение.Value, "("));
														ПараметрыКонструктора = СокрП(ПараметрыКонструктора);
														ВыраженияЗначений = РазобратьФактическиеПараметрыВызова(ПараметрыКонструктора);
														Для ИндексСвойства = 0 По Мин(ИменаСвойств.ВГраница(), ВыраженияЗначений.Количество() - 2) Цикл 
															ВыражениеЗначения = ВыраженияЗначений[ИндексСвойства + 1];
															Если ПустаяСтрока(ВыражениеЗначения) Тогда
																Продолжить;
															КонецЕсли;
															ТаблицаПрисвоенныхТипов = ВычислитьТипЗначенияВыражения(ВыражениеЗначения,,,,, ПолныйАнализСоставаТипов, Ложь,,,,, ПозицияВхождения0);
															Если ТаблицаПрисвоенныхТипов.Количество() = 0 Тогда
																ТаблицаПрисвоенныхТипов = Неопределено;
															КонецЕсли;
															СтруктураТипа.Метаданные[ИменаСвойств[ИндексСвойства]] = ТаблицаПрисвоенныхТипов;
														КонецЦикла;
													КонецЕсли;
												КонецЕсли;
											КонецЕсли;
										КонецЕсли;
									КонецЕсли; 
									мПлатформа.ДобавитьВТаблицуТипов(ТаблицаТипов, СтруктураТипа);
								Иначе
									ПредСлово = ПоследнееВхождение.SubMatches(0);
									Если Ложь
										Или ПредСлово = "И"
										Или ПредСлово = "Или"
										Или ПредСлово = "Если"
										Или ПредСлово = "ИначеЕсли"
									Тогда
										ЛиУстановкаЗначения = Ложь;
										Если ПроверятьТипЧерезЕсли Тогда 
											//ПрименитьТип = МожноПрименитьПрисвоениеТипаИзЕсли(ТекстПроверкиВеток, ГлубинаВеток.Необязательная);
											ПрименитьТип = МожноПрименитьПрисвоениеТипаИзЕсли(ТекстДляПоискаОпределения, Позиция0ВМетодеДо, ПоследнееВхождение, ПозицияВхождения0, ГлубинаВеток.Необязательная);
										Иначе 
											ПрименитьТип = Ложь;
										КонецЕсли;
									Иначе 
										ПрименитьТип = Истина;
									КонецЕсли;
									Если ПрименитьТип Тогда 
										ТаблицаПрисвоенныхТипов = ВычислитьТипЗначенияВыражения(ПрисвоенныйКонтекст,,,,, ПолныйАнализСоставаТипов, Ложь,,, ВычислитьЗначение,, ПозицияВхождения0,, ДляСвойства);
										Если ТаблицаПрисвоенныхТипов.Количество() > 0 Тогда
											ИмяОбщегоТипа = ТаблицаПрисвоенныхТипов[0].ИмяОбщегоТипа;
											Если Истина
												И ирОбщий.СтрНачинаетсяСЛкс(ИмяОбщегоТипа, "Обещание", Истина) 
												И (Ложь
													// TODO переделать на подгруппу
													Или ирОбщий.СтрНайтиЛкс(ПоследнееВхождение.Value, " Ждать ") > 0 
													Или ирОбщий.СтрНайтиЛкс(ПоследнееВхождение.Value, " ждать ") > 0)
											Тогда
												ТаблицаПрисвоенныхТипов[0].ИмяОбщегоТипа = ирОбщий.ТекстМеждуМаркерамиЛкс(ИмяОбщегоТипа, "[", "]", Ложь);
											КонецЕсли;
											Для Каждого СтрокаТипа Из ТаблицаПрисвоенныхТипов.НайтиСтроки(ОтборПоПроизвольномуИмениТипа) Цикл
												СтрокаТипа.Метаданные = Метаданные; // Чтобы колонки владеющей таблицы значений не переносились
											КонецЦикла;
											мПлатформа.ДобавитьВТаблицуТипов(ТаблицаТипов, ТаблицаПрисвоенныхТипов,,,, ИмяОбщегоТипа = "ЭлементыФормы"); // особый двойственный тип
										КонецЕсли;
									КонецЕсли;
								КонецЕсли;
							Иначе
								// Это обход коллекции
								ПрисвоенныйКонтекст = ПоследнееВхождение.SubMatches(ЧислоГруппВШаблонеВыражения + 17);
								ДляСвойстваВниз = "0";
								Если Истина
									И ЗначениеЗаполнено(ДляСвойства)
									И НРег(ирОбщий.ПервыйФрагментЛкс(ДляСвойства)) <> "значение" //TODO передать хвост вниз 
								Тогда
									ДляСвойстваВниз = ДляСвойстваВниз + "." + ДляСвойства;
								КонецЕсли;
								ТаблицаТиповКоллекции = ВычислитьТипЗначенияВыражения(ПрисвоенныйКонтекст,,,,, ПолныйАнализСоставаТипов, Ложь,,,,, ПозицияВхождения0,, ДляСвойстваВниз);
								Для Каждого СтруктураТипаКоллекции Из ТаблицаТиповКоллекции Цикл
									Если ЗначениеЗаполнено(СтруктураТипаКоллекции.ИмяОбщегоТипа) Тогда
										ЛиУстановкаЗначения = Истина;
										мПлатформа.ТаблицаТиповЭлементовКоллекции(СтруктураТипаКоллекции,, мЯзыкПрограммы, ТаблицаТипов);
									КонецЕсли;
								КонецЦикла;
								Если ТаблицаТиповКоллекции.Колонки.Метаданные.Заголовок <> "" Тогда
									ТаблицаТипов.Колонки.Метаданные.Заголовок = ТаблицаТиповКоллекции.Колонки.Метаданные.Заголовок;         
								КонецЕсли;
							КонецЕсли;
							Если СобиратьВсеПрисвоения Тогда
								Если ЛиУстановкаЗначения Тогда
									ВсеПрисвоения.Добавить(ПоследнееВхождение.FirstIndex, ПоследнееВхождение.Value); // Возможно нужно заменить на ПозицияВхождения0
								КонецЕсли;
								Продолжить;
							КонецЕсли;
							Если Ложь
								Или ЛиУстановкаЗначения И ГлубинаВеток.Необязательная = Неопределено
								Или ЧислоПроверенныхВариантов >= 3 И Не ЭтоФактическийТип // для ускорения 
								Или ЧислоПроверенныхВариантов >= 5 И ЭтоФактическийТип // для ускорения 
								Или Истина
									И ЧислоПроверенныхВариантов >= ?(ГлубинаВеток.Необязательная = Неопределено, 1, 2) // для СтруктураКлючаТаблицыБДЛкс нужно 2
									И мПлатформа.ЛиДетальностьТиповДостаточна(ТаблицаТипов, 4,,, Ложь) // если делать меньше 3, то будет давать артефакты частичное обновление модуля, т.к. там не очищаем колонку ТипЗначения
							Тогда 
								Прервать;
							КонецЕсли;
						КонецЦикла;
						Если ЛиУстановкаЗначения Тогда 
							Позиция0ВМетодеОт = ПозицияВхождения0;
						КонецЕсли;
						Если ТаблицаТипов.Количество() > 0 Тогда
							Если СтруктураМоноТипа <> Неопределено Тогда
								Если Не ДобавитьЕдинственныйТип(ТаблицаТипов, СтруктураМоноТипа, ЭтоФактическийТип) Тогда
									ТаблицаТипов.Очистить();
								КонецЕсли;
							КонецЕсли;
							Если ТаблицаТипов.Количество() > 0 Тогда
								СтруктураТипа = ТаблицаТипов[0];   
							КонецЕсли;
						КонецЕсли;
					КонецЕсли;
				КонецЕсли;
			КонецЕсли; 
			Если Истина
				И ТипСлова = "Свойство"
				И Не СтруктураТипа.Конструктор
				И ЗначениеЗаполнено(ТекстДляПоискаОпределения)
				И (Ложь // Отсечки циклических зависимостей для модуля конструктора запросов
					Или Не ЛиПеременнаяМодуля
					Или ГлобальныйПоискВМодулеВход)
			Тогда     
				Если ЛиПеременнаяРезультата Тогда 
					ЛиВиртПрисвоение = Истина;
				КонецЕсли;
				СобратьДинамическиеСвойстваОбъекта(Выражение, ТаблицаТипов, ТекстДляПоискаОпределения, ЭтоВызовКонструктора, ПолныйАнализСоставаТипов, ГлобальныйПоискВМодуле, Позиция0ВМетодеОт, Позиция0ВМетодеДо, ДляСвойства, ЛиВиртПрисвоение);
			КонецЕсли;
			Если Истина 
				И мЯзыкПрограммы = 1
				И РодительскийКонтекст = ""
				И СтруктураТипа.ИмяОбщегоТипа = "НеизвестныйКонтекст"
				И ТаблицаПрисвоенныхТипов = Неопределено
			Тогда 
				Если Истина
					И ТипЗнч(КонтекстВыполнения) = Тип("Запрос") 
					И КонтекстВыполнения.МенеджерВременныхТаблиц <> Неопределено
					И Лев(ТекущееСлово, 1) <> "&"
				Тогда 
					ВременныйЗапрос = Новый Запрос;
					ВременныйЗапрос.МенеджерВременныхТаблиц = КонтекстВыполнения.МенеджерВременныхТаблиц;
					ВременныйЗапрос.Текст = "ВЫБРАТЬ * ИЗ " + ТекущееСлово + " ГДЕ ЛОЖЬ";
					Попытка
						// Активное вычисление!
						СтруктураТипа.Метаданные = ВременныйЗапрос.Выполнить();
						СтруктураТипа.ИмяОбщегоТипа = "ВременнаяТаблица";
						СтруктураТипа.ВиртуальнаяТаблица.Выражение = ТекущееСлово; // Используем не по назначению  
					Исключение
					КонецПопытки;
				Иначе
					СтрокаДоступнойТаблицы = НайтиДобавитьДоступнуюВременнуюТаблицу(ТекущееСлово);
					ТаблицаДоступныхПолей = ПоляДоступнойТаблицы(СтрокаДоступнойТаблицы);
					Если ТаблицаДоступныхПолей.Колонки.Найти("Заголовок") = Неопределено Тогда   
						ТаблицаДоступныхПолей.Колонки.Добавить("Заголовок");
					КонецЕсли;
					СтруктураТипа.ИмяОбщегоТипа = "ВременнаяТаблица";
					СтруктураТипа.Метаданные = ирОбщий.УстановитьМетаданныеКоллекцииЛкс(ТаблицаДоступныхПолей);
				КонецЕсли;
			КонецЕсли;
			//Если ТипыВыраженийМетода <> Неопределено Тогда
			//	ТипыВыраженийМетода.Вставить(КлючВыраженияСПозицией, ТаблицаТипов);
			//КонецЕсли;
		КонецЕсли; 
	КонецЕсли;
	Если ТаблицаТипов.Количество() = 0 Тогда
		мПлатформа.ДобавитьВТаблицуТипов(ТаблицаТипов, СтруктураТипа);
	КонецЕсли;
	Если СобиратьОшибки Тогда 
		ПроверитьВозможныеОшибкиВыражения(ТаблицаТиповОтРодителя, Позиция0ВМетодеДо, ТаблицаТипов, ЛиВиртПрисвоение, РодительскийКонтекст, ТаблицаТиповРодителя, ТекущееСлово, ТекущиеАргументы, ТекущийИндекс, ТипСлова);
	КонецЕсли;
~Возврат:
	Если Истина
		И ТипыВыраженийМетода <> Неопределено 
		И ТаблицаТипов.Колонки.Метаданные.Заголовок <> ""
	Тогда
		ТипыВыраженийМетода[КлючВыраженияСПозицией] = Неопределено;
		ТипыВыраженийМетода[КлючВыраженияСПозициейИСвойством] = ТаблицаТипов;
	КонецЕсли;
	Если ЛиКорневойВызов Тогда
		мРекурсивныйПуть = Неопределено;
		Если ТаблицаТипов.Количество() > 1 Тогда
			ТаблицаТипов.Сортировать("Детальность Убыв");
		КонецЕсли;  
	КонецЕсли;
	Если ГлобальныйПоискВМодулеВход Тогда
		ЗагрузитьМетодМодуля(СтарыйМетод);
	КонецЕсли;
	Возврат ТаблицаТипов;

КонецФункции

//.
// Параметры:
//    Позиция0ВМетодеДо - Число -  
// Возвращаемое значение:
//    Структура - 
Функция НоваяГлубинаВеток(Знач Позиция0ВМетодеДо) Экспорт
	ГлубинаВеток = Новый Структура;
	ГлубинаВеток.Вставить("Основная", 0); // разница глубины
	ГлубинаВеток.Вставить("Альтернативная", -1); // глубина альтернативной ветки, т.е. она не будет выполнена
	ГлубинаВеток.Вставить("Необязательная", Неопределено); // глубина предшествующей ветка внутри родителя, т.е. она не обязательно будет выполнена
	ГлубинаВеток.Вставить("ПредКонецВхождения", Позиция0ВМетодеДо);
	Возврат ГлубинаВеток;
КонецФункции

//.
// Параметры:
//    ТекстДляПоискаОпределения - Строка  -  где ищем определение;
//    ГлубинаВеток - Структура - 
//    ПозицияВхождения0 -  - 
//    ПоследнееВхождение -  - 
// Возвращаемое значение:
//    Строка - 
Функция СчитатьГлубинуВеток(Знач ТекстДляПоискаОпределения, Знач ГлубинаВеток, Знач ПозицияВхождения0, Знач ПоследнееВхождение) Экспорт
	КонецВхождения = ПозицияВхождения0 + ПоследнееВхождение.Length;
	ТекстПроверкиВеток = Сред(ТекстДляПоискаОпределения, КонецВхождения, ГлубинаВеток.ПредКонецВхождения - КонецВхождения + 2);
	ГлубинаВеток.ПредКонецВхождения = КонецВхождения; 
	мРегВыражение.Global = Истина;
	мРегВыражение.Pattern = мПлатформа.шПустоеНачалоСтроки + "(?:(?:Если\s[^\n]*КонецЕсли)|(?:Попытка\s[^\n]*КонецПопытки)|(Если|ИначеЕсли|Иначе|КонецЕсли|Попытка|Исключение|КонецПопытки)(?=\s|/|;|$))";
	ВхожденияЕсли = мРегВыражение.НайтиВхождения(ТекстПроверкиВеток);
	Для ИндексВхожденияЕсли = -ВхожденияЕсли.ВГраница() По 0 Цикл
		ВхождениеЕсли = ВхожденияЕсли[-ИндексВхожденияЕсли];
		Токен = НРег(ВхождениеЕсли.SubMatches(0));
		Если Не ЗначениеЗаполнено(Токен) Тогда
			Продолжить;
		ИначеЕсли Токен = "если" Или Токен = "попытка" Тогда
			ГлубинаВеток.Основная = ГлубинаВеток.Основная + 1;
			Если ГлубинаВеток.Основная > ГлубинаВеток.Альтернативная Тогда
				ГлубинаВеток.Альтернативная = -1;
			КонецЕсли;
			Если ГлубинаВеток.Необязательная <> Неопределено И ГлубинаВеток.Основная > ГлубинаВеток.Необязательная Тогда
				ГлубинаВеток.Необязательная = Неопределено;
			КонецЕсли;
		ИначеЕсли Токен = "конецесли" или Токен = "конецпопытки" Тогда
			ГлубинаВеток.Основная = ГлубинаВеток.Основная - 1;
			Если ГлубинаВеток.Необязательная = Неопределено Тогда
				ГлубинаВеток.Необязательная = ГлубинаВеток.Основная;
			КонецЕсли;
		ИначеЕсли Истина
			И Токен <> "исключение"
			И ГлубинаВеток.Основная > ГлубинаВеток.Альтернативная 
		Тогда
			ГлубинаВеток.Альтернативная = ГлубинаВеток.Основная;
		КонецЕсли;
	КонецЦикла;
	Возврат ТекстПроверкиВеток;
КонецФункции

Процедура ПроверитьВозможныеОшибкиВыражения(Знач ТаблицаТиповОтРодителя, Знач Позиция0ВМетодеДо, Знач ТаблицаТипов, Знач ЛиВиртПрисвоение, Знач РодительскийКонтекст, Знач ТаблицаТиповРодителя, Знач ТекущееСлово,
	Знач ТекущиеАргументы, Знач ТекущийИндекс, Знач ТипСлова) Экспорт
	
	Если ЗначениеЗаполнено(ТекущиеАргументы) Тогда 
		ВызовМетода = РодительскийКонтекст + "." + ТекущееСлово;
		ПозицияОшибки = Позиция0ВМетодеДо + СтрДлина(ВызовМетода + "(");
		Если Истина
			И ТекущиеАргументы <> "()"
			И мРекурсивныйПуть.ВложенныеВыражения.Найти(ТекущиеАргументы, "Выражение") = Неопределено // Если тут ошибка, то где то опять забыл установить ВычислитьТипЗначенияВыражения(ЛиКорневойВызов=Ложь)
		Тогда
			СтрокаВыражения = мРекурсивныйПуть.ВложенныеВыражения.Добавить();
			СтрокаВыражения.Выражение = ТекущиеАргументы;
			СтрокаВыражения.ВызовМетода = ВызовМетода;
			СтрокаВыражения.Позиция0ВБлоке = ПозицияОшибки;
		КонецЕсли;
		Если Истина
			И (Ложь
				Или Не мФлагиПодавленияОшибок.Свойство("МалоПараметров") 
				Или Не мФлагиПодавленияОшибок.Свойство("МногоПараметров"))
			И ЗначениеЗаполнено(РодительскийКонтекст) // Корневые вызовы платформа проверяет. Поэтому не будет тратить на них время
			И ТаблицаТипов.Количество() > 0 
			И СтрЧислоВхождений(ТекущиеАргументы, "(") < 3 // Иначе РазобратьФактическиеПараметрыВызова() будет часто давать некорректный результат 
		Тогда
			ЕстьНарушение = Неопределено;
			ФактическиеПараметры = Неопределено;
			ПройденныеСтроки = Новый Соответствие;
			ТипОшибки = "";
			Для Каждого СтрокаТипа Из ТаблицаТипов Цикл
				СтрокаОписания = СтрокаТипа.СтрокаОписания;
				Если ПройденныеСтроки[СтрокаОписания] <> Неопределено Тогда
					Продолжить;
				КонецЕсли;
				ПройденныеСтроки[СтрокаОписания] = 1;
				Если ТипЗнч(СтрокаОписания) = Тип("СтрокаТаблицыЗначений") Тогда
					ЧислоФормальныхПараметров = Неопределено;
					Если Истина
						И СтрокаОписания.Владелец().Колонки.Найти("ТелоБезВозвратов") <> Неопределено 
						//! СтрокаОписания = 0 // см. мПлатформа.НоваяТаблицаМетодовМодуля()[0]
						И СтрокаОписания.Имя <> "<>"
					Тогда  
						ФормальныеПараметрыМетода = мПлатформа.ПараметрыМетодаМодуля(СтрокаОписания);
						Если ФормальныеПараметрыМетода = Неопределено Тогда
							ЧислоФормальныхПараметров = 0;
						Иначе
							ЧислоФормальныхПараметров = ФормальныеПараметрыМетода.Количество();
						КонецЕсли;
						МинЧислоПараметров = СтрокаОписания.МинЧислоПараметров;
					ИначеЕсли Истина
						И СтрокаОписания.Владелец().Колонки.Найти("ТипКонтекста") <> Неопределено 
						//! СтрокаОписания = 0 // см. мПлатформа.ТаблицаКонтекстов[0]
						И СтрокаОписания.ТипСлова = "Метод"
						И Найти(СтрокаОписания.Слово, "<") = 0
					Тогда
						ФормальныеПараметрыМетода = мПлатформа.ПараметрыМетодаПлатформы(СтрокаОписания);
						ЧислоФормальныхПараметров = ФормальныеПараметрыМетода.Количество();
						Варианты = ирОбщий.РазличныеЗначенияКолонкиТаблицыЛкс(ФормальныеПараметрыМетода, "ВариантСинтаксиса");
						МинЧислоПараметров = 0;
						Если Варианты.Количество() > 0 Тогда
							МинЧислоПараметров = 100;
						КонецЕсли;
						Для Каждого Вариант Из Варианты Цикл
							ИтогиТаблицы = ирОбщий.МаксимумыТаблицыЗначенийЛкс(ФормальныеПараметрыМетода, "Номер", Новый Структура("ВариантСинтаксиса, Необязательный", Вариант, Ложь));
							МинЧислоПараметров = Мин(МинЧислоПараметров, ИтогиТаблицы.Номер);
						КонецЦикла;
					КонецЕсли;
					Если ЧислоФормальныхПараметров <> Неопределено И ЕстьНарушение <> Ложь Тогда
						Если ФактическиеПараметры = Неопределено Тогда
							ФактическиеПараметры = РазобратьФактическиеПараметрыВызова(ТекущиеАргументы);
						КонецЕсли;
						Если Истина
							И Не мФлагиПодавленияОшибок.Свойство("МногоПараметров")
							И ЧислоФормальныхПараметров < ФактическиеПараметры.Количество() 
						Тогда
							ЕстьНарушение = Истина;
							ТипОшибки = "МногоПараметров";
						ИначеЕсли Истина
							И Не мФлагиПодавленияОшибок.Свойство("МалоПараметров")
							И МинЧислоПараметров > ФактическиеПараметры.Количество() 
						Тогда
							ЕстьНарушение = Истина;
							ТипОшибки = "МалоПараметров";
						Иначе
							ЕстьНарушение = Ложь;
						КонецЕсли;
						Если Не ЕстьНарушение Тогда
							Прервать;
						КонецЕсли;
					КонецЕсли;
				КонецЕсли;
			КонецЦикла;
			Если ЕстьНарушение = Истина Тогда
				ОшибкаМодуля = ДобавитьОшибкуМодуля(ПозицияОшибки, ТипОшибки);
				ОшибкаМодуля.ВыражениеРодитель = ВызовМетода + "(";
				ОшибкаМодуля.Слово = ирОбщий.ПредставлениеЗначенияСОграничениемДлиныЛкс(ТекущиеАргументы, Метаданные().ТабличныеЧасти.ОшибкиМодуля.Реквизиты.Слово.Тип.КвалификаторыСтроки.Длина);
				ОшибкаМодуля.Язык = ПредставлениеЯзыкаВыражения();
				ОшибкаМодуля.ТипРодителя = мПлатформа.ПредставлениеМассиваСтруктурТипов(ТаблицаТиповРодителя);
			КонецЕсли;
		КонецЕсли;
	КонецЕсли;
	ЛучшийТипРодителя = Неопределено; // см. мПлатформа.НоваяТаблицаТипов()[0]
	Если Истина
		И Не мФлагиПодавленияОшибок.Свойство("НеизвестноеСлово")
		И ТаблицаТиповОтРодителя = Неопределено 
		И ЗначениеЗаполнено(РодительскийКонтекст) 
		И Не ЛиВиртПрисвоение
		И Не ЗначениеЗаполнено(ТекущийИндекс)
		И ТаблицаТиповРодителя <> Неопределено // не попали в кэш
		И ТаблицаТиповРодителя.Найти("Произвольный", "ИмяОбщегоТипа") = Неопределено // Обработка.ирКлсПолеТекстаПрограммы.Реквизит.Конфигурация
		И мПлатформа.ЛиДетальностьТиповДостаточна(ТаблицаТиповРодителя, 2, Истина, ЛучшийТипРодителя)
		И Не ирОбщий.СтрНачинаетсяСЛкс(ЛучшийТипРодителя.ИмяОбщегоТипа, "ISWbemObject")
		И Не ирОбщий.СтрНачинаетсяСЛкс(ЛучшийТипРодителя.ИмяОбщегоТипа, "AddIn")
		И Не ирОбщий.СтрНачинаетсяСЛкс(ЛучшийТипРодителя.ИмяОбщегоТипа, "IHTMLWindow")
		И Не ирОбщий.ЛиИмяТипаВнешнегоОбъектаМетаданныхЛкс(ЛучшийТипРодителя.ИмяОбщегоТипа)
		И Найти(ЛучшийТипРодителя.ИмяОбщегоТипа, "<") = 0 
		И (Ложь
			Или ирКэш.ЛиПортативныйРежимЛкс()
			Или ЛучшийТипРодителя.Метаданные <> Метаданные.ОбщиеМодули.ирПортативный)
		И Не (Истина
			И ирОбщий.СтрНачинаетсяСЛкс(ЛучшийТипРодителя.ИмяОбщегоТипа, "ПеречислениеКлавиша")
			И (Ложь
				Или СтрДлина(ТекущееСлово) = 1
				Или ирОбщий.СтрНачинаетсяСЛкс(ТекущееСлово, "F"))) 
	Тогда 
		ЛучшийТип = Неопределено;
		Если ТаблицаТипов.Количество() > 1 Тогда
			ЛучшийТип = ТаблицаТипов.Найти("СтандартноеХранилищеНастроекМенеджер", "ИмяОбщегоТипа"); // Против Метаданные.ХранилищеОбщихНастроек
		КонецЕсли;
		Если ЛучшийТип = Неопределено Тогда
			ЛиДетальностьТиповДостаточна = мПлатформа.ЛиДетальностьТиповДостаточна(ТаблицаТипов, 1, Истина, ЛучшийТип);
		Иначе
			ЛиДетальностьТиповДостаточна = Истина;
		КонецЕсли;
		ЛиСистемноеСлово = Истина
			И ЛучшийТип <> Неопределено
			И ТипЗнч(ЛучшийТип.СтрокаОписания) = Тип("СтрокаТаблицыЗначений")
			И ЛучшийТип.СтрокаОписания.Владелец().Колонки.Найти("Слово") <> Неопределено;
		Если Ложь
			Или Не ЛиДетальностьТиповДостаточна
			Или (Истина
				И Прав(РодительскийКонтекст, 1) <> "]"
				И (Ложь
					Или ТипСлова = "Свойство"
					Или ТипСлова = Неопределено)
				И ЛучшийТип.Метаданные <> Неопределено
				И ТипЗнч(ЛучшийТип.Метаданные) <> Тип("ОбъектМетаданных")
				И Не ирОбщий.ЛиИмяТипаВнешнегоОбъектаМетаданныхЛкс(ЛучшийТип.ИмяОбщегоТипа)
				И (Ложь
					Или (Истина
						И Найти(ЛучшийТип.ИмяОбщегоТипа, "<") > 0 
						И ЛучшийТип.СтрокаОписания <> Неопределено
						И (Ложь
							Или Найти(ЛучшийТипРодителя.ИмяОбщегоТипа, "<") = 0 
							Или мЯзыкПрограммы = 1 И ТипЗнч(ЛучшийТипРодителя.Метаданные) = Тип("ОбъектМетаданных")))
					Или (Истина 
						И ирОбщий.СтрНачинаетсяСЛкс(ЛучшийТипРодителя.ИмяОбщегоТипа, "КоллекцияМетаданных")
						И ирОбщий.СтрНачинаетсяСЛкс(ЛучшийТип.ИмяОбщегоТипа, "ОбъектМетаданных"))
					))
			Или (Истина
				И ЛучшийТип.ИмяОбщегоТипа = "Произвольный"
				И ТипСлова <> "Метод"
				И (Ложь
					Или (Истина
						И ЛиСистемноеСлово
						И Найти(ЛучшийТип.СтрокаОписания.Слово, "<") > 0 // Чтобы свойство Отбор.Значение не срабатывало 
						И ТипЗнч(ЛучшийТип.Метаданные) = Тип("ПостроительЗапроса")
						И ЛучшийТип.Метаданные.ВыбранныеПоля.Количество() > 0)
					Или (Истина
						И ТипЗнч(ЛучшийТип.Метаданные) = Тип("Структура") // Сюда попадаем для свойства "Значение" объекта ЭлементСпискаЗначений
						// TODO можно переделать на проверку СтрокаОписания
						//И ЛучшийТипРодителя.ИмяОбщегоТипа = "Структура"
						И ЛучшийТипРодителя.ИмяОбщегоТипа <> "ЭлементСпискаЗначений"
						И ЛучшийТипРодителя.ИмяОбщегоТипа <> "КлючИЗначение"
						И Найти(ЛучшийТипРодителя.ИмяОбщегоТипа, "Форм") = 0
						И (Ложь
							Или ЛучшийТип.Метаданные.Количество() > 0
							Или ТаблицаТипов.Колонки.Метаданные.Заголовок <> ""))
					Или (Истина
						И ТипЗнч(ЛучшийТип.Метаданные) = Тип("ТаблицаЗначений")
						И ЛучшийТип.Метаданные.Колонки.Количество() > 0)
					Или (Истина
						И ЛиСистемноеСлово
						И Найти(ЛучшийТип.СтрокаОписания.Слово, "<") > 0
						И (Ложь
							Или ЛучшийТип.Метаданные = Неопределено // Мультиметка29332671
							Или ирОбщий.ЛиФормаИлиИмитаторЛкс(ЛучшийТип.Метаданные)))
					))
			Или (Истина
				И ТаблицаТипов.Количество() = 1
				И ТипЗнч(ЛучшийТип.СтрокаОписания) = Тип("СтрокаТаблицыЗначений")
				И ЛучшийТип.СтрокаОписания.Владелец().Колонки.Найти("Имя") <> Неопределено
				И ЛучшийТип.СтрокаОписания.Имя = "<>")
			Или (Истина
				// Отсуствующие элементы управляемой формы
				И ЛучшийТипРодителя.ИмяОбщегоТипа = "ВсеЭлементыФормы"
				И ЛучшийТип.ИмяОбщегоТипа = "Неопределено"
				И ЛиСистемноеСлово)
			Или (Истина
				И ЛучшийТип.ИмяОбщегоТипа = "" 
				И ЛучшийТип.ТипЯзыка <> "")
		Тогда 
			СобиратьОшибки = Ложь;
			ПозицияОшибки = Позиция0ВМетодеДо + СтрДлина(РодительскийКонтекст + ".");
			Если мЭтоТекстовыйЛитерал И мЯзыкПрограммы = 0 Тогда
				ПозицияОшибки = ПозицияОшибки + 1;
			КонецЕсли;
			ОшибкаМодуля = ДобавитьОшибкуМодуля(ПозицияОшибки);
			ОшибкаМодуля.ВыражениеРодитель = РодительскийКонтекст;
			ОшибкаМодуля.Слово = ТекущееСлово;
			ОшибкаМодуля.Язык = ПредставлениеЯзыкаВыражения();
			ОшибкаМодуля.ТипРодителя = мПлатформа.ПредставлениеМассиваСтруктурТипов(ТаблицаТиповРодителя);
			Если ТипСлова = "Метод" Тогда
				ОшибкаМодуля.Слово = ОшибкаМодуля.Слово + "(";
			КонецЕсли;
		КонецЕсли;
	КонецЕсли;
КонецПроцедуры

//.
// Параметры:
//    ТекстДляПоискаОпределения - Строка		  -  где ищем определение;
//    Позиция0ВМетодеДо - Число(10,0), Неопределено -  
// Возвращаемое значение:
//    Число(10,0) - 
Функция НачалоЧастиОбъединенияЗапроса(Знач ТекстДляПоискаОпределения, Знач Позиция0ВМетодеДо) Экспорт
	мРегВыражение.Global = Истина;
	мРегВыражение.Pattern = "\sОБЪЕДИНИТЬ\s|\sUNION\s";
	ВхожденияЧастей = мРегВыражение.НайтиВхождения(ТекстДляПоискаОпределения,, Истина);
	НачалоЧасти = 0;
	Для Каждого Вхождение Из ВхожденияЧастей Цикл
		Если Позиция0ВМетодеДо < Вхождение.FirstIndex Тогда
			Прервать;
		КонецЕсли; 
		НачалоЧасти = Вхождение.FirstIndex;
	КонецЦикла;
	Возврат НачалоЧасти;
КонецФункции

Функция ИмяОтключенияЛишнихВычислений() Экспорт
	Возврат "Зукер6да45";
КонецФункции

//.
// Параметры:
//    ПозицияНачалаМетода - Число - 
// Возвращаемое значение:
//    ОбработкаТабличнаяЧастьСтрока.ирКлсПолеТекстаПрограммы.ОшибкиМодуля - 
Функция ДобавитьОшибкуМодуля(Позиция0ВБлоке, ТипОшибки = "НеизвестноеСлово") Экспорт
    Позиция0ВМодуле = мПозицияТекстаДляПоискаОпределения + Позиция0ВБлоке;
	ОшибкаМодуля = ОшибкиМодуля.Добавить();
	ОшибкаМодуля.ДатаОбнаружения = ТекущаяДата();
	Если мМетодМодуля <> Неопределено Тогда
		ОшибкаМодуля.Метод = мМетодМодуля.Имя;
		ПозицияНачалаМетода = мМетодМодуля.ПозицияТела;
	Иначе 
		ОшибкаМодуля.Метод = мПлатформа.ИмяМетодаИнициация();
		ПозицияНачалаМетода = мМодульМетаданных.ПозицияПрограммы;
    КонецЕсли;
    ОшибкаМодуля.Позиция = Позиция0ВМодуле;
    ОшибкаМодуля.ПозицияВМетоде = Позиция0ВМодуле - ПозицияНачалаМетода;
	ОшибкаМодуля.ТипОшибки = ТипОшибки;
	Возврат ОшибкаМодуля;
КонецФункции

//.
// Возвращаемое значение:
//    Структура - 
Функция НоваяСтруктураТипа() Экспорт
	СтруктураТипа = мПлатформа.НоваяСтруктураТипа();
	//Если ЗначениеЗаполнено(Конфигурация) Тогда
	СтруктураТипа.Метаданные = Конфигурация; // Произвольный
	//Иначе
	//	СтруктураТипа.Метаданные = мПлатформа.мМетаданные;
	//КонецЕсли;
	Возврат СтруктураТипа;
КонецФункции

//.
// Параметры:
//    ШаблонПоиска - Строка - 
// Возвращаемое значение:
//    Строка - 
Функция ШаблонПоискаСловаЧерезЭтотОбъект(Знач ШаблонПоиска) Экспорт
	Если мМодульМетаданных.СтруктураТипа <> Неопределено Тогда
		Если ирОбщий.ЛиИмяТипаФормыЛкс(мМодульМетаданных.СтруктураТипа.ИмяОбщегоТипа, Истина, Ложь) Тогда
			ИмяСамоСвойствоКонтекста = "ЭтаФорма";
		ИначеЕсли ирОбщий.ЛиИмяТипаФормыЛкс(мМодульМетаданных.СтруктураТипа.ИмяОбщегоТипа, Ложь, Истина) Тогда
			ИмяСамоСвойствоКонтекста = "(?:ЭтаФорма|ЭтотОбъект)";
		Иначе
			ИмяСамоСвойствоКонтекста = "ЭтотОбъект";
		КонецЕсли;
		ШаблонПоиска = "(?:" + ИмяСамоСвойствоКонтекста + "\.)?" + ШаблонПоиска;
	КонецЕсли;
	Возврат ШаблонПоиска;
КонецФункции

Функция ЗаголовокФлагОбрезкиГлубины()
	Возврат "Обрезано";
КонецФункции

//.
// Параметры:
//    Выражение - Строка	  -  
//    ТаблицаТипов - см. мПлатформа.НоваяТаблицаТипов() - 
//    ТекстДляПоискаОпределения - Строка	  -  где ищем определение;
//    ЭтоВызовКонструктора - Булево -  
//    ПолныйАнализСоставаТипов - Булево -  
//    ГлобальныйПоискВМодуле - Булево -  
//    Позиция0ВМетодеОт - Число, Неопределено -  
//    Позиция0ВМетодеДо - Число(10,0) -  
//    ДляСвойстваПуть - Строка - 
//    ЛиВиртПрисвоение - Булево - 
Процедура СобратьДинамическиеСвойстваОбъекта(Знач Выражение, Знач ТаблицаТипов, ТекстДляПоискаОпределения = "", Знач ЭтоВызовКонструктора = Ложь, Знач ПолныйАнализСоставаТипов = Истина, Знач ГлобальныйПоискВМодуле = Ложь,
	Знач Позиция0ВМетодеОт = 0, Знач Позиция0ВМетодеДо = 0, Знач ДляСвойстваПуть = "", Знач ЛиВиртПрисвоение = Ложь) 
	
	Если Ложь
		Или ЗначениеЗаполнено(Позиция0ВМетодеОт) 
		Или ЗначениеЗаполнено(Позиция0ВМетодеДо) 
	Тогда
		ТекстДляПоискаОпределения = ДиапазонТекстаДляПоиска(ТекстДляПоискаОпределения, Позиция0ВМетодеОт, Позиция0ВМетодеДо);
	КонецЕсли;
	Если ЗначениеЗаполнено(ДляСвойстваПуть) Тогда
		ДляСвойства = ирОбщий.ПервыйФрагментЛкс(ДляСвойстваПуть);
		ДляСвойстваВниз = ирОбщий.СтрокаБезПервогоФрагментаЛкс(ДляСвойстваПуть);
	Иначе
		ДляСвойства = "";
		ДляСвойстваВниз = ИмяФиктивногоСвойства(); 
	КонецЕсли;
	ШаблонВыражения = ирОбщий.ПодготовитьТекстДляРегВыраженияЛкс(Выражение);
	Для Каждого СтруктураТипаЦикл Из ТаблицаТипов Цикл
		ЛиПараметрыФормы = Истина
			И СтруктураТипаЦикл.ИмяОбщегоТипа = "ДанныеФормыСтруктура" 
			И ТипЗнч(СтруктураТипаЦикл.СтрокаОписания) = Тип("СтрокаТаблицыЗначений")
			И СтруктураТипаЦикл.СтрокаОписания.Владелец().Колонки.Найти("ТипКонтекста") <> Неопределено
			И СтруктураТипаЦикл.СтрокаОписания.Слово = "Параметры";
		Если Ложь
			Или СтруктураТипаЦикл.ИмяОбщегоТипа = "Структура"
			Или СтруктураТипаЦикл.ИмяОбщегоТипа = "ФиксированнаяСтруктура"
			Или ЛиПараметрыФормы
		Тогда
			Если ДляСвойства = ИмяФиктивногоСвойства() Тогда
				ТаблицаТипов.Колонки.Метаданные.Заголовок = ЗаголовокФлагОбрезкиГлубины();
				Продолжить;
			КонецЕсли;
			Если ЛиПараметрыФормы Тогда
				СтруктураТипаЦикл.Метаданные = мПлатформа.СхемаКоллекцииПараметровФормы(СтруктураТипаЦикл, ДляСвойства);
				ЛиОбрезано = ЗначениеЗаполнено(ДляСвойства);
			Иначе
				ЛиОбрезано = Ложь;
			КонецЕсли;
			СтруктураТипаЦикл.Метаданные = СобратьСвойстваСтруктуры(Выражение, СтруктураТипаЦикл.Метаданные, ГлобальныйПоискВМодуле, ЛиВиртПрисвоение, Позиция0ВМетодеОт, Позиция0ВМетодеДо, ДляСвойства,
				ДляСвойстваВниз, ЛиОбрезано, ШаблонВыражения, ЛиПараметрыФормы);
			Если ЛиОбрезано Тогда
				ТаблицаТипов.Колонки.Метаданные.Заголовок = ЗаголовокФлагОбрезкиГлубины();
			КонецЕсли;
			Если Истина
				И ТипЗнч(СтруктураТипаЦикл.Метаданные) = Тип("Структура")
				И СтруктураТипаЦикл.Метаданные.Количество() = 0 
			Тогда
				//СтруктураТипаЦикл.Метаданные = Неопределено; // чтобы детальность не стала 5 Мультиметка481662548
				СтруктураТипаЦикл.Детальность = 3;
			Иначе
				мПлатформа.ОбновитьДетальностьСтруктурыТипа(СтруктураТипаЦикл);
			КонецЕсли;
		КонецЕсли; 
		Если ЛиВиртПрисвоение Тогда
			Продолжить;
		КонецЕсли;
		Если ирОбщий.ПервыйФрагментЛкс(СтруктураТипаЦикл.ИмяОбщегоТипа, "[") = "Массив" Тогда
			Если ДляСвойства = ИмяФиктивногоСвойства() Тогда
				ТаблицаТипов.Колонки.Метаданные.Заголовок = ЗаголовокФлагОбрезкиГлубины();
				Продолжить;
			КонецЕсли;
			ИменаТиповЭлементов = Новый СписокЗначений;
			Если Найти(СтруктураТипаЦикл.ИмяОбщегоТипа, "[") > 0 Тогда
				ИмяТипаЭлемента = ирОбщий.ТекстМеждуМаркерамиЛкс(СтруктураТипаЦикл.ИмяОбщегоТипа, "[", "]");
				Если ИмяТипаЭлемента = "РезультатЗапроса" Тогда
					Продолжить;
				КонецЕсли;
				ИменаТиповЭлементов.Добавить(ИмяТипаЭлемента);
			КонецЕсли;
			ШаблонПоиска = шПредИнструкция + ШаблонВыражения + "\s*\.\s*(?:Добавить\s*\(|Вставить\s*\((?:" + шИмя + "|\d+),)\s*(" + шПростоеВыражениеПрограммы + ")\s*\)";
			Вхождения = НайтиВхожденияРегВыраженияКэш(ШаблонПоиска, ГлобальныйПоискВМодуле,, "ДобавлениеВМассив;" + Выражение);
			МаксЭлементов = 2;
			ИндексСвойства = 1;
			Для Каждого ВхождениеСвойства Из Вхождения Цикл
				Если ИндексСвойства > МаксЭлементов Тогда 
					Прервать;
				КонецЕсли;
				Если ЛиВхождениеВЗапрешенномДиапазоне(ВхождениеСвойства, Позиция0ВМетодеОт, Позиция0ВМетодеДо) Тогда
					Продолжить;
				КонецЕсли;
				ИндексСвойства = ИндексСвойства + 1;
				ТаблицаТиповЭлемента = ВычислитьТипЗначенияВыражения(ВхождениеСвойства.SubMatches(0),,,,
					ЭтоВызовКонструктора, ПолныйАнализСоставаТипов, Ложь, ГлобальныйПоискВМодуле,,,, ВхождениеСвойства.FirstIndex,, ДляСвойстваВниз);
				Для Каждого СтруктураТипаКоллекции Из ТаблицаТиповЭлемента Цикл
					ИмяТипаЭлемента = мПлатформа.ИмяТипаИзСтруктурыТипа(СтруктураТипаКоллекции);
					Если ИмяТипаЭлемента <> "?" И ИменаТиповЭлементов.НайтиПоЗначению(ИмяТипаЭлемента) = Неопределено Тогда
						ИменаТиповЭлементов.Добавить(ИмяТипаЭлемента);
					КонецЕсли;
					Если СтруктураТипаКоллекции.Детальность > 3 Тогда
						СтруктураТипаЦикл.Метаданные = СтруктураТипаКоллекции.Метаданные;
					КонецЕсли;
				КонецЦикла;
				Если ТаблицаТиповЭлемента.Колонки.Метаданные.Заголовок <> "" Тогда
					ТаблицаТипов.Колонки.Метаданные.Заголовок = ЗаголовокФлагОбрезкиГлубины();
				КонецЕсли;
			КонецЦикла;
			Если ИменаТиповЭлементов.Количество() > 0 Тогда
				ИменаТиповЭлементов.СортироватьПоЗначению();
				СтруктураТипаЦикл.ИмяОбщегоТипа = "Массив" + "[" + ирОбщий.СтрСоединитьЛкс(ИменаТиповЭлементов.ВыгрузитьЗначения()) + "]";
			КонецЕсли;
			мПлатформа.ОбновитьДетальностьСтруктурыТипа(СтруктураТипаЦикл);
		ИначеЕсли Ложь
			Или СтруктураТипаЦикл.ИмяОбщегоТипа = "СписокЗначений"
			Или СтруктураТипаЦикл.ИмяОбщегоТипа = "Соответствие"
		Тогда
			Если ДляСвойства = ИмяФиктивногоСвойства() Тогда
				ТаблицаТипов.Колонки.Метаданные.Заголовок = ЗаголовокФлагОбрезкиГлубины();
				Продолжить;
			КонецЕсли;
			Если Истина
				И Тип(СтруктураТипаЦикл.ИмяОбщегоТипа) = ТипЗнч(СтруктураТипаЦикл.Метаданные)
				И СтруктураТипаЦикл.Метаданные.Количество() > 0
			Тогда
				Продолжить;
			КонецЕсли; 
			ТаблицаТиповВсехЭлементов = Неопределено;
			Если Истина
				И ТипЗнч(СтруктураТипаЦикл.Метаданные) = Тип("Структура") 
				И СтруктураТипаЦикл.Метаданные.Свойство("Значение")
			Тогда 
				ТаблицаТиповВсехЭлементов = СтруктураТипаЦикл.Метаданные.Значение;
			Иначе 
				СтруктураТипаЦикл.Метаданные = Новый Структура("Значение");
			КонецЕсли;
			Если СтруктураТипаЦикл.ИмяОбщегоТипа = "СписокЗначений" Тогда 
				ШаблонПоиска = шПредИнструкция + ШаблонВыражения + "\s*\.\s*Добавить\s*\(\s*(" + шПростоеВыражениеПрограммы + ")\s*[,\)]";
			Иначе // Если СтруктураТипаЦикл.ИмяОбщегоТипа = "Соответствие" 
				ШаблонПоиска = шПредИнструкция + ШаблонВыражения + "\s*(?:\.\s*Вставить\s*\([^,\)]*,|\[[^\]]*\]\s*=)\s*(" + шПростоеВыражениеПрограммы + ")\s*[\);\n]";
			КонецЕсли;
			Вхождения = НайтиВхожденияРегВыраженияКэш(ШаблонПоиска, ГлобальныйПоискВМодуле,, "ВставкаВСоответствие;" + Выражение);
			МаксЭлементов = 2;
			ИндексСвойства = 1;
			Для Каждого ВхождениеСвойства Из Вхождения Цикл
				Если ИндексСвойства > МаксЭлементов Тогда 
					Прервать;
				КонецЕсли;
				Если ЛиВхождениеВЗапрешенномДиапазоне(ВхождениеСвойства, Позиция0ВМетодеОт, Позиция0ВМетодеДо) Тогда
					Продолжить;
				КонецЕсли;
				ИндексСвойства = ИндексСвойства + 1;
				ТаблицаТиповЭлемента = ВычислитьТипЗначенияВыражения(ВхождениеСвойства.SubMatches(0),,,, 
					ЭтоВызовКонструктора, ПолныйАнализСоставаТипов, Ложь, ГлобальныйПоискВМодуле,,,, ВхождениеСвойства.FirstIndex,, ДляСвойстваВниз);
				мПлатформа.ДобавитьВТаблицуТипов(ТаблицаТиповВсехЭлементов, ТаблицаТиповЭлемента);
				Если мПлатформа.ЛиДетальностьТиповДостаточна(ТаблицаТиповВсехЭлементов, 4) Тогда
					Прервать;
				КонецЕсли;
				Если ТаблицаТиповВсехЭлементов.Колонки.Метаданные.Заголовок <> "" Тогда
					ТаблицаТипов.Колонки.Метаданные.Заголовок = ЗаголовокФлагОбрезкиГлубины();
				КонецЕсли;
			КонецЦикла;
			СтруктураТипаЦикл.Метаданные.Значение = ТаблицаТиповВсехЭлементов;
			мПлатформа.ОбновитьДетальностьСтруктурыТипа(СтруктураТипаЦикл);
		ИначеЕсли Ложь
			Или СтруктураТипаЦикл.ИмяОбщегоТипа = "ТаблицаЗначений"
			Или СтруктураТипаЦикл.ИмяОбщегоТипа = "ДеревоЗначений"
		Тогда
			Если ДляСвойства = ИмяФиктивногоСвойства() Тогда
				ТаблицаТипов.Колонки.Метаданные.Заголовок = ЗаголовокФлагОбрезкиГлубины();
				Продолжить;
			КонецЕсли;
			МетаданныеТаблицы = СтруктураТипаЦикл.Метаданные;
			Если ТипЗнч(МетаданныеТаблицы) = Тип("Структура") Тогда
				НовыеМетаданныеТаблицы = МетаданныеТаблицы;
			Иначе 
				НовыеМетаданныеТаблицы = Новый Структура;
			КонецЕсли;
			// шПредИнструкция здесь не используем, т.к. ищем вызовы функции, а не процедуры. В таком режиме приходится учитывать и закомментированный код.
			ШаблонПоиска = шПредИмяПрямое + ШаблонВыражения + "\s*\.\s*Колонки\s*.\s*(?:Добавить\s*\(|Вставить\s*\((?:" + шИмя + "|\d+),)\s*" 
				+ "(" + шЛитералПрограммы + "|" + шИмяСТочками + ")\s*(?:,\s*(" + шПростоеВыражениеПрограммы + ")|,|\))" 
				+ "(?:\s*,\s*(?:" + шЛитералПрограммы + "|" + шСкобкиЛенивые + "|[^\)""])*)?(?:\)\s*)?" + шНазначениеТипаПриПрисвоении;
			Вхождения = НайтиВхожденияРегВыраженияКэш(ШаблонПоиска, ГлобальныйПоискВМодуле,, "ДобавлениеКолонок;" + Выражение);
			ЕстьДобавленияКолонок = Ложь;
			ЛиОбрезано = Ложь;
			ДляСвойстваТаблицы = ДляСвойства;
			ДляСвойстваВнизТаблицы = ДляСвойстваВниз;
			ОбрезатьДляСвойстваКоллекции(ДляСвойстваВнизТаблицы, ДляСвойстваТаблицы);
			Для Каждого ВхождениеСвойства Из Вхождения Цикл
				Если Ложь
					Или ЛиВхождениеВЗапрешенномДиапазоне(ВхождениеСвойства, Позиция0ВМетодеОт, Позиция0ВМетодеДо) 
					Или Лев(ВхождениеСвойства.Value, 1) = "/" // Закомментированная инструкция
				Тогда
					Продолжить;
				КонецЕсли; 
				ПрисвоенноеВыражение = ВхождениеСвойства.SubMatches(0);
				Если Лев(ПрисвоенноеВыражение, 1) = """" Тогда
					ТекстовоеЗначение = ирОбщий.ТекстИзВстроенногоЯзыкаЛкс(ПрисвоенноеВыражение);
				Иначе
					ТекстовоеЗначение = ВычислитьЗначениеВыражения(ПрисвоенноеВыражение,,, Позиция0ВМетодеОт, ВхождениеСвойства.FirstIndex);
				КонецЕсли;
				Если ирОбщий.ЛиИмяПеременнойЛкс(ТекстовоеЗначение) Тогда
					ЕстьДобавленияКолонок = Истина; // Чтобы не требовалось слияние разных типов метаданных одной таблицы, которое не реализовано в ДобавитьВТаблицуТипов()
					Если Истина
						И ЗначениеЗаполнено(ДляСвойстваТаблицы) 
						И Не ирОбщий.СтрокиРавныЛкс(ДляСвойстваТаблицы, ТекстовоеЗначение)
						//И Не мПлатформа.мРежимПроверкиМодуля
					Тогда
						ЛиОбрезано = Истина;
						Продолжить;
					КонецЕсли;
					ТаблицаТиповКолонки = Неопределено;
					ПрисвоенныйТип = ВхождениеСвойства.SubMatches(8);
					Если ЗначениеЗаполнено(ПрисвоенныйТип) Тогда
						ТипЗначения = ирОбщий.ПервыйФрагментЛкс(ПрисвоенныйТип, "-");
						Если ЗначениеЗаполнено(ТипЗначения) Тогда
							ТаблицаТиповКолонки = ТаблицаТиповИзТекста(ТипЗначения,,, ДляСвойстваВнизТаблицы);
						КонецЕсли;
					КонецЕсли;
					Если Не мПлатформа.ЛиДетальностьТиповДостаточна(ТаблицаТиповКолонки) Тогда
						ОписаниеТипов = ВычислитьЗначениеВыражения(ВхождениеСвойства.SubMatches(1),,, Позиция0ВМетодеОт, ВхождениеСвойства.FirstIndex);
						Если ЗначениеЗаполнено(ОписаниеТипов) Тогда
							ТаблицаТиповКолонки = мПлатформа.ТаблицаТиповИзОписанияТипов(ОписаниеТипов);
						КонецЕсли;
					КонецЕсли;
					Если ЗначениеЗаполнено(ТаблицаТиповКолонки) Тогда
						Если ТаблицаТиповКолонки.Колонки.Метаданные.Заголовок <> "" Тогда
							ЛиОбрезано = Истина;
						КонецЕсли;
					Иначе
						ТаблицаТиповКолонки = Неопределено;
					КонецЕсли;
					НовыеМетаданныеТаблицы.Вставить(ТекстовоеЗначение, ТаблицаТиповКолонки);
				КонецЕсли;
			КонецЦикла; 
			Если ЛиОбрезано Тогда
				ТаблицаТипов.Колонки.Метаданные.Заголовок = ЗаголовокФлагОбрезкиГлубины();
			КонецЕсли;
			Если ЕстьДобавленияКолонок И НовыеМетаданныеТаблицы <> МетаданныеТаблицы Тогда
				Если Ложь
					Или ТипЗнч(МетаданныеТаблицы) = Тип("ДеревоЗначений") 
					Или ТипЗнч(МетаданныеТаблицы) = Тип("ТаблицаЗначений")
				Тогда
					Для Каждого Колонка Из МетаданныеТаблицы.Колонки Цикл
						Если Не НовыеМетаданныеТаблицы.Свойство(Колонка.Имя) Тогда
							ТаблицаТиповКолонки = мПлатформа.ТаблицаТиповИзОписанияТипов(Колонка.ТипЗначения);
							Если ТаблицаТиповКолонки.Количество() = 0 Тогда
								ТаблицаТиповКолонки = Неопределено;
							КонецЕсли;
							НовыеМетаданныеТаблицы.Вставить(Колонка.Имя, ТаблицаТиповКолонки);
						КонецЕсли;
					КонецЦикла;
				КонецЕсли;
				СтруктураТипаЦикл.Метаданные = НовыеМетаданныеТаблицы;
				мПлатформа.ОбновитьДетальностьСтруктурыТипа(СтруктураТипаЦикл);
			КонецЕсли;
		ИначеЕсли Ложь
			Или СтруктураТипаЦикл.ИмяОбщегоТипа = "Запрос"
			Или СтруктураТипаЦикл.ИмяОбщегоТипа = "ПостроительЗапроса"
			Или СтруктураТипаЦикл.ИмяОбщегоТипа = "ПостроительОтчета"
		Тогда
			Если ДляСвойства = ИмяФиктивногоСвойства() Тогда
				ТаблицаТипов.Колонки.Метаданные.Заголовок = ЗаголовокФлагОбрезкиГлубины();
				Продолжить;
			КонецЕсли;
			Если ТипЗнч(СтруктураТипаЦикл.Метаданные) = Тип("Запрос") Тогда
				СтруктураТипаЦикл.Метаданные = мПлатформа.ПостроительЗапросаИзТекстаДляТипа(СтруктураТипаЦикл.Метаданные.Текст);
			ИначеЕсли ТипЗнч(СтруктураТипаЦикл.Метаданные) <> Тип("ПостроительЗапроса") Тогда
				СтруктураТипаЦикл.Метаданные = Новый ПостроительЗапроса;
			КонецЕсли;
			Если ТипЗнч(СтруктураТипаЦикл.ДержательМетаданных) <> Тип("Структура") Тогда
				СтруктураТипаЦикл.ДержательМетаданных = НовыйМенеджерВременныхТаблиц();
			КонецЕсли;
			ПостроительЗапроса = СтруктураТипаЦикл.Метаданные;
			ТаблицаТиповИсточника = Неопределено;
			Если СтруктураТипаЦикл.ИмяОбщегоТипа <> "Запрос" Тогда
				ШаблонПоискаИсточника = ШаблонНазначенияТипаВыражению(ШаблонВыражения + "\.ИсточникДанных");
				ВхожденияИсточника = НайтиВхожденияРегВыраженияКэш(ШаблонПоискаИсточника, ГлобальныйПоискВМодуле, ТекстДляПоискаОпределения, "НазначениеТипа;" + Выражение + ".ИсточникДанных");
				Для Каждого ВхождениеИсточника Из ВхожденияИсточника Цикл
					Если ЛиВхождениеВЗапрешенномДиапазоне(ВхождениеИсточника, Позиция0ВМетодеОт, Позиция0ВМетодеДо) Тогда
						Продолжить;
					КонецЕсли;
					ПрисвоенноеВыражение = ВхождениеИсточника.SubMatches(3);
					ТаблицаТиповИсточника = ВычислитьТипЗначенияВыражения(ПрисвоенноеВыражение, ТекстДляПоискаОпределения,,,,, Ложь, ГлобальныйПоискВМодуле,,,, ВхождениеИсточника.FirstIndex);
					Прервать;
				КонецЦикла;
			КонецЕсли;
			Если ТаблицаТиповИсточника <> Неопределено Тогда
				Если мПлатформа.ЛиДетальностьТиповДостаточна(ТаблицаТиповИсточника, 4) Тогда
					ПустаяТаблица = мПлатформа.ПодготовитьЗначениеПараметраЗапроса(ТаблицаТиповИсточника[0].Метаданные);
					ПостроительЗапроса.ИсточникДанных = Новый ОписаниеИсточникаДанных(ПустаяТаблица);
				КонецЕсли;
			Иначе
				МенеджерВременныхТаблиц = СтруктураТипаЦикл.ДержательМетаданных;
				ЛиМенеджерГотов = ЛиМенеджерВременныхТаблицОбработалМетод(МенеджерВременныхТаблиц);
				Если Не ЛиМенеджерГотов И СтруктураТипаЦикл.ИмяОбщегоТипа = "Запрос" Тогда
					//ТаблицаТиповМенеджера = ВычислитьТипДочернегоЭлемента(ТаблицаТипов, "МенеджерВременныхТаблиц", "Свойство"); // Долго - 2мс
					ТаблицаТиповМенеджера = мПлатформа.ТаблицаТиповИзОписанияТипов(Новый ОписаниеТипов("МенеджерВременныхТаблиц"));
					ТаблицаТиповМенеджера[0].Метаданные = МенеджерВременныхТаблиц;
					СобратьОперацииМенеджераВременныхТаблиц(МенеджерВременныхТаблиц, Выражение, Позиция0ВМетодеОт, Позиция0ВМетодеДо, ДляСвойстваПуть, ТаблицаТиповМенеджера);
				КонецЕсли; 
				ПозицияПоискаТекстаДо = Позиция0ВМетодеДо;  
				ПозицияПоискаТекстаОт = Позиция0ВМетодеОт; // TODO сдвинуть вперед до позиции найденной установки менеджера
				ТекстВЭтомБлокеУстановлен = Ложь;
				НачальныйИндекс = МенеджерВременныхТаблиц.ПакетыЗапросов.Количество();
				ШаблонПоискаТекста = ШаблонНазначенияТипаВыражению(ШаблонВыражения + "\.Текст", Истина);
				ВхожденияТекста = НайтиВхожденияРегВыраженияКэш(ШаблонПоискаТекста, ГлобальныйПоискВМодуле, ТекстДляПоискаОпределения, "НазначениеТипа;" + Выражение + ".Текст");
				Для Индекс = 1 - ВхожденияТекста.Количество() По 0 Цикл // Обратный обход
					ВхождениеТекста = ВхожденияТекста[-Индекс];
					Если ЛиВхождениеВЗапрешенномДиапазоне(ВхождениеТекста, ПозицияПоискаТекстаОт, ПозицияПоискаТекстаДо) Тогда
						Продолжить;
					КонецЕсли;
					ПрисвоенноеВыражение = ВхождениеТекста.SubMatches(3);
					Если Не ЗначениеЗаполнено(ПрисвоенноеВыражение) Тогда
						Продолжить;
					КонецЕсли;  
					Позиция0Группы = Найти(ВхождениеТекста.Value, Лев(ПрисвоенноеВыражение, 50)) - 1;
					КоординатыТекста = Неопределено; // см. НовыеКоординатыВыражения()
					ТекстПакета = ВычислитьЗначениеВыражения(ПрисвоенноеВыражение, ТекстДляПоискаОпределения, ГлобальныйПоискВМодуле, ПозицияПоискаТекстаОт, ВхождениеТекста.FirstIndex + Позиция0Группы, КоординатыТекста);
					Если ЗначениеЗаполнено(ТекстПакета) Тогда
						ПакетЗапросов = НовыйПакетЗапросов(КоординатыТекста.Выражение, КоординатыТекста);
						МенеджерВременныхТаблиц.ПакетыЗапросов.Вставить(НачальныйИндекс, ПакетЗапросов); 
						Если Не ТекстВЭтомБлокеУстановлен Тогда
							мПлатформа.ПостроительЗапросаИзТекстаДляТипа(ТекстПакета, ПостроительЗапроса);
							ПараметрыЗапроса = СобратьСвойстваСтруктуры(Выражение + ".Параметры",,,, ПозицияПоискаТекстаОт, ПозицияПоискаТекстаДо);
							Если ТипЗнч(ПараметрыЗапроса) = Тип("Структура") Тогда
								ШаблонПоиска = шПредИнструкция + ШаблонВыражения + "\s*\.\s*УстановитьПараметр\s*\(\s*(" + шЛитералПрограммы + ")\s*,\s*((?:" + шЛитералПрограммы + "|" + шСкобкиЛенивые + "|[^\)""])*)";
								Вхождения = НайтиВхожденияРегВыраженияКэш(ШаблонПоиска, ГлобальныйПоискВМодуле,, "УстановитьПараметрЗапроса;" + Выражение);
								Для Каждого Вхождение Из Вхождения Цикл
									Если ЛиВхождениеВЗапрешенномДиапазоне(Вхождение, ПозицияПоискаТекстаОт, ПозицияПоискаТекстаДо) Тогда
										Продолжить;
									КонецЕсли;
									ВыражениеИмени = Вхождение.SubMatches(0);
									ТекстовоеЗначение = ирОбщий.ТекстИзВстроенногоЯзыкаЛкс(ВыражениеИмени);
									Если Не ирОбщий.ЛиИмяПеременнойЛкс(ТекстовоеЗначение) Тогда 
										Продолжить;
									КонецЕсли;  
									ВыражениеЗначения = Вхождение.SubMatches(1);
									ТаблицаТиповЗначения = Неопределено;
									Если ЗначениеЗаполнено(ВыражениеЗначения) Тогда
										ТаблицаТиповНовая = ВычислитьТипЗначенияВыражения(ВыражениеЗначения,,,,,, Ложь,,,,, Вхождение.FirstIndex);
										Если ТаблицаТиповНовая.Количество() = 0 Тогда
											ТаблицаТиповЗначения = Неопределено;
										Иначе 
											ТаблицаТиповЗначения = ТаблицаТиповНовая; // Пустые таблицы запрещены, т.к. проверка пустоты участвует в разделении таблицы-значения и таблицы типов значения
										КонецЕсли;
									КонецЕсли;
									Если ТаблицаТиповЗначения = Неопределено И ПостроительЗапроса.Параметры.Свойство(ТекстовоеЗначение) Тогда
										Продолжить;
									КонецЕсли;
									ПараметрыЗапроса.Вставить(ТекстовоеЗначение, ТаблицаТиповЗначения);
								КонецЦикла;
								ирОбщий.СкопироватьКоллекциюЛкс(ПараметрыЗапроса, ПостроительЗапроса.Параметры);
								ИмяКолонкиФлагаВнутриТаблицы = мПлатформа.ИмяКолонкиФлагаВнутриТаблицы();
								Для Каждого КлючИЗначение Из ПостроительЗапроса.Параметры Цикл
									ЗначениеПараметра = КлючИЗначение.Значение;
									ПакетЗапросов.Параметры.Вставить(КлючИЗначение.Ключ, ЗначениеПараметра);
								КонецЦикла;
							КонецЕсли;
							ТекстВЭтомБлокеУстановлен = Истина;
						КонецЕсли;
					КонецЕсли; 
					//Если Ложь
					//	Или ТекстПакета = Неопределено 
					//	Или Не МенеджерВременныхТаблиц.Активен 
					//Тогда
					//	Прервать;
					//КонецЕсли;
				КонецЦикла;
				Если МенеджерВременныхТаблиц.ПакетыЗапросов.Количество() > 0 Тогда
					СтруктураТипаЦикл.ДержательМетаданных = МенеджерВременныхТаблиц;
				КонецЕсли;
			КонецЕсли;
			мПлатформа.ОбновитьДетальностьСтруктурыТипа(СтруктураТипаЦикл);
		ИначеЕсли СтруктураТипаЦикл.ИмяОбщегоТипа = "МенеджерВременныхТаблиц" Тогда
			Если ДляСвойства = ИмяФиктивногоСвойства() Тогда
				ТаблицаТипов.Колонки.Метаданные.Заголовок = ЗаголовокФлагОбрезкиГлубины();
				Продолжить;
			КонецЕсли;
			ЛиМенеджерГотов = ЛиМенеджерВременныхТаблицОбработалМетод(СтруктураТипаЦикл.Метаданные);
			Если ЛиМенеджерГотов Тогда
				Продолжить;
			КонецЕсли;
			Если ТипЗнч(СтруктураТипаЦикл.Метаданные) <> Тип("Структура") Тогда
				СтруктураТипаЦикл.Метаданные = НовыйМенеджерВременныхТаблиц();
			КонецЕсли;
			МенеджерВременныхТаблиц = СтруктураТипаЦикл.Метаданные; // см. НовыйМенеджерВременныхТаблиц()
			ШаблонПоиска = шПредИнструкция + "(" + шИмя + ").МенеджерВременныхТаблиц\s*=\s*" + Выражение + шКонецТокена;
			Вхождения = НайтиВхожденияРегВыраженияКэш(ШаблонПоиска, ГлобальныйПоискВМодуле,, "МенеджерВременныхТаблицВЗапрос;" + Выражение);
			Для Каждого ВхождениеСвойства Из Вхождения Цикл
				Если ЛиВхождениеВЗапрешенномДиапазоне(ВхождениеСвойства, Позиция0ВМетодеОт, Позиция0ВМетодеДо) Тогда
					Продолжить;
				КонецЕсли;
				СобратьОперацииМенеджераВременныхТаблиц(МенеджерВременныхТаблиц, ВхождениеСвойства.SubMatches(0), ВхождениеСвойства.FirstIndex + ВхождениеСвойства.Length, Позиция0ВМетодеДо, ДляСвойстваПуть);
			КонецЦикла;
			ШаблонПоиска = шПредИнструкция + Выражение + "\s*\.\s*докДобавить\(\s*(" + шПростоеВыражениеПрограммы + ")\s*\)"; // Виртуальный документирующий метод докДобавить
			Вхождения = НайтиВхожденияРегВыраженияКэш(ШаблонПоиска, ГлобальныйПоискВМодуле,, "ДобавлениеВременнойТаблицы;" + Выражение);
			Для Каждого ВхождениеСвойства Из Вхождения Цикл
				Если ЛиВхождениеВЗапрешенномДиапазоне(ВхождениеСвойства, Позиция0ВМетодеОт, Позиция0ВМетодеДо) Тогда
					Продолжить;
				КонецЕсли;
				ТаблицаТиповМенеджера = ВычислитьТипЗначенияВыражения(ВхождениеСвойства.SubMatches(0),,,,,,,,,, Позиция0ВМетодеОт, ВхождениеСвойства.FirstIndex);
				Если ТаблицаТиповМенеджера.Количество() > 0 Тогда
					ДобавляемыйМенеджер = ТаблицаТиповМенеджера[0].Метаданные;
					Если ТипЗнч(ДобавляемыйМенеджер) = Тип("Структура") Тогда
						ирОбщий.ДополнитьМассивЛкс(МенеджерВременныхТаблиц.ПакетыЗапросов, ДобавляемыйМенеджер.ПакетыЗапросов);
					КонецЕсли;
				КонецЕсли;
			КонецЦикла; 
			мПлатформа.ОбновитьДетальностьСтруктурыТипа(СтруктураТипаЦикл);
		ИначеЕсли СтруктураТипаЦикл.ИмяОбщегоТипа = "КомпоновщикНастроекКомпоновкиДанных" Тогда
			Если ДляСвойства = ИмяФиктивногоСвойства() Тогда
				ТаблицаТипов.Колонки.Метаданные.Заголовок = ЗаголовокФлагОбрезкиГлубины();
				Продолжить;
			КонецЕсли;
			Если ТипЗнч(СтруктураТипаЦикл.Метаданные) = Тип("СхемаКомпоновкиДанных") Тогда
				СтруктураТипаЦикл.Метаданные = ирОбщий.КомпоновщикПоСхемеКомпоновкиЛкс(СтруктураТипаЦикл.Метаданные);
			ИначеЕсли ТипЗнч(СтруктураТипаЦикл.Метаданные) = Тип("ДинамическийСписок") Тогда
				СтруктураТипаЦикл.Метаданные = СтруктураТипаЦикл.Метаданные.КомпоновщикНастроек;
			ИначеЕсли ТипЗнч(СтруктураТипаЦикл.Метаданные) <> Тип("КомпоновщикНастроекКомпоновкиДанных") Тогда
				СтруктураТипаЦикл.Метаданные = Новый КомпоновщикНастроекКомпоновкиДанных;
				Компоновщик = СтруктураТипаЦикл.Метаданные;
				СхемаКомпоновки = Неопределено;
				ШаблонПоиска = шПредИнструкция + ШаблонВыражения + "\s*\.\s*Инициализировать\(\s*(" + шПростоеВыражениеПрограммы + ")\s*\)";
				Вхождения = НайтиВхожденияРегВыраженияКэш(ШаблонПоиска, ГлобальныйПоискВМодуле,, "ИнициацияКомпоновщика;" + Выражение);
				Для Индекс = 1 - Вхождения.Количество() По 0 Цикл // Обратный обход
					Вхождение = Вхождения[-Индекс];
					Если ЛиВхождениеВЗапрешенномДиапазоне(Вхождение, Позиция0ВМетодеОт, Позиция0ВМетодеДо) Тогда
						Продолжить;
					КонецЕсли;
					ТаблицаТиповИсточника = ВычислитьТипЗначенияВыражения(Вхождение.SubMatches(0),,,,,, Ложь,,,,, Вхождение.FirstIndex);
					Если ТаблицаТиповИсточника.Количество() > 0 Тогда
						СхемаКомпоновкиЛ = ТаблицаТиповИсточника[0].Метаданные;
						Если ТипЗнч(СхемаКомпоновкиЛ) = Тип("СхемаКомпоновкиДанных") Тогда
							СхемаКомпоновки = СхемаКомпоновкиЛ;
							Прервать;
						КонецЕсли;
					КонецЕсли;
				КонецЦикла; 
				Если СхемаКомпоновки <> Неопределено Тогда
					СтруктураТипаЦикл.Метаданные = ирОбщий.КомпоновщикПоСхемеКомпоновкиЛкс(СхемаКомпоновки);
				Иначе
					ПолноеИмяОтчета = "";
					Если Истина
						И Вхождения.Количество() = 0 
						И мМодульМетаданных.СтруктураТипа <> Неопределено
					Тогда
						Если мМодульМетаданных.СтруктураТипа.ИмяОбщегоТипа = "РасширениеФормыОтчета" Тогда
							СтруктураТипаОбъекта = мПлатформа.СтруктураТипаОбъектаОбычнойФормы(мМодульМетаданных.СтруктураТипа.Метаданные);
							Если СтруктураТипаОбъекта <> Неопределено Тогда
								ПолноеИмяОтчета = СтруктураТипаОбъекта.Метаданные.ПолноеИмя();
							КонецЕсли;
						ИначеЕсли мМодульМетаданных.СтруктураТипа.ИмяОбщегоТипа = "РасширениеФормыКлиентскогоПриложенияДляОтчета" Тогда
							СтруктураТипаОбъекта = мПлатформа.СтруктураТипаОбъектаОбычнойФормы(мМодульМетаданных.СтруктураТипа.Метаданные);
							Если СтруктураТипаОбъекта <> Неопределено Тогда
								ПолноеИмяОтчета = СтруктураТипаОбъекта.Метаданные.ПолноеИмя();
							КонецЕсли;
						КонецЕсли;
					КонецЕсли;
					Если ЗначениеЗаполнено(ПолноеИмяОтчета) Тогда
						СхемаКомпоновки = ирКэш.ОсновнаяСхемаКомпоновкиОтчетаЛкс(ПолноеИмяОтчета); 
						Если СхемаКомпоновки <> Неопределено Тогда
							СтруктураТипаЦикл.Метаданные = ирОбщий.КомпоновщикПоСхемеКомпоновкиЛкс(СхемаКомпоновки);
						КонецЕсли;
					КонецЕсли;
				КонецЕсли;
			КонецЕсли;
			//СтруктураТипаЦикл.ДержательМетаданных = СтруктураТипаЦикл.Метаданные;
			мПлатформа.ОбновитьДетальностьСтруктурыТипа(СтруктураТипаЦикл);
		ИначеЕсли Ложь
			Или СтруктураТипаЦикл.ИмяОбщегоТипа = "ДекорацияФормы"
			Или СтруктураТипаЦикл.ИмяОбщегоТипа = "ПолеФормы" 
			Или СтруктураТипаЦикл.ИмяОбщегоТипа = "ГруппаФормы"
		Тогда
			ШаблонПоиска = шПредИнструкция + Выражение + "\s*\.\s*Вид\s*=\s*(" + шПростоеВыражениеПрограммы + ")";
			Вхождения = НайтиВхожденияРегВыраженияКэш(ШаблонПоиска, ГлобальныйПоискВМодуле,, "УстановкаВидаПоля;" + Выражение);
			Для Каждого ВхождениеСвойства Из Вхождения Цикл
				Если ЛиВхождениеВЗапрешенномДиапазоне(ВхождениеСвойства, Позиция0ВМетодеОт, Позиция0ВМетодеДо) Тогда
					Продолжить;
				КонецЕсли;
				ПрисвоенноеВыражение = ВхождениеСвойства.SubMatches(0);
				Если СтруктураТипаЦикл.ИмяОбщегоТипа = "ДекорацияФормы" Тогда
					ИмяПеречисления = "ВидДекорацииФормы";
				ИначеЕсли СтруктураТипаЦикл.ИмяОбщегоТипа = "ПолеФормы" Тогда
					ИмяПеречисления = "ВидПоляФормы";
				ИначеЕсли СтруктураТипаЦикл.ИмяОбщегоТипа = "ГруппаФормы" Тогда
					ИмяПеречисления = "ВидГруппыФормы";
				Иначе 
					ВызватьИсключение "Э";
				КонецЕсли;
				Если ирОбщий.СтрНачинаетсяСЛкс(ПрисвоенноеВыражение, ИмяПеречисления + ".") Тогда
					Попытка
						ВидПоля = ПредопределенноеЗначение(ПрисвоенноеВыражение);
					Исключение
						ВидПоля = Неопределено;
					КонецПопытки;
					Если ВидПоля <> Неопределено Тогда
						ИмяРасширения = мПлатформа.ИмяТипаРасширенияЭлементаФормы(СтруктураТипаЦикл.ИмяОбщегоТипа, Новый Структура("Вид", ВидПоля));
						Если ЗначениеЗаполнено(ИмяРасширения) Тогда
							СтруктураТипаЦикл.ИмяОбщегоТипа = ИмяРасширения;
							СтруктураТипаЦикл.Детальность = 5; // Сделал тут вместо мПлатформа.ОбновитьДетальностьСтруктурыТипа для ускорения
							Прервать;
						КонецЕсли;
					КонецЕсли;
				КонецЕсли;
			КонецЦикла; 
		КонецЕсли; 
	КонецЦикла;
КонецПроцедуры

//.
// Параметры:
//    ДляСвойстваВнизТаблицы - Строка - 
//    ДляСвойстваТаблицы - Строка, Неопределено - 
Процедура ОбрезатьДляСвойстваКоллекции(ДляСвойстваВнизТаблицы, ДляСвойстваТаблицы) Экспорт
	Пока Ложь
		Или ДляСвойстваТаблицы = "0"
		Или ДляСвойстваТаблицы = "Строки" 
		Или ДляСвойстваТаблицы = "Колонки" 
		Или ДляСвойстваТаблицы = "Индексы"  
	Цикл
		ДляСвойстваТаблицы = ирОбщий.ПервыйФрагментЛкс(ДляСвойстваВнизТаблицы);
		ДляСвойстваВнизТаблицы = ирОбщий.СтрокаБезПервогоФрагментаЛкс(ДляСвойстваВнизТаблицы);
	КонецЦикла;
	ДляСвойстваВнизТаблицы = ?(ЗначениеЗаполнено(ДляСвойстваТаблицы), ДляСвойстваВнизТаблицы, ИмяФиктивногоСвойства());
КонецПроцедуры

//.
// Параметры:
//    МенеджерВременныхТаблиц - см. НовыйМенеджерВременныхТаблиц - 
//    ВыражениеЗапроса - Строка	   -   
//    Позиция0ВМетодеОт - Число, Неопределено  -   
//    Позиция0ВМетодеДо - Число(10,0)  -   
//    ДляСвойстваПуть - Строка  -  
Процедура СобратьОперацииМенеджераВременныхТаблиц(Знач МенеджерВременныхТаблиц, Знач ВыражениеЗапроса, Знач Позиция0ВМетодеОт, Знач Позиция0ВМетодеДо, Знач ДляСвойстваПуть,
	Знач ТаблицаТиповМенеджера = Неопределено) Экспорт
	
	ЛиНовыйКэшВыражений = ирОбщий.СтрНачинаетсяСЛкс(ДляСвойстваПуть, "МенеджерВременныхТаблиц");
	РекурсивныйПуть = мРекурсивныйПуть;
	ТаблицаТиповМенеджера = ВычислитьТипЗначенияВыражения(ВыражениеЗапроса + ".МенеджерВременныхТаблиц",,,,,, ЛиНовыйКэшВыражений,, ТаблицаТиповМенеджера, Истина, Позиция0ВМетодеОт,
			Позиция0ВМетодеДо, "МенеджерВременныхТаблиц"); 
	мРекурсивныйПуть = РекурсивныйПуть;
	ЛучшийТип = ЛучшийТипИзТаблицыТипов(ТаблицаТиповМенеджера, 2);
	Если ЛучшийТип <> Неопределено Тогда
		Если ТипЗнч(ЛучшийТип.Метаданные) = Тип("Структура") Тогда 
			НовыйМенеджерВременныхТаблиц = ЛучшийТип.Метаданные; // см. НовыйМенеджерВременныхТаблиц()
			Если НовыйМенеджерВременныхТаблиц <> МенеджерВременныхТаблиц Тогда
				МенеджерВременныхТаблиц.Активен = Истина;
				ирОбщий.ДополнитьМассивЛкс(МенеджерВременныхТаблиц.ПакетыЗапросов, НовыйМенеджерВременныхТаблиц.ПакетыЗапросов);
			КонецЕсли;
		КонецЕсли;
	КонецЕсли;
КонецПроцедуры

// Опасная защита от повторных вычислений менеджера
// Параметры:
//    МенеджерВременныхТаблиц - Структура - 
// Возвращаемое значение:
//    Булево - 
Функция ЛиМенеджерВременныхТаблицОбработалМетод(Знач МенеджерВременныхТаблиц) Экспорт
	ЛиМенеджерГотов = Ложь;
	Если ТипЗнч(МенеджерВременныхТаблиц) = Тип("Структура") Тогда
		Для Каждого ПакетЗапросов Из МенеджерВременныхТаблиц.ПакетыЗапросов Цикл
			Если Истина
				И ПакетЗапросов.КоординатыТекста.Модуль = мМодульМетаданных     
				И ПакетЗапросов.КоординатыТекста.Метод = мМетодМодуля 
			Тогда
				ЛиМенеджерГотов = Истина;
				Прервать;
			КонецЕсли;
		КонецЦикла;
	КонецЕсли;
	Возврат ЛиМенеджерГотов;
КонецФункции

//.
// Параметры:
//    ТаблицаТиповКэш - ТаблицаЗначений - 
//    ДляСвойства - Строка - 
// Возвращаемое значение:
//     - 
Функция ЛиТаблицаТиповКэшНеГотова(Знач ТаблицаТиповКэш, Знач ДляСвойства) Экспорт
	Результат = ТаблицаТиповКэш = Неопределено;
	Если Истина
		И Не Результат 
		И ЗначениеЗаполнено(ДляСвойства)
		И ТаблицаТиповКэш.Количество() > 0
	Тогда
		ДляСвойства = ирОбщий.ПервыйФрагментЛкс(ДляСвойства);
		Если Истина 
			И ДляСвойства <> ИмяФиктивногоСвойства()
			И ДляСвойства <> "0"
		Тогда
			МаксПроверок = 10;
			Счетчик = 0;
			Для Каждого СтрокаТипа Из ТаблицаТиповКэш Цикл
				Если ТипЗнч(СтрокаТипа.Метаданные) = Тип("Структура") Тогда 
					ТаблицаТиповСвойства = Неопределено;
					СтрокаТипа.Метаданные.Свойство(ДляСвойства, ТаблицаТиповСвойства);
					Результат = ТаблицаТиповСвойства = Неопределено; // При наличии свойство со значением Неопределено возможны повторные расчеты
					Прервать;
				Иначе
					Счетчик = Счетчик + 1;
					Если Счетчик = МаксПроверок Тогда 
						Прервать;
					КонецЕсли;
				КонецЕсли;
			КонецЦикла;
		КонецЕсли;
	КонецЕсли;
	Возврат Результат;
КонецФункции

//.
// Возвращаемое значение:
//    Структура - 
Функция НовыйМенеджерВременныхТаблиц(Знач Активен = Ложь) Экспорт
	МенеджерВременныхТаблиц = Новый Структура("Тип,ПакетыЗапросов,Активен");
	МенеджерВременныхТаблиц.Тип = Тип("МенеджерВременныхТаблиц");
	МенеджерВременныхТаблиц.ПакетыЗапросов = Новый Массив; // Массив из НовыйПакетЗапросов()
	МенеджерВременныхТаблиц.Активен = Активен;
	Возврат МенеджерВременныхТаблиц;
КонецФункции

//.
// Параметры:
//    Выражение - Строка(0) - 
//    ДопКлючКэша - Строка, Неопределено - 
Функция ИнициироватьРекурсивныйПуть(Знач Выражение = "", Знач ДопКлючКэша = "") Экспорт
	РекурсивныйПуть = Новый Структура;
	РекурсивныйПуть.Вставить("ДобавлятьКлючевыеПараметры", Ложь);
	РекурсивныйПуть.Вставить("ДопКлючКэша", ДопКлючКэша);
	РекурсивныйПуть.Вставить("ВходящиеВызовы", Новый Соответствие);
	РекурсивныйПуть.Вставить("СчетчикиВызовов", Новый Соответствие);
	РекурсивныйПуть.Вставить("ТипыВыраженийЗапроса", Новый Соответствие);
	РекурсивныйПуть.Вставить("ПозицииЗапроса", Новый Массив); // TODO избавиться, т.к. теперь это обеспечивает ТипыВыраженийЗапроса. Для языка запросов защита от циклической рекурсии
	РекурсивныйПуть.Вставить("ВложенныеВыражения");
	РекурсивныйПуть.Вставить("ПозицияПоследнегоВыраженияВМетоде", Неопределено);
	Если Выражение = ИмяПеременнойВозвращаемогоЗначения() И мМетодМодуля <> Неопределено Тогда
		ВычислениеРезультатаМетода = мМетодМодуля.Имя;
	Иначе 
		ВычислениеРезультатаМетода = Неопределено;
	КонецЕсли;
	РекурсивныйПуть.Вставить("ВычислениеРезультатаМетода", ВычислениеРезультатаМетода);
	мРекурсивныйПуть = РекурсивныйПуть;
	Возврат РекурсивныйПуть;
КонецФункции

//.
// Параметры:
//    Выражение - Строка(0) - 
//    Позиция0ВМетодеДо - Число - 
// Возвращаемое значение:
//    Структура - 
Функция НовыеКоординатыВыражения(Знач Выражение, Знач Позиция0ВМетодеДо) Экспорт 
	СтруктураСтрокиМодуля = Новый Структура;
	СтруктураСтрокиМодуля.Вставить("Тип", "КоординатыВыражения");
	СтруктураСтрокиМодуля.Вставить("Метод", мМетодМодуля);
	СтруктураСтрокиМодуля.Вставить("Модуль", мМодульМетаданных);
	СтруктураСтрокиМодуля.Вставить("Позиция0ВБлоке", Позиция0ВМетодеДо);
	СтруктураСтрокиМодуля.Вставить("ДлинаТекста", СтрДлина(Выражение));
	СтруктураСтрокиМодуля.Вставить("Выражение", Выражение);
	Возврат СтруктураСтрокиМодуля;
КонецФункции

//.
// Параметры:
//    ТаблицаТипов - ТаблицаЗначений - 
//    СтруктураТипа - Структура - 
Функция ДобавитьЕдинственныйТип(Знач ТаблицаТипов, СтруктураТипа, Знач ЗапретитьЗаменуТипа = Ложь) Экспорт
	Если ТаблицаТипов.Количество() > 0 Тогда 
		НайденныйТип = Новый Массив;
		Если СтруктураТипа.ИмяОбщегоТипа = "COMОбъект" Тогда 
			Для Каждого СтрокаТипа Из ТаблицаТипов Цикл
				Если Найти(СтрокаТипа.ИмяОбщегоТипа, "{") > 0 Тогда
					НайденныйТип.Добавить(СтрокаТипа);
				КонецЕсли;
			КонецЦикла;
		ИначеЕсли ирОбщий.СтрНачинаетсяСЛкс(СтруктураТипа.ИмяОбщегоТипа, "Форм") Тогда
			Для Каждого СтрокаТипа Из ТаблицаТипов Цикл
				Если ирОбщий.СтрНачинаетсяСЛкс(СтрокаТипа.ИмяОбщегоТипа, "РасширениеФорм", Истина ) > 0 Тогда
					НайденныйТип.Добавить(СтрокаТипа);
				КонецЕсли;
			КонецЦикла;
		ИначеЕсли СтруктураТипа.ИмяОбщегоТипа = "ПолеФормы" Тогда 
			Для Каждого СтрокаТипа Из ТаблицаТипов Цикл 
				Если ирОбщий.СтрНачинаетсяСЛкс(СтрокаТипа.ИмяОбщегоТипа, "РасширениеПоляФормы", Истина ) > 0 Тогда
					НайденныйТип.Добавить(СтрокаТипа);
				КонецЕсли;
			КонецЦикла;
		ИначеЕсли СтруктураТипа.ИмяОбщегоТипа = "ПолеВвода" Тогда  
			Для Каждого СтрокаТипа Из ТаблицаТипов Цикл
				Если ирОбщий.СтрНачинаетсяСЛкс(СтрокаТипа.ИмяОбщегоТипа, "РасширениеПоляВвода", Истина ) > 0 Тогда
					НайденныйТип.Добавить(СтрокаТипа);
				КонецЕсли;
			КонецЦикла;
		ИначеЕсли СтруктураТипа.ИмяОбщегоТипа = "ТаблицаФормы" Тогда
			Для Каждого СтрокаТипа Из ТаблицаТипов Цикл
				Если ирОбщий.СтрНачинаетсяСЛкс(СтрокаТипа.ИмяОбщегоТипа, "РасширениеТаблицыФормы", Истина ) > 0 Тогда
					НайденныйТип.Добавить(СтрокаТипа);
				КонецЕсли;
			КонецЦикла;
		ИначеЕсли СтруктураТипа.ИмяОбщегоТипа = "ТабличноеПоле" Тогда
			Для Каждого СтрокаТипа Из ТаблицаТипов Цикл
				Если ирОбщий.СтрНачинаетсяСЛкс(СтрокаТипа.ИмяОбщегоТипа, "РасширениеТабличногоПоля", Истина ) > 0 Тогда
					НайденныйТип.Добавить(СтрокаТипа);
				КонецЕсли;
			КонецЦикла;
		ИначеЕсли СтруктураТипа.ИмяОбщегоТипа = "ОбъектМетаданных" Тогда
			Для Каждого СтрокаТипа Из ТаблицаТипов Цикл
				Если Истина
					И СтрокаТипа.ИмяОбщегоТипа <> "ОбъектМетаданныхКонфигурация"
					И ирОбщий.СтрНачинаетсяСЛкс(СтрокаТипа.ИмяОбщегоТипа, "ОбъектМетаданных", Истина) > 0 
				Тогда
					НайденныйТип.Добавить(СтрокаТипа);
					//Прервать;
				КонецЕсли;
			КонецЦикла;
		КонецЕсли;
		Если НайденныйТип.Количество() = 0 Тогда
			ОтборТипов = Новый Структура("ИмяОбщегоТипа", СтруктураТипа.ИмяОбщегоТипа);
			Если Истина
				И СтруктураТипа.Метаданные <> Неопределено 
				И ТипЗнч(СтруктураТипа.Метаданные) <> Тип("ОбъектМетаданныхКонфигурация")
			Тогда
				ОтборТипов.Вставить("Метаданные", СтруктураТипа.Метаданные);
			КонецЕсли;
			НайденныйТип = ТаблицаТипов.НайтиСтроки(ОтборТипов);
		КонецЕсли;
		Если НайденныйТип.Количество() > 0 Тогда
			// Сужаем тип, сохраняя квалификаторы и описание слова
			НайденныйТип = НайденныйТип[0];
			Для Индекс = 1 - ТаблицаТипов.Количество() По 0 Цикл // Обратный обход
				СтрокаТипа = ТаблицаТипов[-Индекс];
				Если СтрокаТипа <> НайденныйТип Тогда
					ТаблицаТипов.Удалить(СтрокаТипа);
				КонецЕсли;
			КонецЦикла;
		Иначе
			Если ЗапретитьЗаменуТипа Тогда
				//СтруктураТипа = Неопределено;
				//ТаблицаТипов.Очистить();
				Возврат Ложь;
			Иначе
				ТаблицаТипов.Очистить();
			КонецЕсли;
		КонецЕсли;
	КонецЕсли;
	Если ТаблицаТипов.Количество() = 0 Тогда
		Если СтруктураТипа.ИмяОбщегоТипа = "ОбъектМетаданных" Тогда
			СтруктураТипа.ИмяОбщегоТипа = мПлатформа.ИмяОбщегоТипаОбъектаМетаданных(); 
		КонецЕсли;
		мПлатформа.ДобавитьВТаблицуТипов(ТаблицаТипов, СтруктураТипа);
	КонецЕсли;
	Если Истина
		И ТипЗнч(СтруктураТипа) = Тип("СтрокаТаблицыЗначений") 
		И СтруктураТипа.Владелец().Колонки.Метаданные.Заголовок <> ""
	Тогда
		ТаблицаТипов.Колонки.Метаданные.Заголовок = ЗаголовокФлагОбрезкиГлубины();
	КонецЕсли;
	Возврат Истина;
КонецФункции

//.
// Параметры:
//    ТекстДляПоискаОпределения - ПолеТекстовогоДокумента, ПолеФормы, Строка - 
//    ГлубинаНеобязательной - Число - 
// Возвращаемое значение:
//    Булево - 
Функция _МожноПрименитьПрисвоениеТипаИзЕсли(Знач ТекстПроверкиВетвлений, Знач ГлубинаНеобязательной)
	Если ГлубинаНеобязательной <> Неопределено Тогда
		Возврат Ложь;
	КонецЕсли;
	ПозицияЕсли = Найти(ТекстПроверкиВетвлений, "Если ");
	Если ПозицияЕсли = 0 Тогда
		ТекстПоискаТогда = ТекстПроверкиВетвлений;
	Иначе 
		ТекстПоискаТогда = Лев(ТекстПроверкиВетвлений, ПозицияЕсли);
	КонецЕсли;
	ПозицияТогда = Найти(ТекстПоискаТогда, "Тогда");
	ПрименитьТип = Ложь
		Или ПозицияТогда > 0 
		Или (Истина
			// Чтобы внутри условия применялось https://www.hostedredmine.com/issues/978910
			И Найти(ТекстПоискаТогда, "ИЛИ ") = 0 
			И Найти(ТекстПоискаТогда, "Или ") = 0);
	Возврат ПрименитьТип;
КонецФункции

Функция МожноПрименитьПрисвоениеТипаИзЕсли(Знач ТекстДляПоискаОпределения, Знач Позиция0ВМетодеДо, Знач ПоследнееВхождение, Знач ПозицияВхождения0, Знач ГлубинаНеобязательной)
	Если ГлубинаНеобязательной <> Неопределено Тогда
		Возврат Ложь;
	КонецЕсли;
	ПрименитьТип = Ложь; 
	НачальнаяПозицияЕсли = ПозицияВхождения0 + ПоследнееВхождение.Length;
	ТекстПоискаЕсли = Сред(ТекстДляПоискаОпределения, НачальнаяПозицияЕсли + 1, Позиция0ВМетодеДо - НачальнаяПозицияЕсли);
	ПозицияЕсли = Найти(ТекстПоискаЕсли, "Если ");
	Если ПозицияЕсли = 0 Тогда
		ТекстПоискаТогда = ТекстПоискаЕсли;
	Иначе 
		ТекстПоискаТогда = Лев(ТекстПоискаЕсли, ПозицияЕсли);
	КонецЕсли;
	ПозицияТогда = Найти(ТекстПоискаТогда, "Тогда");
	ПрименитьТип = Ложь
		Или ПозицияТогда > 0 
		Или (Истина
			// Чтобы внутри условия применялось https://www.hostedredmine.com/issues/978910
			И Найти(ТекстПоискаТогда, "ИЛИ ") = 0 
			И Найти(ТекстПоискаТогда, "Или ") = 0);
	Возврат ПрименитьТип;
КонецФункции

Функция ЛиВхождениеВЗапрешенномДиапазоне(Знач ПоследнееВхождение, Знач Позиция0ВМетодеОт = 0, Знач Позиция0ВМетодеДо = 0, Знач ЛиКорневойВызов = Ложь) Экспорт 
	Если Позиция0ВМетодеДо > 0 Тогда
		КонецВхождения = ПоследнееВхождение.FirstIndex + ПоследнееВхождение.Length;
	КонецЕсли;
	Результат = Ложь
		Или Позиция0ВМетодеОт > 0 И ПоследнееВхождение.FirstIndex < Позиция0ВМетодеОт
		Или (Истина
			И Позиция0ВМетодеДо > 0 
			И (Ложь
				Или КонецВхождения > Позиция0ВМетодеДо
				Или (Истина
					И ЛиКорневойВызов 
					И Прав(ПоследнееВхождение.Value, 1) = "("
					И Найти(Сред(мТекстБлока, КонецВхождения + 1, Позиция0ВМетодеДо - КонецВхождения), ";") = 0)
				));
	Возврат Результат;
КонецФункции

Функция ДиапазонТекстаДляПоиска(Знач ТекстДляПоискаОпределения = "", Знач ПозицияВМетодеОт = 0, Знач ПозицияВМетодеДо = 0)
	Длина = ПозицияВМетодеДо - ПозицияВМетодеОт;
	Если Длина = 0 Тогда
		Длина = 1000000;
	КонецЕсли;
	ТекстДляПоискаОпределения = Сред(ТекстДляПоискаОпределения, ПозицияВМетодеОт, Длина);
	Возврат ТекстДляПоискаОпределения;
КонецФункции

// .
// Параметры:
//  ШаблонПоиска				 - Строка	 - 
//  ГлобальныйПоискВМодуле		 - Булево	 - 
//  выхТекстДляПоискаОпределения - Строка - только выход
// Возвращаемое значение:
//  Массив из ОбработкаОбъект.ирОболочкаРегВхождение
Функция НайтиВхожденияРегВыраженияКэш(Знач ШаблонПоиска, Знач ГлобальныйПоискВМодуле = Ложь, выхТекстДляПоискаОпределения = "", Знач КлючКэшаПоиска = "", КэшПоиска = Неопределено)
	Вхождения = Неопределено; 
	Если ГлобальныйПоискВМодуле Тогда
		выхТекстДляПоискаОпределения = мОригинальныйТекст;
	Иначе 
		выхТекстДляПоискаОпределения = мТекстБлока;
	КонецЕсли; 
	Если Не ЗначениеЗаполнено(КлючКэшаПоиска) Тогда
		КлючКэшаПоиска = ШаблонПоиска;
	КонецЕсли;
	КлючКэшаПоиска = НРег(Лев(КлючКэшаПоиска, 300));
	Если Истина
		И мМетодМодуля <> Неопределено 
		И Не ГлобальныйПоискВМодуле 
	Тогда 
		КэшПоиска = мМетодМодуля.КэшПоиска;
		Если КэшПоиска = Неопределено Тогда 
			КэшПоиска = Новый Соответствие;
			мМетодМодуля.КэшПоиска = КэшПоиска;
		КонецЕсли; 
		Вхождения = КэшПоиска[КлючКэшаПоиска];  
	Иначе
		КэшПоиска = мМодульМетаданных.КэшПоискаПрограммы;
	КонецЕсли;
	Если Вхождения = Неопределено Тогда  
		мРегВыражение.Global = Истина;
		мРегВыражение.Pattern = ШаблонПоиска;
		Вхождения = мРегВыражение.НайтиВхождения(выхТекстДляПоискаОпределения);
		КэшПоиска[КлючКэшаПоиска] = Вхождения;
	КонецЕсли;
	Возврат Вхождения;
КонецФункции

Функция ЗагрузитьМетодМодуляПоПозицииИРазобратьКонтекст(Знач Позиция0, Знач ГлобальныйПоискВМодуле = Истина, Знач ОписаниеПозиции = Неопределено) Экспорт 
	
	Если Не ГлобальныйПоискВМодуле Тогда 
		// В рамках текущего метода
		НачальнаяПозицияБлока = 0;
	Иначе
		Если Истина
			И ОписаниеПозиции <> Неопределено 
			И ЗначениеЗаполнено(ОписаниеПозиции.Метод) 
		Тогда
			ЗагрузитьМетодМодуля(мМодульМетаданных.Методы.Найти(ОписаниеПозиции.Метод, "НИмя")); 
		Иначе
			Позиция1 = Позиция0 + 1;
			Если ЗагрузитьМетодМодуляПоПозиции(Позиция1) Тогда
				// Для ускорения отключил
				//СлужебноеПолеТекстаДолгое.УстановитьГраницыВыделения(Позиция1, Позиция1);
				//НачальнаяСтрока = 0;
				//НачальнаяКолонка = 0;
				//СлужебноеПолеТекстаДолгое.ПолучитьГраницыВыделения(НачальнаяСтрока, НачальнаяКолонка,,);
				//КончитьОбработкуКоманды();
				//РазобратьТекущийКонтекст(,,, НачальнаяСтрока, НачальнаяКолонка,, Позиция1);
			КонецЕсли;
			Если ОписаниеПозиции <> Неопределено Тогда
				ОписаниеПозиции.Метод = НРег(ИмяТекущегоМетода());
			КонецЕсли;
		КонецЕсли;
		НачальнаяПозицияБлока = мПозицияТекстаДляПоискаОпределения;
	КонецЕсли;
	Возврат НачальнаяПозицияБлока;

КонецФункции

Функция ЗагрузитьМетодМодуляПоВхождениюИРазобратьКонтекст(Знач ГлобальныйПоискВМодуле = Ложь, Знач Вхождение, Знач ТекстДляПоискаОпределения = "")
	НачальнаяПозицияБлока = ЗагрузитьМетодМодуляПоПозицииИРазобратьКонтекст(Вхождение.FirstIndex, ГлобальныйПоискВМодуле);
	ТекстДоВхождения = Сред(ТекстДляПоискаОпределения, НачальнаяПозицияБлока, Вхождение.FirstIndex - 1 - НачальнаяПозицияБлока); // МультиМетка8294218
	Возврат ТекстДоВхождения;
КонецФункции

//.
// Параметры:
//    Выражение - Строка - 
//    Структура - Структура, ПостроительЗапроса - 
//    ТекстДляЗаполненияМетаданных - Строка - 
//    ТекстДляПоискаОпределения - Строка - 
//    ПредшествующийТекст - Строка - 
Функция СобратьСвойстваСтруктуры(Знач Выражение, Знач Структура = Неопределено, Знач ГлобальныйПоискВМодуле = Ложь, Знач ТолькоПрисвоение = Ложь, Знач Позиция0ВМетодеОт = 0, Знач Позиция0ВМетодеДо = 0,
	Знач ДляСвойства = "", Знач ДляСвойстваВниз = "", выхОбрезано = Ложь, Знач ШаблонВыражения = "", Знач ЛиПараметрыФормы = Ложь)
	
	Если Истина
		И ГлобальныйПоискВМодуле
		И ТипЗнч(Структура) = Тип("Структура")
		И Структура.Количество() > 0
	Тогда
		// Для сокращения редко полезных затратных поисков по большим модулям
		ГлобальныйПоискВМодуле = Ложь; // Грязно. Подразумеваем что обычно остаемся в том же методе, где структура родилась.
	КонецЕсли;
	Если ТипЗнч(Структура) = Тип("Структура") Тогда
		Структура = ирОбщий.СкопироватьКоллекциюЛкс(Структура); // Могла быть взята из кэша
	КонецЕсли;
	ТаблицаТиповВсехЭлементов = Неопределено;
	Если ТипЗнч(Структура) = Тип("ТаблицаЗначений") Тогда
		Если ТолькоПрисвоение Тогда
			Возврат Структура;
		КонецЕсли;
		ТаблицаТиповВсехЭлементов = Структура;
	КонецЕсли;
	Если Истина
		//И Не НашлиСоздание
		И ТипЗнч(Структура) <> Тип("Структура") 
		И ТипЗнч(Структура) <> Тип("ФиксированнаяСтруктура") 
	Тогда
		Если ТипЗнч(Структура) = Тип("ПостроительЗапроса") Тогда
			Структура = мПлатформа.ПараметрыИзТекстаЗапроса(Структура.Текст, Истина);
		Иначе
			Структура = Новый Структура;
		КонецЕсли;
	КонецЕсли;
	Если ТолькоПрисвоение Тогда
		Возврат Структура;
	КонецЕсли;
	Если Не ЗначениеЗаполнено(ШаблонВыражения) Тогда
		ШаблонВыражения = ирОбщий.ПодготовитьТекстДляРегВыраженияЛкс(Выражение);
	КонецЕсли;
	ЛиСобиратьИменованные = Ложь
		Или ЗначениеЗаполнено(ДляСвойства) И ДляСвойства <> "0"
		Или ДляСвойстваВниз = ИмяФиктивногоСвойства();
	МинДетальность = 4;
	ШаблонПоиска = шПредИмяПрямое + ШаблонВыражения + "\s*\.\s*(Вставить|Свойство)\s*\(\s*(" + шЛитералПрограммы + "|" + шИмяСТочками + ")(?:\s*,\s*((?:" + шЛитералПрограммы + "|" + шСкобкиЛенивые + "|[^\)""])*))?" 
		+ "(?:\)\s*)?" + шНазначениеТипаПриПрисвоении;
	Вхождения = НайтиВхожденияРегВыраженияКэш(ШаблонПоиска, ГлобальныйПоискВМодуле,, "ВставкаВСтруктуру;" + Выражение);
	ПозицииВыражений = Новый Структура;
	Для Каждого Вхождение Из Вхождения Цикл
		Если ЛиВхождениеВЗапрешенномДиапазоне(Вхождение, Позиция0ВМетодеОт, Позиция0ВМетодеДо) Тогда
			Продолжить;
		КонецЕсли;
		ТипВставки = Вхождение.SubMatches(0);
		ВыражениеИмени = Вхождение.SubMatches(1);
		Если Лев(ВыражениеИмени, 1) = """" Тогда
			ТекстовоеЗначение = ирОбщий.ТекстИзВстроенногоЯзыкаЛкс(ВыражениеИмени);
		Иначе
			ЗагрузитьМетодМодуляПоВхождениюИРазобратьКонтекст(ГлобальныйПоискВМодуле, Вхождение);
			ТекстовоеЗначение = ВычислитьЗначениеВыражения(ВыражениеИмени,,, Вхождение.FirstIndex);
		КонецЕсли;
		ЛиИмяПеременной = ирОбщий.ЛиИмяПеременнойЛкс(ТекстовоеЗначение);
		Если ЛиИмяПеременной И Не ЛиСобиратьИменованные Тогда
			выхОбрезано = Истина;
			ЛиИмяПеременной = Ложь;
		КонецЕсли;
		Если ТипВставки = "Свойство" Тогда
			Если ЛиИмяПеременной И Не Структура.Свойство(ТекстовоеЗначение) Тогда
				ЗначениеСвойства = Неопределено;
				Если ЛиПараметрыФормы Тогда
					ЗначениеСвойства = Новый ОписаниеТипов;
				КонецЕсли;
				Структура.Вставить(ТекстовоеЗначение, ЗначениеСвойства);
			КонецЕсли;
			Продолжить;
		КонецЕсли;
		Если ЛиИмяПеременной Тогда
			Если Истина
				И ЗначениеЗаполнено(ДляСвойства) 
				И Не ирОбщий.СтрокиРавныЛкс(ДляСвойства, ТекстовоеЗначение) 
				//И Не мПлатформа.мРежимПроверкиМодуля
			Тогда
				выхОбрезано = Истина;
				Продолжить;
			КонецЕсли;
			ТаблицаТиповЗначения = ВычислитьТипыЭлементаСтруктурыПоВхождению(Вхождение, ГлобальныйПоискВМодуле, ДляСвойстваВниз);
			Структура.Вставить(ТекстовоеЗначение, ТаблицаТиповЗначения);
			ПозицииВыражений.Вставить(ТекстовоеЗначение, Вхождение.FirstIndex);
		ИначеЕсли Истина
			И Структура.Количество() = 0 
			И Найти(Вхождение.Value, ",") > 0
			И (Ложь
				Или ТаблицаТиповВсехЭлементов = Неопределено 
				Или ДляСвойства = "0" И Не мПлатформа.ЛиДетальностьТиповДостаточна(ТаблицаТиповВсехЭлементов, 5)
				)
		Тогда
			ТаблицаТиповЗначения = ВычислитьТипыЭлементаСтруктурыПоВхождению(Вхождение, ГлобальныйПоискВМодуле, ДляСвойстваВниз);
			Если мПлатформа.ЛиДетальностьТиповДостаточна(ТаблицаТиповЗначения) Тогда
				ТаблицаТиповВсехЭлементов = мПлатформа.ДобавитьВТаблицуТипов(ТаблицаТиповВсехЭлементов, ТаблицаТиповЗначения);
			КонецЕсли;
		КонецЕсли;
	КонецЦикла;
	Если Истина
		И ЛиСобиратьИменованные
		И Не ГлобальныйПоискВМодуле // Для сокращения редко полезных затратных вычислений
		И Структура.Количество() > 0    
	Тогда 
		ШаблонПоиска = шПредИнструкция + "ЗаполнитьЗначенияСвойств\s*\(\s*" + ШаблонВыражения + "\s*,\s*(" + шПростоеВыражениеПрограммы + ")(?=\s*[,\)])";
		Вхождения = НайтиВхожденияРегВыраженияКэш(ШаблонПоиска,,, "ЗаполнитьЗначенияСвойствСтруктура;" + Выражение); 
		БазовоеРасширениеКонфигурации = БазовоеРасширениеКонфигурации();
		Для Каждого Вхождение Из Вхождения Цикл
			Если ЛиВхождениеВЗапрешенномДиапазоне(Вхождение, Позиция0ВМетодеОт, Позиция0ВМетодеДо) Тогда
				Продолжить;
			КонецЕсли;
			ВыражениеЗначения = Вхождение.SubMatches(0);
			ТаблицаТиповЗначения = ВычислитьТипЗначенияВыражения(ВыражениеЗначения,,,,,, Ложь,,,,, Вхождение.FirstIndex,, ДляСвойства);
			Если ТаблицаТиповЗначения.Количество() = 0 Тогда
				Продолжить;
			КонецЕсли;
			ТаблицаСловИсточника = мПлатформа.ТаблицаСловИзСтруктурыТипа(ТаблицаТиповЗначения[0],,,,,, "Свойство",,,,,,,, БазовоеРасширениеКонфигурации);
			Для Каждого СтрокаСлова Из ТаблицаСловИсточника Цикл
				Если Структура.Свойство(СтрокаСлова.Слово) Тогда
					Структура[СтрокаСлова.Слово] = СтрокаСлова.ТаблицаТипов;
					//Структура[СтрокаСлова.Слово] = мПлатформа.ДобавитьВТаблицуТипов(, СтрокаСлова.ТаблицаТипов,,, Истина, Ложь); // Вызывает аварийное завершение (возможно позднее) на проверке модуля ирПлатформа
				КонецЕсли;
			КонецЦикла;
		КонецЦикла;
		
		// Уточняем типы значений элементов через присвоения им
		ШаблонПоиска = шПредИмяПрямое + ШаблонВыражения + "\.(" + шИмя + ")(?![\(\d" + шБуква + "])(\s*=[^\n]*//)?";
		Вхождения = НайтиВхожденияРегВыраженияКэш(ШаблонПоиска,,, "ОбращениеКЭлементуСтруктуры;" + Выражение); 
		Если Вхождения.Количество() > 0 Тогда
			СвойстваЧерезТочкуИзТекста = Новый Структура;
			ЗначениеСвойства = Неопределено;
			Для Каждого Вхождение Из Вхождения Цикл
				ИмяСвойства = Вхождение.SubMatches(0);
				ЕстьУказаниеТипа = Вхождение.SubMatches(1) <> Неопределено;
				Если СвойстваЧерезТочкуИзТекста.Свойство(ИмяСвойства, ЗначениеСвойства) Тогда
					ЕстьУказаниеТипа = ЕстьУказаниеТипа Или ЗначениеСвойства;
				КонецЕсли;
				СвойстваЧерезТочкуИзТекста.Вставить(ИмяСвойства, ЕстьУказаниеТипа);
			КонецЦикла;
			ЗначениеСвойства = Неопределено;
			Для Каждого КлючИЗначение Из СвойстваЧерезТочкуИзТекста Цикл
				Если Не Структура.Свойство(КлючИЗначение.Ключ, ЗначениеСвойства) Тогда
					Продолжить;
				КонецЕсли; 
				Если Истина
					И ЗначениеСвойства <> Неопределено 
					И ТипЗнч(ЗначениеСвойства) <> Тип("ТаблицаЗначений")
				Тогда
					Продолжить;
				КонецЕсли;
				Если Истина
					И ЗначениеЗаполнено(ДляСвойства) 
					И Не ирОбщий.СтрокиРавныЛкс(ДляСвойства, КлючИЗначение.Ключ) 
					//И Не мПлатформа.мРежимПроверкиМодуля
				Тогда
					Продолжить;
				КонецЕсли;
				ВыражениеЗначения = Выражение + "." + КлючИЗначение.Ключ;
				ПозицияВМетодеОт = 0;
				ПозицииВыражений.Свойство(КлючИЗначение.Ключ, ПозицияВМетодеОт);
				Если ПозицияВМетодеОт = Неопределено Тогда
					ПозицияВМетодеОт = 0;
				КонецЕсли;
				ТаблицаТиповСоздания = Структура[КлючИЗначение.Ключ]; // см. ОбработкаОбъект.ирПлатформа.НоваяТаблицаТипов()
				Если Истина
					И ТаблицаТиповСоздания <> Неопределено
					И мПлатформа.ЛиДетальностьТиповДостаточна(ТаблицаТиповСоздания, 4) 
					И Не КлючИЗначение.Значение // нет указания типа        
				Тогда
					// Нужно для ускорения вычисления мПлатформа.СброситьКэшТиповВыраженийМодуля()
					// TODO Может приводить к нестабильности вложенных в это свойство свойств. При первом вычислении берем первое определение, а при последующих - последнее
					// TODO сделать копию и затем ее установить в элемент структуры
					СобратьДинамическиеСвойстваОбъекта(ВыражениеЗначения, ТаблицаТиповСоздания,,,, ГлобальныйПоискВМодуле, Позиция0ВМетодеОт, Позиция0ВМетодеДо, ДляСвойстваВниз);
				Иначе
					ТаблицаТиповЗначения = ТаблицаТиповСоздания;
					Если ТаблицаТиповЗначения = Неопределено Тогда
						ТаблицаТиповЗначения = мПлатформа.НоваяТаблицаТипов();
					Иначе 
						ТаблицаТиповЗначения = ТаблицаТиповСоздания.Скопировать();
					КонецЕсли;
					ТаблицаТиповЗначения = ВычислитьТипЗначенияВыражения(ВыражениеЗначения,,,,,, Ложь, ГлобальныйПоискВМодуле, ТаблицаТиповЗначения,, ПозицияВМетодеОт, Позиция0ВМетодеДо,, ДляСвойстваВниз);
					Если ТаблицаТиповЗначения.Количество() = 0 Тогда 
						//Если ТаблицаТиповСоздания = Неопределено Тогда
						//	// Пустые таблицы запрещены, т.к. проверка пустоты участвует в разделении таблицы-значения и таблицы типов значения
						//Иначе 
						//	СобратьДинамическиеСвойстваОбъекта(ВыражениеЗначения, ТаблицаТиповСоздания,,,, ГлобальныйПоискВМодуле, Позиция0ВМетодеОт, Позиция0ВМетодеДо);
						//КонецЕсли;
					Иначе 
						Если ТаблицаТиповСоздания = Неопределено Тогда                                                                              
							Структура[КлючИЗначение.Ключ] = ТаблицаТиповЗначения;
						ИначеЕсли ТаблицаТиповСоздания <> ТаблицаТиповЗначения Тогда
							мПлатформа.ДобавитьВТаблицуТипов(ТаблицаТиповСоздания, ТаблицаТиповЗначения);
						КонецЕсли;
					КонецЕсли;
				КонецЕсли;
			КонецЦикла;
		КонецЕсли;
	КонецЕсли;
	Для Каждого КлючИЗначение Из Структура Цикл
		Если Истина
			И ТипЗнч(КлючИЗначение.Значение) = Тип("ТаблицаЗначений")
			И КлючИЗначение.Значение.Колонки.Метаданные.Заголовок <> "" 
		Тогда
			выхОбрезано = Истина;
			Прервать;
		КонецЕсли;
	КонецЦикла;
	Если Структура.Количество() = 0 Тогда
		Если ТаблицаТиповВсехЭлементов <> Неопределено Тогда
			Структура = ТаблицаТиповВсехЭлементов.Скопировать();
			Если ТаблицаТиповВсехЭлементов.Колонки.Метаданные.Заголовок <> "" Тогда
				выхОбрезано = Истина;
			КонецЕсли;
		ИначеЕсли выхОбрезано Тогда
			Структура = Метаданные; // Чтобы проверка выражений не находила ошибку
		КонецЕсли;
	КонецЕсли;
	Возврат Структура;
КонецФункции

//.
// Параметры:
//    Вхождение - ОбработкаОбъект.ирОболочкаРегВхождение - 
//    ГлобальныйПоискВМодуле - Булево - 
//    ДляСвойстваВниз - Строка - 
//    ВыражениеЗначения - ? - 
// Возвращаемое значение:
//    ТаблицаЗначений, Неопределено - 
Функция ВычислитьТипыЭлементаСтруктурыПоВхождению(Знач Вхождение, Знач ГлобальныйПоискВМодуле = Ложь, Знач ДляСвойстваВниз = "") Экспорт
	СтруктураМоноТипа = Неопределено;
	ТаблицаТиповЗначения = Неопределено;
	ЗагрузитьМетодМодуляПоВхождениюИРазобратьКонтекст(ГлобальныйПоискВМодуле, Вхождение);
	ПрисвоенныйТип = Вхождение.SubMatches(4);
	ЛиДетальностьТиповДостаточна = Ложь;
	Если ЗначениеЗаполнено(ПрисвоенныйТип) Тогда
		ТипЗначения = ирОбщий.ПервыйФрагментЛкс(ПрисвоенныйТип, "-");
		Если ЗначениеЗаполнено(ТипЗначения) Тогда
			ТаблицаТиповИзКомментария = ТаблицаТиповИзТекста(ТипЗначения,,, ДляСвойстваВниз);
			Если ТаблицаТиповИзКомментария.Количество() > 0 Тогда
				ТаблицаТиповЗначения = ТаблицаТиповИзКомментария;
				СтруктураМоноТипа = ТаблицаТиповИзКомментария[0];
				ЛиДетальностьТиповДостаточна = мПлатформа.ЛиДетальностьТиповДостаточна(ТаблицаТиповИзКомментария, 4);
			КонецЕсли;
		КонецЕсли;
	КонецЕсли;
	Если Не ЛиДетальностьТиповДостаточна Тогда
		ВыражениеЗначения = Вхождение.SubMatches(2);
		Если ЛиБулевыйЛитерал(ВыражениеЗначения) Тогда
			мПлатформа.ДобавитьВТаблицуТипов(ТаблицаТиповЗначения, мПлатформа.НоваяСтруктураТипа("Булево"));
		ИначеЕсли ВыражениеЗначения <> Неопределено Тогда 
			ТаблицаТиповНовая = ВычислитьТипЗначенияВыражения(ВыражениеЗначения,,,,,, Ложь,,,,, Вхождение.FirstIndex,, ДляСвойстваВниз);
			ТаблицаТиповЗначения = мПлатформа.ДобавитьВТаблицуТипов(ТаблицаТиповЗначения, ТаблицаТиповНовая,,, Истина, Ложь); // Копируем вложенные структуры чтобы не влиять на кэш, из которого могла быть взята таблица
			Если СтруктураМоноТипа <> Неопределено Тогда
				ДобавитьЕдинственныйТип(ТаблицаТиповЗначения, СтруктураМоноТипа);
			КонецЕсли;
			Если ТаблицаТиповЗначения.Количество() = 0 Тогда
				ТаблицаТиповЗначения = Неопределено; // Пустые таблицы запрещены, т.к. проверка пустоты участвует в разделении таблицы-значения и таблицы типов значения
			КонецЕсли;
		КонецЕсли;
	КонецЕсли;
	Возврат ТаблицаТиповЗначения;
КонецФункции

//.
// Параметры:
//    Выражение - Строка - 
//    ПрисвоенныйКонтекст - Строка - 
// Возвращаемое значение:
//    Булево - 
Функция ЛиБесполезноеПрисвоениеПеременной(Знач ПрисвоенноеВыражение) Экспорт
	ПрисвоенноеВыражение = НРег(ПрисвоенноеВыражение);
	Результат = Ложь 
		// TODO возможно повторно сломано https://www.hostedredmine.com/issues/947747
		Или ПустаяСтрока(ПрисвоенноеВыражение)
		Или ПрисвоенноеВыражение = "неопределено"
		Или ПрисвоенноеВыражение = "undefined"
		Или ПрисвоенноеВыражение = "null"
	;
	Возврат Результат;
КонецФункции    

//.
// Параметры:
//    Выражение - Строка - 
//    ПрисвоенныйКонтекст - Строка - 
// Возвращаемое значение:
//    Булево - 
Функция ЛиБулевыйЛитерал(Знач ПрисвоенноеВыражение, выхЗначение = Неопределено)
	ПрисвоенноеВыражение = НРег(ПрисвоенноеВыражение);
	Если Ложь 
		Или ПрисвоенноеВыражение = "истина"
		Или ПрисвоенноеВыражение = "true"
	Тогда 
		выхЗначение = Истина;
		Результат = Истина;
	ИначеЕсли Ложь 
		Или ПрисвоенноеВыражение = "ложь"
		Или ПрисвоенноеВыражение = "false" 
	Тогда 
		выхЗначение = Ложь;
		Результат = Истина;
	Иначе 
		Результат = Ложь;
	КонецЕсли;
	Возврат Результат;
КонецФункции

//.
// Параметры:
//    ШаблонПриемника - Строка - регулярное выражение
// Возвращаемое значение:
//    Строка - 
Функция ШаблонНазначенияТипаВыражению(Знач ШаблонПриемника, Знач ПроверятьТипЧерезЕсли = Ложь) Экспорт
	Результат = "(?:" + мПлатформа.шПустоеНачалоСтроки + "(?:" + шНачалоДок + "\s*)?|;\s*|" 
		+ шПредИмяПрямое + "(Если|ИначеЕсли|И|Или|If|ElseIf|And|Or|Каждого|Each)\s+)"
		+ ШаблонПриемника 
		+ "(" + шПрисвоение + "|" + шОбходКоллекции + ")" + шНазначениеТипаПриПрисвоении;
	Если ПроверятьТипЧерезЕсли Тогда
		шУсловиеСПроверкойТипа = шПредИмяПрямое + "(?:Если|ИначеЕсли|И|Или|If|ElseIf|And|Or)\s+(?:ТипЗнч|TypeOf)\(" + ШаблонПриемника + "\)\s*=\s*((?:Тип|Type)\s*\(\s*""" + шИмяСТочками + """\s*\))";
		//шУсловиеСПроверкойТипа = шПредИмяПрямое + "(?:Если|ИначеЕсли)([\s\S](?![\s\)]Тогда\s))*?(?:ТипЗнч|TypeOf)\(" + ШаблонПриемника + "\)\s*=\s*((?:Тип|Type)\s*\(\s*""" + шИмя + """\s*\))[\s\S]*?(?:[\s\)]Тогда\s)"; // Дольше на 30%
		Результат = Результат + "|" + шУсловиеСПроверкойТипа;
	КонецЕсли;
	Возврат Результат;
КонецФункции

//.
// Параметры:
//    ВыражениеТекста - Строка - 
//    ТекстДляЗаполненияМетаданных - Строка - 
// Возвращаемое значение:
//    Строка - 
Функция ВычислитьЗначениеВыражения(Выражение, Знач ПредшествующийТекст, Знач ГлобальныйПоискВМодуле = Ложь, Знач Позиция0ВМетодеОт = 0, Знач Позиция0ВМетодеДо = 0, выхКоординаты = Неопределено)
	
	Если ПустаяСтрока(Выражение) Тогда
		Возврат "";
	КонецЕсли;                      
	ТаблицаТиповБезРодителя = Неопределено;
	Если Найти(Выражение, "(") = 0 Тогда 
		ТаблицаТиповБезРодителя = мПлатформа.НоваяТаблицаТипов();
	КонецЕсли;
	ТаблицаТипов = ВычислитьТипЗначенияВыражения(Выражение, ПредшествующийТекст, ПредшествующийТекст,,,, Ложь, ГлобальныйПоискВМодуле, ТаблицаТиповБезРодителя, Истина, Позиция0ВМетодеОт, Позиция0ВМетодеДо);
	Если ТаблицаТипов.Количество() > 0 Тогда
		СтруктураТипа = ТаблицаТипов[0];
		ТипЗначения = ТипЗнч(СтруктураТипа.Метаданные); 
		Если Ложь
			Или ТипЗначения = Тип("Число")
			Или ТипЗначения = Тип("Строка")
			Или ТипЗначения = Тип("Булево")
			Или ТипЗначения = Тип("Тип")
			Или ТипЗначения = Тип("ОписаниеТипов")
			Или ТипЗначения = Тип("ТипОбъектаXDTO")
			Или ТипЗначения = Тип("ТабличныйДокумент")
			Или ТипЗначения = Тип("СхемаКомпоновкиДанных")
		Тогда
			Результат = СтруктураТипа.Метаданные;
			Если ТипЗнч(СтруктураТипа.ДержательМетаданных) = Тип("Структура") Тогда
				выхКоординаты = СтруктураТипа.ДержательМетаданных;
			КонецЕсли;
		КонецЕсли;
	КонецЕсли;
	Возврат Результат;
КонецФункции

//.
// Параметры:
//    ПрисвоенныйТип - Строка - 
//    ТекстДоВхождения - Строка - 
// Возвращаемое значение:
//    ТаблицаЗначений - 
Функция ТаблицаТиповИзТекста(Знач ТекстТипа, Знач Описание = "", Знач ТекстДоВхождения = "", Знач ДляСвойстваПуть = "") Экспорт
	ТаблицаТипов = мПлатформа.НоваяТаблицаТипов();
	Если Прав(ТекстТипа, 1) = "]" И Прав(ТекстТипа, 3) <> "[0]" Тогда
		ФрагментыЗапятой = Новый Массив;
		ФрагментыЗапятой.Добавить(ТекстТипа);
	Иначе 
		ФрагментыЗапятой = ирОбщий.СтрРазделитьЛкс(ТекстТипа, ",", Истина);
	КонецЕсли;
	Для Каждого УказательТипа Из ФрагментыЗапятой Цикл 
		Если Ложь
			Или Не ЗначениеЗаполнено(УказательТипа) 
			Или УказательТипа = "??"
		Тогда
			Продолжить;
		КонецЕсли;   
		ЭтоИмяТипа = Не мПлатформа.УдалитьПрефиксИзТекстаТипов(УказательТипа);
		КорневоеСловоБД = "БД.";
		Если ЭтоИмяТипа Тогда
			ТекстБезВопроса = СтрЗаменить(УказательТипа, "??,", "");
			МаркерКоллекции = " из ";
			ПозицияРазделителя = ирОбщий.СтрНайтиЛкс(ТекстБезВопроса, МаркерКоллекции,,,, Ложь); // Обязательно без учета регистра, т.к. далее рекурсивный вызов на это опирается!
			Если ПозицияРазделителя = 0 Тогда
				МаркерКоллекции = "[";
				ПозицияРазделителя = Найти(ТекстБезВопроса, МаркерКоллекции);
			КонецЕсли;
			Фрагменты = Новый Массив;
			Если ПозицияРазделителя > 0 Тогда
				Фрагменты.Добавить(Лев(ТекстБезВопроса, ПозицияРазделителя - 1));
				Фрагменты.Добавить(Сред(ТекстБезВопроса, ПозицияРазделителя + СтрДлина(МаркерКоллекции)));
			Иначе 
				Фрагменты.Добавить(ТекстБезВопроса);
			КонецЕсли;
			БазовыйТип = Фрагменты[0];
			Если Истина
				И Найти(БазовыйТип, " ") > 0  
				И Найти(БазовыйТип, "{") = 0 // имена COM типов
			Тогда 
				Прервать;
			КонецЕсли;
			Если Фрагменты.Количество() > 1 Тогда
				ЭтоТипСтруктура = ирОбщий.СтрКончаетсяНаЛкс(БазовыйТип, "Структура");
				ЭтоТипСоответствие = ирОбщий.СтрКончаетсяНаЛкс(БазовыйТип, "Соответствие");
				Если ЭтоТипСтруктура Тогда
					ДляСвойстваПуть = "Значение";
				КонецЕсли;
				ТипыЭлементовКоллекции = ТаблицаТиповИзТекста(ирОбщий.ПервыйФрагментЛкс(Фрагменты[1], "]"), Описание,, ДляСвойстваПуть);
				Если ТипыЭлементовКоллекции.Количество() > 0 И Не ЭтоТипСоответствие Тогда
					ИмяОбщегоТипа = БазовыйТип + "[" + мПлатформа.ПредставлениеМассиваСтруктурТипов(ТипыЭлементовКоллекции) + "]";
				Иначе
					ИмяОбщегоТипа = БазовыйТип;
				КонецЕсли;
				СтруктураТипа = мПлатформа.НоваяСтруктураТипа(ИмяОбщегоТипа);
				Если ТипыЭлементовКоллекции.Количество() > 0 Тогда 
					Попытка
						Тип = Тип(ТипыЭлементовКоллекции[0].ИмяОбщегоТипа);
					Исключение
						Тип = Неопределено;
					КонецПопытки;
					МетаданныеТипа = ТипыЭлементовКоллекции[0].Метаданные;
					Если ТипЗнч(МетаданныеТипа) = Тип Тогда
						СтруктураТипа.Метаданные = ирОбщий.ЗначенияВМассивЛкс(МетаданныеТипа);
					ИначеЕсли ЭтоТипСтруктура Тогда
						СтруктураТипа.Метаданные = МетаданныеТипа.Значение;
					Иначе
						СтруктураТипа.Метаданные = МетаданныеТипа;
					КонецЕсли;
					Если ТипыЭлементовКоллекции.Колонки.Метаданные.Заголовок <> "" Тогда
						ТаблицаТипов.Колонки.Метаданные.Заголовок = ЗаголовокФлагОбрезкиГлубины();
					КонецЕсли;
				КонецЕсли;
				мПлатформа.ДобавитьВТаблицуТипов(ТаблицаТипов, СтруктураТипа); 
			//ИначеЕсли Найти(УказательТипа, "[") > 0 Тогда
			//	СтруктураТипа = мПлатформа.НоваяСтруктураТипа(БазовыйТип);
			//	мПлатформа.ДобавитьВТаблицуТипов(ТаблицаТипов, СтруктураТипа); 
			ИначеЕсли ирОбщий.СтрНачинаетсяСЛкс(УказательТипа, "ОпределяемыйТип.") Тогда 
				ОбъектМД = Метаданные.ОпределяемыеТипы.Найти(ирОбщий.ПоследнийФрагментЛкс(УказательТипа));
				Если ОбъектМД <> Неопределено Тогда
					мПлатформа.ДобавитьВТаблицуТипов(ТаблицаТипов, ОбъектМД.Тип);
				КонецЕсли;
			Иначе 
				ТекстОписания = Новый ТекстовыйДокумент;
				ТекстОписания.УстановитьТекст(Описание);
				ПрефиксУровня2 = "**"; 
				ДлинаПрефикса2 = СтрДлина(ПрефиксУровня2);
				ОписаниеСвойств = Новый Структура;
				Если ЗначениеЗаполнено(ДляСвойстваПуть) Тогда
					ДляСвойства = ирОбщий.ПервыйФрагментЛкс(ДляСвойстваПуть);
					ДляСвойстваВниз = ирОбщий.СтрокаБезПервогоФрагментаЛкс(ДляСвойстваПуть);
				Иначе
					ДляСвойства = "";
					ДляСвойстваВниз = ИмяФиктивногоСвойства(); 
				КонецЕсли; 
				Если Ложь
					Или БазовыйТип = "ТаблицаЗначений"
					Или БазовыйТип = "ДеревоЗначений"
				Тогда
					ОбрезатьДляСвойстваКоллекции(ДляСвойстваВниз, ДляСвойства);
				КонецЕсли;
				ОписаниеСвойствОбрезано = Ложь;
				Для Счетчик = 2 По ТекстОписания.КоличествоСтрок() Цикл
					СтрокаОписания = СокрЛП(ТекстОписания.ПолучитьСтроку(Счетчик));
					Если Истина
						И Лев(СтрокаОписания, 1) = "*" 
						И Лев(СтрокаОписания, ДлинаПрефикса2) <> ПрефиксУровня2
					Тогда
						ФрагментыОписания = ирОбщий.СтрРазделитьЛкс(Сред(СтрокаОписания, 2), "-", Истина);
						ИмяСвойства = ФрагментыОписания[0];
						Если ирОбщий.ЛиИмяПеременнойЛкс(ИмяСвойства) Тогда 
							Если Истина
								И ЗначениеЗаполнено(ДляСвойства) 
								И Не ирОбщий.СтрокиРавныЛкс(ДляСвойства, ИмяСвойства) 
								//И Не мПлатформа.мРежимПроверкиМодуля
							Тогда
								ОписаниеСвойствОбрезано = Истина;
								Продолжить;
							КонецЕсли;
							МетаданныеСвойства = Неопределено;
							Если ФрагментыОписания.Количество() > 1 Тогда
								Если ирОбщий.СтрКончаетсяНаЛкс(СтрокаОписания, ":") Тогда
									ОписаниеВложенное = Новый Массив; 
									ОписаниеВложенное.Добавить("");
									Для СчетчикВложенный = Счетчик + 1 По ТекстОписания.КоличествоСтрок() Цикл
										СтрокаОписанияВложенная = СокрЛП(ТекстОписания.ПолучитьСтроку(СчетчикВложенный));
										Если Лев(СтрокаОписанияВложенная, ДлинаПрефикса2) <> ПрефиксУровня2 Тогда 
											Прервать;
										КонецЕсли;
										ОписаниеВложенное.Добавить(Сред(СтрокаОписанияВложенная, ДлинаПрефикса2));
									КонецЦикла;
									ОписаниеВложенное = ирОбщий.СтрСоединитьЛкс(ОписаниеВложенное, Символы.ПС);
									МетаданныеСвойства = ТаблицаТиповИзТекста(ирОбщий.ПервыйФрагментЛкс(ФрагментыОписания[1], ":"), ОписаниеВложенное, ТекстДоВхождения, ДляСвойстваВниз);
								Иначе
									Попытка
										ОписаниеТипов = Новый ОписаниеТипов(ФрагментыОписания[1]);
										МетаданныеСвойства = мПлатформа.ТаблицаТиповИзОписанияТипов(ОписаниеТипов);
									Исключение
										МетаданныеСвойства = ТаблицаТиповИзТекста(ФрагментыОписания[1],, ТекстДоВхождения);  
									КонецПопытки;
								КонецЕсли; 
							КонецЕсли;
							ОписаниеСвойств.Вставить(ИмяСвойства, МетаданныеСвойства);
						КонецЕсли;
					КонецЕсли;
				КонецЦикла;
				
				СтруктураТипа = Неопределено;
				Если Ложь
					Или УказательТипа = "Произвольный"
					Или УказательТипа = "ЛюбаяСсылка"
				Тогда
					СтруктураТипа = мПлатформа.НоваяСтруктураТипа(УказательТипа);
				Иначе 
					ИмяБезВложенных = ирОбщий.ПервыйФрагментЛкс(УказательТипа, "[");
					Попытка
						Тип = Тип(ИмяБезВложенных);
					Исключение
						Тип = Неопределено;
					КонецПопытки;
					Если Истина
						И Тип <> Неопределено 
						И УказательТипа <> "ОтчетОбъект" // Непонятный тип https://www.hostedredmine.com/issues/979813
					Тогда
						СтруктураТипа = мПлатформа.СтруктураТипаИзКонкретногоТипа(Тип);
						//Если ТипЗнч(СтруктураТипа.Метаданные) = Тип("ОбъектМетаданныхКонфигурация") Тогда
						//	СтруктураТипа.ИмяОбщегоТипа = УказательТипа; // Мешает в случае подмены ОбъектМетаданных на ОбъектМетаданныхСправочник
						//КонецЕсли;
						Если ОписаниеСвойств.Количество() > 0 Тогда
							СтруктураТипа.Метаданные = ОписаниеСвойств;
						КонецЕсли;
						Если ОписаниеСвойствОбрезано Тогда
							ТаблицаТипов.Колонки.Метаданные.Заголовок = ЗаголовокФлагОбрезкиГлубины();
						КонецЕсли;
					ИначеЕсли мПлатформа.ЛиИмяТипаComОбъекта(УказательТипа) Тогда 
						СтруктураТипа = мПлатформа.НоваяСтруктураТипа(УказательТипа);
					Иначе
						ОбщиеТипы = Неопределено;
						Если Найти(УказательТипа, " ") = 0 Тогда
							ОбщиеТипы = мПлатформа.ТаблицаОбщихТипов.НайтиСтроки(Новый Структура("БазовыйТип, ЯзыкПрограммы", УказательТипа, 0));
						КонецЕсли;
						Если ОбщиеТипы <> Неопределено И ОбщиеТипы.Количество() > 0 Тогда
							УказательТипа = ОбщиеТипы[0].Слово;
							СтруктураТипа = мПлатформа.НоваяСтруктураТипа(УказательТипа);
						Иначе
							ИмяБезВложенных = НРег(ИмяБезВложенных);
							Если Ложь
								Или ирОбщий.СтрНачинаетсяСЛкс(ИмяБезВложенных, "см.", Истина) 
								Или ирОбщий.СтрНайтиЛкс(ИмяБезВложенных, МаркерКоллекции) 
							Тогда
								СтруктураТипа = ТаблицаТиповИзТекста(УказательТипа, Описание, ТекстДоВхождения, ДляСвойстваПуть);
							Иначе 
								Продолжить;
							КонецЕсли;
						КонецЕсли;
					КонецЕсли;
				КонецЕсли;
				мПлатформа.ДобавитьВТаблицуТипов(ТаблицаТипов, СтруктураТипа);
			КонецЕсли;
		Иначе
			СтруктураТипа = Неопределено;
			Если Истина
				//И Найти(УказательТипа, "(") = 0 // Отключил для различимости методов форм
				И Найти(УказательТипа, ".") > 0 
			Тогда
				ИмяМножественное = ирОбщий.МножественноеИмяМДЛкс(ирОбщий.ПервыйФрагментЛкс(УказательТипа));
				Если ирОбщий.СтрНачинаетсяСЛкс(УказательТипа, КорневоеСловоБД) Тогда
					мЯзыкПрограммы = 1;
					СтруктураТипа = ВычислитьТипЗначенияВыражения(Сред(УказательТипа, СтрДлина(КорневоеСловоБД) + 1),,,,,, Ложь)[0].Квалификаторы;
					мЯзыкПрограммы = 0;
				ИначеЕсли ИмяМножественное <> Неопределено Тогда
					СтруктураТипа = ВычислитьСловоФормыПоПолномуИмени(УказательТипа);
					Если СтруктураТипа = Неопределено Тогда 
						ОбъектМД = Метаданные.НайтиПоПолномуИмени(УказательТипа);
						Попытка
							СтруктураТипа = ОбъектМД.Тип;
						Исключение
						КонецПопытки;
						Если СтруктураТипа = Неопределено Тогда
							Попытка
								СтруктураТипа = ОбъектМД.ТипЗначения;
							Исключение
							КонецПопытки;
						КонецЕсли; 
					КонецЕсли;
				КонецЕсли;
			КонецЕсли;
			Если СтруктураТипа <> Неопределено Тогда 
				мПлатформа.ДобавитьВТаблицуТипов(ТаблицаТипов, СтруктураТипа);
			Иначе
				НоваяТаблицаТипов = Новый Массив;
				Если Найти(УказательТипа, "Объект.") > 0 И СтрЧислоВхождений(УказательТипа, ".") > 1 Тогда
					ИмяТипаОбъекта = ирОбщий.ПервыеФрагментыЛкс(УказательТипа);
					Попытка
						ОписаниеТиповОбъекта = Новый ОписаниеТипов(ИмяТипаОбъекта);
					Исключение
						ОписаниеТиповОбъекта = Неопределено;
					КонецПопытки;
					Если ОписаниеТиповОбъекта <> Неопределено Тогда
						ТаблицаТиповРодителя = мПлатформа.ТаблицаТиповИзОписанияТипов(ОписаниеТиповОбъекта);
						ПоследнийФрагмент = Сред(УказательТипа, СтрДлина(ИмяТипаОбъекта) + 2);
						Слово = ПоследнийФрагмент;
						Если Найти(Слово, "(") > 0 Тогда
							Слово = ирОбщий.ПервыйФрагментЛкс(Слово, "(");
						КонецЕсли;
						НоваяТаблицаТипов = ВычислитьТипДочернегоЭлемента(ТаблицаТиповРодителя, Слово, "Метод",,,,,,,, ДляСвойстваПуть); // Мультметка481922915
						Если НоваяТаблицаТипов.Количество() = 0 И ПоследнийФрагмент <> Слово Тогда
							НоваяТаблицаТипов = ВычислитьТипДочернегоЭлемента(ТаблицаТиповРодителя, Слово, "Свойство",,,,,,,, ДляСвойстваПуть);
						КонецЕсли;
					КонецЕсли;
				КонецЕсли;
				Если НоваяТаблицаТипов.Количество() = 0 Тогда
					НоваяТаблицаТипов = ВычислитьТипЗначенияВыражения(УказательТипа, ТекстДоВхождения, ТекстДоВхождения,,,, Ложь,,,,,,, ДляСвойстваПуть); // Мультметка481922915
				КонецЕсли;
				Если НоваяТаблицаТипов.Количество() = 0 И Найти(УказательТипа, "(") = 0 Тогда
					НоваяТаблицаТипов = ТаблицаТиповИзПолногоИмениМетодаИлиПараметра(УказательТипа, ДляСвойстваПуть);
				КонецЕсли;
				мПлатформа.ДобавитьВТаблицуТипов(ТаблицаТипов, НоваяТаблицаТипов);
			КонецЕсли;
		КонецЕсли;
	КонецЦикла;
	//Если ТаблицаТипов.Количество() = 0 Тогда
	//	мПлатформа.ДобавитьВТаблицуТипов(ТаблицаТипов, мПлатформа.НоваяСтруктураТипа());
	//КонецЕсли;
	Возврат ТаблицаТипов;
КонецФункции

//.
// Параметры:
//    ТекстТипа - Строка - 
// Возвращаемое значение:
//    ТаблицаЗначений, Неопределено - 
Функция ТаблицаТиповИзПолногоИмениМетодаИлиПараметра(ПолноеИмя, Знач ДляСвойства = "") Экспорт
	ТаблицаТипов = ВычислитьТипЗначенияВыражения(ПолноеИмя + "(",,, Ложь,,, Ложь,,,,,,, ДляСвойства);
	Если ТаблицаТипов.Количество() > 0 Или Найти(ПолноеИмя, "(") > 0 Тогда
		Возврат ТаблицаТипов;
	КонецЕсли;
	ТаблицаТипов = ВычислитьТипЗначенияВыражения(ирОбщий.СтрокаБезПоследнегоФрагментаЛкс(ПолноеИмя) + "(",,, Ложь,,, Ложь,,,,,,, ДляСвойства);
	Если ТаблицаТипов.Количество() > 0 Тогда
		СтрокаМетода = ТаблицаТипов[0].СтрокаОписания; // см. мПлатформа.НоваяТаблицаМетодовМодуля()[0]
		Если Истина
			И ТипЗнч(СтрокаМетода) = Тип("СтрокаТаблицыЗначений") 
			И СтрокаМетода.Владелец().Колонки.Найти("ЛиЭкспорт") <> Неопределено
		Тогда
			Если СтрокаМетода.Имя = "<>" Тогда
				ТаблицаТипов = Неопределено;
			Иначе 
				ПараметрыМетода = мПлатформа.ПараметрыМетодаМодуля(СтрокаМетода);
				Если ПараметрыМетода <> Неопределено Тогда
					ПараметрыМетода = ПараметрыМетода.Скопировать();
					СтрокаПараметра = ПараметрыМетода.Найти(НРег(ирОбщий.ПоследнийФрагментЛкс(ПолноеИмя)), "НИмя");
					Если СтрокаПараметра <> Неопределено Тогда
						ПараметрыМетода.Колонки.Добавить("ИмяМодуля"); // Мультиметка4819233927
						ПараметрыМетода.Колонки.Добавить("ИмяМетода");
						ПараметрыМетода.ЗаполнитьЗначения(СтрокаМетода.ИмяМодуля, "ИмяМодуля");
						ПараметрыМетода.ЗаполнитьЗначения(СтрокаМетода.Имя, "ИмяМетода");
						НоваяТаблицаТипов = ТаблицаТиповИзПараметраМетодаМодуля(СтрокаМетода, СтрокаПараметра, ДляСвойства);
						Если НоваяТаблицаТипов <> Неопределено Тогда
							ТаблицаТипов = НоваяТаблицаТипов.Скопировать(); // Чтобы не было циклической ссылки
							Если ТаблицаТипов.Количество() = 0 Тогда
								СтрокаТипа = ТаблицаТипов.Добавить();
								СтрокаТипа.Детальность = 0;
							КонецЕсли;
							ТаблицаТипов.ЗаполнитьЗначения(СтрокаПараметра, "СтрокаОписания");
						КонецЕсли;
					КонецЕсли;
				КонецЕсли;
			КонецЕсли;
		КонецЕсли;
	КонецЕсли;
	Возврат ТаблицаТипов;
КонецФункции

//.
// Параметры:
//    СтрокаМетода - СтрокаТаблицыЗначений - 
//    СтрокаПараметра - СтрокаТаблицыЗначений - 
// Возвращаемое значение:
//    ТаблицаЗначений, Неопределено - 
Функция ТаблицаТиповИзПараметраМетодаМодуля(Знач СтрокаМетода, Знач СтрокаПараметра, Знач ДляСвойства = "") Экспорт
	Если СтрокаПараметра.ТаблицаТипов <> Неопределено Тогда
		НоваяТаблицаТипов = СтрокаПараметра.ТаблицаТипов;
	ИначеЕсли ЗначениеЗаполнено(СтрокаПараметра.ТипЗначения) Тогда
		АнализаторМодуля = мПлатформа.ПолеТекстаМодуля(СтрокаМетода.ИмяМодуля);
		НоваяТаблицаТипов = АнализаторМодуля.ТаблицаТиповИзТекста(СтрокаПараметра.ТипЗначения, СтрокаПараметра.Описание,, ДляСвойства); // TODO защита от бесконечной рекурсии
	Иначе 
		НоваяТаблицаТипов = Неопределено;
	КонецЕсли;
	Возврат НоваяТаблицаТипов;
КонецФункции

Функция ВычислитьСловоФормыПоПолномуИмени(Знач ИмяТипа)
	
	ЧастиИмени = ЧастиПолногоИмениЭлементаФормы(ИмяТипа);
	Если ЧастиИмени = Неопределено Тогда
		Возврат Неопределено;
	КонецЕсли;
	Выражение = 
	"ПолучитьФорму(""" + ЧастиИмени.ИмяФормы + """)";
	Если ЗначениеЗаполнено(ЧастиИмени.ПутьКЭлементу) Тогда
		Выражение = Выражение + "." + ЧастиИмени.ПутьКЭлементу;
	КонецЕсли;
	ТаблицаТипов = ВычислитьТипЗначенияВыражения(Выражение,,,,,, Ложь,,,, Истина);
	Если ТаблицаТипов.Количество() > 0 Тогда
		Результат = ТаблицаТипов[0];
	КонецЕсли;
	Возврат Результат;

КонецФункции                                           

// .
//
// Параметры:
//  ИмяТипа			 - 	 - ? -
// 
// Возвращаемое значение:
//   Структура - 
//
Функция ЧастиПолногоИмениЭлементаФормы(Знач ИмяТипа) Экспорт
	Если Найти(ИмяТипа, "Форма") = 0 Тогда
		Возврат Неопределено;
	КонецЕсли;
	ФрагментыТочки = ирОбщий.СтрРазделитьЛкс(ИмяТипа);
	КоличествоФрагментов = ФрагментыТочки.Количество();
	Если КоличествоФрагментов > 1 И ФрагментыТочки[0] = "ОбщаяФорма" Тогда 
		ЧислоФрагментовИмениФормы = 2;
	ИначеЕсли КоличествоФрагментов > 2 И ФрагментыТочки[2] = "Форма" Тогда 
		ЧислоФрагментовИмениФормы = Мин(4, КоличествоФрагментов);
	Иначе
		ВсеИменаСтандартныхФорм = мПлатформа.ВсеИменаСтандартныхФорм();
		РолиФормКласса = Неопределено; // СписокЗначений
		Если ВсеИменаСтандартныхФорм.Свойство(ФрагментыТочки[0], РолиФормКласса) Тогда
			Для Индекс = 2 По ФрагментыТочки.ВГраница() Цикл
				Если ирОбщий.НайтиЭлементКоллекцииЛкс(РолиФормКласса, "Значение", ФрагментыТочки[Индекс],, Ложь) <> Неопределено Тогда
					ЧислоФрагментовИмениФормы = Индекс + 1;
					Прервать;
				КонецЕсли;
			КонецЦикла;
		КонецЕсли;
		Если ЧислоФрагментовИмениФормы = Неопределено Тогда
			Возврат Неопределено;
		КонецЕсли;
	КонецЕсли;
	Результат = Новый Структура;
	Результат.Вставить("ИмяФормы", ирОбщий.СтрСоединитьЛкс(ФрагментыТочки, ".", ЧислоФрагментовИмениФормы));
	Для Счетчик = 1 По ЧислоФрагментовИмениФормы Цикл
		ФрагментыТочки.Удалить(0);
	КонецЦикла;
	Результат.Вставить("ПутьКЭлементу", ирОбщий.СтрСоединитьЛкс(ФрагментыТочки, "."));
	Возврат Результат;
КонецФункции

Процедура ОбновитьКонтекстВыраженияЗапросаПоНастройкеКомпоновкиЛкс(НастройкаКомпоновки) Экспорт 
	
	#Если Сервер И Не Сервер Тогда
		НастройкаКомпоновки = Новый НастройкиКомпоновкиДанных;
	#КонецЕсли
	ОчиститьТаблицуСловЛокальногоКонтекста();
	Для Каждого ДоступноеПоле Из НастройкаКомпоновки.ДоступныеПоляОтбора.Элементы Цикл
		НрегПервыйФрагмент = ирОбщий.ПервыйФрагментЛкс(НРег(ДоступноеПоле.Поле));
		Если НрегПервыйФрагмент = НРег("ПараметрыДанных") Тогда
			Для Каждого ДоступныйПараметр Из ДоступноеПоле.Элементы Цикл
				ИмяСвойства = мПараметрыДиалектаSQL.ПрефиксПараметра + ирОбщий.ПоследнийФрагментЛкс(ДоступныйПараметр.Поле);
				ДобавитьСловоЛокальногоКонтекста(ИмяСвойства, "Свойство", , ДоступныйПараметр,,,, "СтрокаТаблицы"); // Виртуальный тип
			КонецЦикла; 
		Иначе
			ДобавитьСловоЛокальногоКонтекста("" + ДоступноеПоле.Поле, "Свойство",, ДоступноеПоле,,,, "СтрокаТаблицы"); // Виртуальный тип
		КонецЕсли; 
	КонецЦикла;

КонецПроцедуры

Процедура УстановитьПризнакМодифицированностиФормы()

	Если ПолеТекста.ЭлементФормы.ИзменяетДанные Тогда
		ФормаВладелец.Модифицированность = Истина;
	КонецЕсли; 

КонецПроцедуры

Функция ПолучитьСтруктуруТипаСправаОтРавно() Экспорт 
	
	КончитьОбработкуКоманды();
	ТаблицаТипов = ТаблицаТиповТекущегоВыражения(Истина);
	КончитьОбработкуКоманды();
	СписокТиповКонтекста = Новый СписокЗначений;
	МассивДляПроверкиДублей = Новый Массив;
	Для Каждого СтруктураТипаКонтекста Из ТаблицаТипов Цикл
		ИмяОбщегоТипа = СтруктураТипаКонтекста.ИмяОбщегоТипа;
		Если Ложь
			Или Не мПлатформа.ЭтоАгрегатныйОбщийТип(ИмяОбщегоТипа, ЯзыкПрограммы) 
			Или ТипЗнч(СтруктураТипаКонтекста.Метаданные) <> Тип("ОбъектМетаданных")
			Или (Истина
				И ЯзыкПрограммы = 0
				И Найти(ИмяОбщегоТипа, "Ссылка.") = 0)
		Тогда 
			Продолжить;
		КонецЕсли;
		ПредставлениеКонкретногоТипа = "";
		ПредставлениеКонкретногоТипа = ПредставлениеКонкретногоТипа + мПлатформа.ИмяТипаИзСтруктурыТипа(СтруктураТипаКонтекста);
		Если МассивДляПроверкиДублей.Найти(ПредставлениеКонкретногоТипа) = Неопределено Тогда
			СписокТиповКонтекста.Добавить(СтруктураТипаКонтекста, ПредставлениеКонкретногоТипа);
			МассивДляПроверкиДублей.Добавить(ПредставлениеКонкретногоТипа);
		КонецЕсли;
	КонецЦикла;
	Если СписокТиповКонтекста.Количество() > 0 Тогда
		Ответ = Вопрос("Хотите использовать предсказанные равенством метаданные?", РежимДиалогаВопрос.ДаНет);
		Если Ответ = КодВозвратаДиалога.Нет Тогда
			Возврат Неопределено;
		КонецЕсли;
	КонецЕсли; 
	Если СписокТиповКонтекста.Количество() = 1 Тогда 
		ВыбраннаяСтруктураТипа = СписокТиповКонтекста[0].Значение;
		КонкретныйТип = СписокТиповКонтекста[0].Представление;
	ИначеЕсли СписокТиповКонтекста.Количество() > 1 Тогда
		СписокТиповКонтекста.СортироватьПоПредставлению();
		ВыбранныйТип = СписокТиповКонтекста.ВыбратьЭлемент("Выберите тип контекста");
		Если ВыбранныйТип <> Неопределено Тогда
			ВыбраннаяСтруктураТипа = ВыбранныйТип.Значение;
			КонкретныйТип = ВыбранныйТип.Представление;
		КонецЕсли;
	КонецЕсли;
	//Если ВыбраннаяСтруктураТипа <> Неопределено Тогда
	//	СтруктураТипаКонтекста = мПлатформа.НоваяСтруктураТипа();
	//	ЗаполнитьЗначенияСвойств(СтруктураТипаКонтекста, ВыбраннаяСтруктураТипа);
	//КонецЕсли;
	Возврат ВыбраннаяСтруктураТипа;

КонецФункции//ПолучитьСтруктуруТипаСправоОтРавно

Функция ТаблицаТиповТекущегоВыражения(ВзятьЛевоеОтРавенства = Ложь, БезКонструкторов = Ложь, ПолныйАнализСоставаТипов = Истина, Знач ЛиCOMВызов = Ложь) Экспорт

	НомерСтроки = 0; // Был параметром
	НомерКолонки = 0; // Был параметром
	РазобратьТекущийКонтекст(ВзятьЛевоеОтРавенства,,, НомерСтроки, НомерКолонки, Истина);
	лКонтекст = ?(ВзятьЛевоеОтРавенства, мКонтекст, мРодительскийКонтекст);
	Если Ложь                                 
		Или (Истина
			И Прав(мТекущаяСтрокаНачало, 1) = """"
			И Не ирОбщий.ЛиВнутриТекстовогоЛитералаЛкс(мТекущаяСтрокаНачало))
		Или (Истина
			И Не ВзятьЛевоеОтРавенства 
			И Прав(мТекущаяСтрокаНачало, 1) = "."  
			И ПустаяСтрока(мРодительскийКонтекст))
	Тогда
		Возврат мПлатформа.НоваяТаблицаТипов();
	КонецЕсли;
	мПлатформа.мРежимПроверкиМодуля = Ложь;
	Попытка
		ТаблицаТиповКонтекста = ВычислитьТипЗначенияВыражения(лКонтекст, мТекстДляПоискаОпределения, мПредшествующийТекст, Истина,, ПолныйАнализСоставаТипов,,,,,, мПозицияВБлоке);
	Исключение
		Ошибка = ИнформацияОбОшибке();
		Если Ошибка.Описание = "ОшибкаВычисленияВиртуальнойТаблицы" Тогда 
			Возврат мПлатформа.НоваяТаблицаТипов();
		КонецЕсли;
		Если ЛиCOMВызов Тогда
			ВызватьИсключение ОписаниеОшибки();
		Иначе
			ВызватьИсключение;
		КонецЕсли;
	КонецПопытки;
	ТаблицаТиповКонтекста = ТаблицаТиповКонтекста.Скопировать(); // Могла вернуться прямая таблица из кэша
	Если БезКонструкторов Тогда
		Для Каждого СтрокаТаблицы Из ТаблицаТиповКонтекста.НайтиСтроки(Новый Структура("Конструктор", Истина)) Цикл
			ТаблицаТиповКонтекста.Удалить(СтрокаТаблицы);
		КонецЦикла;
	КонецЕсли; 
    Возврат ТаблицаТиповКонтекста;
	
КонецФункции

Функция ПодготовитьИмяПараметраМетодаПлатформы(ИмяПараметра) Экспорт 
	
	//ирОбщий.ДекодироватьТекстИзXMLЛкс(СтрокаПараметра.Параметр);
	ИмяПараметра = СтрЗаменить(ИмяПараметра, "&gt;", "");
	ИмяПараметра = СтрЗаменить(ИмяПараметра, "&lt;", "");
	Возврат ИмяПараметра;

КонецФункции

Функция СтрокаИменПараметровМетода() Экспорт 
	Возврат ирОбщий.СтрСоединитьЛкс(мПлатформа.ПараметрыМетодаМодуля(мМетодМодуля).ВыгрузитьКолонку("Имя"), ",")
КонецФункции

// Вызывает контекстную подсказку в текстовом поле.
//
// Параметры:
//  Нет.
//
Процедура ОткрытьАвтодополнение(Знач КодКлавиши = "", Знач Модально = Ложь) Экспорт 
	
	Если ирОбщий.ПроверитьПлатформаНеWindowsЛкс(,, Истина) Тогда 
		Возврат;
	КонецЕсли; 
	#Если Сервер И Не Сервер Тогда
		мПлатформа = Обработки.ирПлатформа.Создать();
	#КонецЕсли
	// Мультиметка00452941 Удаляем лишние точки истории из-за запоминания по нажатию CTRL
	УдалитьПоследнийПереходИзИстории();
	ФормаАвтодополнение = ФормаАвтодополнение();
	КодыКлавиш = ирКэш.КодыКлавишЛкс();
	Если Ложь
		Или ПолеТекста.ТолькоПросмотр()
		Или ФормаВладелец <> Неопределено И ФормаВладелец.ТолькоПросмотр     
		Или ФормаАвтодополнение.Открыта() И Не ЗначениеЗаполнено(КодКлавиши)
	Тогда
		Возврат;
	КонецЕсли;
	Если Истина
		//И Найти(КодКлавиши, "04128") = 1 // CTRL+SPACE
		И КодКлавиши = "" // Вызов из обработчика нажатия кнопки
		И ТипЗнч(ПолеТекста.ЭлементФормы) = Тип("ПолеHTMLДокумента")
		И ирКэш.НомерВерсииПлатформыЛкс() <= 803016
	Тогда
		// https://github.com/salexdv/bsl_console/issues/124
		ПолеТекста.РедакторHTML().triggerSuggestions(); 
		Возврат;
	КонецЕсли; 
	
	//Если Истина
	//	И ЯзыкПрограммы = 1
	//	И Не мДоступныеТаблицыПолучены 
	//Тогда
	//	Если ирОбщий.СтрокиРавныЛкс(мДиалектSQL, "1С") Тогда
	//	ИначеЕсли ирОбщий.СтрокиРавныЛкс(мДиалектSQL, "WQL") Тогда
	//	Иначе
	//		ЗаполнитьДоступныеТаблицыADO(); // Может быть очень долго
	//		Для Каждого СтрокаДоступнойТаблицы Из ДоступныеТаблицы Цикл
	//			ДобавитьСловоЛокальногоКонтекста(СтрокаДоступнойТаблицы.Имя,,,, Истина,,, "ВременнаяТаблица");
	//		КонецЦикла; 
	//	КонецЕсли; 
	//КонецЕсли; 
	СтруктураТипаКонтекста = Неопределено;
	ТаблицаТиповКонтекста = Неопределено;  
	Модально = Модально Или Не ЛиДоступноОткрытиеСвободнойФормы();
	ЛиАвтовызов = ЗначениеЗаполнено(КодКлавиши);
	Пока Истина Цикл
		ЕстьЛучшееСлово = Ложь;
		Успешно = ЗаполнитьТаблицуСлов(ТаблицаТиповКонтекста,, ЕстьЛучшееСлово, Модально,, Не ЛиАвтовызов);
		ТекущаяСтрокаНачало = НРег(мТекущаяСтрокаНачало);
		Если Ложь
			Или Не Успешно
			Или (Истина
				И ЛиАвтовызов
				И Не ЕстьЛучшееСлово
				И (Ложь
					Или Прав(СокрП(ТекущаяСтрокаНачало), 1) = "=" 
					Или (Истина
						И ирОбщий.СтрКончаетсяНаЛкс(СокрП(ТекущаяСтрокаНачало), "новый")
						И Прав(ТекущаяСтрокаНачало, 1) = " ")))
		Тогда
			Возврат;
		КонецЕсли;
		//Если Ложь 
		//	Или Не Успешно 
		//	Или (Истина
		//		И мСтруктураТипаКонтекста.ТипЯзыка = "ИмяТипа" 
		//		И Найти(мКодКлавишиОткрытияАвтодополнения, КодыКлавиш["Space"]) = 1
		//		И мСтрокаЛучшегоСлова = Неопределено)
		//Тогда
		//	Возврат;
		//КонецЕсли;
		Если Истина
			И ТаблицаСлов.Количество() = 0
			И Не ирОбщий.ВосстановитьЗначениеЛкс(ИмяКласса + ".ЛиОткрыватьПустойСписок") = Истина
		Тогда
			Возврат;
		КонецЕсли;
		КлючПоискаСтатистики = Новый Структура("ЯзыкПрограммы, ТипКонтекста", ЯзыкПрограммы, мКонкретныйТипКонтекста);
		НайденныеСтроки = мПлатформа.ТаблицаСтатистикиВыбора.НайтиСтроки(КлючПоискаСтатистики);
		ТаблицаСловТЗ = ТаблицаСлов.Выгрузить(, "НСлово, Рейтинг");
		ТаблицаСловТЗ.Индексы.Добавить("НСлово");
		Для Каждого СтрокаРейтинга Из НайденныеСтроки Цикл
			СтрокаСлова = ТаблицаСловТЗ.Найти(НРег(СтрокаРейтинга.Слово), "НСлово");
			Если СтрокаСлова <> Неопределено Тогда
				СтрокаСлова.Рейтинг = СтрокаСлова.Рейтинг + СтрокаРейтинга.Рейтинг;
			КонецЕсли;
		КонецЦикла;
		ТаблицаСлов.ЗагрузитьКолонку(ТаблицаСловТЗ.ВыгрузитьКолонку("Рейтинг"), "Рейтинг");
		//Попытка
		//	ФормаАвтодополнение.мСтруктураТипаКонтекста = мСтруктураТипаКонтекста;
		//Исключение
		//	ВызватьИсключение "Экземпляр формы автодополнения контекстной подсказки сломан ошибкой платформы. Переоткройте форму чтобы восстановить ее работу";
		//КонецПопытки;
		//Если ЗначениеЗаполнено(мСтруктураТипаКонтекста.ТипЯзыка) Тогда
		//	ФормаАвтодополнение.Контекст = мСтруктураТипаКонтекста.ТипЯзыка;
		//Иначе
		//	ФормаАвтодополнение.Контекст = мРодительскийКонтекст;
		//КонецЕсли; 
		Если ФормаАвтодополнение.Открыта() Тогда
			// Иначе будет считана некорректная позиция окна 
			ФормаАвтодополнение.Закрыть();
		КонецЕсли;
		ФормаАвтодополнение.ЗапомнитьПозициюКаретки();
		Если ФормаВладелец <> Неопределено Тогда
			ФормаВладелец.Активизировать(); 
		КонецЕсли;
		//ирКлиент.Форма_АктивироватьОткрытьЛкс(ФормаВладелец); // https://www.hostedredmine.com/issues/911214
		ФормаАвтодополнение.НачальноеЗначениеВыбора = мСтрокаЛучшегоСлова;
		ФормаАвтодополнение.ОжидаемыйТип = мИмяОжидаемогоТипа;
		Если Модально Тогда
			ФормаАвтодополнение.ТекущееСлово = мНачалоСлова;
			ПараметрЗакрытияПодсказки = ФормаАвтодополнение.ОткрытьМодально();
		Иначе
			ПараметрЗакрытияПодсказки = Неопределено;
			ФормаАвтодополнение.Открыть();
		КонецЕсли;
		Если ПараметрЗакрытияПодсказки = Неопределено Тогда
			Возврат;
		КонецЕсли; 
		СтрокаРезультата = ФормаАвтодополнение.СтрокаСловаРезультата;
		Если СтрокаРезультата = Неопределено Тогда
			Возврат;
		КонецЕсли;
		ВставитьВыбранноеСловоАвтодополнения(СтрокаРезультата, ТаблицаТиповКонтекста, ПараметрЗакрытияПодсказки);
		Если ТаблицаТиповКонтекста.Количество() = 0 Тогда
			Возврат;
		КонецЕсли;
	КонецЦикла;

КонецПроцедуры

Функция ФормаАвтодополнение() Экспорт
	Если мФормаАвтодополнение = Неопределено Тогда
		Если Ложь
			Или Не ирКэш.ЛиПлатформаWindowsЛкс()
			Или ирКлиент.ЛиПерехватКлавиатурногоВводаЛкс() 
		Тогда
			ИмяФормы = "Автодополнение";
		Иначе
			ИмяФормы = "АвтодополнениеCOM";
		КонецЕсли; 
		мФормаАвтодополнение = ПолучитьФорму(ИмяФормы, ФормаВладелец); 
		Если Не мФормаАвтодополнение.Открыта() Тогда
			мФормаАвтодополнение.КлючСохраненияПоложенияОкна = ЯзыкПрограммы; 
		КонецЕсли;
	КонецЕсли;
	Возврат мФормаАвтодополнение;
КонецФункции

Процедура УдалитьПоследнийПереходИзИстории()
	
	Если мИсторияПереходов <> Неопределено И мИсторияПереходов.Количество() > 0 Тогда
		мИсторияПереходов.Удалить(0); 
	КонецЕсли;

КонецПроцедуры

// Функция - Заполнить таблицу слов
//
// Параметры:
//  ТаблицаТиповКонтекста		 - см. мПлатформа.НоваяТаблицаТипов() - очищается внутри, поэтому часто нужно передавать копию!
//  _1							 -  - 
//  выхЕстьЛучшееСлово  		 - Булево - мСтрокаЛучшегоСлова <> Неопределено
//  РазрешитьОткрытиеОкон		 - 			 - 
//  Сортировать					 - 			 - 
//  ДобавлятьНизкоВероятные		 - 			 - 
//  ОтделятьБольшиеНаборыСлов	 - 			 - 
// 
// Возвращаемое значение:
//   - 
//
Функция ЗаполнитьТаблицуСлов(ТаблицаТиповКонтекста = Неопределено, _1 = Неопределено, выхЕстьЛучшееСлово = Неопределено, Знач РазрешитьОткрытиеОкон = Истина,
	Знач Сортировать = Истина, Знач ДобавлятьНизкоВероятные = Ложь, Знач ОтделятьБольшиеНаборыСлов = Ложь) Экспорт
	
 	ВычислятьТипы = ПоказыватьВсеТипыВСпискеАвтодополненияHTML();
	мРегВыражение.Global = Истина;
	ТаблицаСтатистикиВыбора = мПлатформа.ТаблицаСтатистикиВыбора;
	#Если Сервер И Не Сервер Тогда
		ТаблицаСтатистикиВыбора = Новый ТаблицаЗначений;
		мПлатформа = Обработки.ирПлатформа.Создать();
	#КонецЕсли
	Если ТаблицаТиповКонтекста = Неопределено Тогда
		ТаблицаТиповКонтекста = ТаблицаТиповТекущегоВыражения();
	КонецЕсли;
	Если ОтделятьБольшиеНаборыСлов Тогда
		мНаборыСлов = Новый Соответствие;
	Иначе
		мНаборыСлов = Неопределено;
	КонецЕсли;
	ТаблицаСлов.Очистить();
	выхЕстьЛучшееСлово = Ложь;
	Если ТаблицаТиповКонтекста.Количество() = 0 Тогда
		ЗаполнитьЗначенияСвойств(ТаблицаТиповКонтекста.Добавить(), мПлатформа.НоваяСтруктураТипа());
		ТаблицаТиповКонтекста[0].Детальность = 0;
	КонецЕсли; 
	мЭтоЛокальныйКонтекстТаблицыСлов = Ложь;
	Если мЭтоТекстовыйЛитерал Тогда
		РазрешитьОткрытиеОкон = Ложь;
	КонецЕсли;
	Если ЯзыкПрограммы <> 0 Тогда
		ДобавлятьНизкоВероятные = Ложь;
	КонецЕсли;
	мСтруктураТипаКонтекста = Неопределено;
	мАгрегатныеТипыКонтекста = Новый СписокЗначений;
	СоответствиеСтруктурТипов = Новый Соответствие;
	МассивДляПроверкиДублей = Новый Массив;
	Для Каждого СтруктураТипаКонтекста Из ТаблицаТиповКонтекста Цикл
		ИмяОбщегоТипа = СтруктураТипаКонтекста.ИмяОбщегоТипа;
		Если ИмяОбщегоТипа = "Локальный" Тогда
			мЭтоЛокальныйКонтекстТаблицыСлов = Истина;
		КонецЕсли; 
		Если Истина
			И Не ЗначениеЗаполнено(СтруктураТипаКонтекста.ТипЯзыка) 
			И Не мПлатформа.ЭтоАгрегатныйОбщийТип(ИмяОбщегоТипа, мЯзыкПрограммы) 
			//И СтруктураТипаКонтекста.Детальность < 4 // нужно для защиты COM объектов, но мешает в случае ОбъектМетаданных+ОбъектМетаданныхСправочник
		Тогда 
			Продолжить;
		КонецЕсли;
		ПредставлениеКонкретногоТипа = "";
		//Если СтруктураТипаКонтекста.СтрокаОписания <> Неопределено Тогда
		//	// Наверное логичнее было бы из ВычислитьТипЗначенияВыражения ее получать
		//	РодительскаяСтруктураТипа = мПлатформа.НоваяСтруктураТипа();
		//	Если СтруктураТипаКонтекста.СтрокаОписания.Владелец().Колонки.Найти("ТипКонтекста") <> Неопределено Тогда
		//		ЗаполнитьЗначенияСвойств(РодительскаяСтруктураТипа, СтруктураТипаКонтекста);
		//		РодительскаяСтруктураТипа.ИмяОбщегоТипа = СтруктураТипаКонтекста.СтрокаОписания.ТипКонтекста;
		//	КонецЕсли;
		//	ПредставлениеКонкретногоТипа = ПредставлениеКонкретногоТипа 
		//		+ мПлатформа.ИмяТипаИзСтруктурыТипа(РодительскаяСтруктураТипа) + " / ";
		//КонецЕсли;
		ПредставлениеКонкретногоТипа = ПредставлениеКонкретногоТипа + мПлатформа.ИмяТипаИзСтруктурыТипа(СтруктураТипаКонтекста);
		Если МассивДляПроверкиДублей.Найти(ПредставлениеКонкретногоТипа) = Неопределено Тогда
			мАгрегатныеТипыКонтекста.Добавить(ПредставлениеКонкретногоТипа, ПредставлениеКонкретногоТипа + " [" + СтруктураТипаКонтекста.Детальность + "]");
			МассивДляПроверкиДублей.Добавить(ПредставлениеКонкретногоТипа);
		КонецЕсли;
		МассивСтруктурТипа = СоответствиеСтруктурТипов[ПредставлениеКонкретногоТипа];
		Если МассивСтруктурТипа = Неопределено Тогда
			МассивСтруктурТипа = Новый Массив;
		КонецЕсли; 
		МассивСтруктурТипа.Добавить(СтруктураТипаКонтекста);
		СоответствиеСтруктурТипов[ПредставлениеКонкретногоТипа] = МассивСтруктурТипа;
	КонецЦикла; 
	ЭтоГруппаОбщихМодулей = Истина
		И Не мЭтоЛокальныйКонтекстТаблицыСлов
		И мАгрегатныеТипыКонтекста.Количество() > 1 
		И ирОбщий.ПервыйФрагментЛкс(мАгрегатныеТипыКонтекста[0].Значение, "[") = "ОбщийМодуль";
	мКонкретныйТипКонтекста = "";
	ЛиВЗаголовкеМетода = ЛиВЗаголовкеМетода();
	Если ЛиВЗаголовкеМетода Тогда
		ВыбраннаяСтруктураТипа = мПлатформа.НоваяСтруктураТипа();
		ТаблицаТиповКонтекста.Очистить();
		ЗаполнитьЗначенияСвойств(ТаблицаТиповКонтекста.Добавить(), ВыбраннаяСтруктураТипа);
		мЭтоЛокальныйКонтекстТаблицыСлов = Ложь;
	ИначеЕсли мАгрегатныеТипыКонтекста.Количество() = 0 Тогда 
		ВыбраннаяСтруктураТипа = ТаблицаТиповКонтекста[0];
		мКонкретныйТипКонтекста = мПлатформа.ИмяТипаИзСтруктурыТипа(СтруктураТипаКонтекста);
	Иначе
		ВыбраннаяСтруктураТипа = Неопределено;
		мАгрегатныеТипыКонтекста.СортироватьПоПредставлению();
		Если мАгрегатныеТипыКонтекста.Количество() > 1 И РазрешитьОткрытиеОкон И Не ЭтоГруппаОбщихМодулей Тогда
			НачальныйВыбор = Неопределено;
			КлючПоискаСтатистики = Новый Структура("ЯзыкПрограммы, ТипКонтекста", мЯзыкПрограммы, "<Выбор типа>");
			ВыбранныеРанееТипы = ТаблицаСтатистикиВыбора.Скопировать(КлючПоискаСтатистики);
			ВыбранныеРанееТипы.Сортировать("Рейтинг Убыв");
			Для Каждого СтрокаТипа Из ВыбранныеРанееТипы Цикл
				Для Каждого ЭлементСписка Из мАгрегатныеТипыКонтекста Цикл
					Если СтрокаТипа.Слово = ЭлементСписка.Представление Тогда
						НачальныйВыбор = ЭлементСписка;
						Прервать;
					КонецЕсли; 
				КонецЦикла;
				Если НачальныйВыбор <> Неопределено Тогда
					Прервать;
				КонецЕсли; 
			КонецЦикла;
			ВыбранныйЭлементСписка = мАгрегатныеТипыКонтекста.ВыбратьЭлемент("Выберите тип контекста", НачальныйВыбор);
			Если ВыбранныйЭлементСписка = Неопределено Тогда
				Возврат Ложь;
			КонецЕсли;
			мКонкретныйТипКонтекста = ВыбранныйЭлементСписка.Значение;
			// Обновим статистику выбора
			КлючПоискаСтатистики.Вставить("Слово", мКонкретныйТипКонтекста);
			НайденныеСтроки = ТаблицаСтатистикиВыбора.НайтиСтроки(КлючПоискаСтатистики);
			Если НайденныеСтроки.Количество() > 0 Тогда
				СтрокаСтатистикиВыбора = НайденныеСтроки[0];
			Иначе
				СтрокаСтатистикиВыбора = ТаблицаСтатистикиВыбора.Добавить();
				ЗаполнитьЗначенияСвойств(СтрокаСтатистикиВыбора, КлючПоискаСтатистики);
			КонецЕсли;
			СтрокаСтатистикиВыбора.Рейтинг = СтрокаСтатистикиВыбора.Рейтинг + 1;
		Иначе
			ВыбранныйЭлементСписка = мАгрегатныеТипыКонтекста[0];
			мКонкретныйТипКонтекста = ВыбранныйЭлементСписка.Значение;
		КонецЕсли;
		МассивСтруктурТипа = СоответствиеСтруктурТипов[мКонкретныйТипКонтекста];
		Для Каждого СтруктураТипа Из МассивСтруктурТипа Цикл
			Если Ложь
				Или ВыбраннаяСтруктураТипа = Неопределено 
				Или ТипЗнч(ВыбраннаяСтруктураТипа.Метаданные) = Тип("ОбъектМетаданныхКонфигурация")
			Тогда
				ВыбраннаяСтруктураТипа = СтруктураТипа;
			КонецЕсли; 
		КонецЦикла;
	КонецЕсли; 
	мСтруктураТипаКонтекста = мПлатформа.НоваяСтруктураТипа();
	Если мЭтоТекстовыйЛитерал Тогда
		мАгрегатныеТипыКонтекста.Очистить();
	КонецЕсли;
	ДобавлятьСтатистическиеСлова = Ложь;
	мТаблицаТиповКонтекста = ТаблицаТиповКонтекста.Скопировать();
	Если мЯзыкПрограммы = 0 И ирОбщий.ЛиВнутриПрепроцессораЛкс(мТекущаяСтрокаНачало) Тогда 
		Слова = Новый Массив;
		Слова.Добавить("Если");
		Слова.Добавить("Тогда");
		Слова.Добавить("ИначеЕсли");
		Слова.Добавить("Иначе");
		Слова.Добавить("КонецЕсли");
		Слова.Добавить("Вставка");
		Слова.Добавить("КонецВставки");
		Слова.Добавить("Удаление"); 
		Слова.Добавить("КонецУдаления");
		Слова.Добавить("Область");
		Слова.Добавить("КонецОбласти");
		Слова.Добавить("Клиент");
		Слова.Добавить("Сервер");
		Слова.Добавить("ТолстыйКлиентУправляемоеПриложение");
		Слова.Добавить("ТолстыйКлиентОбычноеПриложение");
		Слова.Добавить("ТонкийКлиент");
		Слова.Добавить("ВебКлиент");
		Слова.Добавить("МобильныйКлиент");
		Слова.Добавить("ВнешнееСоединение");
		Для Каждого Слово Из Слова Цикл
			мПлатформа.ДобавитьВТаблицуСлов(ТаблицаСлов, Слово, "Конструкция",, "", "Предопределенный");
		КонецЦикла; 
		мСтруктураТипаКонтекста.ИмяОбщегоТипа = "";
		мСтруктураТипаКонтекста.ТипЯзыка = "Препроцессор";
	ИначеЕсли Истина
		И мЯзыкПрограммы = 1 
		И мЭтоОбъявлениеПсевдонима 
		И ВыбраннаяСтруктураТипа.ТипЯзыка = ""
	Тогда
		мРегВыражение.Pattern = "(" + шОбъектноеВыражение + ")\s+(КАК|AS)\s+(?:" + шИмя + ")?$";
		Результат = мРегВыражение.НайтиВхождения(мТекущаяСтрокаНачало);
		Если Результат.Количество() > 0 Тогда
			ПервоеВхождение = Результат[0].SubMatches(0); 
			ВхожденияИмен = ирОбщий.НайтиРегВыражениеЛкс(ПервоеВхождение, шИмяСТочками,,,,,, Истина);
			Для Каждого ВхождениеИмени Из ВхожденияИмен Цикл
				Если Найти(ВхождениеИмени.ТекстВхождения, ".") = 0 Тогда
					Продолжить;
				КонецЕсли;
				Фрагменты = ирОбщий.СтрРазделитьЛкс(ВхождениеИмени.ТекстВхождения);
				Пока Фрагменты.Количество() > 0 Цикл
					мПлатформа.ДобавитьВТаблицуСлов(ТаблицаСлов, ирОбщий.СтрСоединитьЛкс(Фрагменты, ""), "Свойство",, "", "Локальный");
					Фрагменты.Удалить(0);
				КонецЦикла;
			КонецЦикла;
		КонецЕсли;
		мСтруктураТипаКонтекста.ИмяОбщегоТипа = "";
	Иначе
		КоллекцияЭлементовМД = Новый Массив;
		Если мЭтоТекстовыйЛитерал И ВыбраннаяСтруктураТипа.ТипЯзыка <> "ИмяТипа" Тогда
			КонтекстТекстовогоЛитералаИзвестен = Истина;
			мРекурсивныйПуть = Неопределено;
			СтараяТекущаяПозиция = мПозицияВТексте;
			СтарыйМетод = мМетодМодуля;
			ИмяПараметра = "";
			КоллекцияЭлементовМД = ЗаполнитьТаблицуСловДляТекстовогоЛитерала(ВыбраннаяСтруктураТипа, КонтекстТекстовогоЛитералаИзвестен, ИмяПараметра);
			Если ЗначениеЗаполнено(ИмяПараметра) Тогда
				ПерезагрузитьКонтекстЕслиПозицияИзменилась(СтараяТекущаяПозиция, СтарыйМетод); // 10мс // TODO для неизмененной позиции и метода платформы - убрать лишние действия
			КонецЕсли;
			Если Истина
				И Не КонтекстТекстовогоЛитералаИзвестен
				И КоллекцияЭлементовМД.Количество() > 0 
			Тогда
				Если мПлатформа.мРежимПроверкиМодуля Тогда 
					КоллекцияЭлементовМД.Очистить();
				Иначе 
					КонтекстТекстовогоЛитералаИзвестен = Истина;
				КонецЕсли;
			КонецЕсли;
			мСтруктураТипаКонтекста.ТипЯзыка = ВыбраннаяСтруктураТипа.ТипЯзыка;
			Если мЭтоТекстовыйЛитерал Тогда // Может измениться в ЗаполнитьТаблицуСловДляТекстовогоЛитерала()
				мСтруктураТипаКонтекста.ИмяОбщегоТипа = "Строка";
			КонецЕсли;
		ИначеЕсли Истина
			И мЭтоТекстовыйЛитерал 
			И ВыбраннаяСтруктураТипа.ТипЯзыка = "ИмяТипа" 
			И мИмяМетодаВызова = "Тип"
		Тогда 
			// TODO Перенести в ЗаполнитьТаблицуСловДляТекстовогоЛитерала
			КонтекстТекстовогоЛитералаИзвестен = Истина;
			ПолеТекстаПрограммыВызова = КопияКомпоненты();
			#Если Сервер И Не Сервер Тогда
				ПолеТекстаПрограммыВызова = Обработки.ирКлсПолеТекстаПрограммы.Создать();
			#КонецЕсли
			ПолеТекстаПрограммыВызова.РазобратьТекущийКонтекст(,, Истина, мНачальнаяСтрока, мНачальнаяКолонка - СтрДлина(мВызовМетода + мНачалоСлова), Истина);
			Если Истина
				И ПолеТекстаПрограммыВызова.мИмяМетодаВызова = "Добавить" 
				//И ПолеТекстаПрограммыВызова.мНомерПараметра = 1 // 1 не подходит для Форма.Элементы
			Тогда 
				ТаблицаТипов = ПолеТекстаПрограммыВызова.ВычислитьТипЗначенияВыражения(ПолеТекстаПрограммыВызова.мВызовМетода, ПолеТекстаПрограммыВызова.мТекстДляПоискаОпределения);
				Если ТаблицаТипов.Количество() > 1 Тогда
					мСтруктураТипаКонтекста.ИмяОбщегоТипа = "Строка";
					мСтруктураТипаКонтекста.ТипЯзыка = "ИмяТипа";
					ВыбраннаяСтруктураТипа.ТипЯзыка = "ИмяТипа";
					Для Каждого СтруктураТипаЭлемента Из ТаблицаТипов Цикл
						СтрокаСлова = ТаблицаСлов.Добавить();
						СтрокаСлова.Слово = СтруктураТипаЭлемента.ИмяОбщегоТипа;
						СтрокаСлова.ТипСлова = "Свойство";
						СтрокаСлова.Определение = "Предопределенный";
					КонецЦикла; 
				КонецЕсли;
			ИначеЕсли Истина
				И ПолеТекстаПрограммыВызова.мИмяМетодаВызова = "Выполнить" // КомпоновщикМакетаКомпоновкиДанных.Выполнить()
				И ПолеТекстаПрограммыВызова.мНомерПараметра = 5
			Тогда 
				ТаблицаТипов = ПолеТекстаПрограммыВызова.ВычислитьТипЗначенияВыражения(ПолеТекстаПрограммыВызова.мВызовМетода, ПолеТекстаПрограммыВызова.мТекстДляПоискаОпределения);
				Если Истина
					И ТаблицаТипов.Количество() > 0
					И ТипЗнч(ТаблицаТипов[0].СтрокаОписания) = Тип("СтрокаТаблицыЗначений") 
					И ТаблицаТипов[0].СтрокаОписания.Владелец().Колонки.Найти("ТипКонтекста") <> Неопределено
					И ТаблицаТипов[0].СтрокаОписания.ТипКонтекста = "КомпоновщикМакетаКомпоновкиДанных" 
				Тогда
					МассивИменТипов = Новый Массив;
					МассивИменТипов.Добавить("ГенераторМакетаКомпоновкиДанных");
					МассивИменТипов.Добавить("ГенераторМакетаКомпоновкиДанныхДляКоллекцииЗначений");
					Для Каждого ИмяТипа Из МассивИменТипов Цикл
						СтрокаСлова = ТаблицаСлов.Добавить();
						СтрокаСлова.Слово = ИмяТипа;
						СтрокаСлова.ТипСлова = "Свойство";
						СтрокаСлова.Определение = "Предопределенный";
					КонецЦикла;
				КонецЕсли;
			КонецЕсли; 
			Если ТаблицаСлов.Количество() = 0 Тогда
				ЗаполнитьЗначенияСвойств(мСтруктураТипаКонтекста, ВыбраннаяСтруктураТипа);
			КонецЕсли; 
		Иначе
			КонтекстТекстовогоЛитералаИзвестен = ВыбраннаяСтруктураТипа.ТипЯзыка = "ИмяТипа";
			Если Истина
				И мЯзыкПрограммы = 1 
				И (Ложь
					Или мЭтоЛокальныйКонтекстТаблицыСлов
					Или ВыбраннаяСтруктураТипа.ИмяОбщегоТипа = "")
			Тогда 
				Если Истина
					И ВыбраннаяСтруктураТипа.ТипЯзыка = "ИмяТипа"
					И Не мТолькоСсылочныеИменаТипов
				Тогда
					ИменаФиксированныхТипов = Новый Массив;
					ИменаФиксированныхТипов.Добавить("БУЛЕВО");
					ИменаФиксированныхТипов.Добавить("ДАТА");
					ИменаФиксированныхТипов.Добавить("СТРОКА");
					ИменаФиксированныхТипов.Добавить("ЧИСЛО");
					Для Каждого ЭлементКоллекцииМД Из ИменаФиксированныхТипов Цикл
						СтрокаСлова = ТаблицаСлов.Добавить();
						СтрокаСлова.Слово = ЭлементКоллекцииМД;
						СтрокаСлова.ТипСлова = "Свойство";
						СтрокаСлова.Определение = "Предопределенный";
						СтрокаСлова.ТипЗначения = "Тип";
					КонецЦикла;
				КонецЕсли; 
				Если ВыбраннаяСтруктураТипа.ТипЯзыка = "" Тогда
					Для Каждого ОписаниеТаблицы Из ДоступныеТаблицы.НайтиСтроки(Новый Структура("Тип, Схема", "ВременнаяТаблица", "")) Цикл
						СтрокаСлова = ТаблицаСлов.Добавить();
						СтрокаСлова.Слово = ОписаниеТаблицы.Имя;
						СтрокаСлова.ТипСлова = "Свойство";
						СтрокаСлова.Определение = "Локальный";
						СтрокаСлова.ТипЗначения = ОписаниеТаблицы.Тип;
					КонецЦикла;
					СтрокаСлова = ТаблицаСлов.Добавить();
					СтрокаСлова.Слово = СокрП(мМаркерПорядкаОтладки);
					СтрокаСлова.ТипСлова = "Конструкция";
				КонецЕсли;
			КонецЕсли; 
			ЗаполнитьЗначенияСвойств(мСтруктураТипаКонтекста, ВыбраннаяСтруктураТипа);
		КонецЕсли; 
		ДобавитьПростыеСлова(КоллекцияЭлементовМД);
		ДобавитьВТаблицуСловИменаМодуляИМетаданныхИТипов(ВыбраннаяСтруктураТипа, КонтекстТекстовогоЛитералаИзвестен, ДобавлятьНизкоВероятные);
		ЛиВнутриКомментария = ЛиВнутриКомментария();
		Если Истина
			И Не ЭтоГруппаОбщихМодулей 
			И (Ложь
				Или РазрешитьОткрытиеОкон
				Или мЭтоТекстовыйЛитерал 
				Или ЛиВнутриКомментария
				Или мЭтоЛокальныйКонтекстТаблицыСлов)
		Тогда
			мТаблицаТиповКонтекста = ирОбщий.ЗначенияВМассивЛкс(мСтруктураТипаКонтекста);
		ИначеЕсли мТаблицаТиповКонтекста.Количество() > 10 Тогда
			// Для ускорения. Если не урезать, то надо делать аналогично обобщенному типу ОбъектМетаданных: ИмяОбщегоТипаРодителяБезДеталей = "ОбъектМетаданных"
			Если мТаблицаТиповКонтекста[0].ИмяОбщегоТипа = "Диаграмма" Тогда
				мСтруктураТипаКонтекста = мПлатформа.НоваяСтруктураТипа("ТабличноеПоле");
			ИначеЕсли мТаблицаТиповКонтекста[0].ИмяОбщегоТипа = "АтрибутDOM" Тогда
				мСтруктураТипаКонтекста = мПлатформа.НоваяСтруктураТипа("ЭлементDOM"); 
			Иначе
				мСтруктураТипаКонтекста = мТаблицаТиповКонтекста[0];
			КонецЕсли;
			мТаблицаТиповКонтекста = ирОбщий.ЗначенияВМассивЛкс(мСтруктураТипаКонтекста);
		Иначе
			СтрокаТипаОбъектМетаданных = мТаблицаТиповКонтекста.Найти("ОбъектМетаданных", "ИмяОбщегоТипа"); 
			Если СтрокаТипаОбъектМетаданных <> Неопределено Тогда
				мТаблицаТиповКонтекста.Сдвинуть(СтрокаТипаОбъектМетаданных, -мТаблицаТиповКонтекста.Индекс(СтрокаТипаОбъектМетаданных));
			КонецЕсли;
		КонецЕсли;
		ДобавлятьЛокальныйКонтекст = Истина
			И мЭтоЛокальныйКонтекстТаблицыСлов
			И (Ложь
				Или Не мЭтоТекстовыйЛитерал
				Или мСтруктураТипаКонтекста.ТипЯзыка <> "" 
				Или РазрешитьОткрытиеОкон);
		БазовоеРасширениеКонфигурации = БазовоеРасширениеКонфигурации();
		Попытка
			Для Каждого СтруктураКонтекста Из мТаблицаТиповКонтекста Цикл
				ВыгрузкаТаблицыСлов = мПлатформа.ТаблицаСловИзСтруктурыТипа(СтруктураКонтекста, мЯзыкПрограммы, Конфигурация, ВнешниеФункцииКомпоновкиДанных, ВычислятьТипы, ЭтоГруппаОбщихМодулей,,
					?(мЭтоТекстовыйЛитерал И СтруктураКонтекста.ТипЯзыка <> "ИмяТипа", Неопределено, мФлагиКомпиляции),, МодульМетаданныхКонтекста(СтруктураКонтекста),, ВыгрузкаТаблицыСлов,
					ДобавлятьЛокальныйКонтекст, мНаборыСлов, БазовоеРасширениеКонфигурации); //  Мультметка481922915 ДобавлятьЛокальныйКонтекст Или ЛиВнутриКомментария 
			КонецЦикла;
			СловаДляУточненияТипа = ВыгрузкаТаблицыСлов.НайтиСтроки(Новый Структура("МожноУточнитьТип", Истина));
			Если ВычислятьТипы Или СловаДляУточненияТипа.Количество() < 50 Тогда
				Для Каждого ВнутренняяСтрокаСлова Из СловаДляУточненияТипа Цикл
					ОбновитьТипЗначенияИзТаблицыТипов(ВнутренняяСтрокаСлова, ВнутренняяСтрокаСлова.ТаблицаТипов, Ложь);
				КонецЦикла;
			КонецЕсли; 
			#Если Сервер И Не Сервер Тогда
				ВыгрузкаТаблицыСлов = Новый ТаблицаЗначений;
			#КонецЕсли
			Если Ложь
				Или мЭтоЛокальныйКонтекстТаблицыСлов
				Или мСтруктураТипаКонтекста.ИмяОбщегоТипа = "ВнешнийИсточникДанных.<Имя внешнего источника>.ВременнаяТаблица"
			Тогда
				Если ЯзыкПрограммы <> 0 И мЭтоЛокальныйКонтекстТаблицыСлов Тогда
					Для Каждого СтрокаСлова Из ТаблицаЛокальногоКонтекста("Свойство") Цикл
						НоваяСтрока = мПлатформа.ДобавитьВТаблицуСлов(ВыгрузкаТаблицыСлов, СтрокаСлова.Имя, "Свойство"); 
						Если Не ЗначениеЗаполнено(НоваяСтрока.Определение) Тогда
							НоваяСтрока.Определение = "Локальный";
						КонецЕсли;
						//Если ЗаполнятьТипы Тогда // Если откладывать вычисление типа, то потом через метод УточнитьТипЗначенияВСтрокеТаблицыСлов он не вычислится
							НоваяСтрока.ТипЗначения = мПлатформа.ПредставлениеМассиваСтруктурТипов(СтрокаСлова.ТаблицаТипов);
						//КонецЕсли; 
					КонецЦикла;
				КонецЕсли;
				ирОбщий.ДобавитьИндексВТаблицуЛкс(ВыгрузкаТаблицыСлов, "Слово, ТипСлова");
				Если мСтруктураТипаКонтекста.ИмяОбщегоТипа = "ВнешнийИсточникДанных.<Имя внешнего источника>.ВременнаяТаблица" Тогда
					Для Каждого СтрокаВременнойТаблицы Из ДоступныеТаблицы.НайтиСтроки(Новый Структура("Тип", "ВременнаяТаблица")) Цикл
						мПлатформа.ДобавитьВТаблицуСлов(ВыгрузкаТаблицыСлов, СтрокаВременнойТаблицы.Имя, "Свойство",, "ВременнаяТаблица", "Локальный");
					КонецЦикла;
				КонецЕсли;
			КонецЕсли;
			Если Истина
				И мЭтоЛокальныйКонтекстТаблицыСлов
				И мМетодМодуля <> Неопределено
			Тогда 
				ПараметрыМетодаМодуля = мПлатформа.ПараметрыМетодаМодуля(мМетодМодуля);
				Если ПараметрыМетодаМодуля <> Неопределено Тогда
					Для Каждого СтрокаПараметра Из ПараметрыМетодаМодуля Цикл 
						мПлатформа.ДобавитьВТаблицуСлов(ВыгрузкаТаблицыСлов, СтрокаПараметра.Имя, "Свойство",, ?(ПустаяСтрока(СтрокаПараметра.ТипЗначения), "??", СтрокаПараметра.ТипЗначения), "Локальный");
					КонецЦикла;
				КонецЕсли;
			КонецЕсли;  
			Если Истина
				И мЭтоЛокальныйКонтекстТаблицыСлов
				И мЯзыкПрограммы = 1
				И мПакетЗапросов <> Неопределено
			Тогда
				Для Каждого КлючИЗначение Из мПакетЗапросов.Параметры Цикл 
					ТипЗначения = СтрЗаменить(ПредставлениеМассиваСтруктурТипов(КлючИЗначение.Значение), "Ссылка.", ".");
					мПлатформа.ДобавитьВТаблицуСлов(ВыгрузкаТаблицыСлов, мПараметрыДиалектаSQL.ПрефиксПараметра + КлючИЗначение.Ключ, "Свойство", КлючИЗначение.Значение, ТипЗначения, "Локальный");
				КонецЦикла;
			КонецЕсли;  
			Если Истина
				И мЯзыкПрограммы = 0
				И Не мЭтоТекстовыйЛитерал
				И мЭтоЛокальныйКонтекстТаблицыСлов
				И мМодульМетаданных <> Неопределено
				И мПлатформа.ЛиИмяМодуляФормы(мИмяМодуля)
				И (Ложь
					Или мМетодМодуля = Неопределено
					Или мПозицияВТексте < мМетодМодуля.ПозицияОпределения)
			Тогда
				ДирективыКомпиляцииТипаМодуля = Новый Массив;
				ДирективыКомпиляцииТипаМодуля.Добавить("НаСервере");
				ДирективыКомпиляцииТипаМодуля.Добавить("НаКлиенте");
				ДирективыКомпиляцииТипаМодуля.Добавить("НаКлиентеНаСервереБезКонтекста");
				ДирективыКомпиляцииТипаМодуля.Добавить("НаСервереБезКонтекста");
				Для Каждого Директива Из ДирективыКомпиляцииТипаМодуля Цикл
					мПлатформа.ДобавитьВТаблицуСлов(ВыгрузкаТаблицыСлов, "&" + Директива, "Конструкция",, "", "Предопределенный");
				КонецЦикла;
			КонецЕсли;
			Если Истина
				И мСтруктураТипаКонтекста.ИмяОбщегоТипа = "МенеджерВременныхТаблиц" 
				И мСтруктураТипаКонтекста.ТипЯзыка = "" 
			Тогда 
				мПлатформа.ДобавитьВТаблицуСлов(ТаблицаСлов, "докДобавить", "Метод",, Неопределено, "Локальный");
			КонецЕсли;
			ирОбщий.ЗагрузитьВТаблицуЗначенийЛкс(ВыгрузкаТаблицыСлов, ТаблицаСлов);
		Исключение
			Ошибка = ИнформацияОбОшибке();
			Если Ошибка.Описание = "ОшибкаВычисленияВиртуальнойТаблицы" Тогда 
				Возврат Ложь;
			КонецЕсли;
			ВызватьИсключение;
		КонецПопытки;
		СтруктураКлюча = Новый Структура("ТипКонтекста, ЯзыкПрограммы, ТипЯзыка",
			мСтруктураТипаКонтекста.ИмяОбщегоТипа, мЯзыкПрограммы, мСтруктураТипаКонтекста.ТипЯзыка);
		ДобавлятьСтатистическиеСлова = Ложь
			Или ЗначениеЗаполнено(мРодительскийКонтекст)
			//Или мСтруктураТипаКонтекста.ИмяОбщегоТипа = "НеизвестныйКонтекст" // Дает мусор при спуске через ЗаполнитьТаблицуСловДляТекстовогоЛитерала
			Или ЛиВЗаголовкеМетода
			Или ДобавлятьЛокальныйКонтекст
			Или мПлатформа.ТаблицаШаблоновКонтекстов.НайтиСтроки(СтруктураКлюча).Количество() > 0;
	КонецЕсли;
	ЗаполнитьСловаВНижнемРегистре();
	Если РазрешитьОткрытиеОкон Или ВычислятьТипы Или ДобавлятьСтатистическиеСлова Тогда
		Если ДобавлятьСтатистическиеСлова Тогда
			ЗаполнитьЛокальныеСвойстваИМетодыПоТексту(Ложь, Не мЭтоТекстовыйЛитерал И Не ЗначениеЗаполнено(мРодительскийКонтекст), Истина, Ложь,,,,, Не ЛиВЗаголовкеМетода);
			//Если Истина
			//	И _УдалитьФункциюНовый // https://www.hostedredmine.com/issues/963017
			//	И мЭтоЛокальныйКонтекст
			//Тогда
			//	СтрокаСловаНовый = ТаблицаСлов.НайтиСтроки(Новый Структура("Слово, ТипСлова", "Новый", "Метод"));
			//	Если СтрокаСловаНовый.Количество() > 0 Тогда
			//		ТаблицаСлов.Удалить(СтрокаСловаНовый[0]);
			//	КонецЕсли;
			//КонецЕсли;
		КонецЕсли;
		Если Прав(мТекущееСлово, 1) = "(" Тогда 
			ЧистоеТекущееСлово = Лев(мТекущееСлово, СтрДлина(мТекущееСлово) - 1);
			ТипТекущегоСлова = "Метод";
		Иначе
			ЧистоеТекущееСлово = мТекущееСлово;
			ТипТекущегоСлова = "Свойство";
		КонецЕсли;
		КлючПоиска = Новый Структура("НСлово, Определение, ТипСлова", НРег(ЧистоеТекущееСлово), "Статистический", ТипТекущегоСлова);
		НайденныеСтроки = ТаблицаСлов.НайтиСтроки(КлючПоиска);
		Если НайденныеСтроки.Количество() > 0 Тогда
			НайденнаяСтрока = НайденныеСтроки[0];
			НайденнаяСтрока.Частота = НайденнаяСтрока.Частота - 1;
			Если НайденнаяСтрока.Частота = 0 Тогда
				ТаблицаСлов.Удалить(НайденнаяСтрока);
			КонецЕсли;
		КонецЕсли;
		ТаблицаСлов.Свернуть("НСлово, Слово, ТипСлова, Определение, ТипЗначения", "Частота");
	КонецЕсли;
	РассчитатьОжидаемыйТипВТаблицеСлов(ОтделятьБольшиеНаборыСлов);
	Если Сортировать Тогда
		ТаблицаСлов.Сортировать("НСлово, ТипСлова, Определение, ТипЗначения, Частота");
	КонецЕсли;
	ТаблицаТиповКонтекста.Очистить(); // Нужно для прерывания циклического выбора слова автодополнения
	выхЕстьЛучшееСлово = мСтрокаЛучшегоСлова <> Неопределено;
	Возврат Истина;
КонецФункции

//.
// Параметры:
//    ВыбраннаяСтруктураТипа - СтрокаТаблицыЗначений - 
//    КонтекстТекстовогоЛитералаИзвестен - Булево - 
//    ДобавлятьНизкоВероятные - Булево -  
Процедура ДобавитьВТаблицуСловИменаМодуляИМетаданныхИТипов(Знач ВыбраннаяСтруктураТипа, Знач КонтекстТекстовогоЛитералаИзвестен, Знач ДобавлятьНизкоВероятные = Ложь) Экспорт
	КоллекцияЭлементовМД = Новый Массив; 
	Если ЗначениеЗаполнено(мРодительскийКонтекст) Тогда
		ПервоеСловоРодителя = ирОбщий.ПервыйФрагментЛкс(мРодительскийКонтекст);
	КонецЕсли;
	ЛиИмяМетода = Ложь
		Или ВыбраннаяСтруктураТипа.ТипЯзыка = "ИмяМетода"
		Или ВыбраннаяСтруктураТипа.ТипЯзыка = "ИмяПроцедуры"
		Или ВыбраннаяСтруктураТипа.ТипЯзыка = "ИмяФункции";
	
	// Имена типов и метаданных внутри комментария и текстового литерала
	Если Истина
		И мСтруктураТипаКонтекста.ТипЯзыка <> "ИмяТипа"
		И Не ЛиИмяМетода
		И (Ложь
			Или ЛиВнутриКомментария() 
			Или мЭтоТекстовыйЛитерал)
	Тогда  
		// Имена метаданных
		Если Ложь
			Или ВыбраннаяСтруктураТипа.ТипЯзыка = "Местоположение" 
			Или Найти(ВыбраннаяСтруктураТипа.ТипЯзыка, "ИмяФормы") > 0
			Или Найти(ВыбраннаяСтруктураТипа.ТипЯзыка, "ПолноеИмя") > 0  
			Или (Истина
				И ВыбраннаяСтруктураТипа.ТипЯзыка <> "ИмяПредопределенногоЗначения"
				И ирОбщий.МножественноеИмяМДЛкс(ПервоеСловоРодителя) <> Неопределено)
			Или (Истина
				//И ВыбраннаяСтруктураТипа.ТипЯзыка = "" 
				И Не КонтекстТекстовогоЛитералаИзвестен
				И ДобавлятьНизкоВероятные)
		Тогда
			Если ВыбраннаяСтруктураТипа.ТипЯзыка = "Местоположение" Тогда
				КонтекстТекстовогоЛитералаИзвестен = Истина;
				ИмяДочернегоТипаМД = "Макет";
				ИмяКорневогоТипаМД = "ОбщийМакет";
			ИначеЕсли Ложь
				Или Найти(ВыбраннаяСтруктураТипа.ТипЯзыка, "ИмяФормы") > 0
				Или ирОбщий.СтрокиРавныЛкс(ПервоеСловоРодителя, "ОбщаяФорма") > 0
			Тогда 
				КонтекстТекстовогоЛитералаИзвестен = Истина;
				ИмяДочернегоТипаМД = "Форма";
				ИмяКорневогоТипаМД = "ОбщаяФорма";
			Иначе
				Если Истина
					И ЗначениеЗаполнено(ирОбщий.МножественноеИмяМДЛкс(ПервоеСловоРодителя)) 
					И Не ЗначениеЗаполнено(ВыбраннаяСтруктураТипа.ТипЯзыка)
				Тогда 
					ВыбраннаяСтруктураТипа.ТипЯзыка = "ИмяМетаданных";
					мСтруктураТипаКонтекста.ТипЯзыка = ВыбраннаяСтруктураТипа.ТипЯзыка;
				КонецЕсли;
				ИмяКорневогоТипаМД = "";
				ИмяДочернегоТипаМД = "";
			КонецЕсли; 
			Если Ложь
				Или КонтекстТекстовогоЛитералаИзвестен
				Или Не мПлатформа.мРежимПроверкиМодуля
			Тогда
				Если ЗначениеЗаполнено(мРодительскийКонтекст) Тогда
					ВычислятьСловаФормы = Ложь;
					ПервоеСловоРодителя = ирОбщий.ПервыйФрагментЛкс(мРодительскийКонтекст);
					Если Истина
						И ЗначениеЗаполнено(ПервоеСловоРодителя)
						И ирОбщий.СтрокиРавныЛкс(ИмяКорневогоТипаМД, ПервоеСловоРодителя) 
					Тогда
						Если СтрЧислоВхождений(мРодительскийКонтекст, ".") = 0 Тогда
							Для Каждого МетаМакет Из Метаданные[ирОбщий.МножественноеИмяМДЛкс(ИмяКорневогоТипаМД)] Цикл
								КоллекцияЭлементовМД.Добавить(МетаМакет.Имя);
							КонецЦикла;
						ИначеЕсли ИмяДочернегоТипаМД = "Форма" Тогда
							ВычислятьСловаФормы = Истина;
						КонецЕсли; 
					Иначе
						Если СтрЧислоВхождений(мРодительскийКонтекст, ".") = 0 Тогда
							Если Истина
								И ирОбщий.СтрНачинаетсяСЛкс(мРодительскийКонтекст, "Внешн")
								И ирОбщий.СтрНачинаетсяСЛкс(мМодульМетаданных.СтруктураТипа.ДержательМетаданных, "Внешн")
							Тогда
								КоллекцияЭлементовМД.Добавить(мМодульМетаданных.СтруктураТипа.ДержательМетаданных.Метаданные().Имя);
							Иначе
								КорневойТип = ПервоеСловоРодителя;
								МножественноеИмяМД = ирОбщий.МножественноеИмяМДЛкс(КорневойТип);
								Если МножественноеИмяМД <> Неопределено Тогда
									Попытка
										КоллекцияМД = Метаданные[МножественноеИмяМД];
									Исключение
										КоллекцияМД = Новый Массив;
									КонецПопытки;
									Для Каждого МетаОбъект Из КоллекцияМД Цикл
										КоллекцияЭлементовМД.Добавить(МетаОбъект.Имя);
									КонецЦикла;
								КонецЕсли; 
							КонецЕсли;
						ИначеЕсли СтрЧислоВхождений(мРодительскийКонтекст, ".") = 1 Тогда
							Если ЗначениеЗаполнено(ИмяДочернегоТипаМД) Тогда
								КоллекцияЭлементовМД.Добавить(ИмяДочернегоТипаМД);
								Если ИмяДочернегоТипаМД = "Форма" Тогда 
									ВсеИменаСтандартныхФорм = мПлатформа.ВсеИменаСтандартныхФорм();
									Если ВсеИменаСтандартныхФорм.Свойство(ПервоеСловоРодителя) Тогда
										Для Каждого ЭлементСписка Из ВсеИменаСтандартныхФорм[ПервоеСловоРодителя] Цикл
											КоллекцияЭлементовМД.Добавить(ЭлементСписка.Значение);
										КонецЦикла;
									КонецЕсли;
									Если ирОбщий.ЛиКорневойТипТаблицыБДЛкс(ПервоеСловоРодителя) Тогда
										Если ирКэш.НомерВерсииПлатформыЛкс() > 803020 Тогда
											КоллекцияЭлементовМД.Добавить("ФормаИсторииИзмененийИсторииДанных");
											КоллекцияЭлементовМД.Добавить("ФормаДанныхВерсииИсторииДанных");
											КоллекцияЭлементовМД.Добавить("ФормаРазличийВерсийИсторииДанных");
										КонецЕсли;
									КонецЕсли;
								КонецЕсли;
							Иначе
								ТипыДочерние = ирКэш.ТипыМетаОбъектов().НайтиСтроки(Новый Структура("Категория", 2));
								Для Каждого СтрокаТипаМетаОбъекта Из ТипыДочерние Цикл
									ОтборСвойств = Новый Структура("ТипКонтекста, ЯзыкПрограммы, ТипЯзыка, НСлово, ТипСлова", 
											"ОбъектМетаданных" + ПервоеСловоРодителя, 0, "", НРег(СтрокаТипаМетаОбъекта.Множественное), "Свойство");
									Если мПлатформа.ТаблицаКонтекстов.НайтиСтроки(ОтборСвойств).Количество() = 0 Тогда 
										Продолжить;
									КонецЕсли;
									КоллекцияЭлементовМД.Добавить(СтрокаТипаМетаОбъекта.Единственное);
								КонецЦикла;
							КонецЕсли;
						ИначеЕсли СтрЧислоВхождений(мРодительскийКонтекст, ".") = 2 Тогда
							Если Истина
								И ирОбщий.СтрНачинаетсяСЛкс(мРодительскийКонтекст, "Внешн")
								И ирОбщий.СтрНачинаетсяСЛкс(мМодульМетаданных.СтруктураТипа.ДержательМетаданных, "Внешн")
							Тогда
								ОбъектМД = мМодульМетаданных.СтруктураТипа.ДержательМетаданных.Метаданные();
							Иначе
								ОбъектМД = Метаданные.НайтиПоПолномуИмени(ирОбщий.СтрокаБезПоследнегоФрагментаЛкс(мРодительскийКонтекст, "."));
							КонецЕсли;
							#Если Сервер И Не Сервер Тогда
							ОбъектМД = Метаданные.Справочники.Валюты;
							#КонецЕсли
							Если ОбъектМД <> Неопределено Тогда
								ИмяМножественное = ирОбщий.МножественноеИмяМДЛкс(ирОбщий.ПоследнийФрагментЛкс(мРодительскийКонтекст));
								Если ИмяМножественное <> Неопределено Тогда
									Для Каждого МетаМакет Из ОбъектМД[ИмяМножественное] Цикл
										КоллекцияЭлементовМД.Добавить(МетаМакет.Имя);
									КонецЦикла;
								КонецЕсли;
							КонецЕсли;
						Иначе
							ВычислятьСловаФормы = Истина;
						КонецЕсли; 
					КонецЕсли; 
					Если ВычислятьСловаФормы Тогда
						СтруктураТипаКонтекста = ВычислитьСловоФормыПоПолномуИмени(мРодительскийКонтекст);
						Если СтруктураТипаКонтекста <> Неопределено Тогда
							мСтруктураТипаКонтекста = СтруктураТипаКонтекста; 
						КонецЕсли;
					КонецЕсли;
				Иначе
					Для Каждого СтрокаТипаМетаОбъекта Из ирКэш.ТипыМетаОбъектов(Истина, Ложь) Цикл
						НадоДобавить = Ложь
							Или Не ЗначениеЗаполнено(ИмяКорневогоТипаМД) 
							Или ИмяКорневогоТипаМД = СтрокаТипаМетаОбъекта.Единственное;
						Если Истина
							И Не НадоДобавить 
							И мМодульМетаданных.СтруктураТипа <> Неопределено 
							И ирОбщий.ЛиФормаИлиИмитаторЛкс(мМодульМетаданных.СтруктураТипа.Метаданные, Ложь)
						Тогда
							НадоДобавить = Ложь
								Или (Истина
									И СтрокаТипаМетаОбъекта.Единственное = "ВнешняяОбработка" 
									И ирОбщий.СтрНайтиЛкс(мМодульМетаданных.СтруктураТипа.Метаданные.ИмяФормы, ".epf") > 0)
								Или (Истина
									И СтрокаТипаМетаОбъекта.Единственное = "ВнешнийОтчет" 
									И ирОбщий.СтрНайтиЛкс(мМодульМетаданных.СтруктураТипа.Метаданные.ИмяФормы, ".erf") > 0);
						КонецЕсли;
						Если Не НадоДобавить Тогда
							ОтборСвойств = Новый Структура("ТипКонтекста, ЯзыкПрограммы, ТипЯзыка, НСлово, ТипСлова", 
									"ОбъектМетаданных" + СтрокаТипаМетаОбъекта.Единственное, 0, "", НРег(ирОбщий.МножественноеИмяМДЛкс(ИмяДочернегоТипаМД)), "Свойство");
							НадоДобавить = мПлатформа.ТаблицаКонтекстов.НайтиСтроки(ОтборСвойств).Количество() > 0;
						КонецЕсли; 
						Если НадоДобавить Тогда 
							КоллекцияЭлементовМД.Добавить(СтрокаТипаМетаОбъекта.Единственное);
						КонецЕсли; 
					КонецЦикла;
				КонецЕсли;
			КонецЕсли;
		КонецЕсли;
	КонецЕсли;
	Если Ложь
		Или ЛиИмяМетода И Не КонтекстТекстовогоЛитералаИзвестен
		Или мЭтоТекстовыйЛитерал И Не КонтекстТекстовогоЛитералаИзвестен
		Или (Истина
			И ЛиВнутриКомментария() 
			И ирОбщий.СтрКончаетсяНаЛкс(мТекущаяСтрокаНачало, "см. " + мНачалоКонтекста))
	Тогда
		Если Не КонтекстТекстовогоЛитералаИзвестен Тогда
			КонтекстТекстовогоЛитералаИзвестен = ЛиИмяМетода;
		КонецЕсли;
		ИменаТиповМетаданныхСМенеджерами = мПлатформа.ИменаТиповМетаданныхСМенеджерами();
		Если ЗначениеЗаполнено(мРодительскийКонтекст) Тогда
			ЛиИмяОбщегоМодуля = Метаданные.ОбщиеМодули.Найти(мРодительскийКонтекст) <> Неопределено;
			ЛиИмяМножественноеМетаданных = Истина
				И ЗначениеЗаполнено(мРодительскийКонтекст)
				И СтрЧислоВхождений(мРодительскийКонтекст, ".") < 2
				И ирОбщий.ЛиИмяПеременнойЛкс(ПервоеСловоРодителя)
				И ИменаТиповМетаданныхСМенеджерами.Свойство(ПервоеСловоРодителя);
			Если ЛиИмяОбщегоМодуля Тогда
				КонтекстТекстовогоЛитералаИзвестен = Истина;
				мСтруктураТипаКонтекста.ТипЯзыка = "ИмяМетода";
				мСтруктураТипаКонтекста.ИмяОбщегоТипа = "ОбщийМодуль";
				мСтруктураТипаКонтекста.Метаданные = Метаданные.ОбщиеМодули.Найти(мРодительскийКонтекст);
				// Дублирует работу основного добавления слов
				//ВнутренняяТаблицаСлов = мПлатформа.СловаКонтекстаМетаданные(мСтруктураТипаКонтекста,, "Метод",,,,,, мПлатформа.НовыеФлагиКомпиляции(, Ложь, Ложь),,,,,, БазовоеРасширениеКонфигурации());
				//ЗагрузитьВТаблицуСловИзВнутреннейТаблицыСлов(ВнутренняяТаблицаСлов, ТаблицаСлов);
			ИначеЕсли ЛиИмяМножественноеМетаданных Тогда 
				КонтекстТекстовогоЛитералаИзвестен = Истина;
				ЕдинственноеИмяМД = ирОбщий.ЕдинственноеИмяМДЛкс(ПервоеСловоРодителя);
				Если СтрЧислоВхождений(мРодительскийКонтекст, ".") = 0 Тогда 
					мСтруктураТипаКонтекста.ТипЯзыка = ЕдинственноеИмяМД;
					Для Каждого ОбъектМД Из Метаданные[мРодительскийКонтекст] Цикл
						КоллекцияЭлементовМД.Добавить(ОбъектМД.Имя);
					КонецЦикла;
				Иначе 
					мСтруктураТипаКонтекста = мПлатформа.СтруктураТипаИзКонкретногоТипа(Тип(ЕдинственноеИмяМД + "Менеджер." + ирОбщий.ПоследнийФрагментЛкс(мРодительскийКонтекст)));
					// Дублирует работу основного добавления слов
					//ВнутренняяТаблицаСлов = мПлатформа.СловаКонтекстаМетаданные(мСтруктураТипаКонтекста,, "Метод",,,,,, мПлатформа.НовыеФлагиКомпиляции(, Ложь, Ложь),,,,,, БазовоеРасширениеКонфигурации());
					//ЗагрузитьВТаблицуСловИзВнутреннейТаблицыСлов(ВнутренняяТаблицаСлов, ТаблицаСлов);
				КонецЕсли;
				мСтруктураТипаКонтекста.ТипЯзыка = "ИмяМетода";
			ИначеЕсли Найти(мРодительскийКонтекст, "(") = 0 Тогда
				ТаблицаТипов = ВычислитьТипЗначенияВыражения(мРодительскийКонтекст + "(",,,,,, Ложь);
				Если ТаблицаТипов.Количество() > 0 Тогда
					СтрокаМетода = ТаблицаТипов[0].СтрокаОписания; // см. мПлатформа.НоваяТаблицаМетодовМодуля()[0]
					Если Истина
						И ТипЗнч(СтрокаМетода) = Тип("СтрокаТаблицыЗначений") 
						И СтрокаМетода.Владелец().Колонки.Найти("ЛиЭкспорт") <> Неопределено
						И СтрокаМетода.Имя <> "<>"
					Тогда
						ПараметрыМетода = мПлатформа.ПараметрыМетодаМодуля(СтрокаМетода);
						Для Каждого СтрокаПараметра Из ПараметрыМетода Цикл
							СтрокаСлова = ТаблицаСлов.Добавить();
							СтрокаСлова.Слово = СтрокаПараметра.Имя;
							СтрокаСлова.НСлово = СтрокаПараметра.НИмя;
							СтрокаСлова.Определение = "Метаданные";
							СтрокаСлова.ТипСлова = "Свойство";
						КонецЦикла;
						мСтруктураТипаКонтекста.ТипЯзыка = "ИмяПараметраМетода";
					КонецЕсли;
				КонецЕсли;
			КонецЕсли;
		ИначеЕсли Истина
			И Не ЛиВнутриКомментария()
			И ДобавлятьНизкоВероятные 
		Тогда 
			Для Каждого КлючИЗначение Из ирКэш.ДоступныеОбщиеМодулиЛкс(Истина, Истина, Истина) Цикл
				КоллекцияЭлементовМД.Добавить(КлючИЗначение.Значение.Имя);
			КонецЦикла;
			Для Каждого КлючИЗначение Из ИменаТиповМетаданныхСМенеджерами Цикл
				КоллекцияЭлементовМД.Добавить(КлючИЗначение.Ключ);
			КонецЦикла;
			Для Каждого СтрокаМетода Из мМодульМетаданных.Методы Цикл
				Если СтрокаМетода.имя = "<>" Тогда
					Продолжить;
				КонецЕсли;
				КоллекцияЭлементовМД.Добавить(СтрокаМетода.Имя);
			КонецЦикла;
		КонецЕсли; 
	КонецЕсли;
	
	Если Истина
		И мСтруктураТипаКонтекста.ТипЯзыка <> "ИмяТипа"
		И (Ложь
			Или ЛиВнутриКомментария() 
			Или мЭтоТекстовыйЛитерал)
	Тогда 
		// Имена типов без второго уровня
		Если Истина
			И Не ЗначениеЗаполнено(мРодительскийКонтекст) 
			И Не КонтекстТекстовогоЛитералаИзвестен
			И ДобавлятьНизкоВероятные 
		Тогда 
			СтруктураТипаИменТипов = мПлатформа.НоваяСтруктураТипа("");
			СтруктураТипаИменТипов.ТипЯзыка = "ИмяТипа";
			СтруктураТипаИменТипов.Метаданные = Метаданные;
			ТаблицаИменТипов = мПлатформа.ТаблицаСловИзСтруктурыТипа(СтруктураТипаИменТипов, мЯзыкПрограммы, Конфигурация, ВнешниеФункцииКомпоновкиДанных,,,, мФлагиКомпиляции,,,,,, мНаборыСлов, БазовоеРасширениеКонфигурации());
			ирОбщий.ЗагрузитьВТаблицуЗначенийЛкс(ТаблицаИменТипов, ТаблицаСлов); 
			Если ЛиВнутриКомментария() Тогда
				ТаблицаИменТипов = мПлатформа.ТаблицаОбщихТипов.Скопировать(Новый Структура("ЯзыкПрограммы, ТипТипа, ИД", мЯзыкПрограммы, "Расширение", ""), "Слово, НСлово");
				ТаблицаИменТипов.Колонки.Добавить("ТипСлова");
				ТаблицаИменТипов.Колонки.Добавить("ТипЗначения");
				ТаблицаИменТипов.Колонки.Добавить("Определение");
				ТаблицаИменТипов.ЗаполнитьЗначения("Свойство", "ТипСлова");
				Если мНаборыСлов <> Неопределено Тогда
					мНаборыСлов.Вставить("ВиртуальныеТипы", ТаблицаИменТипов);
				Иначе 
					// 15-20мс
					ирОбщий.ЗагрузитьВТаблицуЗначенийЛкс(ТаблицаИменТипов, ТаблицаСлов);
				КонецЕсли;
			КонецЕсли;
		ИначеЕсли ЗначениеЗаполнено(мРодительскийКонтекст) Тогда 
			СтрокаОбщегоТипа = мПлатформа.ТаблицаОбщихТипов.НайтиСтроки(Новый Структура("БазовыйТип, ЯзыкПрограммы", ирОбщий.ПервыйФрагментЛкс(мРодительскийКонтекст), мЯзыкПрограммы));
			Если СтрокаОбщегоТипа.Количество() > 0 Тогда
				СтрокаОбщегоТипа = СтрокаОбщегоТипа[0];
				Если Найти(СтрокаОбщегоТипа.Слово, "<") > 0 Тогда
					ТаблицаТипов = ВычислитьТипЗначенияВыражения(мРодительскийКонтекст, , "Тип(""", Истина,,,,,,,,, "Тип");
					Если ТаблицаТипов.Количество() > 0 Тогда
						// ОбработкаОбъект.Х.
						мСтруктураТипаКонтекста = ТаблицаТипов[0];
						ВыбраннаяСтруктураТипа.ТипЯзыка = "ИмяТипа";
						мСтруктураТипаКонтекста.ТипЯзыка = ВыбраннаяСтруктураТипа.ТипЯзыка; 
						Если Найти(мРодительскийКонтекст, ".") = 0 Тогда
							мСтруктураТипаКонтекста.Метаданные = Метаданные;
						КонецЕсли;
					КонецЕсли;
				КонецЕсли;
			КонецЕсли;
		КонецЕсли;
		
		// Имена БД
		КорневоеСловоБД = "БД";
		Если Истина
			И Не ЗначениеЗаполнено(мРодительскийКонтекст) 
			И Не КонтекстТекстовогоЛитералаИзвестен
			И ДобавлятьНизкоВероятные 
		Тогда 
			СтрокаСлова = ТаблицаСлов.Добавить();
			СтрокаСлова.Слово = КорневоеСловоБД;
			СтрокаСлова.ТипСлова = "Свойство";
		ИначеЕсли ирОбщий.СтрокиРавныЛкс(ПервоеСловоРодителя, КорневоеСловоБД) Тогда
			мЯзыкПрограммы = 1;
			СтруктураТипаИменБД = ВычислитьТипЗначенияВыражения(Сред(мРодительскийКонтекст, СтрДлина(КорневоеСловоБД + ".") + 1))[0];
			ТаблицаСловБД = мПлатформа.ТаблицаСловИзСтруктурыТипа(СтруктураТипаИменБД, 1, Конфигурация, ВнешниеФункцииКомпоновкиДанных,,,, мФлагиКомпиляции,,,,,,, БазовоеРасширениеКонфигурации());
			ирОбщий.ЗагрузитьВТаблицуЗначенийЛкс(ТаблицаСловБД, ТаблицаСлов);
			мЯзыкПрограммы = 0;
		КонецЕсли;
	КонецЕсли;
	ДобавитьПростыеСлова(КоллекцияЭлементовМД);
КонецПроцедуры

Функция ИмяФиктивногоСвойства() Экспорт 
	Возврат "__________________";
КонецФункции

//.
// Параметры:
//    ОтделятьБольшиеНаборыСлов - Булево -  
Процедура РассчитатьОжидаемыйТипВТаблицеСлов(Знач ОтделятьБольшиеНаборыСлов)
	мСтрокаЛучшегоСлова = Неопределено;
	мИмяОжидаемогоТипа = "";
	Если Ложь
		Или мПлатформа.мРежимПроверкиМодуля
		Или (Истина
			И ТаблицаСлов.Количество() < 2 
			И Не ЗначениеЗаполнено(мНаборыСлов))
	Тогда
		Возврат;
	КонецЕсли;
	ТаблицаОжидаемыхТипов = Неопределено;
	СтараяПозиция = мПозицияВТексте;  
	МаркерСсылочногоЛитерала = "";
	Если мСтруктураТипаКонтекста.ТипЯзыка = "ЗначениеВЗапросе" Тогда
		МаркерСсылочногоЛитерала = "ЗНАЧЕНИЕ(" + мНачалоКонтекста;
	ИначеЕсли мЯзыкПрограммы = 0 Тогда
		МаркерСсылочногоЛитерала = "ПредопределенноеЗначение(""" + мНачалоКонтекста;
	ИначеЕсли мЭтоТекстовыйЛитерал Тогда
		Возврат;
	КонецЕсли; 
	ЭтоСсылочныйЛитерал = Ложь;
	Если Истина
		И ЗначениеЗаполнено(МаркерСсылочногоЛитерала)
		И ирОбщий.СтрКончаетсяНаЛкс(мТекущаяСтрокаНачало, МаркерСсылочногоЛитерала) 
	Тогда
		НоваяПозиция = СтараяПозиция - СтрДлина(МаркерСсылочногоЛитерала);
		УстановитьГраницыВыделения(НоваяПозиция, НоваяПозиция);
		РазобратьТекущийКонтекст(,,,,, Истина, НоваяПозиция);
		ЭтоСсылочныйЛитерал = Истина;
	КонецЕсли;
	Если Ложь
		Или мКэшОжидаемогоТипа = Неопределено
		Или мПредшествующийТекст <> мСтарыйПредшествующийТекст 
	Тогда
		ПредшествующийТекст = Прав(СокрП(мПредшествующийТекст), 50);
		МаркерНовый = "Новый";
		Если ирОбщий.СтрКончаетсяНаЛкс(ПредшествующийТекст, МаркерНовый, Ложь) Тогда
			ПредшествующийТекст = СокрП(ирОбщий.СтрокаБезКонцаЛкс(ПредшествующийТекст, СтрДлина(МаркерНовый)));
		КонецЕсли;
		Если ирОбщий.СтрКончаетсяНаЛкс(ПредшествующийТекст, "<>") Тогда
			ПредшествующийТокен = "<>";
		Иначе
			ПредшествующийТокен = Прав(ПредшествующийТекст, 1);
		КонецЕсли;
		Если ПредшествующийТокен = "," Или ПредшествующийТокен = "(" Тогда
			ТекущийВызовМетода();
			Если ЗначениеЗаполнено(мВызовМетода) Тогда
				//ДляСвойства = ИмяФиктивногоСвойства();
				//Если ирОбщий.СтрКончаетсяНаЛкс(мВызовМетода, "УстановитьПараметр(") Тогда
					ДляСвойства = ""; // иначе не найдутся параметры запроса
				//КонецЕсли;
				ТаблицаТиповВызова = ВычислитьТипЗначенияВыражения(мВызовМетода + ИмяОтключенияЛишнихВычислений() + ")",,,, мЭтоКонструктор,,,,,,, мПозицияВБлоке,, ДляСвойства);
				Если ТаблицаТиповВызова.Количество() > 0 Тогда
					СтрокаОписанияМетода = ТаблицаТиповВызова[0].СтрокаОписания;
					ИмяПараметраВызоваМетода(СтрокаОписанияМетода, Ложь, ТаблицаОжидаемыхТипов);
					ЛиСистемноеСлово = Истина
						И СтрокаОписанияМетода <> Неопределено
						И СтрокаОписанияМетода.Владелец().Колонки.Найти("ТипКонтекста") <> Неопределено;
					//! СтрокаОписанияМетода = 0 // см. мПлатформа.ТаблицаКонтекстов[0]
					Если Истина
						И ЛиСистемноеСлово
						И СтрокаОписанияМетода.ТипКонтекста = "Запрос"
						И СтрокаОписанияМетода.Слово = "УстановитьПараметр"
						И мФактическиеПараметры.Количество() > 1
					Тогда
						ИмяПараметраЗапроса = ирОбщий.ТекстИзВстроенногоЯзыкаЛкс(мФактическиеПараметры[0]);
						Если ирОбщий.ЛиИмяПеременнойЛкс(ИмяПараметраЗапроса) Тогда
							ТаблицаТиповВызова[0].Метаданные.Параметры.Свойство(ИмяПараметраЗапроса, ТаблицаОжидаемыхТипов);
						КонецЕсли;
					ИначеЕсли Истина
						И ЛиСистемноеСлово
						И СтрокаОписанияМетода.ТипКонтекста = "Массив"
						И СтрокаОписанияМетода.Слово = "Добавить"
					Тогда
						ТаблицаОжидаемыхТипов = ТаблицаТиповВызова; // Опасно, т.к. это процедура и формально у нее нет типа значения
					КонецЕсли;
				КонецЕсли;
			КонецЕсли; 
		ИначеЕсли Ложь
			Или ПредшествующийТокен = "=" 
			Или ПредшествующийТокен = "<>" 
		Тогда
			АнализаторКода = КопияКомпоненты();
			ТаблицаОжидаемыхТипов = АнализаторКода.ТаблицаТиповТекущегоВыражения(Истина);
			ВыражениеСлеваОтРавно = АнализаторКода.мКонтекст;
		КонецЕсли;
		мСтарыйПредшествующийТекст = мПредшествующийТекст;
		мКэшОжидаемогоТипа = КэшОжидаемогоТипа(ТаблицаОжидаемыхТипов, ВыражениеСлеваОтРавно);
	Иначе
		ВыражениеСлеваОтРавно = мКэшОжидаемогоТипа.ВыражениеСлеваОтРавно;
		мВызовМетода = мКэшОжидаемогоТипа.мВызовМетода;
		мНомерПараметра = мКэшОжидаемогоТипа.мНомерПараметра;
		мЭтоКонструктор = мКэшОжидаемогоТипа.мЭтоКонструктор;
		ТаблицаОжидаемыхТипов = мКэшОжидаемогоТипа.ТаблицаОжидаемыхТипов;
	КонецЕсли;
	Если СтараяПозиция <> мПозицияВТексте Тогда
		УстановитьГраницыВыделения(СтараяПозиция, СтараяПозиция);
		РазобратьТекущийКонтекст(,,,,, Истина, СтараяПозиция);
	КонецЕсли;
	Если ТаблицаОжидаемыхТипов = Неопределено Тогда
		Возврат;
	КонецЕсли;
	ирОбщий.УдалитьСтрокиТаблицыИлиДереваПоЗначениюВКолонкеЛкс(ТаблицаОжидаемыхТипов, "ИмяОбщегоТипа", "Неопределено"); 
	ирОбщий.УдалитьСтрокиТаблицыИлиДереваПоЗначениюВКолонкеЛкс(ТаблицаОжидаемыхТипов, "ИмяОбщегоТипа", "Произвольный");
	Если ТаблицаОжидаемыхТипов.Количество() > 1 Тогда
		ирОбщий.УдалитьСтрокиТаблицыИлиДереваПоЗначениюВКолонкеЛкс(ТаблицаОжидаемыхТипов, "ИмяОбщегоТипа", "Массив"); 
	КонецЕсли;
	Если ТаблицаОжидаемыхТипов.Количество() > 1 Тогда
		ирОбщий.УдалитьСтрокиТаблицыИлиДереваПоЗначениюВКолонкеЛкс(ТаблицаОжидаемыхТипов, "ИмяОбщегоТипа", "СписокЗначений");    
	КонецЕсли;
	Если Ложь
		Или ТаблицаОжидаемыхТипов.Количество() <> 1 
		Или (Истина
			И ОтделятьБольшиеНаборыСлов
			И (Ложь
				Или ТаблицаОжидаемыхТипов[0].Детальность < 3
				Или ТаблицаОжидаемыхТипов[0].ИмяОбщегоТипа = "Строка"
				Или ТаблицаОжидаемыхТипов[0].ИмяОбщегоТипа = "Число")
			И ТаблицаОжидаемыхТипов[0].ИмяОбщегоТипа <> "Тип"
			И ТаблицаОжидаемыхТипов[0].ИмяОбщегоТипа <> "Булево")
	Тогда
		Возврат;
	КонецЕсли;
	НаборыСлов = мНаборыСлов;
	Если НаборыСлов = Неопределено Тогда
		НаборыСлов = Новый Соответствие;
	КонецЕсли;
	КонстантаРейтингСовпаденияТипа = КонстантаРейтингСовпаденияТипа();
	КлючОсновногоНабора = "";
	//Если ТаблицаСлов.Количество() > КонстантаМаксСловПроверятьДляОжидаемогоТипа() Тогда
		НаборыСлов[КлючОсновногоНабора] = ТаблицаСлов;
	//КонецЕсли;
	СтрокаОписания = ТаблицаОжидаемыхТипов[0].СтрокаОписания;
	Попытка
		Пустышка = СтрокаОписания.Владелец();
	Исключение
		// TODO перенести выше
		СтрокаОписания = Неопределено;
		мКэшОжидаемогоТипа = Неопределено;
	КонецПопытки;
	мИмяОжидаемогоТипа = мПлатформа.ИмяТипаИзСтруктурыТипа(ТаблицаОжидаемыхТипов[0]);
	ИмяОжидаемогоТипа = СтрЗаменить(мИмяОжидаемогоТипа, "Ссылка.", ".");
	Если мЯзыкПрограммы = 1 Тогда
		мИмяОжидаемогоТипа = ИмяОжидаемогоТипа;
	КонецЕсли;
	ТипТаблицы = ирОбщий.ПервыйФрагментЛкс(ИмяОжидаемогоТипа);
	МножественноеКорневогоТипа = ирОбщий.МножественноеИмяМДЛкс(ТипТаблицы);
	КлючПоиска = Новый Структура("ТипКонтекста, ЯзыкПрограммы, ТипЯзыка, ТипСлова");
	КлючПоиска.ТипКонтекста = "ПеречислимыеСвойстваОбъектовМетаданных";
	КлючПоиска.ЯзыкПрограммы = 0;
	КлючПоиска.ТипЯзыка = "";
	КлючПоиска.ТипСлова = "Свойство";
	ПеречислимыеСвойстваМД = мПлатформа.ТаблицаКонтекстов.Скопировать(КлючПоиска);
	//ПеречислимыеСвойстваМД.Индексы.Добавить("Слово");
	Если ПеречислимыеСвойстваМД.Найти(ИмяОжидаемогоТипа, "Слово") <> Неопределено Тогда
		УровеньСвойства = СтрЧислоВхождений(мРодительскийКонтекст, ".");
		Если Не ЗначениеЗаполнено(мРодительскийКонтекст) И УровеньСвойства = 0 Тогда
			КлючПоиска = Новый Структура("Слово", "Метаданные");
			ОбозначитьСловоСОжидаемымТипомВТаблицеСлов(КлючПоиска, НаборыСлов, КлючОсновногоНабора);
		ИначеЕсли ЗначениеЗаполнено(мРодительскийКонтекст) И УровеньСвойства = 0 Тогда
			мСтрокаЛучшегоСлова = ТаблицаСлов.Найти("СвойстваОбъектов", "Слово");
		ИначеЕсли УровеньСвойства = 1 Тогда
			мСтрокаЛучшегоСлова = ТаблицаСлов.Найти(ИмяОжидаемогоТипа, "Слово");
		КонецЕсли;
		Если мСтрокаЛучшегоСлова <> Неопределено Тогда
			мСтрокаЛучшегоСлова.Рейтинг = КонстантаРейтингСовпаденияТипа;
		КонецЕсли;
	ИначеЕсли Истина
		И (Ложь
			Или ирОбщий.СтрНачинаетсяСЛкс(ТипТаблицы, мРодительскийКонтекст)
			Или ирОбщий.СтрНачинаетсяСЛкс(МножественноеКорневогоТипа, мРодительскийКонтекст))
		И (Ложь
			Или ирОбщий.ЛиТипТаблицыМетассылкиЛкс(ТипТаблицы) 
			Или ирОбщий.ЛиКорневойТипОбъектаСПредопределеннымЛкс(ТипТаблицы))
	Тогда
		УровеньСвойства = СтрЧислоВхождений(мРодительскийКонтекст, ".");
		Если Не ЗначениеЗаполнено(мРодительскийКонтекст) И УровеньСвойства = 0 Тогда
			Если ЭтоСсылочныйЛитерал Тогда
				КлючПоиска = Новый Структура("Слово", ТипТаблицы);
				мСтрокаЛучшегоСлова = ТаблицаСлов.НайтиСтроки(КлючПоиска)[0];
			Иначе
				КлючПоиска = Новый Структура("Слово", МножественноеКорневогоТипа);
				ОбозначитьСловоСОжидаемымТипомВТаблицеСлов(КлючПоиска, НаборыСлов, КлючОсновногоНабора);
			КонецЕсли;
		ИначеЕсли ЗначениеЗаполнено(мРодительскийКонтекст) И УровеньСвойства = 0 Тогда
			мСтрокаЛучшегоСлова = ТаблицаСлов.Найти(ирОбщий.ПоследнийФрагментЛкс(ИмяОжидаемогоТипа), "Слово");
		КонецЕсли;
		Если мСтрокаЛучшегоСлова <> Неопределено Тогда
			мСтрокаЛучшегоСлова.Рейтинг = КонстантаРейтингСовпаденияТипа;
		КонецЕсли;
	ИначеЕсли Истина
		//И мМодульМетаданных.СтруктураТипа <> Неопределено
		//И ирОбщий.ЛиИмяТипаФормыЛкс(мМодульМетаданных.СтруктураТипа.ИмяОбщегоТипа)
		И СтрокаОписания <> Неопределено
		И СтрокаОписания.Владелец().Колонки.Найти("ТипКонтекста") <> Неопределено
		И ирОбщий.СтрНачинаетсяСЛкс(ВыражениеСлеваОтРавно, мРодительскийКонтекст)
		И (Ложь
			Или СтрокаОписания.Слово = "ТекущаяОбласть" И СтрокаОписания.ТипКонтекста = "ТабличныйДокумент"
			Или СтрокаОписания.Слово = "ТекущаяКолонка" И СтрокаОписания.ТипКонтекста = "ТабличноеПоле"
			Или СтрокаОписания.Слово = "ТекущаяСтраница" И СтрокаОписания.ТипКонтекста = "Панель"
			Или СтрокаОписания.Слово = "ТекущаяСтраница" И СтрокаОписания.ТипКонтекста = "РасширениеГруппыФормыДляСтраниц"
			Или СтрокаОписания.Слово = "ТекущийЭлемент" И СтрокаОписания.ТипКонтекста = "ТаблицаФормы"
			Или СтрокаОписания.Слово = "ТекущийЭлемент" И СтрокаОписания.ТипКонтекста = "Форма"
			Или СтрокаОписания.Слово = "ТекущийЭлемент" И СтрокаОписания.ТипКонтекста = "ФормаКлиентскогоПриложения")  
	Тогда
		Если СтрокаОписания.ТипКонтекста = "ТабличноеПоле" Тогда 
			ИмяКоллекции = "Колонки";        
		ИначеЕсли СтрокаОписания.ТипКонтекста = "Панель" Тогда 
			ИмяКоллекции = "Страницы";
		ИначеЕсли СтрокаОписания.ТипКонтекста = "ТабличныйДокумент" Тогда 
			ИмяКоллекции = "Области";
		ИначеЕсли СтрокаОписания.ТипКонтекста = "Форма" Тогда 
			ИмяКоллекции = "ЭлементыФормы";
		ИначеЕсли СтрокаОписания.ТипКонтекста = "ФормаКлиентскогоПриложения" Тогда 
			ИмяКоллекции = "Элементы";
		Иначе
			ИмяКоллекции = "ПодчиненныеЭлементы";
		КонецЕсли;
		ФрагментыСлеваОтРавно = ирОбщий.СтрРазделитьЛкс(ВыражениеСлеваОтРавно);
		ФрагментыСлеваОтРавно[ФрагментыСлеваОтРавно.ВГраница()] = ИмяКоллекции;
		Если Не ЗначениеЗаполнено(мРодительскийКонтекст) Тогда
			УровеньСвойства = 0;
		Иначе 
			УровеньСвойства = 1 + СтрЧислоВхождений(мРодительскийКонтекст, ".");
		КонецЕсли;
		КлючПоиска = Новый Структура("Слово", ФрагментыСлеваОтРавно[УровеньСвойства]);
		мСтрокаЛучшегоСлова = ТаблицаСлов.НайтиСтроки(КлючПоиска)[0];
		Если мСтрокаЛучшегоСлова <> Неопределено Тогда
			мСтрокаЛучшегоСлова.Рейтинг = КонстантаРейтингСовпаденияТипа;
		КонецЕсли;
	Иначе
		Если мСтруктураТипаКонтекста.ТипЯзыка = "ИмяТипа" Тогда
			КлючПоиска = Новый Структура("Слово", мИмяОжидаемогоТипа);
			ОбозначитьСловоСОжидаемымТипомВТаблицеСлов(КлючПоиска, НаборыСлов, КлючОсновногоНабора);
		ИначеЕсли мИмяОжидаемогоТипа = "Булево" Тогда
			//мСтрокаЛучшегоСлова = ТаблицаСлов.Найти("Истина", "Слово");
			//Если мСтрокаЛучшегоСлова <> Неопределено Тогда
			//	мСтрокаЛучшегоСлова.Рейтинг = КонстантаРейтингСовпаденияТипа;
			//КонецЕсли;
			//СтрокаСлова = ТаблицаСлов.Найти("Ложь", "Слово");
			//Если СтрокаСлова <> Неопределено Тогда
			//	СтрокаСлова.Рейтинг = КонстантаРейтингСовпаденияТипа;
			//КонецЕсли;
			КлючПоиска = Новый Структура("Слово", "Ложь");
			ОбозначитьСловоСОжидаемымТипомВТаблицеСлов(КлючПоиска, НаборыСлов, КлючОсновногоНабора);
			КлючПоиска = Новый Структура("Слово", "Истина");
			ОбозначитьСловоСОжидаемымТипомВТаблицеСлов(КлючПоиска, НаборыСлов, КлючОсновногоНабора);
		Иначе
			Если ТаблицаСлов.Количество() < КонстантаМаксСловПроверятьДляОжидаемогоТипа() Тогда
				// Для малых наборов слов проверяем вхождение подстроки в каждое слово
				_РежимОтладки = Ложь;
				Если _РежимОтладки Тогда // Можно менять на Истина в точке останова, например условием ирОбщий.Пр(_РежимОтладки, 1, 1)
					// Пассивный оригинал расположенного ниже однострочного кода. Выполняйте изменения синхронно в обоих вариантах.
					Для Каждого СтрокаСлова Из ТаблицаСлов Цикл
						Если Найти(СтрокаСлова.ТипЗначения, мИмяОжидаемогоТипа) > 0 Тогда
							СтрокаСлова.Рейтинг = КонстантаРейтингСовпаденияТипа;
						КонецЕсли;
					КонецЦикла;
				Иначе
					// Однострочный код использован для ускорения при разрешенной отладке. Выше расположен оригинал. Выполняйте изменения синхронно в обоих вариантах. Преобразовано консолью кода из подсистемы "Инструменты разработчика"
					Для Каждого СтрокаСлова Из ТаблицаСлов Цикл  						Если Найти(СтрокаСлова.ТипЗначения, мИмяОжидаемогоТипа) > 0 Тогда  							СтрокаСлова.Рейтинг = КонстантаРейтингСовпаденияТипа;  						КонецЕсли;  					КонецЦикла;  
				КонецЕсли;
			КонецЕсли;
			КлючПоиска = Новый Структура("ТипЗначения", мИмяОжидаемогоТипа);
			ОбозначитьСловоСОжидаемымТипомВТаблицеСлов(КлючПоиска, НаборыСлов, КлючОсновногоНабора);
		КонецЕсли;
	КонецЕсли;
	НаборыСлов.Удалить(КлючОсновногоНабора);
КонецПроцедуры

//.
// Параметры:
//    ТаблицаОжидаемыхТипов - ТаблицаЗначений, Неопределено - 
//    ВыражениеСлеваОтРавно - Строка - 
// Возвращаемое значение:
//    Структура - 
Функция КэшОжидаемогоТипа(Знач ТаблицаОжидаемыхТипов, Знач ВыражениеСлеваОтРавно) Экспорт
	Результат = Новый Структура;
	Результат.Вставить("ТаблицаОжидаемыхТипов", ТаблицаОжидаемыхТипов);
	Результат.Вставить("ВыражениеСлеваОтРавно", ВыражениеСлеваОтРавно);
	Результат.Вставить("мВызовМетода", мВызовМетода);
	Результат.Вставить("мНомерПараметра", мНомерПараметра);
	Результат.Вставить("мЭтоКонструктор", мЭтоКонструктор);
	Возврат Результат;
КонецФункции

//.
// Параметры:
//    КлючПоиска - Структура - 
//    НаборыСлов - Соответствие, Неопределено - 
//    КлючОсновногоНабора - Строка - 
Процедура ОбозначитьСловоСОжидаемымТипомВТаблицеСлов(КлючПоиска, Знач НаборыСлов, Знач КлючОсновногоНабора) Экспорт
	КонстантаРейтингСовпаденияТипа = КонстантаРейтингСовпаденияТипа();
	Для Каждого КлючИЗначение Из НаборыСлов Цикл
		// Для больших наборов слов ищем первое точное совпадение
		НаборСлов = КлючИЗначение.Значение;
		мСтрокаЛучшегоСлова = НаборСлов.НайтиСтроки(КлючПоиска);
		Если мСтрокаЛучшегоСлова.Количество() = 0 И КлючПоиска.Свойство("ТипЗначения") Тогда
			КлючПоиска.ТипЗначения = "Перечисление" + КлючПоиска.ТипЗначения;
			мСтрокаЛучшегоСлова = НаборСлов.НайтиСтроки(КлючПоиска);
		КонецЕсли;
		Если мСтрокаЛучшегоСлова.Количество() > 0 Тогда
			мСтрокаЛучшегоСлова = мСтрокаЛучшегоСлова[0];
			Если КлючИЗначение.Ключ <> КлючОсновногоНабора Тогда
				КлючПоиска = Новый Структура("НСлово, ТипСлова");
				КлючПоиска.НСлово = НРег(мСтрокаЛучшегоСлова.Слово);
				КлючПоиска.ТипСлова = мСтрокаЛучшегоСлова.ТипСлова;
				НоваяСтрока = ТаблицаСлов.НайтиСтроки(КлючПоиска);
				Если НоваяСтрока.Количество() > 0 Тогда
					НоваяСтрока = НоваяСтрока[0];
				Иначе
					НоваяСтрока = ТаблицаСлов.Добавить();
				КонецЕсли;
				ЗаполнитьЗначенияСвойств(НоваяСтрока, мСтрокаЛучшегоСлова);
				мСтрокаЛучшегоСлова = НоваяСтрока;
			КонецЕсли;
			мСтрокаЛучшегоСлова.Рейтинг = КонстантаРейтингСовпаденияТипа;
			Прервать;
		Иначе
			мСтрокаЛучшегоСлова = Неопределено;
		КонецЕсли;
	КонецЦикла;
КонецПроцедуры

Функция КонстантаМаксСловПроверятьДляОжидаемогоТипа() Экспорт
	Возврат 200;
КонецФункции

Процедура ЗаполнитьСловаВНижнемРегистре()
	_РежимОтладки = Ложь;
	// 13мс на 1500 слов - в 2 раза быстрее чем иробщий.ОбновитьКопиюКолонкиВНижнемРегистреЛкс()
	Если _РежимОтладки Тогда // Можно менять на Истина в точке останова, например условием ирОбщий.Пр(_РежимОтладки, 1, 1)
		// Пассивный оригинал расположенного ниже однострочного кода. Выполняйте изменения синхронно в обоих вариантах.
		Для Каждого СтрокаСлова Из ТаблицаСлов Цикл
			СтрокаСлова.НСлово = НРег(СтрокаСлова.Слово);
		КонецЦикла;
	Иначе
		// Однострочный код использован для ускорения при разрешенной отладке. Выше расположен оригинал. Выполняйте изменения синхронно в обоих вариантах. Преобразовано консолью кода из подсистемы "Инструменты разработчика"
		Для Каждого СтрокаСлова Из ТаблицаСлов Цикл  			СтрокаСлова.НСлово = НРег(СтрокаСлова.Слово);  		КонецЦикла;  
		КонецЕсли;
КонецПроцедуры

// Меняет контекст!
//
// Параметры:
//  ВыбраннаяСтруктураТипа				 - СтрокаТаблицыЗначений, Неопределено	 - 
//  КонтекстТекстовогоЛитералаИзвестен	 - Булево								 - 
// 
// Возвращаемое значение:
//   Массив, ТаблицаЗначений - 
//
Функция ЗаполнитьТаблицуСловДляТекстовогоЛитерала(ВыбраннаяСтруктураТипа, КонтекстТекстовогоЛитералаИзвестен = Истина, ИмяПараметра = "") Экспорт
	КоллекцияЭлементовМД = Новый Массив;
	КонтекстТекстовогоЛитералаИзвестен = Истина;
	// Находимся внутри строкового литерала на позиции параметра
	СтрокаОписанияМетода = ВыбраннаяСтруктураТипа.СтрокаОписания;
	Если Истина
		И ТипЗнч(СтрокаОписанияМетода) = Тип("СтрокаТаблицыЗначений")
		И СтрокаОписанияМетода.Владелец().Колонки.Найти("ТипСлова") <> Неопределено
		И (Ложь
			Или СтрокаОписанияМетода.ТипСлова = "Метод"
			Или СтрокаОписанияМетода.ТипСлова = "Конструктор")
	Тогда
		//! СтрокаОписанияМетода = мПлатформа.ТаблицаКонтекстов[0]
		Если СтрокаОписанияМетода.ТипСлова <> "Свойство" Тогда
			ИмяПараметра = ИмяПараметраВызоваМетода(СтрокаОписанияМетода);
			ИмяПеременнойСтруктуры = "";
			ИмяПеременнойПоляКомпоновки = "";
			Если Истина
				И мНомерПараметра = 1
				И мЭтоКонструктор
				И (Ложь
					Или мИмяМетодаВызова = "Структура"
					Или мИмяМетодаВызова = "ПолеКомпоновкиДанных"
					Или ИмяПараметра = "ИмяПроцедуры" И СтрокаОписанияМетода.ТипКонтекста = "Действие")
			Тогда 
				ПозицияОбрезки = ирОбщий.СтрНайтиЛкс(мТекущаяСтрокаНачало, "Новый " + мВызовМетода,,,, Ложь) - 1;
				ТекущаяСтрокаНачало = мТекущаяСтрокаНачало;
				ТекущаяСтрокаКонец = мТекущаяСтрокаКонец;
				мТекущаяСтрокаНачало = Лев(мТекущаяСтрокаНачало, ПозицияОбрезки);
				мТекущаяСтрокаКонец = "";
				Если Прав(СокрП(мТекущаяСтрокаНачало), 1) = "=" Тогда 
					Если мИмяМетодаВызова = "Структура" Тогда
						ИмяПеременнойСтруктуры = СокрЛП(ирОбщий.ПервыйФрагментЛкс(мТекущаяСтрокаНачало, "="));
					Иначе
						ВыражениеСлеваОтРавно = СокрЛП(ирОбщий.ПервыйФрагментЛкс(мТекущаяСтрокаНачало, "="));
						Если ЗначениеЗаполнено(ВыражениеСлеваОтРавно) Тогда
							Если Найти(ВыражениеСлеваОтРавно, ".") = 0 Тогда
								Если мИмяМетодаВызова = "ПолеКомпоновкиДанных" Тогда
									ИмяПеременнойПоляКомпоновки = ВыражениеСлеваОтРавно;
								КонецЕсли;
							Иначе
								ВыражениеСлеваОтРавно = ирОбщий.СтрокаБезПоследнегоФрагментаЛкс(ВыражениеСлеваОтРавно);
								ТаблицаТипов = ВычислитьТипЗначенияВыражения(ВыражениеСлеваОтРавно);
								Если ТаблицаТипов.Количество() > 0 Тогда
									Если ИмяПараметра = "ИмяПроцедуры" Тогда
										Если ТаблицаТипов[0].ДержательМетаданных <> Неопределено Тогда
											СтруктураТипаМодуля = мПлатформа.НоваяСтруктураТипа("Форма");
											СтруктураТипаМодуля.Метаданные = ТаблицаТипов[0].ДержательМетаданных;  
										КонецЕсли;
									Иначе
										ВыбраннаяСтруктураТипа.Метаданные = ТаблицаТипов[0].Метаданные;
									КонецЕсли;
								КонецЕсли;
							КонецЕсли;
						КонецЕсли;
					КонецЕсли;
					мТекущаяСтрокаНачало = ТекущаяСтрокаНачало;
					мТекущаяСтрокаКонец = ТекущаяСтрокаКонец;
				Иначе
					ТекущийВызовМетода();
					мТекущаяСтрокаНачало = ТекущаяСтрокаНачало;
					мТекущаяСтрокаКонец = ТекущаяСтрокаКонец;
					Если ЗначениеЗаполнено(мВызовМетода) Тогда
						ТаблицаТиповОбрамляющегоВызова = ВычислитьТипЗначенияВыражения(мВызовМетода, мТекстДляПоискаОпределения, мПредшествующийТекст,,,,,,,,, 
								мПозицияВТексте - мПозицияТекстаДляПоискаОпределения - 1);
						Если ИмяПараметра = "ИмяПроцедуры" Тогда
							Если ТаблицаТиповОбрамляющегоВызова.Количество() > 0 Тогда
								ЛучшийТип = ТаблицаТиповОбрамляющегоВызова[0];
								Если ЛучшийТип.ДержательМетаданных <> Неопределено Тогда
									СтруктураТипаМодуля = мПлатформа.НоваяСтруктураТипа("Форма");
									СтруктураТипаМодуля.Метаданные = ЛучшийТип.ДержательМетаданных;  
								КонецЕсли;
							КонецЕсли;
						Иначе
							ЛучшийТип = ЛучшийТипИзТаблицыТипов(ТаблицаТиповОбрамляющегоВызова, 4);
							Если Истина
								И ЛучшийТип <> Неопределено 
								И ЛучшийТип.СтрокаОписания.Владелец().Колонки.Найти("ТипСлова") <> Неопределено
							Тогда
								ВыбраннаяСтруктураТипа.Метаданные = ЛучшийТип.Метаданные;
							КонецЕсли;
						КонецЕсли;
					КонецЕсли; 
				КонецЕсли;
			ИначеЕсли Истина
				И СтрокаОписанияМетода.ТипКонтекста = "Структура"
				И СтрокаОписанияМетода.Слово = "Вставить" 
				И ИмяПараметра = "Ключ"
				И СтрЧислоВхождений(мВызовМетода, ".") = 1
			Тогда
				ИмяПеременнойСтруктуры = ирОбщий.ПервыйФрагментЛкс(мВызовМетода);
			КонецЕсли;
			Если ЗначениеЗаполнено(ИмяПеременнойПоляКомпоновки) Тогда
				Вхождения = НайтиВхожденияРегВыраженияКэш(шПредИмяПрямое + "(" + шИмяСТочками + ")\.(?:(?:НайтиПоле\()|(?:(?:Левое|Правое)Значение|Поле)\s*=)\s*(" + шИмя + ")"
					,, мТекстДляПоискаОпределения, "ПолеКомпоновкиДанных");
				Для Каждого Вхождение Из Вхождения Цикл
					Если ЛиВхождениеВЗапрешенномДиапазоне(Вхождение, мПозицияВБлоке) Тогда
						Продолжить;
					КонецЕсли;
					Если Не ирОбщий.СтрокиРавныЛкс(Вхождение.SubMatches(1), ИмяПеременнойПоляКомпоновки) Тогда
						Продолжить;
					КонецЕсли;
					ТаблицаТипов = ВычислитьТипЗначенияВыражения(Вхождение.SubMatches(0));
					Если ТаблицаТипов.Количество() > 0 Тогда
						ВыбраннаяСтруктураТипа.Метаданные = ТаблицаТипов[0].Метаданные;
					КонецЕсли;
					Прервать;
				КонецЦикла;
			КонецЕсли;
			Если Истина
				И СтрокаОписанияМетода.ТипКонтекста = "ПолеКомпоновкиДанных" 
				И ТипЗнч(ВыбраннаяСтруктураТипа.Метаданные) = Тип("КомпоновщикНастроекКомпоновкиДанных")
			Тогда
				КомпоновщикНастроек = ВыбраннаяСтруктураТипа.Метаданные; // КомпоновщикНастроекКомпоновкиДанных
				КоллекцияЭлементовМД = ирОбщий.ВыгрузитьСвойствоЛкс(КомпоновщикНастроек.Настройки.ДоступныеПоляОтбора.Элементы, "Поле");
			КонецЕсли;
			Если ЗначениеЗаполнено(ИмяПеременнойСтруктуры) Тогда
				Вхождения = НайтиВхожденияРегВыраженияКэш(шПредИмяПрямое + "(?:Открыть|Получить)Форму(?:Модально)?\(""([^""]+)"",\s*(" + шИмя + ")",, мТекстДляПоискаОпределения, "ПараметрыФормы");
				Для Каждого Вхождение Из Вхождения Цикл
					Если ЛиВхождениеВЗапрешенномДиапазоне(Вхождение, мПозицияВБлоке) Тогда
						Продолжить;
					КонецЕсли;
					Если Не ирОбщий.СтрокиРавныЛкс(Вхождение.SubMatches(1), ИмяПеременнойСтруктуры) Тогда
						Продолжить;
					КонецЕсли;
					ТаблицаТипов = ТаблицаТиповИзТекста("см. " + Вхождение.SubMatches(0) + ".Параметры");
					Если ТаблицаТипов.Количество() > 0 Тогда
						КоллекцияЭлементовМД = мПлатформа.СловаКонтекстаМетаданные(ТаблицаТипов[0],, "Свойство").ВыгрузитьКолонку("Слово");
					КонецЕсли;
					Перейти ~КонецПоискаСтруктур;
				КонецЦикла;
				Если Найти(мТекстБлока, "(" + ИмяПеременнойСтруктуры) > 0 Тогда // Для ускорения. Экономит 3мс на больших текстах
					Вхождения = НайтиВхожденияРегВыраженияКэш(шПредИмяПрямое + "(" + шИмяСТочками + ")\.(?:(?:НайтиСтроки|Выгрузить|Скопировать|НайтиСледующий)|ОтборСтрок\s*=\s*Новый\s*ФиксированнаяСтруктура)\(\s*(" + шИмя + ")"
						,, мТекстДляПоискаОпределения, "ОтборПоКолонкам");
					Для Каждого Вхождение Из Вхождения Цикл
						Если ЛиВхождениеВЗапрешенномДиапазоне(Вхождение, мПозицияВБлоке) Тогда
							Продолжить;
						КонецЕсли;
						Если Не ирОбщий.СтрокиРавныЛкс(Вхождение.SubMatches(1), ИмяПеременнойСтруктуры) Тогда
							Продолжить;
						КонецЕсли;
						ТаблицаТипов = ВычислитьТипЗначенияВыражения(Вхождение.SubMatches(0));
						Если ТаблицаТипов.Количество() > 0 Тогда
							МетаданныеТипа = ТаблицаТипов[0].Метаданные;
							Если ТипЗнч(МетаданныеТипа) = Тип("Структура") Тогда
								КоллекцияЭлементовМД = ирОбщий.ВыгрузитьСвойствоЛкс(МетаданныеТипа);
							ИначеЕсли Ложь
								Или ТипЗнч(МетаданныеТипа) = Тип("ТаблицаЗначений") 
								Или ТипЗнч(МетаданныеТипа) = Тип("ДеревоЗначений")
							Тогда
								КоллекцияЭлементовМД = ирОбщий.ВыгрузитьСвойствоЛкс(МетаданныеТипа.Колонки);
							ИначеЕсли ТипЗнч(МетаданныеТипа) = Тип("ПостроительЗапроса") Тогда
								мПлатформа.ПодготовитьМетаданныеПостроителяЗапроса(МетаданныеТипа, ТаблицаТипов[0].ДержательМетаданных);
								КоллекцияЭлементовМД = МетаданныеТипа.ВыбранныеПоля;
							ИначеЕсли Ложь
								Или ТипЗнч(МетаданныеТипа) = Тип("ДанныеФормыКоллекция") 
								Или ТипЗнч(МетаданныеТипа) = Тип("ДанныеФормыСтруктураСКоллекцией")
							Тогда
								КоллекцияЭлементовМД = ирОбщий.ВыгрузитьСвойствоЛкс(мПлатформа.ДочерниеСвойстваДанныхФормы(МетаданныеТипа, Истина, ТаблицаТипов[0].ДержательМетаданных));
							ИначеЕсли ТипЗнч(МетаданныеТипа) = Тип("ТаблицаФормы") Тогда
								ТаблицаТиповДочерняя = ВычислитьТипДочернегоЭлемента(ТаблицаТипов, "ТекущиеДанные", "Свойство");
								Если ТаблицаТиповДочерняя.Количество() > 0 Тогда
									ТаблицаКолонок = мПлатформа.ТаблицаСловИзСтруктурыТипа(ТаблицаТиповДочерняя[0],,,, Ложь,, "Свойство");
									КоллекцияЭлементовМД = ТаблицаКолонок.ВыгрузитьКолонку("Слово");
								КонецЕсли;
							КонецЕсли;
						КонецЕсли;
						Перейти ~КонецПоискаСтруктур;
					КонецЦикла;
				КонецЕсли;
~КонецПоискаСтруктур:
			КонецЕсли;
		КонецЕсли;
		
		// Имена свойств
		Если Истина
			И (Ложь
				Или Найти(НРег(ИмяПараметра), "ключ") > 0
				Или Найти(НРег(ИмяПараметра), "колонк") > 0
				Или Найти(НРег(ИмяПараметра), "группировк") > 0)
			И (Ложь
				Или ТипЗнч(ВыбраннаяСтруктураТипа.Метаданные) = Тип("ТаблицаЗначений")
				Или ТипЗнч(ВыбраннаяСтруктураТипа.Метаданные) = Тип("ДеревоЗначений")
				Или ТипЗнч(ВыбраннаяСтруктураТипа.Метаданные) = Тип("РезультатЗапроса"))
			И (Ложь
				Или Не мПлатформа.мРежимПроверкиМодуля 
				Или Не ирОбщий.СтрНачинаетсяСЛкс(СтрокаОписанияМетода.ТипКонтекста, "КоллекцияКолонок")
				Или СтрокаОписанияМетода.Слово <> "Найти")
		Тогда
			КоллекцияЭлементовМД = ВыбраннаяСтруктураТипа.Метаданные.Колонки;
		ИначеЕсли Истина
			И (Ложь
				Или Найти(НРег(ИмяПараметра), "ключ") > 0
				Или Найти(НРег(ИмяПараметра), "колонк") > 0) 
			И (Ложь
				Или Не мПлатформа.мРежимПроверкиМодуля
				Или (Истина
					И СтрокаОписанияМетода.Слово <> "Свойство"
					И СтрокаОписанияМетода.Слово <> "Вставить"
					И Не (Истина
						И СтрокаОписанияМетода.Слово = "Найти" 
						И Найти(СтрокаОписанияМетода.ТипКонтекста, "КоллекцияКолонок") > 0)))
			И (Ложь
				Или ТипЗнч(ВыбраннаяСтруктураТипа.Метаданные) = Тип("Структура")
				Или Истина
					И ТипЗнч(ВыбраннаяСтруктураТипа.Метаданные) = Тип("ОбъектМетаданных")
					И Найти(СтрокаОписанияМетода.ТипКонтекста, "ТабличнаяЧасть") > 0)
		Тогда 
			Коллекция = ВыбраннаяСтруктураТипа.Метаданные;
			Если ТипЗнч(Коллекция) = Тип("ОбъектМетаданных") Тогда
				Коллекция = Коллекция.Реквизиты; 
			КонецЕсли;
			КоллекцияЭлементовМД = ирОбщий.ВыгрузитьСвойствоЛкс(Коллекция);
		ИначеЕсли Истина
			И ИмяПараметра = "НаименованиеТаблицы"
			И ВыбраннаяСтруктураТипа.ИмяОбщегоТипа = "ВременнаяТаблицаЗапроса"
			И ТипЗнч(ВыбраннаяСтруктураТипа.Метаданные) = Тип("Структура") 
		Тогда 
			МенеджерВременныхТаблиц = ВыбраннаяСтруктураТипа.Метаданные; // см. НовыйМенеджерВременныхТаблиц
			Для Каждого ПакетЗапросов Из МенеджерВременныхТаблиц.ПакетыЗапросов Цикл
				ПодготовитьПакетЗапросов(ПакетЗапросов);
				ирОбщий.ДополнитьМассивЛкс(КоллекцияЭлементовМД, ирОбщий.ВыгрузитьСвойствоЛкс(ПакетЗапросов.Структура));
			КонецЦикла;
		ИначеЕсли Истина
			И ИмяПараметра = "ИмяРеквизита"
			И СтрокаОписанияМетода.Слово = "НайтиПоРеквизиту"
			И ТипЗнч(ВыбраннаяСтруктураТипа.Метаданные) = Тип("ОбъектМетаданных")
		Тогда 
			ИменаИндексированныхРеквизитов = ирОбщий.ОтобратьКоллекциюЛкс(ВыбраннаяСтруктураТипа.Метаданные.Реквизиты, "Э.Индексирование<>П1", "Имя", Метаданные.СвойстваОбъектов.Индексирование.НеИндексировать);
			ирОбщий.ДополнитьМассивЛкс(КоллекцияЭлементовМД, ИменаИндексированныхРеквизитов);
		ИначеЕсли Истина
			И Найти(НРег(ИмяПараметра), "группировк") > 0 
			И ТипЗнч(ВыбраннаяСтруктураТипа.Метаданные) = Тип("ПостроительЗапроса") 
		Тогда
			мПлатформа.ПодготовитьМетаданныеПостроителяЗапроса(ВыбраннаяСтруктураТипа.Метаданные, ВыбраннаяСтруктураТипа.ДержательМетаданных);
			КоллекцияЭлементовМД = ВыбраннаяСтруктураТипа.Метаданные.Измерения;
		ИначеЕсли Истина
			И СтрокаОписанияМетода.ТипСлова = "Конструктор" 
			И ТипЗнч(ВыбраннаяСтруктураТипа.Метаданные) = Тип("ПостроительЗапроса") 
		Тогда
			мПлатформа.ПодготовитьМетаданныеПостроителяЗапроса(ВыбраннаяСтруктураТипа.Метаданные, ВыбраннаяСтруктураТипа.ДержательМетаданных);
			КоллекцияЭлементовМД = ВыбраннаяСтруктураТипа.Метаданные.ДоступныеПоля;
		ИначеЕсли Ложь
			Или ТипЗнч(ВыбраннаяСтруктураТипа.Метаданные) = Тип("ДанныеФормыКоллекция")
		Тогда
			КоллекцияЭлементовМД = ирОбщий.ВыгрузитьСвойствоЛкс(мПлатформа.ДочерниеСвойстваДанныхФормы(ВыбраннаяСтруктураТипа.Метаданные, Истина, ВыбраннаяСтруктураТипа.ДержательМетаданных));
		ИначеЕсли Истина
			И ИмяПараметра = "ИмяРеквизита"
			И (Ложь
			    Или СтрокаОписанияМетода.Слово = "ЗначениеВРеквизитФормы"
				Или СтрокаОписанияМетода.Слово = "РеквизитФормыВЗначение")
		Тогда
			КоллекцияЭлементовМД = ирОбщий.ВыгрузитьСвойствоЛкс(мПлатформа.ИменаРеквизитовФормы(ВыбраннаяСтруктураТипа.Метаданные, "").Все);
		ИначеЕсли Истина
			И ИмяПараметра = "ИмяОбласти" 
			И ТипЗнч(ВыбраннаяСтруктураТипа.Метаданные) = Тип("ТабличныйДокумент") 
		Тогда
			КоллекцияЭлементовМД = ирОбщий.ВыгрузитьСвойствоЛкс(ВыбраннаяСтруктураТипа.Метаданные.Области,,, Тип("ОбластьЯчеекТабличногоДокумента"));
		ИначеЕсли Истина
			И СтрокаОписанияМетода.Слово = "ПолучитьФорму"
			И ИмяПараметра = "ИмяФормы"
		Тогда 
			//
		ИначеЕсли Истина
			И Найти(СтрокаОписанияМетода.ТипКонтекста, "<") > 0
			И ТипЗнч(ВыбраннаяСтруктураТипа.Метаданные) = Тип("ОбъектМетаданных") 
		Тогда
			Если ИмяПараметра = "Макет" Тогда
				КоллекцияЭлементовМД = ВыбраннаяСтруктураТипа.Метаданные.Макеты;
			ИначеЕсли ИмяПараметра = "Форма" Тогда
				КоллекцияЭлементовМД = ВыбраннаяСтруктураТипа.Метаданные.Формы;
			ИначеЕсли ЗначениеЗаполнено(ИмяПараметра) Тогда 
				ПолноеИмяМД = ВыбраннаяСтруктураТипа.Метаданные.ПолноеИмя();
				Если ирОбщий.ОписаниеТипаМетаданныхЛкс(ирОбщий.ПервыйФрагментЛкс(ПолноеИмяМД)).Категория = 1 Тогда
					Попытка
						// Пытаемся взять реквизиты ТЧ у нехранимого в БД объекта
						КоллекцияЭлементовМД = ВыбраннаяСтруктураТипа.Метаданные.Реквизиты;
					Исключение
						КонтекстТекстовогоЛитералаИзвестен = Ложь;
					КонецПопытки;
				Иначе 
					ИмяТаблицыБД = ирКэш.ИмяТаблицыИзМетаданныхЛкс(ПолноеИмяМД);
					Если ЗначениеЗаполнено(ИмяТаблицыБД) Тогда
						КоллекцияЭлементовМД = ирОбщий.ПоляТаблицыБДЛкс(ИмяТаблицыБД);
					КонецЕсли; 
				КонецЕсли;
			КонецЕсли; 
		ИначеЕсли ИмяПараметра = "ИмяПользователяИБ" Тогда 
			ПользователиИБ = ПользователиИнформационнойБазы.ПолучитьПользователей();
			Для Каждого Пользователь Из ПользователиИБ Цикл
				КоллекцияЭлементовМД.Добавить(Пользователь.Имя);                            
			КонецЦикла;
		ИначеЕсли ИмяПараметра = "Роль" Тогда 
			КоллекцияЭлементовМД = Метаданные.Роли;
		ИначеЕсли ИмяПараметра = "ИмяПользователяИБ" Тогда 
			ПользователиИБ = ПользователиИнформационнойБазы.ПолучитьПользователей();
			Для Каждого Пользователь Из ПользователиИБ Цикл
				КоллекцияЭлементовМД.Добавить(Пользователь.Имя); 
			КонецЦикла;
		ИначеЕсли ИмяПараметра = "ОбщийМакет" Тогда 
			КоллекцияЭлементовМД = Метаданные.ОбщиеМакеты;
		ИначеЕсли Истина
			И СтрокаОписанияМетода.Слово = "ПолучитьОбщуюФорму" 
			И ИмяПараметра = "Форма"
		Тогда
			КоллекцияЭлементовМД = Метаданные.ОбщиеФормы;
		ИначеЕсли Истина
			И СтрокаОписанияМетода.Слово = "УстановитьПараметр" 
			И ИмяПараметра = "Имя"
		Тогда
			Если ТипЗнч(ВыбраннаяСтруктураТипа.Метаданные) = Тип("ПостроительЗапроса") Тогда
				КоллекцияЭлементовМД = ирОбщий.ВыгрузитьСвойствоЛкс(мПлатформа.ПараметрыИзТекстаЗапроса(ВыбраннаяСтруктураТипа.Метаданные.Текст));
			КонецЕсли;
		ИначеЕсли Истина
			И СтрокаОписанияМетода.Слово = "Получить" 
			И СтрокаОписанияМетода.ТипКонтекста = "КоллекцияСвойствXDTO"
			И ИмяПараметра = "Имя" 
			И Типзнч(ВыбраннаяСтруктураТипа.Метаданные) = Тип("ОбъектXDTO")
		Тогда
			//! ВыбраннаяСтруктураТипа.Метаданные = 0 // ОбъектXDTO
			Для Каждого Свойство Из ВыбраннаяСтруктураТипа.Метаданные.Свойства() Цикл
				КоллекцияЭлементовМД.Добавить(Свойство.Имя); 
			КонецЦикла;
		ИначеЕсли Истина
			И СтрокаОписанияМетода.Слово = "Тип" 
			И СтрокаОписанияМетода.ТипКонтекста = "ФабрикаXDTO"
			И ИмяПараметра = "Имя"
		Тогда
			ИмяПространства = ВычислитьЗначениеВыражения(мПервыйФактическийПараметр, мТекстДляПоискаОпределения);
			Для Каждого Пакет Из ФабрикаXDTO.ЭкспортМоделиXDTO(ИмяПространства).package Цикл
				Для Каждого Тип Из Пакет.valueType Цикл
					КоллекцияЭлементовМД.Добавить(Тип.name);
				КонецЦикла;
				Для Каждого Тип Из Пакет.objectType Цикл
					КоллекцияЭлементовМД.Добавить(Тип.name);
				КонецЦикла;
			КонецЦикла;
		ИначеЕсли Истина
			И СтрокаОписанияМетода.Слово = "НайтиПредопределенное" 
			И СтрокаОписанияМетода.ТипКонтекста = "МенеджерРегламентныхЗаданий" 
			И ИмяПараметра = "Метаданные"
		Тогда
			КоллекцияЭлементовМД = Метаданные.РегламентныеЗадания;
		ИначеЕсли Истина
			И СтрокаОписанияМетода.Слово = "ПравоДоступа" 
			И  ИмяПараметра = "Право"
		Тогда
			КоллекцияЭлементовМД = ирОбщий.ТаблицаЗначенийИзТабличногоДокументаЛкс(мПлатформа.ПолучитьМакет("ВидыПравДоступа"));
		ИначеЕсли Истина
			И СтрокаОписанияМетода.Слово = "ЗаполнитьЗначенияСвойств" 
			И (Ложь
				Или ИмяПараметра = "СписокСвойств"
				Или ИмяПараметра = "ИсключаяСвойства")
		Тогда
			// Мультиметка00193361 Вероятно дублирование
			СтруктураТипаПараметра = ВычислитьТипЗначенияВыражения(мПервыйФактическийПараметр, мТекстДляПоискаОпределения);
			Если СтруктураТипаПараметра.Количество() > 0 Тогда
				КоллекцияЭлементовМД = мПлатформа.ТаблицаСловИзСтруктурыТипа(СтруктураТипаПараметра[0],,,,,,,,,,,,,, БазовоеРасширениеКонфигурации());
				КоллекцияЭлементовМД = КоллекцияЭлементовМД.Скопировать(Новый Структура("ТипСлова", "Свойство")).ВыгрузитьКолонку("Слово");
			КонецЕсли;
		ИначеЕсли Истина
			И СтрокаОписанияМетода.ТипКонтекста = "ОформлениеКомпоновкиДанных"
			И СтрокаОписанияМетода.Слово = "УстановитьЗначениеПараметра"
			И ИмяПараметра = "Параметр"
		Тогда 
			КоллекцияЭлементовМД.Добавить("Видимость");
			КоллекцияЭлементовМД.Добавить("ВыделятьОтрицательные");
			КоллекцияЭлементовМД.Добавить("ГоризонтальноеПоложение");
			КоллекцияЭлементовМД.Добавить("Доступность");
			КоллекцияЭлементовМД.Добавить("МаксимальнаяШирина");
			КоллекцияЭлементовМД.Добавить("ОтметкаНезаполненного");
			КоллекцияЭлементовМД.Добавить("Отображать");
			КоллекцияЭлементовМД.Добавить("Размещение");
			КоллекцияЭлементовМД.Добавить("Текст");
			КоллекцияЭлементовМД.Добавить("ТолькоПросмотр");
			КоллекцияЭлементовМД.Добавить("Формат");
			КоллекцияЭлементовМД.Добавить("ЦветФона");
			КоллекцияЭлементовМД.Добавить("ЦветТекста");
			КоллекцияЭлементовМД.Добавить("Шрифт");
		ИначеЕсли Истина
			И СтрокаОписанияМетода.ТипКонтекста = "ЗначенияПараметровДанныхКомпоновкиДанных"
			И СтрокаОписанияМетода.Слово = "УстановитьЗначениеПараметра"
			И ИмяПараметра = "Параметр"
		Тогда
			КомпоновщикНастроек = ВыбраннаяСтруктураТипа.Метаданные; // КомпоновщикНастроекКомпоновкиДанных
			КоллекцияЭлементовМД = ирОбщий.ВыгрузитьСвойствоЛкс(КомпоновщикНастроек.Настройки.ПараметрыДанных.ДоступныеПараметры.Элементы, "Параметр");
		ИначеЕсли Истина
			И (Ложь
				Или СтрокаОписанияМетода.Слово = "ПолучитьФункциональнуюОпцию" 
				Или СтрокаОписанияМетода.Слово = "ПолучитьФункциональнуюОпциюИнтерфейса"
				Или СтрокаОписанияМетода.Слово = "ПолучитьФункциональнуюОпциюФормы")
			И ИмяПараметра = "Имя"
		Тогда
			КоллекцияЭлементовМД = Метаданные.ФункциональныеОпции;
		ИначеЕсли Ложь
			Или ИмяПараметра = "ИмяМетода"
			Или ИмяПараметра = "ИмяПроцедуры"
			Или ИмяПараметра = "ИмяФункции"
			Или ИмяПараметра = "ИмяОбработчика"
			Или ИмяПараметра = "Действие"
		Тогда
			Если СтруктураТипаМодуля = Неопределено Тогда
				СтруктураТипаМодуля = мПлатформа.НоваяСтруктураТипа(СтрокаОписанияМетода.ТипКонтекста);
				СтруктураТипаМодуля.Метаданные = ВыбраннаяСтруктураТипа.Метаданные;  
			КонецЕсли;
			ТолькоЭкспотные = СтрокаОписанияМетода.ТипКонтекста = "ОписаниеОповещения";
			Если СтруктураТипаМодуля.ИмяОбщегоТипа = "Глобальный" Тогда
				ТаблицаСловКонтекста = мПлатформа.ДобавитьВТаблицуСловЭлементыГлобальныхМодулей(СтруктураТипаМодуля,, "Метод");
				КоллекцияЭлементовМД = ТаблицаСловКонтекста.ВыгрузитьКолонку("Слово");
			Иначе
				Если СтрокаОписанияМетода.ТипКонтекста = "ОписаниеОповещения" Тогда
					Если мФактическиеПараметры.Количество() > 1 Тогда
						ТаблицаТиповМодуля = ВычислитьТипЗначенияВыражения(мФактическиеПараметры[1]);
						Если ТаблицаТиповМодуля.Количество() > 0 Тогда
							СтруктураТипаМодуля = ТаблицаТиповМодуля[0];
						КонецЕсли;
					Иначе
						СтруктураТипаМодуля = мМодульМетаданных.СтруктураТипа;
					КонецЕсли;
				КонецЕсли;
				Модуль = мПлатформа.ПодготовитьМодульМетаданных(СтруктураТипаМодуля);
				Если Модуль <> Неопределено Тогда
					КоллекцияЭлементовМД = ОтобратьМетодыДляСпискаСлов(Модуль, ТолькоЭкспотные, ирОбщий.СтрКончаетсяНаЛкс(СтрокаОписанияМетода.Слово, "Ожидания"));
				Иначе
					КонтекстТекстовогоЛитералаИзвестен = Ложь; // Чтобы сработало заполнение полного имени метода в ДобавитьВТаблицуСловИменаМодуляИМетаданныхИТипов
				КонецЕсли;
			КонецЕсли;
		ИначеЕсли Истина
			И ИмяПараметра = "ИмяСобытия"
			//И СтрокаОписанияМетода.Слово <> "ЗаписьЖурналаРегистрации"
			//И СтрокаОписанияМетода.Слово <> "Оповестить"
			И СтрокаОписанияМетода.ТипКонтекста <> "Глобальный"
		Тогда
			ЭлементФормыСобытия = ВыбраннаяСтруктураТипа.Метаданные;
			Если ТипЗнч(ЭлементФормыСобытия) = Тип("ОбъектМетаданныхКонфигурация") Тогда
				ЭлементФормыСобытия = Неопределено;
			КонецЕсли;
			ИмяОбщегоТипа = СтрокаОписанияМетода.ТипКонтекста;
			Если ИмяОбщегоТипа = "РасширениеЭлементовУправленияРасположенныхВФорме" Тогда
				ИмяОбщегоТипа = "";
			КонецЕсли;
			КоллекцияЭлементовМД = ирОбщий.ВыгрузитьСвойствоЛкс(ирОбщий.СобытияЭлементаФормыЛкс(ЭлементФормыСобытия, ИмяОбщегоТипа), "Слово");
		ИначеЕсли Истина
			И ТипЗнч(ВыбраннаяСтруктураТипа.Метаданные) = Тип("ПостроительЗапроса")
			И (Ложь
				Или ИмяПараметра = "ПутьКДанным"
				Или ИмяПараметра = "Описание")
		Тогда
			ИмяПараметра = "ПутьКДанным";
			ПостроительЗапроса = ВыбраннаяСтруктураТипа.Метаданные;
			#Если Сервер И Не Сервер Тогда
				ПостроительЗапроса = Новый ПостроительЗапроса;
			#КонецЕсли
			КоллекцияЭлементовМД = ПостроительЗапроса.ДоступныеПоля;
		ИначеЕсли Истина
			И ИмяПараметра = "ПутьКДанным"
			И (Ложь
				Или ТипЗнч(ВыбраннаяСтруктураТипа.Метаданные) = Тип("НаборДанныхЗапросСхемыКомпоновкиДанных")
				Или ТипЗнч(ВыбраннаяСтруктураТипа.Метаданные) = Тип("НаборДанныхОбъектСхемыКомпоновкиДанных")
				Или ТипЗнч(ВыбраннаяСтруктураТипа.Метаданные) = Тип("НаборДанныхОбъединениеСхемыКомпоновкиДанных"))
		Тогда
			КоллекцияЭлементовМД = ирОбщий.ВыгрузитьСвойствоЛкс(ВыбраннаяСтруктураТипа.Метаданные.Поля, ИмяПараметра);
		ИначеЕсли Истина
			И СтрокаОписанияМетода.ТипКонтекста <> "ТаблицаЗначений"
			И СтрокаОписанияМетода.ТипКонтекста <> "ДеревоЗначений"
			И СтрокаОписанияМетода.ТипКонтекста <> "Структура"
			И Найти(СтрокаОписанияМетода.ТипКонтекста, "ТабличнаяЧасть.") = 0
			И Найти(СтрокаОписанияМетода.ТипКонтекста, "НаборЗаписей.") = 0
		Тогда
			КонтекстТекстовогоЛитералаИзвестен = Ложь;
		КонецЕсли;
		ВыбраннаяСтруктураТипа.ТипЯзыка = ИмяПараметра;
	ИначеЕсли Истина
		И ТипЗнч(СтрокаОписанияМетода) = Тип("СтрокаТаблицыЗначений")
		И СтрокаОписанияМетода.Владелец().Колонки.Найти("ТелоБезВозвратов") <> Неопределено
	Тогда
		//! СтрокаОписанияМетода = мПлатформа.НоваяТаблицаМетодовМодуля()[0]
		КонтекстТекстовогоЛитералаИзвестен = Ложь;
		ИмяПараметра = ИмяПараметраВызоваМетода(СтрокаОписанияМетода);
		Если ЗначениеЗаполнено(ИмяПараметра) Тогда 
			КонтекстТекстовогоЛитералаИзвестен = Истина;
			Если Истина // БСП
				И Найти(ИмяПараметра, "Реквизит") > 0
				И Найти(СтрокаОписанияМетода.Имя, "Значен") > 0
				И Найти(СтрокаОписанияМетода.Имя, "Реквизит") > 0
			Тогда
				// БСП https://www.hostedredmine.com/issues/966675
				ТаблицаТиповСсылки = ВычислитьТипЗначенияВыражения(мПервыйФактическийПараметр, мТекстДляПоискаОпределения);
				Если ТаблицаТиповСсылки.Количество() > 0 Тогда
					Для Каждого СтруктураТипаСсылки Из ТаблицаТиповСсылки Цикл
						Если ирОбщий.СтрНачинаетсяСЛкс(СтруктураТипаСсылки.ИмяОбщегоТипа, "Массив[") Тогда
							ТаблицаТиповСсылки = мПлатформа.ТаблицаТиповЭлементовКоллекции(СтруктураТипаСсылки);
							Если ТаблицаТиповСсылки.Количество() > 0 Тогда
								СтруктураТипаСсылки = ТаблицаТиповСсылки[0];
							КонецЕсли;
						КонецЕсли;
						Если ТипЗнч(СтруктураТипаСсылки.Метаданные) = Тип("ОбъектМетаданных") Тогда
							ИмяТаблицыБД = ирКэш.ИмяТаблицыИзМетаданныхЛкс(СтруктураТипаСсылки.Метаданные.ПолноеИмя());
							Если ЗначениеЗаполнено(ИмяТаблицыБД) Тогда
								КоллекцияЭлементовМДТипа = ирОбщий.ПоляТаблицыБДЛкс(ИмяТаблицыБД);
								Если ТипЗнч(КоллекцияЭлементовМД) = Тип("ТаблицаЗначений") Тогда
									ирОбщий.ЗагрузитьВТаблицуЗначенийЛкс(КоллекцияЭлементовМДТипа, КоллекцияЭлементовМД);
								Иначе
									КоллекцияЭлементовМД = КоллекцияЭлементовМДТипа.Скопировать();
								КонецЕсли;
								ИмяПараметра = "ИмяРеквизита";
							КонецЕсли; 
						КонецЕсли;
					КонецЦикла;
				КонецЕсли;
			ИначеЕсли Истина // БСП
				И ИмяПараметра = "Поле" 
				И СтрокаОписанияМетода.Имя = "СообщитьПользователю" 
			Тогда 
				Форма = Неопределено;
				Если Истина
					И Не ЗначениеЗаполнено(мФактическиеПараметры[1])
					И мМодульМетаданных.СтруктураТипа <> Неопределено
					И ЛиПодробнаяСтруктураТипаУпрФормы(мМодульМетаданных.СтруктураТипа)
				Тогда
					Форма = мМодульМетаданных.СтруктураТипа.Метаданные;
				ИначеЕсли ЗначениеЗаполнено(мФактическиеПараметры[1]) Тогда 
					СтруктураТипаСсылки = ВычислитьТипЗначенияВыражения(мФактическиеПараметры[1], мТекстДляПоискаОпределения);
					Если СтруктураТипаСсылки.Количество() > 0 Тогда
						СтруктураТипаСсылки = СтруктураТипаСсылки[0];
						Если ТипЗнч(СтруктураТипаСсылки.Метаданные) = Тип("ОбъектМетаданных") Тогда
							Форма = мПлатформа.ПассивнаяФормаПоИмениКэш(СтруктураТипаСсылки.Метаданные.ПолноеИмя() + ".ФормаОбъекта");
						КонецЕсли;
					КонецЕсли;
				КонецЕсли;
				Если Форма <> Неопределено Тогда
					КоллекцияЭлементовМД = ирОбщий.ВыгрузитьСвойствоЛкс(мПлатформа.ИменаРеквизитовФормы(Форма, мРодительскийКонтекст).Все);
				КонецЕсли;
			ИначеЕсли Истина // ИР
				И ИмяПараметра = "ПутьКСвойству" 
				И (Ложь
					ИЛи СтрокаОписанияМетода.Имя = "ВыгрузитьСвойствоЛкс" 
					Или СтрокаОписанияМетода.Имя = "ОтобратьКоллекциюЛкс")
			Тогда
				СтруктураТипаПараметра = ВычислитьТипЗначенияВыражения(мПервыйФактическийПараметр, мТекстДляПоискаОпределения);
				Если СтруктураТипаПараметра.Количество() > 0 Тогда
					СтруктураТипаЭлемента = мПлатформа.ТаблицаТиповЭлементовКоллекции(СтруктураТипаПараметра[0]);
					Если СтруктураТипаЭлемента.Количество() > 0 Тогда
						БазовоеРасширениеКонфигурации = БазовоеРасширениеКонфигурации();
						КоллекцияЭлементовМД = мПлатформа.ТаблицаСловИзСтруктурыТипа(СтруктураТипаЭлемента[0],,,,,,,,,,,,,, БазовоеРасширениеКонфигурации);
						КоллекцияЭлементовМД = КоллекцияЭлементовМД.Скопировать(Новый Структура("ТипСлова", "Свойство")).ВыгрузитьКолонку("Слово");
						ВыбраннаяСтруктураТипа.ИмяОбщегоТипа = "Локальный";
					КонецЕсли;
				КонецЕсли;
			ИначеЕсли Истина // ИР
				И ИмяПараметра = "Условие" 
				И СтрокаОписанияМетода.Имя = "ОтобратьКоллекциюЛкс"
			Тогда
				// TODO 
				СтруктураТипаПараметра = ВычислитьТипЗначенияВыражения(мПервыйФактическийПараметр);
				Если СтруктураТипаПараметра.Количество() > 0 Тогда
					// Опасно. Полная замена контекста
					мЭтоТекстовыйЛитерал = Ложь;
					ДобавитьСловоЛокальногоКонтекста("Э",,,,,, мПлатформа.ДобавитьВТаблицуТипов(, СтруктураТипаПараметра));
					СмещениеНомера = 2;
					Для НомерПараметра = 1 По 3 Цикл
						Если мФактическиеПараметры.Количество() > СмещениеНомера + НомерПараметра Тогда
							СтруктураТипаПараметра = ВычислитьТипЗначенияВыражения(мФактическиеПараметры[СмещениеНомера + НомерПараметра]);
							Если СтруктураТипаПараметра.Количество() > 0 Тогда
								ДобавитьСловоЛокальногоКонтекста("П" + НомерПараметра,,,,,, мПлатформа.ДобавитьВТаблицуТипов(, СтруктураТипаПараметра));
							КонецЕсли;
						КонецЕсли;
					КонецЦикла;
					мТекстДляПоискаОпределения = "";
					мПредшествующийТекст = мТекстДляПоискаОпределения;
					ТаблицаТипов = ТаблицаТиповТекущегоВыражения();
					Если ТаблицаТипов.Количество() > 0 Тогда
						мСтруктураТипаКонтекста = ТаблицаТипов[0];
					КонецЕсли;
				КонецЕсли;
			ИначеЕсли Ложь
				Или ИмяПараметра = "ПолноеИмяМД"
			Тогда
				// TODO 
			Иначе
				//! СтрокаМетода = 0; // см. мПлатформа.НоваяТаблицаМетодовМодуля()[0]
				СтарыеКлючевыеПараметры = СтрокаОписанияМетода.КлючевыеПараметры;
				СтрокаОписанияМетода.КлючевыеПараметры = Новый Структура;
				ИндексПараметра = 0;
				Для Каждого СтрокаПараметра Из мПлатформа.ПараметрыМетодаМодуля(СтрокаОписанияМетода) Цикл
					Если мФактическиеПараметры.Количество() = ИндексПараметра Тогда
						Прервать;
					КонецЕсли;
					ВыражениеПараметра = мФактическиеПараметры[ИндексПараметра];
					Если ЗначениеЗаполнено(ВыражениеПараметра) Тогда
						СтрокаОписанияМетода.КлючевыеПараметры.Вставить(СтрокаПараметра.Имя, ВычислитьТипЗначенияВыражения(ВыражениеПараметра,,,,,, Ложь,,,,, мПозицияВБлоке, Неопределено));
					КонецЕсли;
					ИндексПараметра = ИндексПараметра + 1;
				КонецЦикла;
				ИмяПараметра = ИмяПараметраВызоваМетода(СтрокаОписанияМетода);
				КонтекстТекстовогоЛитералаИзвестен = Ложь;
				Если ВыбраннаяСтруктураТипа.СтрокаОписания.ИмяМодуля <> мМодульМетаданных.Имя Тогда
					АнализаторКодаМодуля = мПлатформа.ПолеТекстаМодуля(ВыбраннаяСтруктураТипа.СтрокаОписания.ИмяМодуля);
					АнализаторКодаМодуля.мРекурсивныйПуть = мРекурсивныйПуть; // Защита от циклической рекурсии
				Иначе 
					//АнализаторКодаМодуля = КопияКомпоненты(); // 5мс
					АнализаторКодаМодуля = ЭтотОбъект;
				КонецЕсли;
				АнализаторКодаМодуля.ЗагрузитьМетодМодуля(СтрокаОписанияМетода);
				КоллекцияЭлементовМД = АнализаторКодаМодуля.ВычислитьВозможныеТекстовыеЗначенияПараметра(ИмяПараметра, КонтекстТекстовогоЛитералаИзвестен);
				СтрокаОписанияМетода.КлючевыеПараметры = СтарыеКлючевыеПараметры;
			КонецЕсли;
			Если мЭтоТекстовыйЛитерал Тогда
				ВыбраннаяСтруктураТипа.ТипЯзыка = ИмяПараметра;
			КонецЕсли;
		КонецЕсли;
	Иначе
		КонтекстТекстовогоЛитералаИзвестен = Ложь;
	КонецЕсли;
	Если ВыбраннаяСтруктураТипа.ТипЯзыка = "ИмяПредопределенногоЗначения" Тогда
		КонтекстТекстовогоЛитералаИзвестен = Истина;
		Если ЗначениеЗаполнено(мРодительскийКонтекст) Тогда
			ТаблицаТиповМетаОбъектов = ирКэш.ТипыМетаОбъектов(Ложь);
			КорневойТип = ирОбщий.ПервыйФрагментЛкс(мРодительскийКонтекст);
			КоллекцияЭлементовМД.Добавить("ПустаяСсылка");
			Если Найти(мРодительскийКонтекст, ".") > 0 Тогда
				ОбъектМД = Метаданные.НайтиПоПолномуИмени(мРодительскийКонтекст);
				Если ирОбщий.ЛиКорневойТипПеречисленияЛкс(КорневойТип) Тогда
					#Если Сервер И Не Сервер Тогда
						ОбъектМД = Метаданные.Перечисления.ABCКлассификация;
					#КонецЕсли
					Для Каждого ЗначениеПеречисления Из ОбъектМД.ЗначенияПеречисления Цикл
						КоллекцияЭлементовМД.Добавить(ЗначениеПеречисления.Имя);
					КонецЦикла;
				Иначе
					#Если Сервер И Не Сервер Тогда
						ОбъектМД = Метаданные.Справочники.Валюты;
					#КонецЕсли
					Если Истина
						И ирКэш.НомерВерсииПлатформыЛкс() > 803004 
						И ирОбщий.ЛиКорневойТипОбъектаСПредопределеннымЛкс(КорневойТип) 
					Тогда
						Для Каждого ИмяЭлемента Из ОбъектМД.ПолучитьИменаПредопределенных() Цикл
							КоллекцияЭлементовМД.Добавить(ИмяЭлемента);
						КонецЦикла;
					КонецЕсли; 
				КонецЕсли; 
			Иначе
				МножественноеИмяМД = ирОбщий.МножественноеИмяМДЛкс(КорневойТип);
				Если МножественноеИмяМД <> Неопределено Тогда
					Для Каждого МетаОбъект Из Метаданные[МножественноеИмяМД] Цикл
						КоллекцияЭлементовМД.Добавить(МетаОбъект);
					КонецЦикла;
				КонецЕсли; 
			КонецЕсли; 
		Иначе
			Для Каждого СтрокаТипаМетаОбъекта Из ирКэш.ТипыМетаОбъектов(Ложь, Ложь, Ложь) Цикл
				Если Ложь
					Или ирОбщий.ЛиКорневойТипПеречисленияЛкс(СтрокаТипаМетаОбъекта.Единственное)
					Или ирОбщий.ЛиКорневойТипОбъектаСПредопределеннымЛкс(СтрокаТипаМетаОбъекта.Единственное) 
				Тогда
					КоллекцияЭлементовМД.Добавить(СтрокаТипаМетаОбъекта.Единственное);
				КонецЕсли; 
			КонецЦикла;
		КонецЕсли;  
	ИначеЕсли ВыбраннаяСтруктураТипа.ТипЯзыка = "ПространствоБлокировки" Тогда
		КонтекстТекстовогоЛитералаИзвестен = Истина;
		Если ЗначениеЗаполнено(мРодительскийКонтекст) Тогда
			КорневойТип = ирОбщий.ПервыйФрагментЛкс(мРодительскийКонтекст);
			ЭтоТаблицаВнешнейБД = ирОбщий.ЛиКорневойТипВнешнегоИсточникаДанныхЛкс(КорневойТип);
			Если Истина
				И ЭтоТаблицаВнешнейБД
				И СтрЧислоВхождений(мРодительскийКонтекст, ".") = 1 
			Тогда
				КоллекцияЭлементовМД.Добавить("Таблица");
			ИначеЕсли Истина
				И ЭтоТаблицаВнешнейБД
				И СтрЧислоВхождений(мРодительскийКонтекст, ".") = 2 
			Тогда
				Для Каждого МетаОбъект Из ирКэш.ОбъектМДПоПолномуИмениЛкс(ирОбщий.СтрокаБезПоследнегоФрагментаЛкс(мРодительскийКонтекст)).Таблицы Цикл
					КоллекцияЭлементовМД.Добавить(МетаОбъект.Имя);
				КонецЦикла; 
			ИначеЕсли Найти(мРодительскийКонтекст, ".") > 0 Тогда
				Если ирОбщий.ЛиКорневойТипРегистраБДЛкс(КорневойТип) Тогда
					КоллекцияЭлементовМД.Добавить("НаборЗаписей");
				КонецЕсли; 
				Если ирОбщий.ЛиКорневойТипПоследовательностиЛкс(КорневойТип) Тогда
					КоллекцияЭлементовМД.Добавить("Записи");
				КонецЕсли; 
			Иначе
				МножественноеИмяМД = ирОбщий.МножественноеИмяМДЛкс(КорневойТип);
				Если МножественноеИмяМД <> Неопределено Тогда
					Для Каждого МетаОбъект Из Метаданные[МножественноеИмяМД] Цикл
						КоллекцияЭлементовМД.Добавить(МетаОбъект);
					КонецЦикла;
				КонецЕсли; 
			КонецЕсли; 
		Иначе
			Для Каждого СтрокаТипаМетаОбъекта Из ирКэш.ТипыМетаОбъектов(Ложь, Ложь, Ложь) Цикл
				КоллекцияЭлементовМД.Добавить(СтрокаТипаМетаОбъекта.Единственное);
			КонецЦикла;
		КонецЕсли;  
	ИначеЕсли ВыбраннаяСтруктураТипа.ТипЯзыка = "ПолеПространстваБлокировок" Тогда
		КонтекстТекстовогоЛитералаИзвестен = Истина;
		ПространствоБлокировки = ВыбраннаяСтруктураТипа.Метаданные;
		КорневойТип = ирОбщий.ПервыйФрагментЛкс(ПространствоБлокировки);
		ОбъектМД = ирОбщий.ПолучитьМетаданныеЛкс(ПространствоБлокировки);
		ЭтоТаблицаВнешнейБД = ирОбщий.ЛиКорневойТипВнешнегоИсточникаДанныхЛкс(КорневойТип);
		Если ирОбщий.ЛиМетаданныеСсылочногоОбъектаЛкс(ОбъектМД) Тогда
			КоллекцияЭлементовМД.Добавить("Ссылка");
			Если ОбъектМД <> Неопределено Тогда
				#Если Сервер И Не Сервер Тогда
					ОбъектМД = Метаданные.Справочники.Пользователи;
				#КонецЕсли
				Для Каждого ПолеБлокировки Из ОбъектМД.ПоляБлокировкиДанных Цикл
					КоллекцияЭлементовМД.Добавить(ПолеБлокировки.Имя);
				КонецЦикла;
			КонецЕсли; 
		Иначе
			Если ОбъектМД <> Неопределено Тогда
				#Если Сервер И Не Сервер Тогда
					ОбъектМД = Метаданные.РегистрыСведений.КурсыВалют;
				#КонецЕсли
				Если Найти(ПространствоБлокировки, "." + "НаборЗаписей") > 0 Тогда
					СтруктураКлюча = ирОбщий.СтруктураКлючаТаблицыБДЛкс(ирКэш.ИмяТаблицыИзМетаданныхЛкс(ОбъектМД.ПолноеИмя()), Ложь);
				Иначе
					СтруктураКлюча = Новый Структура;
					Если ирОбщий.ЛиКорневойТипРегистраСведенийЛкс(КорневойТип) Тогда
						Если ОбъектМД.ПериодичностьРегистраСведений <> Метаданные.СвойстваОбъектов.ПериодичностьРегистраСведений.Непериодический Тогда
							СтруктураКлюча.Вставить(ирОбщий.ПеревестиСтроку("Период"));
						КонецЕсли; 
						Если ОбъектМД.РежимЗаписи = Метаданные.СвойстваОбъектов.РежимЗаписиРегистра.ПодчинениеРегистратору Тогда
							СтруктураКлюча.Вставить(ирОбщий.ПеревестиСтроку("Регистратор"));
						КонецЕсли; 
					КонецЕсли; 
					Если ирОбщий.ЛиКорневойТипРегистраРасчетаЛкс(КорневойТип) Тогда
						СтруктураКлюча.Вставить(ирОбщий.ПеревестиСтроку("ПериодРегистрации"));
						СтруктураКлюча.Вставить(ирОбщий.ПеревестиСтроку("ПериодДействия"));
					КонецЕсли; 
					Если ЭтоТаблицаВнешнейБД Тогда
						//! ОбъектМД = Метаданные.ВнешниеИсточникиДанных.Tropic.Таблицы.dbo_Dorem_Lines;
						Для Каждого ПолеКлюча Из ОбъектМД.ПоляКлюча Цикл
							СтруктураКлюча.Вставить(ПолеКлюча.Имя);
						КонецЦикла;
					Иначе
						Для Каждого Измерение Из ОбъектМД.Измерения Цикл
							СтруктураКлюча.Вставить(Измерение.Имя);
						КонецЦикла;
					КонецЕсли; 
				КонецЕсли; 
				Для Каждого КлючИЗначение Из СтруктураКлюча Цикл
					КоллекцияЭлементовМД.Добавить(КлючИЗначение.Ключ);
				КонецЦикла;
			КонецЕсли; 
		КонецЕсли; 
	ИначеЕсли Истина
		И ирОбщий.СтрокиРавныЛкс(мИмяМетодаВызова, "COMОбъект") 
		И мНомерПараметра = 1 
		И ВыбраннаяСтруктураТипа.ТипЯзыка <> ""
	Тогда
		КонтекстТекстовогоЛитералаИзвестен = Истина;
		Если ИменаВсехКомКлассов = Неопределено Тогда
			Компьютер = "localhost";
			ИменаВсехКомКлассов = Новый Соответствие;
			КаталогПриложений = Новый COMОбъект("COMAdmin.COMAdminCatalog");
			КаталогПриложений.Connect(Компьютер);
			Компоненты = КаталогПриложений.GetCollection("InprocServers");
			Компоненты.Populate();
			ДобавитьCOMКлассыВСписокСлов(ИменаВсехКомКлассов, Компоненты);
			Компоненты = КаталогПриложений.GetCollection("WOWLegacyServers");
			Компоненты.Populate();
			ДобавитьCOMКлассыВСписокСлов(ИменаВсехКомКлассов, Компоненты);
			Компоненты = КаталогПриложений.GetCollection("LegacyServers");
			Компоненты.Populate();
			ДобавитьCOMКлассыВСписокСлов(ИменаВсехКомКлассов, Компоненты);
			ИменаВсехКомКлассов = ирОбщий.ВыгрузитьСвойствоЛкс(ИменаВсехКомКлассов);
		КонецЕсли; 
		КоллекцияЭлементовМД = ИменаВсехКомКлассов;
	КонецЕсли; 
	Возврат КоллекцияЭлементовМД;
КонецФункции

//.
// Параметры:
//    СтараяТекущаяПозиция - Неопределено - 
Процедура ПерезагрузитьКонтекстЕслиПозицияИзменилась(Знач СтараяТекущаяПозиция, Знач СтарыйМетод) Экспорт
	Если СтараяТекущаяПозиция <> мПозицияВТексте Тогда 
		ПолеТекста.УстановитьГраницыВыделения(СтараяТекущаяПозиция, СтараяТекущаяПозиция);
		КончитьОбработкуКоманды();
		РазобратьТекущийКонтекст(,, Истина,,,, СтараяТекущаяПозиция);
	Иначе
		ЗагрузитьМетодМодуля(СтарыйМетод);
	КонецЕсли;
КонецПроцедуры

// Меняет контекст, т.к. зовет РазобратьТекущийКонтекст()
//
// Параметры:
//  ИмяПараметра						 - 	 - 
//  КонтекстТекстовогоЛитералаИзвестен	 - Булево - 
// 
// Возвращаемое значение:
//   - 
//
Функция ВычислитьВозможныеТекстовыеЗначенияПараметра(Знач ИмяПараметра, КонтекстТекстовогоЛитералаИзвестен) Экспорт
	ЗначенияПараметра = Новый Массив;
	БазовоеРасширениеКонфигурации = БазовоеРасширениеКонфигурации();
	Если Истина
		И Не КонтекстТекстовогоЛитералаИзвестен 
		И Найти(мТекстБлока, "[" + ИмяПараметра + "]") > 0 
	Тогда
		ВхожденияОбъектов = НайтиВхожденияРегВыраженияКэш("(" + шОбъектноеВыражение + ")\[" + ИмяПараметра + "\]",,, "ОбъектСВКвадратнымиСкобками;" + ИмяПараметра);
		Для Каждого Вхождение Из ВхожденияОбъектов Цикл
			ПозицияВхождения0 = Вхождение.FirstIndex;
			ВыражениеВладелецСвойств = Вхождение.SubMatches(0);
			ТаблицаТипов = ВычислитьТипЗначенияВыражения(ВыражениеВладелецСвойств,,,,,, Ложь,,,,, ПозицияВхождения0, Неопределено);
			ТаблицаСловОбъекта = Неопределено;
			Для Каждого СтруктураТипа Из ТаблицаТипов Цикл
				Если Истина
					И мПлатформа.мРежимПроверкиМодуля
					И ирОбщий.ЛиИмяТипаФормыЛкс(СтруктураТипа.ИмяОбщегоТипа, Истина) 
					И СтруктураТипа.Детальность < 5 
				Тогда
					Продолжить;
				КонецЕсли;
				ТаблицаСловОбъекта = мПлатформа.ТаблицаСловИзСтруктурыТипа(СтруктураТипа,,,,,, "Свойство",,,,, ТаблицаСловОбъекта,,, БазовоеРасширениеКонфигурации); 
			КонецЦикла;
			Если ТаблицаСловОбъекта <> Неопределено Тогда
				ЗначенияПараметра = ТаблицаСловОбъекта.ВыгрузитьКолонку("Слово");
				Если ЗначенияПараметра.Количество() > 0 Тогда
					КонтекстТекстовогоЛитералаИзвестен = Истина;
					Прервать;
				КонецЕсли;
			КонецЕсли;
		КонецЦикла;
	КонецЕсли;
	Если Истина
		И Не КонтекстТекстовогоЛитералаИзвестен 
		И Найти(мТекстБлока, "ЗаполнитьЗначенияСвойств(") > 0 
	Тогда
		// Мультиметка00193361 Вероятно дублирование
		ШаблонПоиска = шПредИнструкция + "ЗаполнитьЗначенияСвойств\(\s*(" + шОбъектноеВыражение + ")\s*,\s*(" + шОбъектноеВыражение + ")\s*,\s*" + ИмяПараметра + "(?=[\s,\)])";
		ВхожденияОбъектов = НайтиВхожденияРегВыраженияКэш(ШаблонПоиска,,, "ОбъектИзЗаполнитьЗначенияСвойств;" + ИмяПараметра);
		Для Каждого Вхождение Из ВхожденияОбъектов Цикл
			ПозицияВхождения0 = Вхождение.FirstIndex;
			Для Счетчик = 0 По 1 Цикл
				ВыражениеВладелецСвойств = Вхождение.SubMatches(Счетчик*4);
				ТаблицаТипов = ВычислитьТипЗначенияВыражения(ВыражениеВладелецСвойств,,,,,, Ложь,,,,, ПозицияВхождения0, Неопределено);
				Если ТаблицаТипов.Количество() > 0 Тогда
					ЛучшийТип = ЛучшийТипИзТаблицыТипов(ТаблицаТипов);
					ТаблицаСловОбъекта = мПлатформа.ТаблицаСловИзСтруктурыТипа(ЛучшийТип,,,,,, "Свойство",,,,,,,, БазовоеРасширениеКонфигурации);
					ЗначенияПараметра = ТаблицаСловОбъекта.ВыгрузитьКолонку("Слово");
					Если ЗначенияПараметра.Количество() > 1 Тогда
						КонтекстТекстовогоЛитералаИзвестен = Истина;
						Прервать;
					КонецЕсли;
				КонецЕсли;
			КонецЦикла;
		КонецЦикла;
	КонецЕсли;
	Если Истина
		И Не КонтекстТекстовогоЛитералаИзвестен 
		И (Ложь
			Или Найти(мТекстБлока, "Выполнить(") > 0 
			Или Найти(мТекстБлока, "Вычислить(") > 0) 
	Тогда
		ШаблонПоиска = шПредИнструкция + "(?:Выполнить|Вычислить)\(""(" + шИмя + ")\.""\s*\+\s*" + ИмяПараметра + "\s*\+\s*""\(";
		ВхожденияОбъектов = НайтиВхожденияРегВыраженияКэш(ШаблонПоиска,,, "ДинамическийВызов;" + ИмяПараметра);
		Для Каждого Вхождение Из ВхожденияОбъектов Цикл
			ПозицияВхождения0 = Вхождение.FirstIndex;
			ИмяПараметраОбъекта = Вхождение.SubMatches(0);
			ТаблицаТипов = ВычислитьТипЗначенияВыражения(ИмяПараметраОбъекта,,,,,, Ложь,,,,, ПозицияВхождения0, Неопределено);
			Если ТаблицаТипов.Количество() > 0 Тогда
				ЛучшийТип = ЛучшийТипИзТаблицыТипов(ТаблицаТипов);
				ТаблицаСловОбъекта = мПлатформа.СловаКонтекстаМетаданные(ЛучшийТип,,,,,, "Метод",,,,,,,, БазовоеРасширениеКонфигурации); 
				ЗначенияПараметра = ТаблицаСловОбъекта.ВыгрузитьКолонку("Слово");
				Если ЗначенияПараметра.Количество() > 0 Тогда
					КонтекстТекстовогоЛитералаИзвестен = Истина;
					Прервать;
				КонецЕсли;
			КонецЕсли;
		КонецЦикла;
	КонецЕсли;
	Если Истина
		И (Ложь
			Или Не мПлатформа.мРежимПроверкиМодуля
			Или КонтекстТекстовогоЛитералаИзвестен)
		И (Ложь
			Или Найти(мТекстБлока, ИмяПараметра + "=") > 0 
			Или Найти(мТекстБлока, ИмяПараметра + " =") > 0)
	Тогда
		ШаблонПоиска = шПредИмяПрямое + "(?:(?:Если|ИначеЕсли|И|Или|If|ElseIf|And|Or)\s|\(|,)\s*" + ИмяПараметра + "\s*=\s*(" + шЛитералПрограммы + ")";
		ВхожденияОбъектов = НайтиВхожденияРегВыраженияКэш(ШаблонПоиска,,, "ЛитеральныеЗначенияПараметра;" + ИмяПараметра);
		Для Каждого Вхождение Из ВхожденияОбъектов Цикл
			ЗначениеПараметра = ирОбщий.ТекстИзВстроенногоЯзыкаЛкс(Вхождение.SubMatches(0));
			Если ЗначенияПараметра.Найти(ЗначениеПараметра) = Неопределено Тогда
				ЗначенияПараметра.Добавить(ЗначениеПараметра);
			КонецЕсли;
		КонецЦикла;
	КонецЕсли;
	Если КонтекстТекстовогоЛитералаИзвестен Тогда
		Возврат ЗначенияПараметра;
	КонецЕсли;
	Если мРекурсивныйПуть = Неопределено Тогда
		ИнициироватьРекурсивныйПуть();
	КонецЕсли;
	МаксВызовов = 4; // Для ускорения
	СчетчикиВызовов = мРекурсивныйПуть.СчетчикиВызовов;
	СчетчикиВызовов[НРег(мМетодМодуля.Имя)] = 1;
	Если СчетчикиВызовов.Количество() > МаксВызовов Тогда 
		// Для ускорения
		Возврат ЗначенияПараметра;
	КонецЕсли;
	ИмяОтключенияЛишнихВычислений = ИмяОтключенияЛишнихВычислений();
	ЭтоТекстовыйЛитерал = мЭтоТекстовыйЛитерал;
	ПозицияТекстаДляПоискаОпределения = мПозицияТекстаДляПоискаОпределения;
	// TODO Поддержать пропуски параметров. Не видит вызовы вида Таб.Найти(, Имя)
	ВхожденияВызовов = НайтиВхожденияРегВыраженияКэш("((Новый\s+)?(" + шОбъектноеВыражение + ")\s*\(\s*(?:(?:" + шПростоеВыражениеПрограммы + "\s*,\s*)*?))" + ИмяПараметра + "\s*[,\)]",,,
		"ПараметрМетода;" + ИмяПараметра);
	Для Каждого Вхождение Из ВхожденияВызовов Цикл
		ПозицияВхождения0 = Вхождение.FirstIndex;
		ВыражениеВызоваМетода = Вхождение.SubMatches(2); 
		ПозицияСсылки = СтрДлина(Вхождение.SubMatches(0)) + 1;
		КлючКэша = НРег(ВыражениеВызоваМетода);
		Если СчетчикиВызовов[КлючКэша] <> Неопределено Тогда  
			Продолжить;
		КонецЕсли;
		СчетчикиВызовов[КлючКэша] = 1;
		ЛиВызовКонструктора = Вхождение.SubMatches(1) <> Неопределено;
		ВыражениеВызоваМетода = ВыражениеВызоваМетода + "(" + ИмяОтключенияЛишнихВычислений + ")";
		ТаблицаТипов = ВычислитьТипЗначенияВыражения(ВыражениеВызоваМетода,,,, ЛиВызовКонструктора,, Ложь,,,,, ПозицияВхождения0, Неопределено);
		Если ТаблицаТипов.Количество() > 0 Тогда
			ПозицияВТексте = ПозицияТекстаДляПоискаОпределения + ПозицияВхождения0 + ПозицияСсылки;
			ПолеТекста.УстановитьГраницыВыделения(ПозицияВТексте, ПозицияВТексте);
			КончитьОбработкуКоманды();
			РазобратьТекущийКонтекст(,, Истина,,,, ПозицияВТексте); 
			Если Не ирОбщий.СтрНачинаетсяСЛкс(ВыражениеВызоваМетода, мВызовМетода, Истина) Тогда
				// Например выражение внутри текстового литерала ирКлиент.ОписаниеОповещенияЛкс
				Продолжить;
			КонецЕсли;
			//ТекущийВызовМетода();
			НовыеЗначенияПараметра = ЗаполнитьТаблицуСловДляТекстовогоЛитерала(ТаблицаТипов[0], КонтекстТекстовогоЛитералаИзвестен);
			Если ЗначенияПараметра.Количество() > 0 Тогда
				ирОбщий.ДополнитьМассивЛкс(НовыеЗначенияПараметра, ЗначенияПараметра);
			КонецЕсли;
			ЗначенияПараметра = НовыеЗначенияПараметра;
		КонецЕсли;
		Если Ложь
			Или КонтекстТекстовогоЛитералаИзвестен 
			Или СчетчикиВызовов.Количество() > МаксВызовов 
		Тогда
			Прервать;
		КонецЕсли;
	КонецЦикла;
	мЭтоТекстовыйЛитерал = ЭтоТекстовыйЛитерал;
	Возврат ЗначенияПараметра;
КонецФункции

Функция ЛучшийТипИзТаблицыТипов(Знач ТаблицаТипов, Знач МинДетальность = 3) Экспорт
	ЛучшийТип = Неопределено; // см. мПлатформа.НоваяСтруктураТипа()
	мПлатформа.ЛиДетальностьТиповДостаточна(ТаблицаТипов, МинДетальность, Истина, ЛучшийТип);
	Возврат ЛучшийТип;
КонецФункции

//.
// Параметры:
//    КоллекцияЭлементовМД - Массив[Строка, ОбъектМетаданных]
Процедура ДобавитьПростыеСлова(КоллекцияЭлементовМД)
	Для Каждого ЭлементКоллекцииМД Из КоллекцияЭлементовМД Цикл
		СтрокаСлова = ТаблицаСлов.Добавить();
		Если Ложь
			Или ТипЗнч(ЭлементКоллекцииМД) = Тип("Строка") 
			Или ТипЗнч(ЭлементКоллекцииМД) = Тип("ПараметрКомпоновкиДанных")
			Или ТипЗнч(ЭлементКоллекцииМД) = Тип("ПолеКомпоновкиДанных")
		Тогда
			СтрокаСлова.Слово = "" + ЭлементКоллекцииМД;
		Иначе
			СтрокаСлова.Слово = ЭлементКоллекцииМД.Имя;
		КонецЕсли; 
		СтрокаСлова.ТипСлова = "Свойство";
		СтрокаСлова.Определение = "Метаданные";
		СтрокаСлова.ТипЗначения = "Строка";
	КонецЦикла;
КонецПроцедуры

//.
// Параметры:
//    ТолькоЭкспортные - Строка - 
// Возвращаемое значение:
//    КоллекцияМетаданныхФункциональныеОпции, Массив[?], Массив[Строка] - 
Функция ОтобратьМетодыДляСпискаСлов(Знач Модуль, Знач ЛиЭкспортные = Истина, Знач ЛиБезПараметров = Ложь) Экспорт
	Если Модуль = Неопределено Тогда
		Модуль = мМодульМетаданных;
	КонецЕсли;
	ОтобранныеМетоды = Модуль.Методы;
	УсловиеОтбора = "Э.Имя<>П1";
	Если ЛиЭкспортные Тогда 
		УсловиеОтбора = УсловиеОтбора + " И Э.ЛиЭкспорт";
	КонецЕсли;
	Если ЛиБезПараметров Тогда 
		УсловиеОтбора = УсловиеОтбора + " И Не ЗначениеЗаполнено(Э.Параметры)";
	КонецЕсли;
	КоллекцияЭлементовМД = ирОбщий.ОтобратьКоллекциюЛкс(ОтобранныеМетоды, УсловиеОтбора,, "<>");
	Возврат КоллекцияЭлементовМД;
КонецФункции

//.
// Параметры:
//    КоллекцияЭлементовМД - ? - 
Процедура ДобавитьКоллекциюМетаданныхВТаблицуСлов(Знач КоллекцияЭлементовМД) Экспорт
КонецПроцедуры

// .
//
// Параметры:
//  СтрокаОписания	 - 	 - 
//  СТипомСтрока	 - Булево - для платформенного метода находить только параметр со строковым типом значения
// 
// Возвращаемое значение:
//  Строка - 
//
Функция ИмяПараметраВызоваМетода(СтрокаОписания, Знач СТипомСтрока = Истина, выхТаблицаТипов = Неопределено) Экспорт
	ИмяПараметра = "";
	Если СтрокаОписания = Неопределено Тогда
		Возврат ИмяПараметра;
	КонецЕсли;
	Если СтрокаОписания.Владелец().Колонки.Найти("ТелоБезВозвратов") <> Неопределено Тогда  
		ПараметрыМетодаМодуля = мПлатформа.ПараметрыМетодаМодуля(СтрокаОписания);
		Если ПараметрыМетодаМодуля <> Неопределено И ПараметрыМетодаМодуля.Количество() >= мНомерПараметра Тогда
			// TODO добавить проверку на строковый тип
			СтрокаПараметра = ПараметрыМетодаМодуля[мНомерПараметра - 1];
			ИмяПараметра = СтрокаПараметра.Имя;
			Если Не СТипомСтрока Тогда 
				выхТаблицаТипов = ТаблицаТиповИзПараметраМетодаМодуля(СтрокаОписания, СтрокаПараметра);
			КонецЕсли;
		КонецЕсли;
	Иначе
		СтрокиПараметров = мПлатформа.ПараметрыМетодаПлатформы(СтрокаОписания);
		СтрокиПараметров = СтрокиПараметров.НайтиСтроки(Новый Структура("Номер", мНомерПараметра));
		Для Каждого СтрокаПараметра Из СтрокиПараметров Цикл
			Если Ложь
				Или Не СТипомСтрока
				Или Найти(СтрокаПараметра.ТипЗначения, "Строка") > 0 
				Или Истина
					// Структура - По ключам и значениям
					И СтрокаПараметра.ТипЗначения = "Произвольный"  
					И Найти(СтрокаПараметра.Описание, "Строка") > 0
			Тогда
				ИмяПараметра = ПодготовитьИмяПараметраМетодаПлатформы(СтрокаПараметра.Параметр);
				Если Не СТипомСтрока Тогда
					выхТаблицаТипов = ТаблицаТиповИзТекста(СтрокаПараметра.ТипЗначения);
				КонецЕсли;
				Прервать;
			КонецЕсли; 
		КонецЦикла;
	КонецЕсли;
	Возврат ИмяПараметра;
КонецФункции

// до 5мс в больших методах и модулях
Функция КопияКомпоненты() Экспорт 
	
	КопияКопоненты = ирОбщий.НовыйАнализаторКодаЛкс();  
	ЗаполнитьЗначенияСвойств(КопияКопоненты, ЭтотОбъект);
	Возврат КопияКопоненты;

КонецФункции

Процедура ВставитьВыбранноеСловоАвтодополнения(СтрокаРезультата, ТаблицаТиповКонтекста = Неопределено, ПараметрЗакрытияПодсказки = Истина) Экспорт 

	#Если Сервер И Не Сервер Тогда
		ПолеТекста = Обработки.ирОболочкаПолеТекста.Создать();
	#КонецЕсли
	ТаблицаСтатистикиВыбора = мПлатформа.ТаблицаСтатистикиВыбора;
	РодительИСлово = РодительИСловоСтрокиТаблицыСлов(СтрокаРезультата);
	Слово = РодительИСлово.Слово;
	СтруктураТипаКонтекста = РодительИСлово.СтруктураТипаКонтекста;
	Если ирОбщий.СтрНачинаетсяСЛкс(Слово, мНачалоСлова + мКонецКонтекста) = 1 Тогда 
		НеобрабатываемыйКонецСтроки = Сред(мТекущаяСтрокаКонец, СтрДлина(мКонецКонтекста) + 1);
	Иначе
		НеобрабатываемыйКонецСтроки = мТекущаяСтрокаКонец;
		мРегВыражение.Pattern = "[" + шБуква + "\d]";
		Если мРегВыражение.Проверить(Лев(НеобрабатываемыйКонецСтроки, 1)) Тогда
			НеобрабатываемыйКонецСтроки = " " + НеобрабатываемыйКонецСтроки;
		КонецЕсли; 
	КонецЕсли;
	СтрокаНачала = "";
	Если Истина
		И Не мЭтоТекстовыйЛитерал 
		И Не ЛиВнутриКомментария()
		И СтрокаРезультата.ТипСлова = "Метод" 
	Тогда
		Если Лев(мКонецКонтекста, 1) = "(" Тогда 
			НеобрабатываемыйКонецСтроки = Сред(НеобрабатываемыйКонецСтроки, 2);
		КонецЕсли;
		СтрокаОкончания = "()";
		Если Истина
			И ПараметрЗакрытияПодсказки = Истина 
			И Прав(мТекущееСлово, 1) = "(" 
		Тогда 
			СтрокаОкончания = "(";
		Иначе
			Если Истина
				И ЯзыкПрограммы = 0 
				И Лев(НеобрабатываемыйКонецСтроки, 1) <> ";"
				И СтрокаРезультата.ТипЗначения = ""
				И СтрокаРезультата.Определение <> "Статистический"
			Тогда
				СтрокаОкончания = СтрокаОкончания + ";"
			КонецЕсли;
		КонецЕсли;
		СмещениеКурсораВОкончании = СтрДлина(СтрокаОкончания);
		Если ПараметрЗакрытияПодсказки = Истина Тогда
			ТаблицаМетодовМодуля = мПлатформа.СловаКонтекстаМетаданные(СтруктураТипаКонтекста, Слово, "Метод",,,,, Истина, мФлагиКомпиляции, МодульМетаданныхКонтекста(СтруктураТипаКонтекста),,,,,
				БазовоеРасширениеКонфигурации());
			Если Истина
				И ТаблицаМетодовМодуля.Количество() > 0 
				И ТаблицаМетодовМодуля[0].Слово <> "<>"
			Тогда
				СтрокаОписания = ТаблицаМетодовМодуля[0].ТаблицаТипов[0].СтрокаОписания;
				Если Ложь
					Или (Истина
						И ТипЗнч(СтрокаОписания) = Тип("COMОбъект") 
						И СтрокаОписания.Parameters.Count > 0)
					Или (Истина
						И ТипЗнч(СтрокаОписания) = Тип("СтрокаТаблицыЗначений")
						И СтрокаОписания.Параметры <> Неопределено)
				Тогда
					СмещениеКурсораВОкончании = 1;
				КонецЕсли; 
			Иначе
				МассивОбщихТипов = мПлатформа.ТаблицаОбщихТиповИзСтруктурыТипа(СтруктураТипаКонтекста, мЭтоЛокальныйКонтекстТаблицыСлов);
				КлючПоискаПараметров = Новый Структура("ТипКонтекста, ЯзыкПрограммы, ТипЯзыка, НСлово, ТипСлова"); // Индекс 
				КлючПоискаПараметров.НСлово = НРег(Слово);
				КлючПоискаПараметров.ЯзыкПрограммы = ЯзыкПрограммы;
				КлючПоискаПараметров.ТипЯзыка = "";
				КлючПоискаПараметров.ТипСлова = СтрокаРезультата.ТипСлова;
				СмещениеКурсораВОкончании = 2;
				Для Каждого СтрокаОбщегоТипа Из МассивОбщихТипов Цикл
					КлючПоискаПараметров.ТипКонтекста = СтрокаОбщегоТипа.ИмяОбщегоТипа;
					СтрокиКонтекста = мПлатформа.ТаблицаКонтекстов.НайтиСтроки(КлючПоискаПараметров);
					Если СтрокиКонтекста.Количество() > 0 Тогда
						НайденныеСтроки = мПлатформа.ПараметрыМетодаПлатформы(СтрокиКонтекста[0]);
						Если НайденныеСтроки.Количество() > 0 Тогда 
							СмещениеКурсораВОкончании = 1;
							Прервать;
						КонецЕсли;
					КонецЕсли;
				КонецЦикла;
			КонецЕсли; 
		КонецЕсли;
	ИначеЕсли Истина
		И ПараметрЗакрытияПодсказки = "."
		И ЯзыкПрограммы <> 0
		И СтрокаРезультата.ТипСлова = "Свойство"
		И Найти(Слово, мПараметрыДиалектаSQL.ПрефиксПараметра) = 1
	Тогда 
		СтрокаНачала = "(";
		СтрокаОкончания = ")";
		СмещениеКурсораВОкончании = 1;
	Иначе
		СтрокаОкончания = "";
		СмещениеКурсораВОкончании = 0;
	КонецЕсли;
	
	// Обновим статистику выбора
	Если Истина
		И СтрокаРезультата.Определение <> "Локальный" 
		И СтрокаРезультата.Определение <> "Статистический" 
	Тогда
		КлючПоиска = Новый Структура("ЯзыкПрограммы, ТипКонтекста, Слово", ЯзыкПрограммы, мКонкретныйТипКонтекста, Слово);
		НайденныеСтроки = ТаблицаСтатистикиВыбора.НайтиСтроки(КлючПоиска);
		Если НайденныеСтроки.Количество() > 0 Тогда
			СтрокаСтатистикиВыбора = НайденныеСтроки[0];
		Иначе
			СтрокаСтатистикиВыбора = ТаблицаСтатистикиВыбора.Добавить();
			ЗаполнитьЗначенияСвойств(СтрокаСтатистикиВыбора, КлючПоиска);
		КонецЕсли;
		СтрокаСтатистикиВыбора.Рейтинг = СтрокаСтатистикиВыбора.Рейтинг + 1;
	КонецЕсли; 
	
	СтрокаДобавка = СтрокаНачала + Слово + СтрокаОкончания;
	Если мРодительскийКонтекст <> "" Тогда
		Если РодительИСлово.ВнутриГруппыОбщихМодулей Тогда
			мРодительскийКонтекст = СтруктураТипаКонтекста.Метаданные.Имя;
		КонецЕсли;
		СтрокаДобавка = мРодительскийКонтекст + "." + СтрокаДобавка;
	КонецЕсли;
	мРодительскийКонтекст = СтрокаДобавка;
	Если Истина
		И ПараметрЗакрытияПодсказки <> Истина
	Тогда
		СтрокаДобавка = СтрокаДобавка + ПараметрЗакрытияПодсказки;
		мТекущееСлово = Слово;
		Если ПараметрЗакрытияПодсказки = "." Тогда
			Если СтрокаРезультата.Определение = "Статистический" Тогда 
				ТаблицаТиповКонтекста = ВычислитьТипЗначенияВыражения(мРодительскийКонтекст, " " + мТекстДляПоискаОпределения, мПредшествующийТекст, Истина);
			Иначе
				ТаблицаТиповКонтекста = ВычислитьТипДочернегоЭлемента(мПлатформа.ДобавитьВТаблицуТипов(, СтруктураТипаКонтекста), мТекущееСлово, СтрокаРезультата.ТипСлова);
			КонецЕсли;
		КонецЕсли;
	КонецЕсли; 
	Если ирОбщий.СтрКончаетсяНаЛкс(мТекущаяСтрокаНачало, " =") Тогда
		СтрокаДобавка = " " + СтрокаДобавка;
	КонецЕсли;
	мТекущаяСтрокаНачало = Лев(мТекущаяСтрокаНачало, мКонечнаяКолонка - 1 - СтрДлина(мНачалоКонтекста)) + СтрокаДобавка;
	ТекущаяСтрока = мТекущаяСтрокаНачало + НеобрабатываемыйКонецСтроки;
	Если мОригинальныйТекст = "" Тогда
		ВыделенныйТекст("" + ТекущаяСтрока);
	Иначе
		Если ПолеТекста.КоличествоСтрок() < мКонечнаяСтрока Тогда
			ПолеТекста.ДобавитьСтроку(ТекущаяСтрока);
		Иначе
			ПолеТекста.ЗаменитьСтроку(мКонечнаяСтрока, ТекущаяСтрока); // Баг платформы. Вызывает выделение всего предшествующего текста на 8.3.18
		КонецЕсли; 
	КонецЕсли; 
	УстановитьПризнакМодифицированностиФормы();
	мОткрытьСправкуПоПараметру = АвтоматическаяПодсказкаПоВызовуМетода() И СмещениеКурсораВОкончании = 1;
	мКонечнаяКолонка = мКонечнаяКолонка + СтрДлина(СтрокаДобавка) - СтрДлина(мНачалоКонтекста) - СтрДлина(СтрокаОкончания) + СмещениеКурсораВОкончании;
	мНачальнаяКолонка = мКонечнаяКолонка;
	мНачалоКонтекста = мРодительскийКонтекст + ".";
	мНачалоСлова = "";
	ВосстановитьГраницыВыделенияПослеКоманды();
КонецПроцедуры

Функция АвтоматическаяПодсказкаПоВызовуМетода(Обновить = Ложь) Экспорт 
	Если АвтоматическаяПодсказкаПоВызовуМетода = Неопределено Или Обновить Тогда
		АвтоматическаяПодсказкаПоВызовуМетода = ирОбщий.ВосстановитьЗначениеЛкс(ИмяКласса + ".АвтоматическаяПодсказкаПоВызовуМетода") <> Ложь;
	КонецЕсли; 
	Возврат АвтоматическаяПодсказкаПоВызовуМетода;
КонецФункции

Функция АвтоматическаяПодсказкаАвтодополненияHTML(Обновить = Ложь) Экспорт
	Если АвтоматическаяПодсказкаАвтодополненияHTML = Неопределено Или Обновить Тогда
		АвтоматическаяПодсказкаАвтодополненияHTML = ирОбщий.ВосстановитьЗначениеЛкс(ИмяКласса + ".АвтоматическаяПодсказкаАвтодополненияHTML") <> Ложь;
	КонецЕсли; 
	Возврат АвтоматическаяПодсказкаАвтодополненияHTML;
КонецФункции

Функция ГитРепозиторий() Экспорт
	ГитРепозиторий = ирОбщий.ВосстановитьЗначениеЛкс(ИмяКласса + ".ГитРепозиторий");
	Возврат ГитРепозиторий;
КонецФункции

Функция ПоказыватьВсеТипыВСпискеАвтодополненияHTML(Обновить = Ложь) Экспорт 
	Если ПоказыватьВсеТипыВСпискеАвтодополненияHTML = Неопределено Или Обновить Тогда
		ПоказыватьВсеТипыВСпискеАвтодополненияHTML = ирОбщий.ВосстановитьЗначениеЛкс(ИмяКласса + ".ПоказыватьВсеТипыВСпискеАвтодополненияHTML") = Истина;
	КонецЕсли;
	Возврат ПоказыватьВсеТипыВСпискеАвтодополненияHTML;
КонецФункции

// надо вызывать после Форма_ПриОткрытииЛкс
Функция ПредпочитатьHTMLРедакторКода(Обновить = Ложь) Экспорт 
	Если Не ирКэш.ДоступенРедакторМонакоЛкс() Тогда
		Возврат Ложь;
	КонецЕсли;
	Если Истина
		И ирОбщий.ЛиЕстьМодальныеГруппыЛкс()
		И (Ложь
			Или АвтоматическаяПодсказкаАвтодополненияHTML() 
			Или АвтоматическаяПодсказкаПоВызовуМетода())
	Тогда
		Возврат Истина;
	КонецЕсли;
	Если ПредпочитатьHTMLРедакторКода = Неопределено Или Обновить Тогда
		ПредпочитатьHTMLРедакторКода = ирОбщий.ВосстановитьЗначениеЛкс(ИмяКласса + ".ПредпочитатьHTMLРедакторКода") = Истина;
	КонецЕсли;
	Возврат ПредпочитатьHTMLРедакторКода;
КонецФункции

Процедура ДобавитьCOMКлассыВСписокСлов(Знач Соответствие, Знач Компоненты)
	
	Для Каждого Класс Из Компоненты Цикл
		Если Не ЗначениеЗаполнено(Класс.Name) Тогда
			Продолжить;
		КонецЕсли;
		Соответствие[Класс.Name] = 1;
	КонецЦикла;

КонецПроцедуры

Процедура ЗагрузитьВТаблицуСловИзВнутреннейТаблицыСлов(Знач ВнутренняяТаблицаСлов, Знач ВыгрузкаТаблицыСлов)
	
	Для Каждого ВнутренняяСтрокаСлова Из ВнутренняяТаблицаСлов Цикл
		НоваяСтрока = ВыгрузкаТаблицыСлов.Добавить();
		ЗаполнитьЗначенияСвойств(НоваяСтрока, ВнутренняяСтрокаСлова);
		ТаблицаТипов = ВнутренняяСтрокаСлова.ТаблицаТипов;
		Если ТаблицаТипов <> Неопределено Тогда
			ОбновитьТипЗначенияИзТаблицыТипов(НоваяСтрока, ТаблицаТипов);
		КонецЕсли; 
	КонецЦикла;

КонецПроцедуры
                             
Функция УточнитьТипЗначенияВСтрокеТаблицыСлов(Знач СтруктураТипаКонтекста, Знач ТекущаяСтрока, Знач ВернутьСтруктуруТипа = Ложь, Знач НужноУточнитьТип = Истина) Экспорт 
	#Если Сервер И Не Сервер Тогда
		ТекущаяСтрока = ТаблицаСлов.Добавить();
	#КонецЕсли
	ТаблицаТипов = Неопределено;
	НужноУточнитьТип = Ложь
		Или НужноУточнитьТип
		Или Лев(ТекущаяСтрока.ТипЗначения, 2) = "??" 
		Или Найти(ТекущаяСтрока.ТипЗначения, "<") > 0;
	Если НужноУточнитьТип Или ВернутьСтруктуруТипа Тогда
		#Если Сервер И Не Сервер Тогда
			мПлатформа = Обработки.ирПлатформа.Создать();
		#КонецЕсли 
		Если Ложь
			Или ТекущаяСтрока.Определение = "Статистический" 
			Или ТекущаяСтрока.Определение = "Локальный"
		Тогда
			ТаблицаТипов = ВычислитьТипЗначенияВыражения(ТекущаяСтрока.Слово, мТекстДляПоискаОпределения);
		Иначе 
			РодительИСлово = РодительИСловоСтрокиТаблицыСлов(ТекущаяСтрока);
			СтруктураТипаКонтекста = РодительИСлово.СтруктураТипаКонтекста;
			ОписанияСлов = мПлатформа.ТаблицаСловИзСтруктурыТипа(СтруктураТипаКонтекста, мЯзыкПрограммы, Конфигурация,, Истина,, ТекущаяСтрока.ТипСлова, мФлагиКомпиляции, РодительИСлово.Слово,
				МодульМетаданныхКонтекста(СтруктураТипаКонтекста), НужноУточнитьТип,, мЭтоЛокальныйКонтекстТаблицыСлов,, БазовоеРасширениеКонфигурации());
			Если ОписанияСлов.Количество() > 0 Тогда
				ТаблицаТипов = ОписанияСлов[0].ТаблицаТипов;
			КонецЕсли;
		КонецЕсли;
		Если ТаблицаТипов <> Неопределено И НужноУточнитьТип Тогда
			ОбновитьТипЗначенияИзТаблицыТипов(ТекущаяСтрока, ТаблицаТипов, ТекущаяСтрока.Определение <> "Метаданные");
		КонецЕсли; 
	КонецЕсли;
	Возврат ТаблицаТипов;

КонецФункции

//.
// Параметры:
//    ТекущаяСтрока - ОбработкаТабличнаяЧастьСтрока.ирКлсПолеТекстаПрограммы.ТаблицаСлов - 
//    СтруктураТипаКонтекста - СтрокаТаблицыЗначений - 
//    Слово - Строка - 
// Возвращаемое значение:
//    Структура - 
Функция РодительИСловоСтрокиТаблицыСлов(Знач ТекущаяСтрока) Экспорт
	ФрагментыСлова = ирОбщий.СтрРазделитьЛкс(ТекущаяСтрока.Слово, РазделительВариантаКонтекста());
	Слово = ФрагментыСлова[0]; 
	СтруктураТипаКонтекста = мСтруктураТипаКонтекста;
	ВнутриГруппыОбщихМодулей = Ложь; 
	Родитель = "";
	Если ФрагментыСлова.Количество() > 1 Тогда
		Для Каждого СтруктураТипа Из мТаблицаТиповКонтекста Цикл
			Если СтруктураТипа.Метаданные.Имя = ФрагментыСлова[1] Тогда 
				СтруктураТипаКонтекста = СтруктураТипа;
				ВнутриГруппыОбщихМодулей = Истина;
				Родитель = ФрагментыСлова[1];
				Прервать; 
			КонецЕсли;
		КонецЦикла;
	КонецЕсли;
	Результат = Новый Структура;
	Результат.Вставить("Слово", Слово);
	Результат.Вставить("Родитель", Родитель);
	Результат.Вставить("СтруктураТипаКонтекста", СтруктураТипаКонтекста);
	Результат.Вставить("ВнутриГруппыОбщихМодулей", ВнутриГруппыОбщихМодулей);
	Возврат Результат;
КонецФункции

// Вызывается из адаптера
Функция РазделительВариантаКонтекста() Экспорт
	Возврат мПлатформа.РазделительВариантаКонтекста();
КонецФункции

Процедура ОткрытьСписокМетодов(Знач СтрокаПоиска = "", Знач ТолькоЭтогоМодуля = Ложь) Экспорт 
	
	Если Не ЗначениеЗаполнено(СтрокаПоиска) Тогда
		//СтрокаПоиска = ирОбщий.ПервыйФрагментЛкс(мТекущееСлово, "("); // Часто вредно
	КонецЕсли;
	Если ТолькоЭтогоМодуля Тогда
		НовыйКлючСохраненияПоложенияОкна = "ОдинМодуль";
		АнализаторКода = ирКэш.ПолеТекстаМодуляЛкс(мМодульМетаданных.Имя);
	Иначе 
		АнализаторКода = ЭтотОбъект;
	КонецЕсли;  
	ФормаВыбора = АнализаторКода.ПолучитьФорму("МетодыМодулей");
	ФормаВыбора.ПараметрСтрокаПоиска = СтрокаПоиска; 
	Если Не ФормаВыбора.Открыта() Тогда
		ФормаВыбора.КлючСохраненияПоложенияОкна = НовыйКлючСохраненияПоложенияОкна;
	КонецЕсли;
	ФормаВыбора.ПараметрМодуль = мМодульМетаданных; 
	Если мМетодМодуля <> Неопределено Тогда
		ФормаВыбора.ПараметрИмяМетода = мМетодМодуля.Имя; 
	КонецЕсли;
	ФормаВыбора.Открыть();
	
КонецПроцедуры 

Функция ОткрытьПоискВызововСлова(Знач ЧтоИскать = Неопределено, Знач ИскатьНепрямые = Истина, Знач Автозапуск = Истина) Экспорт 
	
	Если ЧтоИскать = Неопределено Тогда
		КончитьОбработкуКоманды();
		РазобратьТекущийКонтекст(,,,,, Истина);
		Если ЗначениеЗаполнено(мРодительскийКонтекст) Тогда
			ТаблицаТиповРодителя = ВычислитьТипЗначенияВыражения(мРодительскийКонтекст, " " + мТекстДляПоискаОпределения, мПредшествующийТекст, Истина);
			Если ТаблицаТиповРодителя.Количество() > 0 Тогда
				СтруктураТипаРодителя = ТаблицаТиповРодителя[0];
			КонецЕсли;
		Иначе 
			СтруктураТипаРодителя = мМодульМетаданных.СтруктураТипа;
		КонецЕсли;
		ЧтоИскать = мКонтекст;
		Если Прав(мКонтекст, 1) <> "(" И ЛиВЗаголовкеМетода() Тогда
			ЧтоИскать = мМетодМодуля.Имя + "(";
			ИмяПараметра = мКонтекст;
		КонецЕсли;
	КонецЕсли; 
	Если Не ЗначениеЗаполнено(ЧтоИскать) Тогда
		Возврат Ложь;
	КонецЕсли;
	ТаблицаТиповКонтекста = ВычислитьТипЗначенияВыражения(ЧтоИскать, " " + мТекстДляПоискаОпределения, мПредшествующийТекст, Истина);
	Если ТаблицаТиповКонтекста.Количество() > 0 Тогда
		СтруктураТипаКонтекста = ТаблицаТиповКонтекста[0];
	Иначе 
		СтруктураТипаКонтекста = мПлатформа.НоваяСтруктураТипа();
	КонецЕсли;
	ПолноеИмяСлова = "";
	Если СтруктураТипаКонтекста.ТипЯзыка = "ИмяТипа" Тогда
		ПолноеИмяСлова = "Новый "; 
		Если ИскатьНепрямые = Неопределено Тогда
			ИскатьНепрямые = Ложь;
		КонецЕсли;
		Если Прав(ЧтоИскать, 1) <> "(" Тогда
			ЧтоИскать = ЧтоИскать + "(";
		КонецЕсли;
		//СтруктураТипаКонтекста = Неопределено;
	Иначе
		Если СтруктураТипаРодителя <> Неопределено Тогда 
			ПолноеИмяСлова = мПлатформа.ИмяТипаИзСтруктурыТипа(СтруктураТипаРодителя) + ".";
			Если ИскатьНепрямые = Неопределено Тогда
				ИскатьНепрямые = Ложь;
			КонецЕсли;
			//СтруктураТипаКонтекста = Неопределено;
		Иначе
			Если ирОбщий.МножественноеИмяМДЛкс(ирОбщий.ПервыйФрагментЛкс(ЧтоИскать)) <> Неопределено Тогда
				//ПолноеИмяСлова = ирОбщий.ПервыеФрагментыЛкс(ЧтоИскать,, Макс(2, СтрЧислоВхождений(ЧтоИскать, ".") - 1)) + ".";
				ПолноеИмяСлова = ирОбщий.СтрокаБезПоследнегоФрагментаЛкс(ЧтоИскать) + "."; // TODO сделать вычисление типа родителя
			КонецЕсли;
			Если ИскатьНепрямые = Неопределено Тогда
				СтрокаОписания = СтруктураТипаКонтекста.СтрокаОписания; // СтрокаТаблицыЗначений
				Если Истина
					И СтрокаОписания <> Неопределено
					И СтрокаОписания.Владелец().Колонки.Найти("ТипКонтекста") <> Неопределено
					И СтрокаОписания.ТипКонтекста = "Глобальный"
				Тогда
					ИскатьНепрямые = Ложь;
				ИначеЕсли Истина
					И мМодульМетаданных <> Неопределено
					И СтрокаОписания <> Неопределено
					И СтрокаОписания.Владелец() = мМодульМетаданных.Методы
					И Не мМетодМодуля.ЛиЭкспорт
				Тогда
					ИскатьНепрямые = Ложь;
				Иначе
					ИскатьНепрямые = Истина;
				КонецЕсли;
			КонецЕсли;
		КонецЕсли;
	КонецЕсли;
	ПолноеИмяСлова = ПолноеИмяСлова + ирОбщий.ПоследнийФрагментЛкс(ЧтоИскать);
	ПоискВызововМетода = ПолучитьФорму("ПоискВМодулях"); // Всегда новая, т.к. при открытии будет подмена основного объекта
	ПоискВызововМетода.ПараметрЧтоИскать = ПолноеИмяСлова;
	ПоискВызововМетода.ПараметрСтруктураТипаРодителя = СтруктураТипаРодителя;
	ПоискВызововМетода.ПараметрРежимПоиска = "Ссылки";
	ПоискВызововМетода.ПараметрИскатьНепрямые = ИскатьНепрямые;
	ПоискВызововМетода.ПараметрСтруктураТипаКонтекста = СтруктураТипаКонтекста;
	ПоискВызововМетода.ПараметрИмяПараметра = ИмяПараметра;
	ПоискВызововМетода.Открыть();
	Если Автозапуск Тогда
		ПоискВызововМетода.ОбновитьДанные();
	КонецЕсли;
	Возврат Истина;
	
КонецФункции

Функция ОткрытьПоискВМодулях(Знач ЧтоИскать = Неопределено, Знач Автозапуск = Истина) Экспорт 
	
	Если ЧтоИскать = Неопределено Тогда
		ЧтоИскать = ВыделенныйТекст();
		Если Истина
			И Не ЗначениеЗаполнено(ЧтоИскать) 
			И ЗначениеЗаполнено(ТекущееОбъектноеВыражение())
		Тогда
			Возврат ОткрытьПоискВызововСлова(, Истина, Автозапуск);
		КонецЕсли;
	КонецЕсли;
	ПоискВызововМетода = ПолучитьФорму("ПоискВМодулях"); // Всегда новая, т.к. при открытии будет подмена основного объекта
	ПоискВызововМетода.ПараметрЧтоИскать = ЧтоИскать;
	ПоискВызововМетода.ПараметрРежимПоиска = "Точный";
	ПоискВызововМетода.Открыть();
	Если Автозапуск и ЗначениеЗаполнено(ЧтоИскать) Тогда
		ПоискВызововМетода.ОбновитьДанные();
	КонецЕсли;
	Возврат Истина;
	
КонецФункции

// Заменяет все символы табуляции в строке после первого печатного символа эквивалентным количеством пробелов.
//
// Параметры:
//  Строка       - Строка;
//
// Возвращаемое значение:
//  Строка.
//
Функция ЗаменитьТабуляцииВСтроке(Знач Строка, ЛиТекущая = Ложь)
	
	Табы = "";
	А = 1; НачалоСтроки = Истина;   
	Пока А <= СтрДлина(Строка) Цикл
		Если Сред(Строка, А, 1) <> Символы.Таб И НачалоСтроки Тогда
			// Найдем начало строки без табов 
			Табы = Лев(Строка, А-1);
			Строка = Прав(Строка, СтрДлина(Строка) - А + 1);
			НачалоСтроки = Ложь;
		ИначеЕсли Сред(Строка, А, 1) = Символы.Таб И НЕ НачалоСтроки Тогда
			// Удалим табы из строки 
			Строка = Лев(Строка, А - 1) + Лев("    ", 4 - СтрДлина(Лев(Строка, А - 1)) % 4) 
				+ Прав(Строка, СтрДлина(Строка) - А);
			Если Истина
				И ЛиТекущая
				И мКонечнаяКолонка > А
			Тогда
				мКонечнаяКолонка = мКонечнаяКолонка + 3 - СтрДлина(Лев(Строка, А - 1)) % 4;
			КонецЕсли;
		КонецЕсли;
		А = А + 1;
	КонецЦикла;
	
	Возврат Табы + Строка;
    
КонецФункции

// Заменяет все символы табуляции в каждой строке текста после первого печатного символа эквивалентным
// количеством пробелов.
//
// Параметры:
//  Нет.
//
Процедура ЗаменитьТабуляции()

	Если Ложь
		Или ПолеТекста.ТолькоПросмотр()
		Или ФормаВладелец.ТолькоПросмотр
	Тогда
		Возврат;
	КонецЕсли;
	КоличествоСтрок = ПолеТекста.КоличествоСтрок();
	Для А = 1 По КоличествоСтрок Цикл
	    Строка = ЗаменитьТабуляцииВСтроке(ПолеТекста.ПолучитьСтроку(А), (А = мКонечнаяСтрока));
	    ПолеТекста.ЗаменитьСтроку(А, Строка);
	КонецЦикла;
	УстановитьПризнакМодифицированностиФормы();
	мНачальнаяКолонка = мКонечнаяКолонка;

КонецПроцедуры

Процедура УстановитьАвтоКонтекстнаяПомощь(НовыйРежим)

	Кнопка = ирКлиент.КнопкаКоманднойПанелиЭкземпляраКомпонентыЛкс(ЭтотОбъект, "АвтоКонтекстнаяПомощь");
	Если Кнопка = Неопределено Тогда
		// Это сделано временно для работы в ссылочном режиме
		Возврат;
	КонецЕсли; 
	мАвтоКонтекстнаяПомощь = НовыйРежим;
	Если мАвтоКонтекстнаяПомощь Тогда
		ФормаВладелец.ПодключитьОбработчикОжидания("КлсПолеТекстаПрограммыАвтоОбновитьСправку", 1);
	Иначе
		ФормаВладелец.ОтключитьОбработчикОжидания("КлсПолеТекстаПрограммыАвтоОбновитьСправку");
	КонецЕсли; 
	Кнопка.Пометка = мАвтоКонтекстнаяПомощь;

КонецПроцедуры

// Удаляет все символы переноса строки из текста.
Процедура УдалитьПереносы()
	
	#Если Сервер И Не Сервер Тогда
		ПолеТекста = Обработки.ирОболочкаПолеТекста.Создать();
	#КонецЕсли
	Если Ложь
		Или ПолеТекста.ТолькоПросмотр()
		Или ФормаВладелец.ТолькоПросмотр
	Тогда
		Возврат;
	КонецЕсли;
	Текст = ПолеТекста.ПолучитьТекст();
	Текст = мПлатформа.ЗамаскироватьДирективыПрепроцессора(Текст);
	Текст = СокрЛП(Текст);
	Если Истина
		И Лев(Текст, 1) = """"
		И Лев(Текст, 2) <> """"""
	Тогда
		Текст = "|" + Сред(Текст, 2);
	КонецЕсли; 
	ОбработанныеСтроки = Новый Массив;
	Для Каждого СтрокаТекста Из ирОбщий.СтрРазделитьЛкс(Текст, Символы.ПС) Цикл
		Если Лев(СокрЛ(СтрокаТекста), 1) = "|" Тогда
			СтрокаТекста = СтрЗаменить(СтрокаТекста, """""", """");
			СтрокаТекста = СтрЗаменить(СтрокаТекста, "|", "");
		КонецЕсли;
		ОбработанныеСтроки.Добавить(СтрокаТекста);
	КонецЦикла;
	Текст = ирОбщий.СтрСоединитьЛкс(ОбработанныеСтроки, Символы.ПС);
	Если Истина
		И Прав(Текст, 1) = """"
		И Прав(Текст, 2) <> """"""
	Тогда
		Текст = Лев(Текст, СтрДлина(Текст) - 1);
	КонецЕсли; 
	Если Истина
		И Прав(Текст, 2) = """;"
		И Прав(Текст, 3) <> """"";"
	Тогда
		Текст = Лев(Текст, СтрДлина(Текст) - 2);
	КонецЕсли;
	ВыделитьВесьТекст();
	ВыделенныйТекст(Текст);
	УстановитьПризнакМодифицированностиФормы();
	
КонецПроцедуры

// .
// Параметры:
//  РодительскаяСтруктураТипа	 - см. ОбработкаОбъект.ирПлатформа.НоваяСтруктураТипа() - 
Функция ВычислитьПолучитьФорму(Знач РодительскаяСтруктураТипа, Знач МассивПараметров, Знач Слово = "", Знач ПредшествующийТекст = "", Знач ПозицияВМетоде = 0, Знач ТаблицаТипов = Неопределено) 
	Если МассивПараметров.Количество() = 0 Тогда
		ИмяФормы = "";
	Иначе
		ИмяФормы = ВычислитьЗначениеВыражения(МассивПараметров[0], ПредшествующийТекст,,, ПозицияВМетоде);
	КонецЕсли; 
	Если ИмяФормы = Неопределено Тогда
		//СтруктураТипа = мПлатформа.СтруктураТипаИзКонкретногоТипа(ирОбщий.ТипУправляемаяФормаЛкс());
	Иначе 
		Если Найти(ИмяФормы, ".") = 0 Тогда
			Если ирОбщий.СтрокиРавныЛкс("ПолучитьОбщуюФорму", Слово) Тогда
				МетаФорма = Метаданные.ОбщиеФормы.Найти(ИмяФормы);
			Иначе
				ОбъектМД = ОбъектМДИзСтруктурыТипаМодуля(РодительскаяСтруктураТипа);
				Если ТипЗнч(ОбъектМД) = Тип("Форма") Тогда
					Попытка
						ОбъектМД = ОбъектМД.Метаданные(); 
					Исключение
					КонецПопытки;
				КонецЕсли;
				Если ТипЗнч(ОбъектМД) <> Тип("ОбъектМетаданных") Тогда
					Возврат Неопределено;
				КонецЕсли;
				Если ЗначениеЗаполнено(ИмяФормы) Тогда
					МетаФорма = ОбъектМД.Формы.Найти(ИмяФормы); 
				ИначеЕсли ирОбщий.СтрокиРавныЛкс("ПолучитьФормуСписка", Слово) Тогда     
					МетаФорма = ОбъектМД.ОсновнаяФормаСписка;
				ИначеЕсли ирОбщий.СтрокиРавныЛкс("ПолучитьФормуВыбора", Слово) Тогда     
					МетаФорма = ОбъектМД.ОсновнаяФормаДляВыбора;
				Иначе
					ИменаСвойствОсновнойФормы = Новый Массив();
					ИменаСвойствОсновнойФормы.Добавить("ОсновнаяФорма");
					ИменаСвойствОсновнойФормы.Добавить("ОсновнаяФормаОбъекта");
					ИменаСвойствОсновнойФормы.Добавить("ОсновнаяФормаЗаписи");
					Для Каждого ИмяСвойстваОсновнойФормы Из ИменаСвойствОсновнойФормы Цикл
						Попытка
							МетаФорма = ОбъектМД[ИмяСвойстваОсновнойФормы];
							Прервать;
						Исключение
						КонецПопытки;
					КонецЦикла;
				КонецЕсли;
			КонецЕсли;
			Если МетаФорма = Неопределено Тогда
				Возврат Неопределено;
			КонецЕсли;
			ИмяФормы = МетаФорма.ПолноеИмя();
		КонецЕсли;
		Если ирОбщий.СтрНачинаетсяСЛкс(ИмяФормы, "Внешн") тогда
			ФрагментыИмени = ирОбщий.СтрРазделитьЛкс(ИмяФормы);
			Если РодительскаяСтруктураТипа.ИмяОбщегоТипа = "Локальный" Тогда
				РодительскаяСтруктураТипа = мМодульМетаданных.СтруктураТипа;
			КонецЕсли;
			Если Истина
				И ирОбщий.СтрНачинаетсяСЛкс(РодительскаяСтруктураТипа.ДержательМетаданных, "Внешн")
				И ирОбщий.СтрокиРавныЛкс(РодительскаяСтруктураТипа.ДержательМетаданных.Метаданные().Имя, ФрагментыИмени[1])
			Тогда
				ИмяФормы = "Ф::" + РодительскаяСтруктураТипа.ДержательМетаданных.ИспользуемоеИмяФайла + "::" + ирОбщий.СтрокаБезПервогоФрагментаЛкс(ИмяФормы);
			КонецЕсли;
		КонецЕсли;
		ФормаИлиИмитатор = мПлатформа.ПассивнаяФормаПоИмениКэш(ИмяФормы);
		Если ФормаИлиИмитатор <> Неопределено Тогда 
			Если ТипЗнч(ФормаИлиИмитатор) = Тип("Структура") Тогда 
				СтруктураТипа = мПлатформа.СтруктураТипаИзКонкретногоТипа(ФормаИлиИмитатор.Тип);
				СтруктураТипа.Метаданные = ФормаИлиИмитатор;
			Иначе 
				Форма = ФормаИлиИмитатор;
				СтруктураТипа = мПлатформа.СтруктураТипаИзЗначения(Форма);
			КонецЕсли;
			Если ТипЗнч(Форма) = Тип("Форма") Тогда     
				СлужебныеДанныеФормы = ирОбщий.СлужебныеДанныеФормыЛкс(Форма);
				Если СлужебныеДанныеФормы <> Неопределено И Не СлужебныеДанныеФормы.Свойство("ИмяФормы") Тогда
					СлужебныеДанныеФормы.ИмяФормы = ИмяФормы;
				КонецЕсли;
			КонецЕсли;
		КонецЕсли;
	КонецЕсли;
	Если СтруктураТипа <> Неопределено Тогда
		Результат = мПлатформа.ДобавитьВТаблицуТипов(, СтруктураТипа);
	КонецЕсли;
	Возврат Результат;

КонецФункции

// .
// Параметры:
//  РодительскаяСтруктураТипа	 - см. ОбработкаОбъект.ирПлатформа.НоваяСтруктураТипа() - 
Функция ВычислитьПолучитьМакет(Знач РодительскаяСтруктураТипа, Знач МассивПараметров, Знач Слово = "", Знач ПредшествующийТекст = "", Знач ПозицияВМетоде = 0, Знач ТаблицаТипов = Неопределено) 
	Если МассивПараметров.Количество() = 0 Тогда
		Возврат Неопределено;
	КонецЕсли;
	ИмяМакета = ВычислитьЗначениеВыражения(МассивПараметров[0], ПредшествующийТекст,,, ПозицияВМетоде);
	Если ИмяМакета = Неопределено Тогда
		Возврат Неопределено;
	КонецЕсли;
	Макет = Неопределено;
	Если ирОбщий.СтрокиРавныЛкс("ПолучитьОбщийМакет", Слово) Тогда
		МетаМакет = Метаданные.ОбщиеМакеты.Найти(ИмяМакета);
		Если МетаМакет <> Неопределено Тогда 
			Макет = ПолучитьОбщийМакет(ИмяМакета);
		КонецЕсли;  
	Иначе
		ОбъектМД = ОбъектМДИзСтруктурыТипаМодуля(РодительскаяСтруктураТипа);
		Если Ложь
			Или ТипЗнч(ОбъектМД) <> Тип("ОбъектМетаданных") 
			Или (Истина 
				// TODO Придумать как тут создать объект внешней обработки
				И ирОбщий.СтрНачинаетсяСЛкс(РодительскаяСтруктураТипа.ИмяОбщегоТипа, "Внешн")
				И Найти(РодительскаяСтруктураТипа.ИмяОбщегоТипа, "Объект."))
		Тогда
			Возврат Неопределено;
		КонецЕсли;
		Если ЗначениеЗаполнено(ИмяМакета) Тогда
			Попытка
				Макеты = ОбъектМД.Макеты;
			Исключение
				Макеты = Новый Массив;
			КонецПопытки;
			МетаМакет = Макеты.Найти(ИмяМакета);
			Если МетаМакет <> Неопределено Тогда 
				Менеджер = Новый(ирОбщий.ИмяТипаИзПолногоИмениМДЛкс(ОбъектМД.ПолноеИмя(), "Менеджер")); // ОбработкаМенеджер.ирПлатформа
				Макет = Менеджер.ПолучитьМакет(ИмяМакета);
			КонецЕсли;
		КонецЕсли;
	КонецЕсли;
	Если МетаМакет = Неопределено Тогда
		Возврат Неопределено;
	КонецЕсли;
	СтруктураТипа = мПлатформа.СтруктураТипаИзЗначения(Макет);
	Результат = мПлатформа.ДобавитьВТаблицуТипов(, СтруктураТипа);
	Возврат Результат;

КонецФункции 

//.
// Параметры:
//    СтруктураТипа - см. ОбработкаОбъект.ирПлатформа.НоваяСтруктураТипа()  -  
// Возвращаемое значение:
//    ОбъектМетаданных, Неопределено - 
Функция ОбъектМДИзСтруктурыТипаМодуля(Знач СтруктураТипа) Экспорт
	ОбъектМД = СтруктураТипа.Метаданные;
	Если ТипЗнч(ОбъектМД) = Тип("Форма") Тогда
		СтруктураТипаОбъекта = мПлатформа.СтруктураТипаОбъектаОбычнойФормы(ОбъектМД);
		Если СтруктураТипаОбъекта <> Неопределено Тогда
			ОбъектМД = СтруктураТипаОбъекта.Метаданные;
		КонецЕсли;
	КонецЕсли;
	Возврат ОбъектМД;
КонецФункции 

// .
// Параметры:
//  РодительскаяСтруктураТипа	 - см. ОбработкаОбъект.ирПлатформа.НоваяСтруктураТипа() - 
Функция ВычислитьПрочитатьЗначениеJSON(Знач РодительскаяСтруктураТипа, Знач МассивПараметров, Знач Слово = "", Знач ПредшествующийТекст = "", Знач ПозицияВМетоде = 0, Знач ТаблицаТипов = Неопределено) 
	Если МассивПараметров.Количество() = 0 Тогда
		Возврат Неопределено;
	КонецЕсли;
	Текст = ВычислитьЗначениеВыражения(МассивПараметров[0], ПредшествующийТекст,,, ПозицияВМетоде);
	Если Текст = Неопределено Тогда
		Возврат Неопределено;
	КонецЕсли;
	Попытка
		ДанныеИзТекста = ирОбщий.ОбъектИзСтрокиJSONЛкс(Текст);
	Исключение
		Возврат Неопределено;
	КонецПопытки;
	СтруктураТипа = мПлатформа.СтруктураТипаИзЗначения(ДанныеИзТекста);
	Результат = мПлатформа.ДобавитьВТаблицуТипов(, СтруктураТипа);
	Возврат Результат;

КонецФункции

// .
// Параметры:
//  РодительскаяСтруктураТипа	 - см. ОбработкаОбъект.ирПлатформа.НоваяСтруктураТипа() - 
Функция ВычислитьФабрикаXDTOПрочитатьJSON(Знач РодительскаяСтруктураТипа, Знач МассивПараметров, Знач Слово = "", Знач ПредшествующийТекст = "", Знач ПозицияВМетоде = 0, Знач ТаблицаТипов = Неопределено) 
	Если МассивПараметров.Количество() = 0 Тогда
		Возврат Неопределено;
	КонецЕсли;
	Текст = ВычислитьЗначениеВыражения(МассивПараметров[0], ПредшествующийТекст,,, ПозицияВМетоде);
	Если Текст = Неопределено Тогда
		Возврат Неопределено;
	КонецЕсли;
	Попытка              
		Чтение = Новый("ЧтениеJSON"); // В 8.2 нет
		Чтение.УстановитьСтроку(Текст);
		ДанныеИзТекста = ФабрикаXDTO.ПрочитатьJSON(Чтение);
	Исключение
		Возврат Неопределено;
	КонецПопытки;
	СтруктураТипа = мПлатформа.СтруктураТипаИзЗначения(ДанныеИзТекста);
	Результат = мПлатформа.ДобавитьВТаблицуТипов(, СтруктураТипа);
	Возврат Результат;

КонецФункции

// .
// Параметры:
//  РодительскаяСтруктураТипа	 - см. ОбработкаОбъект.ирПлатформа.НоваяСтруктураТипа() - 
Функция ВычислитьФабрикаXDTOСоздать(Знач РодительскаяСтруктураТипа, Знач МассивПараметров, Знач Слово = "", Знач ПредшествующийТекст = "", Знач ПозицияВМетоде = 0, Знач ТаблицаТипов = Неопределено) 
	Если МассивПараметров.Количество() < 1 Тогда
		Возврат Неопределено;
	КонецЕсли;
	ТипОбъекта = ВычислитьЗначениеВыражения(МассивПараметров[0], ПредшествующийТекст,,, ПозицияВМетоде);
	Если ТипОбъекта = Неопределено Тогда
		Возврат Неопределено;
	КонецЕсли;
	Попытка              
		ДанныеИзТекста = ФабрикаXDTO.Создать(ТипОбъекта);
	Исключение
		Возврат Неопределено;
	КонецПопытки;
	СтруктураТипа = мПлатформа.СтруктураТипаИзЗначения(ДанныеИзТекста);
	Результат = мПлатформа.ДобавитьВТаблицуТипов(, СтруктураТипа);
	Возврат Результат;

КонецФункции

// .
// Параметры:
//  РодительскаяСтруктураТипа	 - см. ОбработкаОбъект.ирПлатформа.НоваяСтруктураТипа() - 
Функция ВычислитьФабрикаXDTOТип(Знач РодительскаяСтруктураТипа, Знач МассивПараметров, Знач Слово = "", Знач ПредшествующийТекст = "", Знач ПозицияВМетоде = 0, Знач ТаблицаТипов = Неопределено) 
	Если МассивПараметров.Количество() < 2 Тогда
		Возврат Неопределено;
	КонецЕсли;
	Текст1 = ВычислитьЗначениеВыражения(МассивПараметров[0], ПредшествующийТекст,,, ПозицияВМетоде);
	Если Текст1 = Неопределено Тогда
		Возврат Неопределено;
	КонецЕсли;
	Текст2 = ВычислитьЗначениеВыражения(МассивПараметров[1], ПредшествующийТекст,,, ПозицияВМетоде);
	Если Текст2 = Неопределено Тогда
		Возврат Неопределено;
	КонецЕсли;
	Попытка              
		ДанныеИзТекста = ФабрикаXDTO.Тип(Текст1, Текст2);
	Исключение
		Возврат Неопределено;
	КонецПопытки;
	СтруктураТипа = мПлатформа.СтруктураТипаИзЗначения(ДанныеИзТекста);
	СтруктураТипа.Метаданные = ДанныеИзТекста;
	Результат = мПлатформа.ДобавитьВТаблицуТипов(, СтруктураТипа);
	Возврат Результат;

КонецФункции

// .
// Параметры:
//  РодительскаяСтруктураТипа	 - см. ОбработкаОбъект.ирПлатформа.НоваяСтруктураТипа() - 
Функция ВычислитьФабрикаXDTOПрочитатьXML(Знач РодительскаяСтруктураТипа, Знач МассивПараметров, Знач Слово = "", Знач ПредшествующийТекст = "", Знач ПозицияВМетоде = 0, Знач ТаблицаТипов = Неопределено) 
	Если МассивПараметров.Количество() = 0 Тогда
		Возврат Неопределено;
	КонецЕсли;
	Текст = ВычислитьЗначениеВыражения(МассивПараметров[0], ПредшествующийТекст,,, ПозицияВМетоде);
	Если Текст = Неопределено Тогда
		Возврат Неопределено;
	КонецЕсли;
	Попытка              
		Чтение = Новый ЧтениеXML;
		Чтение.УстановитьСтроку(Текст);
		ДанныеИзТекста = ФабрикаXDTO.ПрочитатьXML(Чтение);
	Исключение
		Возврат Неопределено;
	КонецПопытки;
	СтруктураТипа = мПлатформа.СтруктураТипаИзЗначения(ДанныеИзТекста);
	Результат = мПлатформа.ДобавитьВТаблицуТипов(, СтруктураТипа);
	Возврат Результат;

КонецФункции

// .
// Параметры:
//  РодительскаяСтруктураТипа	 - см. ОбработкаОбъект.ирПлатформа.НоваяСтруктураТипа() - 
Функция ВычислитьПолучитьОбласть(Знач РодительскаяСтруктураТипа, Знач МассивПараметров, Знач Слово = "", Знач ПредшествующийТекст = "", Знач ПозицияВМетоде = 0, Знач ТаблицаТипов = Неопределено) 
	Если МассивПараметров.Количество() = 0 Тогда
		Возврат Неопределено;
	КонецЕсли;
	ПервыйПараметр = МассивПараметров[0];
	ИмяОбласти = ВычислитьЗначениеВыражения(ПервыйПараметр, ПредшествующийТекст,,, ПозицияВМетоде);
	Если Ложь
		Или ИмяОбласти = Неопределено 
		Или ТипЗнч(РодительскаяСтруктураТипа.Метаданные) <> Тип("ТабличныйДокумент")
	Тогда
		Возврат Неопределено;
	КонецЕсли;  
	ТабличныйДокумент = РодительскаяСтруктураТипа.Метаданные; // ТабличныйДокумент
	Попытка
		Если ирОбщий.СтрокиРавныЛкс(Слово, "Область") Тогда
			Значение = ТабличныйДокумент.Область(ИмяОбласти);
		Иначе
			Значение = ТабличныйДокумент.ПолучитьОбласть(ИмяОбласти);
		КонецЕсли;
	Исключение
		Возврат Неопределено;
	КонецПопытки;
	СтруктураТипа = мПлатформа.СтруктураТипаИзЗначения(Значение);
	Результат = мПлатформа.ДобавитьВТаблицуТипов(, СтруктураТипа);
	Возврат Результат;

КонецФункции

// .
// Параметры:
//  РодительскаяСтруктураТипа	 - см. ОбработкаОбъект.ирПлатформа.НоваяСтруктураТипа() - 
Функция ВычислитьРеквизитФормыВЗначение(Знач РодительскаяСтруктураТипа, Знач МассивПараметров, Знач Слово = "", Знач ПредшествующийТекст = "", Знач ПозицияВМетоде = 0, Знач ТаблицаТипов = Неопределено) 
	Если МассивПараметров.Количество() = 0 Тогда
		Возврат Неопределено;
	КонецЕсли;
	Если Не ЛиПодробнаяСтруктураТипаУпрФормы(РодительскаяСтруктураТипа) Тогда
		Возврат Неопределено;
	КонецЕсли;
	ИмяРеквизита = ВычислитьЗначениеВыражения(МассивПараметров[0], ПредшествующийТекст,,, ПозицияВМетоде);
	Если ПустаяСтрока(ИмяРеквизита) Тогда
		Возврат Неопределено;
	КонецЕсли;      
	СлужебныеДанные = ирОбщий.СлужебныеДанныеФормыЛкс(РодительскаяСтруктураТипа.Метаданные);
	Если Истина
		И СлужебныеДанные <> Неопределено
		И СлужебныеДанные.Свойство("Реквизиты")
		И Найти(ИмяРеквизита, ".") = 0 
	Тогда 
		//! СлужебныеДанные.Вставить("Реквизиты"); // см. мПлатформа.НоваяТаблицаРеквизитовФормы()
		ОписаниеРеквизита = СлужебныеДанные.Реквизиты.Найти(НРег(ИмяРеквизита), "НИмя");
		Если Истина
			И ОписаниеРеквизита <> Неопределено
			И ОписаниеРеквизита.Значение <> Неопределено 
		Тогда
			СтруктураТипа = мПлатформа.СтруктураТипаИзЗначения(ОписаниеРеквизита.Значение);
		Иначе 
			Типы = ОписаниеРеквизита.ОписаниеТипов.Типы();
			Если Типы.Количество() = 0 Тогда
				Фрагменты = ирОбщий.СтрРазделитьЛкс(РодительскаяСтруктураТипа.Метаданные.ИмяФормы, "::"); 
				Если Истина
					И Фрагменты.Количество() > 1
					И ИмяРеквизита = "Объект" 
				Тогда
					Попытка
						МенеджерОбъекта = ирОбщий.МенеджерВнешнегоОбъектаЛкс(Фрагменты[1]); // Если в модуле внешней обработки, то можно брать РодительскаяСтруктураТипа.ДержательМетаданных
					Исключение
						МенеджерОбъекта = Неопределено;
					КонецПопытки;
					Если МенеджерОбъекта <> Неопределено Тогда
						СтруктураТипа = мПлатформа.СтруктураТипаИзЗначения(МенеджерОбъекта);
					КонецЕсли;
				КонецЕсли;
			КонецЕсли;
			Если СтруктураТипа = Неопределено Тогда
				Если Типы.Количество() = 0 Тогда
					Возврат Неопределено;
				КонецЕсли;
				СтруктураТипа = мПлатформа.СтруктураТипаИзКонкретногоТипа(Типы[0]);
			КонецЕсли;
		КонецЕсли;
	Иначе
		Возврат Неопределено;
	КонецЕсли;
	Результат = мПлатформа.ДобавитьВТаблицуТипов(, СтруктураТипа);
	Возврат Результат;

КонецФункции

// .
// Параметры:
//  РодительскаяСтруктураТипа	 - см. ОбработкаОбъект.ирПлатформа.НоваяСтруктураТипа() - 
//  МассивПараметров - Массив -
Функция ВычислитьКоллекцияДобавить(Знач РодительскаяСтруктураТипа, Знач МассивПараметров, Знач Слово = "", Знач ПредшествующийТекст = "", Знач ПозицияВМетоде = 0, Знач ТаблицаТипов = Неопределено) 
	Если МассивПараметров.Количество() = 0 Тогда
		Возврат Неопределено;
	КонецЕсли;
	Если РодительскаяСтруктураТипа.ИмяОбщегоТипа = "ВсеЭлементыФормы" Тогда
		ИндексПараметраТипа = 1;
	Иначе 
		ИндексПараметраТипа = 0;
		Если ирОбщий.СтрокиРавныЛкс(Слово, "Вставить") Тогда
			ИндексПараметраТипа = ИндексПараметраТипа + 1;
		КонецЕсли;
	КонецЕсли; 
	Если МассивПараметров.ВГраница() < ИндексПараметраТипа Тогда
		Возврат Неопределено;
	КонецЕсли;
	ПервыйПараметр = НРег(МассивПараметров[ИндексПараметраТипа]);
	Если Не ирОбщий.СтрНачинаетсяСЛкс(ПервыйПараметр, "Тип(""") Тогда
		Возврат Неопределено;
	КонецЕсли;
	ИмяТипа = ирОбщий.ТекстИзВстроенногоЯзыкаЛкс(ирОбщий.ТекстМеждуМаркерамиЛкс(ПервыйПараметр, "тип(", ")"));
	Попытка
		ТипЭлемента = Тип(ИмяТипа);
	Исключение
		Возврат Неопределено;
	КонецПопытки;
	СтруктураТипа = мПлатформа.СтруктураТипаИзКонкретногоТипа(ТипЭлемента);
	ДобавитьЕдинственныйТип(ТаблицаТипов, СтруктураТипа);
	Возврат ТаблицаТипов;

КонецФункции 

// .
// Параметры:
//  РодительскаяСтруктураТипа - см. мПлатформа.НоваяСтруктураТипа() - 
//  ТаблицаТипов - см. мПлатформа.НоваяТаблицаТипов() -
Функция ВычислитьРезультатЗапросаВыгрузить(Знач РодительскаяСтруктураТипа, Знач МассивПараметров, Знач Слово = "", Знач ПредшествующийТекст = "", Знач ПозицияВМетоде = 0, Знач ТаблицаТипов = Неопределено) 
	Если МассивПараметров.Количество() = 0 Тогда
		ПервыйПараметр = "";
	Иначе 
		ПервыйПараметр = МассивПараметров[0];
	КонецЕсли;
	Если Ложь
		Или Не ЗначениеЗаполнено(ПервыйПараметр)
		Или ирОбщий.СтрокиРавныЛкс(ПервыйПараметр, "ОбходРезультатаЗапроса.Прямой")
	Тогда
		ИмяОбщегоТипа = "ТаблицаЗначений";
	Иначе 
		ИмяОбщегоТипа = "ДеревоЗначений";
	КонецЕсли;
	СтрокаТипа = ТаблицаТипов.Найти(ИмяОбщегоТипа, "ИмяОбщегоТипа");
	ДобавитьЕдинственныйТип(ТаблицаТипов, СтрокаТипа);
	Возврат ТаблицаТипов;

КонецФункции

// .
// Параметры:
//  РодительскаяСтруктураТипа - см. мПлатформа.НоваяСтруктураТипа() - 
//  ТаблицаТипов - см. мПлатформа.НоваяТаблицаТипов() -
Функция ВычислитьСкопироватьКолонки(Знач РодительскаяСтруктураТипа, Знач МассивПараметров, Знач Слово = "", Знач ПредшествующийТекст = "", Знач ПозицияВМетоде = 0, Знач ТаблицаТипов = Неопределено) 
	Если ирОбщий.СтрокиРавныЛкс(Слово, "Скопировать") Тогда
		НомерПараметра = 2;
	Иначе
		НомерПараметра = 1;
	КонецЕсли;
	Если МассивПараметров.Количество() < НомерПараметра Тогда
		Возврат ТаблицаТипов;
	Иначе 
		ВыражениеПараметра = МассивПараметров[НомерПараметра - 1];
	КонецЕсли;
	ИменаКолонок = "";
	Если ЗначениеЗаполнено(ВыражениеПараметра) Тогда
		ИменаКолонок = ВычислитьЗначениеВыражения(ВыражениеПараметра, ПредшествующийТекст,,, ПозицияВМетоде);
	КонецЕсли;
	МетаданныеРодителя = РодительскаяСтруктураТипа.Метаданные;
	СтрукутураТипа = мПлатформа.НоваяСтруктураТипа("ТаблицаЗначений");
	Если ТипЗнч(МетаданныеРодителя) = Тип("ТаблицаЗначений") Тогда
		Попытка
			СтрукутураТипа.Метаданные = МетаданныеРодителя.СкопироватьКолонки(ИменаКолонок);
		Исключение
			Возврат ТаблицаТипов;
		КонецПопытки;
	Иначе
		Если ЗначениеЗаполнено(ИменаКолонок) Тогда
			Попытка
				СтрукутураТипа.Метаданные = Новый Структура(ИменаКолонок);
			Исключение
				Возврат ТаблицаТипов;
			КонецПопытки;
			ЗаполнитьЗначенияСвойств(СтрукутураТипа.Метаданные, МетаданныеРодителя);
		ИначеЕсли ТипЗнч(МетаданныеРодителя) = Тип("Структура") Тогда
			СтрукутураТипа.Метаданные = ирОбщий.СкопироватьКоллекциюЛкс(МетаданныеРодителя);
		КонецЕсли;
	КонецЕсли;
	ДобавитьЕдинственныйТип(ТаблицаТипов, СтрукутураТипа);
	Возврат ТаблицаТипов;

КонецФункции 

// .
// Параметры:
//  РодительскаяСтруктураТипа - см. мПлатформа.НоваяСтруктураТипа() - 
//  ТаблицаТипов - см. мПлатформа.НоваяТаблицаТипов() -
Функция ВычислитьТаблицаЗначенийВыгрузитьКолонку(Знач РодительскаяСтруктураТипа, Знач МассивПараметров, Знач Слово = "", Знач ПредшествующийТекст = "", Знач ПозицияВМетоде = 0, Знач ТаблицаТипов = Неопределено) 
	Если Ложь
		Или МассивПараметров.Количество() = 0 
		Или Не ЗначениеЗаполнено(МассивПараметров[0])
	Тогда
		Возврат ТаблицаТипов;
	КонецЕсли; 
	ПервыйПараметр = МассивПараметров[0];
	ИмяКолонки = ВычислитьЗначениеВыражения(ПервыйПараметр, ПредшествующийТекст,,, ПозицияВМетоде);
	Если Истина
		И ТипЗнч(ИмяКолонки) <> Тип("Число") 
		И ТипЗнч(ИмяКолонки) <> Тип("Строка")
	Тогда
		Возврат ТаблицаТипов;
	КонецЕсли;
	Если Истина
		И ТипЗнч(РодительскаяСтруктураТипа.Метаданные) = Тип("Структура") 
		И ТипЗнч(ИмяКолонки) = Тип("Число") 
	Тогда
		// TODO Придумать хранение позиций в структуре
		Возврат ТаблицаТипов;
	КонецЕсли;
	Если ТипЗнч(РодительскаяСтруктураТипа.Метаданные) = Тип("Структура") Тогда 
		ТаблицаТиповЭлемента = ирОбщий.СвойствоСтруктурыЛкс(РодительскаяСтруктураТипа.Метаданные, ИмяКолонки);
	ИначеЕсли ТипЗнч(РодительскаяСтруктураТипа.Метаданные) = Тип("ТаблицаЗначений") Тогда
		Колонки = РодительскаяСтруктураТипа.Метаданные.Колонки;
		Если ТипЗнч(ИмяКолонки) = Тип("Число") И ИмяКолонки >= 0 И ИмяКолонки < Колонки.Количество() Тогда
			Колонка = Колонки[ИмяКолонки];
		Иначе                                        
			Колонка = Колонки.Найти(ИмяКолонки);
		КонецЕсли;
		Если Колонка <> Неопределено Тогда
			ТаблицаТиповЭлемента = мПлатформа.ДобавитьВТаблицуТипов(, Колонка.ТипЗначения);
		КонецЕсли;
	Иначе
		//! РодительскаяСтруктураТипа.Метаданные = 0; // ОбъектМетаданныхТабличнаяЧасть
		Попытка
			Колонка = РодительскаяСтруктураТипа.Метаданные.Реквизиты[ИмяКолонки];
		Исключение
			Колонка = Неопределено;
		КонецПопытки;
		Если Колонка <> Неопределено Тогда
			ТаблицаТиповЭлемента = мПлатформа.ДобавитьВТаблицуТипов(, Колонка.Тип);
		КонецЕсли;
	КонецЕсли;
	Если ТаблицаТиповЭлемента = Неопределено Тогда
		Возврат ТаблицаТипов;
	КонецЕсли;
	СтруктураТипа = мПлатформа.НоваяСтруктураТипа("Массив");
	ИменаТиповЭлементов = Новый СписокЗначений;
	Для Каждого СтруктураТипаЭлемента Из ТаблицаТиповЭлемента Цикл
		ИмяТипаЭлемента = мПлатформа.ИмяТипаИзСтруктурыТипа(СтруктураТипаЭлемента);
		Если ИмяТипаЭлемента <> "?" И ИменаТиповЭлементов.НайтиПоЗначению(ИмяТипаЭлемента) = Неопределено Тогда
			ИменаТиповЭлементов.Добавить(ИмяТипаЭлемента);
		КонецЕсли;
	КонецЦикла;
	Если ИменаТиповЭлементов.Количество() > 0 Тогда
		ИменаТиповЭлементов.СортироватьПоЗначению();
		СтруктураТипа.ИмяОбщегоТипа = СтруктураТипа.ИмяОбщегоТипа + "[" + ирОбщий.СтрСоединитьЛкс(ИменаТиповЭлементов.ВыгрузитьЗначения()) + "]";
	КонецЕсли;
	Результат = мПлатформа.ДобавитьВТаблицуТипов(, СтруктураТипа);
	Возврат Результат;

КонецФункции  

// .
// Параметры:
//  РодительскаяСтруктураТипа - см. мПлатформа.НоваяСтруктураТипа() - 
//  ТаблицаТипов - см. мПлатформа.НоваяТаблицаТипов() -
Функция ВычислитьВременныеТаблицыЗапросаНайти(Знач РодительскаяСтруктураТипа, Знач МассивПараметров, Знач Слово = "", Знач ПредшествующийТекст = "", Знач ПозицияВМетоде = 0, Знач ТаблицаТипов = Неопределено) 
	Если МассивПараметров.Количество() = 0 Тогда
		Возврат Неопределено;
	КонецЕсли;
	ИмяТаблицы = ВычислитьЗначениеВыражения(МассивПараметров[0], ПредшествующийТекст,,, ПозицияВМетоде);
	Если ТипЗнч(ИмяТаблицы) <> Тип("Строка") Тогда
		Возврат Неопределено;
	КонецЕсли;
	ПакетЗапросов = Неопределено;
	ПостроительЗапроса = НайтиЗапросВременнойТаблицы(ИмяТаблицы, РодительскаяСтруктураТипа.Метаданные, ПакетЗапросов);
	ТаблицаТипов[0].Метаданные = ПостроительЗапроса;
	ТаблицаТипов[0].ДержательМетаданных = ПакетЗапросов;
	Возврат ТаблицаТипов;

КонецФункции

// .
// Параметры:
//  РодительскаяСтруктураТипа	 - см. ОбработкаОбъект.ирПлатформа.НоваяСтруктураТипа() - 
Функция ВычислитьНайтиЭлементКоллекцииЛкс(Знач РодительскаяСтруктураТипа, Знач МассивПараметров, Знач Слово = "", Знач ПредшествующийТекст = "", Знач ПозицияВМетоде = 0, Знач ТаблицаТипов = Неопределено) 
	Если МассивПараметров.Количество() = 0 Тогда
		Возврат Неопределено;
	КонецЕсли;
	ТипыКоллекции = ВычислитьТипЗначенияВыражения(МассивПараметров[0],,,,,, Ложь,,,,, ПозицияВМетоде);
	Если ТипыКоллекции.Количество() = 0 Тогда
		Возврат Неопределено;
	КонецЕсли;
	Результат = мПлатформа.ТаблицаТиповЭлементовКоллекции(ТипыКоллекции[0],, мЯзыкПрограммы);
	Возврат Результат;

КонецФункции 

// Массив из Коллекция[0]
// Параметры:
//  РодительскаяСтруктураТипа	 - см. ОбработкаОбъект.ирПлатформа.НоваяСтруктураТипа() - 
Функция ВычислитьОтобратьКоллекциюЛкс(Знач РодительскаяСтруктураТипа, Знач МассивПараметров, Знач Слово = "", Знач ПредшествующийТекст = "", Знач ПозицияВМетоде = 0, Знач ТаблицаТипов = Неопределено) 
	Если МассивПараметров.Количество() < 1 Тогда
		Возврат Неопределено;
	КонецЕсли;
	ТипыКоллекции = ВычислитьТипЗначенияВыражения(МассивПараметров[0],,,,,, Ложь,,,,, ПозицияВМетоде);  
	Если ТипыКоллекции.Количество() = 0 Тогда
		Возврат Неопределено;
	КонецЕсли;
	ТаблицаТиповЭлементов = мПлатформа.ТаблицаТиповЭлементовКоллекции(ТипыКоллекции[0],, мЯзыкПрограммы);
	ИмяОбщегоТипа = "Массив[" + мПлатформа.ПредставлениеМассиваСтруктурТипов(ТаблицаТиповЭлементов) + "]";
	//Результат = мПлатформа.ТаблицаСловИзСтруктурыТипа(РодительскаяСтруктураТипа,,,, Ложь,, "Метод", мФлагиКомпиляции, Слово)[0].ТаблицаТипов; // см. мПлатформа.НоваяТаблицаТипов()
	//Результат[0].ИмяОбщегоТипа = ИмяОбщегоТипа;
	//Пока Результат.Количество() > 1 Цикл
	//	// Удаляем статически вычисленные типы
	//	Результат.Удалить(1);
	//КонецЦикла;
	СтруктураТипа = мПлатформа.НоваяСтруктураТипа(ИмяОбщегоТипа);
	Результат = мПлатформа.ДобавитьВТаблицуТипов(, СтруктураТипа);
	Возврат Результат;

КонецФункции

// .
// Параметры:
//  РодительскаяСтруктураТипа	 - см. ОбработкаОбъект.ирПлатформа.НоваяСтруктураТипа() - 
Функция ВычислитьСкопироватьКолонкиКоллекцииЛкс(Знач РодительскаяСтруктураТипа, Знач МассивПараметров, Знач Слово = "", Знач ПредшествующийТекст = "", Знач ПозицияВМетоде = 0, Знач ТаблицаТипов = Неопределено) 
	Если МассивПараметров.Количество() < 1 Тогда
		Возврат Неопределено;
	КонецЕсли;
	ТипыКоллекцииИсточника = ВычислитьТипЗначенияВыражения(МассивПараметров[0],,,,,, Ложь,,,,, ПозицияВМетоде);  
	Если ТипыКоллекцииИсточника.Количество() = 0 Тогда
		Возврат Неопределено;
	КонецЕсли;
	ТипыКоллекцииИсточника.Сортировать("Детальность Убыв");
	ИмяОбщегоТипа = ТипыКоллекцииИсточника[0].ИмяОбщегоТипа;
	Если МассивПараметров.Количество() > 1 Тогда
		ТипыКоллекцииПриемника = ВычислитьТипЗначенияВыражения(МассивПараметров[1],,,,,, Ложь,,,,, ПозицияВМетоде);  
		Если ТипыКоллекцииПриемника.Количество() > 0 Тогда
			ИмяОбщегоТипа = ТипыКоллекцииПриемника[0].ИмяОбщегоТипа;
		КонецЕсли;
	КонецЕсли;  
	СтруктураТипа = мПлатформа.НоваяСтруктураТипа(ИмяОбщегоТипа);
	ЗаполнитьЗначенияСвойств(СтруктураТипа, ТипыКоллекцииИсточника[0],, "ИмяОбщегоТипа");
	Результат = мПлатформа.ДобавитьВТаблицуТипов(ТипыКоллекцииПриемника, СтруктураТипа);
	Возврат Результат;
КонецФункции

// .
// Параметры:
//  РодительскаяСтруктураТипа	 - см. ОбработкаОбъект.ирПлатформа.НоваяСтруктураТипа() - 
Функция ВычислитьСоздатьОбъектПоИмениМетаданныхЛкс(Знач РодительскаяСтруктураТипа, Знач МассивПараметров, Знач Слово = "", Знач ПредшествующийТекст = "", Знач ПозицияВМетоде = 0, Знач ТаблицаТипов = Неопределено) 
	Если МассивПараметров.Количество() = 0 Тогда
		Возврат Неопределено;
	КонецЕсли;
	Текст = ВычислитьЗначениеВыражения(МассивПараметров[0], ПредшествующийТекст,,, ПозицияВМетоде);
	Попытка
		ИмяТипа = ирОбщий.ИмяТипаИзПолногоИмениМДЛкс(Текст, "Объект");
		ОписаниеТипов = Новый ОписаниеТипов(ИмяТипа);
	Исключение
		Возврат Неопределено;
	КонецПопытки;
	Результат = мПлатформа.ДобавитьВТаблицуТипов(, ОписаниеТипов);
	Возврат Результат;

КонецФункции

// .
// Параметры:
//  РодительскаяСтруктураТипа	 - см. ОбработкаОбъект.ирПлатформа.НоваяСтруктураТипа() - 
Функция ВычислитьВычислить(Знач РодительскаяСтруктураТипа, Знач МассивПараметров, Знач Слово = "", Знач ПредшествующийТекст = "", Знач ПозицияВМетоде = 0, Знач ТаблицаТипов = Неопределено) 
	Если МассивПараметров.Количество() = 0 Тогда
		Возврат Неопределено;
	КонецЕсли;
	Текст = ВычислитьЗначениеВыражения(МассивПараметров[0], ПредшествующийТекст,,, ПозицияВМетоде);
	Если Ложь
		Или ТипЗнч(Текст) <> Тип("Строка") 
		Или Найти(Текст, "(") > 0
	Тогда
		Возврат Неопределено;
	КонецЕсли;
	Попытка
		Значение = Вычислить(Текст);
	Исключение
		Возврат Неопределено;
	КонецПопытки;
	СтруктураТипа = мПлатформа.СтруктураТипаИзЗначения(Значение);
	Если СтруктураТипа.ИмяОбщегоТипа = "ОбщийМодуль" Тогда
		СтруктураТипа.Метаданные = Метаданные.ОбщиеМодули.Найти(Текст);
	КонецЕсли;
	Результат = мПлатформа.ДобавитьВТаблицуТипов(, СтруктураТипа);
	Возврат Результат;

КонецФункции 

// .
// Параметры:
//  РодительскаяСтруктураТипа	 - см. ОбработкаОбъект.ирПлатформа.НоваяСтруктураТипа() - 
Функция ВычислитьПоместитьВоВременноеХранилище(Знач РодительскаяСтруктураТипа, Знач МассивПараметров, Знач Слово = "", Знач ПредшествующийТекст = "", Знач ПозицияВМетоде = 0, Знач ТаблицаТипов = Неопределено) 
	Если МассивПараметров.Количество() = 0 Тогда
		Возврат Неопределено;
	КонецЕсли;
	ТипыСодержимого = ВычислитьТипЗначенияВыражения(МассивПараметров[0],,,,,, Ложь,,,,, ПозицияВМетоде);  
	Если ТипыСодержимого.Количество() = 0 Тогда
		Возврат Неопределено;
	КонецЕсли;
	ТаблицаТипов[0].Метаданные = ТипыСодержимого;
	//ТаблицаТипов[0].Детальность = 5; // перенес в мПлатформа.ОбновитьДетальностьСтруктурыТипа()
	Возврат ТаблицаТипов;

КонецФункции  

// .
// Параметры:
//  РодительскаяСтруктураТипа	 - см. ОбработкаОбъект.ирПлатформа.НоваяСтруктураТипа() - 
Функция ВычислитьПолучитьИзВременногоХранилища(Знач РодительскаяСтруктураТипа, Знач МассивПараметров, Знач Слово = "", Знач ПредшествующийТекст = "", Знач ПозицияВМетоде = 0, Знач ТаблицаТипов = Неопределено) 
	Если МассивПараметров.Количество() = 0 Тогда
		Возврат Неопределено;
	КонецЕсли;
	ТипыУказателя = ВычислитьТипЗначенияВыражения(МассивПараметров[0],,,,,, Ложь,,,,, ПозицияВМетоде);  
	Если ТипыУказателя.Количество() = 0 Тогда
		Возврат Неопределено;
	КонецЕсли; 
	ТипыСодержимого = ТипыУказателя[0].Метаданные; 
	Если ТипЗнч(ТипыСодержимого) <> Тип("ТаблицаЗначений") Тогда
		Возврат Неопределено;
	КонецЕсли;
	Возврат ТипыСодержимого;

КонецФункции  

// .
// Параметры:
//  РодительскаяСтруктураТипа	 - см. ОбработкаОбъект.ирПлатформа.НоваяСтруктураТипа() - 
Функция ВычислитьПредопределенноеЗначение(Знач РодительскаяСтруктураТипа, Знач МассивПараметров, Знач Слово = "", Знач ПредшествующийТекст = "", Знач ПозицияВМетоде = 0, Знач ТаблицаТипов = Неопределено) 
	Если МассивПараметров.Количество() = 0 Тогда
		Возврат Неопределено;
	КонецЕсли;
	ПервыйПараметр = МассивПараметров[0];
	Текст = ВычислитьЗначениеВыражения(ПервыйПараметр, ПредшествующийТекст,,, ПозицияВМетоде);
	Попытка
		Значение = ПредопределенноеЗначение(Текст);
	Исключение
		Возврат Неопределено;
	КонецПопытки;
	СтруктураТипа = мПлатформа.СтруктураТипаИзЗначения(Значение);
	Результат = мПлатформа.ДобавитьВТаблицуТипов(, СтруктураТипа);
	Возврат Результат;

КонецФункции

// .
// Параметры:
//  РодительскаяСтруктураТипа	 - см. ОбработкаОбъект.ирПлатформа.НоваяСтруктураТипа() - 
Функция ВычислитьОбщийМодуль(Знач РодительскаяСтруктураТипа, Знач МассивПараметров, Знач Слово = "", Знач ПредшествующийТекст = "", Знач ПозицияВМетоде = 0, Знач ТаблицаТипов = Неопределено) 
	Если МассивПараметров.Количество() = 0 Тогда
		Возврат Неопределено;
	КонецЕсли;
	ПервыйПараметр = МассивПараметров[0];
	ИмяМодуля = ВычислитьЗначениеВыражения(ПервыйПараметр, ПредшествующийТекст,,, ПозицияВМетоде);
	ОбъектМД = Метаданные.ОбщиеМодули.Найти(ИмяМодуля);
	Если ОбъектМД = Неопределено Тогда
		Возврат Неопределено;
	КонецЕсли;
	СтруктураТипа = мПлатформа.СтруктураТипаИзКонкретногоТипа(Тип("ОбщийМодуль"));
	СтруктураТипа.Метаданные = ОбъектМД;
	Результат = мПлатформа.ДобавитьВТаблицуТипов(, СтруктураТипа);
	Возврат Результат;

КонецФункции

// .
// Параметры:
//  РодительскаяСтруктураТипа	 - см. ОбработкаОбъект.ирПлатформа.НоваяСтруктураТипа() - 
Функция ВычислитьМакетПечатнойФормыБСП(Знач РодительскаяСтруктураТипа, Знач МассивПараметров, Знач Слово = "", Знач ПредшествующийТекст = "", Знач ПозицияВМетоде = 0, Знач ТаблицаТипов = Неопределено) 
	Если МассивПараметров.Количество() = 0 Тогда
		Возврат Неопределено;
	КонецЕсли;
	ПервыйПараметр = МассивПараметров[0];
	ИмяМакета = ВычислитьЗначениеВыражения(ПервыйПараметр, ПредшествующийТекст,,, ПозицияВМетоде);
	Попытка
		Макет = ирСервер.ВычислитьВыражение("УправлениеПечатью.МакетПечатнойФормы(""" + ИмяМакета + """)");
	Исключение
		Макет = Неопределено;
	КонецПопытки;
	Если Макет = Неопределено Тогда
		Возврат Неопределено;
	КонецЕсли;
	СтруктураТипа = мПлатформа.СтруктураТипаИзЗначения(Макет);
	Результат = мПлатформа.ДобавитьВТаблицуТипов(, СтруктураТипа);
	Возврат Результат;

КонецФункции   

// .
// Параметры:
//  РодительскаяСтруктураТипа	 - см. ОбработкаОбъект.ирПлатформа.НоваяСтруктураТипа() - 
Функция ВычислитьЗначенияРеквизитовОбъектаБСП(Знач РодительскаяСтруктураТипа, Знач МассивПараметров, Знач Слово = "", Знач ПредшествующийТекст = "", Знач ПозицияВМетоде = 0, Знач ТаблицаТипов = Неопределено) 
	Если МассивПараметров.Количество() < 2 Тогда
		Возврат Неопределено;
	КонецЕсли;
	// TODO Сделать вычисление значений элементов структуры
	ТаблицаТиповРеквизитов = ВычислитьТипЗначенияВыражения(МассивПараметров[1], ПредшествующийТекст, ПредшествующийТекст,,,, Ложь,,, Истина,, ПозицияВМетоде);
	ИменаРеквизитов = "";
	Если ТаблицаТиповРеквизитов.Количество() > 0 Тогда
		СтруктураТипаРеквизитов = ТаблицаТиповРеквизитов[0];
		ТипЗначения = ТипЗнч(СтруктураТипаРеквизитов.Метаданные); 
		Если ТипЗначения = Тип("Строка") Тогда
			ИменаРеквизитов = СтруктураТипаРеквизитов.Метаданные;
			Попытка 		
				Структура = Новый Структура(ИменаРеквизитов);
			Исключение
				Структура = Неопределено;
			КонецПопытки;		
		ИначеЕсли ТипЗначения = Тип("Структура") Тогда
			Структура = СтруктураТипаРеквизитов.Метаданные;
		Иначе
			Возврат Неопределено;
		КонецЕсли;
	КонецЕсли;
	ТипыСсылки = ВычислитьТипЗначенияВыражения(МассивПараметров[0], ПредшествующийТекст,,,,, Ложь,,,,, ПозицияВМетоде);
	СтруктураТипа = Неопределено;
	Если Истина
		И ЗначениеЗаполнено(ИменаРеквизитов)
		И ТипыСсылки.Количество() > 0 
		И ТипЗнч(ТипыСсылки[0].Метаданные) = Тип("ОбъектМетаданных") 
	Тогда
		ИмяТаблицыБД = ирКэш.ИмяТаблицыИзМетаданныхЛкс(ТипыСсылки[0].Метаданные.ПолноеИмя());
		Попытка
			ТаблицаРезультата = ирОбщий.ПустаяТаблицаЗначенийИзТекстаЗапросаЛкс("ВЫБРАТЬ ПЕРВЫЕ 0 " + ИменаРеквизитов + " ИЗ " + ИмяТаблицыБД + " КАК Т");
		Исключение
			ТаблицаРезультата = Неопределено;
		КонецПопытки;
		Если ТаблицаРезультата <> Неопределено Тогда
			СтруктураТипа = мПлатформа.НоваяСтруктураТипа("Структура");
			Структура = Новый Структура;
			СтруктураТипа.Метаданные = Структура;
			Для Каждого Колонка Из ТаблицаРезультата.Колонки Цикл
				Структура.Вставить(Колонка.Имя, мПлатформа.ТаблицаТиповИзОписанияТипов(Колонка.ТипЗначения));
			КонецЦикла;
		КонецЕсли;
	КонецЕсли;
	Если СтруктураТипа = Неопределено Тогда
		СтруктураТипа = мПлатформа.СтруктураТипаИзЗначения(Структура);
	КонецЕсли;
	Если СтруктураТипа <> Неопределено Тогда
		Результат = мПлатформа.ДобавитьВТаблицуТипов(, СтруктураТипа);
	КонецЕсли;
	Возврат Результат;
КонецФункции 

// .
// Параметры:
//  РодительскаяСтруктураТипа	 - см. ОбработкаОбъект.ирПлатформа.НоваяСтруктураТипа() - 
Функция ВычислитьЗначениеРеквизитаОбъектаБСП(Знач РодительскаяСтруктураТипа, Знач МассивПараметров, Знач Слово = "", Знач ПредшествующийТекст = "", Знач ПозицияВМетоде = 0, Знач ТаблицаТипов = Неопределено) 
	Если МассивПараметров.Количество() < 2 Тогда
		Возврат Неопределено;
	КонецЕсли;
	ИмяРеквизита = ВычислитьЗначениеВыражения(МассивПараметров[1], ПредшествующийТекст,,, ПозицияВМетоде);
	Если ТипЗнч(ИмяРеквизита) <> Тип("Строка") Тогда
		Возврат Неопределено;
	КонецЕсли;
	Попытка
		Структура = Новый Структура(ИмяРеквизита);
	Исключение
		Возврат Неопределено;
	КонецПопытки;
	ТипыСсылки = ВычислитьТипЗначенияВыражения(МассивПараметров[0], ПредшествующийТекст,,,,, Ложь,,,,, ПозицияВМетоде);
	Если ТипыСсылки.Количество() = 0 Тогда
		Возврат Неопределено;
	КонецЕсли;
	Для Каждого СтрокаТипа Из ТипыСсылки Цикл
		Если ТипЗнч(СтрокаТипа.Метаданные) = Тип("ОбъектМетаданных") Тогда
			ТипСсылки = ирОбщий.ИмяТипаИзПолногоИмениМДЛкс(СтрокаТипа.Метаданные.ПолноеИмя());
			Попытка
				ПустаяСсылка = Новый (ТипСсылки);
				ЗначениеРеквизита = ПустаяСсылка[ИмяРеквизита];
				Прервать;
			Исключение
			КонецПопытки;
		КонецЕсли;
	КонецЦикла;
	СтруктураТипа = мПлатформа.СтруктураТипаИзЗначения(ЗначениеРеквизита);
	Результат = мПлатформа.ДобавитьВТаблицуТипов(, СтруктураТипа);
	Возврат Результат;

КонецФункции

// .
// Параметры:
//  РодительскаяСтруктураТипа	 - см. ОбработкаОбъект.ирПлатформа.НоваяСтруктураТипа() - 
Функция ВычислитьСтрокаТаблицыЗначенийВСтруктуруБСП(Знач РодительскаяСтруктураТипа, Знач МассивПараметров, Знач Слово = "", Знач ПредшествующийТекст = "", Знач ПозицияВМетоде = 0, Знач ТаблицаТипов = Неопределено) 
	Если МассивПараметров.Количество() < 1 Тогда
		Возврат Неопределено;
	КонецЕсли;
	ТаблицаТипов = ВычислитьТипЗначенияВыражения(МассивПараметров[0], ПредшествующийТекст,,,,, Ложь,,,,, ПозицияВМетоде);
	Если ТаблицаТипов.Количество() = 0 Тогда
		Возврат Неопределено;
	КонецЕсли;
	ТаблицаСвойств = мПлатформа.ТаблицаСловИзСтруктурыТипа(ТаблицаТипов[0],,,, Ложь,, "Свойство",,,,,,,, БазовоеРасширениеКонфигурации());
	Структура = новый Структура;
	Для Каждого СтрокаСвойства Из ТаблицаСвойств Цикл
		Структура.Вставить(СтрокаСвойства.Слово, СтрокаСвойства.ТаблицаТипов);
	КонецЦикла;
	СтруктураТипа = мПлатформа.СтруктураТипаИзЗначения(Структура);
	Результат = мПлатформа.ДобавитьВТаблицуТипов(, СтруктураТипа);
	Возврат Результат;

КонецФункции

// .
// Параметры:
//  РодительскаяСтруктураТипа - см. ОбработкаОбъект.ирПлатформа.НоваяСтруктураТипа() - 
Функция ВычислитьВнешниеОбъектыСоздать(Знач РодительскаяСтруктураТипа, Знач МассивПараметров, Знач Слово = "", Знач ПредшествующийТекст = "", Знач ПозицияВМетоде = 0, Знач ТаблицаТипов = Неопределено) 
	Если МассивПараметров.Количество() < 1 Тогда
		Возврат Неопределено;
	КонецЕсли;
	ИмяФайла = ВычислитьЗначениеВыражения(МассивПараметров[0], ПредшествующийТекст,,, ПозицияВМетоде);
	Если Не ЗначениеЗаполнено(ИмяФайла) Тогда
		Возврат Неопределено;
	КонецЕсли; 
	Попытка
		ВнешнийОбъект = ирОбщий.МенеджерВнешнегоОбъектаЛкс(ИмяФайла);
	Исключение
		Возврат Неопределено;
	КонецПопытки;
	СтруктураТипа = мПлатформа.СтруктураТипаИзЗначения(ВнешнийОбъект);
	Результат = мПлатформа.ДобавитьВТаблицуТипов(, СтруктураТипа);
	Возврат Результат;

КонецФункции    

// Коллекция
// Параметры:
//  РодительскаяСтруктураТипа	 - см. ОбработкаОбъект.ирПлатформа.НоваяСтруктураТипа() - 
Функция ВычислитьФункцияКопированияПараметра(Знач РодительскаяСтруктураТипа, Знач МассивПараметров, Знач Слово = "", Знач ПредшествующийТекст = "", Знач ПозицияВМетоде = 0, Знач ТаблицаТипов = Неопределено) 
	Если МассивПараметров.Количество() < 1 Тогда
		Возврат Неопределено;
	КонецЕсли;
	ТаблицаТипов = ВычислитьТипЗначенияВыражения(МассивПараметров[0], ПредшествующийТекст,,,,, Ложь,,,,, ПозицияВМетоде);
	Если ТаблицаТипов.Количество() = 0 Тогда
		Возврат Неопределено;
	КонецЕсли;
	Результат = мПлатформа.ДобавитьВТаблицуТипов(, ТаблицаТипов);
	Возврат Результат;

КонецФункции

// .
// Параметры:
//  РодительскаяСтруктураТипа	 - см. ОбработкаОбъект.ирПлатформа.НоваяСтруктураТипа() - 
Функция ВычислитьТаблицаЗначенийИзТабличногоДокументаЛкс(Знач РодительскаяСтруктураТипа, Знач МассивПараметров, Знач Слово = "", Знач ПредшествующийТекст = "", Знач ПозицияВМетоде = 0, Знач ТаблицаТипов = Неопределено) 
	Если МассивПараметров.Количество() = 0 Тогда
		Возврат Неопределено;
	КонецЕсли;
	ТабличныйДокумент = ВычислитьЗначениеВыражения(МассивПараметров[0], ПредшествующийТекст,,, ПозицияВМетоде); // ТабличныйДокумент
	Если ТабличныйДокумент = Неопределено Тогда
		Возврат Неопределено;
	КонецЕсли;
	ТабличныйДокумент = ТабличныйДокумент.ПолучитьОбласть(1,,1);
	Если МассивПараметров.Количество() > 1 И ЗначениеЗаполнено(МассивПараметров[1]) Тогда
		ЛиПерваяСтрокаСодержитИменаКолонок = ВычислитьЗначениеВыражения(МассивПараметров[1], ПредшествующийТекст,,, ПозицияВМетоде);
	КонецЕсли;
	Если ЛиПерваяСтрокаСодержитИменаКолонок = Неопределено Тогда
		ЛиПерваяСтрокаСодержитИменаКолонок = Истина;
	КонецЕсли;
	Попытка
		ТаблицаЗначений = ирОбщий.ТаблицаЗначенийИзТабличногоДокументаЛкс(ТабличныйДокумент, ЛиПерваяСтрокаСодержитИменаКолонок);
	Исключение
		Возврат Неопределено;
	КонецПопытки;      
	СтруктураТипа = мПлатформа.СтруктураТипаИзЗначения(ТаблицаЗначений);
	//СтруктураТипа.СтрокаОписания = ТаблицаТипов[0].СтрокаОписания;
	Результат = мПлатформа.ДобавитьВТаблицуТипов(, СтруктураТипа);
	Возврат Результат;

КонецФункции

// .
// Параметры:
//  РодительскаяСтруктураТипа	 - см. ОбработкаОбъект.ирПлатформа.НоваяСтруктураТипа() - 
Функция ВычислитьНоваяТаблицаЗначенийЛкс(Знач РодительскаяСтруктураТипа, Знач МассивПараметров, Знач Слово = "", Знач ПредшествующийТекст = "", Знач ПозицияВМетоде = 0, Знач ТаблицаТипов = Неопределено) 
	Если МассивПараметров.Количество() < 1 Тогда
		Возврат Неопределено;
	КонецЕсли;
	ИменаКолонок = ВычислитьЗначениеВыражения(МассивПараметров[0], ПредшествующийТекст,,, ПозицияВМетоде);
	Если ТипЗнч(ИменаКолонок) <> Тип("Строка") Тогда
		Возврат Неопределено;
	КонецЕсли;
	Попытка
		ТаблицаЗначений = ирОбщий.НоваяТаблицаЗначенийЛкс(ИменаКолонок); // Натуральное вычисление
	Исключение
		Возврат Неопределено;
	КонецПопытки;
	СтруктураТипа = мПлатформа.СтруктураТипаИзЗначения(ТаблицаЗначений);
	Результат = мПлатформа.ДобавитьВТаблицуТипов(, СтруктураТипа);
	Возврат Результат;

КонецФункции

// .
// Параметры:
//  РодительскаяСтруктураТипа	 - см. ОбработкаОбъект.ирПлатформа.НоваяСтруктураТипа() - 
Функция ВычислитьНайтиРегВыражениеЛкс(Знач РодительскаяСтруктураТипа, Знач МассивПараметров, Знач Слово = "", Знач ПредшествующийТекст = "", Знач ПозицияВМетоде = 0, Знач ТаблицаТипов = Неопределено) 
	Если МассивПараметров.Количество() < 3 Тогда
		Возврат ТаблицаТипов;
	КонецЕсли;
	ИменаКолонок = ВычислитьЗначениеВыражения(МассивПараметров[2], ПредшествующийТекст,,, ПозицияВМетоде);
	Если Ложь
		Или ТипЗнч(ИменаКолонок) <> Тип("Строка") 
		Или ПустаяСтрока(ИменаКолонок)
	Тогда
		Возврат ТаблицаТипов;
	КонецЕсли;
	Попытка
		ТаблицаЗначений = ирОбщий.НоваяТаблицаЗначенийЛкс(ИменаКолонок);
	Исключение
		Возврат ТаблицаТипов;
	КонецПопытки;
	СтруктураТипа = мПлатформа.СтруктураТипаИзЗначения(ТаблицаЗначений);
	Результат = мПлатформа.ДобавитьВТаблицуТипов(ТаблицаТипов, СтруктураТипа);
	Возврат Результат;

КонецФункции

//.
// Параметры:
//    РодительскаяСтруктураТипа - см. ОбработкаОбъект.ирПлатформа.НоваяСтруктураТипа()  -  
// Возвращаемое значение:
//     - 
Функция ЛиПодробнаяСтруктураТипаУпрФормы(РодительскаяСтруктураТипа) Экспорт
	Результат = Истина
		И ирОбщий.ЛиИмяТипаФормыЛкс(РодительскаяСтруктураТипа.ИмяОбщегоТипа) 
		И ирОбщий.ЛиФормаИлиИмитаторЛкс(РодительскаяСтруктураТипа.Метаданные, Ложь);
	Возврат Результат;
КонецФункции

// Добавляет переменную локального контекста.
//
// Параметры:
//  ИмяПеременной - Строка;
//  ДопустимыеТипы - Строка, ТаблицаЗначений;
//
Процедура ДобавитьПеременнуюЛокальногоКонтекста(ИмяПеременной, ДопустимыеТипы) Экспорт

	НоваяСтрока = ДобавитьСловоЛокальногоКонтекста(ИмяПеременной);
	Если ТипЗнч(ДопустимыеТипы) = Тип("Строка") Тогда 
		МассивСериализованныхТипов = ирОбщий.СтрРазделитьЛкс(ДопустимыеТипы, ";");
		ТаблицаТипов = НоваяСтрока.ТаблицаТипов;
		Для Каждого СериализованныйТип Из МассивСериализованныхТипов Цикл
			СтруктураТипа = мПлатформа.СтруктураТипаИзСтрокиВнутр(СериализованныйТип);
			СтруктураТипа.Вставить("СтрокаОписания", НоваяСтрока); // Циклическая ссылка СтрокаОписания
			мПлатформа.ДобавитьВТаблицуТипов(ТаблицаТипов, СтруктураТипа);
		КонецЦикла;
		НоваяСтрока.ТаблицаТипов = ТаблицаТипов;
	Иначе
		НоваяСтрока.ТаблицаТипов = ДопустимыеТипы;
	КонецЕсли; 

КонецПроцедуры

// Удаляет слово локального контекста.
//
// Параметры:
//  Слово        - Строка;
//  ТипСлова     - Строка.
//
Процедура УдалитьСловоЛокальногоКонтекста(Слово, ТипСлова) Экспорт

	КлючСтроки = Новый Структура;
	КлючСтроки.Вставить("нИмя", НРег(Слово));
	СтрокиСлова = ТаблицаЛокальногоКонтекста(ТипСлова).НайтиСтроки(КлючСтроки);
	Если СтрокиСлова.Количество() > 0 Тогда
		СтрокиСлова[0].Владелец().Удалить(СтрокиСлова[0]);
	КонецЕсли;

КонецПроцедуры

// Устанавливает доступность действий, изменяющих данные.
//
// Параметры:
//  НовыйТолькоПросмотр - Булево.
//
Процедура УстановитьТолькоПросмотр(НовыйТолькоПросмотр) Экспорт 

	ФормаКласса = ПолучитьФорму("ФормаМакет");
	КоманднаяПанельЛ = ФормаКласса.ЭлементыФормы["КоманднаяПанель" + Формат(ЯзыкПрограммы, "ЧН=")]; // КоманднаяПанель
	МассивКоллекцийКнопок = Новый Массив;
	МассивКоллекцийКнопок.Добавить(КоманднаяПанельЛ.Кнопки);
	МассивКоллекцийКнопок.Добавить(ФормаКласса.ЭлементыФормы.КоманднаяПанельОбщая.Кнопки);
	Для Каждого КнопкиМакета Из МассивКоллекцийКнопок Цикл
		Для Каждого КнопкаМакета Из КнопкиМакета Цикл
			Если КнопкаМакета.ТипКнопки <> ТипКнопкиКоманднойПанели.Действие Тогда 
				Продолжить;
			КонецЕсли;
			КонечноеИмя = ирКлиент.СформироватьИмяЭлементаУправленияЭкземпляраЛкс(ЭтотОбъект, КнопкаМакета.Имя);
			Кнопка = КоманднаяПанель.Кнопки.Найти(КонечноеИмя);
			Если Кнопка.ИзменяетДанные Тогда 
				Кнопка.Доступность = Не НовыйТолькоПросмотр;
			КонецЕсли;
		КонецЦикла;
	КонецЦикла;
	
КонецПроцедуры

Процедура ОформитьЯчейкуТипаЗначения(ОформлениеСтроки, ДанныеСтроки) Экспорт 
	
	Если Истина
		И ОформлениеСтроки.Ячейки.ТипЗначения.Видимость 
		И ЗначениеЗаполнено(ДанныеСтроки.ТипЗначения) 
		//И Найти(ДанныеСтроки.ТипЗначения, ",") = 0
	Тогда
		СтрокаИменТипов = ирОбщий.ПервыйФрагментЛкс(ДанныеСтроки.ТипЗначения, "[");
		мРегВыражение = ирКэш.ВычислительРегВыраженийЛкс();
		#Если Сервер И Не Сервер Тогда
			мРегВыражение = Обработки.ирОболочкаРегВыражение.Создать();
		#КонецЕсли
		мРегВыражение.Global = Истина;
		мРегВыражение.Pattern = "\(.*?\)";
		СтрокаИменТипов = мРегВыражение.Заменить(СтрокаИменТипов, "");
		Попытка
			ОписаниеТипов = Новый ОписаниеТипов(СтрокаИменТипов);
		Исключение
			ОписаниеТипов = Неопределено;
		КонецПопытки; 
		Если ОписаниеТипов <> Неопределено Тогда
			Типы = ОписаниеТипов.Типы();
			Если Типы.Количество() > 0 Тогда
				КартинкаТипа = ирКлиент.КартинкаТипаЛкс(Типы[0]);
				Если КартинкаТипа <> Неопределено Тогда
					ОформлениеСтроки.Ячейки.ТипЗначения.УстановитьКартинку(КартинкаТипа);
				КонецЕсли; 
			КонецЕсли; 
		КонецЕсли; 
	КонецЕсли;

КонецПроцедуры

// Выполняет шаблон текста.
//
// Параметры:
//  Нет.
//
Процедура ВыполнитьШаблонТекста()
	
	Если ПолеТекста.ТолькоПросмотр() Тогда
		Возврат;
	КонецЕсли; 
	#Если Сервер И Не Сервер Тогда
		мПлатформа = Обработки.ирПлатформа.Создать();
	#КонецЕсли
	ПрочитатьНачалоИКонецТекущейСтроки();
	//РазобратьКонтекстСтроки();
	НадежноУстановитьФокус = Ложь;
	ПоследняяПозицияКурсора = 0;
	ТаблицаШаблоновТекста = мПлатформа.ПолучитьТаблицуШаблоновТекста(ИмяКласса);
	КонечныйТекстЗамены = " ";
	Если Ложь
		Или ТаблицаШаблоновТекста = Неопределено 
		Или ТаблицаШаблоновТекста.Количество() = 0
	Тогда
		//
	Иначе
		мРегВыражение.Global = Ложь; 
		СтрокаРазделителейШаблоновТекста = ";.,:()[]";
		мРегВыражение.Pattern = "([^\s" + ирОбщий.ПодготовитьТекстДляРегВыраженияЛкс(СтрокаРазделителейШаблоновТекста) + "]*)$";
		Результат = мРегВыражение.НайтиВхождения(мТекущаяСтрокаНачало);
		Если Результат.Количество() > 0 Тогда
			НачалоМаркера = Результат[0].SubMatches(0);
			Если ЗначениеЗаполнено(НачалоМаркера) Тогда
				//СтрокаШаблона = ТаблицаШаблоновТекста.Найти(НРег(НачалоМаркера), "ШаблонБезКвадратныхСкобок");
				СтрокаШаблона = Неопределено;
				Для каждого ТекСтрокаШаблона Из ТаблицаШаблоновТекста Цикл
					Если ТекСтрокаШаблона.Шаблон = НРег(НачалоМаркера) Тогда
						СтрокаШаблона = ТекСтрокаШаблона;
						Прервать;
					КонецЕсли;
					МинимальнаяДлинаСовпадения = Найти(ТекСтрокаШаблона.Шаблон, "[");
					Если МинимальнаяДлинаСовпадения > 0 Тогда
						Если СтрДлина(НачалоМаркера) < МинимальнаяДлинаСовпадения - 1 Тогда
							Продолжить;
						КонецЕсли; 
						ШаблонБезСкобок = СтрЗаменить(ТекСтрокаШаблона.Шаблон, "[", "");
						ШаблонБезСкобок = СтрЗаменить(ШаблонБезСкобок, "]", "");
						Если Найти(ШаблонБезСкобок, НРег(НачалоМаркера)) = 1 Тогда
							СтрокаШаблона = ТекСтрокаШаблона;
							Прервать;
						КонецЕсли;
					КонецЕсли; 
				КонецЦикла;
				Если СтрокаШаблона = Неопределено Тогда
					НачалоМаркера = "";
				Иначе
					мРегВыражение.Global = Истина;
					мРегВыражение.MultiLine = Ложь;
					мРегВыражение.Pattern = "(<\?\s*(""[^""\^]*"")?(?:,\s*(" + мПлатформа.шИмя + "))?>)|(.|\r|\n)";
					Результат = мРегВыражение.НайтиВхождения(СтрокаШаблона.Замена);
					КонечныйТекстЗамены = "";
					КешПараметров = ирОбщий.НоваяТаблицаЗначенийЛкс("ИмяПараметра, ЗначениеПараметра");
					Для Каждого Match Из Результат Цикл
						УправляющаяКонструкция = Match.SubMatches(0);
						Если УправляющаяКонструкция = Неопределено Тогда
							КонечныйТекстЗамены = КонечныйТекстЗамены + Match.SubMatches(3);
						Иначе
							ИмяПараметраШаблона = Match.SubMatches(1);
							ТипШаблона = Match.SubMatches(2);
							Если ТипШаблона = "КонструкторОписанияТипов" Тогда
								КонечныйТекстЗамены = ТекстИзКонструктораОписанияТипов();
							ИначеЕсли ТипШаблона = "ТекстЗапроса" Тогда
								//ВызватьКонструкторЗапросов();
							ИначеЕсли ИмяПараметраШаблона <> Неопределено Тогда
								ИмяПараметраШаблона = Сред(ИмяПараметраШаблона, 2, СтрДлина(ИмяПараметраШаблона) - 2);
								ВведеннаяСтрока = "";
								Если ИмяПараметраШаблона <> "" Тогда
									СтрокаКэша = КешПараметров.Найти(ИмяПараметраШаблона, "ИмяПараметра");
									Если СтрокаКэша <> Неопределено Тогда
										ВведеннаяСтрока = СтрокаКэша.ЗначениеПараметра;
									Иначе
										СтрокаКэша = КешПараметров.Добавить();
										СтрокаКэша.ИмяПараметра = ИмяПараметраШаблона;
										НадежноУстановитьФокус = Истина;
										ВвестиЗначение(ВведеннаяСтрока, ИмяПараметраШаблона, Тип("Строка"));
										СтрокаКэша.ЗначениеПараметра = ВведеннаяСтрока;
									КонецЕсли;
								КонецЕсли; 
								КонечныйТекстЗамены = КонечныйТекстЗамены + ВведеннаяСтрока;
							Иначе
								ПоследняяПозицияКурсора = СтрДлина(КонечныйТекстЗамены) + 1;
							КонецЕсли;
						КонецЕсли;
					КонецЦикла;
					ЗаменаТабуляции = ирОбщий.СтрокаПовторомЛкс(" ", мШиринаТабуляции);
				КонецЕсли; 
			КонецЕсли; 
		КонецЕсли; 
	КонецЕсли;
	Если КонечныйТекстЗамены <> Неопределено Тогда
		КонечныйТекстЗаменыТД = Новый ТекстовыйДокумент;
		КонечныйТекстЗаменыТД.УстановитьТекст(КонечныйТекстЗамены);
		лКонечнаяСтрока = 0;
		лКонечнаяКолонка = 0;
		Если ПоследняяПозицияКурсора > 0 Тогда
			мПолеТекстаВременное.УстановитьТекст(КонечныйТекстЗамены);
			Если ПоследняяПозицияКурсора <= СтрДлина(КонечныйТекстЗамены) Тогда
				мПолеТекстаВременное.УстановитьГраницыВыделения(ПоследняяПозицияКурсора, ПоследняяПозицияКурсора);
				мПолеТекстаВременное.ПолучитьГраницыВыделения(лКонечнаяСтрока, лКонечнаяКолонка, лКонечнаяСтрока, лКонечнаяКолонка);
			Иначе
				лКонечнаяСтрока = КонечныйТекстЗаменыТД.КоличествоСтрок();
				лКонечнаяКолонка = СтрДлина(КонечныйТекстЗаменыТД.ПолучитьСтроку(КонечныйТекстЗаменыТД.КоличествоСтрок())) + 1;
			КонецЕсли;
		КонецЕсли;
		ЧислоСтрокЗамены = КонечныйТекстЗаменыТД.КоличествоСтрок();
		СтрокаДобавка = КонечныйТекстЗаменыТД.ПолучитьСтроку(1);
		ДлинаНачалаСтроки = мКонечнаяКолонка - СтрДлина(НачалоМаркера) - 1;
		НачалоСтроки = Лев(мТекущаяСтрокаНачало, ДлинаНачалаСтроки);
		мТекущаяСтрокаНачало = НачалоСтроки + СтрокаДобавка;
		ТекущаяСтрока = мТекущаяСтрокаНачало;
		Если ЧислоСтрокЗамены = 1 Тогда
			ТекущаяСтрока = ТекущаяСтрока + мТекущаяСтрокаКонец;
		КонецЕсли;
		ПолеТекста.ЗаменитьСтроку(мКонечнаяСтрока, "" + ТекущаяСтрока);
		ДлинаРазвернутогоНачалаСтроки = СтрДлина(СтрЗаменить(НачалоСтроки, Символы.Таб, ЗаменаТабуляции));
		ЧислоТабуляций = ДлинаРазвернутогоНачалаСтроки / мШиринаТабуляции;
		ЧислоПробелов = ДлинаРазвернутогоНачалаСтроки % мШиринаТабуляции;
		НачалоНовойСтроки = ирОбщий.СтрокаПовторомЛкс(Символы.Таб, ЧислоТабуляций);
		НачалоНовойСтроки = НачалоНовойСтроки + ирОбщий.СтрокаПовторомЛкс(" ", ЧислоПробелов);
		Для Счетчик = 2 По ЧислоСтрокЗамены - 1 Цикл
			ТекущаяСтрокаВставки = КонечныйТекстЗаменыТД.ПолучитьСтроку(Счетчик);
			ПолеТекста.ВставитьСтроку(мКонечнаяСтрока + Счетчик - 1, НачалоНовойСтроки + ТекущаяСтрокаВставки);
		КонецЦикла;
		Если ЧислоСтрокЗамены > 1 Тогда
			ТекущаяСтрокаВставки = КонечныйТекстЗаменыТД.ПолучитьСтроку(ЧислоСтрокЗамены);
			ПолеТекста.ВставитьСтроку(мКонечнаяСтрока + ЧислоСтрокЗамены - 1, НачалоНовойСтроки + ТекущаяСтрокаВставки + мТекущаяСтрокаКонец);
		КонецЕсли;
		Если лКонечнаяСтрока > 0 Тогда
			Если лКонечнаяСтрока = 1 Тогда
				лКонечнаяКолонка = лКонечнаяКолонка + СтрДлина(НачалоСтроки);
			Иначе
				лКонечнаяКолонка = лКонечнаяКолонка + СтрДлина(НачалоНовойСтроки);
			КонецЕсли;
			лКонечнаяСтрока = лКонечнаяСтрока + мКонечнаяСтрока - 1;
			мКонечнаяКолонка = лКонечнаяКолонка;
			мКонечнаяСтрока = лКонечнаяСтрока;
		Иначе
			Если ЧислоСтрокЗамены > 0 Тогда
				мКонечнаяСтрока = мКонечнаяСтрока + ЧислоСтрокЗамены - 1;
			КонецЕсли; 
			Если ЧислоСтрокЗамены > 1 Тогда
				мКонечнаяКолонка = СтрДлина(НачалоСтроки + ТекущаяСтрокаВставки) + 1;
			Иначе
				мКонечнаяКолонка = мКонечнаяКолонка + СтрДлина(КонечныйТекстЗамены) - СтрДлина(НачалоМаркера);
			КонецЕсли;
		КонецЕсли;
		мНачальнаяСтрока = мКонечнаяСтрока;
		мНачальнаяКолонка = мКонечнаяКолонка;
	КонецЕсли;
	УстановитьФокус();

КонецПроцедуры

Функция ТекстИзКонструктораОписанияТипов()
	
	ОписаниеТипов = ирКлиент.РедактироватьОписаниеРедактируемыхТиповЛкс();
	Если ОписаниеТипов <> Неопределено Тогда
		Результат = ирОбщий.ВыражениеВстроенногоЯзыкаСозданиеОписанияТиповЛкс(ОписаниеТипов);
	КонецЕсли;
	Возврат Результат;

КонецФункции

Процедура КонструкторОписанияТипов()
	
	НовыйТекст = ТекстИзКонструктораОписанияТипов();
	Если ЗначениеЗаполнено(НовыйТекст) Тогда
		ПолеТекста.ВыделенныйТекст(НовыйТекст);
	КонецЕсли;
	
КонецПроцедуры

Процедура ОкружитьВыделенныеСтроки(Знач НачалоОкружения, Знач КонецОкружения, Знач СмещатьВправо = Истина) Экспорт 
	
	#Если Сервер И Не Сервер Тогда
		ПолеТекста = Обработки.ирОболочкаПолеТекста.Создать();
	#КонецЕсли
	НомерНачальнойСтроки = ПолучитьНомерТекущейСтроки(Истина);
	ВыделенныйТекст = ПолеТекста.ВыделенныйТекст();
	Смещение = "";
	Если СмещатьВправо Тогда
		Смещение = Символы.Таб;
	КонецЕсли;
	СмещениеПервойСтроки = Лев(ВыделенныйТекст, СтрДлина(ВыделенныйТекст) - СтрДлина(СокрЛ(ВыделенныйТекст)));
	ПолеТекста.ВставитьТекст(
	"" + СмещениеПервойСтроки + НачалоОкружения + "
	|" + Смещение + ирОбщий.ДобавитьМногострочнуюСтрокуВТекстЛкс("", ВыделенныйТекст, Смещение) + "
	|" + СмещениеПервойСтроки + КонецОкружения);
	НомерНачальнойКолонки = СтрДлина(СмещениеПервойСтроки) + 1;
	ПолеТекста.УстановитьГраницыВыделения(НомерНачальнойСтроки, НомерНачальнойКолонки, НомерНачальнойСтроки, НомерНачальнойКолонки,, ФормаВладелец);
	УстановитьПризнакМодифицированностиФормы();

КонецПроцедуры

Функция ПредставлениеЗначенияВЯзыкеЗапросов(Знач Значение, Знач ВыводитьСообщение = Ложь, Знач ПараметрыДиалектаSQL = Неопределено, Знач Английский1С = Неопределено) Экспорт 
	
	Если Английский1С = Неопределено Тогда
		Английский1С = мАнглийский1С;
	КонецЕсли;
	Результат = "";
	ТипЗначенияПараметра = ТипЗнч(Значение);
	ОбъектМД = Метаданные.НайтиПоТипу(ТипЗначенияПараметра);
	Если ОбъектМД <> Неопределено Тогда
		КорневойТип = ирОбщий.ПервыйФрагментЛкс(ОбъектМД.ПолноеИмя());
		Если ирОбщий.ЛиКорневойТипСсылкиЛкс(КорневойТип) Тогда
			Если ирОбщий.ЛиТипСсылкиТочкиМаршрутаЛкс(ТипЗначенияПараметра) Тогда 
				Результат = "ТочкаМаршрута." + Значение.Имя;
			ИначеЕсли Значение.Пустая() Тогда
				Результат = "ПустаяСсылка";
			ИначеЕсли ирОбщий.ЛиКорневойТипПеречисленияЛкс(КорневойТип) Тогда
				Результат = XMLСтрока(Значение);
			ИначеЕсли ирОбщий.ЛиКорневойТипОбъектаСПредопределеннымЛкс(КорневойТип) Тогда
				Если Значение.Предопределенный Тогда
					Результат = ирОбщий.ПолучитьМенеджерЛкс(ОбъектМД).ПолучитьИмяПредопределенного(Значение);
				КонецЕсли;
			КонецЕсли; 
		КонецЕсли; 
	ИначеЕсли ТипЗначенияПараметра = Тип("ВидДвиженияБухгалтерии") Тогда 
		Результат = "ВидДвиженияБухгалтерии." + Значение;
	ИначеЕсли ТипЗначенияПараметра = Тип("ВидДвиженияНакопления") Тогда 
		Результат = "ВидДвиженияНакопления." + Значение;
	КонецЕсли; 
	Если ЗначениеЗаполнено(Результат) Тогда
		Если ОбъектМД <> Неопределено Тогда
			Результат = ОбъектМД.ПолноеИмя() + "." + Результат;
		КонецЕсли; 
		Результат = "ЗНАЧЕНИЕ(" + Результат + ")";
	ИначеЕсли ТипЗначенияПараметра = Тип("Неопределено") Тогда
		Результат = СловоЯзыкаЗапросов("UNDEFINED", ПараметрыДиалектаSQL, Английский1С);
	ИначеЕсли ТипЗначенияПараметра = Тип("Null") Тогда
		Результат = "NULL";
	Иначе 
		Если ПараметрыДиалектаSQL = Неопределено Тогда
			ПараметрыДиалектаSQL = мПараметрыДиалектаSQL;
		КонецЕсли;
		Если ТипЗначенияПараметра = Тип("СтандартнаяДатаНачала") Тогда
			Значение = Значение.Дата;
			ТипЗначенияПараметра = ТипЗнч(Значение);
		КонецЕсли; 
		Если ТипЗначенияПараметра = Тип("Дата") Тогда
			Если ПараметрыДиалектаSQL.Это1С Тогда
				Результат = СловоЯзыкаЗапросов("DATETIME", ПараметрыДиалектаSQL, Английский1С) + "(" + XMLСтрока(Год(Значение)) + ", " + XMLСтрока(Месяц(Значение)) + ", " + XMLСтрока(День(Значение));
				Если НачалоДня(Значение) <> Значение Тогда
					Результат = Результат + ",  " + XMLСтрока(Час(Значение)) + ", " + XMLСтрока(Минута(Значение)) + ", " + XMLСтрока(Секунда(Значение));
				КонецЕсли;
				Результат = Результат + ")";
			ИначеЕсли ирОбщий.СтрокиРавныЛкс(ПараметрыДиалектаSQL.Диалект, "WQL") Тогда
				Значение = ирОбщий.ПолучитьЛитералДатыДляWQLЛкс(Значение);
			Иначе// Если ирОбщий.СтрокиРавныЛкс(КодЯзыка, "WQL") Тогда
				Результат = "'" + Формат(Значение, "ДФ='yyyyMMdd HH:mm:ss'; ДП=") + "'";
			КонецЕсли; 
		ИначеЕсли ТипЗначенияПараметра = Тип("Число") Тогда
			Результат = XMLСтрока(Значение);
		ИначеЕсли ТипЗначенияПараметра = Тип("Булево") Тогда
			Если Значение Тогда
				Результат = СловоЯзыкаЗапросов("TRUE", ПараметрыДиалектаSQL, Английский1С);
			Иначе
				Результат = СловоЯзыкаЗапросов("FALSE", ПараметрыДиалектаSQL, Английский1С);
			КонецЕсли; 
		ИначеЕсли ТипЗначенияПараметра = Тип("Строка") Тогда
			Если ПараметрыДиалектаSQL.Это1С Тогда
				Результат = """" + СтрЗаменить(Значение, """", """""") + """";
			Иначе
				Результат = "'" + Значение + "'";
			КонецЕсли; 
		КонецЕсли; 
	КонецЕсли;
	Если Результат = "" Тогда
		Если ВыводитьСообщение Тогда
			ирОбщий.СообщитьЛкс(ирОбщий.СтрШаблонЛкс("Литеральное представление значения ""%1"" в языке запросов не предусмотрено", ирОбщий.РасширенноеПредставлениеЗначенияЛкс(Значение)));
		КонецЕсли;
	КонецЕсли;
	Возврат Результат;

КонецФункции

// Внешний вызов
Функция ВычисляемыйКонтекстОтладчика() Экспорт 
	Возврат ирКлиент.ВычисляемыйКонтекстОтладчикаЛкс();
КонецФункции

Функция СловоЯзыкаЗапросов(Ключ, ПараметрыДиалектаSQL = Неопределено, Английский1С = Неопределено) Экспорт

	Если ПараметрыДиалектаSQL = Неопределено Тогда
		ПараметрыДиалектаSQL = мПараметрыДиалектаSQL;
	КонецЕсли;
	Если Английский1С = Неопределено Тогда
		Английский1С = мАнглийский1С;
	КонецЕсли;
	Результат = Неопределено;
	Если ирОбщий.СтрокиРавныЛкс("AS", Ключ) Тогда
		Если Не ПараметрыДиалектаSQL.КАК Тогда
			Результат = "";
		КонецЕсли;
	КонецЕсли; 
	Если Результат = Неопределено Тогда
		СтрокаТерминала = мТерминалыЯзыкаЗапросов.Найти(Ключ, "Ключ");
		Если ПараметрыДиалектаSQL <> Неопределено И ПараметрыДиалектаSQL.Это1С Тогда 
			Если СтрокаТерминала = Неопределено Тогда
				ВызватьИсключение "Не найден терминал """ + Ключ + """ языка запросов 1C";
			КонецЕсли; 
			Если Не Английский1С Тогда
				Результат = СтрокаТерминала.Русский;
			Иначе
				Результат = СтрокаТерминала.Английский;
			КонецЕсли; 
		Иначе
			Результат = Ключ;
		КонецЕсли; 
	КонецЕсли; 
	Возврат Результат;
	
КонецФункции

// Функция - Найти выбранные таблицы в тексте запроса
//
// Параметры:
//  СтрокаЗапросаПакета		 - см. Обработка.ирКонсольЗапросов.Форма.Форма.ДеревоЗапроса.Строки[0] - 
//  НачальнаяПозицияЗапроса	 - 	 - 
//  ПолеТекстаЗапроса		 - 	 - 
// 
// Возвращаемое значение:
//   - 
//
Функция НайтиВыбранныеТаблицыВТекстеЗапроса(Знач СтрокаЗапросаПакета, Знач НачальнаяПозицияЗапроса, Знач ПолеТекстаЗапроса) Экспорт 
	СтрокаЗапросаПакета.СложныйАнализВыполнен = Истина;   
	//Шаблон = шИЗ;
	Шаблон = "((?:ИЗ|FROM)" + шРазделитель + "+" + шОписаниеТаблицы + "[\s\S]*?)(?:$|\sОБЪЕДИНИТЬ(?:\s+ВСЕ)?\s+|\sUNION(?:\s+ALL)?\s+|\sУПОРЯДОЧИТЬ\s+[^\)]*$|\ORDER\s+[^\)]*$)";
	ВхожденияИЗ = ирОбщий.НайтиРегВыражениеЛкс(СтрокаЗапросаПакета.Текст, Шаблон);
	НачальнаяПозицияЧасти = НачальнаяПозицияЗапроса;
	//! ВхожденияИЗ.Колонки.Добавить("Подгруппа0");
	Для Каждого ВхождениеИЗ Из ВхожденияИЗ Цикл
		Если ВхожденияИЗ.Количество() > 1 Тогда 
			СтрокаЧастиОбъединения = СтрокаЗапросаПакета.Строки.Вставить(0);
			Если Истина
				И СтрокаЗапросаПакета.ТипУзла = "<CreateRoot>" 
				И СтрокаЗапросаПакета.Строки.Количество() = 1 
			Тогда
				СтрокаЧастиОбъединения.ТипУзла = "<CreateQuery>";
			Иначе
				СтрокаЧастиОбъединения.ТипУзла = "<SelectQuery>";
			КонецЕсли;
			СтрокаЧастиОбъединения.СложныйАнализВыполнен = Истина;
			СтрокаЧастиОбъединения.Порядок = -СтрокаЗапросаПакета.Строки.Количество();
			СтрокаЧастиОбъединения.Имя = "Выборка";
			КонечнаяПозицияЧасти = НачальнаяПозицияЗапроса + ВхождениеИЗ.ПозицияВхождения + СтрДлина(ВхождениеИЗ.Подгруппа0);        
			ПолеТекстаЗапроса.УстановитьГраницыВыделения(НачальнаяПозицияЧасти, КонечнаяПозицияЧасти);
			ТекстИсточника = ПолеТекстаЗапроса.ВыделенныйТекст;
			//ТекстИсточника = Сред(СлужебноеПолеТекста.Получитьтекст(), НачальнаяПозицияЧасти, КонечнаяПозицияЧасти - НачальнаяПозицияЧасти);
			НачальнаяПозицияЧасти = НачальнаяПозицияЗапроса + ВхождениеИЗ.ПозицияВхождения + СтрДлина(ВхождениеИЗ.ТекстВхождения);
			ЗаполнитьСтрокуУпрощеннойСтруктурыЗапроса(СтрокаЧастиОбъединения, ПолеТекстаЗапроса);
		Иначе
			СтрокаЧастиОбъединения = СтрокаЗапросаПакета;
		КонецЕсли;
		Найденные = ирОбщий.НайтиРегВыражениеЛкс(ВхождениеИЗ.ТекстВхождения, шОписаниеТаблицыСЗахватом);
		//! Найденные.Колонки.Добавить("Подгруппа0");
		//! Найденные.Колонки.Добавить("Подгруппа4");
		Для Каждого Найденное Из Найденные Цикл
			НачальнаяПозиция = НачальнаяПозицияЗапроса + ВхождениеИЗ.ПозицияВхождения + Найденное.ПозицияВхождения;
			КонечнаяПозиция = НачальнаяПозиция + СтрДлина(Найденное.Подгруппа0);
			Если Лев(Найденное.Подгруппа0, 1) = "(" Тогда
				НачальнаяПозиция = НачальнаяПозиция + 1;
				КонечнаяПозиция = КонечнаяПозиция - 1;
				ТипУзла = "<FromUnion>";
			Иначе
				ТипУзла = "<TableWithName>";
			КонецЕсли; 
			ПолеТекстаЗапроса.УстановитьГраницыВыделения(НачальнаяПозиция, КонечнаяПозиция);
			ТекстИсточника = ПолеТекстаЗапроса.ВыделенныйТекст;
			//ТекстИсточника = Сред(СлужебноеПолеТекста.Получитьтекст(), НачальнаяПозиция, КонечнаяПозиция - НачальнаяПозиция);
			КорневойТипТаблицы = ирОбщий.ПервыйФрагментЛкс(СокрЛ(ТекстИсточника));
			Если Ложь
				Или Найденное.Подгруппа4 = "ЧИСЛО" // Ложное срабатываение ВЫРАЗИТЬ ВЫБОР ... КОНЕЦ КАК ЧИСЛО
				Или ТекстИсточника = "КОНЕЦ" // Ложное срабатываение ВЫРАЗИТЬ ВЫБОР ... КОНЕЦ КАК ЧИСЛО
				Или (Истина
					// {ГДЕ (АналитикаУчета.Договор) КАК Договор}
					// ОБЪЕДИНИТЬ ВЫБРАТЬ АналитикаУчета.Партнер КАК Партнер
					И мПараметрыДиалектаSQL.Это1С
					И Найти(ТекстИсточника, ".") > 0
					И Не ирОбщий.ЛиКорневойТипТаблицыБДЛкс(КорневойТипТаблицы) 
					И Не ирОбщий.ЛиКорневойТипПеречисленияЛкс(КорневойТипТаблицы) 
					И Не ирОбщий.СтрНачинаетсяСЛкс(СокрЛ(ТекстИсточника), "ВЫБРАТЬ") 
					И Не ирОбщий.СтрНачинаетсяСЛкс(СокрЛ(ТекстИсточника), "SELECT") 
					)   
			Тогда
				Продолжить;
			КонецЕсли;
			СтрокаИсточника = СтрокаЧастиОбъединения.Строки.Вставить(0);
			СтрокаИсточника.Порядок = -СтрокаЧастиОбъединения.Строки.Количество();
			СтрокаИсточника.Имя = Найденное.Подгруппа4;
			СтрокаИсточника.ТипУзла = ТипУзла;
			ЗаполнитьСтрокуУпрощеннойСтруктурыЗапроса(СтрокаИсточника, ПолеТекстаЗапроса);
		КонецЦикла;
	КонецЦикла;
КонецФункции
 
Процедура ЗаполнитьСтрокуУпрощеннойСтруктурыЗапроса(Знач СтрокаДерева, Знач ПолеТекстаЗапроса)
	
	лНачальнаяСтрока = 0;
	лНачальнаяКолонка = 0;
	лКонечнаяСтрока = 0;
	лКонечнаяКолонка = 0;
	ПолеТекстаЗапроса.ПолучитьГраницыВыделения(лНачальнаяСтрока, лНачальнаяКолонка, лКонечнаяСтрока, лКонечнаяКолонка);
	СтрокаДерева.Текст = ПолеТекстаЗапроса.ВыделенныйТекст;
	ГраницыДвумерные = Новый Структура();
	ГраницыДвумерные.Вставить("НачальнаяСтрока", лНачальнаяСтрока);
	ГраницыДвумерные.Вставить("НачальнаяКолонка", лНачальнаяКолонка);
	ГраницыДвумерные.Вставить("КонечнаяСтрока", лКонечнаяСтрока);
	ГраницыДвумерные.Вставить("КонечнаяКолонка", лКонечнаяКолонка);
	СтрокаДерева.СтрокаДанных = ГраницыДвумерные;

КонецПроцедуры

// Скопировано от РедакторHTML_ПриАктивацииСтрокиАвтодополнения
Функция ОписаниеТекущегоСловаАвтодополнения(Знач Слово, Знач ЛиМетод, Знач КлючНабораСлов = "", Знач ЛиОтдельноеОписаниеАктивно = Истина) Экспорт 
	
	ТолькоПолезноеОписание = Истина;
	Если ЗначениеЗаполнено(КлючНабораСлов) Тогда
		ТаблицаПоиска = мНаборыСлов[КлючНабораСлов];
		Если ТаблицаПоиска = Неопределено Тогда
			Возврат Неопределено;
		КонецЕсли;
	Иначе
		ТаблицаПоиска = ТаблицаСлов;
	КонецЕсли;
	НайденныеСтроки = ТаблицаПоиска.НайтиСтроки(Новый Структура("Слово", Слово));
	Для Каждого НайденнаяСтрока Из НайденныеСтроки Цикл
		Если Ложь
			Или НайденнаяСтрока.ТипСлова = "Метод" И ЛиМетод 
			Или НайденнаяСтрока.ТипСлова <> "Метод" И Не ЛиМетод 
		Тогда
			СтрокаТаблицыСлов = НайденнаяСтрока;
			Прервать;
		КонецЕсли;
	КонецЦикла;
	ЕстьПараметры = Ложь;
	ЧислоРасширений = 0;
	Если СтрокаТаблицыСлов <> Неопределено Тогда
		ТаблицаТипов = УточнитьТипЗначенияВСтрокеТаблицыСлов(мСтруктураТипаКонтекста, СтрокаТаблицыСлов, ЛиОтдельноеОписаниеАктивно);
		СтруктураОписания = Новый Массив;
		Если мСтруктураТипаКонтекста.Конструктор Тогда
			ДетальноеОписаниеДляСписка = "";
		Иначе
			ДетальноеОписаниеДляСписка = СтрокаТаблицыСлов.ТипЗначения;
		КонецЕсли; 
		Если ЛиОтдельноеОписаниеАктивно И ТаблицаТипов <> Неопределено Тогда 
			Если Ложь
				Или мСтруктураТипаКонтекста.Конструктор
				Или СтрокаТаблицыСлов.ТипСлова = "Метод" 
			Тогда
				Если мСтруктураТипаКонтекста.Конструктор Тогда
					СтруктураТипа = мПлатформа.НоваяСтруктураТипа();
					СтруктураТипа.ИмяОбщегоТипа = "Глобальный";
					ТаблицаТипов = мПлатформа.СловаКонтекстаПредопределенные(СтруктураТипа, СтрокаТаблицыСлов.Слово, "Конструктор",, ЯзыкПрограммы, Конфигурация)[0].ТаблицаТипов;
				КонецЕсли; 
				Если ТаблицаТипов.Количество() > 0 Тогда
					//ПараметрыМетода = мПлатформа.ПараметрыМетодаПлатформы(ТаблицаТипов[0]);
					СтруктураПодсказкиМетода = СтруктураПодсказкиМетода(ТаблицаТипов[0], ТолькоПолезноеОписание, Истина, ЕстьПараметры);
					Если СтруктураПодсказкиМетода.Количество() > 0 Тогда
						СтруктураОписания.Вставить(0, "> Параметры: " + СтруктураПодсказкиМетода[0].label);
						Если СтруктураПодсказкиМетода.Количество() > 1 Тогда
							СтруктураОписания.Вставить(0, "> Варианты: " + СтруктураПодсказкиМетода.Количество());
						КонецЕсли; 
						ОписаниеСлова = СтруктураПодсказкиМетода[0].documentation;
						Если ЗначениеЗаполнено(ОписаниеСлова) Тогда
							СтруктураОписания.Добавить("> Описание: " + ОписаниеСлова);
						КонецЕсли; 
					КонецЕсли; 
				КонецЕсли;
			КонецЕсли; 
			// TODO Сделать отображение и для рассчитанных таблиц типов (ТаблицаТипов = Неопределено)
			//Если Истина
			//	И СтрокаТаблицыСлов.ТипСлова = "Метод"
			//	И ТаблицаТипов.Количество() > 0
			//Тогда 
			//	СтрокаМетода = ТаблицаТипов[0].СтрокаОписания;
			//	Если Истина
			//		И СтрокаМетода <> Неопределено
			//		И СтрокаМетода.Владелец().Колонки.Найти("ЛиЭкспорт") <> Неопределено
			//	Тогда
			//		Для Каждого КлючИЗначение Из ирКэш.РасширенияКонфигурацииЛкс(Ложь) Цикл
			//			Расширение = КлючИЗначение.Ключ;
			//			ИмяРасширенияМодуля = Расширение.Имя + " " + СтрокаМетода.ИмяМодуля;
			//			ПолеТекстаМодуля = мПлатформа.ПолеТекстаМодуля(ИмяРасширенияМодуля);
			//			РасширениеМетода = ПолеТекстаМодуля.мМодульМетаданных.Методы.Найти(СтрокаМетода.Имя, "РасширяемыйМетод");
			//			Если РасширениеМетода <> Неопределено Тогда
			//				ЧислоРасширений = ЧислоРасширений + 1;
			//			КонецЕсли;
			//		КонецЦикла;
			//	КонецЕсли;
			//КонецЕсли;
		КонецЕсли; 
		СтруктураОписания.Добавить("> Определение: " + СтрокаТаблицыСлов.Определение);
		ДетальноеОписаниеОтдельное = ирОбщий.СтрСоединитьЛкс(СтруктураОписания, Символы.ПС);
	КонецЕсли;
	Результат = Новый Структура;
	Результат.Вставить("Описание", "" + ДетальноеОписаниеОтдельное);
	Результат.Вставить("Тип", ДетальноеОписаниеДляСписка);
	Результат.Вставить("ЕстьПараметры", ЕстьПараметры);
	Результат.Вставить("ЧислоРасширений", ЧислоРасширений);
	Возврат Результат;

КонецФункции
 
// Функция - Установить текст
//
// Параметры:
//  Текст						 - Строка, Неопределено - "Неопределено" не меняет текст поля
//  Активировать				 - 	 - 
//  НачальныйТекстДляСравнения	 - 	 - 
//  СохранитьГраницыВыделения	 - 	 - 
//  ПолноеИмя	 - Строка - например Обработка.ирКонсольЗапросов.МодульОбъекта
// 
Процедура УстановитьТекст(Знач Текст = Неопределено, Знач Активировать = Ложь, Знач НачальныйТекстДляСравнения = Неопределено, Знач СохранитьГраницыВыделения = Ложь, Знач ИмяМодуляСжатое = Неопределено,
	Знач ИмяМодуля = Неопределено, Знач НовоеНачалоВыделения = 0, Знач НовоеКонецВыделения = 0) Экспорт
	
	#Если Сервер И Не Сервер Тогда
		мПлатформа = Обработки.ирПлатформа.Создать();
	#КонецЕсли
	//Если Текст = Неопределено Тогда 
	//	// Пробовал так передавать из адаптера для ускорения. Эффекта не дало.
	//	Текст = мСтарыйОригинальныйТекст; 
	//	СлужебноеПолеТекстаДолгое.УстановитьТекст(Текст);
	//КонецЕсли;
	Если Текст <> Неопределено Тогда 
		ПолеТекста.УстановитьТекст(Текст, Активировать, НачальныйТекстДляСравнения, СохранитьГраницыВыделения);
	КонецЕсли;
	Если ЗначениеЗаполнено(НовоеКонецВыделения) Тогда
		УстановитьГраницыВыделения(НовоеНачалоВыделения, НовоеКонецВыделения,,, Ложь);
	Иначе 
		НовоеКонецВыделения = мПозицияВТексте;
	КонецЕсли;
	ОчиститьТаблицуСловЛокальногоКонтекста();
	мФлагиКомпиляции = мПлатформа.НовыеФлагиКомпиляции();
	мКорневаяТаблицаТипов = Неопределено;
	мПлатформа.ПроверитьОбновитьКэш();
	Если Истина
		И Не ЗначениеЗаполнено(ИмяМодуляСжатое) 
		И (Ложь
			Или ПустаяСтрока(ИмяМодуля)
			Или ИмяМодуля = мПлатформа.ИмяДинамическогоМодуля())
	Тогда
		ОчиститьИсториюПереходов();
		Если ИмяМодуля <> мПлатформа.ИмяДинамическогоМодуля() Тогда 
			мМодульМетаданных = Неопределено; // Чтобы пересоздался мМодульМетаданных, иначе передача текста без указания имени модуля может перезаписать чужой текст модуля в кэше
		КонецЕсли;
		ОбновитьМодульМетаданных(Текст); 
		Возврат;
	КонецЕсли;
	#Если Сервер И Не Сервер Тогда
		мПлатформа = Обработки.ирПлатформа.Создать();
	#КонецЕсли
	Если ИмяМодуля <> Неопределено И ИмяМодуляСжатое = Неопределено Тогда
		ИмяМодуляСжатое = ИмяМодуля;
		Если мПлатформа.ЛиИмяМодуляФормы(ИмяМодуляСжатое) Тогда
			ИмяМодуляСжатое = СтрЗаменить(ИмяМодуляСжатое, ".Форма.Модуль", "");
			ИмяМодуляСжатое = СтрЗаменить(ИмяМодуляСжатое, ".Форма.", ".");
		КонецЕсли;
		Если ирОбщий.СтрНачинаетсяСЛкс(ИмяМодуляСжатое, "Конфигурация.") Тогда
			ИмяМодуляСжатое = СтрЗаменить(ИмяМодуляСжатое, "Конфигурация.", "");
		КонецЕсли;
	КонецЕсли;
	Фрагменты = ирОбщий.СтрРазделитьЛкс(ИмяМодуляСжатое, "::");
	ИмяМодуля = ИмяМодуляСжатое;    
	Если Фрагменты.Количество() > 1 Тогда
		// Внешняя обработка/отчет
		ИмяФайла = Фрагменты[1];
		ТипМодуля = Фрагменты[2];
		//КлючПоиска = Новый Структура;
		//КлючПоиска.Вставить("БазовыйТип", ИмяОбщегоТипа + "Объект");
		//КлючПоиска.Вставить("ЯзыкПрограммы", 0);
		//ИмяОбщегоТипа = мПлатформа.ТаблицаОбщихТипов.НайтиСтроки(КлючПоиска)[0].Слово;
		ОшибкаКомпиляции = "";
		Попытка
			МенеджерОбъекта = ирОбщий.МенеджерВнешнегоОбъектаЛкс(ИмяФайла);
			ОбъектМД = МенеджерОбъекта.Метаданные();
		Исключение
			ОшибкаКомпиляции = ОписаниеОшибки(); // Для отладки
			ОбъектМД = Новый Структура("Имя", "Нескомпилированный");
		КонецПопытки;
		ИмяМодуля = Фрагменты[0] + "::" + ИмяФайла + "::" + ОбъектМД.Имя;
		Если ирОбщий.СтрокиРавныЛкс(ТипМодуля, "МодульОбъекта") Тогда
			Если ЗначениеЗаполнено(ОшибкаКомпиляции) Тогда
				СтруктураТипа = мПлатформа.НоваяСтруктураТипа("ВнешняяОбработкаОбъект.<Имя внешней обработки>");
				СтруктураТипа.Метаданные = ОбъектМД;
			Иначе
				СтруктураТипа = мПлатформа.СтруктураТипаИзЗначения(МенеджерОбъекта);
			КонецЕсли;
			ТипМодуля = "МодульОбъекта";
			ИмяМодуля = ИмяМодуля + "." + ТипМодуля;
		Иначе                      
			ИмяОбщегоТипа = "Форма";
			ИмяМодуля = ИмяМодуля + "." + "Форма" + "." + ТипМодуля;
			Форма = мПлатформа.ПассивнаяФормаПоИмениКэш(ИмяМодуля);
			ТипМодуля = "Форма.Модуль";
			ИмяМодуля = ИмяМодуля + "." + ТипМодуля;
			Если ТипЗнч(Форма) = Тип("Структура") Тогда
				СтруктураТипа = мПлатформа.СтруктураТипаИзКонкретногоТипа(Форма.Тип);
				СтруктураТипа.Метаданные = Форма;
			ИначеЕсли Форма <> Неопределено Тогда
				СтруктураТипа = мПлатформа.СтруктураТипаИзЗначения(Форма);
			Иначе
				СтруктураТипа = мПлатформа.НоваяСтруктураТипа("Форма");
				СтруктураТипа.Метаданные = ОбъектМД; 
				//ТипМодуля = ИмяМодуля;
			КонецЕсли;
		КонецЕсли;
		СтруктураТипа.ДержательМетаданных = МенеджерОбъекта;
	Иначе 
		ИмяРасширения = Неопределено;
		ФрагментыПробела = ирОбщий.СтрРазделитьЛкс(ИмяМодуляСжатое, " ");
		Если ФрагментыПробела.Количество() > 1 Тогда 
			ИмяРасширения = ФрагментыПробела[0];
			ИмяМодуля = ФрагментыПробела[1];
		КонецЕсли;
		Фрагменты = ирОбщий.СтрРазделитьЛкс(ИмяМодуля);
		ИмяОбщегоТипа = Фрагменты[0];
		ТипМодуля = "";
		Если Фрагменты.Количество() = 1 Тогда
			ОбъектМД = Метаданные;
			ИмяОбщегоТипа = "Глобальный";
			ТипМодуля = ИмяМодуля;
			ИмяМодуля = "Конфигурация";
		ИначеЕсли Ложь
			Или ИмяОбщегоТипа = "WebСервис"
			Или ИмяОбщегоТипа = "HttpСервис"
			Или ИмяОбщегоТипа = "ОбщийМодуль"
			Или ИмяОбщегоТипа = "ОбщаяКоманда"
		Тогда
			ОбъектМД = Метаданные[ирОбщий.МножественноеИмяМДЛкс(ИмяОбщегоТипа)].Найти(Фрагменты[1]);
		ИначеЕсли Ложь
			Или ИмяОбщегоТипа = "Команда"
		Тогда 
			// Конфигуратор оставил нам только полный перебор, т.к. не показывает имя родительского объекта в заголовке
			Для Каждого СтрокаТипаМетаданных Из ирКэш.ТипыМетаОбъектов(, Ложь, Ложь) Цикл
				Если СтрокаТипаМетаданных.Единственное = "Перерасчет" Тогда
					Продолжить;
				КонецЕсли;
				Для Каждого ОбъектМДЦикл Из Метаданные[СтрокаТипаМетаданных.Множественное] Цикл
					#Если Сервер И Не Сервер Тогда
						ОбъектМДЦикл = Метаданные.Обработки.ирКонсольЗапросов;
					#КонецЕсли
					Попытка
						Команды = ОбъектМДЦикл.Команды;
					Исключение
						Прервать;
					КонецПопытки;
					КомандаМД = Команды.Найти(Фрагменты[1]);
					Если КомандаМД <> Неопределено Тогда
						ОбъектМД = ОбъектМДЦикл;
						Перейти ~ВыходЦикла;
					КонецЕсли;
				КонецЦикла;
			КонецЦикла;   
			~ВыходЦикла:
			Если ОбъектМД <> Неопределено Тогда
				ИмяМодуля = ОбъектМД.ПолноеИмя() + "." + ИмяМодуля;
				Если КомандаМД <> Неопределено Тогда
					ОбъектМД = КомандаМД;
				КонецЕсли;
			КонецЕсли;
		ИначеЕсли ирОбщий.СтрокиРавныЛкс(Фрагменты[0], "ОбщаяФорма") Тогда
			ИмяОбщегоТипа = "Форма"; 
			ТипМодуля = "Форма.Модуль";
			ОбъектМД = Метаданные.ОбщиеФормы.Найти(Фрагменты[1]);
		Иначе
			ТипМодуля = Фрагменты[Фрагменты.ВГраница()];
			ИмяОбщегоТипа = Фрагменты[0];
			Если ирОбщий.СтрокиРавныЛкс(ТипМодуля, "МодульОбъекта") Тогда
				Подтип = "Объект";
			ИначеЕсли ирОбщий.СтрокиРавныЛкс(ТипМодуля, "МодульМенеджера") Тогда
				Подтип = "Менеджер";
			ИначеЕсли ирОбщий.СтрокиРавныЛкс(ТипМодуля, "МодульНабораЗаписей") Тогда
				Подтип = "НаборЗаписей";
			ИначеЕсли ирОбщий.СтрокиРавныЛкс(ТипМодуля, "МодульМенеджераЗначения") Тогда
				Подтип = "МенеджерЗначения";
			Иначе 
				ТипМодуля = "Форма.Модуль";
				Подтип = "";
			КонецЕсли;
			Если ЗначениеЗаполнено(Подтип) Тогда
				Фрагменты.Удалить(Фрагменты.ВГраница());
				КлючПоиска = Новый Структура;
				КлючПоиска.Вставить("БазовыйТип", ИмяОбщегоТипа + Подтип);
				КлючПоиска.Вставить("ЯзыкПрограммы", 0);
				ИмяОбщегоТипа = мПлатформа.ТаблицаОбщихТипов.НайтиСтроки(КлючПоиска)[0].Слово;
			Иначе
				ИмяОбщегоТипа = "Форма";
				Фрагменты.Вставить(Фрагменты.ВГраница(), ИмяОбщегоТипа);
			КонецЕсли;
			ИмяМодуля = ирОбщий.СтрСоединитьЛкс(Фрагменты, ".");
			ОбъектМД = Метаданные.НайтиПоПолномуИмени(ИмяМодуля);
		КонецЕсли;
		СтруктураТипа = мПлатформа.НоваяСтруктураТипа(ИмяОбщегоТипа);
		Если ОбъектМД = Неопределено Тогда 
			Если ИмяОбщегоТипа = "Форма" Тогда 
				СтруктураТипа.Метаданные = Новый Структура("ИмяФормы", ИмяМодуля);
			Иначе
				СтруктураТипа.Метаданные = ИмяМодуля;
			КонецЕсли;
		КонецЕсли;
		Если ИмяОбщегоТипа = "Форма" Тогда
			Форма = мПлатформа.ПассивнаяФормаПоИмениКэш(ИмяМодуля);
			Если Форма = Неопределено Тогда
				ОбъектМД = Метаданные;
			Иначе
				ОбъектМД = Форма;
			КонецЕсли;
			Если ТипЗнч(ОбъектМД) = Тип("Структура") Тогда
				СтруктураТипа = мПлатформа.СтруктураТипаИзКонкретногоТипа(ОбъектМД.Тип);
			ИначеЕсли ТипЗнч(ОбъектМД) <> ТипЗнч(Метаданные) Тогда
				СтруктураТипа = мПлатформа.СтруктураТипаИзЗначения(ОбъектМД);
			КонецЕсли;
		КонецЕсли;
		Если ОбъектМД <> Неопределено Тогда
			СтруктураТипа.Метаданные = ОбъектМД;
		КонецЕсли;      
		Если ЗначениеЗаполнено(ТипМодуля) Тогда
			ИмяМодуля = ИмяМодуля + "." + ТипМодуля;
		КонецЕсли;
		СтруктураТипа.ДержательМетаданных = ИмяРасширения;
	КонецЕсли; 
	мМодульМетаданных = мПлатформа.ПодготовитьМодульМетаданных(СтруктураТипа, ТипМодуля,, Текст, НовоеКонецВыделения);
	Если Текст <> Неопределено И мСтарыйОригинальныйТекст <> Текст Тогда
		мСтарыйОригинальныйТекст = Текст;
		СлужебноеПолеТекстаДолгое.УстановитьТекст(Текст);
	КонецЕсли;
	мФлагиКомпиляции = ирОбщий.СкопироватьКоллекциюЛкс(мМодульМетаданных.ФлагиКомпиляции);
	Если ТипЗнч(СтруктураТипа.ДержательМетаданных) = Тип("Строка") Тогда
		ИмяМодуля = СтруктураТипа.ДержательМетаданных + " " + ИмяМодуля;
	КонецЕсли;
	Если ЗначениеЗаполнено(мИмяМодуля) И мИмяМодуля <> ИмяМодуля Тогда
		ОчиститьИсториюПереходов();
		мПлатформа.СброситьКэшиТиповВыраженийМодулей(мИмяМодуля);
	КонецЕсли;
	мИмяМодуля = ИмяМодуля;

КонецПроцедуры

Процедура ПрочитатьТекстИзФайлаБезМетаданных(Знач ИмяФайла) Экспорт 
	ПолеТекста.Прочитать(ИмяФайла);
	мСтарыйОригинальныйТекст = ПолеТекста.ПолучитьТекст();
	мОригинальныйТекст = мСтарыйОригинальныйТекст;
КонецПроцедуры 

Процедура УстановитьТекстБезМетаданных(Знач Текст) Экспорт 
	Если Текст = мСтарыйОригинальныйТекст Тогда
		Возврат;
	КонецЕсли;
	ПолеТекста.УстановитьТекст(Текст);
	мСтарыйОригинальныйТекст = Текст;
	мОригинальныйТекст = Текст;
КонецПроцедуры

//.
// Возвращаемое значение:
//    Дата, Неопределено - 
Функция ДатаОбновленияСтруктурыФормыМодуля() Экспорт
	Результат = Неопределено;
	Если мМодульМетаданных <> Неопределено Тогда
		СтруктураТипа = мМодульМетаданных.СтруктураТипа;
		Если Истина
			И СтруктураТипа <> Неопределено 
			И ирОбщий.ЛиИмяТипаФормыЛкс(СтруктураТипа.ИмяОбщегоТипа) 
		Тогда 
			СлужебныеДанные = ирОбщий.СлужебныеДанныеФормыЛкс(СтруктураТипа.Метаданные);
			Если СлужебныеДанные.Тип = ирОбщий.ТипУправляемаяФормаЛкс() Тогда
				Результат = ирОбщий.СвойствоСтруктурыЛкс(СлужебныеДанные, "ДатаОбновления", Дата(1,1,1));
			КонецЕсли;
		КонецЕсли;
	КонецЕсли;
	Возврат Результат;
КонецФункции

Процедура ОткрытьПроверкуМодуля(ПараметрИмяМетода = "") Экспорт 
	Если Не ЗначениеЗаполнено(ПараметрИмяМетода) И мМетодМодуля <> Неопределено Тогда
		ПараметрИмяМетода = мМетодМодуля.Имя
	КонецЕсли;
	Форма = ПолучитьФорму("ОшибкиМодуля");
	Форма.ПараметрМодуль = мМодульМетаданных.Имя;
	Если ПараметрИмяМетода <> Неопределено Тогда
		Форма.ПараметрИмяМетода = ПараметрИмяМетода;
	КонецЕсли;
	Форма.Открыть();
КонецПроцедуры

// Процедура - Проверить выражения после точки
//
// Параметры:
//  ТабличноеПоле	 - ТабличноеПоле - 
//  Форма			 - 				 - 
//  ПолныйПерерасчет - 				 - 
// 
// Возвращаемое значение:
//  Булево - были ли обнаружены новые ошибки
//
Функция ПроверитьВыраженияТекста(Знач ТабличноеПоле = Неопределено, Форма = Неопределено, Знач ПолныйПерерасчет = Ложь, Знач ПроверятьВсеЛитералы = Ложь) Экспорт
	мПлатформа.СброситьКэшТиповВыраженийМодуля(мМодульМетаданных);
	ОшибкиМодуля.Очистить();
	мПлатформа.мРежимПроверкиМодуля = Истина; 
	ирКлиент.ПодключитьГлобальныйОбработчикОжиданияЛкс("ОтключитьРежимПроверкиМодуляЛкс");
	Если ПолныйПерерасчет Тогда 
		мМодульМетаданных.Методы.ЗаполнитьЗначения(Неопределено, "ЕстьОшибки");
	ИначеЕсли мМодульМетаданных.Ошибки <> Неопределено Тогда
		ОшибкиМодуля.Загрузить(мМодульМетаданных.Ошибки);
	КонецЕсли;
	мПлатформа.УдалитьОшибкиМетода(, ОшибкиМодуля);
	Если ТабличноеПоле <> Неопределено Тогда
		ТабличноеПоле.ОбновитьСтроки();
	КонецЕсли;
	ИнициироватьРекурсивныйПуть();
	КончитьОбработкуКоманды();
	РазобратьТекущийКонтекст();
	ПрочитатьНачалоИКонецТекущейСтроки("");
	Если мМетодМодуля <> Неопределено Тогда
		ПараметрМетод = мМетодМодуля.Имя;
	КонецЕсли; 
	НачальнаяПозицияТекущегоМетода = мПозицияТекстаДляПоискаОпределения;
	КонечнаяПозицияТекущегоМетода = мПозицияТекстаДляПоискаОпределения + СтрДлина(мТекстБлока);
	НачальноеКоличество = ОшибкиМодуля.Количество();
	СтруктураОбновленияТабличногПоля = ирКлиент.СтрукутраПервогоОбновленияТабличногоПоляЛкс();
	ВложенныеВыраженияШаблон = ирОбщий.НоваяТаблицаЗначенийЛкс("Выражение, Позиция0ВБлоке, ВызовМетода");
	мРегВыражение.Global = Истина;
	мРегВыражение.Pattern = шПроверяемоеВыражение;
	Вхождения = мРегВыражение.НайтиВхождения(мОригинальныйТекст);
	Для Этап = 1 По 2 Цикл
		Если Этап = 1 Тогда
			ДобавкаПредставления = "метода";
		Иначе 
			ДобавкаПредставления = "модуля";
		КонецЕсли;
		Индикатор = ирОбщий.ПолучитьИндикаторПроцессаЛкс(Вхождения.Количество(), "Проверка " + ДобавкаПредставления);
		ПроверитьВыраженияУровня(Вхождения, ПроверятьВсеЛитералы, ТабличноеПоле, Форма, Индикатор, КонечнаяПозицияТекущегоМетода, НачальнаяПозицияТекущегоМетода,
			СтруктураОбновленияТабличногПоля, Этап, ВложенныеВыраженияШаблон);
		ирОбщий.ОсвободитьИндикаторПроцессаЛкс();
		Если Этап = 1 И ТабличноеПоле <> Неопределено Тогда
			ТабличноеПоле.ОбновитьСтроки();
		КонецЕсли;
	КонецЦикла;
	Если ТабличноеПоле <> Неопределено И НачальноеКоличество > 0 Тогда
		ТабличноеПоле.ВыделенныеСтроки.Очистить();
		Для Счетчик = НачальноеКоличество + 1 По ОшибкиМодуля.Количество() Цикл
			ТабличноеПоле.ВыделенныеСтроки.Добавить(ОшибкиМодуля[Счетчик - 1]);
		КонецЦикла;
		Если ТабличноеПоле.ВыделенныеСтроки.Количество() > 0 Тогда
			ТабличноеПоле.ТекущаяСтрока = ТабличноеПоле.ВыделенныеСтроки[0];
		КонецЕсли;
	КонецЕсли;
	//Если Не ПолныйПерерасчет Тогда
		ОшибкиМодуля.Сортировать("Метод, Позиция");
	//КонецЕсли;
	мРекурсивныйПуть = Неопределено;
	мМодульМетаданных.Ошибки = ОшибкиМодуля.Выгрузить(, "ВыражениеРодитель, ДатаОбнаружения, Метод, Позиция, ПозицияВМетоде, Слово, ТипРодителя, Язык, ТипОшибки");
	мМодульМетаданных.Методы.ЗаполнитьЗначения(Ложь, "ЕстьОшибки");
	Для Каждого Метод Из ирОбщий.РазличныеЗначенияКолонкиТаблицыЛкс(ОшибкиМодуля, "Метод") Цикл 
		СтрокаМетода = мМодульМетаданных.Методы.Найти(Метод, "Имя");
		Если СтрокаМетода <> Неопределено Тогда
			СтрокаМетода.ЕстьОшибки = Истина;
		КонецЕсли;
	КонецЦикла;
	Если Форма <> Неопределено Тогда
		Форма.КоличествоНайдено = ОшибкиМодуля.Количество();
	Иначе
		Если ОшибкиМодуля.Количество() > 0 Тогда
			ОткрытьПроверкуМодуля(ПараметрМетод); 
		КонецЕсли;
	КонецЕсли;
	Возврат НачальноеКоличество < ОшибкиМодуля.Количество();
КонецФункции

//.
// Параметры:
//    ТабличноеПоле - ТабличноеПоле  -  
//    Форма - Неопределено -  
//    ПроверятьВсеЛитералы - Булево - 
//    ВложенныеВыраженияШаблон - ТаблицаЗначений - 
//    Вхождения - Массив[ОбработкаОбъект.ирОболочкаРегВхождение] - 
//    ДлинаДобавкиОкрестности - Число - 
//    Индикатор - СтрокаТаблицыЗначений, Структура - 
//    ИнструкцияПодавленияПроверки - Строка - 
//    КонечнаяПозицияТекущегоМетода - Неопределено - 
//    НачальнаяПозицияТекущегоМетода - Неопределено - 
//    СтруктураОбновленияТабличногПоля - Структура - 
//    Этап - Число - 
Функция ПроверитьВыраженияУровня(Знач Вхождения, Знач ПроверятьВсеЛитералы = Ложь, Знач ТабличноеПоле = Неопределено, Знач Форма = Неопределено, Знач Индикатор = Неопределено,
	Знач КонечнаяПозицияТекущегоМетода = Неопределено, Знач НачальнаяПозицияТекущегоМетода = Неопределено, Знач СтруктураОбновленияТабличногПоля = Неопределено, Знач Этап = 0,
	Знач ВложенныеВыраженияШаблон, Знач СмещениеВБлоке = 0, Знач НачалоБлока = Неопределено, Знач ДлинаДобавкиОкрестности = 120) Экспорт

	ИнструкцияПодавленияНеизвестноеСлово = ИнструкцияПодавленияПроверки();
	ИнструкцияПодавленияМалоПараметров = ИнструкцияПодавленияПроверки("МалоПараметров");
	ИнструкцияПодавленияМногоПараметров = ИнструкцияПодавленияПроверки("МногоПараметров");
	Счетчик = 0; 
	Если НачалоБлока = Неопределено Тогда
	   НачалоБлока = мПозицияТекстаДляПоискаОпределения - 1;
	КонецЕсли;
	Для Каждого Вхождение Из Вхождения Цикл
		//МоментНачала = ирОбщий.ТекущееВремяВМиллисекундахЛкс();
		Если Этап > 0 Тогда
			// Это НЕ вложенная проверка
			ЛиВТекущемМетоде = Не ЛиВхождениеВЗапрешенномДиапазоне(Вхождение, НачальнаяПозицияТекущегоМетода, КонечнаяПозицияТекущегоМетода);
			Если Ложь
				Или Этап = 1 И Не ЛиВТекущемМетоде 
				Или Этап = 2 И ЛиВТекущемМетоде
			Тогда 
				Продолжить;
			КонецЕсли;
		КонецЕсли;
		Счетчик = Счетчик + 1;
		ВыражениеЛитерала = Вхождение.SubMatches(0);
		ВыражениеСТочкой = Вхождение.SubMatches(3);
		Если ВыражениеСТочкой = Неопределено И ВыражениеЛитерала = Неопределено Тогда
			Продолжить;
		КонецЕсли;
		Если Этап > 0 Тогда
			Если ирОбщий.ОбработатьИндикаторЛкс(Индикатор, Счетчик) Тогда 
				Если Форма <> Неопределено Тогда
					Форма.КоличествоНайдено = ОшибкиМодуля.Количество();
				КонецЕсли;
			КонецЕсли;
			ПредФрагмент = Сред(мОригинальныйТекст, Вхождение.FirstIndex - ДлинаДобавкиОкрестности, ДлинаДобавкиОкрестности);
			ПостФрагмент = Сред(мОригинальныйТекст, Вхождение.FirstIndex + Вхождение.Length, ДлинаДобавкиОкрестности);
			Если Истина
				И Найти(ПредФрагмент, Символы.Таб + "Попытка") > 0 
				И Найти(ПостФрагмент, Символы.Таб + "Исключение") > 0
			Тогда
				// Узкие вычисления в попытке обычно подразумевают возможность обращения к неизвестному слову
				Продолжить;
			КонецЕсли;
			мФлагиПодавленияОшибок = Новый Структура;
			ПервыйПостФрагмент = ирОбщий.ПервыйФрагментЛкс(ПостФрагмент, Символы.ПС);
			Если Найти(ПервыйПостФрагмент, ИнструкцияПодавленияНеизвестноеСлово) > 0 Тогда
				мФлагиПодавленияОшибок.Вставить("НеизвестноеСлово");
			КонецЕсли; 
			ЛиВнутриНевыполнимогоКода = Истина
				И Найти(ПредФрагмент, "#Если Сервер И Не Сервер") > 0 
				И Найти(ПостФрагмент, "#КонецЕсли") > 0;
			Если Ложь
				Или ЛиВнутриНевыполнимогоКода
				Или Найти(ПервыйПостФрагмент, ИнструкцияПодавленияМалоПараметров) > 0
			Тогда
				мФлагиПодавленияОшибок.Вставить("МалоПараметров");
			КонецЕсли;
			Если Ложь
				Или ЛиВнутриНевыполнимогоКода
				Или Найти(ПервыйПостФрагмент, ИнструкцияПодавленияМногоПараметров) > 0
			Тогда
				мФлагиПодавленияОшибок.Вставить("МногоПараметров");
			КонецЕсли;
		КонецЕсли;
		ПозицияВхождения0ВМодуле = СмещениеВБлоке + Вхождение.FirstIndex + СтрДлина(Вхождение.SubMatches(1));
		Если Этап > 0 Тогда
			Если ЗагрузитьМетодМодуляПоПозиции(ПозицияВхождения0ВМодуле) Тогда
				НачалоБлока = мПозицияТекстаДляПоискаОпределения - 1;
			КонецЕсли;
			Если мМетодМодуля <> Неопределено И мМетодМодуля.ЕстьОшибки <> Неопределено Тогда
				Продолжить;
			КонецЕсли;
		Иначе
			ПозицияВхождения0ВМодуле = ПозицияВхождения0ВМодуле + НачалоБлока - 1;
		КонецЕсли;
		ПозицияВхождения0ВБлоке = ПозицияВхождения0ВМодуле - НачалоБлока + 1;
		мЭтоТекстовыйЛитерал = Ложь;
		//мТекстДляПоискаОпределения = "";
		Если ВыражениеЛитерала <> Неопределено Тогда 
			ЧислоСтрок = СтрЧислоСтрок(ВыражениеЛитерала);
			ЛиНачинаетсяСКавычки = Лев(ВыражениеЛитерала, 1) = """";
			Если Не ЛиНачинаетсяСКавычки Тогда
				ВыражениеЛитерала = СокрЛ(Сред(ВыражениеЛитерала, 2));
			КонецЕсли;
			ЛиКончаетсяНаКавычки = Прав(ВыражениеЛитерала, 1) = """";
			Если Не ЛиКончаетсяНаКавычки Тогда
				ВыражениеЛитерала = СокрП(ирОбщий.СтрокаБезКонцаЛкс(ВыражениеЛитерала));
			КонецЕсли;
			Если Истина
				И ЧислоСтрок = 1 
				И (Ложь
					Или Найти(ВыражениеЛитерала, ".") > 0 
					Или Этап = 1
					Или ПроверятьВсеЛитералы)
				И Найти(ВыражениеЛитерала, ",") = 0
				И Найти(ВыражениеЛитерала, " ") = 0
				И ЛиНачинаетсяСКавычки
				И ЛиКончаетсяНаКавычки
				И СтрДлина(ВыражениеЛитерала) > 2
			Тогда
				ТекстЛитерала = ирОбщий.ТекстИзВстроенногоЯзыкаЛкс(ВыражениеЛитерала);
				мЭтоТекстовыйЛитерал = Истина;
				мНомерПараметра = 0;
				НетТочки = Найти(ВыражениеЛитерала, ".") = 0;
				Если Истина
					И НетТочки
					И ирОбщий.ЛиИмяПеременнойЛкс(ТекстЛитерала) 
				Тогда
					ПолеТекста.УстановитьГраницыВыделения(ПозицияВхождения0ВМодуле + 2, ПозицияВхождения0ВМодуле + 2);
					//КончитьОбработкуКоманды();
					//РазобратьТекущийКонтекст(,, Истина,,,, ПозицияВхождения0ВМодуле + 2);
					ПолучитьГраницыВыделения();
					ПрочитатьНачалоИКонецТекущейСтроки("");
					РазобратьКонтекстСтроки(,, Истина);
				КонецЕсли;  
				ПозицияВхождения0ВБлоке = ПозицияВхождения0ВБлоке - 1;
				ТаблицаТипов = ДобавитьВозможнуюОшибкуПослеТочки(ВложенныеВыраженияШаблон, ТекстЛитерала, ПозицияВхождения0ВБлоке, ПроверятьВсеЛитералы, НачалоБлока);
				Если Истина
					И мНомерПараметра > 0
					И НетТочки 
					И ТаблицаТипов.Количество() > 0
				Тогда
					ИмяВызывающегоМетода = ИмяТекущегоМетода();
					ВызовМетода = мВызовМетода;
					СтрокаОписания = ТаблицаТипов[0].СтрокаОписания;
					РекурсивныйПуть = мРекурсивныйПуть;
					мРекурсивныйПуть = Неопределено;
					мПозицияВТексте = ПозицияВхождения0ВМодуле + 2;
					мПозицияВБлоке = ПозицияВхождения0ВБлоке; 
					ЗаполнитьТаблицуСлов(ТаблицаТипов.Скопировать(),,, Ложь, Ложь);
					мРекурсивныйПуть = РекурсивныйПуть;
					Если Истина
						И ТаблицаСлов.Количество() > 0
						И ТаблицаСлов.Найти(НРег(ТекстЛитерала), "НСлово") = Неопределено
					Тогда
						СтрокаОшибки = ДобавитьОшибкуМодуля(ПозицияВхождения0ВБлоке + 1);
						СтрокаОшибки.Метод = ИмяВызывающегоМетода;
						СтрокаОшибки.ВыражениеРодитель = ВызовМетода;
						Если ТипЗнч(СтрокаОписания) = Тип("СтрокаТаблицыЗначений") Тогда
							Если СтрокаОписания.Владелец().Колонки.Найти("ТипКонтекста") <> Неопределено Тогда
								Если СтрокаОписания.ТипСлова = "Метод" Тогда
									СтрокаОшибки.ТипРодителя = СтрокаОписания.ТипКонтекста + "." + СтрокаОписания.Слово + "("; 
								//Иначе
								//	СтрокаОшибки.ТипРодителя = "(" + СтрокаОписания.ТипЯзыка;
								КонецЕсли;
							Иначе 
								СтрокаОшибки.ТипРодителя = СтрокаОписания.Имя + "("; 
								Если СтрокаОписания.ИмяМодуля <> мМодульМетаданных.Имя Тогда
									СтрокаОшибки.ТипРодителя = СтрокаОписания.ИмяМодуля + "." + СтрокаОшибки.ТипРодителя;
								КонецЕсли;
							КонецЕсли;
							СтрокаОшибки.ТипРодителя = СтрокаОшибки.ТипРодителя + ИмяПараметраВызоваМетода(СтрокаОписания) + ")";
						КонецЕсли;
						СтрокаОшибки.Слово = ТекстЛитерала;
						Если мМетодМодуля = Неопределено Тогда
							СтрокаОшибки.ПозицияВМетоде = СтрокаОшибки.ПозицияВМетоде - 1;
						КонецЕсли;
						СтрокаОшибки.Язык = "Литерал";
					КонецЕсли;
				КонецЕсли;
			ИначеЕсли Истина
				И ЧислоСтрок > 1 
				//И ирОбщий.СтрНачинаетсяСЛкс(ВыражениеЛитерала, """ВЫБРАТЬ")
			Тогда
				ТекстЛитерала = ирОбщий.ТекстИзВстроенногоЯзыкаЛкс(ВыражениеЛитерала);
				Если ирОбщий.ЛиТекстЯзыкаЗапросовЛкс(ТекстЛитерала) Тогда
					мНачальнаяПозиция0ВложенногоТекста = ПозицияВхождения0ВМодуле + 1;
					УстановитьГраницыВыделения(мНачальнаяПозиция0ВложенногоТекста, мНачальнаяПозиция0ВложенногоТекста);
					РазобратьКонтекстЗапросаВТекстовомЛитерале(ВыражениеЛитерала, ТекстЛитерала, Ложь);
					СчетчикЗапроса = 0; 
					мРегВыражение.Global = Истина;
					НадоВосстановитьМетод = Ложь;
					мРегВыражение.Pattern = шПроверяемоеВыражение;
					ВхожденияЗапроса = мРегВыражение.НайтиВхождения(Сред(ВыражениеЛитерала, 2)); // Отрезаем первую кавычку
					ИндикаторЗапроса = ирОбщий.ПолучитьИндикаторПроцессаЛкс(ВхожденияЗапроса.Количество(), "Глубокая проверка запроса " + мНачальнаяПозиция0ВложенногоТекста);
					Для Каждого ВхождениеЗапроса Из ВхожденияЗапроса Цикл
						СчетчикЗапроса = СчетчикЗапроса + 1;
						Выражение = ВхождениеЗапроса.SubMatches(3);
						Если Выражение = Неопределено Тогда
							Продолжить;
						КонецЕсли;
						ирОбщий.ОбработатьИндикаторЛкс(ИндикаторЗапроса, СчетчикЗапроса);
						НадоВосстановитьМетод = Истина;
						ПозицияВхождения0ВБлоке = ВхождениеЗапроса.FirstIndex + СтрДлина(ВхождениеЗапроса.SubMatches(1)) + 1;
						ЗагрузитьЗапросПакетаМодуляПоПозиции(,, ПозицияВхождения0ВБлоке);
						//мТекстДляПоискаОпределения = мТекстБлока; 
						ПозицияВхождения0ВБлоке = ПозицияВхождения0ВБлоке - мПозицияТекстаДляПоискаОпределения + мНачальнаяПозиция0ВложенногоТекста + 1;
						ДобавитьВозможнуюОшибкуПослеТочки(ВложенныеВыраженияШаблон, Выражение, ПозицияВхождения0ВБлоке, ПроверятьВсеЛитералы, Неопределено);
						Если ТабличноеПоле <> Неопределено Тогда
							ирКлиент.ПроверитьПервоеОбновлениеТабличногоПоляЛкс(ТабличноеПоле, СтруктураОбновленияТабличногПоля, 20);
						КонецЕсли;
					КонецЦикла;
					ирОбщий.ОсвободитьИндикаторПроцессаЛкс();
					мЯзыкПрограммы = 0;
					мНачальнаяПозиция0ВложенногоТекста = 0;
					Если НадоВосстановитьМетод Тогда
						ЗагрузитьМетодМодуляПоПозиции(ПозицияВхождения0ВМодуле, Истина);
					КонецЕсли; 
				КонецЕсли;
			КонецЕсли; 
		Иначе
			ДобавитьВозможнуюОшибкуПослеТочки(ВложенныеВыраженияШаблон, ВыражениеСТочкой, ПозицияВхождения0ВБлоке, ПроверятьВсеЛитералы, НачалоБлока); 
			Если ТабличноеПоле <> Неопределено Тогда
				ирКлиент.ПроверитьПервоеОбновлениеТабличногоПоляЛкс(ТабличноеПоле, СтруктураОбновленияТабличногПоля, 20);
			КонецЕсли;
		КонецЕсли;
		//Длительность = ирОбщий.ТекущееВремяВМиллисекундахЛкс() - МоментНачала; // Для отладки
	КонецЦикла; 
КонецФункции

Функция ИнструкцияПодавленияПроверки(Знач ТипОшибки = "НеизвестноеСлово", Знач Чистая = Ложь) Экспорт
	Результат = "@skip-check ";
	Если ТипОшибки = "НеизвестноеСлово" Тогда
		Результат = Результат + "unknown-method-property";
	ИначеЕсли ТипОшибки = "МногоПараметров" Тогда
		Результат = Результат + "many-actual-parameters";
	ИначеЕсли ТипОшибки = "МалоПараметров" Тогда
		Результат = Результат + "not-enough-parameters";
	КонецЕсли;
	Если Чистая Тогда
		Возврат Результат;
	Иначе 
		Возврат "//" + Результат;
	КонецЕсли;
КонецФункции

//.
// Параметры:
//    ВложенныеВыраженияШаблон - ТаблицаЗначений - :
//      * Выражение
//      * Позиция0ВБлоке
//      * ВызовМетода
//    Выражение - Неопределено - 
//    ПозицияВхождения0ВБлоке - Число - 
//    ТаблицаРезультата - ТаблицаЗначений - 
Функция ДобавитьВозможнуюОшибкуПослеТочки(Знач ВложенныеВыраженияШаблон, Знач НайденноеВыражение, Знач Позиция0ВБлоке, Знач ПроверятьВсеЛитералы, Знач НачалоБлока) Экспорт
	ВложенныеВыражения = ВложенныеВыраженияШаблон.СкопироватьКолонки();
	мРекурсивныйПуть.ВложенныеВыражения = ВложенныеВыражения;
	мРекурсивныйПуть.ПозицииЗапроса.Очистить();
	мРекурсивныйПуть.ВходящиеВызовы.Очистить(); // Иначе будут ложные ошибки {Обработка.ирКлсПолеТекстаПрограммы.МодульОбъекта(8743:ДобавитьЕдинственныйТип,15)}: ИначеЕсли СтруктураТипа.ИмяОбщегоТипа = "ПолеФормы" Тогда
	мРекурсивныйПуть.СчетчикиВызовов.Очистить();
	ТаблицаТипов = ВычислитьТипЗначенияВыражения(НайденноеВыражение,,, Истина,,, Ложь,,,,, Позиция0ВБлоке,,, Истина);
	Для Каждого ВложенноеВыражение Из ВложенныеВыражения Цикл
		мРегВыражение.Pattern = шПроверяемоеВыражение;
		мРегВыражение.Global = Истина;
		ВложенныеВхождения = мРегВыражение.НайтиВхождения(ВложенноеВыражение.Выражение,, Истина);
		ПроверитьВыраженияУровня(ВложенныеВхождения, ПроверятьВсеЛитералы,,,,,,,, ВложенныеВыраженияШаблон, ВложенноеВыражение.Позиция0ВБлоке, НачалоБлока);
	КонецЦикла; 
	Возврат ТаблицаТипов;
КонецФункции

///////////////////
// Редактор HTML

// Процедура - Редактор HTML инициировать
//
// Параметры:
//  ПолеHTML - ПолеHTMLДокумента - 
//
Процедура РедакторHTML_Инициировать(ПолеHTML) Экспорт 
	
	#Если Сервер И Не Сервер Тогда
		мПлатформа = Обработки.ирПлатформа.Создать();
	#КонецЕсли
	ФормаКласса = мПлатформа.ПолучитьМакетКомпоненты(ЭтотОбъект);
	КнопкиМакета = ФормаКласса.ЭлементыФормы.КПРедакторHTML.Кнопки.КонтекстноеМеню.Кнопки;
	КонтекстноеМеню = ПолеHTML.КонтекстноеМеню;
	Если КонтекстноеМеню = Неопределено Тогда
		КонтекстноеМеню = ФормаВладелец.ЭлементыФормы.Добавить(Тип("КоманднаяПанель"), "КонтекстноеМеню" + ПолеHTML.Имя, Ложь);
		КонтекстноеМеню.ИсточникДействий = ПолеHTML;
		ПолеHTML.КонтекстноеМеню = КонтекстноеМеню;
	КонецЕсли;
	ирКлиент.ДобавитьКнопкиКоманднойПанелиКомпонентыЛкс(ЭтотОбъект, КнопкиМакета, КонтекстноеМеню,,, Истина);
	ПолеТекстаHTML = ирКлиент.ОболочкаПоляТекстаЛкс(ПолеHTML);
	#Если Сервер И Не Сервер Тогда
		ПолеТекстаHTML = Обработки.ирОболочкаПолеТекста.Создать();
	#КонецЕсли
	ПолеТекстаHTML.Инициировать(ФормаВладелец);
	РедакторHTML = ПолеHTML.Документ.defaultView;
	Инфо = Новый СистемнаяИнформация();
	РедакторHTML.minimap(Ложь);
	РедакторHTML.init(Инфо.ВерсияПриложения);
	Если ЯзыкПрограммы = 1 Тогда
		РедакторHTML.setLanguageMode("bsl_query");
	ИначеЕсли ЯзыкПрограммы = 2 Тогда
		РедакторHTML.setLanguageMode("dcs_query");
	КонецЕсли; 
	РедакторHTML.setOption("disableContextQueryConstructor", Истина);
	РедакторHTML.setOption("disableNativeSuggestions", Истина); // События не перестают вызываться
	РедакторHTML.setOption("disableNativeSignatures", Истина); // События не перестают вызываться
	РедакторHTML.setOption("disableNativeHovers", Истина); // События не перестают вызываться
	РедакторHTML.setOption("skipInsertSuggestionAcceptor", Истина); // Отключаем вставку точки при выборе слова из списка https://github.com/salexdv/bsl_console/issues/120#issuecomment-844372676
	РедакторHTML.setOption("skipAcceptionSelectedSuggestion", Истина); // Отключаем стандартную обработку вставки активного пункта подсказки. Практически 'СтандартнаяОбработка = Ложь'
	РедакторHTML.setOption("renderQueryDelimiters", Истина); // Разделители запросов пакета https://github.com/salexdv/bsl_console/issues/218
	РедакторHTML.setOption("generateBeforeSignatureEvent", Истина);
	РедакторHTML.setOption("generateBeforeShowSuggestEvent", Истина);
	РедакторHTML.setOption("generateSelectSuggestEvent", Истина);
	РедакторHTML.setOption("generateBeforeHoverEvent", Истина);
	РедакторHTML.setOption("generateModificationEvent", Истина);
	РедакторHTML.disableKeyBinding(2082); // CTRL(2048)+D(34) - CTRL+D
	РедакторHTML.disableKeyBinding(2118); // CTRL(2048)+D(70) - F12
	РедакторHTML.setActiveSuggestionAcceptors("."); // По нажатию точки выполняется вставка активного слова и ввод точки // Много нежелательных срабатываний
	
КонецПроцедуры 

Процедура РедакторHTML_Уничтожить(ПолеHTML) Экспорт
	//Если ирКэш.НомерВерсииПлатформыЛкс() >= 803025 Тогда
	//	// Антибаг Аварийное завершение https://www.hostedredmine.com/issues/984781 
	//	Возврат;
	//КонецЕсли;
	//РедакторHTML = ирКлиент.ОболочкаПоляТекстаЛкс(ПолеHTML).РедакторHTML();
	//Если РедакторHTML <> Неопределено Тогда
	//	РедакторHTML.version1C = ""; // Предотвращаем повторное удаление обработчика без добавления https://www.hostedredmine.com/issues/936924
	//	ИмяОбработчика = "" + ПолеHTML.ПолучитьДействие("onclick") + "Динамический";
	//	ПолеHTML.УстановитьДействие("onclick", Неопределено);
	//	// Блокирует неоправданное обновление формы https://github.com/salexdv/bsl_console/issues/178
	//	// Не забудь отключить в ПередЗакрытием
	//	Выполнить("УдалитьОбработчик РедакторHTML.onclick, ФормаВладелец." + ИмяОбработчика); 
	//КонецЕсли;
КонецПроцедуры

Функция ДобавитьПодсказкуПоЗначениюВыражения(Знач ЗначениеВыражения = Неопределено, Знач ОбъектноеВыражение, Знач ПодсказкаМассив, СтруктураТипа = Неопределено) Экспорт 
	
	#Если Сервер И Не Сервер Тогда
		ПодсказкаМассив = Новый Массив;
	#КонецЕсли
	ЕстьОписаниеТипа = Ложь;
	Если СтруктураТипа = Неопределено Тогда
		СтруктураТипа = мПлатформа.СтруктураТипаИзЗначения(ЗначениеВыражения, ЯзыкПрограммы);
	КонецЕсли;
	ИмяТипаЗначения = мПлатформа.ИмяТипаИзСтруктурыТипа(СтруктураТипа);
	ИмяОбщегоТипа = СтруктураТипа.ИмяОбщегоТипа;
	СтрокаОбщегоТипа = мПлатформа.ТаблицаОбщихТипов.Найти(НРег(ИмяОбщегоТипа), "НСлово");
	Если СтрокаОбщегоТипа <> Неопределено Тогда
		ЕстьОписаниеТипа = ЗначениеЗаполнено(СтрокаОбщегоТипа.ПутьКОписанию);
	КонецЕсли;
	Если ИмяТипаЗначения = "Строка" Тогда
		ПодсказкаЗначения = "Знач: """ + ЗначениеВыражения + """";
	Иначе
		Если ТипЗнч(ЗначениеВыражения) = Тип("Строка") Тогда
			ПодсказкаЗначения = ЗначениеВыражения;
		Иначе
			ПодсказкаЗначения = ирОбщий.РасширенноеПредставлениеЗначенияЛкс(ЗначениеВыражения,, Ложь, Истина);
		КонецЕсли; 
		Если Ложь
			Или ТипЗнч(ЗначениеВыражения) = Тип("Неопределено") 
			Или ТипЗнч(ЗначениеВыражения) = Тип("Null")
		Тогда
			ПодсказкаЗначения = "Знач: " + ПодсказкаЗначения;
		Иначе
			ПодсказкаЗначения = "[Знач](" + ОбъектноеВыражение + "): " + ПодсказкаЗначения;
		КонецЕсли; 
		Если ПодсказкаЗначения = ИмяТипаЗначения Тогда
			ПодсказкаЗначения = "";
		Иначе
			ПодсказкаЗначения = ПодсказкаЗначения + " ";
		КонецЕсли; 
		Если ЕстьОписаниеТипа Тогда
			ИмяСсылкиТипа = "_Тип" + XMLСтрока(мСтруктурыТиповПодсказкиУдержания.Количество());
			ПодсказкаЗначения = ПодсказкаЗначения + "[[" + ИмяТипаЗначения + "]](" + ИмяСсылкиТипа + ")";
			мСтруктурыТиповПодсказкиУдержания.Вставить(ИмяСсылкиТипа, СтруктураТипа);
		Иначе
			ПодсказкаЗначения = ПодсказкаЗначения + "[" + ИмяТипаЗначения + "]";
		КонецЕсли; 
	КонецЕсли; 
	ПодсказкаМассив.Добавить(ПодсказкаЗначения);
	Возврат ИмяТипаЗначения;

КонецФункции

Функция ДобавитьПодсказкуПоДопустимымТипам(Знач ИмяТипаЗначения, Знач ПодсказкаМассив, Знач ОбъектноеВыражение) Экспорт 
	
	ТаблицаТипов = ТаблицаТиповТекущегоВыражения(Истина, Истина, Ложь);
	Если Истина
		И ЯзыкПрограммы = 1 
		И ТаблицаТипов.Количество() > 0
		И ТаблицаТипов[0].ИмяОбщегоТипа = "ВременнаяТаблица"
		И ТипЗнч(КонтекстВыполнения) = Тип("Запрос")
	Тогда
		ВременныйЗапрос = Новый Запрос;
		ВременныйЗапрос.МенеджерВременныхТаблиц = КонтекстВыполнения.МенеджерВременныхТаблиц;
		ИмяВременнойТаблицы = ТаблицаТипов[0].ВиртуальнаяТаблица.Выражение;
		Если ЗначениеЗаполнено(ИмяВременнойТаблицы) Тогда
			ВременныйЗапрос.Текст = "ВЫБРАТЬ КОЛИЧЕСТВО(*) ИЗ " + ИмяВременнойТаблицы;
			КоличествоСтрокВТаблице = ВременныйЗапрос.Выполнить().Выгрузить()[0][0];
			ДобавитьПодсказкуПоЗначениюВыражения(ИмяВременнойТаблицы + "(" + КоличествоСтрокВТаблице + ")", ОбъектноеВыражение, ПодсказкаМассив, ТаблицаТипов[0]);
		КонецЕсли;
	КонецЕсли; 
	ПредставлениеДопустимыхТипов = мПлатформа.ПредставлениеМассиваСтруктурТипов(ТаблицаТипов, Истина);
	Если Истина
		И ПредставлениеДопустимыхТипов <> "?"
		И ПредставлениеДопустимыхТипов <> "ОбщийМодуль"
		И ПредставлениеДопустимыхТипов <> "ВременнаяТаблица"
		И ЗначениеЗаполнено(ПредставлениеДопустимыхТипов)
		И ПредставлениеДопустимыхТипов <> ИмяТипаЗначения
	Тогда
		ИмяСсылкиТипа = "_Тип" + XMLСтрока(мСтруктурыТиповПодсказкиУдержания.Количество());
		мСтруктурыТиповПодсказкиУдержания.Вставить(ИмяСсылкиТипа, ТаблицаТипов);
		ПредставлениеДопустимыхТипов = "[Допустимые типы](" + ИмяСсылкиТипа + "): " + ПредставлениеДопустимыхТипов;
		ПодсказкаМассив.Добавить(ПредставлениеДопустимыхТипов);
	КонецЕсли;
	Если ПредставлениеДопустимыхТипов <> "ОбщийМодуль" Тогда
		ПодсказкаМассив.Добавить("[Определение](" + XMLСтрока(мКонечнаяСтрока) + "," + XMLСтрока(мКонечнаяКолонка) + ")");
	КонецЕсли; 
	Возврат ПредставлениеДопустимыхТипов;

КонецФункции

Процедура ОткрытьОписаниеТипаПоГиперссылке(Знач ИмяОбщегоТипа) Экспорт 
	
	Если Истина
		И ирОбщий.СтрНачинаетсяСЛкс(ИмяОбщегоТипа, "_Тип")
		И мСтруктурыТиповПодсказкиУдержания.Свойство(ИмяОбщегоТипа) 
	Тогда 
		СтруктураТипа = мСтруктурыТиповПодсказкиУдержания[ИмяОбщегоТипа];
		Если ТипЗнч(СтруктураТипа) = Тип("ТаблицаЗначений") Тогда
			ТаблицаДляПользователя = мПлатформа.ТаблицаТиповДляПользователя(СтруктураТипа, Ложь);
			СписокВыбора = Новый СписокЗначений;
			Для Каждого СтрокаТаблицы Из ТаблицаДляПользователя Цикл
				Если ирОбщий.СтрокиРавныЛкс(СтрокаТаблицы.Имя, "null") Тогда
					Продолжить;
				КонецЕсли; 
				СписокВыбора.Добавить(СтрокаТаблицы.СтруктураТипа, СтрокаТаблицы.Имя);
			КонецЦикла;
			СписокВыбора = ирОбщий.СвернутьСписокЗначенийПоПредставлениюЛкс(СписокВыбора);
			Если СписокВыбора.Количество() = 1 Тогда
				СтруктураТипа = СписокВыбора[0];
			Иначе
				СтруктураТипа = СписокВыбора.ВыбратьЭлемент("Выберите тип значения"); 
				Если СтруктураТипа = Неопределено Тогда
					Возврат;
				КонецЕсли; 
			КонецЕсли; 
			СтруктураТипа = СтруктураТипа.Значение; // см. мПлатформа.НоваяСтруктураТипа()
		КонецЕсли; 
		ОткрытьОпределениеСтруктурыТипа(СтруктураТипа, Истина);
	Иначе
		ирКлиент.ОткрытьОписаниеТипаПоИмениТипаЛкс(ИмяОбщегоТипа);
	КонецЕсли; 

КонецПроцедуры

// антибаг редактора https://github.com/salexdv/bsl_console/issues/78#issuecomment-836447865
Функция ЧистоеСловоСпискаПодсказкиHTML(ВыбранноеСлово) Экспорт 
	
	Возврат ирОбщий.ТекстМеждуМаркерамиЛкс(ВыбранноеСлово, "Элемент ", ",", Истина);

КонецФункции

Процедура РедакторHTML_ПередПоказомПодсказкиУдержания(Знач Событие, Знач ФункцияВычислитьВыражение = "") Экспорт 
	
	#Если Сервер И Не Сервер Тогда
		ПолеТекста = Обработки.ирОболочкаПолеТекста.Создать();
	#КонецЕсли
	НомерКолонки23 = Событие.params.column;
	НомерСтроки23 = Событие.params.line; 
	ТекущееСлово = Событие.params.word;
	мСтруктурыТиповПодсказкиУдержания = Новый Структура;
	Если ТекущееСлово = Неопределено Тогда 
		Возврат;
	КонецЕсли; 
	КончитьОбработкуКоманды();
	РедакторHTML = ПолеТекста.РедакторHTML();
	ОбъектноеВыражение = ТекущееОбъектноеВыражение(НомерСтроки23, НомерКолонки23,, Ложь);
	ПодсказкаМассив = Новый Массив;
	Если Истина
		И (Ложь
			Или Найти(ОбъектноеВыражение, "(") = 0 
			Или ирОбщий.СтрКончаетсяНаЛкс(ОбъектноеВыражение, "(") 
			Или ирОбщий.СтрНачинаетсяСЛкс(ОбъектноеВыражение, "("))
		И (Ложь
			Или ирОбщий.ЛиИмяПеременнойЛкс(Лев(ОбъектноеВыражение, 1)) 
			Или Лев(ОбъектноеВыражение, 1) = мПараметрыДиалектаSQL.ПрефиксПараметра
			Или Лев(ОбъектноеВыражение, 1) = "(")
	Тогда
		ФормаВладелец.КлсПолеТекстаПрограммыОбновитьКонтекст(ЭтотОбъект);
		ИмяТипаЗначения = "";
		Если Истина                                                                         
			И ЗначениеЗаполнено(ФункцияВычислитьВыражение)
			И (Ложь
				Или (ЯзыкПрограммы > 0 И Лев(ОбъектноеВыражение, 1) = мПараметрыДиалектаSQL.ПрефиксПараметра)
				Или (ЯзыкПрограммы = 0 И Не ирОбщий.СтрКончаетсяНаЛкс(ОбъектноеВыражение, "(")))
		Тогда
			УспехЗначения = Истина;
			ЗначениеВыражения = Вычислить("ФормаВладелец." + ФункцияВычислитьВыражение + "(ОбъектноеВыражение, УспехЗначения)");
			Если УспехЗначения Тогда
				ИмяТипаЗначения = ДобавитьПодсказкуПоЗначениюВыражения(ЗначениеВыражения, ОбъектноеВыражение, ПодсказкаМассив);
			КонецЕсли; 
		КонецЕсли; 
		ПредставлениеДопустимыхТипов = ДобавитьПодсказкуПоДопустимымТипам(ИмяТипаЗначения, ПодсказкаМассив, ОбъектноеВыражение);
	КонецЕсли; 
	КончитьОбработкуКоманды();
	СтруктураПодсказки = Новый Соответствие;
	СтруктураПодсказки.Вставить(ТекущееСлово.word, ПодсказкаМассив);
	РедакторHTML.setCustomHovers(ирОбщий.ОбъектВСтрокуJSONЛкс(СтруктураПодсказки));

КонецПроцедуры

Процедура РедакторHTML_ПередПоказомСигнатуры(НомерПараметра, ИмяМетодаОтРедактора, НомерСигнатуры, Триггер) Экспорт 
	
	Если РазрешеноСобытиеПередПоказомАвтодополнения = Ложь Или НомерСигнатуры > 0 Тогда
		// https://github.com/salexdv/bsl_console/issues/182
		РазрешеноСобытиеПередПоказомАвтодополнения = Истина;
		Возврат;
	КонецЕсли; 
	Если Триггер <> Неопределено И Не АвтоматическаяПодсказкаПоВызовуМетода() Тогда
		Возврат;
	КонецЕсли;
	#Если Сервер И Не Сервер Тогда
		ПолеТекста = Обработки.ирОболочкаПолеТекста.Создать();
	#КонецЕсли
	РедакторHTML = ПолеТекста.РедакторHTML();
	//РедакторHTML.hideSignatureList();
	Если Не ЛиДоступноОткрытиеСвободнойФормы() Тогда 
		КончитьОбработкуКоманды();
		ФормаВладелец.КлсПолеТекстаПрограммыОбновитьКонтекст(ЭтотОбъект);
		СтруктураПодсказки = СтруктураПодсказкиМетода(, Триггер <> Неопределено);
		Если СтруктураПодсказки.Количество() = 0 Тогда
			Возврат;
		КонецЕсли;
		ВариантыСинтаксиса = Новый Соответствие;
		//ВариантыСинтаксиса.Вставить(ирОбщий.ПоследнийФрагментЛкс(ИмяМетодаОтРедактора, " "), СтруктураПодсказки); // В какой то версии перестало работать после точки https://github.com/salexdv/bsl_console/issues/343
		ВариантыСинтаксиса.Вставить(ирОбщий.ПервыйФрагментЛкс(мВызовМетода, "("), СтруктураПодсказки);
		РедакторHTML.setCustomSignatures(ирОбщий.ОбъектВСтрокуJSONЛкс(ВариантыСинтаксиса));
		//РедакторHTML.enableBeforeShowSuggestEvent(Ложь);
		РедакторHTML.setOption("generateBeforeShowSuggestEvent", Ложь);
		РазрешеноСобытиеПередПоказомАвтодополнения = Ложь;
		РедакторHTML.triggerSigHelp();
		//РедакторHTML.enableBeforeShowSuggestEvent(Истина);
		РедакторHTML.setOption("generateBeforeShowSuggestEvent", Истина);
		//ИмяМетодаОтРедактора = ФормаВызовМетода.ИмяМетода;
		//НомерПараметра = мНомерПараметра - 1;
	КонецЕсли;

КонецПроцедуры

Функция СтруктураПодсказкиМетода(Знач ПараметрПостояннаяСтруктураТипа = Неопределено, Знач ТолькоПолезноеОписание = Истина, Знач ДляСпискаАвтодополнения = Ложь, выхЕстьПараметры = Ложь)
	
	СтруктураПодсказки = Новый Массив;
	ФормаВызовМетода = ФормаВызовМетода();
	ФормаВызовМетода.ПараметрПостояннаяСтруктураТипа = ПараметрПостояннаяСтруктураТипа;
	ФормаВызовМетода.ОбновитьИлиЗакрытьФорму(, Истина);
	Если Не ФормаВызовМетода.ЕстьПолезнаяИнформация И ТолькоПолезноеОписание Тогда
		Возврат СтруктураПодсказки;
	КонецЕсли; 
	Для ИндексВарианта = 0 По ФормаВызовМетода.ВариантыСинтаксиса.Количество() - 1 Цикл
		Если Истина
			И ФормаВызовМетода.ВариантыСинтаксиса.Количество() > 1 
		Тогда
			ФормаВызовМетода.УстановитьВариантСинтаксисаПоИндексу(ИндексВарианта);
		КонецЕсли; 
		ПодсказкаСлова = Новый Структура();
		ПараметрыМетода = Новый Массив;
		КраткиеОписанияПараметров = Новый Массив;
		Для Каждого СтрокаПараметра Из ФормаВызовМетода.ТаблицаПараметров Цикл
			ЛиНеОбязательный = ФормаВызовМетода.ЛиНеОбязательныйПараметр(СтрокаПараметра);
			СтруктураПараметра = Новый Структура();
			КраткоеПредставлениеПараметра = "" 
			//+ ?(СтрокаПараметра.Знач = "Знач", "`", СтрокаПараметра.Знач) 
			+ СтрокаПараметра.Имя 
			+ ?(ЛиНеОбязательный, "?", "");
			// Мало пользы, лишние неудобства при поиске нужного параметра. Поэтому пока отключено
			//Если ЗначениеЗаполнено(СтрЗаменить(СтрокаПараметра.ТипЗначения, "?", "")) Тогда
			//	КраткоеПредставлениеПараметра = КраткоеПредставлениеПараметра + " [" + ирОбщий.ПредставлениеЗначенияСОграничениемДлиныЛкс(СокрЛП(СтрокаПараметра.ТипЗначения), 20) + "]";
			//КонецЕсли; 
			КраткиеОписанияПараметров.Добавить(КраткоеПредставлениеПараметра);
			СтруктураПараметра.Вставить("label", КраткоеПредставлениеПараметра);
			ОписаниеПараметра = 
			"Обяз.: " + ?(Не ЛиНеОбязательный, "Да", "Нет, " + СтрокаПараметра.Значение) + ";  Возвр.: " + ?(Не ЗначениеЗаполнено(СтрокаПараметра.Знач), "?", ?(СтрокаПараметра.Знач = "Знач", "Нет", "Да")) + "
			|Тип: " + ирОбщий.ПредставлениеЗначенияСОграничениемДлиныЛкс(СокрЛП(СтрокаПараметра.ТипЗначения), 200) + ".";
			Если ЗначениеЗаполнено(СтрокаПараметра.Описание) Тогда
				ОписаниеПараметра = ОписаниеПараметра + "
				|> " + СтрокаПараметра.Описание;
			КонецЕсли; 
			СтруктураПараметра.Вставить("documentation", ОписаниеПараметра);
			ПараметрыМетода.Добавить(СтруктураПараметра);
			выхЕстьПараметры = Истина;
		КонецЦикла;
		ПредставлениеМетода = "";
		Если Не ДляСпискаАвтодополнения Тогда
			ПредставлениеМетода = ПредставлениеМетода + ирОбщий.ПредставлениеЗначенияСОграничениемДлиныЛкс(ФормаВызовМетода.ИмяМетода, 13);
		КонецЕсли; 
		ПредставлениеМетода = ПредставлениеМетода + "(" + ирОбщий.СтрСоединитьЛкс(КраткиеОписанияПараметров, ", ") + ")";
		Если ЗначениеЗаполнено(ФормаВызовМетода.ТипЗначенияМетода) Тогда
			Если Не ДляСпискаАвтодополнения Тогда
				ПредставлениеМетода = ПредставлениеМетода + " [" + ирОбщий.ПредставлениеЗначенияСОграничениемДлиныЛкс(СокрЛП(ФормаВызовМетода.ТипЗначенияМетода), 15) + "]";
			КонецЕсли; 
		КонецЕсли; 
		ПодсказкаСлова.Вставить("label", ПредставлениеМетода);
		ПодсказкаСлова.Вставить("parameters", ПараметрыМетода);
		ОписаниеМетода = "";
		Если ЗначениеЗаполнено(ФормаВызовМетода.ТекущийВариант) Тогда
			ОписаниеМетода = ОписаниеМетода + "Вариант: " + ФормаВызовМетода.ТекущийВариант + "." + Символы.ПС;
		КонецЕсли;
		ОписаниеМетода = ОписаниеМетода + ФормаВызовМетода.ОписаниеМетода;
		ПодсказкаСлова.Вставить("documentation", ОписаниеМетода);
		СтруктураПодсказки.Добавить(ПодсказкаСлова);
	КонецЦикла;
	Возврат СтруктураПодсказки;

КонецФункции
 
Процедура РедакторHTML_ПередПоказомАвтодополнения(Триггер, ПоследнееВыражение, ПоследнееСлово)  Экспорт 
	
	#Если Сервер И Не Сервер Тогда
		ПолеТекста = Обработки.ирОболочкаПолеТекста.Создать();
	#КонецЕсли
	РедакторHTML = ПолеТекста.РедакторHTML();
	//РедакторHTML.hideSuggestionsList();
	ПоказатьСписок = МожноПоказатьСписокСлов(Триггер, ПоследнееВыражение, ПоследнееСлово);
	//Сообщить(Триггер);
	Если ПоказатьСписок Тогда 
		Если Триггер = "backspace" Тогда
			//РедакторHTML.enableBeforeShowSuggestEvent(Ложь);
			РедакторHTML.setOption("generateBeforeShowSuggestEvent", Ложь);
			РедакторHTML.showPreviousCustomSuggestions();
			//РедакторHTML.enableBeforeShowSuggestEvent(Истина);
			РедакторHTML.setOption("generateBeforeShowSuggestEvent", Истина);
		Иначе
			ФормаВызовМетода = ФормаВызовМетода();
			Если ФормаВызовМетода.Открыта() Тогда
				ФормаВызовМетода.Закрыть();
			КонецЕсли; 
			КончитьОбработкуКоманды();
			ФормаВладелец.КлсПолеТекстаПрограммыОбновитьКонтекст(ЭтотОбъект);
			РазобратьТекущийКонтекст(,,,,, Истина);
			Если ЯзыкПрограммы = 0 И Триггер = """" Тогда
				ПоказатьСписок = мЭтоТекстовыйЛитерал;
			ИначеЕсли Истина
				И Триггер <> "space"
				И ЯзыкПрограммы = 1 
				И мЭтоОбъявлениеПсевдонима 
			Тогда
				ПоказатьСписок = Ложь;
			Иначе
				ПоказатьСписок = Не (мКонтекст = "" И Триггер = ".");
			КонецЕсли; 
			Если Не ПоказатьСписок Тогда 
				Возврат;
			КонецЕсли;
			//РедакторHTML.enableSuggestActivationEvent(Истина, Истина);  // Второй параметр включает отображение типов для всех слов списка автодополнения https://github.com/salexdv/bsl_console/issues/119
			РедакторHTML.setOption("generateSuggestActivationEvent", Истина);
			РедакторHTML.setOption("alwaysDisplaySuggestDetails", Истина);
			
			УспехЗаполнения = ЗаполнитьТаблицуСлов(,,, Триггер = "space", Ложь);
			Если Истина
				И УспехЗаполнения
				И (Ложь
					Или Триггер = "space"
					Или ТаблицаСлов.Количество() > 0)
			Тогда
				СтруктураПодсказки = Новый Массив;
				КодыТиповСлов = Новый Структура;
				СоответствиеТипаСлова();
				Для Каждого СтрокаСоответствия Из мСоответствиеТиповСловHTML Цикл
					Если Не ЗначениеЗаполнено(СтрокаСоответствия.Имя) Тогда
						Продолжить;
					КонецЕсли; 
					КодыТиповСлов.Вставить(СтрокаСоответствия.Имя, СоответствиеТипаСлова(СтрокаСоответствия.Имя).Код);
				КонецЦикла; 
				Для Каждого СтрокаСлова Из ТаблицаСлов Цикл
					ПодсказкаСлова = Новый Структура();
					ПодсказкаСлова.Вставить("name", СтрокаСлова.Слово);
					//ТекстВставки = СтрокаСлова.Слово;
					//ПодсказкаСлова.Вставить("text", ТекстВставки); // Закомментировал, т.к. пользы от этого нет, а вред есть https://github.com/salexdv/bsl_console/issues/171
					ПодсказкаСлова.Вставить("kind", КодыТиповСлов[СтрокаСлова.ТипСлова]);
					ПодсказкаСлова.Вставить("detail", СтрокаСлова.ТипЗначения);
					Если СтрокаСлова.ТипСлова = "Конструкция" Тогда
						ПодсказкаСлова.Вставить("sort", "-1"); // https://www.hostedredmine.com/issues/963233
					Иначе
						ПодсказкаСлова.Вставить("sort", XMLСтрока(-СтрокаСлова.Рейтинг));
					КонецЕсли;
					ПодсказкаСлова.Вставить("detail", СтрокаСлова.ТипЗначения);
					ПодсказкаСлова.Вставить("documentation", "_"); // Нужно чтобы окно детального описания открывалось
					СтруктураПодсказки.Добавить(ПодсказкаСлова);
				КонецЦикла;
				СтрокаСпискаАвтодополненияHTML = ирОбщий.ОбъектВСтрокуJSONЛкс(СтруктураПодсказки);
				Если СтрокаСпискаАвтодополненияHTML <> Неопределено Тогда
					РедакторHTML.setOption("showSnippetsOnCustomSuggestions", мСтруктураТипаКонтекста.ИмяОбщегоТипа = "Локальный"); // Штатные сниппеты https://github.com/salexdv/bsl_console/issues/200
					РедакторHTML.setOption("generateBeforeShowSuggestEvent", Ложь);
					РедакторHTML.showCustomSuggestions(СтрокаСпискаАвтодополненияHTML);
					РедакторHTML.setOption("generateBeforeShowSuggestEvent", Истина);
				КонецЕсли; 
			КонецЕсли;
		КонецЕсли; 
	КонецЕсли; 

КонецПроцедуры

//.
// Параметры:
//    Триггер - Строка - 
//    ПоследнееВыражение - Строка - 
//    ПоследнееСлово - Строка - 
// Возвращаемое значение:
//    Булево - 
Функция МожноПоказатьСписокСлов(Триггер, ПоследнееВыражение, ПоследнееСлово) Экспорт
	Последние2Символа = Прав(ПоследнееВыражение, 2);
	ПрефиксПараметра = мПараметрыДиалектаSQL.ПрефиксПараметра;
	ОтображатьСписок = Ложь
		Или Триггер = "space"
		Или (Истина
			И АвтоматическаяПодсказкаАвтодополненияHTML()
			И (Ложь
				Или Триггер = Неопределено // ввод буквы или после выбора слова списка вводом "."
				Или Триггер = "." И Последние2Символа <> ".."
				Или ЯзыкПрограммы <> 0 И Триггер = ПрефиксПараметра И Последние2Символа <> (ПрефиксПараметра + ПрефиксПараметра)
				Или ЯзыкПрограммы = 0 И Триггер = """" И Последние2Символа <> """"""
				Или ирОбщий.ЛиИмяПеременнойЛкс(Триггер) // Иначе слишком часто вызывается затратное обновление списка слов локального контекста
				Или ЯзыкПрограммы = 0 И ирОбщий.СтрокиРавныЛкс(ПоследнееСлово, "новый")
				Или ЯзыкПрограммы = 0 И ирОбщий.СтрокиРавныЛкс(ПоследнееСлово, "new")));
	Возврат ОтображатьСписок;
КонецФункции

Функция СоответствиеТипаСлова(Знач ВстроенныйТипСлова = "", Знач ИмяКлюча = "Имя")
	
	Если мСоответствиеТиповСловHTML = Неопределено Тогда
		мСоответствиеТиповСловHTML = ирОбщий.ТаблицаЗначенийИзТабличногоДокументаЛкс(ПолучитьМакет("ТипыСловHTML"));
		#Если Сервер И Не Сервер Тогда
			мСоответствиеТиповСловHTML = Новый ТаблицаЗначений;
		#КонецЕсли
		мСоответствиеТиповСловHTML.Колонки.Добавить("НКод");
		мСоответствиеТиповСловHTML.Индексы.Добавить("Имя");
		мСоответствиеТиповСловHTML.Индексы.Добавить("НКод");
		Для Каждого СтрокаТЗ Из мСоответствиеТиповСловHTML Цикл
			СтрокаТЗ.НКод = НРег(СтрокаТЗ.Код);
		КонецЦикла;
	КонецЕсли;
	НайденнаяСтрока = мСоответствиеТиповСловHTML.Найти(ВстроенныйТипСлова, ИмяКлюча);
	//Если НайденнаяСтрока = Неопределено Тогда
	//	НайденнаяСтрока = мСоответствиеТиповСловHTML[0];
	//КонецЕсли;
	Возврат НайденнаяСтрока;

КонецФункции

Процедура РедакторHTML_ПриВыбореСтрокиАвтодополнения(Триггер, ПоследнееВыражение, ВыбранноеСлово, ТипСловаHTML, ТекстВставки, ПоследнееСлово) 
	
	Если ирОбщий.СтрНачинаетсяСЛкс(Триггер, "force-") Тогда
		ПараметрЗакрытия = Прав(Триггер, 1);
		Если Найти(ПоследнееВыражение, ".") > 0 Тогда
			ВыделенныйТекст(ПараметрЗакрытия);
			Возврат;
		КонецЕсли; 
	Иначе
		ПараметрЗакрытия = Истина;
	КонецЕсли; 
	#Если Сервер И Не Сервер Тогда
		ПолеТекста = Обработки.ирОболочкаПолеТекста.Создать();
	#КонецЕсли
	РедакторHTML = ПолеТекста.РедакторHTML();
	РедакторHTML.hideSuggestionsList();
	КончитьОбработкуКоманды();
	РазобратьТекущийКонтекст(,,,,, Истина);
	ОтборСлов = Новый Структура("Слово", ЧистоеСловоСпискаПодсказкиHTML(ВыбранноеСлово));
	ТипСлова = ТипСловаИзТипаСловаHTML(ТипСловаHTML);
	Если ТипСлова = "Шаблон" Тогда
		мНачальнаяКолонка = мНачальнаяКолонка - СтрДлина(ПоследнееСлово);
		УстановитьГраницыВыделения();
		РедакторHTML.insertSnippet(ТекстВставки);
		Возврат;
	КонецЕсли; 
	Если ЗначениеЗаполнено(ТипСлова)  Тогда
		ОтборСлов.Вставить("ТипСлова", ТипСлова);
	КонецЕсли; 
	НайденныеСтроки = ТаблицаСлов.НайтиСтроки(ОтборСлов);
	Если НайденныеСтроки.Количество() = 0 Тогда
		//Возврат;
		НоваяСтрока = ТаблицаСлов.Добавить();
		НоваяСтрока.Слово = ВыбранноеСлово;
		НоваяСтрока.ТипСлова = "Свойство";
		НайденныеСтроки = ирОбщий.ЗначенияВМассивЛкс(НоваяСтрока);
	КонецЕсли; 
	СтрокаТаблицыСлов = НайденныеСтроки[0];
	ВставитьВыбранноеСловоАвтодополнения(СтрокаТаблицыСлов,, ПараметрЗакрытия);
	Если ПараметрЗакрытия = "." Тогда
		РедакторHTML.triggerSuggestions();
	КонецЕсли; 
	Если мОткрытьСправкуПоПараметру = Истина Тогда
		Если ЛиДоступноОткрытиеСвободнойФормы() Тогда 
			ОткрытьСправкуПоПараметру(, Ложь); 
		Иначе
			РедакторHTML.triggerSigHelp();
		КонецЕсли;
	КонецЕсли; 

КонецПроцедуры

Функция ТипСловаИзТипаСловаHTML(Знач ТипСловаHTML)
	ТипСлова = СоответствиеТипаСлова(ирОбщий.ПоследнийФрагментЛкс(ТипСловаHTML, "-"), "НКод").Имя;
	Возврат ТипСлова;
КонецФункции

Функция ЛиДоступноОткрытиеСвободнойФормы() Экспорт
	
	Возврат Не (Ложь
		Или ирКэш.ЛиСеансТолстогоКлиентаУПЛкс() 
		Или ирОбщий.ЛиЕстьМодальныеГруппыЛкс());

КонецФункции

Процедура РедакторHTML_ОбработатьСобытие(Событие) Экспорт 
	//Сообщить("Отладка. " + Событие.event);
	Попытка
		Если Событие.event = "EVENT_BEFORE_SIGNATURE" Тогда
			РедакторHTML_ПередПоказомСигнатуры(Событие.params.activeParameter, Событие.params.word, Событие.params.activeSignature, Событие.params.triggerCharacter);
		ИначеЕсли Событие.event = "EVENT_ON_SELECT_SUGGEST_ROW" Тогда
			РедакторHTML_ПриВыбореСтрокиАвтодополнения(Событие.params.trigger, Событие.params.last_expression, Событие.params.selected, Событие.params.kind, Событие.params.insert_text, Событие.params.last_word);
		ИначеЕсли Ложь
			Или Событие.event = "EVENT_ON_ACTIVATE_SUGGEST_ROW"
			Или Событие.event = "EVENT_ON_DETAIL_SUGGEST_ROW"
		Тогда
			РедакторHTML_ПриАктивацииСтрокиАвтодополнения(Событие.params.trigger, Событие.params.focused, Событие.params.row_id, Событие.params.sideDetailIsOpened, Событие.params.kind);
		ИначеЕсли Событие.event = "EVENT_BEFORE_SHOW_SUGGEST" Тогда
			РедакторHTML_ПередПоказомАвтодополнения(Событие.params.trigger, Событие.params.last_expression, Событие.params.last_word);
		КонецЕсли;
	Исключение
		// Антибаг платформы https://www.hostedredmine.com/issues/962188
		ирОбщий.СообщитьЛкс(ОписаниеОшибки());
	КонецПопытки;
КонецПроцедуры

Процедура РедакторHTML_ПриАктивацииСтрокиАвтодополнения(Триггер, ТекущееСлово, НомерСлова, ЛиОтдельноеОписаниеАктивно, ТипСловаHTML) Экспорт 
	
	// Показывать надо обязательно каждый раз, т.к. редактор забывает предыдущие уточнения типа
	#Если Сервер И Не Сервер Тогда
		ПолеТекста = Обработки.ирОболочкаПолеТекста.Создать();
	#КонецЕсли
	ТипСлова = ТипСловаИзТипаСловаHTML(ТипСловаHTML);
	Если ТипСлова = "Шаблон" Тогда
		Возврат;
	КонецЕсли; 
	РедакторHTML = ПолеТекста.РедакторHTML();
	СтрокаТаблицыСлов = ТаблицаСлов.Найти(ЧистоеСловоСпискаПодсказкиHTML(ТекущееСлово), "Слово");
	Если СтрокаТаблицыСлов <> Неопределено Тогда
		ТаблицаТипов = УточнитьТипЗначенияВСтрокеТаблицыСлов(мСтруктураТипаКонтекста, СтрокаТаблицыСлов, ЛиОтдельноеОписаниеАктивно);
		СтруктураОписания = Новый Массив;
		Если мСтруктураТипаКонтекста.Конструктор Тогда
			ДетальноеОписаниеДляСписка = "";
		Иначе
			ДетальноеОписаниеДляСписка = СтрокаТаблицыСлов.ТипЗначения;
			Если ЗначениеЗаполнено(ДетальноеОписаниеДляСписка) Тогда
				СтруктураОписания.Добавить("> Тип: " + ДетальноеОписаниеДляСписка);
			КонецЕсли; 
		КонецЕсли; 
		Если ЛиОтдельноеОписаниеАктивно И ТаблицаТипов <> Неопределено Тогда 
			Если Ложь
				Или мСтруктураТипаКонтекста.Конструктор
				Или СтрокаТаблицыСлов.ТипСлова = "Метод" 
			Тогда
				Если мСтруктураТипаКонтекста.Конструктор Тогда
					СтруктураТипа = мПлатформа.НоваяСтруктураТипа();
					СтруктураТипа.ИмяОбщегоТипа = "Глобальный";
					ТаблицаТипов = мПлатформа.СловаКонтекстаПредопределенные(СтруктураТипа, СтрокаТаблицыСлов.Слово, "Конструктор",, ЯзыкПрограммы, Конфигурация)[0].ТаблицаТипов;
				КонецЕсли; 
				//ПараметрыМетода = мПлатформа.ПараметрыМетодаПлатформы(ТаблицаТипов[0]);
				СтруктураПодсказкиМетода = СтруктураПодсказкиМетода(ТаблицаТипов[0], Триггер <> Неопределено, Истина);
				Если СтруктураПодсказкиМетода.Количество() > 0 Тогда
					СтруктураОписания.Вставить(0, "> Параметры: " + СтруктураПодсказкиМетода[0].label);
					Если СтруктураПодсказкиМетода.Количество() > 1 Тогда
						СтруктураОписания.Вставить(0, "> Варианты: " + СтруктураПодсказкиМетода.Количество());
					КонецЕсли; 
					ОписаниеСлова = СтруктураПодсказкиМетода[0].documentation;
					Если ЗначениеЗаполнено(ОписаниеСлова) Тогда
						СтруктураОписания.Добавить("> Описание: " + ОписаниеСлова);
					КонецЕсли; 
				КонецЕсли; 
			КонецЕсли; 
		КонецЕсли; 
		СтруктураОписания.Добавить("> Определение: " + СтрокаТаблицыСлов.Определение);
		ДетальноеОписаниеОтдельное = ирОбщий.СтрСоединитьЛкс(СтруктураОписания, Символы.ПС);
		Если Триггер = "hover" Тогда
			РедакторHTML.setSuggestItemDetailById(НомерСлова, ДетальноеОписаниеДляСписка, ДетальноеОписаниеОтдельное);
		Иначе
			МаксВысотаТочек = 800;
			РедакторHTML.setActiveSuggestDetail(ДетальноеОписаниеДляСписка, ДетальноеОписаниеОтдельное, МаксВысотаТочек);
		КонецЕсли; 
	КонецЕсли; 

КонецПроцедуры

Процедура РедакторHTML_ОтключитьСочетанияПереключенияСигнатуры() Экспорт 
	
	#Если Сервер И Не Сервер Тогда
		ПолеТекста = Обработки.ирОболочкаПолеТекста.Создать();
	#КонецЕсли
	РедакторHTML = ПолеТекста.РедакторHTML();
	// https://github.com/salexdv/bsl_console/issues/130
	// Коды клавиш https://microsoft.github.io/monaco-editor/api/enums/monaco.keycode.html
	РедакторHTML.disableKeyBinding(512+16); // ALT(512)+ArrowUp(16)
	РедакторHTML.disableKeyBinding(512+18); // ALT(512)+ArrowDown(18)
	
КонецПроцедуры

Процедура РедакторHTML_ВключитьСочетанияПереключенияСигнатуры() Экспорт 
	
	#Если Сервер И Не Сервер Тогда
		ПолеТекста = Обработки.ирОболочкаПолеТекста.Создать();
	#КонецЕсли
	РедакторHTML = ПолеТекста.РедакторHTML();
	// https://github.com/salexdv/bsl_console/issues/130
	РедакторHTML.enableKeyBinding(528); // ALT(512)+ArrowUp(16)
	РедакторHTML.enableKeyBinding(530); // ALT(512)+ArrowDown(18)
	
КонецПроцедуры

Процедура РедакторHTML_ОбработатьКликНаГиперссылке(Событие, ФункцияПерейтиКОпределению = "", ФункцияВычислитьВыражение = "") Экспорт 
	#Если Сервер И Не Сервер Тогда
		ПолеТекста = Обработки.ирОболочкаПолеТекста.Создать();
	#КонецЕсли
	Если ПолеТекста.ОбработатьКликНаГиперссылке(Событие) Тогда 
		Возврат;
	КонецЕсли; 
	РедакторHTML = ПолеТекста.РедакторHTML();
	РедакторHTML.hideHoverList();
	ЗаголовокГиперссылки = Событие.params.label;
	ЗначениеГиперссылки = Событие.params.href;
	Если ЗаголовокГиперссылки = "Определение" Тогда
		Координаты = ирОбщий.СтрРазделитьЛкс(ЗначениеГиперссылки, ",");
		НомерСтроки = Число(Координаты[0]);
		НомерКолонки = Число(Координаты[1]);
		Если Ложь
			Или Не ЗначениеЗаполнено(ФункцияПерейтиКОпределению)
			Или Не Вычислить("ФормаВладелец." + ФункцияПерейтиКОпределению + "(НомерСтроки, НомерКолонки)") 
		Тогда 
			ПерейтиКОпределению(НомерСтроки, НомерКолонки);
		КонецЕсли; 
	ИначеЕсли ЗаголовокГиперссылки = "Знач" Тогда
		УспехВычисления = Истина;
		Если ЗначениеЗаполнено(ФункцияВычислитьВыражение) Тогда
			ЗначениеВыражения = Вычислить("ФормаВладелец." + ФункцияВычислитьВыражение + "(ЗначениеГиперссылки, УспехВычисления)");
		КонецЕсли;
		Если УспехВычисления Тогда
			ирКлиент.ОткрытьЗначениеЛкс(ЗначениеВыражения);
		КонецЕсли; 
	ИначеЕсли Ложь
		Или Лев(ЗаголовокГиперссылки, 1) = "["
		Или ЗаголовокГиперссылки = "Допустимые типы" 
	Тогда
		ОткрытьОписаниеТипаПоГиперссылке(ЗначениеГиперссылки);
	Иначе
		ОткрытьКонтекстнуюСправку(ЗначениеГиперссылки);
	КонецЕсли;
КонецПроцедуры

Процедура КомандаРедактораHTML(Команда)
	#Если Сервер И Не Сервер Тогда
		ПолеТекста = Обработки.ирОболочкаПолеТекста.Создать();
	#КонецЕсли
	РедакторHTML = ПолеТекста.РедакторHTML();
	РедакторHTML.editor.trigger("", Команда);
КонецПроцедуры

Процедура ЗаменитьВхожденияHTML()
	КомандаРедактораHTML("editor.action.changeAll");
КонецПроцедуры

Процедура СочетанияКлавишHTML()
	ирКлиент.ОткрытьТекстЛкс(ПолучитьМакет("СочетанияКлавишHTML").ПолучитьТекст(), "Сочетания клавиш HTML редактора", "Обычный", Истина, "СочетанияКлавишHTML");
КонецПроцедуры

Процедура ОткрытьКонструкторФорматнойСтроки(ФорматнаяСтрока)
	
	Конструктор = Новый КонструкторФорматнойСтроки();
	Попытка
		Конструктор.Текст = ФорматнаяСтрока;
	Исключение
		Инфо = ИнформацияОбОшибке();
		ирОбщий.СообщитьЛкс("Ошибка в тексте форматной строки:" + Символы.ПС + Инфо.Причина.Описание);
		Возврат;
	КонецПопытки;
	Если Конструктор.ОткрытьМодально() Тогда
		Результат = Конструктор.Текст;
		Результат = СтрЗаменить(Результат, "'", "");
		Результат = """" + Результат + """";
		ВыделенныйТекст(Результат);
	КонецЕсли; 
	
КонецПроцедуры

Процедура КонструкторФорматнойСтроки()
	
	ФорматнаяСтрока = ВыделитьТекстовыйЛитерал();
	ОткрытьКонструкторФорматнойСтроки(ФорматнаяСтрока);
	
КонецПроцедуры

Процедура НайтиСледующееHTML()
	
	#Если Сервер И Не Сервер Тогда
		ПолеТекста = Обработки.ирОболочкаПолеТекста.Создать();
	#КонецЕсли
	РедакторHTML = ПолеТекста.РедакторHTML();
	РедакторHTML.nextMatch();

КонецПроцедуры

Процедура НайтиПредыдущееHTML()
	
	#Если Сервер И Не Сервер Тогда
		ПолеТекста = Обработки.ирОболочкаПолеТекста.Создать();
	#КонецЕсли
	РедакторHTML = ПолеТекста.РедакторHTML();
	РедакторHTML.previousMatch();
	
КонецПроцедуры

Процедура РедакторHTML_Перерисовать() Экспорт 
	#Если Сервер И Не Сервер Тогда
		ПолеТекста = Обработки.ирОболочкаПолеТекста.Создать();
	#КонецЕсли
	//ПолеТекста.Перерисовать();
	//ОбновитьПодсказкуПоВызовуМетода();
КонецПроцедуры

Процедура ПанельРедактораКодаПриСменеСтраницы(Знач ПанельРедактора, Знач Поле1, Знач Поле2, Знач ИсходныйТекст) Экспорт 
	
	Поле2 = ирКлиент.ОболочкаПоляТекстаЛкс(Поле2);
	Если Поле2.РедакторHTML() = Неопределено Тогда
		Возврат;
	КонецЕсли;
	Поле1 = ирКлиент.ОболочкаПоляТекстаЛкс(Поле1);
	ТекущаяСтраница = ПанельРедактора.ТекущаяСтраница;
	Если ТекущаяСтраница = ПанельРедактора.Страницы.РедакторHTML Тогда
		ЭтотОбъект.ПолеТекста = Поле2;
		ПолеТекста.ЗагрузитьСостояниеИзПоляТекстаЛкс(Поле1, ИсходныйТекст);
	Иначе
		ЭтотОбъект.ПолеТекста = Поле1;
		ПолеТекста.ЗагрузитьСостояниеИзПоляТекстаЛкс(Поле2, ИсходныйТекст);
	КонецЕсли;      

КонецПроцедуры

#КонецЕсли

// Добавляет правило вычисления типа значения функции.
// При вызове правила вычисляется "Правило(<СтрокаАргументов>)", а оно должно вернуть ТаблицаТипов.
//
// Параметры:
//  Слово        - Строка;
//  ТипСлова     - Строка - "Метод", "Свойство";
//  *ТипЗначения - ОписаниеТипов, *Неопределено;
//  *Метаданные  - Произвольный, *Неопределено;
//
Процедура ДобавитьПравилоВычисленияФункции(ИмяФункции, Правило, ТипКонтекста = "Локальный") Экспорт
	
	КлючСтроки = Новый Структура;
	КлючСтроки.Вставить("НСлово", Нрег(ИмяФункции));
	КлючСтроки.Вставить("ТипКонтекста", ТипКонтекста);
	НайденныеСтроки = мПравилаВычисленияФункций.НайтиСтроки(КлючСтроки);
	Если НайденныеСтроки.Количество() = 0 Тогда
		НоваяСтрока = мПравилаВычисленияФункций.Добавить();
	Иначе
		НоваяСтрока = НайденныеСтроки[0];
	КонецЕсли;
	ЗаполнитьЗначенияСвойств(НоваяСтрока, КлючСтроки);
	НоваяСтрока.Правило = Правило;
	НоваяСтрока.Слово = ИмяФункции;

КонецПроцедуры

//.
// Параметры:
//    ТекущееСлово - Строка, Строка(256) - 
//    РодительскаяСтруктураТипа - ? - 
// Возвращаемое значение:
//    СтрокаТаблицыЗначений - 
Функция НайтиПравилоВычисленияФункции(Знач ИмяМетода, Знач РодительскаяСтруктураТипа) Экспорт
	Если РодительскаяСтруктураТипа = Неопределено Тогда
		Возврат Неопределено;
	КонецЕсли;
	ТипКонтекста = РодительскаяСтруктураТипа.ИмяОбщегоТипа;
	Если Истина
		И ТипКонтекста = "ОбщийМодуль" 
		И ТипЗнч(РодительскаяСтруктураТипа.Метаданные) = Тип("ОбъектМетаданных")
	Тогда
		ТипКонтекста = ТипКонтекста + "." + РодительскаяСтруктураТипа.Метаданные.Имя;
	КонецЕсли;
	КлючСтроки = Новый Структура;
	КлючСтроки.Вставить("ТипКонтекста", ТипКонтекста);
	КлючСтроки.Вставить("НСлово", НРег(ИмяМетода));
	НайденныеСтроки = мПравилаВычисленияФункций.НайтиСтроки(КлючСтроки);
	Если НайденныеСтроки.Количество() = 0 Тогда
		КлючСтроки.ТипКонтекста = "*";   
		НайденныеСтроки = мПравилаВычисленияФункций.НайтиСтроки(КлючСтроки);
	КонецЕсли;
	ПравилоВычисленияФункции = Неопределено;
	Если НайденныеСтроки.Количество() > 0 Тогда
		ПравилоВычисленияФункции = НайденныеСтроки[0];
	КонецЕсли;
	Возврат ПравилоВычисленияФункции;
КонецФункции

Процедура УстановитьКонфигурациюМетаданных(пКонфигурация = Неопределено, пКонтекстВыполнения = Неопределено, Знач ДиалектSQL = Неопределено, РасширенноеПолучениеМетаданныхADO = Ложь) Экспорт

	//Если ЯзыкПрограммы = 1 Тогда
		Если ДиалектSQL = Неопределено Тогда
			Если пКонфигурация <> Неопределено Тогда
				ЭтотОбъект.Конфигурация = пКонфигурация;
			Иначе
				ЭтотОбъект.Конфигурация = мПлатформа.мМетаданные;
			КонецЕсли; 
			Если ТипЗнч(Конфигурация) = Тип("ОбъектМетаданныхКонфигурация") Тогда
				ЭтотОбъект.мДиалектSQL = "1С";
			Иначе
				//! Конфигурация = Новый COMОбъект("ADODB.Connection");
				ЭтотОбъект.мДиалектSQL = "MSSQL"; 
				Попытка
					Пустышка = Конфигурация.Provider;  
				Исключение
					Пустышка = Неопределено;
				КонецПопытки;
				Если Пустышка <> Неопределено Тогда
					Если Конфигурация.State = 1 Тогда
						ДиалектSQL = Конфигурация.Properties("DBMS Name").Value;
					Иначе
						// Не меняем мДиалектSQL!
					КонецЕсли; 
				Иначе
					ДиалектSQL = "WQL";
				КонецЕсли; 
			КонецЕсли; 
		Иначе
			Если ирОбщий.СтрокиРавныЛкс(ДиалектSQL, "1С") Тогда
				ЭтотОбъект.Конфигурация = мПлатформа.мМетаданные;
			Иначе
				ЭтотОбъект.Конфигурация = пКонфигурация;
			КонецЕсли; 
		КонецЕсли;
		Если мДиалектыSQL = Неопределено Тогда
			Если мПлатформа.мДиалектыSQL = Неопределено Тогда
				мПлатформа.мДиалектыSQL = ирОбщий.ТаблицаЗначенийИзТабличногоДокументаЛкс(ПолучитьМакет("ДиалектыSQL"),,, Ложь, Истина);
			КонецЕсли; 
			ЭтотОбъект.мДиалектыSQL = мПлатформа.мДиалектыSQL;
		КонецЕсли; 
		Если мДиалектыSQL.Найти(ДиалектSQL, "Диалект") <> Неопределено Тогда 
			ЭтотОбъект.мДиалектSQL = ДиалектSQL;
		КонецЕсли; 
		ЭтотОбъект.мПараметрыДиалектаSQL = мДиалектыSQL.Найти(мДиалектSQL, "Диалект");
		ЭтотОбъект.мРасширенноеПолучениеМетаданныхADO = РасширенноеПолучениеМетаданныхADO = Истина;
	//Иначе
	//	Если пКонфигурация <> Неопределено Тогда
	//		ЭтотОбъект.Конфигурация = пКонфигурация;
	//	Иначе
	//		ЭтотОбъект.Конфигурация = мПлатформа.мМетаданные;
	//	КонецЕсли; 
	//КонецЕсли;
	
	//Если ирОбщий.СтрокиРавныЛкс(мДиалектSQL, "1С") Тогда
	//	мДоступныеТаблицыПолучены = Истина;
	//ИначеЕсли ирОбщий.СтрокиРавныЛкс(мДиалектSQL, "WQL") Тогда
	//	//ЗаполнитьДоступныеТаблицыWQL(); // Слишком долго
	//	мДоступныеТаблицыПолучены = Истина;
	//Иначе
	//	мДоступныеТаблицыПолучены = Ложь;
	//КонецЕсли; 
	ЭтотОбъект.КонтекстВыполнения = пКонтекстВыполнения;

КонецПроцедуры

// Очишает таблицу слов локального контекста.
//
// Параметры:
//  Нет.
//
Процедура ОчиститьТаблицуСловЛокальногоКонтекста() Экспорт
	Если Ложь
		Или мМодульМетаданных = Неопределено // Для консоли кода без режима "Модуль"
		Или мМодульМетаданных.Имя <> мПлатформа.ИмяДинамическогоМодуля()
	Тогда
		Возврат;
	КонецЕсли;
	ОчиститьТаблицуСловЛокальногоКонтекстаПоТипуСлова();
	ОчиститьТаблицуСловЛокальногоКонтекстаПоТипуСлова("Метод");
КонецПроцедуры

Процедура ОчиститьТаблицуСловЛокальногоКонтекстаПоТипуСлова(Знач ТипСлова = "Свойство")
	ОтборСтрок = Новый Структура("ПозицияСОписанием", 0);
	ТаблицаЛокальногоКонтекста = ТаблицаЛокальногоКонтекста(ТипСлова);
	ВыбранныеСтроки = ТаблицаЛокальногоКонтекста.НайтиСтроки(ОтборСтрок);
	Для Каждого ВыбраннаяСтрока Из ВыбранныеСтроки Цикл
		ВыбраннаяСтрока.ТаблицаТипов = Неопределено; // Мультиметка4529884 Разрываем циклические ссылки во вложенной колонке СтрокаОписания. Возможно уже не нужно. Очищает колонки в переменной СтрокаРезультата обрабочика консоли запросов
		ТаблицаЛокальногоКонтекста.Удалить(ВыбраннаяСтрока);
	КонецЦикла;
КонецПроцедуры

Функция ПроверитьТекстИВернутьОшибку(ТекстДляПроверки = Неопределено, СтартоваяСтрока = 0, СтартоваяКолонка = 0, Контекст = Неопределено, СамаяВложеннаяПричина = Ложь) Экспорт

	#Если Сервер И Не Сервер Тогда
		мПлатформа = Обработки.ирПлатформа.Создать();
	#КонецЕсли
	ТекстИнициализации = "";
	Если ЯзыкПрограммы = 0 Тогда 
		Если мМодульМетаданных <> Неопределено Тогда
			Для Каждого ЛокальноеСлово Из мМодульМетаданных.Переменные Цикл
				Если ТипТекста = "Алгоритм" Тогда
					ТекстИнициализации = ЛокальноеСлово.Имя + " = 0; " + ТекстИнициализации;
				КонецЕсли;
			КонецЦикла;
		КонецЕсли;
		Для Каждого СтрокаПараметра Из Параметры Цикл
			Если ТипТекста = "Алгоритм" И СтрокаПараметра.Вход Тогда
				ТекстИнициализации = СтрокаПараметра.Имя + " = 0; " + ТекстИнициализации;
			КонецЕсли;
		КонецЦикла;
	КонецЕсли; 

	Если ТекстДляПроверки = Неопределено Тогда
		ТекстДляПроверки = ПолеТекста.ПолучитьТекст();
		Если Не ЭтоМодуль И мМодульМетаданных <> Неопределено И мМодульМетаданных.Методы.Количество() > 0 Тогда
			ВызватьИсключение "Текст программы не допускает определения методов";
		КонецЕсли;
	КонецЕсли; 
	
	СтартоваяСтрока = 0;
	СтартоваяКолонка = 0;
	Если ЯзыкПрограммы = 1 Тогда
		ТекстЗапроса = ТекстДляПроверки;
		Если ТекстЗапроса <> "" Тогда
			Если ТипТекста = "Выражение" Тогда
				лКонтекстВыполнения = КонтекстВыполнения;
				лМетодВыполнения = МетодВыполнения;
				Попытка
					ИнформацияОбОшибке = мПлатформа.ВыполнитьПрограммныйКодВКонтексте(лКонтекстВыполнения, лМетодВыполнения, ТекстЗапроса, Истина);
				Исключение
					ИнформацияОбОшибке = ИнформацияОбОшибке();
				КонецПопытки;
				СтартоваяСтрока = -1;
			Иначе
				Если мДиалектSQL <> "1С" Тогда
					РезультатРазбора = Ложь;
					#Если Клиент Тогда
					РезультатРазбора = ЗагрузитьТекстВКонструктор(ТекстЗапроса);
					#КонецЕсли
					Если Не РезультатРазбора Тогда
						ИнформацияОбОшибке = 1;
					КонецЕсли; 
				Иначе
					Если ТипЗнч(КонтекстВыполнения) = Тип("Запрос") Тогда
						ПроверочныйЗапрос = Новый Запрос;
						ПроверочныйЗапрос.МенеджерВременныхТаблиц = КонтекстВыполнения.МенеджерВременныхТаблиц;
						ПроверочныйЗапрос.Текст = ТекстЗапроса;
						Попытка
							ПроверочныйЗапрос.НайтиПараметры();
						Исключение
							ИнформацияОбОшибке = ИнформацияОбОшибке();
						КонецПопытки;
					Иначе
						КонструкторЗапроса = Новый КонструкторЗапроса;
						КонструкторЗапроса.РежимКомпоновкиДанных = РежимКомпоновкиДанных;
						Попытка
							КонструкторЗапроса.Текст = ТекстЗапроса;
						Исключение
							ИнформацияОбОшибке = ИнформацияОбОшибке();
						КонецПопытки;
					КонецЕсли; 
				КонецЕсли;
			КонецЕсли; 
		КонецЕсли;
	ИначеЕсли ЯзыкПрограммы = 0 Тогда 
		ТекстДляВыполнения = ТекстИнициализации;
		Если ТипТекста = "Выражение" Тогда
			Если ТекстДляПроверки = "" Тогда
				ТекстДляПроверки = 0;
			КонецЕсли;
			ТекстДляВыполнения = ТекстДляВыполнения + "?(Истина, 0, " + Символы.ПС + ТекстДляПроверки + Символы.ПС + ")";
		Иначе
			//ТекстДляВыполнения = ТекстДляВыполнения + "Если Ложь Тогда " + Символы.ПС + ТекстДляПроверки + Символы.ПС + " КонецЕсли"; // Заменено 06.12.2011
			ТекстДляВыполнения = "Если Ложь Тогда Попытка " + ТекстДляВыполнения + Символы.ПС + ТекстДляПроверки + Символы.ПС + " Исключение КонецПопытки КонецЕсли";
		КонецЕсли;
		Если Нрег(Контекст) = Нрег("Сервер") Тогда
			лКонтекстВыполнения = ирСервер;
			лМетодВыполнения = "ВыполнитьАлгоритм";
		ИначеЕсли Контекст <> Неопределено Тогда 
			лКонтекстВыполнения = Контекст;
			лМетодВыполнения = "ВыполнитьАлгоритм";
		Иначе
			лКонтекстВыполнения = КонтекстВыполнения;
			лМетодВыполнения = МетодВыполнения;
		КонецЕсли; 
		Попытка
			ИнформацияОбОшибке = мПлатформа.ВыполнитьПрограммныйКодВКонтексте(лКонтекстВыполнения, лМетодВыполнения, ТекстДляВыполнения, Истина);
		Исключение
			ИнформацияОбОшибке = ИнформацияОбОшибке();
		КонецПопытки;
		СтартоваяСтрока = - 1;
	ИначеЕсли ЯзыкПрограммы = 2 Тогда
		лКонтекстВыполнения = КонтекстВыполнения;
		лМетодВыполнения = МетодВыполнения;
		Попытка
			ИнформацияОбОшибке = мПлатформа.ВыполнитьПрограммныйКодВКонтексте(лКонтекстВыполнения, лМетодВыполнения, ТекстДляПроверки, Истина);
		Исключение
			ИнформацияОбОшибке = ИнформацияОбОшибке();
		КонецПопытки;
	КонецЕсли;
	Если СамаяВложеннаяПричина И ИнформацияОбОшибке <> Неопределено Тогда
		#Если Сервер И Не Сервер Тогда
			ИнформацияОбОшибке = ИнформацияОбОшибке();
		#КонецЕсли
		Пока ИнформацияОбОшибке.Причина <> Неопределено Цикл
			ИнформацияОбОшибке = ИнформацияОбОшибке.Причина;
		КонецЦикла;
	КонецЕсли; 
	Возврат ИнформацияОбОшибке;

КонецФункции

// Выполняет проверку синтаксиса программного кода
//
// Параметры:
//  *СообщатьОбУспешнойПроверке - Булево, *Ложь;
//  *ТекстДляПроверки - Строка, *Неопределено - проверяемый текст (используется весь текст или этот).
//
// Возвращаемое значение:
//  Булево - Истина если нет ошибок.
//
Функция ПроверитьПрограммныйКод(СообщатьОбУспешнойПроверке = Ложь, ТекстДляПроверки = Неопределено, Контекст = Неопределено) Экспорт
	
	СтартоваяСтрока = 0;
	СтартоваяКолонка = 0;
	ИнформацияОбОшибке = ПроверитьТекстИВернутьОшибку(ТекстДляПроверки, СтартоваяСтрока, СтартоваяКолонка, Контекст);
	Если ЗначениеЗаполнено(Контекст) Тогда
		ПредставлениеКонтекста = " (Проверка " + Контекст + ")";
	КонецЕсли; 
	Если ИнформацияОбОшибке <> Неопределено Тогда
		Если ТипЗнч(ИнформацияОбОшибке) = Тип("ИнформацияОбОшибке") Тогда
			#Если Клиент Тогда
			Если ФормаВладелец <> Неопределено Тогда
				ФормаВладелец.ТекущийЭлемент = ПолеТекста.ЭлементФормы;
			КонецЕсли; 
			ирКлиент.ПоказатьОшибкуВТекстеПрограммыЛкс(ПолеТекста, СтартоваяСтрока, СтартоваяКолонка, ЯзыкПрограммы, , ИнформацияОбОшибке,, ПредставлениеКонтекста);
			#КонецЕсли
		Иначе
			// Ошибка обработана и отображена ранее
		КонецЕсли; 
	Иначе
		Если СообщатьОбУспешнойПроверке Тогда
			СообщитьОбУспешнойПроверке(ПредставлениеКонтекста);
		КонецЕсли;
	КонецЕсли;
	Успех = ИнформацияОбОшибке = Неопределено;
	Если СообщатьОбУспешнойПроверке И Успех И ЯзыкПрограммы = 0 Тогда
		#Если Клиент Тогда
		ПроверитьВыраженияТекста(,, Истина, Истина);
		#КонецЕсли
	КонецЕсли;
	Возврат Успех;
	
КонецФункции       

Процедура СообщитьОбУспешнойПроверке(Знач ПредставлениеКонтекста = "") Экспорт 
	
	ирОбщий.СообщитьСУчетомМодальностиЛкс(ирОбщий.ПредставлениеИзИдентификатораЛкс(ПолеТекста.ЭлементФормы.Имя) 
		+ ПредставлениеКонтекста + ": Синтаксических ошибок не обнаружено!");

КонецПроцедуры

Процедура СброситьРезультатРазбораПозицииВТексте()
	
	мНомерПараметра = 0;
	мНачалоКонтекста = "";
	мНачалоСлова = "";
	мКонецКонтекста = "";
	выхЕстьТочкаСправа = Ложь;
	мРодительскийКонтекст = "";
	мКонтекст = "";
	мЭтоТекстовыйЛитерал = Ложь;
	мЭтоОбъявлениеПсевдонима = Ложь;
	мЭтоКонструктор = Ложь;
	мАргументы = "";
	мПервыйФактическийПараметр = "";
	мФактическиеПараметры = Новый Массив;
	//КончитьОбработкуКоманды(); // Нельзя, т.к. сломается вычисление в окне "Выражение"

КонецПроцедуры

Процедура ПродолжитьОбработкуКоманды() Экспорт 
	мРазбиратьКонтекст = Ложь;
КонецПроцедуры

// Вызывается в конце обработки команды.
//
// Параметры:
//  Нет.
//
Процедура КончитьОбработкуКоманды() Экспорт
	мРазбиратьКонтекст = Истина;
КонецПроцедуры

// Комментарии заливает только если в строке левее нет инструкций.
//
// Параметры:
//  Текст								 - 	 - Строка;
//  СимволЗамена						 - 	 - Строка.
//  ЗалитьСтроковыеЛитералы				 - 	 - 
//  ЗалитьУсловия						 - Булево - очень долго, вроде бы уже не применяется
//  ЗалитьКомментарииВСмешанныхСтроках	 - Булево - 
// 
// Возвращаемое значение:
//  Строка - .
//
Функция ЗалитьКомментарииИСтроковыеЛитералы(Знач Текст, СимволЗамена = " ", Знач ЗалитьСтроковыеЛитералы = Ложь, Знач ЗалитьУсловия = Ложь, Знач ЗалитьКомментарииВСмешанныхСтроках = Ложь) Экспорт 

	Если Не ЗначениеЗаполнено(Текст) Тогда
		Возврат Текст;
	КонецЕсли;
	мРегВыражение.Global = Истина;
	мРегВыражение.Multiline = Ложь;
	
	// Количество символов в тексте меняется, но позиции строк сохраняются
	Если Ложь
		Или ЯзыкПрограммы = 1
		Или ЯзыкПрограммы = 2
	Тогда
		////RegExp.Pattern = "(""" + шИмя+ "(?:\." + шИмя + ")*"")|(" + "//(:)?[^\n]*" + ")|(" + шЛитералВЗапросе   + ")|(.|\n|\r)";
		//RegExp.Pattern = "(""" + шИмя+ "(?:\." + шИмя + ")*"")|(?:" + "//:([^\n]*)" + ")|(?:" + "//[^\n]*" + ")|(" + шЛитералВЗапросе + ")|(.|\n|\r)";
		мРегВыражение.Pattern = "(""" + шИмя+ "(?:\." + шИмя + ")*"")|(?:" + "//:([^\n]*)" + ")|(?:" + "//[^\n]*" + ")|(" + шЛитералВЗапросе + ")|([\s\S])";
		ШаблонЗамены = "$1$2$3$4";
	ИначеЕсли ЯзыкПрограммы = 0 Тогда
		//RegExp.Pattern = "(""" + шИмя+ "(?:\." + шИмя + ")*"")|(" + "//(:)?[^\n]*" + ")|(" + шЛитералПрограммы + ")|(.|\n|\r)";
		шОднострочнаяСтрокаПрограммыСКавычки = """(?:(?:"""")|[^""\n])*""?"; 
		шОднострочнаяСтрокаПрограммыСЧерты = "(?:(\n|^)\s*\|(?:(?:"""")|[^""\n])*""?)";
		//	+ шОднострочнаяСтрокаПрограммыСКавычки + "|" + шОднострочнаяСтрокаПрограммыСЧерты + "|(.|\n|\r)";
		мРегВыражение.Pattern = "(""" + шИмя + "(?:\.[" + шБуква + "\d]+)*"")" // имена ProgId от COM объектов бывают "Forms.TextBox.1"
			+ "|(""(?:" + шИмя + "\s*,\s*)*" + шИмя + """)" // создание структуры
			+ "|" + ?(ЗалитьКомментарииВСмешанныхСтроках, "", мПлатформа.шПустоеНачалоСтроки) + "//[^\n]*" // комментарии с начала строки
			+ "|#[^\n]*" // Инструкции препроцессора
			;  
		ШаблонЗамены = "$1$2$3";
		Если ЗалитьСтроковыеЛитералы Тогда
			мРегВыражение.Pattern = мРегВыражение.Pattern  + "|" + шОднострочнаяСтрокаПрограммыСКавычки + "|" + шОднострочнаяСтрокаПрограммыСЧерты + "";
			ШаблонЗамены = ШаблонЗамены + "$4";
		Иначе
			// http://www.hostedredmine.com/issues/885452
		КонецЕсли; 
		мРегВыражение.Pattern = мРегВыражение.Pattern + "|([\s\S])";
	КонецЕсли;
	ЗалитыйТекст = мРегВыражение.Заменить(Текст, ШаблонЗамены);
	
	Если Истина 
		И мЯзыкПрограммы = 0
		И ЗалитьУсловия 
		И СтрДлина(ЗалитыйТекст) < 10000 // Долго на больших текстах!
	Тогда 
		// Заливаем условия, чтобы проверка равенства в них не считалась присвоением
		// В будущем можно отказаться от этого блока и собирать все возможные типы, а потом давать юзеру выбирать.
		мРегВыражение.Pattern = "(" + шЕсли + ")|(" + шПока + ")";
		ЗалитыйТекстОригинал = ЗалитыйТекст;
		Результат = мРегВыражение.НайтиВхождения(ЗалитыйТекстОригинал,, Истина);
		ЗалитыйТекст = Новый ЗаписьXML;
		ЗалитыйТекст.УстановитьСтроку("");
		ТекущаяПозицияВОригинале = 1;
		Для Каждого Match Из Результат Цикл
			НайденныйТекст = Неопределено;
			НачалоТокена = "";
			Если Match.SubMatches(0) <> Неопределено Тогда
				НайденныйТекст = Match.SubMatches(0);
				НачалоТокена = Match.SubMatches(1);
			ИначеЕсли Match.SubMatches(3) <> Неопределено Тогда
				НайденныйТекст = Match.SubMatches(3);
				НачалоТокена = Match.SubMatches(4);
			КонецЕсли;
			ЗалитыйТекст.ЗаписатьБезОбработки(Сред(ЗалитыйТекстОригинал, ТекущаяПозицияВОригинале, Match.FirstIndex + 1 - ТекущаяПозицияВОригинале));
			ЗалитыйТекст.ЗаписатьБезОбработки(НачалоТокена + мРегВыражение.Заменить(Сред(НайденныйТекст, 1 + СтрДлина(НачалоТокена), СтрДлина(НайденныйТекст) - СтрДлина(НачалоТокена)), СимволЗамена));
			ТекущаяПозицияВОригинале = Match.FirstIndex + 1 + СтрДлина(Match.Value); 
		КонецЦикла;
		ЗалитыйТекст.ЗаписатьБезОбработки(Сред(ЗалитыйТекстОригинал, ТекущаяПозицияВОригинале));
		ЗалитыйТекст = ЗалитыйТекст.Закрыть();
	КонецЕсли; 
	Возврат ЗалитыйТекст;

КонецФункции

Процедура ЗаполнитьЛокальныеСвойстваИМетодыПоТексту(ОчиститьТаблицуСлов = Истина, Знач ВключатьКонструкции = Истина, УчитыватьРодительскийКонтекст = Ложь, ОбновитьТекстДляАнализа = Истина,
	ВключатьГлобальныйКонтекст = Ложь, Знач ТекстДляАнализа = "", Знач ТекстСинтаксическиКорректен = Ложь, Знач ТолькоСвойства = Ложь, Знач ЗаполнятьПоТексту = Истина) Экспорт 

	#Если Сервер И Не Сервер Тогда
		мПлатформа = Обработки.ирПлатформа.Создать();
		мРегВыражение = Обработки.ирОболочкаРегВыражение.Создать();
	#КонецЕсли
	Если ирОбщий.ПроверитьПлатформаНеWindowsЛкс(, "Заполнение параметров", Истина) Тогда
		Возврат;
	КонецЕсли; 
	Если Не ЗначениеЗаполнено(ТекстДляАнализа) Тогда
		Если Ложь
			Или ОбновитьТекстДляАнализа 
			Или мТекстБезТекстовыхЛитералов = ""
		Тогда
			Если ЗначениеЗаполнено(мТекстБлока) Тогда
				ТекстДляАнализа = мТекстБлока;          
			//Иначе
			//	ТекстДляАнализа = ПолеТекста.ПолучитьТекст(); // Опасно. На больших модулях между методами срабатывает.
			КонецЕсли;
		КонецЕсли;
	КонецЕсли; 
	Если ЗначениеЗаполнено(ТекстДляАнализа) Тогда
		Если мЯзыкПрограммы = 1 Тогда
			ТекстДляАнализа = СокрЛ(ТекстДляАнализа);
			Если Лев(ТекстДляАнализа, 1) = "|" Тогда 
				ТекстДляАнализа = """" + Символы.ПС + ТекстДляАнализа;
			КонецЕсли;
			Если Лев(ТекстДляАнализа, 1) = """" Тогда 
				ТекстДляАнализа = ирОбщий.ТекстИзВстроенногоЯзыкаЛкс(ТекстДляАнализа); // Мультиметка9017742
			КонецЕсли;
		КонецЕсли;
		мТекстБезТекстовыхЛитералов = ЗалитьКомментарииИСтроковыеЛитералы(ТекстДляАнализа,, Истина);
	ИначеЕсли ОбновитьТекстДляАнализа Тогда 
		мТекстБезТекстовыхЛитералов = ТекстДляАнализа;
	КонецЕсли; 

	Если ОчиститьТаблицуСлов Тогда
		ТаблицаСлов.Очистить();
	ИначеЕсли ВключатьГлобальныйКонтекст Тогда 
		ВызватьИсключение "Запрещенное сочетание параметров ОчиститьТаблицуСлов и ВключатьГлобальныйКонтекст"; 
	КонецЕсли;                        
	Если ВключатьГлобальныйКонтекст Тогда
		// 23мс
		СтруктураТипа = мПлатформа.НоваяСтруктураТипа();
		СтруктураТипа.ИмяОбщегоТипа = "Глобальный";
		СтруктураТипа.Метаданные = Метаданные;
		ТаблицаГлобальногоКонтекста = мПлатформа.ТаблицаСловИзСтруктурыТипа(СтруктураТипа,, Конфигурация,, Ложь,,, мФлагиКомпиляции,,,,,,, БазовоеРасширениеКонфигурации());
		ТаблицаСлов.Загрузить(ТаблицаГлобальногоКонтекста);
		ирОбщий.ОбновитьКопиюКолонкиВНижнемРегистреЛкс(ТаблицаСлов, "Слово", "НСлово");
		ТаблицаГлобальногоКонтекста = Неопределено;
	КонецЕсли;
	
	ЛитералыЗначения = мПлатформа.ЛитералыЗначенияВсехЯзыков1С();
	ЧастыеВстроенныеМетоды = Новый Массив;
	Если мЯзыкПрограммы = 0 Тогда
		КлючевыеСловаЯзыка = мПлатформа.КлючевыеСловаВстроенногоЯзыка().ВыгрузитьЗначения();
		КлючевыеСловаЯзыка.Добавить("Символы");
		ЧастыеВстроенныеМетоды.Добавить("Тип");
		ЧастыеВстроенныеМетоды.Добавить("ТипЗнч");
		ЧастыеВстроенныеМетоды.Добавить("СокрЛ");
		ЧастыеВстроенныеМетоды.Добавить("СокрЛП");
		ЧастыеВстроенныеМетоды.Добавить("Найти");
		ЧастыеВстроенныеМетоды.Добавить("Лев");
		ЧастыеВстроенныеМетоды.Добавить("Нрег");
		ЧастыеВстроенныеМетоды.Добавить("Прав");
		ЧастыеВстроенныеМетоды.Добавить("Сред");
		ЧастыеВстроенныеМетоды.Добавить("СтрДлина");
		ЧастыеВстроенныеМетоды.Добавить("ПустаяСтрока");
		ЧастыеВстроенныеМетоды.Добавить("Дата");
		ЧастыеВстроенныеМетоды.Добавить("Число");
		ЧастыеВстроенныеМетоды.Добавить("Мин");
		ЧастыеВстроенныеМетоды.Добавить("Макс");
		ЧастыеВстроенныеМетоды.Добавить("ЗначениеЗаполнено");
		ЧастыеВстроенныеМетоды.Добавить("ОписаниеТипов");
	ИначеЕсли мЯзыкПрограммы = 1 Тогда
		ВключаяРусские = ТипЗнч(Конфигурация) = Тип("ОбъектМетаданныхКонфигурация");
		КлючевыеСловаЯзыка = мПлатформа.КлючевыеСловаЯзыкаЗапросов(РежимКомпоновкиДанных, ВключаяРусские, Истина).ВыгрузитьЗначения();
	ИначеЕсли мЯзыкПрограммы = 2 Тогда
		//СписокСловЯзыка = мПлатформа.КлючевыеСловаЯзыкаЗапросов();
		КлючевыеСловаЯзыка = Новый Массив;
		КлючевыеСловаЯзыка.Добавить("РАЗЛИЧНЫЕ"); // Криво https://www.hostedredmine.com/issues/931487
	КонецЕсли;
	Если ВключатьКонструкции Тогда
		Для Каждого Слово Из КлючевыеСловаЯзыка Цикл
			НоваяСтрока = ТаблицаСлов.Добавить();
			НоваяСтрока.Слово = Слово;
			НоваяСтрока.НСлово = НРег(НоваяСтрока.Слово);
			НоваяСтрока.ТипСлова = "Конструкция";
			НоваяСтрока.Определение = "Предопределенный";
		КонецЦикла;                                      
		Для Каждого ЭлементСписка Из ЛитералыЗначения Цикл
			НоваяСтрока = ТаблицаСлов.Добавить();
			НоваяСтрока.Слово = ЭлементСписка.Значение;
			НоваяСтрока.НСлово = НРег(НоваяСтрока.Слово);
			НоваяСтрока.ТипЗначения = ЭлементСписка.Представление;
			НоваяСтрока.ТипСлова = "Свойство";
			НоваяСтрока.Определение = "Предопределенный";
		КонецЦикла;
	КонецЕсли;
	Если Не ЗаполнятьПоТексту Тогда
		Возврат;
	КонецЕсли;
	
	//Поиск использованных свойств и методов данного контекста.
	мРегВыражение.Global = Истина;
	Если Ложь
		Или Не УчитыватьРодительскийКонтекст
		Или мРодительскийКонтекст = ""
	Тогда
		шЛитералыЗначения = ирОбщий.СтрСоединитьЛкс(ЛитералыЗначения.ВыгрузитьЗначения(), "|");
		шКлючевыеСлова = ирОбщий.СтрСоединитьЛкс(КлючевыеСловаЯзыка, "|") + "|" + шЛитералыЗначения;
		шИмяСвойстваНеКлючевое = шПредИмяПрямое + "(?!(?:" + шКлючевыеСлова + ")[^?:\." + шБуква + "\d])(" + шИмя + ")";
		Если ТолькоСвойства Тогда
			Шаблон = "(ъъъ)|(ъъъ)";
		Иначе
			Если ЧастыеВстроенныеМетоды.Количество() > 0 Тогда
				шКлючевыеСлова = шКлючевыеСлова + "|" + ирОбщий.СтрСоединитьЛкс(ЧастыеВстроенныеМетоды, "|");
			КонецЕсли;
			шИмяМетодаНеКлючевое = шПредИмяПрямое + "(?!(?:" + шКлючевыеСлова + ")[^?:\." + шБуква + "\d])(" + шИмя + ")";
			Шаблон = "(?:" + шИмяМетодаНеКлючевое + "(?=\s*\())"
					+ "|(" + шПараметрЗапроса + ")";
		КонецЕсли;
		Шаблон = Шаблон + "|" + шИмяСвойстваНеКлючевое + "(?=(?:\.(?:" + шИмя + ")?)+|[^?:\(\." + шБуква + "\d]|$)";
		КоличествоПодгрупп = 3;
	Иначе
		шИмяНеКлючевое = шПредИмяПрямое + "(?:" + ирОбщий.ПодготовитьТекстДляРегВыраженияЛкс(мРодительскийКонтекст) + "\.(" + шИмя + ")"; 
		Если ТолькоСвойства Тогда
			Шаблон = "(ъъъ)";
		Иначе
			Шаблон = шИмяНеКлючевое + "(?=\s*\())";
		КонецЕсли;
		Шаблон = Шаблон + "|" + шИмяНеКлючевое + "(?=[^\(?:" + шБуква + "\d]|$))";
		КоличествоПодгрупп = 2;
	КонецЕсли;
	ТаблицаСловТЗ = ТаблицаСлов.Выгрузить(, "НСлово, ТипСлова, Частота");
	ТаблицаСловТЗ.Индексы.Добавить("НСлово");
	Если ЯзыкПрограммы = 0 Тогда
		мРегВыражение.Pattern = "(?:" + шЛитералПрограммы + "|" + шКомментарий + "|(?:Новый|New)\s+" + шИмя + ")";
	Иначе
		мРегВыражение.Pattern = "(?:" + шЛитералПрограммы + "|" + шКомментарий + ")";
	КонецЕсли;
	ВременныйТекст = мРегВыражение.Заменить(мТекстБезТекстовыхЛитералов, "");
	мРегВыражение.Pattern = Шаблон;
	Результат = мРегВыражение.НайтиВхождения(ВременныйТекст,, Истина);
	Счетчик = 0;
	_РежимОтладки = Ложь;
	Если _РежимОтладки Тогда // Можно менять на Истина в точке останова, например условием ирОбщий.Пр(_РежимОтладки, 1, 1)
		// Пассивный оригинал расположенного ниже однострочного кода. Выполняйте изменения синхронно в обоих вариантах.
		Для Каждого Match Из Результат Цикл
			Счетчик = Счетчик + 1;
			Если Счетчик = МаксСловНаходитьВТекстеМетода Тогда
				// Обрезка контекста для ускорения
				Прервать;
			КонецЕсли;
			Подгруппа1 = Match.SubMatches(0);
			Подгруппа2 = Match.SubMatches(1);
			Если КоличествоПодгрупп = 3 Тогда
				Подгруппа3 = Match.SubMatches(2);
			Иначе
				Подгруппа3 = Неопределено;
			КонецЕсли; 
			Если Подгруппа1 <> Неопределено Тогда
				Слово = Подгруппа1;
				ТипСлова = "Метод";
			ИначеЕсли Подгруппа2 <> Неопределено Тогда
				Слово = Подгруппа2;
				ТипСлова = "Свойство";
			ИначеЕсли Подгруппа3 <> Неопределено Тогда 
				Слово = Подгруппа3;   
				ТипСлова = "Свойство";
				Если Истина
					И ОчиститьТаблицуСлов
					И ВключатьГлобальныйКонтекст
					И ЗначениеЗаполнено(ТекстДляАнализа)
					И ТекстСинтаксическиКорректен
					И (Ложь
						Или Не УчитыватьРодительскийКонтекст
						Или мРодительскийКонтекст = "")
				Тогда 
					// Подмена контекста нужна, чтобы избежать бесконечной рекурсии через вызов КонсольКода.ЗаполнитьПараметрыВыхода в режиме ЭтоМодуль
					КонтекстВыполненияПроверки = ?(мФлагиКомпиляции.Сервер, ирСервер, ирОбщий);
					// Вызов из консоли кода для заполнения выходных параметров. https://www.hostedredmine.com/issues/947841
					ИнформацияОбОшибке = ПроверитьТекстИВернутьОшибку(ТекстДляАнализа + ";Сообщить(" + Слово + ")",,, КонтекстВыполненияПроверки);
					Если Истина
						И ИнформацияОбОшибке <> Неопределено 
						И ирОбщий.СтрНайтиЛкс(ИнформацияОбОшибке.Причина.Описание, "функция",,,, Ложь) = 0
						И ирОбщий.СтрНайтиЛкс(ИнформацияОбОшибке.Причина.Описание, "function",,,, Ложь) = 0
					Тогда
						Продолжить;
					КонецЕсли;
				КонецЕсли;
			Иначе 
				Продолжить;
			КонецЕсли;
			СтруктураКлюча = Новый Структура("НСлово", НРег(Слово));
			Если ТипСлова = "Метод" Тогда
				СтруктураКлюча.Вставить("ТипСлова", ТипСлова);
			КонецЕсли;
			НайденныеСтроки = ТаблицаСловТЗ.НайтиСтроки(СтруктураКлюча);
			Если Истина        
				И ТаблицаГлобальногоКонтекста <> Неопределено
				И НайденныеСтроки.Количество() = 0 
			Тогда
				НайденныеСтроки = ТаблицаГлобальногоКонтекста.НайтиСтроки(СтруктураКлюча);
			КонецЕсли;
			НоваяСтрока = Неопределено;
			Для Каждого НайденнаяСтрока Из НайденныеСтроки Цикл
				Если Ложь
					Или ЯзыкПрограммы = 1
					Или ТипСлова = "Метод" 
					Или (Истина
						И ТипСлова <> "Метод" 
						И НайденнаяСтрока.ТипСлова <> "Метод")
				Тогда
					НоваяСтрока = НайденнаяСтрока;
					Прервать;
				КонецЕсли;
			КонецЦикла;
			Если НоваяСтрока = Неопределено Тогда 
				НоваяСтрока = ТаблицаСлов.Добавить();
				НоваяСтрока.Определение = "Статистический";
				НоваяСтрока.Слово = Слово;
				НоваяСтрока.НСлово = НРег(НоваяСтрока.Слово);
				НоваяСтрока.ТипСлова = ТипСлова;
				НоваяСтрока.ТипЗначения = "??";
				НоваяСтрока = ТаблицаСловТЗ.Добавить();
				ЗаполнитьЗначенияСвойств(НоваяСтрока, СтруктураКлюча);
			КонецЕсли;
			НоваяСтрока.Частота = НоваяСтрока.Частота + 1;
		КонецЦикла;
	Иначе
		// Однострочный код использован для ускорения при разрешенной отладке. Выше расположен оригинал. Выполняйте изменения синхронно в обоих вариантах. Преобразовано консолью кода из подсистемы "Инструменты разработчика"
		Для Каждого Match Из Результат Цикл  		Счетчик = Счетчик + 1;  		Если Счетчик = МаксСловНаходитьВТекстеМетода Тогда    			Прервать;  		КонецЕсли;  		Подгруппа1 = Match.SubMatches(0);  		Подгруппа2 = Match.SubMatches(1);  		Если КоличествоПодгрупп = 3 Тогда  			Подгруппа3 = Match.SubMatches(2);  		Иначе  			Подгруппа3 = Неопределено;  		КонецЕсли;  		Если Подгруппа1 <> Неопределено Тогда  			Слово = Подгруппа1;  			ТипСлова = "Метод";  		ИначеЕсли Подгруппа2 <> Неопределено Тогда  			Слово = Подгруппа2;  			ТипСлова = "Свойство";  		ИначеЕсли Подгруппа3 <> Неопределено Тогда  			Слово = Подгруппа3;  			ТипСлова = "Свойство";  			Если Истина  				И ОчиститьТаблицуСлов  				И ВключатьГлобальныйКонтекст  				И ЗначениеЗаполнено(ТекстДляАнализа)  				И ТекстСинтаксическиКорректен  				И (Ложь  					Или Не УчитыватьРодительскийКонтекст  					Или мРодительскийКонтекст = "")  			Тогда    				КонтекстВыполненияПроверки = ?(мФлагиКомпиляции.Сервер, ирСервер, ирОбщий);    				ИнформацияОбОшибке = ПроверитьТекстИВернутьОшибку(ТекстДляАнализа + ";Сообщить(" + Слово + ")",,, КонтекстВыполненияПроверки);  				Если Истина  					И ИнформацияОбОшибке <> Неопределено  					И ирОбщий.СтрНайтиЛкс(ИнформацияОбОшибке.Причина.Описание, "функция",,,, Ложь) = 0  					И ирОбщий.СтрНайтиЛкс(ИнформацияОбОшибке.Причина.Описание, "function",,,, Ложь) = 0  				Тогда  					Продолжить;  				КонецЕсли;  			КонецЕсли;  		Иначе  			Продолжить;  		КонецЕсли;  		СтруктураКлюча = Новый Структура("НСлово", НРег(Слово));  		Если ТипСлова = "Метод" Тогда  			СтруктураКлюча.Вставить("ТипСлова", ТипСлова);  		КонецЕсли;  		НайденныеСтроки = ТаблицаСловТЗ.НайтиСтроки(СтруктураКлюча);  		Если Истина  			И ТаблицаГлобальногоКонтекста <> Неопределено  			И НайденныеСтроки.Количество() = 0  		Тогда  			НайденныеСтроки = ТаблицаГлобальногоКонтекста.НайтиСтроки(СтруктураКлюча);  		КонецЕсли;  		НоваяСтрока = Неопределено;  		Для Каждого НайденнаяСтрока Из НайденныеСтроки Цикл  			Если Ложь  				Или ЯзыкПрограммы = 1  				Или ТипСлова = "Метод"  				Или (Истина  					И ТипСлова <> "Метод"  					И НайденнаяСтрока.ТипСлова <> "Метод")  			Тогда  				НоваяСтрока = НайденнаяСтрока;  				Прервать;  			КонецЕсли;  		КонецЦикла;  		Если НоваяСтрока = Неопределено Тогда  			НоваяСтрока = ТаблицаСлов.Добавить();  			НоваяСтрока.Определение = "Статистический";  			НоваяСтрока.Слово = Слово;  			НоваяСтрока.НСлово = НРег(НоваяСтрока.Слово);  			НоваяСтрока.ТипСлова = ТипСлова;  			НоваяСтрока.ТипЗначения = "??";  			НоваяСтрока = ТаблицаСловТЗ.Добавить();  			ЗаполнитьЗначенияСвойств(НоваяСтрока, СтруктураКлюча);  		КонецЕсли;  		НоваяСтрока.Частота = НоваяСтрока.Частота + 1;  	КонецЦикла;  
	КонецЕсли;
	ТаблицаСлов.ЗагрузитьКолонку(ТаблицаСловТЗ.ВыгрузитьКолонку("Частота"), "Частота");

КонецПроцедуры

Функция БазовоеРасширениеКонфигурации()
	Результат = "";
	Если Истина
		И мМодульМетаданных <> Неопределено
		И мМодульМетаданных.СтруктураТипа <> Неопределено
	Тогда 
		ДержательМетаданных = мМодульМетаданных.СтруктураТипа.ДержательМетаданных;
		Если Истина
			И ТипЗнч(ДержательМетаданных) = Тип("Строка") 
			И ЗначениеЗаполнено(ДержательМетаданных)
		Тогда
			Результат = ДержательМетаданных;
		ИначеЕсли ирОбщий.СтрНачинаетсяСЛкс(мМодульМетаданных.СтруктураТипа.ИмяОбщегоТипа, "Внешн") Тогда 
			Результат = "*";
		КонецЕсли;
	КонецЕсли;
	Возврат Результат;
КонецФункции

// Процедура - Обновить тип значения из таблицы типов
//
// Параметры:
//  НоваяСтрока			 - 	 - 
//  ТаблицаТипов		 - см. мПлатформа.НоваяТаблицаТипов() - 
//  ЗаменитьСуществующий - 	 - 
//
Процедура ОбновитьТипЗначенияИзТаблицыТипов(Знач НоваяСтрока, Знач ТаблицаТипов, ЗаменитьСуществующий = Истина) Экспорт 
	
	#Если Сервер И Не Сервер Тогда
		мПлатформа = Обработки.ирПлатформа.Создать();
	#КонецЕсли
	СтарыйТипЗначения = НоваяСтрока.ТипЗначения;
	Если Лев(СтарыйТипЗначения, 2) = "??" Тогда
		НовыйТипЗначения = мПлатформа.ПредставлениеМассиваСтруктурТипов(ТаблицаТипов);
		////Если Истина
		////	И ЗначениеЗаполнено(НовыйТипЗначения) 
		////	И Найти(НРег(СтарыйТипЗначения), НРег(НовыйТипЗначения)) > 0 
		////	И НовыйТипЗначения <> "??"
		////Тогда
		////	НовыйТипЗначения = "";
		////КонецЕсли; 
		//ОстатокТипа = СокрЛП(Сред(СтарыйТипЗначения, 4));
		//Если Истина
		//	И ОстатокТипа <> "" 
		//	И (Ложь
		//		Или Найти("," + Нрег(НовыйТипЗначения) + ",", "," + Нрег(ОстатокТипа) + ",") > 0
		//		Или ТаблицаТипов.НайтиСтроки(Новый Структура("ИмяОбщегоТипа", ОстатокТипа)).Количество() > 0
		//	)
		//Тогда
			НоваяСтрока.ТипЗначения = НовыйТипЗначения;
		//Иначе
		//	НоваяСтрока.ТипЗначения = СтрЗаменить(СтарыйТипЗначения, "??", НовыйТипЗначения);
		//КонецЕсли;
		Если Не ЗначениеЗаполнено(НоваяСтрока.ТипЗначения) Тогда
			НоваяСтрока.ТипЗначения = "?";
		ИначеЕсли Лев(НоваяСтрока.ТипЗначения, 1) = "," Тогда 
			НоваяСтрока.ТипЗначения = СокрЛ(Сред(НоваяСтрока.ТипЗначения, 2));
		КонецЕсли; 
	ИначеЕсли Ложь
		Или ЗаменитьСуществующий
		Или Не ЗначениеЗаполнено(СтарыйТипЗначения) 
		Или Найти(СтарыйТипЗначения, "<") > 0
	Тогда 
		НоваяСтрока.ТипЗначения = мПлатформа.ПредставлениеМассиваСтруктурТипов(ТаблицаТипов);
	КонецЕсли;

КонецПроцедуры

Функция СобратьКомментарийМетода(ОписаниеМетода = "", Знач СтрокаРезультата = Неопределено, ЗначенияПараметров = Неопределено) Экспорт 
	
	#Если Сервер И Не Сервер Тогда
		ЗначенияПараметров = Новый Структура;
		мПлатформа = Обработки.ирПлатформа.Создать();
	#КонецЕсли
	ПрефиксОписанияПараметра = "//    ";
	КомментарийМетода = Новый Массив;
	Для Каждого Параметр Из Параметры Цикл
		ТаблицаСвойств = Неопределено;
		Если Не ЗначениеЗаполнено(Параметр.ТипЗначения) Тогда
			ЗначениеПараметра = Параметр.Значение;
			Если ЗначенияПараметров <> Неопределено И ЗначенияПараметров.Свойство(Параметр.Имя) Тогда
				ЗначениеПараметра = ЗначенияПараметров[Параметр.Имя];
			КонецЕсли;
			СтруктураТипа = мПлатформа.СтруктураТипаИзЗначения(ЗначениеПараметра);    
			ИмяОбщегоТипа = мПлатформа.ИмяТипаИзСтруктурыТипа(СтруктураТипа);
			ТаблицаЗначений = Неопределено;
			Если Ложь
				Или ТипЗнч(ЗначениеПараметра) = Тип("Структура") 
				Или ТипЗнч(ЗначениеПараметра) = Тип("ФиксированнаяСтруктура")
			Тогда
				ТаблицаСвойств = мПлатформа.ТаблицаСловИзСтруктурыТипа(СтруктураТипа,,,,,, "Свойство");
			ИначеЕсли Ложь
				Или ТипЗнч(ЗначениеПараметра) = Тип("ТаблицаЗначений") 
				Или ТипЗнч(ЗначениеПараметра) = Тип("ДеревоЗначений")
			Тогда
				ТаблицаЗначений = ЗначениеПараметра;
			ИначеЕсли Ложь
				Или ТипЗнч(ЗначениеПараметра) = Тип("СтрокаТаблицыЗначений") 
				Или ТипЗнч(ЗначениеПараметра) = Тип("СтрокаДереваЗначений")
			Тогда
				ТаблицаЗначений = ЗначениеПараметра.Владелец();
			КонецЕсли; 
			Если ТаблицаЗначений <> Неопределено Тогда
				СтруктураТипа = мПлатформа.СтруктураТипаИзЗначения(ТаблицаЗначений);    
				ТаблицаСвойств = мПлатформа.ТаблицаСловИзСтруктурыТипа(СтруктураТипа,,,,,, "Метод",,, "Найти");
				ТаблицаСвойств = мПлатформа.ТаблицаСловИзСтруктурыТипа(ТаблицаСвойств[0].ТаблицаТипов[0],,,,,, "Свойство");
			КонецЕсли;
			Параметр.ТипЗначения = ИмяОбщегоТипа;
		КонецЕсли;
		ТипЗначения = Параметр.ТипЗначения;
		Если ТипЗначения = "Неопределено" Тогда
			ТипЗначения = "";
		КонецЕсли;
		КомментарийМетода.Добавить(ПрефиксОписанияПараметра + Параметр.Имя + " - " + ТипЗначения + " - " + Параметр.Комментарий);
		Если ТаблицаСвойств <> Неопределено И ТаблицаСвойств.Количество() > 0 Тогда 
			КомментарийМетода[КомментарийМетода.ВГраница()] = КомментарийМетода[КомментарийМетода.ВГраница()] + ":";
			Для Каждого Свойство Из ТаблицаСвойств Цикл
				ОбновитьТипЗначенияИзТаблицыТипов(Свойство, Свойство.ТаблицаТипов);
				ТипЗначения = Свойство.ТипЗначения;
				Если ТипЗначения = "Неопределено" Тогда
					ТипЗначения = "";
				КонецЕсли;
				КомментарийМетода.Добавить(ПрефиксОписанияПараметра + "  * " + Свойство.Слово + " - " + ТипЗначения + " - " + Параметр.Комментарий);
			КонецЦикла;
		КонецЕсли;
	КонецЦикла;
	КомментарийМетода = ирОбщий.СтрСоединитьЛкс(КомментарийМетода, Символы.ПС);
	Если ЗначениеЗаполнено(КомментарийМетода) Тогда
		КомментарийМетода = "// Параметры:" + Символы.ПС + КомментарийМетода + Символы.ПС;
	КонецЕсли; 
	Если ЗначениеЗаполнено(ОписаниеМетода) Тогда
		КомментарийМетода = Сред(ирОбщий.ДобавитьМногострочнуюСтрокуВТекстЛкс(, ОписаниеМетода, "// ", Истина), 2) + Символы.ПС + КомментарийМетода;
	ИначеЕсли Ложь
		Или ЗначениеЗаполнено(КомментарийМетода) 
		Или СтрокаРезультата <> Неопределено 
	Тогда 
		КомментарийМетода = "//.
		|" + КомментарийМетода;
	КонецЕсли;
	Если СтрокаРезультата <> Неопределено Тогда
		КомментарийМетода = КомментарийМетода + "// Возвращаемое значение:" + Символы.ПС + ПрефиксОписанияПараметра + СтрокаРезультата.ТипЗначения + " - " + СтрокаРезультата.Комментарий + Символы.ПС;
	КонецЕсли;
	Если Не ЗначениеЗаполнено(КомментарийМетода) Тогда
		КомментарийМетода = "";
	КонецЕсли;
	Возврат КомментарийМетода;

КонецФункции

Процедура УстановитьКлиентСерверКонтекст(Знач НовыйНаСервере = Истина) Экспорт 
	мФлагиКомпиляции = мПлатформа.НовыеФлагиКомпиляции(НовыйНаСервере, Не НовыйНаСервере, Не НовыйНаСервере);
	Если мМодульМетаданных <> Неопределено Тогда
		УстановитьФлагиКомпиляцииМодуля();
	КонецЕсли;
КонецПроцедуры

Процедура УстановитьФлагиКомпиляцииМодуля() Экспорт
	Если мФлагиКомпиляции = Неопределено Тогда
		мФлагиКомпиляции = мПлатформа.НовыеФлагиКомпиляции();
	КонецЕсли;
	мМодульМетаданных.ФлагиКомпиляции = ирОбщий.СкопироватьКоллекциюЛкс(мФлагиКомпиляции);
КонецПроцедуры

Функция ПроверитьОписаниеФормыИзБуфераОбмена(ТекстОписания) Экспорт
	ИмяФормы = ирОбщий.ТекстМеждуМаркерамиЛкс(ТекстОписания, "},""", """", Ложь);
	Возврат ЗначениеЗаполнено(ИмяФормы) И ирОбщий.СтрКончаетсяНаЛкс(мИмяМодуля, ИмяФормы + ".Форма.Модуль");
КонецФункции

Процедура УстановитьСлужебныеДанныеФормы(Знач Текст) Экспорт
	СлужебныеДанные = ирОбщий.СлужебныеДанныеФормыЛкс(мМодульМетаданных.СтруктураТипа.Метаданные);
	Если ТипЗнч(мМодульМетаданных.СтруктураТипа.Метаданные) = ирОбщий.ТипУправляемаяФормаЛкс() Тогда
		Форма = мМодульМетаданных.СтруктураТипа.Метаданные;
	КонецЕсли;
	Если мПлатформа.ОбновитьКэшСтруктурыФормыИзБуфера(СлужебныеДанные, Текст, Форма) Тогда 
		мПлатформа.СброситьКэшТиповВыраженийМодуля(мМодульМетаданных);
	Иначе
		Если Истина
			И мМодульМетаданных.СтруктураТипа.ИмяОбщегоТипа = "ФормаКлиентскогоПриложения" 
			И мМодульМетаданных.СтруктураТипа.Метаданные.Тип = Тип("Форма")
		тогда
			мМодульМетаданных.СтруктураТипа.ИмяОбщегоТипа = "Форма";
		КонецЕсли;
	КонецЕсли;
КонецПроцедуры

// Для вызова через COM
Функция ПредставлениеМассиваСтруктурТипов(ТаблицаТипов) Экспорт 
	Возврат мПлатформа.ПредставлениеМассиваСтруктурТипов(ТаблицаТипов);
КонецФункции

// Вызывается из адаптера
//
Функция ИмяТипаКонтекста(_ТаблицаТипов = Неопределено) Экспорт 
	Результат = "?";
	Если мСтруктураТипаКонтекста <> Неопределено Тогда
		//Результат = мПлатформа.ИмяТипаИзСтруктурыТипа(мСтруктураТипаКонтекста);
		//Если Результат = "Локальный" Тогда 
		Если мЭтоЛокальныйКонтекстТаблицыСлов Тогда
			Если Истина
				И мМодульМетаданных <> Неопределено
				И мМодульМетаданных.СтруктураТипа <> Неопределено 
			Тогда
				Результат = мПлатформа.ИмяТипаИзСтруктурыТипа(мМодульМетаданных.СтруктураТипа);
			КонецЕсли; 
		ИначеЕсли мТаблицаТиповКонтекста.Количество() > 1 Тогда
			//Результат = Результат + ", +" + XMLСтрока(мТаблицаТиповКонтекста.Количество() - 1) + " типов";
			Результат = "" + XMLСтрока(мТаблицаТиповКонтекста.Количество()) + ": " + ПредставлениеМассиваСтруктурТипов(мТаблицаТиповКонтекста);
		Иначе
			Результат = мПлатформа.ИмяТипаИзСтруктурыТипа(мСтруктураТипаКонтекста);
		КонецЕсли;
	Иначе 
		ПУстышка = 0;
	КонецЕсли;
	Возврат Результат;
КонецФункции

Функция ЛиНуженОбъектИзКонфигуратора() Экспорт 
	Возврат мОбъектИзКонфигуратора = Неопределено;
КонецФункции

Процедура УстановитьДанныеОбъектаИзКонфигуратора(Знач КодированнаяСтрока) Экспорт 
	ДвоичныеДанные = Base64Значение(ирОбщий.ТекстМеждуМаркерамиЛкс(КодированнаяСтрока, "#base64:", "}"));
	Текст = Новый ТекстовыйДокумент;
	Текст.Прочитать(ДвоичныеДанные.ОткрытьПотокДляЧтения());
	ТекстФайла = Текст.ПолучитьТекст();
	мОбъектИзКонфигуратора = ирОбщий.ДокументDOMИзСтрокиВнутрЛкс(ТекстФайла);
	//XMLСтрока = СтрокаВнутрВХМЛТелоЛкс(ТекстФайла);
	//мОбъектИзКонфигуратора = ТекстВДокументDOMЛкс(XMLСтрока);
	
	//Выражение = "/e/e[1]/e/d[6]/text()"; // Корневые элементы
	//Выражение = "/e/e[1]/e//d[(position()=5 or position()=6) and starts-with(text(), '""') and text()!='""""']/text()"; // Все элементы
	//Выражение = "/e/e[3]/e/d[2]/text()"; // Все параметры
	////Выражение = "/e/e[4]/e/d[2]/text()"; // Все команды
	////Выражение = "/e/e[2]/e/d[3]/text()"; // Корневые реквизиты
	//Разыменователь = Новый РазыменовательПространствИменDOM(Новый Соответствие); 
	//НаборУзлов = ДокументDOM.ВычислитьВыражениеXPath(Выражение, ДокументDOM, Разыменователь, ТипРезультатаDOMXPath.Строка);
	//УзелDOM = НаборУзлов.ПолучитьСледующий();
	//Пока УзелDOM <> Неопределено Цикл
	//	Сообщить(УзелDOM.ТекстовоеСодержимое);
	//	УзелDOM = НаборУзлов.ПолучитьСледующий();
	//КонецЦикла;

КонецПроцедуры

Процедура ОбновитьМодульМетаданных(Знач Текст = Неопределено) Экспорт 
	
	#Если Сервер И Не Сервер Тогда
		мПлатформа = Обработки.ирПлатформа.Создать();
	#КонецЕсли
	Если Текст = Неопределено Тогда
		Текст = ПолеТекста.ПолучитьТекст();
	КонецЕсли; 
	СтарыйМодульМетаданных = мМодульМетаданных;
	Если мМодульМетаданных <> Неопределено И мМодульМетаданных.СтруктураТипа <> Неопределено Тогда
		мМодульМетаданных = мПлатформа.ПодготовитьМодульМетаданных(мМодульМетаданных.СтруктураТипа, ирОбщий.ПоследнийФрагментЛкс(мИмяМодуля),, Текст, мПозицияВТексте);
	Иначе
		мИмяМодуля = мПлатформа.ИмяДинамическогоМодуля();
		мМодульМетаданных = мПлатформа.МодульМетаданных(Текст,, мИмяМодуля,, мМодульМетаданных, мПозицияВТексте); 
		УстановитьФлагиКомпиляцииМодуля();
	КонецЕсли;           
	Если Истина
		И СтарыйМодульМетаданных <> Неопределено
		И СтарыйМодульМетаданных <> мМодульМетаданных
		И СтарыйМодульМетаданных.Имя = мПлатформа.ИмяДинамическогоМодуля()
		И мМодульМетаданных.Имя = мПлатформа.ИмяДинамическогоМодуля()
	Тогда
		СкопироватьСпециальныеЭлементыМодуля(СтарыйМодульМетаданных.Методы, мМодульМетаданных.Методы);
		СкопироватьСпециальныеЭлементыМодуля(СтарыйМодульМетаданных.Переменные, мМодульМетаданных.Переменные);
	КонецЕсли;

КонецПроцедуры

Процедура ПодготовитьГлобальныйКонтекст() Экспорт  
	ГлобальныйКонтекст = мПлатформа.НоваяСтруктураТипа("Глобальный");
	ГлобальныйКонтекст.Метаданные = Метаданные;
	мПлатформа.ТаблицаСловИзСтруктурыТипа(ГлобальныйКонтекст,, Метаданные,, Ложь,,, мФлагиКомпиляции,,,,,,, БазовоеРасширениеКонфигурации());
	Попытка
		Пустышка = БиблиотекаКартинок["!"]; // Путем обращения к заведомо несуществующей картинке вызываем полную загрузку кэша картинок платформой. В редких случаях встречается длительное выполнение.
	Исключение
	КонецПопытки;
КонецПроцедуры

Процедура СкопироватьСпециальныеЭлементыМодуля(СтараяКоллекцияМодуля, НоваяКоллекцияМодуля) Экспорт
	Если Истина
		И СтараяКоллекцияМодуля.Количество() > 0 
		И СтараяКоллекцияМодуля[СтараяКоллекцияМодуля.Количество() - 1].ПозицияСОписанием = 0
	Тогда
		ирОбщий.ЗагрузитьВТаблицуЗначенийЛкс(СтараяКоллекцияМодуля.Скопировать(Новый Структура("ПозицияСОписанием", 0)), НоваяКоллекцияМодуля);
	КонецЕсли;
КонецПроцедуры

Процедура ОчиститьИсториюПереходов() Экспорт 
	мИсторияПереходов = Неопределено;
КонецПроцедуры
	
Процедура ЗапомнитьИсточникПерехода() Экспорт 
	Если мИсторияПереходов = Неопределено Тогда
		мИсторияПереходов = Новый Массив;
	КонецЕсли; 
	АдресУхода = ПолеТекста.ВыделениеДвумерное();
	Если Истина
		И мИсторияПереходов.Количество() > 0 
		И ирОбщий.СравнитьЗначенияСвойствЛкс(мИсторияПереходов[0], АдресУхода) 
	Тогда
		Возврат;
	КонецЕсли;
	мИсторияПереходов.Вставить(0, АдресУхода);
КонецПроцедуры

Функция ВернутьсяИзПерехода() Экспорт 
	
	Пока Истина Цикл
		Если мИсторияПереходов = Неопределено Или мИсторияПереходов.Количество() = 0 Тогда
			Возврат Ложь;
		КонецЕсли; 
		АдресУхода = мИсторияПереходов[0];
		Если ирОбщий.СравнитьЗначенияСвойствЛкс(ПолеТекста.ВыделениеДвумерное(), АдресУхода) Тогда
			мИсторияПереходов.Удалить(0);
		Иначе
			Прервать;
		КонецЕсли;
	КонецЦикла;
	ПолеТекста.УстановитьВыделениеДвумерное(АдресУхода);
	мИсторияПереходов.Удалить(0);
	Возврат Истина;
	
КонецФункции

// Вызывается из адаптера
Функция ТаблицаСловВJSON(КлючНабораСлов = "") Экспорт 
	
	ВыгрузкаТаблицы = ТаблицаСловДляАдаптера(КлючНабораСлов);
	Возврат ирОбщий.ТаблицаЗначенийВJSONЛкс(ВыгрузкаТаблицы);
	
КонецФункции 

//.
// Параметры:
//    КлючНабораСлов - Строка - 
//    мНаборыСлов - Соответствие - 
//    ТаблицаСлов -  - 
// Возвращаемое значение:
//     - 
Функция ТаблицаСловДляАдаптера(Знач КлючНабораСлов) Экспорт
	Если ЗначениеЗаполнено(КлючНабораСлов) Тогда
		ИменаКолонок = "ТипСлова,Слово,ТипЗначения,Определение";
		ВыгрузкаТаблицы = мНаборыСлов[КлючНабораСлов].Скопировать(, ИменаКолонок);
		ВыгрузкаТаблицы.Колонки.Добавить("Рейтинг");
	Иначе
		ИменаКолонок = "ТипСлова,Слово,ТипЗначения,Определение,Рейтинг";
		ВыгрузкаТаблицы = ТаблицаСлов.Выгрузить(, ИменаКолонок);
	КонецЕсли;
	ВыгрузкаТаблицы.Колонки.Добавить("ЛиРез");
	ВыгрузкаТаблицы.Колонки.Добавить("ЛиМетод");
	ВыгрузкаТаблицы.Колонки.Добавить("ЛиТочный");
	ВыгрузкаТаблицы.Колонки.Добавить("Тип");           
	ВыгрузкаТаблицы.Колонки.Добавить("Приоритет");  
	РейтингСовпаденияТипа = КонстантаРейтингСовпаденияТипа();
	//ВыгрузкаТаблицы[ВыгрузкаТаблицы.Количество() - 1].Рейтинг = РейтингСовпаденияТипа; // Для отладки
	_РежимОтладки = Ложь;
	Если _РежимОтладки Тогда // Можно менять на Истина в точке останова, например условием ирОбщий.Пр(_РежимОтладки, 1, 1)
		// Пассивный оригинал расположенного ниже однострочного кода. Выполняйте изменения синхронно в обоих вариантах.
		Для Каждого Строка Из ВыгрузкаТаблицы Цикл 
			Строка.ЛиРез = Строка.ТипЗначения <> "";
			Строка.ЛиМетод = Строка.ТипСлова = "Метод"; 
			Строка.ЛиТочный = Строка.Определение <> "Статистический"; 
			Строка.Тип = Лев(Строка.ТипЗначения, 200);
			Строка.Приоритет = ?(Строка.Рейтинг = РейтингСовпаденияТипа, 100, 0);
		КонецЦикла; 
	Иначе
		// Однострочный код использован для ускорения при разрешенной отладке. Выше расположен оригинал. Выполняйте изменения синхронно в обоих вариантах. Преобразовано консолью кода из подсистемы "Инструменты разработчика"
		Для Каждого Строка Из ВыгрузкаТаблицы Цикл  			Строка.ЛиРез = Строка.ТипЗначения <> "";  			Строка.ЛиМетод = Строка.ТипСлова = "Метод";  			Строка.ЛиТочный = Строка.Определение <> "Статистический";  			Строка.Тип = Лев(Строка.ТипЗначения, 200);  			Строка.Приоритет = ?(Строка.Рейтинг = РейтингСовпаденияТипа, 100, 0);  		КонецЦикла;  
	КонецЕсли;
	ВыгрузкаТаблицы.Колонки.Удалить("ТипСлова");
	ВыгрузкаТаблицы.Колонки.Удалить("ТипЗначения");
	ВыгрузкаТаблицы.Колонки.Удалить("Рейтинг");
	Возврат ВыгрузкаТаблицы;
КонецФункции

//.
// Возвращаемое значение:
//     - 
Функция КонстантаРейтингСовпаденияТипа() Экспорт
	Возврат 1000000;
КонецФункции

Процедура СброситьКэшТиповВыраженийМодуля() Экспорт
	мПлатформа.СброситьКэшТиповВыраженийМодуля(мМодульМетаданных);
КонецПроцедуры

// Добавляет слово локального контекста.
//
// Параметры:
//  Слово        - Строка;
//  ТипСлова     - Строка - "Метод", "Свойство";
//  *ОписаниеТипов - ОписаниеТипов, *Неопределено - ;
//  *Метаданные  - Произвольный, *Неопределено - используется, если ОписаниеТипов задан;
//  *ТаблицаСтруктурТипа - ТаблицаЗначений, *Неопределено;
//
Функция ДобавитьСловоЛокальногоКонтекста(Слово, ТипСлова = "Свойство", Знач ОписаниеТипов = Неопределено,
	пМетаданные = Неопределено, _Глобальное = Ложь, Значение = Неопределено, ТаблицаТипов = Неопределено, Знач ИмяОбщегоТипа = "") Экспорт
	
	КлючСтроки = Новый Структура;
	КлючСтроки.Вставить("нИмя", Нрег(Слово));
	ТаблицаЛокальногоКонтекста = ТаблицаЛокальногоКонтекста(ТипСлова);
	НайденныеСтроки = ТаблицаЛокальногоКонтекста.НайтиСтроки(КлючСтроки);
	Если НайденныеСтроки.Количество() = 0 Тогда
		НоваяСтрока = ТаблицаЛокальногоКонтекста.Добавить();
		НоваяСтрока.Имя = Слово;
		ЗаполнитьЗначенияСвойств(НоваяСтрока, КлючСтроки);
	Иначе
		НоваяСтрока = НайденныеСтроки[0];
	КонецЕсли;
	Если ТаблицаТипов = Неопределено Тогда
		ТаблицаТипов = мПлатформа.НоваяТаблицаТипов();
	КонецЕсли;
	НоваяСтрока.ТаблицаТипов = ТаблицаТипов;
	НоваяСтрока.Вычислено = Истина;
	Если ЗначениеЗаполнено(ИмяОбщегоТипа) Тогда
		СтруктураТипа = мПлатформа.НоваяСтруктураТипа(ИмяОбщегоТипа);
		СтруктураТипа.Метаданные = пМетаданные;
		мПлатформа.ДобавитьВТаблицуТипов(ТаблицаТипов, СтруктураТипа);
	КонецЕсли;
	Если Значение <> Неопределено Тогда
		СтруктураТипа = мПлатформа.СтруктураТипаИзЗначения(Значение, ЯзыкПрограммы,
			Новый Структура("СтрокаОписания, Метаданные", НоваяСтрока, пМетаданные)); // Циклическая ссылка СтрокаОписания
		мПлатформа.ДобавитьВТаблицуТипов(ТаблицаТипов, СтруктураТипа);
	КонецЕсли; 
	//Если Значение <> Неопределено Тогда
	//	Если ОписаниеТипов = Неопределено Тогда
	//		ОписаниеТипов = Новый ОписаниеТипов;
	//	КонецЕсли; 
	//	ОписаниеТипов = Новый ОписаниеТипов(ОписаниеТипов, ирОбщий.ЗначенияВМассивЛкс(ТипЗнч(Значение)));
	//КонецЕсли;
	Если ОписаниеТипов <> Неопределено Тогда
		Для Каждого Тип Из ОписаниеТипов.Типы() Цикл
			СтруктураТипа = мПлатформа.СтруктураТипаИзКонкретногоТипа(Тип, ЯзыкПрограммы,
				Новый Структура("СтрокаОписания, Метаданные", НоваяСтрока, пМетаданные)); // Циклическая ссылка СтрокаОписания
			мПлатформа.ДобавитьВТаблицуТипов(ТаблицаТипов, СтруктураТипа);
		КонецЦикла;
	КонецЕсли;
	НоваяСтрока.ТипЗначения = мПлатформа.ПредставлениеМассиваСтруктурТипов(ТаблицаТипов);
	СброситьКэшТиповВыраженийМодуля();
	Возврат НоваяСтрока;

КонецФункции

Функция ТаблицаЛокальногоКонтекста(Знач ТипСлова = "Свойство")
	
	Если мМодульМетаданных = Неопределено Тогда
		ОбновитьМодульМетаданных(""); 
	КонецЕсли;
	Если ТипСлова = "Метод" Тогда
		ТаблицаЛокальногоКонтекста = мМодульМетаданных.Методы;
	Иначе
		ТаблицаЛокальногоКонтекста = мМодульМетаданных.Переменные;
	КонецЕсли; 
	Возврат ТаблицаЛокальногоКонтекста;

КонецФункции

// Не рекомендуется вызывать. Вызывается из адаптера. 
Функция ЛиТекстЯзыкаЗапросовЛкс(Знач НачалоТекста) Экспорт 
	
	Результат = ирОбщий.ЛиТекстЯзыкаЗапросовЛкс(НачалоТекста);
	Возврат Результат;

КонецФункции

Функция ПрочитатьУдалитьСообщенияПользователю() Экспорт
	Если мПлатформа.мОчередьСообщений = Неопределено Тогда
		Результат = "";
	Иначе
		Результат = ирОбщий.СтрСоединитьЛкс(мПлатформа.мОчередьСообщений, Символы.ПС);
	КонецЕсли;
	мПлатформа.мОчередьСообщений = Новый Массив;
	Возврат Результат;
КонецФункции

//ирПортативный лФайл = Новый Файл(ИспользуемоеИмяФайла);
//ирПортативный ПолноеИмяФайлаБазовогоМодуля = Лев(лФайл.Путь, СтрДлина(лФайл.Путь) - СтрДлина("Модули\")) + "ирПортативный.epf";
//ирПортативный #Если Клиент Тогда
//ирПортативный 	Контейнер = Новый Структура();
//ирПортативный 	Оповестить("ирПолучитьБазовуюФорму", Контейнер);
//ирПортативный 	Если Не Контейнер.Свойство("ирПортативный", ирПортативный) Тогда
//ирПортативный 		ирПортативный = ВнешниеОбработки.ПолучитьФорму(ПолноеИмяФайлаБазовогоМодуля);
//ирПортативный 		ирПортативный.Открыть();
//ирПортативный 	КонецЕсли; 
//ирПортативный #Иначе
//ирПортативный 	ирПортативный = ВнешниеОбработки.Создать(ПолноеИмяФайлаБазовогоМодуля, Ложь); // Это будет второй экземпляр объекта
//ирПортативный #КонецЕсли
//ирПортативный ирОбщий = ирПортативный.ОбщийМодульЛкс("ирОбщий");
//ирПортативный ирКэш = ирПортативный.ОбщийМодульЛкс("ирКэш");
//ирПортативный ирСервер = ирПортативный.ОбщийМодульЛкс("ирСервер");
//ирПортативный ирКлиент = ирПортативный.ОбщийМодульЛкс("ирКлиент");

мПлатформа = ирКэш.Получить(); 
#Если Сервер И Не Сервер Тогда
	мПлатформа = Обработки.ирПлатформа.Создать();
	ПолеТекста = Обработки.ирОболочкаПолеТекста.Создать();
	мРегВыражение = Обработки.ирОболочкаРегВыражение.Создать();
	мМодульМетаданных = мПлатформа.МодульМетаданных("");
	ФормаВладелец = ОткрытьФорму(); // см. Обработка.ирКлсПолеТекстаПрограммы.Форма.ФормаПример
	УстановитьКонфигурациюМетаданных();
	СоздатьСлужебноеПоле();
#КонецЕсли
#Если Клиент Тогда
	мПолеТекстаВременное = мПлатформа.СлужебноеПолеТекста;
#КонецЕсли 
//мПравилаВычисленияФункций = ирОбщий.НоваяТаблицаЗначенийЛкс("Слово, нСлово, ТипКонтекста, Правило"); // Долго
мПравилаВычисленияФункций = Новый ТаблицаЗначений;
мПравилаВычисленияФункций.Колонки.Добавить("Слово");
мПравилаВычисленияФункций.Колонки.Добавить("нСлово");
мПравилаВычисленияФункций.Колонки.Добавить("ТипКонтекста");
мПравилаВычисленияФункций.Колонки.Добавить("Правило");
мПравилаВычисленияФункций.Индексы.Добавить("Слово, ТипКонтекста");  

НаКлиенте = Истина;
НаСервере = Истина;
мРазбиратьКонтекст = Истина;
мРасширенноеПолучениеМетаданныхADO = Ложь;
//мДоступныеТаблицыПолучены = Ложь;
мАвтоКонтекстнаяПомощь = Ложь;
мИменаОбщихТиповПоИменамКлассовCOM = Новый Соответствие;
мСтруктурыТиповПодсказкиУдержания = Новый Структура;
мДоступныеПоляТаблиц = Новый Соответствие;

мШиринаТабуляции = 4;
МаксСловНаходитьВТекстеМетода = 2000;

мРегВыражение = ирОбщий.НовоеРегВыражениеЛкс();
мРегВыражение.IgnoreCase = Истина;
мРегВыражение.MultiLine = Ложь;

шЛюбой = мПлатформа.шЛюбой;
шБуква = мПлатформа.шБуква;
шИмя         = мПлатформа.шИмя;
шЧисло       = мПлатформа.шЧисло;
шИндекс      = мПлатформа.шИндекс;
шСкобки      = мПлатформа.шСкобки;
шРазделитель = мПлатформа.шРазделитель;
шКомментарий = мПлатформа.шКомментарий;
шЛитералПрограммы = мПлатформа.шЛитералПрограммы;
шЛитералВЗапросе = мПлатформа.шЛитералВЗапросе;  
шЛитералПростой = мПлатформа.шЛитералПростой;

шНачалоДок = "//[!:]"; 
шНачалоЧисла = "\d+(?:\.)?\d*";
// зависает на некорректном выражении ФорматДок.УстановитьФорматированнуюСтроку(Вычислить(Новый ФорматированнаяСтрока("" "", , ИсходныйЦвет)"));
// Но видит на уровень глубже чем шСкобки, который 
шМеждуСкобок = "[^\(\);""]";
шСимволыПрефиксаПараметра = "&@~\?"; 

// Если добавляем любой символ в конце, то вызывает бесконечный откат на тесте ("<?xml version=""1.0"" encoding=""UTF-8"" lns=""http://v8.1c.ru/8.2/roles"" xmlns:xs=""я"">")
шСкобкиЛенивые = "(\((?:" + шМеждуСкобок + "*?(?:(?:(?:" + шЛитералПростой + "|\((?:" + "[^\);""]" + "|" + шЛитералПростой + ")*?\))" + шМеждуСкобок + "*?)*)*\))?)"; // МультиМетка82355611

шИмяСкобки        = "(?:" + шИмя + "|\?|(?=\())" + шСкобки;
шИмяСкобкиЛенивые = "(?:" + шИмя + "|\?|(?=\())" + шСкобкиЛенивые;
шИмяСТочками = шИмя + "(?:\." + шИмя + ")*";
шПредИмяПрямое = "(?:^|[^\d\." + шБуква + шСимволыПрефиксаПараметра + "])";
шПостИмяСвойства = "(?=$|[^\d" + шБуква + "\(])";
//шПредИнструкция = "(?:" + мПлатформа.шПустоеНачалоСтроки + "(?:" + шНачалоДок + "\s*)?|;\s*|Иначе\s+|Тогда\s+|Цикл\s+)"; // Редко полезно, а скорость снижает
шПредИнструкция = "(?:" + мПлатформа.шПустоеНачалоСтроки + "(?:" + шНачалоДок + "\s*)?|;\s*)";

// Шаблоны программы 

шПрефиксПараметраНеобяз = "[" + шСимволыПрефиксаПараметра + "]?";
шНачалоЛитералаПрограммы = шЛитералПрограммы + "?"; // опасно!
шОператорПрограммы = "(?:(?:=|>|<|<>|<=|>=|\*|\/|\+|\-)|" + шРазделитель + "(?:И|ИЛИ|НЕ|AND|OR|NOT)" + шРазделитель + ")+";
шНазначениеТипаПриПрисвоении = "(?:;?[ \t]*//([^\n]+))?";

шФрагментЛитералаПрограммы = "(?:""|\|)(?:(?:"""")|[^""\n$])*(?:""|\n|$)";
шНачалоТокена = "([" + шБуква + "\d]" + шРазделитель + "+|(?:\]|\)|" + шФрагментЛитералаПрограммы + "|;|^)" + шРазделитель + "*)";
шКонецТокена = "(?=" + шРазделитель + "+[" + шБуква + "\d]|" + шРазделитель + "*(?:\[|\(|" + шФрагментЛитералаПрограммы + "|;|$))";
шЕсли = шНачалоТокена + "(?:Если|ИначеЕсли|If|ElseIf)"  
	+ шКонецТокена + "(?:" + шФрагментЛитералаПрограммы + "|\." + шРазделитель + "*Тогда|\r|\n|.)*?" + "[^" + шБуква + "\d\.]"
	+ "(?:Тогда|Then)" + шКонецТокена;
шПока = шНачалоТокена + "Пока" 
	+ шКонецТокена + "(?:" + шФрагментЛитералаПрограммы + "|\r|\n|.)*?" + "[^" + шБуква + "\d\.]"
	+ "Цикл" + шКонецТокена;
шВызватьИсключение = шНачалоТокена + "ВызватьИсключение" 
	+ шКонецТокена + "(?:" + шФрагментЛитералаПрограммы + "|\." + шРазделитель + "*;|\r|\n|.)*?;";
шОбъектноеВыражение = шИмяСкобки + "?" + "(?:(?:\.(?:" + шИмя + ")" + шСкобки + "?)|" + шИндекс + ")*";
шПроверяемоеВыражение = "(([+=]\s*)?" + шЛитералПрограммы + "(?:\s*[+=;])?)|" + шКомментарий + "|(" + шПредИмяПрямое + ")(" + шИмяСкобки + "?" + шИндекс + "*(?:\." + шИмяСкобки + "?" + шИндекс + "*)+)";
шОбходКоллекции = "(" + шРазделитель + "+Из" + шРазделитель + "+(" + шИмяСкобки + "?" + шИндекс + "*" + "(\." + шИмяСкобки + "?" + шИндекс + "*)*))\s*(?:Цикл|Do)?";

// Не захватывает
шВыражениеПрограммы1 = "(?:(?:новый|New)" + "(?:" + шРазделитель + "(?:" + шИмя + "))?" + шРазделитель + "*" + "(?:\(""(?:" + шИмя+ "(?:\." + шИмя + ")*)""\))?"
	+ "|(?:(?:не|not)" + шРазделитель + "+)?(?:(?:(?:новый|New)" + шРазделитель + ")?" + шОбъектноеВыражение + ")"
	+ "|" + шЧисло  
	+ "|" + шЛитералПрограммы + ")";
шВыражениеПрограммы = шРазделитель + "*" + шВыражениеПрограммы1 + "(?:" + шРазделитель + "*" + шОператорПрограммы + шРазделитель + "*"
	+ шВыражениеПрограммы1 + ")*";
	
шНачалоВыраженияПрограммы = "(?:" + шРазделитель + "*(?:(?:" 
	+ шОбъектноеВыражение + ")|"
	+ шЧисло + "|" + шЛитералПрограммы + ")" + шРазделитель + "*" + шОператорПрограммы + ")*" 
	+ шРазделитель + "*(?:(?:" + шОбъектноеВыражение + ")|"
	+ шНачалоЧисла + "|" + шНачалоЛитералаПрограммы + ")?";

шВызовМетодаПрограммы = "()?"
	//+ "(" + мПлатформа.шПустоеНачалоСтроки + "(?!//)[^\n]*?" + ")" // Если раскомментировать, то очень долго разбирается текст - ВыделенныйТекст(СловоЯзыкаЗапросовВФорме("SELECT") + " " + ТекстВыбор + " " + СловоЯзыкаЗапросовВФорме("FROM") + " " + 1);
	+ "(?:" + шПредИмяПрямое + "(Новый|New)\s+)?(" + шОбъектноеВыражение + "?)"
	+ "\(((?:(?:" + шВыражениеПрограммы + ")?" + шРазделитель + "*,)*)" + "(" + шНачалоВыраженияПрограммы + ")?" + шРазделитель + "*";

// Если брать шПрисвоенноеВыражениеПрограммы, то зависало в ВычислитьВозможныеТекстовыеЗначенияПараметра на тексте: Фу(1, новый Структура("П1, П2, П3", 1, 1, 1), 1)
//шПростоеВыражениеПрограммы = "(?:(?:(?:(?:новый|New)\s+)?" + шИмяСкобки + "?" + шИндекс + "?(?:\." + шИмяСкобки + "?" + шИндекс + "?)*)"
шПростоеВыражениеПрограммы = "(?:(?:(?:(?:новый|New)\s+)?" + шИмяСкобкиЛенивые + "?" + шИндекс + "*(?:\." + шИмяСкобкиЛенивые + "?" + шИндекс + "*)*)"
	+ "|(?:" + шЧисло + ")"
	+ "|(?:" + шЛитералПрограммы + ")"
	+ ")";

шПрисвоенноеВыражениеПрограммы = "((новый|New)(?=[\s\(])" // Изменение для поддержки ProgID типа Forms.TextBox.1
	+ "(?:" + шРазделитель + "+(" + шИмя + "))?" + шРазделитель + "*(?:\(\s*(?:(" + шЛитералПрограммы + "|" + шИмяСТочками + шСкобки + "?)|[^\(\)]+)*?(?:\(|\)|$))?"
	//+ "|(" + шИмяСкобки + "?" + шИндекс + "?(?:\." + шИмяСкобки + "?" + шИндекс + "?)*)"
	+ "|(" + шИмяСкобкиЛенивые + "?" + шИндекс + "*(?:\." + шИмяСкобкиЛенивые + "?" + шИндекс + "*)*)" // Заменил на ленивые скобки, т.к. вложенность их может быть иногда большой и тогда надо хотя бы часть параметров захватить
	+ "|(" + шЧисло + ")"
	+ "|(" + шЛитералПрограммы + "(?:\s*\+)?)"
	+ "|" // Пустая строка нужна чтобы посчитать количество присвоений
	+ ")";

шПрисвоение = "(" + шРазделитель + "*=" + шРазделитель + "*(?:(?:Ждать|Await)" + шРазделитель + "+)?" + шПрисвоенноеВыражениеПрограммы + ")";

// Шаблоны запроса
шПараметрЗапроса = "[" + шСимволыПрефиксаПараметра + "][" + шБуква + "][" + шБуква + "\d]*";
шНачалоЛитералаВЗапросе = шЛитералВЗапросе + "?"; // Опасно
шОператорЗапроса = "(?:(?:=|>|<|<>|<=|>=|\*|\/|\+|\-)|" + шРазделитель 
	+ "(?:И|AND|ИЛИ|OR|НЕ|NOT|МЕЖДУ|BETWEEN|ПОДОБНО|LIKE|ССЫЛКА|REFS|(?:ЕСТЬ|IS)" + шРазделитель + "+NULL|В|IN"
	+ "|В" + шРазделитель + "+ИЕРАРХИИ|IN" + шРазделитель + "+HIERARCHY)" + шРазделитель + ")+";
ШаблонВыбора = "(?:ВЫБОР|CASE)" + шЛюбой + "+?(?:КОГДА|WHEN)" + шЛюбой + "+?(?:ТОГДА|THEN)" + шЛюбой + "+?(?:ИНАЧЕ|ELSE)" + шЛюбой + "+?(?:КОНЕЦ|END)";
ШаблонНачалаВыбора = "(?:ВЫБОР|CASE)" + шЛюбой + "+?(?:КОНЕЦ|END)?";
шИмяЗапроса = "(?:" + шИмя + "|\[[^\]]+\])";
шТаблицаЗапроса = "(" + шИмяЗапроса + "\.)*" + шИмяЗапроса + шСкобки + "?";
ШаблонСоединения = шРазделитель + "+((ПРАВОЕ|RIGHT|ЛЕВОЕ|LEFT|ВНУТРЕННЕЕ|INNER|ПОЛНОЕ|FULL|ВНЕШНЕЕ|OUTER)" + шРазделитель + "+)?(?:СОЕДИНЕНИЕ|JOIN)" 
	+ шРазделитель + "+";
	
шОписаниеТаблицы          = "(" + шСкобки + "|" + шТаблицаЗапроса + "|&" + шИмя + ")" + шРазделитель + "+(?:КАК|AS)" + шРазделитель + "+" + шИмяЗапроса;
шОписаниеТаблицыСЗахватом = "(" + шСкобки + "|" + шТаблицаЗапроса + "|&" + шИмя + ")" + шРазделитель + "+(?:КАК|AS)" + шРазделитель + "+(" + шИмяЗапроса + ")";
	
шВыражениеЗапроса = 
	"(?:" + шРазделитель + "*(?:" + шСкобки + "|(?:&|\?|@)" + шИмя + "|" + шЧисло + "|" + шЛитералВЗапросе + "|" + ШаблонВыбора
	//+ "|" + шИмяСкобки + "?" + "(?:\." + шИмяСкобки + "?" + ")*)" + шРазделитель + "*" + шОператорЗапроса + ")*"
	+ "|" + шИмяСкобки + "?" + "(?:\." + шИмяСкобки + "?" + ")*)" + шРазделитель + "*" + шОператорЗапроса + ")*?" // Сделал захват ленивым, чтобы избежать катастрофического шагания назад
	      + шРазделитель + "*(?:" + шСкобки + "|(?:&|\?|@)" + шИмя + "|" + шЧисло + "|" + шЛитералВЗапросе + "|" + ШаблонВыбора
	+ "|" + шИмяСкобки + "?" + "(?:\." + шИмяСкобки + "?" + ")*)";
	
шНачалоВыраженияЗапроса = 
	"(?:" + шРазделитель + "*(?:" + шСкобки + "|(?:&|\?|@)" + шИмя + "|" + шЧисло + "|" + шЛитералВЗапросе + "|" + ШаблонВыбора
	+ "|" + шИмяЗапроса + шСкобки + "?" + "(?:\." + шИмяЗапроса + шСкобки + "?" + ")*)" + шРазделитель + "*" + шОператорЗапроса + ")*?" // Сделал захват ленивым, чтобы избежать катастрофического шагания назад
	      + шРазделитель + "*(?:" + шСкобки + "|(?:&|\?|@)" + шИмя + "|" + шЧисло + "|" + шНачалоЛитералаВЗапросе + "|" + ШаблонНачалаВыбора
	+ "|" + шИмяЗапроса + шСкобки + "?" + "(?:\." + шИмяЗапроса + шСкобки + "?" + ")*)?";
	
шВызовМетодаЗапроса = "()?()?(" + шИмяЗапроса + шСкобки + "?" + "(?:(?:\.(?:" + шИмяЗапроса + ")" + шСкобки + "?)|" + шИндекс + ")*)"
	+ "\(((?:(?:" + шВыражениеЗапроса + ")?" + шРазделитель + "*,)*)" + "(" + шНачалоВыраженияЗапроса + ")?" + шРазделитель + "*";
	
ШаблонОписанияПоля = шВыражениеЗапроса + шРазделитель + "+КАК" + шРазделитель + "+" + шИмяЗапроса;
ШаблонВЫБРАТЬ = "(?:ВЫБРАТЬ|SELECT)(" + шРазделитель + "+(?:РАЗРЕШЕННЫЕ|ALLOWED))?(" + ШаблонОписанияПоля + ",)*" + ШаблонОписанияПоля;
шИЗ = "(?:ИЗ|FROM)" + шРазделитель + "+" + шОписаниеТаблицы + "(" + ШаблонСоединения + шОписаниеТаблицы 
	+ шРазделитель + "+(?:ПО|ON)" + шРазделитель + "+" + шВыражениеЗапроса + "|" + шРазделитель + "*," 
	+ шРазделитель + "*" + шОписаниеТаблицы + ")*";
шПоискОписанияТаблицы = "(" + ШаблонСоединения + ")?(" + шСкобки + "|" + шТаблицаЗапроса + "|&" + шИмя 
	+ ")" + шРазделитель + "+(?:КАК|AS)" + шРазделитель + "+" + "#Идентификатор#(" + шРазделитель 
	+ "+(?:ПО|ON)" + шРазделитель + "+" + шВыражениеЗапроса + "|" + шРазделитель + "|,|;|\)|$)";
	
// К нему привязаны имена методов-трансляторов событий
ИмяКласса = "ПолеТекстаПрограммы";
мМаркерСлужебногоКомментария = "{: ";
мМаркерПорядкаОтладки = "ПорядокОтладки ";
мЭтоАвтоВызов = Ложь;
СброситьРезультатРазбораПозицииВТексте();    

мАнглийский1С = Метаданные.ВариантВстроенногоЯзыка = Метаданные.СвойстваОбъектов.ВариантВстроенногоЯзыка.Английский; 
