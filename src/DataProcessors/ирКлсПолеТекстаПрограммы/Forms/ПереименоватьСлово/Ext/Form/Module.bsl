Перем ПолеТекстаОбласти;
Перем мСмещениеНачалаТела;

// @@@.КЛАСС.ПолеТекстаПрограммы
// Транслятор обработки событий нажатия на кнопки командной панели в компоненту.
// Является обязательным.
//
// Параметры:
//  Кнопка       - КнопкаКоманднойПанели.
//
Процедура КлсПолеТекстаПрограммыНажатие(Кнопка)
	#Если Сервер И Не Сервер Тогда
		ПолеТекстаОбласти = Обработки.ирКлсПолеТекстаПрограммы.Создать();
	#КонецЕсли
	РезультатНажатия = ПолеТекстаОбласти.Нажатие(Кнопка);
КонецПроцедуры

Процедура ПередОткрытием(Отказ, СтандартнаяОбработка)
	ЭтаФорма.СтароеСлово = ТекущееОбъектноеВыражение();
	Если Ложь
		Или Не ЗначениеЗаполнено(СтароеСлово)
		Или Найти(СтароеСлово, ".") > 0
	Тогда
		Отказ = Истина;
		Возврат;
	КонецЕсли;
	ЭтаФорма.ЛиМетод = Прав(СтароеСлово, 1) = "(";
	Если ЛиМетод Тогда
		// Ветка чтобы обязательно заполнился полный контекст модуля. Иначе сработает урезанный контекст через ЛиВЗаголовкеМетода()
		ТаблицаТиповКонтекста = ТаблицаТиповТекущегоВыражения();
		ЭтотОбъект.мМетодМодуля = Неопределено;
	Иначе
		РазобратьТекущийКонтекст(,,, мКонечнаяСтрока + 1, 1);
	КонецЕсли;
	ЗаполнитьТаблицуСлов(ТаблицаТиповКонтекста, Ложь, Ложь, Ложь, Ложь);
	Если ЛиМетод Тогда
		ЭтаФорма.СтароеСлово = ирОбщий.СтрокаБезКонцаЛкс(СтароеСлово);
		СловоМодуля = мМодульМетаданных.Методы.НайтиСтроки(Новый Структура("НИмя", НРег(СтароеСлово)));
		Если СловоМодуля.Количество() > 0 Тогда
			СловоМодуля = СловоМодуля[0];
		Иначе
			СловоМодуля = Неопределено;
		КонецЕсли;
	КонецЕсли;
	ОписаниеСлова = ТаблицаСлов.НайтиСтроки(Новый Структура("НСлово, ТипСлова", НРег(СтароеСлово), ?(ЛиМетод, "Метод", "Свойство")));
	Если ОписаниеСлова.Количество() > 0 Тогда
		ОписаниеСлова = ОписаниеСлова[0];
	Иначе
		ОписаниеСлова = ТаблицаСлов.НайтиСтроки(Новый Структура("НСлово, ТипСлова", НРег(СтароеСлово), "Конструкция"));
		Если ОписаниеСлова.Количество() > 0 Тогда
			ОписаниеСлова = ОписаниеСлова[0];
		Иначе
			ОписаниеСлова = Неопределено;
		КонецЕсли;
	КонецЕсли;
	Если Истина
		И ОписаниеСлова <> Неопределено
		И ОписаниеСлова.ТипСлова = "Конструкция"
	Тогда
		Отказ = Истина;
		Возврат;
	КонецЕсли;
	Если ОписаниеСлова <> Неопределено Тогда
		ЭтаФорма.Определение = ОписаниеСлова.Определение;
	Иначе
		ЭтаФорма.Определение = "Неизвестно";
	КонецЕсли;
	Если Определение = "Метаданные" Тогда
		Если Не ЛиМетод Тогда
			СловоМодуля = мМодульМетаданных.Переменные.НайтиСтроки(Новый Структура("НИмя", НРег(СтароеСлово)));
			Если СловоМодуля.Количество() > 0 Тогда
				СловоМодуля = СловоМодуля[0];
			Иначе
				СловоМодуля = Неопределено;
			КонецЕсли;
		КонецЕсли;
		Если СловоМодуля <> Неопределено Тогда
			ЭтаФорма.Определение = "Модуль";
			Если СловоМодуля.ЛиЭкспорт Тогда
				ЭлементыФормы.ЛиЭкспорт.Видимость = Истина;
			КонецЕсли;
		Иначе
			ЭлементыФормы.ЛиЭкспорт.Видимость = Истина;
		КонецЕсли;
	КонецЕсли;
	ЭлементыФормы.НадписьТипОпределения.Заголовок = "Принадлежность: " + Определение;
	Если Определение = "Предопределенный" Тогда
		ЭлементыФормы.НадписьТипОпределения.ЦветТекста = WebЦвета.Красный;
	ИначеЕсли Определение = "Метаданные" Тогда
		ЭлементыФормы.НадписьТипОпределения.ЦветТекста = WebЦвета.Синий;
	КонецЕсли;
	ЭтаФорма.НовоеСлово = СтароеСлово;
	Вхождения = ВхожденияСлова(СтароеСлово);
	Если Вхождения.Количество() = 0 Тогда
		Отказ = Истина;
		Возврат;
	КонецЕсли;
	ПолеТекстаОбласти = ирОбщий.СоздатьОбъектПоИмениМетаданныхЛкс("Обработка.ирКлсПолеТекстаПрограммы");
	#Если Сервер И Не Сервер Тогда
		ПолеТекстаОбласти = Обработки.ирКлсПолеТекстаПрограммы.Создать();
	#КонецЕсли
	ПолеТекстаОбласти.Инициализировать(, ЭтаФорма, ЭлементыФормы.ПолеТекстаОбласти);
	мСмещениеНачалаТела = 0;
	Если мМетодМодуля <> Неопределено Тогда
		мСмещениеНачалаТела = мМетодМодуля.ПозицияТела - мМетодМодуля.ПозицияСОписанием;
	КонецЕсли;
	Если Не ЛиМетод Тогда
		ВсеПрисвоения = Новый СписокЗначений;
		ВычислитьТипЗначенияВыражения(СтароеСлово,,, Истина,,,,,,,,,,,, ВсеПрисвоения);
		СтроитьДеревоПрограммныхСкобок(ОпределениеАктивногоМетодаСОписанием(),, мПозицияВБлоке + мСмещениеНачалаТела, Области);
		Области.Сортировать("ПозицияНачала");
		ПредСтрока = Неопределено;
		СтрокаОбласти = Области.Вставить(0);
		СтрокаОбласти.Область = "<Метод>";
		СтрокаОбласти.ПозицияНачала = 1;
		СтрокаОбласти.ПозицияКонца = 1 + СтрДлина(ОпределениеАктивногоМетодаСОписанием());
		СтрокиКУдалению = Новый Массив;
		Для Каждого СтрокаОбласти Из Области Цикл
			СтрокаОбласти.ПозицияНачала = мПозицияТекстаДляПоискаОпределения - мСмещениеНачалаТела + СтрокаОбласти.ПозицияНачала;
			СтрокаОбласти.ПозицияКонца = мПозицияТекстаДляПоискаОпределения - мСмещениеНачалаТела + СтрокаОбласти.ПозицияКонца;
			СтрокаОбласти.НайденоСтарое = ПосчитатьВхожденияОбласти(Вхождения, СтрокаОбласти, ВсеПрисвоения);
			Если ПредСтрока <> Неопределено И ПредСтрока.НайденоСтарое = СтрокаОбласти.НайденоСтарое Тогда
				ЭлементыФормы.Области.ТекущаяСтрока = СтрокаОбласти;
				//СтрокиКУдалению.Добавить(ПредСтрока); // Там могут быть использования нового имени. Поэтому нельзя удалять
			КонецЕсли;
			Если ПредСтрока <> Неопределено И ПустаяСтрока(СтрокаОбласти.СтрокаВозможногоСоздания) Тогда
				Для ИндексСтроки = Макс(2, Области.Индекс(СтрокаОбласти)) По Области.Количество() - 1 Цикл
					Области.Удалить(Области.Количество() - 1);
				КонецЦикла;
				Прервать;
			КонецЕсли;
			ПредСтрока = СтрокаОбласти;
		КонецЦикла;
		Для Каждого Строка Из СтрокиКУдалению Цикл
			Области.Удалить(Строка);
		КонецЦикла;
	КонецЕсли;
	Если Ложь
		Или ЛиМетод
		Или Определение = "Модуль"
		Или Определение = "Метаданные"
	Тогда
		СтрокаОбласти = Области.Вставить(0);
		СтрокаОбласти.Область = "<Модуль>";
		СтрокаОбласти.ПозицияНачала = 1;
		СтрокаОбласти.ПозицияКонца = СтрДлина(мОригинальныйТекст);
		СтрокаОбласти.НайденоСтарое = Вхождения.Количество();
	КонецЕсли;
	Если ЭлементыФормы.Области.ТекущаяСтрока = Неопределено Тогда
		ЭлементыФормы.Области.ТекущаяСтрока = Области[0];
	КонецЕсли;
КонецПроцедуры

//.
// Параметры:
//   Вхождения - ТаблицаЗначений -
//   СтрокаОбласти - СтрокаТаблицыЗначений -
//   ВсеПрисвоения - СписокЗначений -
// Возвращаемое значение:
//   Число -
Функция ПосчитатьВхожденияОбласти(Знач Вхождения, Знач СтрокаОбласти, Знач ВсеПрисвоения = Неопределено) Экспорт
	ЧислоВхождений = 0;
	Для Каждого Вхождение Из Вхождения Цикл
		ПозицияВхождения = Вхождение.ПозицияВхождения + 1;
		Если Истина
			И ПозицияВхождения >= СтрокаОбласти.ПозицияНачала
			И ПозицияВхождения < СтрокаОбласти.ПозицияКонца
		Тогда
			Если ЧислоВхождений = 0 И ВсеПрисвоения <> Неопределено Тогда
				ПодходящееПрисвоение = НайтиПрисвоениеДляВхождения(Вхождение, ВсеПрисвоения);
				Если ПодходящееПрисвоение <> Неопределено Тогда
					СтрокаОбласти.СтрокаВозможногоСоздания = СокрЛП(ПодходящееПрисвоение.Представление);
					Если Лев(СтрокаОбласти.СтрокаВозможногоСоздания, 1) = ";" Тогда
						СтрокаОбласти.СтрокаВозможногоСоздания = СокрЛ(Сред(СтрокаОбласти.СтрокаВозможногоСоздания, 2));
					КонецЕсли;
					СтрокаОбласти.ПозицияПервогоПрисвоения = мПозицияТекстаДляПоискаОпределения + ПодходящееПрисвоение.Значение - СтрокаОбласти.ПозицияНачала - 1;
				КонецЕсли;
			КонецЕсли;
			ЧислоВхождений = ЧислоВхождений + 1;
		КонецЕсли;
		Если Истина
			И ЗначениеЗаполнено(СтрокаОбласти.СтрокаВозможногоСоздания)
			И ПозицияВхождения > СтрокаОбласти.ПозицияКонца
			И ПозицияВхождения < Области[0].ПозицияКонца
			И ВсеПрисвоения <> Неопределено
		Тогда
			ПодходящееПрисвоение = НайтиПрисвоениеДляВхождения(Вхождение, ВсеПрисвоения);
			Если ПодходящееПрисвоение = Неопределено Тогда
				СтрокаОбласти.СтрокаВозможногоСоздания = "";
				СтрокаОбласти.ПозицияПервогоПрисвоения = 0;
			КонецЕсли;
			Прервать;
		КонецЕсли;
	КонецЦикла;
	Возврат ЧислоВхождений;
КонецФункции

//.
// Параметры:
//    Вхождение - СтрокаТаблицыЗначений -
//    ВсеПрисвоения - СписокЗначений -
// Возвращаемое значение:
//    ЭлементСпискаЗначений -
Функция НайтиПрисвоениеДляВхождения(Знач Вхождение, Знач ВсеПрисвоения) Экспорт
	ПодходящееПрисвоение = Неопределено;
	Для Каждого Присвоение Из ВсеПрисвоения Цикл
		Если Истина
			И мПозицияТекстаДляПоискаОпределения + Присвоение.Значение < Вхождение.ПозицияВхождения
			И мПозицияТекстаДляПоискаОпределения + Присвоение.Значение + СтрДлина(Присвоение.Представление) > Вхождение.ПозицияВхождения + Вхождение.ДлинаВхождения
		Тогда
			// Проверим что справа от "=" нет чтения этой же переменной
			ПозицияРавно = Вхождение.ПозицияВхождения + 1 + СтрДлина(СтароеСлово) + 1;
			ОстатокПрисвоения = Сред(мОригинальныйТекст, ПозицияРавно, мПозицияТекстаДляПоискаОпределения + Присвоение.Значение + СтрДлина(Присвоение.Представление) - ПозицияРавно);
			Если ирОбщий.СтрНайтиСловоЛкс(ОстатокПрисвоения, СтароеСлово) = Неопределено Тогда
				ПодходящееПрисвоение = Присвоение;
				Прервать;
			КонецЕсли;
		КонецЕсли;
	КонецЦикла;
	Возврат ПодходящееПрисвоение;
КонецФункции

Процедура ПриОткрытии()
	ирКлиент.Форма_ПриОткрытииЛкс(ЭтаФорма);
	Если ЛиМетод Тогда
		ЭтаФорма.Заголовок = ирОбщий.СтрЗаменитьЛкс(Заголовок, "слово", "метод");
	КонецЕсли;
КонецПроцедуры

Процедура ПриЗакрытии()
	ирКлиент.Форма_ПриЗакрытииЛкс(ЭтаФорма);
КонецПроцедуры

Процедура ВнешнееСобытие(Источник, Событие, Данные) Экспорт
	ирКлиент.Форма_ВнешнееСобытиеЛкс(ЭтаФорма, Источник, Событие, Данные);
КонецПроцедуры

Процедура НайтиСтарое(Элемент = Неопределено)
	НайтиСлово(СтароеСлово);
КонецПроцедуры

Процедура НайтиНовое(Элемент = Неопределено)
	НайтиСлово(НовоеСлово);
КонецПроцедуры

Процедура НайтиСлово(Знач ЧтоИскать, Знач ИскатьСНачала = Ложь) Экспорт
	ТекущаяОбласть = ЭлементыФормы.Области.ТекущаяСтрока;
	Если Не ПолеТекстаОбласти.НайтиПоказатьСловоВТексте(ЧтоИскать, ШаблонПоискаСлова(ЧтоИскать),, Истина, ИскатьСНачала,,, ТекущаяОбласть.ПозицияКонца - ТекущаяОбласть.ПозицияНачала) Тогда
		ПолеТекстаОбласти.НайтиПоказатьСловоВТексте(ЧтоИскать, ШаблонПоискаСлова(ЧтоИскать),, Истина, Истина,,, ТекущаяОбласть.ПозицияКонца - ТекущаяОбласть.ПозицияНачала);
	КонецЕсли;
КонецПроцедуры

Функция ВхожденияСлова(Слово)
	Вхождения = ирОбщий.НайтиРегВыражениеЛкс(мОригинальныйТекст, ШаблонПоискаСлова(Слово),,,,,,,, Истина);
	Возврат Вхождения;
КонецФункции

Функция ШаблонПоискаСлова(Слово)
	ДоступнаОбластьМодуль = Ложь
		Или ЛиМетод
		Или Определение = "Модуль"
		Или Определение = "Метаданные";
	Результат = ирОбщий.ШаблонПоискаСловаЛкс(Слово, ШаблонШаблонаПоискаСлова(ЛиМетод, ДоступнаОбластьМодуль));
	Возврат Результат;
КонецФункции

Процедура ОсновныеДействияФормыПрименитьИЗакрыть(Кнопка)
	Если Не ЗначениеЗаполнено(НовоеСлово) Тогда
		Предупреждение("Нужно указать новое имя");
		Возврат;
	КонецЕсли;
	Если Не ирОбщий.ЛиИмяПеременнойЛкс(НовоеСлово) Тогда
		Предупреждение("Некорректное новое имя");
		Возврат;
	КонецЕсли;
	ВыделениеДвумерное = ПолеТекста.ВыделениеДвумерное();
	ТекущаяОбласть = ЭлементыФормы.Области.ТекущаяСтрока;
	Если Истина
		И мМетодМодуля <> Неопределено
		И ТекущаяОбласть.Область = "<Метод>"
	Тогда
		АнализаторКода = ПолеТекстаОбласти;
		НачалоОбластиВТексте = 0;
		КонецОбластиВТексте = Неопределено;
	Иначе
		АнализаторКода = ЭтотОбъект;
		НачалоОбластиВТексте = мПозицияТекстаДляПоискаОпределения - мСмещениеНачалаТела;
		КонецОбластиВТексте = мПозицияТекстаДляПоискаОпределения + СтрДлина(мТекстБлока) + 1;
	КонецЕсли;
	Если АнализаторКода.НайтиПоказатьСловоВТексте(НовоеСлово, ШаблонПоискаСлова(НовоеСлово),, Истина, Истина,, НачалоОбластиВТексте, КонецОбластиВТексте) Тогда
		Ответ = Вопрос("Новое имя уже используется в области. Продолжить?", РежимДиалогаВопрос.ОКОтмена);
		Если Ответ <> КодВозвратаДиалога.ОК Тогда
			Возврат;
		КонецЕсли;
	КонецЕсли;
	Если Не ЛиМетод Тогда
		СловоМодуля = мМодульМетаданных.Переменные.НайтиСтроки(Новый Структура("НИмя", НРег(НовоеСлово)));
		Если СловоМодуля.Количество() > 0 Тогда
			Ответ = Вопрос("Новое имя уже используется в модуле. Продолжить?", РежимДиалогаВопрос.ОКОтмена);
			Если Ответ <> КодВозвратаДиалога.ОК Тогда
				Возврат;
			КонецЕсли;
		КонецЕсли;
	Иначе
		СловоМодуля = мМодульМетаданных.Методы.НайтиСтроки(Новый Структура("НИмя", НРег(НовоеСлово)));
		Если СловоМодуля.Количество() > 0 Тогда
			Предупреждение("Новое имя уже используется в модуле. Укажите уникальное имя.");
			Возврат;
		КонецЕсли;
	КонецЕсли;
	ВыполнитьЗамену(ЭтотОбъект,, ВыделениеДвумерное);
	Если ФормаВладелец = Неопределено Тогда
		ЭтаФорма.ВесьМодульИзменен = ТекущаяОбласть.Область = "<Модуль>";
		мЗаменяемыйДиапазон = НовыйЗаменяемыйДиапазон();
		мЗаменяемыйДиапазон.Начало = 1;
		мЗаменяемыйДиапазон.Конец = СтрДлина(мОригинальныйТекст) + 1;
		ИндексМетода = Неопределено;
		Если ТекущаяОбласть.Область = "<Модуль>" Тогда
			//
		ИначеЕсли мМетодМодуля <> Неопределено Тогда
			ИндексМетода = мМодульМетаданных.Методы.Индекс(мМетодМодуля);
			мЗаменяемыйДиапазон.Начало = мМетодМодуля.ПозицияСОписанием;
			мЗаменяемыйДиапазон.Конец = мМетодМодуля.ПозицияСОписанием + мМетодМодуля.ДлинаСОписанием;
		Иначе
			мЗаменяемыйДиапазон.Начало = мМодульМетаданных.ПозицияПрограммы;
		КонецЕсли;
		РазобратьТекущийКонтекст();
		Если ТекущаяОбласть.Область = "<Модуль>" Тогда
			мЗамещающийФрагмент = мОригинальныйТекст;
		ИначеЕсли ИндексМетода <> Неопределено Тогда
			СтрокаМетода = мМодульМетаданных.Методы[ИндексМетода];
			мЗамещающийФрагмент = Сред(мОригинальныйТекст, СтрокаМетода.ПозицияСОписанием, СтрокаМетода.ДлинаСОписанием);
		Иначе
			мЗамещающийФрагмент = Сред(мОригинальныйТекст, мМодульМетаданных.ПозицияПрограммы);
		КонецЕсли;
		//ПолеТекста.УстановитьГраницыВыделения(ПозицияНачала, ПозицияКонца);
	КонецЕсли;
	Закрыть(ЭтаФорма);
КонецПроцедуры

//.
// Параметры:
//    ПолеТекстаПрограммы - ОбработкаОбъект.ирКлсПолеТекстаПрограммы -
Функция ВыполнитьЗамену(Знач ПолеТекстаПрограммы, Знач АвтоНовоеСлово = Ложь, Знач ВыделениеДвумерное = Неопределено) Экспорт
	Перем НовоеСлово;
	НовоеСлово = ЭтаФорма.НовоеСлово;
	Если АвтоНовоеСлово И НовоеСлово = СтароеСлово Тогда
		НовоеСлово = "Новое" + НовоеСлово;
	КонецЕсли;
	Если ВыделениеДвумерное = Неопределено Тогда
		ВыделениеДвумерное = ПолеТекстаПрограммы.ПолеТекста.ВыделениеДвумерное();
	КонецЕсли;
	ТекущаяОбласть = ЭлементыФормы.Области.ТекущаяСтрока;
	Если ПолеТекстаПрограммы = ЭтотОбъект Тогда
		НачалоОбластиВМодуле = ТекущаяОбласть.ПозицияНачала;
		КонецОбластиВМодуле = ТекущаяОбласть.ПозицияКонца;
	Иначе
		УстановитьТекстПоляОбласти();
		ПолеТекстаПрограммы.ПолеТекста.ТолькоПросмотр(Ложь);
		НачалоОбластиВМодуле = 1;
		КонецОбластиВМодуле = СтрДлина(ПолеТекстаПрограммы.ПолеТекста.ПолучитьТекст());
	КонецЕсли;
	РазницаДлинСлова = СтрДлина(НовоеСлово) - СтрДлина(СтароеСлово);
	ПолеТекстаПрограммы.УстановитьГраницыВыделения(НачалоОбластиВМодуле, НачалоОбластиВМодуле);
	Пока ПолеТекстаПрограммы.НайтиПоказатьСловоВТексте(СтароеСлово, ШаблонПоискаСлова(СтароеСлово),,, Ложь,, НачалоОбластиВМодуле, КонецОбластиВМодуле) Цикл
		НовоеВыражение = ирОбщий.СтрокаБезПоследнегоФрагментаЛкс(ПолеТекстаПрограммы.ВыделенныйТекст());
		Если ЗначениеЗаполнено(НовоеВыражение) Тогда
			НовоеВыражение = НовоеВыражение + "." + НовоеСлово;
		Иначе
			НовоеВыражение = НовоеСлово;
		КонецЕсли;
		ПолеТекстаПрограммы.ВыделенныйТекст(НовоеВыражение);
		КонецОбластиВМодуле = КонецОбластиВМодуле + РазницаДлинСлова;
	КонецЦикла;
	Если ПолеТекстаПрограммы = ПолеТекстаОбласти Тогда
		ПолеТекстаПрограммы.ПолеТекста.ТолькоПросмотр(Истина);
	КонецЕсли;
	ПолеТекстаПрограммы.ПолеТекста.УстановитьВыделениеДвумерное(ВыделениеДвумерное);
	Возврат ВыделениеДвумерное;
КонецФункции

Процедура УстановитьТекстПоляОбласти(ВыделениеДвумерное = Неопределено)
	ТекущаяОбласть = ЭлементыФормы.Области.ТекущаяСтрока;
	ПолеТекстаОбласти.УстановитьТекст(Сред(мОригинальныйТекст, ТекущаяОбласть.ПозицияНачала, ТекущаяОбласть.ПозицияКонца - ТекущаяОбласть.ПозицияНачала));
	Если ВыделениеДвумерное <> Неопределено Тогда
		ПолеТекстаОбласти.ПолеТекста.УстановитьВыделениеДвумерное(ВыделениеДвумерное);
	КонецЕсли;
КонецПроцедуры

Процедура НовоеСловоПриИзменении(Элемент)
	ирКлиент.ПолеВводаСИсториейВыбора_ПриИзмененииЛкс(Элемент, ЭтаФорма);
	Вхождения = ВхожденияСлова(НовоеСлово);
	Для Каждого СтрокаОбласти Из Области Цикл
		СтрокаОбласти.НайденоНовое = ПосчитатьВхожденияОбласти(Вхождения, СтрокаОбласти);
	КонецЦикла;
	Если ЭлементыФормы.Области.ТекущаяСтрока.НайденоНовое > 0 Тогда
		НайтиСлово(НовоеСлово, Истина);
	КонецЕсли;
КонецПроцедуры

Процедура НовоеСловоНачалоВыбораИзСписка(Элемент, СтандартнаяОбработка)
	ирОбщий.ПолеВводаСИсториейВыбора_ОбновитьСписокЛкс(Элемент, ЭтаФорма);
КонецПроцедуры

Процедура ОбластиПриАктивизацииСтроки(Элемент)
	ирКлиент.ТабличноеПолеПриАктивизацииСтрокиЛкс(ЭтаФорма, Элемент);
	УстановитьТекстПоляОбласти();
КонецПроцедуры

Процедура ОбластиПриВыводеСтроки(Элемент, ОформлениеСтроки, ДанныеСтроки)
	ирКлиент.ТабличноеПолеПриВыводеСтрокиЛкс(ЭтаФорма, Элемент, ОформлениеСтроки, ДанныеСтроки);
КонецПроцедуры

Процедура ОбластиВыбор(Элемент, ВыбраннаяСтрока, Колонка, СтандартнаяОбработка)
	ТекущаяОбласть = ЭлементыФормы.Области.ТекущаяСтрока;
	Если Колонка = ЭлементыФормы.Области.Колонки.НайденоНовое Тогда
		НайтиНовое();
	ИначеЕсли Колонка = ЭлементыФормы.Области.Колонки.СтрокаВозможногоСоздания Тогда
		ПолеТекстаОбласти.УстановитьГраницыВыделения(ВыбраннаяСтрока.ПозицияПервогоПрисвоения, ВыбраннаяСтрока.ПозицияПервогоПрисвоения + СтрДлина(ВыбраннаяСтрока.СтрокаВозможногоСоздания));
		ПолеТекстаОбласти.УстановитьФокус();
	Иначе
		НайтиСтарое();
	КонецЕсли;
КонецПроцедуры

Процедура КоманднаяПанель1Сравнить(Кнопка)
	ТекущаяОбласть = ЭлементыФормы.Области.ТекущаяСтрока;
	ТекстСтарый = Сред(мОригинальныйТекст, ТекущаяОбласть.ПозицияНачала, ТекущаяОбласть.ПозицияКонца - ТекущаяОбласть.ПозицияНачала);
	ВыделениеДвумерное = ВыполнитьЗамену(ПолеТекстаОбласти, Истина);
	ТекстНовый = ПолеТекстаОбласти.ПолеТекста.ПолучитьТекст();
	УстановитьТекстПоляОбласти(ВыделениеДвумерное);
	ирКлиент.Сравнить2ЗначенияВФормеЛкс(ТекстСтарый, ТекстНовый,, "Старый", "Новый",,,,, "ВстроенныйЯзык");
КонецПроцедуры

Процедура КоманднаяПанель1НайтиВызовыМетода(Кнопка = Неопределено)
	ЭтаФорма.Закрыть("НайтиВнешниеСсылки");
	Если РазрешитьОткрыватьОкна Тогда
		ОткрытьПоискВызововСлова(СтароеСлово);
	Иначе
		// Схлопываем выделение, чтобы НЕ включился режим поиска "Точный"
		ВыделениеОдномерное = ПолеТекста.ВыделениеОдномерное();
		УстановитьГраницыВыделения(ВыделениеОдномерное.Начало, ВыделениеОдномерное.Начало);
	КонецЕсли;
КонецПроцедуры

Процедура ЛиЭкспортНажатие(Элемент)
	КоманднаяПанель1НайтиВызовыМетода();
КонецПроцедуры

ирКлиент.ИнициироватьФормуЛкс(ЭтаФорма, "Обработка.ирКлсПолеТекстаПрограммы.Форма.ПереименоватьСлово");
