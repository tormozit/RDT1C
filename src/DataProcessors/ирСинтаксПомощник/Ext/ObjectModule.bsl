//ирПортативный Перем ирПортативный Экспорт;
//ирПортативный Перем ирОбщий Экспорт;
//ирПортативный Перем ирСервер Экспорт;
//ирПортативный Перем ирКэш Экспорт;
//ирПортативный Перем ирКлиент Экспорт;

Перем ФайлСтилейСинтаксПомощника Экспорт;
Перем ЗаменыВнешнихОбъектов;
Перем СоответствиеЗамены;
Перем типСтрока;
Перем СрабатываниеЗамен Экспорт;
Перем РегВыражение;
Перем РегВыражение2;
Перем СодержанияАрхивовСправки Экспорт;
Перем мПлатформа;
Перем мЗапрещен экспорт;
Перем шТег Экспорт;
Перем шТегНеКлюч Экспорт;
Перем шТегКлюч Экспорт;
Перем шКонецТегаКлюч Экспорт;
Перем шТегКлючСлабый Экспорт;
Перем шКонецТегаКлючСлабый Экспорт;
Перем шТип Экспорт;
Перем шТипСтрогий Экспорт;
Перем шТипВложенный экспорт;

Функция РаспаковатьФайлАрхиваСинтаксПомощника(Знач ПутьКЭлементу) Экспорт

	ФайлАрхива = ПолучитьАрхивСинтаксПомощникаПоПутиКЭлементу(ПутьКЭлементу,, Истина);
	Если ФайлАрхива = Неопределено Тогда
		Возврат Неопределено;
	КонецЕсли;
	#Если Сервер И Не Сервер Тогда
		мПлатформа = Обработки.ирПлатформа.Создать();
		ФайлАрхива = Новый Файл;
	#КонецЕсли
	Если Лев(ПутьКЭлементу, 1) = "/" Тогда
		ПутьКЭлементу = Сред(ПутьКЭлементу, 2);
	КонецЕсли;
	МассивФрагментов = ирОбщий.СтрРазделитьЛкс(ПутьКЭлементу, "#");
	ПутьКЭлементу = МассивФрагментов[0];
	ФайлСтраницы = Новый Файл(ПутьКэшаСинтаксПомощника() + ПутьКЭлементу);
	Если Не ФайлСтраницы.Существует() Тогда
		ФайлРаспаковщикаZIP = мПлатформа.ПолучитьФайлРаспаковщикаZIP(Истина);
		#Если Сервер И Не Сервер Тогда
			ФайлРаспаковщикаZIP = Новый Файл;
		#КонецЕсли
		Если ирКэш.ЛиПлатформаWindowsЛкс() Тогда
			// Распаковка асинхронно всего архива
			ПараметрыКоманды = " -o " + ФайлАрхива.Имя;
			ПроцессРаспаковки = ирОбщий.ПолучитьПроцессОСЛкс(,,,,, ПараметрыКоманды);
			Если ТипЗнч(ПроцессРаспаковки) = Тип("COMОбъект") Тогда
				Возврат Неопределено;
			КонецЕсли;
			ПроверочныйФайлБыстрый = Новый Файл(ПутьКэшаСинтаксПомощника() + ФайлАрхива.ИмяБезРасширения + ".chk");
			Если Не ПроверочныйФайлБыстрый.Существует() Тогда
				ЧтениеЗип = Новый ЧтениеZipФайла(ФайлАрхива.ПолноеИмя);
				ПроверочныйФайл = Новый Файл(ПутьКэшаСинтаксПомощника() + ЧтениеЗип.Элементы[0].Путь + ЧтениеЗип.Элементы[0].Имя); // Долго
				Если ПроверочныйФайл.Существует() Тогда
					ТекстовыйДокумент = Новый ТекстовыйДокумент;
					ТекстовыйДокумент.Записать(ПроверочныйФайлБыстрый.ПолноеИмя);
				КонецЕсли;
			КонецЕсли;
			Если ПроверочныйФайлБыстрый.Существует() Тогда
				ПараметрыКоманды = "";
			Иначе
				РазмерАрхиваМБ = Цел(ФайлАрхива.Размер()/1000000);
				ОжидатьЗавершения = РазмерАрхиваМБ = 0;
				Если Не ОжидатьЗавершения Тогда
					ирОбщий.СообщитьЛкс(ирОбщий.СтрШаблонЛкс("Запущена распаковка (1-2 мин) архива %1 %2МБ синтакс-помощника для платформы %3. ", ФайлАрхива.Имя, РазмерАрхиваМБ, ирКэш.НомерВерсииПлатформыЛкс()),,, Истина);
				КонецЕсли;
			КонецЕсли;
		Иначе
			// Распаковка синхронно нужного элемента архива
			ПараметрыКоманды = " -o " + ФайлАрхива.Имя + " """ + ПутьКЭлементу + """";
			ОжидатьЗавершения = Истина;
		КонецЕсли;
		Если ЗначениеЗаполнено(ПараметрыКоманды) Тогда
			// Не используем ЧтениеZipФайла, т.к. оно не поддеживает асинхронность и делает непосредственно распаковку элемента за 130мс, но еще необходимо получение элементов архива (для shcntx_ru занимает 500мс).
			Если ирКэш.ЛиПлатформаWindowsЛкс() И ирКэш.ЛиДоступноВыполнениеКомандныхФайловЛкс() Тогда
				// Так быстрее - для одного элемента было 100-150мс
				ПолноеИмяРаспаковщика = ФайлРаспаковщикаZIP.ПолноеИмя;
				ВК = ирОбщий.ВКОбщаяЛкс(); 
				ВК.Run(ПолноеИмяРаспаковщика, ПараметрыКоманды, ПутьКэшаСинтаксПомощника(), ОжидатьЗавершения, Ложь); // В 8.2 все параметры метода ВК зачем то должны быть доступны на запись https://www.hostedredmine.com/issues/931482
			Иначе
				// Так медленнее - для одного элемента было 200мс
				ирОбщий.ЗапуститьСкрытоеПриложениеИДождатьсяЗавершенияЛкс("""" + ФайлРаспаковщикаZIP.ПолноеИмя + """" + ПараметрыКоманды, ПутьКэшаСинтаксПомощника(),, ОжидатьЗавершения);
			КонецЕсли; 
			Если Не ОжидатьЗавершения Тогда
				Возврат Неопределено;
			КонецЕсли;
		КонецЕсли;
		Если Не ФайлСтраницы.Существует() Тогда
			ирОбщий.СообщитьЛкс("Синтаксический элемент в текущей версии платформы не поддерживается", СтатусСообщения.Внимание);
			Возврат Неопределено;
		КонецЕсли;
	КонецЕсли; 
	ВременныйАдрес = ФайлСтраницы.ПолноеИмя;
	Если МассивФрагментов.Количество() > 1 Тогда
		ВременныйАдрес = ВременныйАдрес + "#" + МассивФрагментов[1];
	КонецЕсли; 
	Возврат ВременныйАдрес;

КонецФункции

Функция ФайлСтилейСинтаксПомощника() Экспорт 

	Если ФайлСтилейСинтаксПомощника = Неопределено Тогда 
		ФайлСтилейСинтаксПомощника = Новый Файл(ПолучитьИмяВременногоФайла("css"));
		ТекстовыйДокумент = ПолучитьМакет("СтилиСинтаксПомощника");
		ТекстовыйДокумент.Вывод = ИспользованиеВывода.Разрешить;
		ТекстовыйДокумент.Записать(ФайлСтилейСинтаксПомощника.ПолноеИмя);
	КонецЕсли;
	Возврат ФайлСтилейСинтаксПомощника;

КонецФункции

// Получает zip-архив синтакс-помощника из файла "shcntx_ru.hbk" в каталоге установки платформы.
//
// Параметры:
//  ЭлементСтруктуры - Число, *0 - 0 - архив страниц, 1 - содержание книги, 2 - индекс книги
//
Функция АрхивСинтаксПомощникаПоИмени(ЭлементСтруктуры = 0, ИмяАрхива = "shcntx_ru") Экспорт

	Если мЗапрещен Тогда
		Возврат Неопределено;
	КонецЕсли;
	Если Не ирКэш.ЛиДоступноВыполнениеКомандныхФайловЛкс() Тогда
		// https://www.hostedredmine.com/issues/997647
		ирОбщий.СообщитьЛкс("Работа синтакс-помощника отключена из-за запрета выполнения командных файлов");
		мЗапрещен = Истина;
		Возврат Неопределено;
	КонецЕсли;
	мПлатформа = ирКэш.Получить();
	#Если Сервер И Не Сервер Тогда
		мПлатформа = Обработки.ирПлатформа.Создать();
	#КонецЕсли
	КлючСтруктуры = "_" + ИмяАрхива + ЭлементСтруктуры;
	ФайлАрхива = Новый Файл(ПутьКэшаСинтаксПомощника() + КлючСтруктуры + ".zip");
	Если Не ФайлАрхива.Существует() Тогда
		Если ЭлементСтруктуры = 0 Тогда
			ИмяБлока = "FileStorage.data";
		ИначеЕсли ЭлементСтруктуры = 1 Тогда
			ИмяБлока = "PackBlock.data";
		ИначеЕсли ЭлементСтруктуры = 2 Тогда
			ИмяБлока = "IndexPackBlock.data";
		КонецЕсли; 
		ИмяФайлаПлатформы = ИмяАрхива + ".hbk";
		ТекущийКаталог = КаталогВременныхФайлов();
		ФайлПлатформы = Новый Файл(КаталогПрограммы() + ИмяФайлаПлатформы);
		Если Не ФайлПлатформы.Существует() Тогда
			ирОбщий.СообщитьЛкс("Работа синтакс-помощника отключена из-за отсутствия русских файлов платформы");
			мЗапрещен = Истина;
			Возврат Неопределено;
		КонецЕсли;
		ФайлБлока = Новый Файл(ТекущийКаталог + ИмяБлока);
		#Если Клиент Тогда
		Состояние("Распаковка синтакс-помощника");
		#КонецЕсли 
		мПлатформа.РаспаковатьФайлВнешнейОбработки(ФайлПлатформы.ПолноеИмя, ТекущийКаталог);
		Если Не ФайлБлока.Существует() Тогда
			// Если файл залочен на чтение (открыт синтакс-помощник в конфигураторе)
			КопияФайлаПлатформы = Новый Файл(ПолучитьИмяВременногоФайла());
			КопироватьФайл(ФайлПлатформы.ПолноеИмя, КопияФайлаПлатформы.ПолноеИмя);
			//ФайлПлатформы = Новый Файл(мПлатформа.ПолучитьИмяФайлаВФорматеDOS(КопияФайлаПлатформы.ПолноеИмя)); не работае в 64б процессе
			ФайлПлатформы = КопияФайлаПлатформы;
			ФайлБлока = Новый Файл(ТекущийКаталог + ИмяБлока);
			мПлатформа.РаспаковатьФайлВнешнейОбработки(ФайлПлатформы.ПолноеИмя, ТекущийКаталог);
			Если Не ФайлБлока.Существует() Тогда 
				ирОбщий.СообщитьЛкс("Ошибка выполнения приложения V8unpack");
				Возврат Неопределено;
			КонецЕсли;
		КонецЕсли;
		ПереместитьФайл(ФайлБлока.ПолноеИмя, ФайлАрхива.ПолноеИмя);
		УдалитьФайлы(ТекущийКаталог + Лев(ФайлПлатформы.ИмяБезРасширения, 8));
		#Если Клиент Тогда
		Состояние("");
		#КонецЕсли 
	КонецЕсли;
	Возврат ФайлАрхива;

КонецФункции

Функция ПутьКэшаСинтаксПомощника() Экспорт
	
	Результат = ирКэш.КаталогИзданияПлатформыВПрофилеЛкс() + ирОбщий.РазделительПутиКФайлуЛкс() + "Syntax1C_" + XMLСтрока(ирКэш.НомерВерсииПлатформыЛкс());
	СоздатьКаталог(Результат);
	Возврат Результат + ирОбщий.РазделительПутиКФайлуЛкс();

КонецФункции

Функция ПрочитатьИндексЯзыкаСинтаксПомощника(ЯзыкПрограммы) Экспорт 
	
	Результат = Неопределено;
	ФайлИндекса = Новый Файл(ПутьКэшаСинтаксПомощника() + "Язык" + ЯзыкПрограммы + ".idx");
	Если ФайлИндекса.Существует() Тогда
		Результат = ЗначениеИзФайла(ФайлИндекса.ПолноеИмя);
		Результат = Результат.Индекс;
	КонецЕсли;
	Возврат Результат;
	
КонецФункции

Процедура ЗаписатьИндексЯзыкаСинтаксПомощника(ЯзыкПрограммы, ТаблицаИндекса) Экспорт 
	
	ФайлИндекса = Новый Файл(ПутьКэшаСинтаксПомощника() + "Язык" + ЯзыкПрограммы + ".idx");
	Результат = Новый Структура;
	Результат.Вставить("Индекс", ТаблицаИндекса);
	ЗначениеВФайл(ФайлИндекса.ПолноеИмя, Результат);
	
КонецПроцедуры

// 
//
// Параметры:
//  ПутьКЭлементу  - Строка - модифицируется
//  ИмяАрхива    - Строка - входное значение игнорируется, на выход подается вычисленное имя файла архива;
//
Функция ПолучитьАрхивСинтаксПомощникаПоПутиКЭлементу(ПутьКЭлементу, ЭлементСтруктуры = 0, ЛиОбрезатьПутьДоОтносительного = Ложь, ИмяАрхива = "") Экспорт

	МаркерДопАрхива = "//";
	Если Найти(ПутьКЭлементу, МаркерДопАрхива) = 1 Тогда
		ИмяАрхива = ирОбщий.ПервыйФрагментЛкс(Сред(ПутьКЭлементу, СтрДлина(МаркерДопАрхива) + 1), "/");
		Если ЛиОбрезатьПутьДоОтносительного Тогда
			ПутьКЭлементу = Сред(ПутьКЭлементу, СтрДлина(МаркерДопАрхива) + 1 + СтрДлина(ИмяАрхива) + 1);
		КонецЕсли;
		ФайлАрхива = АрхивСинтаксПомощникаПоИмени(ЭлементСтруктуры, ИмяАрхива);
	Иначе
		ФайлАрхива = АрхивСинтаксПомощникаПоИмени(ЭлементСтруктуры);
	КонецЕсли;
	Возврат ФайлАрхива;

КонецФункции

// Загрузить описание метода (все варианты)
//
// Параметры:
//  ТипКонтекста		 - 	 - 
//  ИмяМетода			 - 	 - 
//  ОписаниеХТМЛ		 - 	 - 
//  ТипСлова			 - 	 - 
//  ЯзыкПрограммы		 - 	 - 
//  ТаблицаПараметров	 - 	 - 
//  РабочийКаталог		 - 	 -
//  СтрокаОписанияМетода - 	 - 
//  ОписаниеМетода		 - 	 - 
// 
// Возвращаемое значение:
//  Число - количество параметров
//
Функция ЗагрузитьОписаниеМетода(Знач ТипКонтекста, Знач ИмяМетода, Знач ОписаниеХТМЛ, Знач ТипСлова = "Метод", Знач ЯзыкПрограммы = 0, Знач ТаблицаПараметров = Неопределено, Знач РабочийКаталог = "",
	Знач СтрокаОписанияМетода = Неопределено, ОписаниеМетода = "") Экспорт 
	
	мПлатформа = ирКэш.Получить();
	#Если Сервер И Не Сервер Тогда
		мПлатформа = Обработки.ирПлатформа.Создать();
	#КонецЕсли
	Если ТаблицаПараметров = Неопределено Тогда
		ТаблицаПараметров = мПлатформа.ТаблицаПараметров;
	КонецЕсли;
	#Если Сервер И Не Сервер Тогда
		ТаблицаПараметров = Новый ТаблицаЗначений;
	#КонецЕсли
	Если ЯзыкПрограммы = 2 Тогда
		шКлюч = шТегКлюч;
		шКонецКлюча = шКонецТегаКлюч;
	Иначе
		шКлюч = шТегКлючСлабый;
		шКонецКлюча = шКонецТегаКлючСлабый;
	КонецЕсли;
	ТекстовыйДокумент = Новый ТекстовыйДокумент;
	РегВыражение.IgnoreCase = Истина;
	РегВыражение.Global = Истина;
	РегВыражение.Pattern = шКлюч + "Доступность:" + шКонецКлюча ;
	ВхожденияДоступности = РегВыражение.НайтиВхождения(ОписаниеХТМЛ);
	ОписаниеДоступности = "";
	Если ВхожденияДоступности.Количество() > 0 Тогда
		ОписаниеДоступности = Сред(ОписаниеХТМЛ, ВхожденияДоступности[0].FirstIndex + 1);
		ОписаниеДоступности = ирОбщий.ПервыйФрагментЛкс(ОписаниеДоступности, "Методическая информация");
	КонецЕсли;
	РегВыражение.Pattern = шКлюч + "Вариант синтаксиса:\s*([^<""]+)" + шКонецКлюча;
	ВхожденияВариантов = РегВыражение.НайтиВхождения(ОписаниеХТМЛ);
	ОписанияВариантов = Новый СписокЗначений;
	Если ВхожденияВариантов.Количество() = 0 Тогда
		ОписанияВариантов.Добавить(ОписаниеХТМЛ);
	Иначе
		ТекущаяПозиция = 1;
		ТекущийВариант = "";
		Для Каждого Вхождение Из ВхожденияВариантов Цикл
			Если ТекущаяПозиция > 1 Тогда
				ОписанияВариантов.Добавить(Сред(ОписаниеХТМЛ, ТекущаяПозиция, Вхождение.FirstIndex - ТекущаяПозиция), ТекущийВариант);
			КонецЕсли; 
			ТекущаяПозиция = Вхождение.FirstIndex;
			ТекущийВариант = Вхождение.SubMatches(0);
		КонецЦикла;
		ОписанияВариантов.Добавить(Сред(ОписаниеХТМЛ, ТекущаяПозиция), Вхождение.SubMatches(0));
	КонецЕсли;
	МаксНомерПараметра = 0;
	Для Каждого ЭлементСписка Из ОписанияВариантов Цикл
		ОписаниеВарианта = ЭлементСписка.Значение;
		РегВыражение.Pattern = "(?:Возвращаемое значение:.*?" + шКлюч + "+)?Описание(?: варианта метода)?:?" + шКонецКлюча + "+(?:.*?)(?:\s*</p>\s*)";
		РезультатМетод = РегВыражение.НайтиВхождения(ОписаниеВарианта);
		Если РезультатМетод.Количество() = 0 Тогда
			ОписаниеМетода = "";
			Если ЯзыкПрограммы = 1 Тогда
				РегВыражение.Pattern = "</H1>([\s\S]*)(</BODY>)?";
				РезультатОписание = РегВыражение.НайтиВхождения(ОписаниеВарианта);
				Если РезультатОписание.Количество() > 0 Тогда
					ОписаниеВарианта = РезультатОписание[0].SubMatches(0);
					//ОписаниеМетода = ирОбщий.ПервыйФрагментЛкс(ОписаниеВарианта, "Синтаксис:");
				Иначе
					ОписаниеВарианта = "";
				КонецЕсли; 
			ИначеЕсли ЯзыкПрограммы = 2 Тогда
				РегВыражение.Pattern = "<H2[^>]*><A[^>]*>(?:</A>)?" + ИмяМетода + "[<\s\(].*?</H2>((?:.|\n|\r)*?)(?:<H2[^>]*>|$)";
				РезультатОписание = РегВыражение.НайтиВхождения(ОписаниеВарианта);
				Если РезультатОписание.Количество() > 0 Тогда
					ОписаниеВарианта = РезультатОписание[0].SubMatches(0);
					ОписаниеМетода = ирОбщий.ПервыйФрагментЛкс(ОписаниеВарианта, "Синтаксис:");
				Иначе
					ОписаниеВарианта = "";
				КонецЕсли; 
			КонецЕсли; 
		Иначе
			ОписаниеМетода = РезультатМетод[0].Value;
		КонецЕсли; 
		Если ТаблицаПараметров = мПлатформа.ТаблицаПараметров Тогда
			СтрокаОписанияМетода.Описание = ОписаниеМетода + ОписаниеДоступности;
			ОбрезатьОписание(СтрокаОписанияМетода.Описание);  
			СтрокаОписанияМетода.Описание = ИзвлечьИзФрагментаHTMLОбычныйТекст(СтрокаОписанияМетода.Описание, Ложь);
		КонецЕсли; 
		РегВыражение.Pattern = шКлюч + "+Параметры?(?: функции)?:?" + шКонецКлюча + "+((?:.|\n)*?)(?:" + шКлюч + "+Описание(?: варианта метода)?:?" + шКонецКлюча + "|$)";
		РезультатВарианты = РегВыражение.НайтиВхождения(ОписаниеВарианта);
		Если РезультатВарианты.Количество() = 0 Тогда
			Продолжить;
		КонецЕсли; 
		ОписаниеВариантаСПараметрами = РезультатВарианты[0].SubMatches(0);
		Если ТипСлова = "Таблица" Тогда
			РегВыражение.Pattern = "(<a href=""v8help://SyntaxHelperContext(/[" + мПлатформа.шБукваЦифра + "/]+params/[" + мПлатформа.шБукваЦифра + "/]+.html)"">[" + мПлатформа.шБукваЦифра + "\-\s\(\)]+</a>)";
		Иначе
			РегВыражение.Pattern = шКлюч + "(?:&lt;|<strong>)([^&<:]+)(?:&gt;|</strong>)" 
			+ "()?(?:\s*(?:\((необязательный|обязательный)?\)\s*)?" + шКонецКлюча + "+(?:Тип:" + шТегНеКлюч + "?((?:" + шТип + ")+)" + шТегНеКлюч + "?)?)?(?:" + шТипВложенный + ")?\.?(?:\s*-\s*)?((?:(?:Значение по умолчанию: " + шТег 
			+ "?([^<>]+)" + шТег + "?\.)|[^dlp](?=[^dlp]|$)|[^<][dlp]+|<li>(?!<strong>))*)";
		КонецЕсли;
		ВхожденияПараметра = РегВыражение.НайтиВхождения(ОписаниеВариантаСПараметрами);
		
		КлючПоискаПараметра = Новый Структура("ТипКонтекста, ЯзыкПрограммы, Слово, Номер, ВариантСинтаксиса");
		Если ТипСлова = "Конструктор" Тогда
			КлючПоискаПараметра.Слово = "<Новый>";
			КлючПоискаПараметра.ВариантСинтаксиса = ИмяМетода;
		Иначе
			КлючПоискаПараметра.Слово = ИмяМетода;
			КлючПоискаПараметра.ВариантСинтаксиса = ЭлементСписка.Представление;
		КонецЕсли;
		КлючПоискаПараметра.ТипКонтекста = ТипКонтекста;
		КлючПоискаПараметра.ЯзыкПрограммы = ЯзыкПрограммы;
		ЧтениеХмлПараметра = Новый ЧтениеXML;
		НомерПараметра = 1;
		Для Каждого ВхождениеПараметра Из ВхожденияПараметра Цикл
			#Если Сервер И Не Сервер Тогда
				ВхождениеПараметра = Обработки.ирОболочкаРегВхождение.Создать();
			#КонецЕсли
			НоваяСтрокаПараметра = Неопределено;
			КлючПоискаПараметра.Номер = НомерПараметра; 
			Если ТаблицаПараметров = мПлатформа.ТаблицаПараметров Тогда
				НайденныеСтроки = ТаблицаПараметров.НайтиСтроки(КлючПоискаПараметра);
				Если НайденныеСтроки.Количество() > 0 Тогда
					НоваяСтрокаПараметра = НайденныеСтроки[0];
				КонецЕсли; 
			КонецЕсли; 
			Если НоваяСтрокаПараметра = Неопределено Тогда
				НоваяСтрокаПараметра = ТаблицаПараметров.Добавить();
			КонецЕсли;
			СтруктураСтроки = ирОбщий.СтруктураСвойствСтрокиТаблицыИлиДереваЛкс(НоваяСтрокаПараметра);
			ЗаполнитьЗначенияСвойств(СтруктураСтроки, КлючПоискаПараметра); 
			ТекстПараметра = ВхождениеПараметра.SubMatches(0);
			ТекстПоискаТипов = Неопределено;
			АдресСтраницыОписанияПараметра = "";
			
			// Для параметров виртуальных таблиц надо убрать оберку <A>...</A>. В ней находится ссылка на страницу описания параметра. Это примеяется пока только в описаниях виртуальных таблиц языка запросов.
			ЧтениеХмлПараметра.УстановитьСтроку(ТекстПараметра);
			Попытка
				ЧтениеХмлПараметра.Прочитать();
				ЧтениеХмлПараметра.Прочитать();
			Исключение
			КонецПопытки;
			Если ЧтениеХмлПараметра.ТипУзла = ТипУзлаXML.Текст Тогда
				ТекстПараметра = ЧтениеХмлПараметра.Значение;
			КонецЕсли;
			СтруктураСтроки.Параметр = ТекстПараметра;
			Если ТипСлова <> "Таблица" Тогда
				Если ВхождениеПараметра.SubMatches(2) = "необязательный" Тогда
					СтруктураСтроки.Необязательный = Истина;
				КонецЕсли;
				Если ТаблицаПараметров = мПлатформа.ТаблицаПараметров Тогда
					СтруктураСтроки.Описание = ИзвлечьИзФрагментаHTMLОбычныйТекст(ВхождениеПараметра.SubMatches(9), Ложь);
				КонецЕсли; 
				ЗначениеПоУмолчанию = ВхождениеПараметра.SubMatches(10);
				Если ирОбщий.СтрокиРавныЛкс(ЗначениеПоУмолчанию, "Пустая строка") Тогда
					ЗначениеПоУмолчанию = """""";
				КонецЕсли; 
				СтруктураСтроки.Значение = ЗначениеПоУмолчанию;
				ТекстПоискаТипов = ВхождениеПараметра.SubMatches(3);
			КонецЕсли;
			Если ВхождениеПараметра.SubMatches(1) <> "" Тогда
				СтруктураСтроки.ПутьКОписанию = ВхождениеПараметра.SubMatches(1);
				Если Не ЗначениеЗаполнено(РабочийКаталог) Тогда
					РаспаковатьФайлАрхиваСинтаксПомощника(СтруктураСтроки.ПутьКОписанию);
					ФайлОписанияПараметра = Новый Файл(ПутьКэшаСинтаксПомощника() + СтруктураСтроки.ПутьКОписанию);
				Иначе
					ФайлОписанияПараметра = Новый Файл(РабочийКаталог + СтруктураСтроки.ПутьКОписанию);
				КонецЕсли; 
				Если Истина
					И ФайлОписанияПараметра.Существует()
					И ФайлОписанияПараметра.ЭтоФайл()
				Тогда
					ТекстовыйДокумент.Прочитать(ФайлОписанияПараметра.ПолноеИмя);
					РегВыражение2.Global = Ложь;
					РегВыражение2.Pattern = "Тип параметра:" + шТегНеКлюч + "?((?:" + шТип + ")+)";
					ОписаниеПараметра = ТекстовыйДокумент.ПолучитьТекст();
					Результат2 = РегВыражение2.НайтиВхождения(ОписаниеПараметра);
					Если Результат2.Количество() > 0 Тогда
						ТекстПоискаТипов = Результат2[0].SubMatches(0);
						ОписаниеПараметра = Сред(ОписаниеПараметра, Результат2[0].FirstIndex + Результат2[0].Length + 1);
					КонецЕсли;
					Если ТаблицаПараметров = мПлатформа.ТаблицаПараметров Тогда
						Если Не ЗначениеЗаполнено(СтруктураСтроки.Описание) Тогда
							СтруктураСтроки.Описание = ИзвлечьИзФрагментаHTMLОбычныйТекст(ОписаниеПараметра, Ложь);
						КонецЕсли;
					КонецЕсли;
				КонецЕсли;
			КонецЕсли;
			Если ТекстПоискаТипов <> Неопределено Тогда
				РегВыражение2.Global = Истина;
				РегВыражение2.Pattern = шТип;
				Результат2 = РегВыражение2.НайтиВхождения(ТекстПоискаТипов);
				СтрокаТипаЗначения = "";
				Для Каждого Вхождение2 Из Результат2 Цикл
					СтрокаТипаЗначения = СтрокаТипаЗначения + ", " + СокрЛП(Вхождение2.SubMatches(0));
				КонецЦикла;
				СтруктураСтроки.ТипЗначения = ИзвлечьИзФрагментаHTMLОбычныйТекст(Сред(СтрокаТипаЗначения, 3));
				Если Истина
					И ТипСлова <> "Таблица" 
					И ВхождениеПараметра.SubMatches(7) <> Неопределено 
				Тогда
					//ТипЗначенияВложенный = ИмяТипаИзПредставления(ИзвлечьИзФрагментаHTMLОбычныйТекст(ВхождениеПараметра.SubMatches(7)));
					ТипЗначенияВложенный = ИзвлечьИзФрагментаHTMLОбычныйТекст(ВхождениеПараметра.SubMatches(7));
					Если ирОбщий.СтрокиРавныЛкс(ТипЗначенияВложенный, "истина") Тогда
						ТипЗначенияВложенный = "Булево";
					КонецЕсли;
					Если ВхождениеПараметра.SubMatches(6) <> Неопределено Тогда
						СтруктураСтроки.ТипЗначения = "Массив[" + ТипЗначенияВложенный + "]";
					КонецЕсли;
				КонецЕсли;
			КонецЕсли;
			
			СкорректироватьЭлементыСтруктуры(СтруктураСтроки);
			ЗаполнитьЗначенияСвойств(НоваяСтрокаПараметра, СтруктураСтроки);
			НомерПараметра = НомерПараметра + 1;
		КонецЦикла;
		НомерПараметра = НомерПараметра - 1;
		Если НомерПараметра > МаксНомерПараметра Тогда
			МаксНомерПараметра = НомерПараметра;
		КонецЕсли;
	КонецЦикла;
	Если Истина
		И ТаблицаПараметров = мПлатформа.ТаблицаПараметров 
		И Не ЗначениеЗаполнено(СтрокаОписанияМетода.Описание) // Мультиметка443985642
	Тогда
		СтрокаОписанияМетода.Описание = "."; // Обязательно заполняем чтобы потом повторно не загружать
	КонецЕсли;
	Возврат МаксНомерПараметра;

КонецФункции

// Функция - Загрузить описание свойства
//
// Параметры:
//  СтрокаОписания - СтрокаТаблицыЗначений, см. ОбработкаОбъект.ирПлатформа.ТаблицаКонтекстов[0] - 
// 
// Возвращаемое значение:
//   - 
//
Функция ЗагрузитьОписаниеСвойства(Знач СтрокаОписания) Экспорт 
	Если СтрокаОписания.Владелец().Колонки.Найти("Описание") = Неопределено Тогда
		Возврат "";
	КонецЕсли;
	Если ЗначениеЗаполнено(СтрокаОписания.Описание) Тогда 
		Возврат СтрокаОписания.Описание;
	КонецЕсли;
	ПутьКЭлементуАрхива = СтрокаОписания.ПутьКОписанию;
	Если Не ЗначениеЗаполнено(ПутьКЭлементуАрхива) Тогда
		Возврат "";
	КонецЕсли;
	НовыйАдрес = РаспаковатьФайлАрхиваСинтаксПомощника(ПутьКЭлементуАрхива);
	Если НовыйАдрес = Неопределено Тогда
		СтрокаОписания.Описание = "<Описание не найдено>"; // Чтобы больше не пытаться загружать
		Возврат "";
	КонецЕсли;
	РегВыражение.Global = Истина;
	ТекстовыйДокумент = Новый ТекстовыйДокумент;
	ТекстовыйДокумент.Прочитать(ирОбщий.ПервыйФрагментЛкс(НовыйАдрес, "#"));
	ТекстДокумента = ТекстовыйДокумент.ПолучитьТекст();
	РегВыражение.Pattern = шТегКлючСлабый + ирОбщий.ТекстДляРегВыраженияЛкс(ирОбщий.КодироватьТекстВXMLЛкс(СтрокаОписания.Слово)) + "\s*(\([^<>\)]+\))?" + шКонецТегаКлючСлабый
		+ "(?:<div class=""__SINCE_SHOW_STYLE__[^/]*/p>)?";
	Вхождения = РегВыражение.НайтиВхождения(ТекстДокумента);
	Если Вхождения.Количество() > 0 Тогда
		Индекс = Вхождения.ВГраница();
		Пока Вхождения[Индекс].SubMatches(0) = Неопределено И Индекс > 0 Цикл
			Индекс = Индекс - 1;
		КонецЦикла;
		ТекстДокумента = СокрЛ(Сред(ТекстДокумента, Вхождения[Индекс].FirstIndex + Вхождения[Индекс].Length + 1));
	КонецЕсли;
	// Элементы списков делаем в одну строку
	РегВыражение.Pattern = "(?:\s*\(\w+\))?(</a><br>\s*<[ap])";
	ТекстДокумента = РегВыражение.Заменить(ТекстДокумента, ",$1");
	
	ОбрезатьОписание(ТекстДокумента);
	ТекстДокумента = ИзвлечьИзФрагментаHTMLОбычныйТекст(ТекстДокумента, Ложь);
	Если Истина
		И Найти(СтрокаОписания.Слово, "<") > 0 
		И Лев(ТекстДокумента, 1) <> "<"
	Тогда
		ТекстДокумента = СтрокаОписания.Слово + Символы.ПС + ТекстДокумента;
	КонецЕсли;
	СтрокаОписания.Описание = СокрЛП(ТекстДокумента);
	Возврат СтрокаОписания.Описание;      
КонецФункции

Функция ИзвлечьИзФрагментаHTMLОбычныйТекст(Знач Текст, Знач УдалитьКрайнююТочку = Истина) Экспорт 
	
	РегВыражение.Global = Истина;
	// Заменяем концы параграфов и переносы строк на пробелы
	РегВыражение.Pattern = "(?:<br>|</p>)";
	//Текст = РегВыражение.Заменить(Текст, Символы.ПС); // менее эффективно используется место
	Текст = РегВыражение.Заменить(Текст, " "); // более эффективно используется место
	// элемент списка выносим на новую строку с префиксом " - "
	РегВыражение.Pattern = "<li>";
	Текст = РегВыражение.Заменить(Текст, Символы.ПС + " - ");
	// Параграфы выносим на новую строку
	РегВыражение.Pattern = "<p[^>]*>|</?ul>";
	Текст = РегВыражение.Заменить(Текст, Символы.ПС);
	// Удаляем все оставшиеся теги
	РегВыражение.Pattern = "<[^>]+>";
	Текст = РегВыражение.Заменить(Текст, "");
	
	Текст = ирОбщий.ДекодироватьТекстИзXMLЛкс(Текст);
	// Нормализация пустых строк
	РегВыражение.Pattern = "(?:\r?\n\s*){2,}";
	Текст = СокрЛП(РегВыражение.Заменить(Текст, Символы.ПС));
	Если УдалитьКрайнююТочку И Прав(Текст, 1) = "." Тогда       
		// Например, Тип: Произвольный. 
		Текст = ирОбщий.СтрокаБезКонцаЛкс(Текст, 1);
	КонецЕсли;
	Возврат Текст;

КонецФункции

Процедура ОбрезатьОписание(Текст)
	Текст = ирОбщий.ПервыйФрагментЛкс(Текст, "Методическая информация");
	МаркерОписание = "Описание:";
	Если ирОбщий.СтрНачинаетсяСЛкс(Текст, МаркерОписание) Тогда
		Текст = Сред(Текст, СтрДлина(МаркерОписание) + 1);
	КонецЕсли;
	РегВыражение.Global = Истина;
	// Удаляем секцию "Пример"
	РегВыражение.Pattern = "<p class=""?V8SH_chapter""?>Пример:</p>\s*<table[\s\S]*?</table>";
	Текст = РегВыражение.Заменить(Текст, "");
	// Удаляем секцию "См. также"
	РегВыражение.Pattern = "<p class=""?V8SH_chapter""?>См. также:</p>\s*[\s\S]*?</p>";
	Текст = РегВыражение.Заменить(Текст, "");
	// Все заголовки выносим на новую строку с префиксом "> "
	РегВыражение.Pattern = "<p class=""?V8SH_chapter""?>([^<]+?)[:\s]*</p>\s*(<p[^<]*>)?";
	Текст = РегВыражение.Заменить(Текст, Символы.ПС + "> $1: ");
КонецПроцедуры

Процедура СкорректироватьЭлементыСтруктуры(Структура) Экспорт 
	
	Для Каждого ЭлементСтруктуры Из Структура Цикл
		Если ТипЗнч(ЭлементСтруктуры.Значение) <> типСтрока Тогда
			Продолжить;
		КонецЕсли; 
		Если Найти(ЭлементСтруктуры.Значение, "<Имя регистра>") > 0 Тогда
			Если Найти(ЭлементСтруктуры.Значение, "РегистрСведений") > 0 Тогда
				СтрокаЗаменыИмениРегистра = "<Имя регистра сведений>";
			ИначеЕсли Найти(ЭлементСтруктуры.Значение, "РегистрНакопления") > 0 Тогда
				СтрокаЗаменыИмениРегистра = "<Имя регистра накопления>";
			КонецЕсли;
			Прервать;
		КонецЕсли;
	КонецЦикла;
	
	Для Каждого ЭлементСтруктуры Из Структура Цикл
		ЗначениеЭлемента = ЭлементСтруктуры.Значение;
		Если ТипЗнч(ЗначениеЭлемента) <> типСтрока Тогда
			Продолжить;
		КонецЕсли; 
		Если Истина
			И Структура.Свойство("ЯзыкПрограммы")
			И Структура.ЯзыкПрограммы = 1 
			И ЗначениеЭлемента <> "Ссылка"
		Тогда
			ЗначениеЭлемента = СтрЗаменить(ЗначениеЭлемента, "Ссылка", "");
		КонецЕсли;
		Если СтрокаЗаменыИмениРегистра <> Неопределено Тогда
			ЗначениеЭлемента = СтрЗаменить(ЗначениеЭлемента, "<Имя регистра>", СтрокаЗаменыИмениРегистра);
		КонецЕсли;
		
		Если ирКэш.РежимОтладкиЛкс() Тогда 
			// Пассивный оригинал расположенного ниже однострочного кода. Выполняйте изменения синхронно в обоих вариантах.
			// Выполняется много раз! Тяжелый цикл
			Для Каждого ЭлементЗамены Из СоответствиеЗамены Цикл
				//Если ВключитьАнализСрабатыванияЗамен Тогда
				//	Если СрабатываниеЗамен[ЭлементЗамены.Ключ] = 0 И Найти(ЗначениеЭлемента, ЭлементЗамены.Ключ) > 0 Тогда
				//		СрабатываниеЗамен[ЭлементЗамены.Ключ] = 1;
				//	КонецЕсли; 
				//КонецЕсли; 
				ЗначениеЭлемента = СтрЗаменить(ЗначениеЭлемента, ЭлементЗамены.Ключ, ЭлементЗамены.Значение);
			КонецЦикла;
			Если Найти(ЗначениеЭлемента, "<") = 0 Тогда
				СтароеЗначениеЭлемента = ЗначениеЭлемента;
				Для Каждого СтрокаЗамены Из ЗаменыВнешнихОбъектов Цикл
					ЗначениеЭлемента = СтрЗаменить(ЗначениеЭлемента, СтрокаЗамены.Образец, СтрокаЗамены.Замена);
					Если СтароеЗначениеЭлемента <> ЗначениеЭлемента Тогда
						Прервать;
					КонецЕсли;
				КонецЦикла;
			КонецЕсли; 
		Иначе
			// Однострочный код использован для ускорения. Выше расположен оригинал. Выполняйте изменения синхронно в обоих вариантах. Преобразовано консолью кода из подсистемы "Инструменты разработчика" (http://devtool1c.ucoz.ru)
			Для Каждого ЭлементЗамены Из СоответствиеЗамены Цикл            			ЗначениеЭлемента = СтрЗаменить(ЗначениеЭлемента, ЭлементЗамены.Ключ, ЭлементЗамены.Значение);  		КонецЦикла;  		Если Найти(ЗначениеЭлемента, "<") = 0 Тогда  			СтароеЗначениеЭлемента = ЗначениеЭлемента;  			Для Каждого СтрокаЗамены Из ЗаменыВнешнихОбъектов Цикл  				ЗначениеЭлемента = СтрЗаменить(ЗначениеЭлемента, СтрокаЗамены.Образец, СтрокаЗамены.Замена);  				Если СтароеЗначениеЭлемента <> ЗначениеЭлемента Тогда  					Прервать;  				КонецЕсли;  			КонецЦикла;  		КонецЕсли;  
		КонецЕсли; 
		Структура[ЭлементСтруктуры.Ключ] = ЗначениеЭлемента;
	КонецЦикла;

КонецПроцедуры

Функция СтрокаДляПодсветкиПараметра(Знач ИмяПараметра, Знач ЯзыкПрограммы = 0) Экспорт 
	
	Если ЯзыкПрограммы = 2 Тогда
		СтрокаДляПодсветки = "<strong>" + ИмяПараметра + "</strong>";
	Иначе
		СтрокаДляПодсветки = "&lt;" + ИмяПараметра + "&gt;";
	КонецЕсли;
	Возврат СтрокаДляПодсветки;

КонецФункции

//ирПортативный лФайл = Новый Файл(ИспользуемоеИмяФайла);
//ирПортативный ПолноеИмяФайлаБазовогоМодуля = Лев(лФайл.Путь, СтрДлина(лФайл.Путь) - СтрДлина("Модули\")) + "ирПортативный.epf";
//ирПортативный #Если Клиент Тогда
//ирПортативный 	Контейнер = Новый Структура();
//ирПортативный 	Оповестить("ирПолучитьБазовуюФорму", Контейнер);
//ирПортативный 	Если Не Контейнер.Свойство("ирПортативный", ирПортативный) Тогда
//ирПортативный 		ирПортативный = ВнешниеОбработки.ПолучитьФорму(ПолноеИмяФайлаБазовогоМодуля);
//ирПортативный 		ирПортативный.Открыть();
//ирПортативный 	КонецЕсли; 
//ирПортативный #Иначе
//ирПортативный 	ирПортативный = ВнешниеОбработки.Создать(ПолноеИмяФайлаБазовогоМодуля, Ложь); // Это будет второй экземпляр объекта
//ирПортативный #КонецЕсли
//ирПортативный ирОбщий = ирПортативный.ОбщийМодульЛкс("ирОбщий");
//ирПортативный ирКэш = ирПортативный.ОбщийМодульЛкс("ирКэш");
//ирПортативный ирСервер = ирПортативный.ОбщийМодульЛкс("ирСервер");
//ирПортативный ирКлиент = ирПортативный.ОбщийМодульЛкс("ирКлиент");

мПлатформа = ирКэш.Получить();
#Если Сервер И Не Сервер Тогда
	мПлатформа = Обработки.ирПлатформа.Создать();
#КонецЕсли
шТег =           "(?:\s*<[^>]+>\s*)";
шТегНеКлюч =     "(?:\s*<[^>""]+>\s*)";
шТегКлюч =       "(?:\s*<(?:li|(?:div|p|b)(?:\s[^>]*)?)>\s*)";  // <li><strong> используется в описании функций языка выражений компоновки . <P>Параметры:</P> - встречается в описании функций языка выражений компоновки, например КлассификацияABC
шКонецТегаКлюч = "(?:\s*</(?:div|li|p|b)>\s*)";
шТегКлючСлабый = "(?:\s*<(?:li|(?:div|p|b|strong|u|h1)(?:\s[^>]*)?)>\s*)"; // Добавлены <strong> и <u>. Много ложных срабатываний в описаниях языка выражений компоновки
шКонецТегаКлючСлабый = "(?:(?:<br>|\s)*</(?:div|li|p|b|strong|u|h1)>(?:<br>|\s)*)";
шТип =        "\s*(?:<[^>""]+""(?:[^""]*)"">)?((?:[" + мПлатформа.шБукваЦифра + "\-\s\:\&\/.;]+))(?:(?:<[^>""]+>)?[,;])?"; // Добавлены символы "." и ";" Для разрабора типов параметра "Субконто" виртуальной таблицы ОстаткиИОбороты
шТипСтрогий = "\s*(?:<[^>""]+""(?:[^""]*)"">)((?:[" + мПлатформа.шБукваЦифра + "\-\s\:\&\/.;]+))(?:(?:<[^>""]+>)[,;])?"; // Добавлены символы "." и ";" Для разрабора типов параметра "Субконто" виртуальной таблицы ОстаткиИОбороты
шТипВложенный = "\.\s+<br>(Результат выполнения обещания\s+[–-]\s+)?(Массив)?[^.<]*((?:" + шТипСтрогий + ")+<[^>""]+>)";
СоответствиеЗамены = Новый Соответствие;

// Баг платформы. Небрежность в файлах справки.
СоответствиеЗамены.Вставить("<Имя журнала>",      "<Имя журнала документов>");
СоответствиеЗамены.Вставить("<Имя критерия>", "<Имя критерия отбора>");
СоответствиеЗамены.Вставить("<Имя WS-ссылки>", "<Имя WS-Ссылки>");
СоответствиеЗамены.Вставить("<Имя значения>", "<Имя значения перечисления>");
СоответствиеЗамены.Вставить("<ИмяПеречисления>", "<Имя перечисления>");
СоответствиеЗамены.Вставить("<Имя внешнего источника данных>", "<Имя внешнего источника>");

ЗаменыВнешнихОбъектов = Новый ТаблицаЗначений;
ЗаменыВнешнихОбъектов.Колонки.Добавить("Образец");
ЗаменыВнешнихОбъектов.Колонки.Добавить("Замена");
СтрокаЗамены = ЗаменыВнешнихОбъектов.Добавить();
СтрокаЗамены.Образец = "ВнешнийОтчетТабличнаяЧасть";
СтрокаЗамены.Замена = "ВнешнийОтчетТабличнаяЧасть.<Имя внешнего отчета>.<Имя табличной части>";
СтрокаЗамены = ЗаменыВнешнихОбъектов.Добавить();
СтрокаЗамены.Образец = "ВнешняяОбработкаТабличнаяЧасть";
СтрокаЗамены.Замена = "ВнешняяОбработкаТабличнаяЧасть.<Имя внешней обработки>.<Имя табличной части>";
СтрокаЗамены = ЗаменыВнешнихОбъектов.Добавить();
СтрокаЗамены.Образец = "ВнешнийОтчет";
СтрокаЗамены.Замена = "ВнешнийОтчетОбъект.<Имя внешнего отчета>";
СтрокаЗамены = ЗаменыВнешнихОбъектов.Добавить();
СтрокаЗамены.Образец = "ВнешняяОбработка";
СтрокаЗамены.Замена = "ВнешняяОбработкаОбъект.<Имя внешней обработки>";
СтрокаЗамены = ЗаменыВнешнихОбъектов.Добавить();
СтрокаЗамены.Образец = "ТочкаМаршрутаБизнесПроцессаСсылка";
СтрокаЗамены.Замена = "ТочкаМаршрутаБизнесПроцессаСсылка.<Имя бизнес-процесса>";
типСтрока = Тип("Строка");
РегВыражение = ирОбщий.НовоеРегВыражениеЛкс();
РегВыражение2 = ирОбщий.НовоеРегВыражениеЛкс();
СодержанияАрхивовСправки = Новый Соответствие;
мЗапрещен = Ложь;
