<!DOCTYPE html>
<https://chat.qwen.ai>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Сравнение строк</title>
    <style>
        body {
            font-family: 'Courier New', monospace;
            margin: 0;
            padding: 0;
            background-color: white;
        }
        
        .comparison {
            display: flex;
            flex-direction: column;
            gap: 2px;
        }
        
        .text-row {
            display: flex;
            align-items: flex-start;
            min-height: 15px;
        }
        
        .text-content {
            white-space: pre;
            overflow-x: auto;
            font-size: 13px;
            line-height: 1.2;
        }
        
        .diff-delete {
            background-color: #ffe0e0;
            color: #c62828;
        }
        
        .diff-insert {
            background-color: #d8ffd8;
            color: #2e7d32;
        }
        
        .diff-space {
            background-color: #e0e0ff;
            color: #1565c0;
        }
        
        .char-cell {
            display: inline-block;
            min-width: 7px;
            text-align: center;
            margin: 0 0.5px;
        }
    </style>
</head>
<body>
    <div class="comparison" id="comparisonResult"></div>
    <script>
        // Функция для сравнения двух строк с выделением различий
        function setText(text1, text2, IgnoreBoundaryWhitespace = true) {
            const comparisonResult = document.getElementById('comparisonResult');
            comparisonResult.innerHTML = '';
            
            let processedText1 = text1;
            let processedText2 = text2;
            
            // Обработка крайней пустоты
            if (IgnoreBoundaryWhitespace) {
                processedText1 = text1.trim();
                processedText2 = text2.trim();
            }
            
            // Если строки полностью совпадают после обработки
            if (processedText1 === processedText2) {
                addTextRow(processedText1, 'common');
                addTextRow(processedText2, 'common');
                return;
            }
            
            // Находим различия с помощью улучшенного алгоритма
            const diff = computeHybridDiff(processedText1, processedText2);
            
            // Выравниваем строки и добавляем служебные пробелы
            const aligned = alignStrings(diff);
            
            // Отображаем выровненные строки
            addTextRow(aligned.str1, 'diff', aligned.types1);
            addTextRow(aligned.str2, 'diff', aligned.types2);
        }
        
        // Добавление строки
        function addTextRow(text, type, types = null) {
            const row = document.createElement('div');
            row.className = 'text-row';
            
            const textContent = document.createElement('div');
            textContent.className = 'text-content';
            
            if (type === 'common') {
                textContent.innerHTML = escapeHtml(text);
            } else {
                textContent.innerHTML = formatAlignedText(text, types);
            }
            
            row.appendChild(textContent);
            document.getElementById('comparisonResult').appendChild(row);
        }
        
        // Форматирование выровненного текста
        function formatAlignedText(text, types) {
            let html = '';
            for (let i = 0; i < text.length; i++) {
                const char = text[i];
                const type = types[i];
                
                let spanClass = '';
                if (type === 'delete') spanClass = 'diff-delete';
                else if (type === 'insert') spanClass = 'diff-insert';
                else if (type === 'space') spanClass = 'diff-space';
                
                if (spanClass) {
                    html += `<span class="${spanClass} char-cell">${escapeHtml(char)}</span>`;
                } else {
                    html += `<span class="char-cell">${escapeHtml(char)}</span>`;
                }
            }
            return html;
        }
        
        // Выравнивание строк с добавлением служебных пробелов
        function alignStrings(diff) {
            let str1 = '';
            let str2 = '';
            let types1 = [];
            let types2 = [];
            
            for (const operation of diff) {
                if (operation.type === 'common') {
                    // Для общих фрагментов добавляем символы по одному
                    for (let i = 0; i < operation.text.length; i++) {
                        str1 += operation.text[i];
                        str2 += operation.text[i];
                        types1.push('common');
                        types2.push('common');
                    }
                } else if (operation.type === 'delete') {
                    // Для удаленных фрагментов добавляем символы в первую строку, пробелы во вторую
                    for (let i = 0; i < operation.text.length; i++) {
                        str1 += operation.text[i];
                        str2 += ' ';
                        types1.push('delete');
                        types2.push('space');
                    }
                } else if (operation.type === 'insert') {
                    // Для вставленных фрагментов добавляем пробелы в первую строку, символы во вторую
                    for (let i = 0; i < operation.text.length; i++) {
                        str1 += ' ';
                        str2 += operation.text[i];
                        types1.push('space');
                        types2.push('insert');
                    }
                } else if (operation.type === 'replace') {
                    // Для замены используем посимвольное сравнение для лучшего выравнивания
                    const len1 = operation.text1.length;
                    const len2 = operation.text2.length;
                    
                    // Используем стандартный алгоритм Левенштейна для фрагментов замены
                    const subDiff = computeCharDiff(operation.text1, operation.text2);
                    
                    for (const subOp of subDiff) {
                        if (subOp.type === 'common') {
                            str1 += subOp.char;
                            str2 += subOp.char;
                            types1.push('common');
                            types2.push('common');
                        } else if (subOp.type === 'delete') {
                            str1 += subOp.char;
                            str2 += ' ';
                            types1.push('delete');
                            types2.push('space');
                        } else if (subOp.type === 'insert') {
                            str1 += ' ';
                            str2 += subOp.char;
                            types1.push('space');
                            types2.push('insert');
                        } else if (subOp.type === 'replace') {
                            str1 += subOp.char1;
                            str2 += subOp.char2;
                            types1.push('delete');
                            types2.push('insert');
                        }
                    }
                }
            }
            
            return { str1, str2, types1, types2 };
        }
        
        // Гибридный алгоритм вычисления различий
        function computeHybridDiff(str1, str2) {
            if (str1 === str2) {
                return [{ type: 'common', text: str1 }];
            }
            
            // Сначала попробуем найти длинные совпадающие подстроки
            const commonSubstrings = findLongestCommonSubstrings(str1, str2);
            
            if (commonSubstrings.length === 0) {
                // Если нет общих подстрок, используем посимвольное сравнение
                return [{ type: 'replace', text1: str1, text2: str2 }];
            }
            
            // Разбиваем строки на части на основе найденных общих подстрок
            let result = [];
            let pos1 = 0, pos2 = 0;
            
            for (const cs of commonSubstrings) {
                // Добавляем различающиеся части перед общим фрагментом
                if (cs.start1 > pos1 || cs.start2 > pos2) {
                    const before1 = str1.substring(pos1, cs.start1);
                    const before2 = str2.substring(pos2, cs.start2);
                    
                    if (before1 && before2) {
                        // Используем посимвольное сравнение для несовпадающих частей
                        result.push({ type: 'replace', text1: before1, text2: before2 });
                    } else if (before1) {
                        result.push({ type: 'delete', text: before1 });
                    } else if (before2) {
                        result.push({ type: 'insert', text: before2 });
                    }
                }
                
                // Добавляем общий фрагмент
                result.push({ type: 'common', text: cs.text });
                
                // Обновляем позиции
                pos1 = cs.start1 + cs.text.length;
                pos2 = cs.start2 + cs.text.length;
            }
            
            // Добавляем оставшиеся части
            if (pos1 < str1.length || pos2 < str2.length) {
                const after1 = str1.substring(pos1);
                const after2 = str2.substring(pos2);
                
                if (after1 && after2) {
                    result.push({ type: 'replace', text1: after1, text2: after2 });
                } else if (after1) {
                    result.push({ type: 'delete', text: after1 });
                } else if (after2) {
                    result.push({ type: 'insert', text: after2 });
                }
            }
            
            return result;
        }
        
        // Поиск самых длинных общих подстрок
        function findLongestCommonSubstrings(str1, str2) {
            const m = str1.length;
            const n = str2.length;
            
            if (m === 0 || n === 0) return [];
            
            // Создаем матрицу для поиска общих подстрок
            const dp = Array(m + 1).fill().map(() => Array(n + 1).fill(0));
            let maxLength = 0;
            const endings = [];
            
            // Заполняем матрицу
            for (let i = 1; i <= m; i++) {
                for (let j = 1; j <= n; j++) {
                    if (str1[i-1] === str2[j-1]) {
                        dp[i][j] = dp[i-1][j-1] + 1;
                        if (dp[i][j] > maxLength) {
                            maxLength = dp[i][j];
                            endings.length = 0; // Очищаем предыдущие результаты
                            endings.push({ i, j });
                        } else if (dp[i][j] === maxLength && maxLength > 0) {
                            endings.push({ i, j });
                        }
                    }
                }
            }
            
            // Если не нашли общих подстрок длиной больше 3, ищем подстроки длиной 3 и более
            if (maxLength < 3) {
                maxLength = 0;
                endings.length = 0;
                
                for (let i = 1; i <= m; i++) {
                    for (let j = 1; j <= n; j++) {
                        if (str1[i-1] === str2[j-1]) {
                            dp[i][j] = dp[i-1][j-1] + 1;
                            if (dp[i][j] >= 3) {
                                if (dp[i][j] > maxLength) {
                                    maxLength = dp[i][j];
                                    endings.length = 0;
                                    endings.push({ i, j });
                                } else if (dp[i][j] === maxLength) {
                                    endings.push({ i, j });
                                }
                            }
                        } else {
                            dp[i][j] = 0;
                        }
                    }
                }
            }
            
            if (maxLength === 0) return [];
            
            // Восстанавливаем общие подстроки
            const substrings = [];
            const used = new Set();
            
            for (const end of endings) {
                const i = end.i;
                const j = end.j;
                const start1 = i - maxLength;
                const start2 = j - maxLength;
                const text = str1.substring(start1, i);
                
                // Проверяем, не пересекается ли с уже добавленными подстроками
                let isOverlapping = false;
                for (const sub of substrings) {
                    if (!(start1 >= sub.start1 + sub.text.length || 
                          start1 + text.length <= sub.start1 ||
                          start2 >= sub.start2 + sub.text.length || 
                          start2 + text.length <= sub.start2)) {
                        isOverlapping = true;
                        break;
                    }
                }
                
                if (!isOverlapping) {
                    substrings.push({
                        text: text,
                        start1: start1,
                        start2: start2,
                        length: maxLength
                    });
                }
            }
            
            // Сортируем по позиции в первой строке
            substrings.sort((a, b) => a.start1 - b.start1);
            
            return substrings;
        }
        
        // Посимвольный алгоритм Левенштейна для небольших фрагментов
        function computeCharDiff(str1, str2) {
            const m = str1.length;
            const n = str2.length;
            
            const dp = Array(m + 1).fill().map(() => Array(n + 1).fill(0));
            
            for (let i = 0; i <= m; i++) {
                for (let j = 0; j <= n; j++) {
                    if (i === 0) {
                        dp[i][j] = j;
                    } else if (j === 0) {
                        dp[i][j] = i;
                    } else if (str1[i - 1] === str2[j - 1]) {
                        dp[i][j] = dp[i - 1][j - 1];
                    } else {
                        dp[i][j] = 1 + Math.min(dp[i][j - 1], dp[i - 1][j], dp[i - 1][j - 1]);
                    }
                }
            }
            
            const diff = [];
            let i = m, j = n;
            
            while (i > 0 || j > 0) {
                if (i > 0 && j > 0 && str1[i - 1] === str2[j - 1]) {
                    diff.unshift({ type: 'common', char: str1[i - 1] });
                    i--;
                    j--;
                } else {
                    if (j > 0 && (i === 0 || dp[i][j - 1] <= dp[i - 1][j] && dp[i][j - 1] <= dp[i - 1][j - 1])) {
                        diff.unshift({ type: 'insert', char: str2[j - 1] });
                        j--;
                    } else if (i > 0 && (j === 0 || dp[i - 1][j] <= dp[i][j - 1] && dp[i - 1][j] <= dp[i - 1][j - 1])) {
                        diff.unshift({ type: 'delete', char: str1[i - 1] });
                        i--;
                    } else {
                        diff.unshift({ type: 'replace', char1: str1[i - 1], char2: str2[j - 1] });
                        i--;
                        j--;
                    }
                }
            }
            
            return diff;
        }
        
        // Экранирование HTML для безопасности
        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }
        
        // Экспорт функции для внешнего использования
        window.setText = setText;
    </script>
</body>
</html>