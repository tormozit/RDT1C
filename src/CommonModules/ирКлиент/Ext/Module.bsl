////////////////////////////////////////////////////////////////////////////////
// Подсистема "Инструменты разработчика Tormozit"
// Авторское право (с) 2007-2023, Старых С.А.
// Лицензия MIT
// Разрешается повторное распространение и использование как в виде исходника так и в двоичной форме,
// с модификациями или без, при соблюдении следующих условий: 
// - При повторном распространении исходного кода должно оставаться указанное выше уведомление об авторском
//   праве, этот список условий и нижеследующий отказ от гарантий. 
// - При повторном распространении двоичного кода должно воспроизводиться указанное выше уведомление об
//   авторском праве, этот список условий и нижеследующий отказ от гарантий в документации и/или в других
//   материалах, поставляемых при распространении. 
// 
// ЭТО ПРОГРАММА ПРЕДОСТАВЛЕНА БЕСПЛАТНО ДЕРЖАТЕЛЯМИ АВТОРСКИХ ПРАВ И/ИЛИ ДРУГИМИ СТОРОНАМИ "КАК ОНА ЕСТЬ"
// БЕЗ КАКОГО-ЛИБО ВИДА ГАРАНТИЙ, ВЫРАЖЕННЫХ ЯВНО ИЛИ ПОДРАЗУМЕВАЕМЫХ, ВКЛЮЧАЯ, НО НЕ ОГРАНИЧИВАЯСЬ ИМИ,
// ПОДРАЗУМЕВАЕМЫЕ ГАРАНТИИ КОММЕРЧЕСКОЙ ЦЕННОСТИ И ПРИГОДНОСТИ ДЛЯ КОНКРЕТНОЙ ЦЕЛИ. НИ В КОЕМ СЛУЧАЕ,
// ЕСЛИ НЕ ТРЕБУЕТСЯ СООТВЕТСТВУЮЩИМ ЗАКОНОМ, ИЛИ НЕ УСТАНОВЛЕНО В УСТНОЙ ФОРМЕ, НИ ОДИН ДЕРЖАТЕЛЬ АВТОРСКИХ
// ПРАВ И НИ ОДНО ДРУГОЕ ЛИЦО, КОТОРОЕ МОЖЕТ ИЗМЕНЯТЬ И/ИЛИ ПОВТОРНО РАСПРОСТРАНЯТЬ ПРОГРАММУ, КАК БЫЛО
// РАЗРЕШЕНО ВЫШЕ, НЕ ОТВЕТСТВЕННЫ ПЕРЕД ВАМИ ЗА УБЫТКИ, ВКЛЮЧАЯ ЛЮБЫЕ ОБЩИЕ, СЛУЧАЙНЫЕ, СПЕЦИАЛЬНЫЕ ИЛИ
// ПОСЛЕДОВАВШИЕ УБЫТКИ, ПРОИСТЕКАЮЩИЕ ИЗ ИСПОЛЬЗОВАНИЯ ИЛИ НЕВОЗМОЖНОСТИ ИСПОЛЬЗОВАНИЯ ПРОГРАММЫ (ВКЛЮЧАЯ,
// НО НЕ ОГРАНИЧИВАЯСЬ ПОТЕРЕЙ ДАННЫХ, ИЛИ ДАННЫМИ, СТАВШИМИ НЕПРАВИЛЬНЫМИ, ИЛИ ПОТЕРЯМИ ПРИНЕСЕННЫМИ ИЗ-ЗА
// ВАС ИЛИ ТРЕТЬИХ ЛИЦ, ИЛИ ОТКАЗОМ ПРОГРАММЫ РАБОТАТЬ СОВМЕСТНО С ДРУГИМИ ПРОГРАММАМИ), ДАЖЕ ЕСЛИ ТАКОЙ
// ДЕРЖАТЕЛЬ ИЛИ ДРУГОЕ ЛИЦО БЫЛИ ИЗВЕЩЕНЫ О ВОЗМОЖНОСТИ ТАКИХ УБЫТКОВ.

//ирПортативный Перем ирПортативный Экспорт;
//ирПортативный Перем ирОбщий Экспорт;
//ирПортативный Перем ирСервер Экспорт;
//ирПортативный Перем ирКэш Экспорт;
//ирПортативный Перем ирКлиент Экспорт;

#Если Не ТонкийКлиент И Не ВебКлиент И Не МобильныйКлиент Тогда

Процедура ИзменитьОтборКлиентаПоМетаданнымЛкс(ТабличноеПоле, Знач ИмяКолонкиСреднегоИмениМД = "Метаданные", ЭтоКолонкаПолногоИмениМД = Ложь) Экспорт 
	
	лСтруктураПараметров = Новый Структура;
	лСтруктураПараметров.Вставить("ОтображатьСсылочныеОбъекты", Истина);
	лСтруктураПараметров.Вставить("ОтображатьВнешниеИсточникиДанных", Истина);
	лСтруктураПараметров.Вставить("ОтображатьРегистры", Истина);
	лСтруктураПараметров.Вставить("ОтображатьПерерасчеты", Истина);
	лСтруктураПараметров.Вставить("ОтображатьПеречисления", Истина);
	лСтруктураПараметров.Вставить("ОтображатьТабличныеЧасти", Истина);
	лСтруктураПараметров.Вставить("ОтображатьКонстанты", Истина);
	лСтруктураПараметров.Вставить("ОтображатьВыборочныеТаблицы", Истина);
	лСтруктураПараметров.Вставить("ОтображатьРегламентныеЗадания", Истина);
	лСтруктураПараметров.Вставить("ОтображатьОтчеты", Истина);
	лСтруктураПараметров.Вставить("ОтображатьОбработки", Истина);
	лСтруктураПараметров.Вставить("ОтображатьПоследовательности", Истина);
	лСтруктураПараметров.Вставить("МножественныйВыбор", Истина);
	лДоступныеОбъекты = ТаблицаИлиДеревоЗначенийИзТаблицыФормыСКоллекциейЛкс(ТабличноеПоле);
	лДоступныеОбъекты.Свернуть(ИмяКолонкиСреднегоИмениМД);
	лДоступныеОбъекты = лДоступныеОбъекты.ВыгрузитьКолонку(ИмяКолонкиСреднегоИмениМД);
	Если ЭтоКолонкаПолногоИмениМД Тогда
		ДоступныеОбъекты = Новый Массив;
		Для Каждого ПолноеИмяМД Из лДоступныеОбъекты Цикл
			СреднееИмяМД = ирКэш.ИмяТаблицыИзМетаданныхЛкс(ПолноеИмяМД,, Ложь);
			ДоступныеОбъекты.Добавить(СреднееИмяМД);
		КонецЦикла;
	Иначе
		//лСтруктураПараметров.Вставить("ОтображатьВиртуальныеТаблицы", Истина);
		//лСтруктураПараметров.Вставить("ОтображатьТаблицыИзменений", Истина);
		ДоступныеОбъекты = лДоступныеОбъекты;
	КонецЕсли; 
	ЭлементОтбора = ТабличноеПоле.ОтборСтрок[ИмяКолонкиСреднегоИмениМД];
	Если Истина
		И ЭлементОтбора.Использование
		И ЭлементОтбора.ВидСравнения = ВидСравнения.ВСписке 
	Тогда
		лНачальноеЗначениеВыбора = ЭлементОтбора.Значение.ВыгрузитьЗначения();
		Если ЭтоКолонкаПолногоИмениМД Тогда
			НачальноеЗначениеВыбора = Новый Массив;
			Для Каждого ПолноеИмяМД Из лНачальноеЗначениеВыбора Цикл
				СреднееИмяМД = ирКэш.ИмяТаблицыИзМетаданныхЛкс(ПолноеИмяМД,, Ложь);
				НачальноеЗначениеВыбора.Добавить(СреднееИмяМД);
			КонецЦикла;
		Иначе
			НачальноеЗначениеВыбора = лНачальноеЗначениеВыбора;
		КонецЕсли; 
	Иначе
		НачальноеЗначениеВыбора = ДоступныеОбъекты;
	КонецЕсли; 
	мПлатформа = ирКэш.Получить();
	Форма = мПлатформа.ПолучитьФорму("ВыборОбъектаМетаданных");
	лСтруктураПараметров.Вставить("НачальноеЗначениеВыбора", НачальноеЗначениеВыбора);
	лСтруктураПараметров.Вставить("ДоступныеОбъекты", ДоступныеОбъекты);
	Форма.НачальноеЗначениеВыбора = лСтруктураПараметров;
	ЗначениеВыбора = Форма.ОткрытьМодально();
	Если ЗначениеВыбора <> Неопределено Тогда
		Если ЭтоКолонкаПолногоИмениМД Тогда
			ТаблицаВсехТаблицБД = ирКэш.ТаблицаВсехТаблицБДЛкс();
			МассивИменМД = Новый Массив;
			Для Каждого СреднееИмяМД Из ЗначениеВыбора Цикл
				СтрокаОписанияТаблицы = ТаблицаВсехТаблицБД.Найти(СреднееИмяМД, "ПолноеИмя");
				Если СтрокаОписанияТаблицы <> Неопределено Тогда
					МассивИменМД.Добавить(СтрокаОписанияТаблицы.ПолноеИмяМД);
				Иначе
					МассивИменМД.Добавить(СреднееИмяМД);
				КонецЕсли; 
			КонецЦикла;
		Иначе
			МассивИменМД = ЗначениеВыбора;
		КонецЕсли; 
		СписокЗначений = Новый СписокЗначений;
		СписокЗначений.ЗагрузитьЗначения(МассивИменМД);
		ЭлементОтбора.ВидСравнения = ВидСравнения.ВСписке;
		ЭлементОтбора.Значение = СписокЗначений;
		ЭлементОтбора.Использование = Истина;
	КонецЕсли;

КонецПроцедуры

Процедура ОткрытьДиалогЗаменыИдентификаторовОбъектовЛкс(Знач Объекты) Экспорт 
	
	ФормаОбработки = ПолучитьФормуЛкс("Обработка.ирПоискДублейИЗаменаСсылок.Форма");
	Дерево = Новый ДеревоЗначений;
	Дерево.Колонки.Добавить("Объект");
	Индикатор = ирОбщий.ПолучитьИндикаторПроцессаЛкс(Объекты.Количество(), "Создание дублей объектов");
	НачатьТранзакцию();
	Попытка
		Для Каждого Объект Из Объекты Цикл
			ирОбщий.ОбработатьИндикаторЛкс(Индикатор);
			КопияОбъекта = Объект.Ссылка.ПолучитьОбъект();
			ирОбщий.ЗаменитьИдентификаторОбъектаЛкс(КопияОбъекта); 
			Попытка
				КопияОбъекта.ОбменДанными.Загрузка = Истина;
			Исключение
				ирОбщий.СообщитьЛкс("Для узлов планов обмена групповая замена внутренних идентификаторов не поддерживается");
				Возврат;
			КонецПопытки; 
			КопияОбъекта.Записать();
			СтрокаГруппы = Дерево.Строки.Добавить();
			СтрокаЭлемента = СтрокаГруппы.Строки.Добавить();
			СтрокаЭлемента[0] = КопияОбъекта.Ссылка;
			СтрокаЭлемента = СтрокаГруппы.Строки.Добавить();
			СтрокаЭлемента[0] = Объект;
		КонецЦикла;
	Исключение
		ОтменитьТранзакцию();
		ВызватьИсключение;
	КонецПопытки;
	ЗафиксироватьТранзакцию();
	ирОбщий.ОсвободитьИндикаторПроцессаЛкс();
	ФормаОбработки.ОткрытьДляЗаменыПоДеревуСсылок(Дерево,, Ложь);
	ФормаОбработки.ОтключатьКонтрольЗаписи = Истина;
	ФормаОбработки.РазрешитьУдалениеСНарушениемСсылочнойЦелостности = Ложь;
	
КонецПроцедуры // ПередОткрытием()

// Оформляет ячейку табличного поля, допускающую значения, не имеющие стандартного отображения в платформе и хранимые отдельно.
// Иными словам колонка отображает данные, хранимые отдельно.
//
// Параметры:
//  ОформлениеЯчейки - ОформлениеЯчейки
//  Значение         - Произвольный - значение для отображения.
//
Процедура ОформитьЯчейкуСРасширеннымЗначениемЛкс(ОформлениеЯчейки, Знач Значение = Неопределено, КолонкаТабличногоПоля = Неопределено, ВыводитьПиктограммуТипа = Истина) Экспорт 

	Если Значение = Неопределено Тогда
		Значение = ОформлениеЯчейки.Значение;
	КонецЕсли; 
	Если ВыводитьПиктограммуТипа Тогда
		ТипЗначения = ТипЗнч(Значение);
		Если Истина
			И ТипЗначения = Тип("Булево")
			И ОформлениеЯчейки.ОтображатьФлажок
		Тогда
			//
		Иначе
			КартинкаТипа = КартинкаТипаЛкс(ТипЗначения);
			Если КартинкаТипа <> Неопределено Тогда
				ОформлениеЯчейки.УстановитьКартинку(КартинкаТипа);
			КонецЕсли;
		КонецЕсли;
	КонецЕсли; 
	
	РасширенноеПредставление = ирОбщий.РасширенноеПредставлениеЗначенияЛкс(Значение, КолонкаТабличногоПоля);
	Если Ложь
		Или ОформлениеЯчейки.Текст = РасширенноеПредставление 
	Тогда
		Возврат;
	КонецЕсли; 
	//ОформлениеЯчейки.ТолькоПросмотр = Истина;
	//ОформлениеЯчейки.ЦветФона = ирОбщий.ЦветСтиляЛкс("ирЦветФонаРасширенногоПредставленияЗначения");
	ОформлениеЯчейки.УстановитьТекст(РасширенноеПредставление);

КонецПроцедуры

// Находит файлы в иерархии заданного каталога локальной файловой системы.
//
// Параметры:
//  Путь         - Строка;
//  Маска        - Строка.
//
// Возвращаемое значение:
//  Массив - элементы типа Файл.
//
Функция НайтиФайлыВИерархииЛкс(Путь, Маска) Экспорт
	
	НайденныеКаталоги = НайтиФайлы(Путь, "*.*");
	МассивРезультатов = Новый Массив;
	Для каждого НайденныйФайл Из НайденныеКаталоги Цикл
		Если НайденныйФайл.ЭтоКаталог() Тогда
			МассивРезультатов.Добавить(НайтиФайлыВИерархииЛкс(НайденныйФайл.ПолноеИмя, Маска));
		КонецЕсли; 
	КонецЦикла;
	МассивРезультатов.Добавить(НайтиФайлы(Путь, Маска));
	Результат = Новый Массив;
	Для Каждого ЭлементРезультат Из МассивРезультатов Цикл
		Для Каждого Файл Из ЭлементРезультат Цикл
			Результат.Добавить(Файл);
		КонецЦикла; 
	КонецЦикла;
	Возврат Результат;
	
КонецФункции
	
// Проверяет, является ли тип типом элемента формы.
//
// Параметры:
//  пТип         - Тип - проверяемый тип.
//
// Возвращаемое значение:
//  Истина       - тип элемента формы подтвержден;
//  Ложь         - тип элемента формы не подтвержден.
//
Функция ЛиТипЭлементаФормыЛкс(пТип) Экспорт

	Если Ложь
		ИЛИ пТип = Тип("Индикатор")
		ИЛИ пТип = Тип("Кнопка")
		ИЛИ пТип = Тип("КоманднаяПанель")
		ИЛИ пТип = Тип("Надпись")
		ИЛИ пТип = Тип("Панель")
		ИЛИ пТип = Тип("Переключатель")
		ИЛИ пТип = Тип("ПолеВвода")
		ИЛИ пТип = Тип("ПолеВыбора")
		ИЛИ пТип = Тип("ПолеСписка")
		ИЛИ пТип = Тип("ПолеТекстовогоДокумента")
		ИЛИ пТип = Тип("ПолеТабличногоДокумента")
		ИЛИ пТип = Тип("ПолосаРегулирования")
		ИЛИ пТип = Тип("ТабличноеПоле")
		ИЛИ пТип = Тип("РамкаГруппы")
		ИЛИ пТип = Тип("Флажок")
	Тогда
	    Возврат Истина;
	КонецЕсли;
	Возврат Ложь;

КонецФункции // ЛиТипЭлементаФормыЛкс()
	
// Сообщает об ошибке в тексте запроса и устанавливает выделение на ошибочную строку, если это возможно.
//
// Параметры:
//  *ПолеТекста - ПолеТекста, *Неопределено;
//  *СтартоваяСтрока - Число, *0 - стартовое смещение строки;
//  *СтартоваяКолонка - Число, *0 - стартовое смещение колонки;
//  *ЯзыкПрограммы - Число, *0 - признак обработки ошибки при установке текста запроса;
//  *ЛиМодально     - Булево, *Ложь - модальный режим формы - будет использовано Предупреждение() вместо ирОбщий.СообщитьЛкс().
//  *ИнформацияОбОшибке - ИнформацияОбОшибке, *Неопределено;
//  *ИмяМодуля - Строка, *Неопределено - имя модуля в котором произошла ошибка.
//
// Возвращаемое значение:
//  Строка - истинное описание ошибки.
//
Функция ПоказатьОшибкуВТекстеПрограммыЛкс(Знач ПолеТекста = Неопределено,
	СтартоваяСтрока = 0, СтартоваяКолонка = 0, ЯзыкПрограммы = 0, ЛиМодально = Ложь, ИнформацияОбОшибке = Неопределено,
	ИмяМодуля = Неопределено, ПредставлениеКонтекста = "", ЭтаФорма = Неопределено) Экспорт
	
	ПолеТекста = ОболочкаПоляТекстаЛкс(ПолеТекста);
	#Если Сервер И Не Сервер Тогда
		ПолеТекста = Обработки.ирОболочкаПолеТекста.Создать();
	#КонецЕсли
	Если ЭтаФорма <> Неопределено Тогда
		// Баг платформы. Зависает приложение, если пытаемся установить выделение на невидимой странице.
		ЭтаФорма.ТекущийЭлемент = ПолеТекста.ЭлементФормы;
	КонецЕсли; 
	НомерСтроки = 0;
	Если ИмяМодуля <> Неопределено Тогда
		Вступление = Символы.Таб;
	Иначе
		Вступление = "";
	КонецЕсли;
	Если ИнформацияОбОшибке = Неопределено Тогда
		ИнформацияОбОшибке = ИнформацияОбОшибке();
	КонецЕсли;
	ОписаниеОшибки = ирОбщий.ПодробноеПредставлениеОшибкиЛкс(ИнформацияОбОшибке);
	ирОбщий.ВОписанииОшибкиЕстьПередачаМутабельногоЗначенияЛкс(ОписаниеОшибки, Истина, ЛиМодально);
	Если Истина
		И ЯзыкПрограммы = 0
		И ИмяМодуля <> Неопределено
		И ИнформацияОбОшибке.ИмяМодуля <> ИмяМодуля
	Тогда
		ПоказатьИнформациюОбОшибке(ИнформацияОбОшибке);
		Возврат ОписаниеОшибки;
	КонецЕсли;
	Если ЯзыкПрограммы = 2 Тогда
		Пока ИнформацияОбОшибке.Причина <> Неопределено Цикл
			ИнформацияОбОшибке = ИнформацияОбОшибке.Причина;
		КонецЦикла;  
		Выражение = "";
		Если Выражение = "" Тогда
			Маркер = "Ошибка в выражении """;
			Если Найти(НРег(ИнформацияОбОшибке.Описание), Нрег(Маркер)) = 1 Тогда
				Выражение = Сред(ИнформацияОбОшибке.Описание, СтрДлина(Маркер) + 2, СтрДлина(ИнформацияОбОшибке.Описание) - СтрДлина(Маркер) - 3);
			КонецЕсли; 
		КонецЕсли; 
		Если Выражение = "" Тогда
			Маркер = "Поле не найдено """;
			Если Найти(НРег(ИнформацияОбОшибке.Описание), Нрег(Маркер)) = 1 Тогда
				МаркерНайден = Истина;
				Выражение = Сред(ИнформацияОбОшибке.Описание, СтрДлина(Маркер) + 1, СтрДлина(ИнформацияОбОшибке.Описание) - СтрДлина(Маркер) - 1);
			КонецЕсли; 
		КонецЕсли;
		Если Выражение <> "" Тогда
			ТекстПоля = ПолеТекста.ПолучитьТекст();
			ПозицияВыражения = Найти(ТекстПоля, Выражение);
			Если ПозицияВыражения > 0 Тогда
				ПолеТекста.УстановитьГраницыВыделения(ПозицияВыражения, ПозицияВыражения + СтрДлина(Выражение));
				Пустышка = 0;
				НомерСтроки = 0;
				ПолеТекста.ПолучитьГраницыВыделения(НомерСтроки, Пустышка, Пустышка, Пустышка);
			КонецЕсли; 
		КонецЕсли; 
	КонецЕсли; 
	Если Истина
		И ИнформацияОбОшибке.Причина <> Неопределено 
		И ИнформацияОбОшибке.ИмяМодуля <> ""
		И ИнформацияОбОшибке.ИмяМодуля <> ИмяМодуля
	Тогда 
		ФигурноеОписаниеОшибки = ирОбщий.СтрокаМеждуМаркерамиЛкс(ИнформацияОбОшибке.Причина.Описание, "{", "}", Ложь);
		Если Истина
			И ФигурноеОписаниеОшибки <> Неопределено 
			//И ИнформацияОбОшибке.Причина.ИмяМодуля <> "" // В закомментированном виде в некоторых случаях неоправдано спускается до ошибки в запросе в модуле, а в раскомментированном ломает нахождение ошибки в строке алгоритма
		Тогда 
			ИнформацияОбОшибке = ИнформацияОбОшибке.Причина;
		КонецЕсли;
	КонецЕсли;
	Если Истина
		И ЯзыкПрограммы = 0
		И ИнформацияОбОшибке.ИмяМодуля <> ""
		И ИнформацияОбОшибке.ИмяМодуля <> ИмяМодуля
	Тогда
		ПоказатьИнформациюОбОшибке(ИнформацияОбОшибке);
		Возврат ирОбщий.ПодробноеПредставлениеОшибкиЛкс(ИнформацияОбОшибке);
	КонецЕсли;
	МаксимальныйНомерСтроки = 100000;
	Если ПолеТекста <> Неопределено Тогда
		МаксимальныйНомерСтроки = ПолеТекста.КоличествоСтрок();
	КонецЕсли;
	ФигурноеОписаниеОшибки = ирОбщий.СтрокаМеждуМаркерамиЛкс(ИнформацияОбОшибке.Описание, "{", "}", Ложь);
	ОписаниеОшибки = ИнформацияОбОшибке.Описание;
	Если НомерСтроки = 0 Тогда
		НомерСтроки = Мин(ИнформацияОбОшибке.НомерСтроки + СтартоваяСтрока, МаксимальныйНомерСтроки);
		Если ИнформацияОбОшибке.ИсходнаяСтрока = "" Тогда
			СтрокаКоординатыОшибки = ирОбщий.СтрокаМеждуМаркерамиЛкс(ФигурноеОписаниеОшибки, "(", ")", Ложь);
			Если СтрокаКоординатыОшибки <> Неопределено Тогда 
				НомерКолонки = 0;
				МассивФрагментов = ирОбщий.СтрРазделитьЛкс(СтрокаКоординатыОшибки, ",");
				СтрокаНомерСтроки = МассивФрагментов[0];
				Попытка
					НомерСтроки = Число(СтрокаНомерСтроки);
				Исключение
				КонецПопытки;
				НомерСтроки = Мин(НомерСтроки + СтартоваяСтрока, МаксимальныйНомерСтроки);
				Если МассивФрагментов.Количество() > 1  Тогда
					СтрокаНомерКолонки = МассивФрагментов[1];
					Попытка
						НомерКолонки = Число(СтрокаНомерКолонки);
					Исключение
					КонецПопытки;
					НомерКолонки = НомерКолонки + СтартоваяКолонка;
				КонецЕсли;
				Если НомерСтроки = 0 Тогда
					НомерКолонки = 1;
					НомерСтроки = 1;
				КонецЕсли;
				ОписаниеОшибки = СтрЗаменить(ОписаниеОшибки, ФигурноеОписаниеОшибки, "(" + НомерСтроки + "," + НомерКолонки + ")");
			КонецЕсли;
		КонецЕсли;
	КонецЕсли; 
	Если Истина
		И ЯзыкПрограммы = 0
		И НомерСтроки <= 0 
	Тогда
		Если ЗначениеЗаполнено(ОписаниеОшибки) Тогда
			ОписаниеОшибки = "Ошибка передачи переменной: " + ОписаниеОшибки;
		Иначе
			ОписаниеОшибки = "Ошибка без описания";
		КонецЕсли; 
	Иначе
		ОписаниеОшибки = "Строка кода " + НомерСтроки + ": " + ОписаниеОшибки;
	КонецЕсли;
	Если ИнформацияОбОшибке.Причина <> Неопределено Тогда
		ОписаниеОшибки = ОписаниеОшибки + ": " + ирОбщий.ПодробноеПредставлениеОшибкиЛкс(ИнформацияОбОшибке.Причина);
	КонецЕсли;
	ТекстСообщения = "";
	Если ПолеТекста <> Неопределено Тогда
		Если НомерСтроки > 0 Тогда
			ПолеТекста.ПоказатьОшибку(НомерСтроки, НомерКолонки);
		КонецЕсли;
		ТекстСообщения = ТекстСообщения + ирОбщий.ПредставлениеИзИдентификатораЛкс(ПолеТекста.ЭлементФормы.Имя) + ПредставлениеКонтекста;
		ТекстСообщения = ТекстСообщения + ": " + ОписаниеОшибки;
		ПолныйТекстСообщения = Вступление + ТекстСообщения;
		ирОбщий.СообщитьЛкс(ПолныйТекстСообщения, СтатусСообщения.Важное);
	Иначе
		ПолныйТекстСообщения = Вступление + ТекстСообщения;
		ирОбщий.СообщитьЛкс(ПолныйТекстСообщения, СтатусСообщения.Важное);
	КонецЕсли;
	Возврат ПолныйТекстСообщения;
	
КонецФункции

// Рассчитывает и устанавливает ширину колонок табличного документа. Ориентирована на обработку
// результата построителя отчета.
//
// Параметры:
//  ТабличныйДокумент - ТабличныйДокумент;
//  *ЛиМинимальный - Булево, *Ложь - признак установки необходимой ширины, иначе достаточной;
//  *ЛиИгнорироватьОбразание - Булево, *Ложь - признак игнорирования ячеек с обрезанием;
//  *ШиринаОбластиПолей - Число, *0 - ширина области полей (не показателей);
//  *РассчитыватьШиринуКолонкиПоНазванию - Булево, *Истина - признак расчета ширины колонки по названию;
//  *МинимальнаяШиринаКолонкиПоказатель - Число, *10 - минимальная ширина колонки показателя;
//  *ПорогКоличестваЯчеекДляАнализа - Число, *100000 - пороговое количество ячеек для анализа (усечение по высоте).
//
Процедура УстановитьАвтоширинуКолонокТабличногоДокументаЛкс(ТабличныйДокумент, ЛиМинимальный = Ложь,
	ЛиИгнорироватьОбрезание = Ложь, ШиринаОбластиПолей = 0, РассчитыватьШиринуКолонкиПоНазванию = Ложь,
	МинимальнаяШиринаКолонкиПоказатель = 10, ПорогКоличестваЯчеекДляАнализа = 10000) Экспорт
	
	Перем МаксимальнаяШиринаКолонки;
	Перем КонечнаяСтрока, НачальнаяСтрока, ТекущаяКолонка, ТекущаяСтрока, НачалоДанных;
	Перем ОбластьШапки, ОбластьПодвала;
	Перем ШиринаКолонки, ТекстЯчейки, НомерСтрокиТекста;
	Перем КоличествоУровнейГруппировокСтрок, Отступ;
	Перем ШириныКолонок;
	
	СтрокаСостояния = "Расчет ширины колонок табличного документа ";
	КоличествоОбновленийСостояния = 10;
	
	// Ограничение максимальной ширины колонки
	МаксимальнаяШиринаКолонки = 50;
	
	// Массив, в который будут помещаться ширины колонок
	ШириныКолонок = Новый Массив;
	
	// Получим количество уровней группировок в отчете для учета автоматического отступа
	КоличествоУровнейГруппировокСтрок = ТабличныйДокумент.КоличествоУровнейГруппировокСтрок();
	
	// Инициализируем начальные строки
	НачальнаяСтрока = 0;
	НачалоДанных = 0;
	
	// Найдем в результирующем документе область шапки таблицы
	ОбластьШапки = ТабличныйДокумент.Области.Найти("ШапкаТаблицы");
	
	Если ТипЗнч(ОбластьШапки) = Тип("ОбластьЯчеекТабличногоДокумента") Тогда
		
		// Из шапки таблицы получим начальную строку с которой будем рассчитывать ширины
		НачальнаяСтрока = ОбластьШапки.Верх;
		НачалоДанных = ОбластьШапки.Низ + 1;
		
	Иначе
		
		// Если область шапки таблицы не найдена, найдем область шапки строк
		ОбластьШапки = ТабличныйДокумент.Области.Найти("ШапкаСтрок");
		
		Если ТипЗнч(ОбластьШапки) = Тип("ОбластьЯчеекТабличногоДокумента") Тогда
			
			// Из шапки таблицы получим начальную строку с которой будем рассчитывать ширины
			НачальнаяСтрока = ОбластьШапки.Верх;
			НачалоДанных = ОбластьШапки.Низ + 1;
			
		КонецЕсли;
			
	КонецЕсли;
	
	// Получим область подвала отчета и вычислим конечную строку расчета
	ОбластьПодвала = ТабличныйДокумент.Области.Найти("Подвал");
	
	Если ТипЗнч(ОбластьПодвала) = Тип("ОбластьЯчеекТабличногоДокумента") Тогда
		
		// Область подвала найдена
		КонечнаяСтрока = ОбластьПодвала.Верх - 1;
		
	Иначе 
		
		// Область подвала не найдена
		КонечнаяСтрока = ТабличныйДокумент.ВысотаТаблицы;
		
	КонецЕсли;
	
	СтарыйПрогресс = 0;
	
	КоличествоЯчеекПоказателейДляРасчета = (КонечнаяСтрока - НачальнаяСтрока) * (ТабличныйДокумент.ШиринаТаблицы - 1);
	Если КоличествоЯчеекПоказателейДляРасчета > ПорогКоличестваЯчеекДляАнализа Тогда 
		КонечнаяСтрока = Мин(КонечнаяСтрока, ПорогКоличестваЯчеекДляАнализа / (ТабличныйДокумент.ШиринаТаблицы - 1));
	КонецЕсли;
	
	// Переберем все колонки отчета
	Для ТекущаяКолонка = 1 По ТабличныйДокумент.ШиринаТаблицы Цикл
		ПрогрессКолонок =  ТекущаяКолонка / ТабличныйДокумент.ШиринаТаблицы / КонечнаяСтрока;
		АвтоОтступ = 0;
		// Переберем строки, которые будут использованы для расчета ширин колонок
		Для ТекущаяСтрока = НачальнаяСтрока По КонечнаяСтрока Цикл
			
			ОбработкаПрерыванияПользователя();
			Прогресс = КоличествоОбновленийСостояния * ПрогрессКолонок * ТекущаяСтрока;
			Если Прогресс - СтарыйПрогресс >= 1 Тогда 
				СтарыйПрогресс = Прогресс;
				ирОбщий.СостояниеЛкс(СтрокаСостояния + Цел(100 * ПрогрессКолонок * ТекущаяСтрока) + "%");
			КонецЕсли;
			ШиринаКолонки = 0;

			// Получим область текущей ячейки
			ОбластьЯчейки = ТабличныйДокумент.Область(ТекущаяСтрока, ТекущаяКолонка);
			
			Если ОбластьЯчейки.Лево <> ТекущаяКолонка Или ОбластьЯчейки.Верх <> ТекущаяСтрока Тогда
				// Данная ячейка принадлежит объединенным ячейкам и не является начальной ячейкой
				Продолжить;
			КонецЕсли;
			
			// Данная ячейка обрезает текст
			Если Истина
				И ЛиИгнорироватьОбрезание
				И ОбластьЯчейки.РазмещениеТекста = ТипРазмещенияТекстаТабличногоДокумента.Обрезать
			Тогда
				Продолжить;
			КонецЕсли;
			
			Если КоличествоУровнейГруппировокСтрок > 0 И ТекущаяСтрока = НачалоДанных Тогда
				// Для первой строки с данными получим значение автоотступа
				АвтоОтступ = ОбластьЯчейки.АвтоОтступ;
			КонецЕсли;
			
			// Получим текст ячейки
			ТекстЯчейки = ОбластьЯчейки.Текст;
			
			КоличествоСтрокВТекстеЯчейки = СтрЧислоСтрок(ТекстЯчейки);
			ТекстЯчейкиТД = Новый ТекстовыйДокумент;
			ТекстЯчейкиТД.УстановитьТекст(ТекстЯчейки);

			// Для каждой строки из текста ячейки рассчитаем количество символов в строке
			Для НомерСтрокиТекста = 1 По КоличествоСтрокВТекстеЯчейки Цикл
				ШиринаТекстаЯчейки = СтрДлина(ТекстЯчейкиТД.ПолучитьСтроку(НомерСтрокиТекста));
				Если Истина
					И НЕ РассчитыватьШиринуКолонкиПоНазванию 
					И ТекущаяСтрока < НачалоДанных 
					И ШиринаТекстаЯчейки > 0 
				Тогда
					ШиринаТекстаЯчейки = МинимальнаяШиринаКолонкиПоказатель;
				КонецЕсли;
				// Если используется автоотступ, то прибавим к ширине ячейки его величину
				Если АвтоОтступ <> Неопределено И АвтоОтступ > 0 Тогда
					ШиринаТекстаЯчейки = ШиринаТекстаЯчейки + КоличествоУровнейГруппировокСтрок * АвтоОтступ;
				КонецЕсли;
				ШиринаКолонки = Макс(ШиринаКолонки, ШиринаТекстаЯчейки);
			КонецЦикла;

			Если ШиринаКолонки > МаксимальнаяШиринаКолонки Тогда
				// Ограничим ширину колонки
				ШиринаКолонки = МаксимальнаяШиринаКолонки;
			КонецЕсли;
			
			Если ШиринаКолонки <> 0 Тогда
			// Ширина колонки рассчитана
				
				// Определим, сколько ячеек по ширине используется в области для текущей ячейки
				КоличествоКолонок = ОбластьЯчейки.Право - ОбластьЯчейки.Лево;
				
				// Переберем все ячейки, расположенные в области
				Для НомерКолонки = 0 По КоличествоКолонок Цикл
					
					Если ШириныКолонок.ВГраница() >= ТекущаяКолонка - 1 + НомерКолонки Тогда
						
						// В массиве ширин колонок уже был элемент для текущей колонки
						Если ШириныКолонок[ТекущаяКолонка - 1 + НомерКолонки] = Неопределено Тогда
							
							// Значение ширины колонки еще не было установлено
							ШириныКолонок[ТекущаяКолонка - 1 + НомерКолонки] = ШиринаКолонки / (КоличествоКолонок + 1);
							
						Иначе
							
							// Значение ширины колонки уже было установлено
							// Вычислим максимум ширины колонки
							ШириныКолонок[ТекущаяКолонка - 1 + НомерКолонки] = 
								Макс(ШириныКолонок[ТекущаяКолонка - 1 + НомерКолонки], ШиринаКолонки / (КоличествоКолонок + 1));
							
						КонецЕсли;
						
					Иначе
						
						// В массиве ширин колонок еще не было элемента для данной колонки
						// Добавим элемент в массив ширин колонок
						ШириныКолонок.Вставить(ТекущаяКолонка - 1 + НомерКолонки, ШиринаКолонки / (КоличествоКолонок + 1));
						
					КонецЕсли;
					
				КонецЦикла;
				
			КонецЕсли;
			
		КонецЦикла;	// Конец цикла перебора строк
		
	КонецЦикла;	// Конец цикла перебора колонок
	
	// Переберем все элементы в массиве вычисленных ширин колонок
	Для ТекущаяКолонка = 0 По ШириныКолонок.ВГраница() Цикл
		
		Если ШиринаОбластиПолей >= ТекущаяКолонка Тогда 
			УстановитьМинимальнуюШирину = Ложь;
		Иначе
			УстановитьМинимальнуюШирину = ЛиМинимальный;
		КонецЕсли;
		
		Если ШириныКолонок[ТекущаяКолонка] <> Неопределено Тогда
			
			ОбластьКолонки = ТабличныйДокумент.Область(, ТекущаяКолонка + 1, НачалоДанных, ТекущаяКолонка + 1);
			
			// Ширина колонок установлена
			// Установим ширину области ячеек
			Если УстановитьМинимальнуюШирину Тогда
				ОбластьКолонки.ШиринаКолонки = Макс(ШириныКолонок[ТекущаяКолонка] + 1, МинимальнаяШиринаКолонкиПоказатель);
			Иначе
				ОбластьКолонки.ШиринаКолонки = ШириныКолонок[ТекущаяКолонка] + 1;
			КонецЕсли;
			
		КонецЕсли;
		
	КонецЦикла;
	
	ирОбщий.СостояниеЛкс("");

КонецПроцедуры 

// Устанавливает отбор построителя по расшифровке, содержащей NULL'ы.
// Устанавливает значение каждого NULL элемента отбора в "<Отсутствует>" и вид сравнения в "Равно".
// Для измерений, которые могут содержать значение "NULL" в запросах в секции условий построителя следует
// писать "ЕСТЬNULL(ПутьКДаннымИзмерения, "<Отсутствует>") КАК ИмяИзмерения".
//
// Параметры:
//  пПостроительОтчета - ПостроительОтчета - чей отбор обрабатываем;
//  пРасшифровка - Структура - расшифровка.
//
Процедура УстановитьОтборПостроителяПриРасшифровкеЛкс(пПостроительОтчета, пРасшифровка) Экспорт

	Для каждого ЭлементРасшифровки Из пРасшифровка Цикл
		Если ЭлементРасшифровки.Значение = NULL Тогда
			ЭлементОтбора = пПостроительОтчета.Отбор[ЭлементРасшифровки.Ключ];
			Если ЭлементОтбора.ТипЗначения.СодержитТип(Тип("Строка")) Тогда
				ЭлементОтбора.Значение = "<Отсутствует>";
				Если ЭлементОтбора.ВидСравнения = ВидСравнения.ВИерархии Тогда 
					ЭлементОтбора.ВидСравнения = ВидСравнения.Равно;
				КонецЕсли;
			Иначе
				ирОбщий.СообщитьЛкс(ирОбщий.СтрШаблонИменЛкс("Запрос не поддерживает расшифровку по отсутствующему значению элемента отбора %1!",, ЭлементОтбора.Представление));
			КонецЕсли;
		КонецЕсли;
	КонецЦикла;

КонецПроцедуры

// Получает копию построителя отчетов.
//
// Параметры:
//  Оригинал     - ПостроительОтчета.
//
// Возвращаемое значение:
//               - <Тип.Вид> - <описание значения>
//                 <продолжение описания значения>;
//  <Значение2>  - <Тип.Вид> - <описание значения>
//                 <продолжение описания значения>.
//
Функция _СкопироватьПостроительОтчетаЛкс(Оригинал, ВосстанавливатьНастройки = Истина) Экспорт

	Копия = Новый ПостроительОтчета;
	Для Каждого ДоступноеПоле Из Оригинал.ДоступныеПоля Цикл
		ЗаполнитьЗначенияСвойств(Копия.ДоступныеПоля.Добавить(ДоступноеПоле.Имя, ДоступноеПоле.Представление), ДоступноеПоле);
	КонецЦикла;
	Если ВосстанавливатьНастройки Тогда
		Копия.Текст = Оригинал.Текст;
		Копия.ЗаполнитьНастройки(); // Баг платформы. Без этого почему то иногда измерения не восстанавливаются!
		Копия.УстановитьНастройки(Оригинал.ПолучитьНастройки());
	КонецЕсли;
	Возврат Копия;

КонецФункции

// Возвращает менеджер временных таблиц, в котором создана временная таблица по переданному источнику.
//
// Параметры:
//  ТаблицаЗначений - ТаблицаЗначений;
//  ИмяТаблицы   - Строка;
//  *МенеджерВременныхТаблиц - МенеджерВременныхТаблиц, *Неопределено.
//
// Возвращаемое значение:
//  МенеджерВременныхТаблиц.
//
Функция _МенеджерВременныхТаблицИзТаблицыЛкс(ТаблицаЗначений, ИмяТаблицы, МенеджерВременныхТаблиц = Неопределено) Экспорт 

	#Если Сервер И Не Сервер Тогда
		ТаблицаЗначений = Новый ТаблицаЗначений;
	#КонецЕсли
	Если МенеджерВременныхТаблиц = Неопределено Тогда
		МенеджерВременныхТаблиц = Новый МенеджерВременныхТаблиц;
	КонецЕсли;
	ТекстВЫБРАТЬ = "";
	Для Каждого Колонка Из ТаблицаЗначений.Колонки Цикл
		ТекстВЫБРАТЬ = ТекстВЫБРАТЬ + ", " + Колонка.Имя;
	КонецЦикла;
	ТекстЗапроса = "ВЫБРАТЬ " + Сред(ТекстВЫБРАТЬ, 3);
	ТекстЗапроса = ТекстЗапроса + "	ПОМЕСТИТЬ " + ИмяТаблицы;
	ТекстЗапроса = ТекстЗапроса + "	ИЗ &ВнешнийИсточник КАК ВнешнийИсточник";
	Запрос = Новый Запрос(ТекстЗапроса);
	Запрос.МенеджерВременныхТаблиц = МенеджерВременныхТаблиц;
	Запрос.УстановитьПараметр("ВнешнийИсточник", ТаблицаЗначений);
	Запрос.Выполнить();
	Возврат МенеджерВременныхТаблиц;

КонецФункции

Процедура ПанельИнструментовОПодсистемеЛкс() Экспорт
	
	ОткрытьСправкуПоПодсистемеЛкс();
	
КонецПроцедуры

// Открывает обработку ирПоискДублейИЗаменаСсылок и заполняет группы дублей по табличному полю, связанному с таблицей или деревом значений.
//
Процедура ОткрытьФормуЗаменыСсылокИзТабличногоПоляЛкс(ТабличноеПоле) Экспорт

	Если ТабличноеПоле.ТекущаяКолонка = Неопределено Тогда
		Возврат;
	КонецЕсли; 
	ФормаОбработки = ПолучитьФормуЛкс("Обработка.ирПоискДублейИЗаменаСсылок.Форма");
	Если ТипЗнч(ТабличноеПоле.Значение) = Тип("ТаблицаЗначений") Тогда
		ВыделенныеСтроки = ТабличноеПоле.ВыделенныеСтроки;
		СписокВыбора = Новый СписокЗначений;
		СписокВыбора.Добавить(0, "Создать группы дублей из пар неправильных значений текущей и правильных значений следующей колонок");
		СписокВыбора.Добавить(1, "Создать одну группу дублей из значений текущей колонки выделенных строк");
		//СписокВыбора.Добавить(2, "Создать правила замены значений из текущей колонки на значения следующей колонки");
		ВыбранныйВариант = СписокВыбора.ВыбратьЭлемент("Выберите вариант");
		Если ВыбранныйВариант = Неопределено Тогда
			Возврат;
		КонецЕсли; 
		Если ВыбранныйВариант.Значение = 1 Тогда
			Если ВыделенныеСтроки.Количество() = 0 Тогда
				Возврат ;
			КонецЕсли; 
			ИмяКолонки = ирОбщий.ПутьКДаннымКолонкиТабличногоПоляЛкс(ТабличноеПоле);
			Если Не ЗначениеЗаполнено(ИмяКолонки) Тогда
				Возврат;
			КонецЕсли; 
			МассивСсылок = Новый Массив;
			Для Каждого Строка Из ВыделенныеСтроки Цикл
				ЗначениеСтроки = Строка[ИмяКолонки];
				ТипЗначения = ТипЗнч(ЗначениеСтроки);
				Если Метаданные.НайтиПоТипу(ТипЗначения) = Неопределено Тогда
					Продолжить;
				КонецЕсли; 
				МассивСсылок.Добавить(ЗначениеСтроки);
			КонецЦикла;
			ФормаОбработки.ОткрытьДляЗаменыПоСпискуСсылок(МассивСсылок,, 0);
		ИначеЕсли ВыбранныйВариант.Значение = 0 Тогда
			ТекущаяКолонка = ТабличноеПоле.ТекущаяКолонка;
			Если Ложь
				Или ТекущаяКолонка = Неопределено 
				Или ТекущаяКолонка.Данные = ""
			Тогда
				Возврат;
			КонецЕсли;
			ИндексКолонки = ТабличноеПоле.Колонки.Индекс(ТекущаяКолонка);
			Если ТабличноеПоле.Колонки.Количество() = ИндексКолонки + 1 Тогда
				Возврат;
			КонецЕсли; 
			СледующаяКолонка = ТабличноеПоле.Колонки[ИндексКолонки + 1];
			Если СледующаяКолонка.Данные = "" Тогда
				Возврат;
			КонецЕсли; 
			ФормаОбработки.ОткрытьСЗаполнениемГруппДублейПоТаблицеПар(ТабличноеПоле.Значение, ТекущаяКолонка.Данные, СледующаяКолонка.Данные);
		КонецЕсли;
	ИначеЕсли ТипЗнч(ТабличноеПоле.Значение) = Тип("ДеревоЗначений") Тогда
		ФормаОбработки.ОткрытьДляЗаменыПоДеревуСсылок(ТабличноеПоле.Значение, ТабличноеПоле.ТекущаяКолонка.Имя);
	КонецЕсли; 

КонецПроцедуры

// Возвращает кнопку командной панели компоненты по ее имени из макета.
//
// Параметры:
//  ОбъектКомпоненты - ОбработкаОбъект - компонента;
//  КраткоеИмяКнопки - Строка - имя кнопки из макета компоненты;
//  *КоманднаяПанель - КоманднаяПанель, *Неопределено - на случай, если у компоненты несколько командных панелей.
//
// Возвращаемое значение:
//  Кнопка.
//
Функция КнопкаКоманднойПанелиЭкземпляраКомпонентыЛкс(ОбъектКомпоненты, КраткоеИмяКнопки,
	Знач КоманднаяПанель = Неопределено) Экспорт

	Если КоманднаяПанель = Неопределено Тогда
		КоманднаяПанель = ОбъектКомпоненты.КоманднаяПанель;
	КонецЕсли;
	Если КоманднаяПанель = Неопределено Тогда
		// Был вызван деструктор
		Возврат Неопределено;
	КонецЕсли;
	ПолноеИмяКнопки = СформироватьИмяЭлементаУправленияЭкземпляраЛкс(ОбъектКомпоненты, КраткоеИмяКнопки);
	Кнопка = КоманднаяПанель.Кнопки.Найти(ПолноеИмяКнопки);
	Если Кнопка = Неопределено Тогда
		Для Каждого Подменю Из КоманднаяПанель.Кнопки Цикл
			Если Подменю.ТипКнопки <> ТипКнопкиКоманднойПанели.Подменю Тогда
				Продолжить;
			КонецЕсли; 
			Кнопка = КнопкаКоманднойПанелиЭкземпляраКомпонентыЛкс(ОбъектКомпоненты, КраткоеИмяКнопки, Подменю);
			Если Кнопка <> Неопределено Тогда
				Прервать;
			КонецЕсли; 
		КонецЦикла; 
	КонецЕсли;
	Возврат Кнопка;

КонецФункции

// Формирует имя элемента управления экземпляра компоненты.
//
// Параметры:
//  ИмяКласса    - Строка;
//  ИмяЭкземпляра - Строка;
//  КраткоеИмяЭлементаУправления - Строка.
//
// Возвращаемое значение:
//  Строка - имя.
//
Функция СформироватьИмяЭлементаУправленияЭкземпляраЛкс(ОбъектКомпоненты, КраткоеИмяЭлементаУправления) Экспорт

	Возврат ПрефиксИменЭлементовЭкземпляраКомпонентыЛкс(ОбъектКомпоненты) + КраткоеИмяЭлементаУправления;

КонецФункции

Функция ПрефиксИменЭлементовЭкземпляраКомпонентыЛкс(ОбъектКомпоненты) Экспорт 
	
	Возврат ОбъектКомпоненты.ИмяКласса + "_" + ОбъектКомпоненты.Имя + "_";

КонецФункции // СформироватьИмяЭлементаУправленияЭкземпляраЛкс()

Функция НоваяТаблицуСобытийЭлементаУправленияКомпонентыЛкс() Экспорт 

	ТаблицаСобытий = Новый ТаблицаЗначений;
	ТаблицаСобытий.Колонки.Добавить("СобытиеОбъекта");
	ТаблицаСобытий.Колонки.Добавить("БлижайшийВидАлгоритма");
	ТаблицаСобытий.Колонки.Добавить("ИмяСобытия");
	ТаблицаСобытий.Колонки.Добавить("Компонента");
	ТаблицаСобытий.Колонки.Добавить("ВызовОбработчика");
	Возврат ТаблицаСобытий;

КонецФункции

// Добавляет в кнопки командной панели приемника коллекцию кнопок командной панели источника.
//
// Параметры:
//  ОбъектКомпоненты - ОбработкаОбъект - компонента;
//  КнопкиМакета  - КоллекцияКнопокКоманднойПанели - источник;
//  КнопкиПриемника - КоллекцияКнопокКоманднойПанели - приемник;
//  *ДействияКнопокКомпонент - ТаблицаЗначений, *Неопределено;
//
Процедура ДобавитьКнопкиКоманднойПанелиКомпонентыЛкс(ОбъектКомпоненты, КнопкиМакета, КнопкаПриемника,
	ДействияКнопокКомпонент = Неопределено, ОбщийПриемник = Неопределено, НеДобавлятьЕслиСуществует = Ложь) Экспорт
	
	КнопкиПриемника = КнопкаПриемника.Кнопки;
	ИмяКласса = ОбъектКомпоненты.ИмяКласса;
	Если ДействияКнопокКомпонент = Неопределено Тогда
		ДействиеТранслятор = Новый Действие("Клс" + ИмяКласса + "Нажатие");
	Иначе
		ЭтоКоманднаяПанель = (ТипЗнч(КнопкаПриемника) = Тип("КоманднаяПанель"));
		ДопКнопкиКомандныхПанелей = ОбъектКомпоненты.ДопКнопкиКомандныхПанелей;
		ДопКнопкиКоманднойПанели = Новый Массив;
		ДопКнопкиКомандныхПанелей.Вставить(КнопкаПриемника.Имя, ДопКнопкиКоманднойПанели);
		ДействиеТранслятор = Новый Действие("КнопкаКоманднойПанели_Действие")
	КонецЕсли;
	ИмяЭкземпляра = ОбъектКомпоненты.Имя;
	Для Каждого КнопкаМакета Из КнопкиМакета Цикл
		Кнопка = Неопределено;
		ИмяКнопкиСПрефиксом = СформироватьИмяЭлементаУправленияЭкземпляраЛкс(ОбъектКомпоненты, КнопкаМакета.Имя);
		Если КнопкаМакета.ТипКнопки = ТипКнопкиКоманднойПанели.Действие Тогда 
			Если Истина
				И Строка(КнопкаМакета.Действие) = "" 
			Тогда
				Если НеДобавлятьЕслиСуществует И КнопкиПриемника.Найти(ИмяКнопкиСПрефиксом) <> Неопределено Тогда
					Продолжить;
				КонецЕсли; 
				// Это пустое действие
				Кнопка = КнопкиПриемника.Добавить(ИмяКнопкиСПрефиксом, КнопкаМакета.ТипКнопки);
				ЗаполнитьЗначенияСвойств(Кнопка, КнопкаМакета, , "Действие, Имя");
				//Попытка
					Кнопка.Действие = ДействиеТранслятор;
				//Исключение
				//	ОписаниеОшибки = ОписаниеОшибки(); // Для отладки
				//	Возврат;
				//КонецПопытки;
				Если ДействияКнопокКомпонент <> Неопределено Тогда
					СтрокаДействия = ДействияКнопокКомпонент.Добавить();
					СтрокаДействия.Кнопка = Кнопка;
					СтрокаДействия.Компонента = ОбъектКомпоненты;
					ВызовОбработчика = "Действие_";
					Если ОбщийПриемник = Неопределено Тогда
						ВызовОбработчика = ВызовОбработчика + КнопкаМакета.Имя;
					Иначе
						ВызовОбработчика = ВызовОбработчика + ОбщийПриемник;
					КонецЕсли;
					СтрокаДействия.ВызовОбработчика = ВызовОбработчика + "(П0, П1)";
				КонецЕсли;
			Иначе 
				Если НеДобавлятьЕслиСуществует И КнопкиПриемника.Найти(КнопкаМакета.Имя) <> Неопределено Тогда
					Продолжить;
				КонецЕсли; 
				Кнопка = КнопкиПриемника.Добавить(КнопкаМакета.Имя, КнопкаМакета.ТипКнопки, , КнопкаМакета.Действие);
				// Автокартинки предопределенных действий платформа подключает до вызова ПередОткрытием, а потом они уже пустые
				Если КнопкаМакета.Картинка.Вид <> ВидКартинки.Пустая Тогда
					Кнопка.Картинка = КнопкаМакета.Картинка;
				КонецЕсли; 
				ЗаполнитьЗначенияСвойств(Кнопка, КнопкаМакета, , "Имя, ТипКнопки, Картинка");
			КонецЕсли;
		КонецЕсли;
		Если Кнопка = Неопределено Тогда
			Если НеДобавлятьЕслиСуществует И КнопкиПриемника.Найти(ИмяКнопкиСПрефиксом) <> Неопределено Тогда
				Продолжить;
			КонецЕсли; 
			Кнопка = КнопкиПриемника.Добавить(ИмяКнопкиСПрефиксом);
			ЗаполнитьЗначенияСвойств(Кнопка, КнопкаМакета, , "Действие, Имя");
			Если КнопкаМакета.ТипКнопки = ТипКнопкиКоманднойПанели.Подменю Тогда 
				ДобавитьКнопкиКоманднойПанелиКомпонентыЛкс(ОбъектКомпоненты, КнопкаМакета.Кнопки, Кнопка, ДействияКнопокКомпонент, ОбщийПриемник);
			КонецЕсли; 
		КонецЕсли;
		Если Истина
			И ДействияКнопокКомпонент <> Неопределено
			И ЭтоКоманднаяПанель
		Тогда
			ДопКнопкиКоманднойПанели.Добавить(Кнопка.Имя);
		КонецЕсли;
	КонецЦикла;

КонецПроцедуры

// Возвращает имя экземпляра компоненты, которой принадлежит элемент управления.
//
// Параметры:
//  ЭлементУправления - ЭлементУправления.
//
// Возвращаемое значение:
//  Строка - имя.
//
Функция ИмяЭкземпляраКомпонентыЛкс(ЭлементУправления) Экспорт

	Результат = ирОбщий.СтрРазделитьЛкс(ЭлементУправления.Имя, "_")[1];
	Возврат Результат;

КонецФункции

Процедура ТабличноеПолеКолонокПриВыводеСтрокиЛкс(Знач ОформлениеСтроки, Знач ДанныеСтроки, Знач ИмяКолонкиОписанияТипов = "ТипЗначения") Экспорт 
	
	ИндексКартинки = ИндексКартинкиТипаЗначенияБДЛкс(ДанныеСтроки[ИмяКолонкиОписанияТипов]);
	Если ИндексКартинки <> Неопределено Тогда
		ОформлениеСтроки.Ячейки[ИмяКолонкиОписанияТипов].ОтображатьКартинку = Истина;
		ОформлениеСтроки.Ячейки[ИмяКолонкиОписанияТипов].ИндексКартинки = ИндексКартинки;
	КонецЕсли;

КонецПроцедуры

// Глобальный обработчик события ПриПолученииДанных для табличных полей доступных полей компоновки.
//
// Параметры:
//  ЭтаФорма					 - Форма - 
//  Элемент						 - ТабличноеПоле - системное дерево доступных полей, коллекция элементов настроек компоновки, таблица значений (конструктор запроса)
//  ОформленияСтрок				 - 	 - ОформленияСтрок.
//  ТабличноеПолеВыбранныхПолей	 - 	 - 
//
Процедура ПриПолученииДанныхТабличногоПоляКомпоновкиЛкс(ЭтаФорма, Элемент, ОформленияСтрок, ТабличноеПолеВыбранныхПолей = Неопределено, ОтображатьВВидеИмен = Ложь) Экспорт
	
	//СлужебныеДанныеФормы = ирОбщий.СлужебныеДанныеФормыЛкс(ЭтаФорма);
	//ОбработчикиПриВыводеСтроки = СлужебныеДанныеФормы.ОбработчикиПриВыводеСтроки;
	//ОбработчикПриВыводеСтроки = ОбработчикиПриВыводеСтроки[Элемент.Имя];
	//Если Истина
	//	И ОбработчикПриВыводеСтроки <> Неопределено 
	//	И Не ирОбщий.МетодРеализованЛкс(ЭтаФорма, ОбработчикПриВыводеСтроки) // Сообщение о его отсутствии выдаем в общем обработчике Форма_ПриОткрытии
	//Тогда
	//	ОбработчикПриВыводеСтроки = Неопределено;
	//КонецЕсли;
	КолонкаКартинки = КолонкаКартинкиТабличногоПоляКомпоновкиЛкс(Элемент);
	Если Истина
		И ТабличноеПолеВыбранныхПолей <> Неопределено 
		И ОформленияСтрок[0].Ячейки.Найти("Использовано") <> Неопределено 
	Тогда
		ВсеПоляВыбранныхПолей = ирОбщий.ВсеВыбранныеПоляГруппировкиКомпоновкиЛкс(ТабличноеПолеВыбранныхПолей.Значение,,, Истина);
	КонецЕсли; 
	ДоступныеПоля = ирОбщий.ДоступныеПоляКоллекцииНастроекКомпоновкиЛкс(Элемент.Значение);
	#Если Сервер И Не Сервер Тогда
		ДоступныеПоля = Новый НастройкиКомпоновкиДанных;
		ДоступныеПоля = ДоступныеПоля.ДоступныеПоляВыбора;
	#КонецЕсли
	КартинкаРеквизита = ирКэш.КартинкаПоИмениЛкс("ирРеквизит");
	Для каждого ОформлениеСтроки Из ОформленияСтрок Цикл
		ДанныеСтроки = ОформлениеСтроки.ДанныеСтроки;
		ТипСтроки = ТипЗнч(ДанныеСтроки);
		ЭтоДоступноеПоле = Ложь
			Или ТипСтроки = Тип("ДоступноеПолеКомпоновкиДанных") 
			Или ТипСтроки = Тип("ДоступноеПолеОтбораКомпоновкиДанных"); 
		ДоступноеПоле = ДанныеСтроки;
		Если Истина
			И ТипСтроки = Тип("ЭлементОтбораКомпоновкиДанных") 
			И ДанныеСтроки.ЛевоеЗначение <> Неопределено 
		Тогда
			ДоступноеПоле = ДоступныеПоля.НайтиПоле(ДанныеСтроки.ЛевоеЗначение);
		ИначеЕсли Истина
			И ТипСтроки <> Тип("СтрокаТаблицыЗначений") 
			И Не ЭтоДоступноеПоле
		Тогда
			Попытка
				ДоступноеПоле = ДоступныеПоля.НайтиПоле(ДанныеСтроки.Поле);
			Исключение
				ДоступноеПоле = Неопределено;
			КонецПопытки;
		КонецЕсли;
		Если ДоступноеПоле = Неопределено Тогда
			Продолжить;
		КонецЕсли; 
		#Если Сервер И Не Сервер Тогда
			ДоступноеПоле = ДоступныеПоля.НайтиПоле();
		#КонецЕсли
		Ячейки = ОформлениеСтроки.Ячейки;
		ЯчейкаПоля = Ячейки[КолонкаКартинки];
		ЯчейкаТипа = Ячейки.Найти("Тип");
		Если ЯчейкаТипа <> Неопределено Тогда
			Ячейки.Тип.УстановитьТекст(ДоступноеПоле.ТипЗначения);
		КонецЕсли; 
		ИндексКартинки = Неопределено;
		Попытка
			ЭтоПапка = ДоступноеПоле.Папка;
			ЭтоРесурс = ДоступноеПоле.Ресурс;
		Исключение
			ЭтоПапка = Ложь;
			ЭтоРесурс = Ложь;
		КонецПопытки;
		Если ЭтоПапка Тогда
			ПапкаСРесурсами = ДоступноеПоле.Элементы.Количество() > 0;
			Для каждого ДоступноеПоле Из ДоступноеПоле.Элементы Цикл
				Если Не ДоступноеПоле.Ресурс Тогда
					ПапкаСРесурсами = Ложь;
					Прервать;
				КонецЕсли;
			КонецЦикла;
			Если ПапкаСРесурсами Тогда
				ИндексКартинки = 17;
			КонецЕсли;
		КонецЕсли; 
		НовыйТекстЯчейки = "";
		Если Не ЭтоРесурс И Не ЭтоПапка Тогда
			ИндексКартинки = ИндексКартинкиТипаЗначенияБДЛкс(ДоступноеПоле.ТипЗначения);
		КонецЕсли;
		Если ИндексКартинки <> Неопределено Тогда
			ЯчейкаПоля.ОтображатьКартинку = Истина;
			ЯчейкаПоля.ИндексКартинки = ИндексКартинки;
			Если Истина
				И ОтображатьВВидеИмен
				И ТипСтроки <> Тип("СтрокаТаблицыЗначений") 
				И Не ЭтоПапка
			Тогда 
				ПолноеИмяПоля = "" + ДоступноеПоле.Поле;
				КраткоеИмя = ирОбщий.ПоследнийФрагментЛкс(ПолноеИмяПоля);
				//Если Найти(ЯчейкаПоля.Текст, "_") > 0 Тогда 
				//	Если СтрЗаменить(ЯчейкаПоля.Текст, "._", ".") = ПолноеИмяПоля Тогда
				//		ЯчейкаПоля.УстановитьТекст(ПолноеИмяПоля);
				//	Иначе
				//		//Если ЯчейкаПоля.Текст = "_" + КраткоеИмя Тогда 
				//		//	ЯчейкаПоля.УстановитьТекст(КраткоеИмя);
				//		//КонецЕсли;
				//	КонецЕсли;
				//КонецЕсли;
				Если ЭтоДоступноеПоле Тогда
					Если ЯчейкаПоля.Текст <> КраткоеИмя Тогда 
						ЯчейкаПоля.УстановитьТекст(КраткоеИмя);
					КонецЕсли;
				Иначе
					Если ЯчейкаПоля.Текст <> ПолноеИмяПоля Тогда 
						ЯчейкаПоля.УстановитьТекст(ПолноеИмяПоля);
					КонецЕсли;
				КонецЕсли;
			КонецЕсли;
		КонецЕсли; 
		Если Истина
			И ВсеПоляВыбранныхПолей <> Неопределено 
			И ВсеПоляВыбранныхПолей.Найти(ДоступноеПоле.Поле) <> Неопределено 
		Тогда
			Ячейки.Использовано.УстановитьКартинку(КартинкаРеквизита);
		КонецЕсли;
		Если Ячейки.Найти("Заголовок") <> Неопределено Тогда
			Типы = ДоступноеПоле.ТипЗначения.Типы();
			Если Типы.Количество() > 1 Тогда
				Ячейки.Заголовок.УстановитьТекст(Ячейки.Заголовок.Текст + " (" + XMLСтрока(Типы.Количество()) + "т)");
			КонецЕсли; 
		КонецЕсли; 
		//Если ОбработчикПриВыводеСтроки = Неопределено Тогда
			ТабличноеПолеПриВыводеСтрокиЛкс(ЭтаФорма, Элемент, ОформлениеСтроки, ДанныеСтроки);
		//Иначе
		//	Выполнить("ЭтаФорма." + ОбработчикПриВыводеСтроки + "(Элемент, ОформлениеСтроки, ДанныеСтроки);");
		//КонецЕсли; 
	КонецЦикла;

КонецПроцедуры

Процедура ОформитьСтрокуДоступногоПоляЛкс(ОформлениеСтроки, СтрокаПоля, Знач СтрокаДоступнойТаблицы = Неопределено, ИмяКолонки = "Заголовок", Знач ЭтоИндекс = Ложь, Использовано = Ложь) Экспорт 
	
	Ячейки = ОформлениеСтроки.Ячейки;
	ЭтоСтандартное = Истина
		И СтрокаПоля <> Неопределено 
		И (Ложь
			Или СтрокаПоля.Метаданные = Неопределено 
			Или ТипЗнч(СтрокаПоля.Метаданные) = Тип("ОписаниеСтандартногоРеквизита"))
		И Не СтрокаПоля.ТипЗначения.СодержитТип(Тип("ТаблицаЗначений"))
		И (Ложь
			Или СтрокаДоступнойТаблицы = Неопределено
			Или (Истина
				И СтрокаДоступнойТаблицы.Тип <> "ДвиженияССубконто"
				И СтрокаДоступнойТаблицы.Тип <> "ВиртуальнаяТаблица"
				И СтрокаДоступнойТаблицы.Тип <> "ВременнаяТаблица"
				И СтрокаДоступнойТаблицы.Тип <> "Параметр"
				И СтрокаДоступнойТаблицы.Тип <> "Константы"));
	ТекстВСкобках = "";
	ЭтоИзмерение = Найти(ирОбщий.ПолноеИмяМДПоляТаблицыЛкс(СтрокаПоля), ".Измерение.") > 0;
	Если Истина
		И СтрокаПоля <> Неопределено 
		И ИмяКолонки <> "Заголовок"
	Тогда
		Типы = СтрокаПоля.ТипЗначения.Типы();
		Если Типы.Количество() > 1 Тогда
			ТекстВСкобках = ТекстВСкобках + "," + XMLСтрока(Типы.Количество()) + "т";
		КонецЕсли; 
	КонецЕсли; 
	Если ЭтоИзмерение Тогда
		ТекстВСкобках = ТекстВСкобках + ",Измер";
	КонецЕсли;
	Если Ложь
		Или ЭтоИзмерение 
		Или (Истина
			И СтрокаПоля <> Неопределено
			И СтрокаДоступнойТаблицы <> Неопределено
			И СтрокаПоля.Имя = ирОбщий.ПеревестиСтроку("Ссылка") 
			И НуженСдвигПоляСсылкаВНачалоСпискаЛкс(СтрокаДоступнойТаблицы.Тип))
	Тогда
		ОформлениеСтроки.ЦветФона = Новый Цвет(255, 245, 240);
	КонецЕсли;
	Если ЭтоСтандартное Тогда
		//ТекстВСкобках = ТекстВСкобках + ",Станд";
		//ОформлениеСтроки.ЦветФона = Новый Цвет(250, 250, 255);
	КонецЕсли; 
	Если ЭтоИндекс Тогда
		ТекстВСкобках = ТекстВСкобках + ",Индекс";
	КонецЕсли;
	Если ЗначениеЗаполнено(ТекстВСкобках) Тогда
		ТекстВСкобках = " (" + Сред(ТекстВСкобках, 2) + ")";
		Ячейки[ИмяКолонки].УстановитьТекст(Ячейки[ИмяКолонки].Текст + ТекстВСкобках);
	КонецЕсли;
	Если Использовано И Ячейки.Найти("Использовано") <> Неопределено Тогда
		Ячейки.Использовано.УстановитьКартинку(ирКэш.КартинкаПоИмениЛкс("ирРеквизит"));
	КонецЕсли;

КонецПроцедуры

Функция НуженСдвигПоляСсылкаВНачалоСпискаЛкс(Знач ТипТаблицы) Экспорт 
	
	Возврат Ложь
		Или ирОбщий.ЛиКорневойТипСсылкиЛкс(ТипТаблицы) 
		Или ирОбщий.ЛиКорневойТипЖурналаДокументовЛкс(ТипТаблицы) 
		Или ирОбщий.ЛиТипВложеннойТаблицыБДЛкс(ТипТаблицы);

КонецФункции

Процедура ОформитьСтрокуДопРеквизитаБСПЛкс(ОформлениеСтроки) Экспорт
	
	ОформлениеСтроки.ЦветТекста = Новый Цвет(0, 0, 128);
	
КонецПроцедуры

Процедура УсловноеОформлениеПриВыводеСтрокиЛкс(Знач ЭтаФорма, Знач Элемент, Знач ОформлениеСтроки, Знач ДанныеСтроки, Знач КомпоновщикНастроек = Неопределено) Экспорт 
	
	#Если Сервер И Не Сервер Тогда
		ДанныеСтроки = Новый НастройкиКомпоновкиДанных;
		ДанныеСтроки = ДанныеСтроки.УсловноеОформление.Элементы[0];
		КомпоновщикНастроек = Новый КомпоновщикНастроекКомпоновкиДанных;
	#КонецЕсли
	ТабличноеПолеПриВыводеСтрокиЛкс(ЭтаФорма, Элемент, ОформлениеСтроки, ДанныеСтроки);
	МассивОформляемыхКолонок = Новый Массив;
	//МассивОформляемыхКолонок.Добавить("ОформлениеДляКраткогоОтображенияЭлемента");
	//МассивОформляемыхКолонок.Добавить("ПредставлениеДляКраткогоОтображенияЭлемента");
	//МассивОформляемыхКолонок.Добавить("ОформлениеДляПодробногоОтображенияЭлемента");
	//МассивОформляемыхКолонок.Добавить("ПредставлениеДляПодробногоОтображенияЭлемента");
	МассивОформляемыхКолонок.Добавить("Пример");
	//МассивТекстовыхКолонок = Новый Массив;
	//МассивТекстовыхКолонок.Добавить("ОформлениеДляПодробногоОтображенияЭлемента");
	//МассивТекстовыхКолонок.Добавить("ОформлениеДляКраткогоОтображенияЭлемента");
	ИменаКолонокОбласти = Новый Массив;
	ИменаКолонокОбласти.Добавить("ОбластиДляКраткогоОтображенияЭлемента");
	ИменаКолонокОбласти.Добавить("ОбластиДляПодробногоОтображенияЭлемента");
	ИменаКолонокОтбора = Новый Массив;
	ИменаКолонокОтбора.Добавить("ОтборДляКраткогоОтображенияЭлемента");
	ИменаКолонокОтбора.Добавить("ОтборДляПодробногоОтображенияЭлемента");
	ПараметрФормат = Новый ПараметрКомпоновкиДанных("Format");
	ПараметрТекст  = Новый ПараметрКомпоновкиДанных("Text");
	//Для Каждого ОформлениеСтроки Из ОформленияСтрок Цикл
	//	ДанныеСтроки = ОформлениеСтроки.ДанныеСтроки;	
	//: ДанныеСтроки = Новый ("ЭлементУсловногоОформленияКомпоновкиДанных")
	Ячейки = ОформлениеСтроки.Ячейки;
	ЯчейкаОформления = Ячейки.Пример;
	//Для Каждого ИмяКолонки Из МассивТекстовыхКолонок Цикл
	//	ЯчейкаТекста = Ячейки[ИмяКолонки];
	//	Если ЯчейкаТекста.Видимость Тогда
	//		Прервать;
	//	КонецЕсли;	
	//КонецЦикла;
	Для Каждого ИмяКолонки Из ИменаКолонокОбласти Цикл
		ЯчейкаОбласти = Ячейки[ИмяКолонки];
		Если ЯчейкаОбласти.Видимость Тогда
			Прервать;
		КонецЕсли;	
	КонецЦикла;
	Для Каждого ИмяКолонки Из ИменаКолонокОтбора Цикл
		ЯчейкаОтбор = Ячейки[ИмяКолонки];
		Если ЯчейкаОтбор.Видимость Тогда
			Прервать;
		КонецЕсли;	
	КонецЦикла;
	ЗначенияПараметров = ДанныеСтроки.Оформление.Элементы;
	
	ПредставлениеЗначенийПараметра = "";
	Для Каждого ЗначениеПараметра Из ЗначенияПараметров Цикл
		Если НЕ ЗначениеПараметра.Использование Тогда
			Продолжить;
		КонецЕсли;
		Если ЗначениеПараметра.Параметр = ПараметрФормат Тогда
		ИначеЕсли ЗначениеПараметра.Параметр = ПараметрТекст Тогда
		Иначе
			Попытка
				Выполнить("ЯчейкаОформления." + ЗначениеПараметра.Параметр + " = ЗначениеПараметра.Значение;");
			Исключение
			КонецПопытки;
		КонецЕсли;
		Если ПредставлениеЗначенийПараметра <> "" Тогда
			ПредставлениеЗначенийПараметра = ПредставлениеЗначенийПараметра + ", ";
		КонецЕсли;
		ПредставлениеЗначенийПараметра = ПредставлениеЗначенийПараметра + ЗначениеПараметра.Параметр + "=" + ЗначениеПараметра.Значение;
	КонецЦикла;
	//Выполнить("ЯчейкаТекста.УстановитьТекст(ПредставлениеЗначенийПараметра);");
	ЯчейкаОформления.УстановитьТекст("Пример");
	
	// Антибаг платформы 8.2.13. Если область элемента оформления содержит включенные пустые поля, то представление области выглядит пустым,
	// а элемент оформления не будет применяться даже если он включен. Поэтому нужно отобразить такие пустые поля
	Если Истина
		И ЯчейкаОбласти.Видимость
		//И "" + ДанныеСтроки.Поля = ""
		И ЯчейкаОбласти.Текст = ""
		И ДанныеСтроки.Поля.Элементы.Количество() > 0
	Тогда
		Для Каждого Поле Из ДанныеСтроки.Поля.Элементы Цикл
			Если Поле.Использование Тогда
				ЯчейкаОбласти.УстановитьТекст("<>");
				Прервать;
			КонецЕсли;
		КонецЦикла;
	КонецЕсли;
	
	Если КомпоновщикНастроек <> Неопределено Тогда
		Для Каждого Поле Из ДанныеСтроки.Поля.Элементы Цикл
			Если Истина
				И ЗначениеЗаполнено("" + Поле.Поле) 
				И КомпоновщикНастроек.Настройки.ДоступныеПоляВыбора.НайтиПоле(Поле.Поле) = Неопределено 
			Тогда
				ЯчейкаОбласти.УстановитьКартинку(ирКэш.КартинкаПоИмениЛкс("ирНедоступноеПоле"));
				Прервать;
			КонецЕсли;
		КонецЦикла;
		Если ирОбщий.ЛиЕстьНеактуальныеПоляВГруппеОтбораЛкс(КомпоновщикНастроек, ДанныеСтроки.Отбор) Тогда 
			ЯчейкаОтбор.УстановитьКартинку(ирКэш.КартинкаПоИмениЛкс("ирНедоступноеПоле"));
		КонецЕсли;
	КонецЕсли;

КонецПроцедуры

Функция ПодобратьВариантыПоляКомпоновкиЛкс(Знач ТабличноеПоле, Знач Текст, СтандартнаяОбработка = Ложь, Знач РежимАвтоподбора = Ложь, Знач ПрефиксПараметра = "&") Экспорт 
	Варианты = Новый СписокЗначений;
	Если Не ЗначениеЗаполнено(Текст) Тогда
		Возврат Варианты;
	КонецЕсли;
	ГруппаДоступныхПолей = ирОбщий.ДоступныеПоляКоллекцииНастроекКомпоновкиЛкс(ирОбщий.ДанныеЭлементаФормыЛкс(ТабличноеПоле));
	ИскатьСРодителем = Истина;
	СловаПоиска = ирОбщий.РазделитьСтрокуПоискаНаСловаПоискаЛкс(НРег(Текст), ИскатьСРодителем);
	Если ИскатьСРодителем Тогда
		СловоРодителя = СловаПоиска[0];
		СловаПоиска.Удалить(0);
	Иначе
		СловоРодителя = "";
	КонецЕсли;
	Если Ложь
		Или Найти(СловаПоиска, ".") > 0 
		Или Лев(СловаПоиска, 1) = ПрефиксПараметра
	Тогда
		ДоступноеПоле = ирОбщий.НайтиДоступноеПолеКомпоновкиПоПолномуИмениЛкс(ГруппаДоступныхПолей, СловаПоиска,,, ПрефиксПараметра);
		Если ДоступноеПоле <> Неопределено Тогда
			Варианты.Добавить(ДоступноеПоле.Поле);
		КонецЕсли;
	КонецЕсли;
	Если Варианты.Количество() = 0 Тогда
		ПодобратьВариантыПоляКомпоновкиИзГруппы(Варианты, ГруппаДоступныхПолей, СловаПоиска, СловоРодителя);
		Если Варианты.Количество() > 0 Тогда
			Таблица = ирОбщий.ТаблицаЗначенийИзКоллекцииЛкс(Варианты,,,,, Ложь);
			Таблица.Сортировать("Пометка Убыв, Представление");
			Варианты.Очистить();
			Для Каждого СтрокаТаблицы Из Таблица Цикл
				ЗаполнитьЗначенияСвойств(Варианты.Добавить(), СтрокаТаблицы);
			КонецЦикла;
		КонецЕсли;
	КонецЕсли;
	Если РежимАвтоподбора Тогда
		Если Варианты.Количество() = 1 И ирОбщий.СтрНачинаетсяСЛкс("" + Варианты[0].Значение, Текст) Тогда
			СтандартнаяОбработка = Истина;
		Иначе
			СтандартнаяОбработка = Ложь;
		КонецЕсли;
	Иначе
		СтандартнаяОбработка = Варианты.Количество() = 0;
	КонецЕсли;
	Возврат Варианты;

КонецФункции

Процедура ПодобратьВариантыПоляКомпоновкиИзГруппы(Знач Варианты, Знач ГруппаДоступныхПолей, Знач СловаПоиска, Знач СловоРодителя = "", Знач ВычислительРегВыражений = Неопределено)
	
	Если ВычислительРегВыражений = Неопределено Тогда
		ВычислительРегВыражений = ирКэш.ВычислительРегВыраженийЛкс();
		#Если Сервер И Не Сервер Тогда
			ВычислительРегВыражений = Обработки.ирОболочкаРегВыражение.Создать();
		#КонецЕсли
		ВычислительРегВыражений.Global = Истина;
		ВычислительРегВыражений.Pattern = ирОбщий.РегВыражениеСтрокиПоискаЛкс(СловаПоиска, Ложь);
	КонецЕсли;
	ШаблонРазметкиВхождений = ирОбщий.ШаблонРазметкиВхожденийЛкс();
	#Если Сервер И Не Сервер Тогда
		ГруппаДоступныхПолей = Новый НастройкиКомпоновкиДанных;
		ГруппаДоступныхПолей = ГруппаДоступныхПолей.ДоступныеПоляВыбора;
	#КонецЕсли
	ПозицияКраткогоЗаголовка = Неопределено;
	Для Каждого ДоступноеПоле Из ГруппаДоступныхПолей.Элементы Цикл
		Если ДоступноеПоле.Папка Тогда 
			Если Ложь
				Или ПустаяСтрока(СловоРодителя)
				Или Найти(НРег(ДоступноеПоле.Заголовок), СловоРодителя) > 0
			Тогда 
				ПодобратьВариантыПоляКомпоновкиИзГруппы(Варианты, ДоступноеПоле, СловаПоиска,, ВычислительРегВыражений);
			КонецЕсли;
		Иначе
			КраткийЗаголовок = ДоступноеПоле.Заголовок;
			Если ДоступноеПоле.Родитель <> Неопределено Тогда 
				Если ПозицияКраткогоЗаголовка = Неопределено Тогда
					ПозицияКраткогоЗаголовка = СтрДлина(ГруппаДоступныхПолей.Заголовок + ".") + 1;
				КонецЕсли;
				КраткийЗаголовок = Сред(КраткийЗаголовок, ПозицияКраткогоЗаголовка);
			ИначеЕсли ЗначениеЗаполнено(СловоРодителя) Тогда 
				Продолжить;
			КонецЕсли;
			Если ирОбщий.ЛиСтрокаСодержитВсеПодстрокиЛкс(НРег(КраткийЗаголовок), СловаПоиска) Тогда 
				ПредставлениеЗначения = ВычислительРегВыражений.Заменить(ДоступноеПоле.Заголовок, ШаблонРазметкиВхождений);
				ОписаниеТипов = Новый ОписаниеТипов(ДоступноеПоле.Тип,, "ПолеКомпоновкиДанных, NULL");
				Если ОписаниеТипов.Типы().Количество() = 1 Тогда
					ТипЗначения = ОписаниеТипов.Типы()[0];
					НужноПредставлениеТипа = ирОбщий.ЛиТипСсылкиБДЛкс(ТипЗначения);
				Иначе
					ТипЗначения = Тип("Неопределено");
					НужноПредставлениеТипа = Истина;
				КонецЕсли; 
				Если НужноПредставлениеТипа Тогда
					ПредставлениеТипа = "  [" + ирОбщий.РасширенноеПредставлениеЗначенияЛкс(ОписаниеТипов) + "]";
				Иначе
					ПредставлениеТипа = "";
				КонецЕсли;
				Пометка = Ложь;
				Если СловаПоиска.Количество() > 0 Тогда
					Пометка = ирОбщий.СтрНачинаетсяСЛкс(ДоступноеПоле.Заголовок, СловаПоиска[0]);
				КонецЕсли;
				Варианты.Добавить(ДоступноеПоле.Поле, ПредставлениеЗначения + ПредставлениеТипа, Пометка, КартинкаТипаЛкс(ТипЗначения));
			КонецЕсли;
		КонецЕсли;
	КонецЦикла;

КонецПроцедуры

Процедура ОформитьЯчейкуРазностиЛкс(Знач ОформлениеСтроки, Знач ИмяКолонки = "Разность") Экспорт 
	
	РазностьОбъекта = ОформлениеСтроки.ДанныеСтроки[ИмяКолонки];
	Если ТипЗнч(РазностьОбъекта) = Тип("Число") Тогда
		ЦветТекста = Новый Цвет;
		Ячейка = ОформлениеСтроки.Ячейки[ИмяКолонки];
		ТекстЯчейки = Ячейка.Текст;
		Если РазностьОбъекта > 0 Тогда
			ЦветТекста = WebЦвета.Зеленый;
			ТекстЯчейки = "+" + ТекстЯчейки;
		ИначеЕсли РазностьОбъекта < 0 Тогда
			ЦветТекста = WebЦвета.Красный;
		КонецЕсли;
		Ячейка.ЦветТекста = ЦветТекста;
		Ячейка.Текст = ТекстЯчейки;
	КонецЕсли;

КонецПроцедуры

// .
// Параметры:
//  ТабличноеПоле - ТабличноеПоле - отбора компоновки.
//
Процедура ПодключитьОбработчикиСобытийДоступныхПолейКомпоновкиЛкс(ТабличноеПоле) Экспорт 

	#Если Сервер И Не Сервер Тогда
		ТабличноеПоле = Новый ТабличноеПоле;
		ПриПолученииДанныхТабличногоПоляКомпоновкиЛкс();
	#КонецЕсли
	ИменаСобытий = Новый Структура;
	ИменаСобытий.Вставить("ПриПолученииДанных", "ПриПолученииДанныхДоступныхПолей");
	ИменаСобытий.Вставить("ПриАктивизацииСтроки", "ТабличноеПолеПриАктивизацииСтроки");
	ИменаСобытий.Вставить("ПриИзмененииФлажка", "ТабличноеПолеПриИзмененииФлажка");
	ИмяАбстрактногоПоляВвода = "ТабличноеПоле"; 
	Для Каждого КлючИЗначение Из ИменаСобытий Цикл
		ИмяОбработчика = КлючИЗначение.Значение;
		Обработчик = ТабличноеПоле.ПолучитьДействие(КлючИЗначение.Ключ);
		Если Истина
			И Обработчик <> Неопределено 
			И Не ирОбщий.СтрокиРавныЛкс(Обработчик, ИмяОбработчика) 
		Тогда 
			//ирОбщий.СообщитьЛкс(ирОбщий.СтрШаблонЛкс("Обнаружено переопределение обработчика события %1 табличного поля %2", КлючИЗначение.Ключ, ТабличноеПоле.Имя));
			Продолжить;
		КонецЕсли; 
		ТабличноеПоле.УстановитьДействие(КлючИЗначение.Ключ, Новый Действие(ИмяОбработчика));
	КонецЦикла;
	КолонкаКартинки = КолонкаКартинкиТабличногоПоляКомпоновкиЛкс(ТабличноеПоле);
	ТабличноеПоле.Колонки[КолонкаКартинки].КартинкиСтрок = ирКэш.КартинкаПоИмениЛкс("ирТипыДоступныхПолейКомпоновки");

КонецПроцедуры

Функция КолонкаКартинкиТабличногоПоляКомпоновкиЛкс(Знач ТабличноеПоле)

	КолонкаПоля = ТабличноеПоле.Колонки.Найти("Поле");
	Если КолонкаПоля = Неопределено Тогда
		КолонкаПоля = ТабличноеПоле.Колонки.Найти("Заголовок");
	КонецЕсли;
	Если КолонкаПоля = Неопределено Тогда
		КолонкаПоля = ТабличноеПоле.Колонки.Найти("ЛевоеЗначениеДляКраткогоОтображенияЭлемента");
	КонецЕсли;
	Если КолонкаПоля = Неопределено Тогда
		КолонкаПоля = ТабличноеПоле.Колонки[0];
	КонецЕсли;
	КолонкаКартинки = КолонкаПоля.Имя;
	Возврат КолонкаКартинки;

КонецФункции 

// .
// Параметры:
//  ТабличноеПоле - ТабличноеПоле - отбора компоновки.
//
Процедура ПодключитьОбработчикиСобытийНастроекКомпоновкиЛкс(ТабличноеПоле) Экспорт 

	ПодключитьОбработчикиСобытийДоступныхПолейКомпоновкиЛкс(ТабличноеПоле);
	КоллекцияНастроек = ирОбщий.ДанныеЭлементаФормыЛкс(ТабличноеПоле);
	ИменаСобытий = Новый Массив;
	ИменаСобытий.Добавить("АвтоПодборТекста");
	ИменаСобытий.Добавить("ОкончаниеВводаТекста");
	ИмяКолонки = "Поле";
	Если ТипЗнч(КоллекцияНастроек) = Тип("ОтборКомпоновкиДанных") Тогда
		ИменаКолонок = Новый Массив;
		ИменаКолонок.Добавить("ПравоеЗначениеДляКраткогоОтображенияЭлемента");
		ИменаКолонок.Добавить("ПравоеЗначениеДляПодробногоОтображенияЭлемента");
		ИмяСобытия = "НачалоВыбора";
		ИмяАбстрактногоПоляВвода = "ОтборЗначение"; 
		ИмяОбработчика = ИмяАбстрактногоПоляВвода + ИмяСобытия;
		Для Каждого ИмяКолонки Из ИменаКолонок Цикл
			ПодключитьОбработчикПоляВводаТабличногоПоляКомпоновкиЛкс(ИмяОбработчика, ИмяКолонки, ИмяСобытия, ТабличноеПоле, ИмяКолонки = "ПравоеЗначениеДляКраткогоОтображенияЭлемента");
		КонецЦикла;
		ИменаКолонок.Добавить("ЛевоеЗначениеДляКраткогоОтображенияЭлемента");
		ИменаКолонок.Добавить("ЛевоеЗначениеДляПодробногоОтображенияЭлемента");
		ИмяАбстрактногоПоляВвода = "ПолеКомпоновки"; 
		Для Каждого ИмяКолонки Из ИменаКолонок Цикл
			Для Каждого ИмяСобытия Из ИменаСобытий Цикл
				ИмяОбработчика = ИмяАбстрактногоПоляВвода + ИмяСобытия;
				ПодключитьОбработчикПоляВводаТабличногоПоляКомпоновкиЛкс(ИмяОбработчика, ИмяКолонки, ИмяСобытия, ТабличноеПоле, ИмяКолонки = "ЛевоеЗначениеДляКраткогоОтображенияЭлемента");
			КонецЦикла;
		КонецЦикла;
	Иначе
		ИмяАбстрактногоПоляВвода = "ПолеКомпоновки"; 
		Для Каждого ИмяСобытия Из ИменаСобытий Цикл
			ИмяОбработчика = ИмяАбстрактногоПоляВвода + ИмяСобытия;
			ПодключитьОбработчикПоляВводаТабличногоПоляКомпоновкиЛкс(ИмяОбработчика, ИмяКолонки, ИмяСобытия, ТабличноеПоле);
		КонецЦикла;
	КонецЕсли;  

КонецПроцедуры

Процедура ПодключитьОбработчикПоляВводаТабличногоПоляКомпоновкиЛкс(Знач ИмяОбработчика, Знач ИмяПоля, ИмяСобытия, Знач ТабличноеПоле, Знач КолонкаОбязательна = Истина)
	
	ПолеВвода = ТабличноеПоле.Колонки.Найти(ИмяПоля);
	Если ПолеВвода = Неопределено Тогда
		Если КолонкаОбязательна Тогда
			ВызватьИсключение "В табличном поле не найдена колонка """ + ИмяПоля + """";
		Иначе
			Возврат;
		КонецЕсли;
	КонецЕсли;
	ПолеВвода = ПолеВвода.ЭлементУправления;
	НазначенныйОбработчик = ПолеВвода.ПолучитьДействие(ИмяСобытия); 
	Если Истина
		И НазначенныйОбработчик <> Неопределено 
		И Не ирОбщий.СтрокиРавныЛкс(НазначенныйОбработчик, ИмяОбработчика) 
	Тогда 
		ирОбщий.СообщитьЛкс(ирОбщий.СтрШаблонЛкс("Обнаружено переопределение обработчика события %1 поля ввода табличного поля %2", ИмяСобытия, ТабличноеПоле.Имя));
	КонецЕсли; 
	ПолеВвода.УстановитьДействие(ИмяСобытия, Новый Действие(ИмяОбработчика));

КонецПроцедуры

Процедура УстановитьПолеВПравомЗначенииТабличПоляОтбораЛкс(Знач ТабличноеПолеОтбора, Знач ТабличноеПолеДоступныхПолей = Неопределено) Экспорт 
	
	Если ТабличноеПолеДоступныхПолей <> Неопределено И ТабличноеПолеДоступныхПолей.ТекущаяСтрока <> Неопределено Тогда
		ПолеКомпоновки = ТабличноеПолеДоступныхПолей.ТекущаяСтрока.Поле;
	Иначе
		ПолеКомпоновки = Новый ПолеКомпоновкиДанных("");
	КонецЕсли; 
	ТекущаяСтрока = ТабличноеПолеОтбора.ТекущаяСтрока;
	Если ТипЗнч(ТекущаяСтрока) = Тип("ЭлементОтбораКомпоновкиДанных") Тогда
		Если ТипЗнч(ТекущаяСтрока.ПравоеЗначение) <> Тип("ПолеКомпоновкиДанных") Или ЗначениеЗаполнено("" + ПолеКомпоновки) Тогда
			ТекущаяСтрока.ПравоеЗначение = ПолеКомпоновки;
		КонецЕсли; 
		ТабличноеПолеОтбора.ТекущаяКолонка = ТабличноеПолеОтбора.Колонки.ПравоеЗначениеДляКраткогоОтображенияЭлемента;
	КонецЕсли;

КонецПроцедуры

// Получает макет компоновки данных по схеме с использованием временных таблиц.
//
// Параметры:
//  Схема        - СхемаКомпоновкиДанных;
//  Настройки    - НастройкиКомпоновкиДанных;
//  *ВнешниеНаборыДанных - Структура, *Неопределено - туда добавляются временные таблицы;
//  *ДанныеРасшифровки - ДанныеРасшифровкиКомпоновкиДанных, *Неопределено;
//  *ЛиОтладка   - Булево, *Ложь - показывать тексты запросов и время выполнения этапов.
//
// Возвращаемое значение:
//  МакетКомпоновкиДанных.
//
Функция МакетКомпоновкиДанныхСВременнымиТаблицамиЛкс(Схема, Настройки, ВнешниеНаборыДанных = Неопределено,
	ДанныеРасшифровки = Неопределено, ЛиОтладка = Ложь, СвойМакетОформления = Неопределено, ПроверятьДоступностьПолей = Ложь) Экспорт 
	
	RegExp = ирОбщий.НовыйВычислительРегВыражений();
	RegExp.Global = Истина;
	RegExp.MultiLine = Истина;
	RegExp.IgnoreCase = Истина;
	// Допустим 1 уровень скобок.
	шСкобки = "\([^\)\(]*?\)";
	RegExp.Pattern = "\(ВЫБРАТЬ(?:" + шСкобки + "|[^$\(\)])*?""ВременнаяТаблица"" = ""(.*?)""\)";

	Если ВнешниеНаборыДанных = Неопределено Тогда
		ВнешниеНаборыДанных = Новый Структура;
	КонецЕсли;
	
	Запрос = Новый Запрос;
	Запрос.МенеджерВременныхТаблиц = Новый МенеджерВременныхТаблиц;
	КомпоновщикМакета = Новый КомпоновщикМакетаКомпоновкиДанных;
	КомпоновщикНастроек = Новый КомпоновщикНастроекКомпоновкиДанных;
	
	// Выполним создание всех временных таблиц. Временной таблицей считаем набор данных запрос,
	// имя которого начинается с "@". Наборы данных временных таблиц удаляются из предварительной схемы.
	ПредварительнаяСхема = ирОбщий.КопияОбъектаЛкс(Схема);
	НаборыДанныхСхемы = ПредварительнаяСхема.НаборыДанных;
	ЕстьВременныеТаблицы = Ложь;
	НачальноеКоличество = НаборыДанныхСхемы.Количество(); 
	Для СчетчикНаборыДанныхСхемы = 1 По НачальноеКоличество Цикл
		НаборДанных = НаборыДанныхСхемы[НачальноеКоличество - СчетчикНаборыДанныхСхемы];
		Если Истина
			И Лев(НаборДанных.Имя, 1) = "@"
			И ТипЗнч(НаборДанных) = Тип("НаборДанныхЗапросСхемыКомпоновкиДанных")
		Тогда
			ВременнаяСхема = ирОбщий.КопияОбъектаЛкс(Схема);
			
			// Кривое копирование набора данных в новую схемы, где он будет один.
			ВременнаяСхема.СвязиНаборовДанных.Очистить();
			НаборыДанныхВременнойСхемы = ВременнаяСхема.НаборыДанных;
			НаборыДанныхВременнойСхемыВГраница = НаборыДанныхВременнойСхемы.Количество() - 1;
			Для СчетчикВременнойСхемы = 0 По НаборыДанныхВременнойСхемыВГраница Цикл
				НаборДанныхВременнойСхемы = НаборыДанныхВременнойСхемы[НаборыДанныхВременнойСхемыВГраница - СчетчикВременнойСхемы];
				Если НаборДанныхВременнойСхемы.Имя <> НаборДанных.Имя Тогда
					НаборыДанныхВременнойСхемы.Удалить(НаборДанныхВременнойСхемы);
				КонецЕсли;
			КонецЦикла;
			Для Каждого ПолеНабора Из НаборыДанныхВременнойСхемы[0].Поля Цикл
				ПолеНабора.ОграничениеИспользования.Поле = Ложь;
				ПолеНабора.ВыражениеПредставления = ПолеНабора.ПутьКДанным;
			КонецЦикла;
				
			КомпоновщикНастроек.Инициализировать(Новый ИсточникДоступныхНастроекКомпоновкиДанных(ВременнаяСхема));
			
			КомпоновщикНастроек.ЗагрузитьНастройки(Настройки);
			КомпоновщикНастроек.Настройки.Структура.Очистить();
			КомпоновщикНастроек.Настройки.Выбор.Элементы.Очистить();
			ирОбщий.КомпоновщикНастроекВосстановитьЛкс(КомпоновщикНастроек);

			ВременныеНастройки = КомпоновщикНастроек.Настройки;
			
			// Установим использование параметров
			Для Каждого ЭлементПараметра Из ВременныеНастройки.ПараметрыДанных.Элементы Цикл
				ЭлементПараметра.Использование = Истина;
			КонецЦикла;
			
			// Установим структуру и выбранные поля
			ЭлементСтруктуры = ВременныеНастройки.Структура.Добавить(Тип("ГруппировкаКомпоновкиДанных"));
			ЭлементСтруктуры.Выбор.Элементы.Добавить(Тип("АвтоВыбранноеПолеКомпоновкиДанных"));
			Для Каждого ДоступноеПоле Из ВременныеНастройки.ДоступныеПоляВыбора.Элементы Цикл
				// Чтобы пропустить системные папки
				Если Не ДоступноеПоле.Папка Тогда
					НовоеВыбранноеПоле = ВременныеНастройки.Выбор.Элементы.Добавить(Тип("ВыбранноеПолеКомпоновкиДанных"));
					НовоеВыбранноеПоле.Поле = ДоступноеПоле.Поле;
					НовоеВыбранноеПоле.Использование = Истина;
				КонецЕсли;
			КонецЦикла;

			МакетКомпоновкиДанных = КомпоновщикМакета.Выполнить(ВременнаяСхема, ВременныеНастройки,,,, ПроверятьДоступностьПолей);
			Запрос.Текст = МакетКомпоновкиДанных.НаборыДанных[0].Запрос;
			Для Каждого Параметр Из МакетКомпоновкиДанных.ЗначенияПараметров Цикл
				Запрос.УстановитьПараметр(Параметр.Имя, Параметр.Значение);
			КонецЦикла;
			Запрос.Текст = RegExp.Заменить(Запрос.Текст, "$1");
			ирОбщий.ВыполнитьЗамеритьЗапросЛкс(Запрос, ЛиОтладка, "Предварительный запрос - " + НаборДанных.Имя);
			
			//// Недоступные поля набора данных цепляются в настройках при совпадении имен с выбранными полями
			//// http://partners.v8.1c.ru/forum/thread.jsp?id=514094
			//Для Каждого Поле Из НаборДанных.Поля Цикл
			//	Поле.ПутьКДанным = "_поле_" + Поле.ПутьКДанным;
			//КонецЦикла;
			
			НаборыДанныхСхемы.Удалить(НаборДанных);
			ЕстьВременныеТаблицы = Истина;
			
		КонецЕсли;
	КонецЦикла;
	
	Если Не ЕстьВременныеТаблицы Тогда
		Если ЛиОтладка Тогда
			ВремяНачалаКомпоновкиМакета = ирОбщий.ТекущееВремяВМиллисекундахЛкс();
		КонецЕсли;
		МакетКомпоновкиДанных = КомпоновщикМакета.Выполнить(ПредварительнаяСхема, Настройки, ДанныеРасшифровки, СвойМакетОформления,, ПроверятьДоступностьПолей);
		Если ЛиОтладка Тогда
			ирОбщий.СообщитьЛкс(ирОбщий.СтрШаблонИменЛкс("Компоновка макета - %1мс",, ирОбщий.ТекущееВремяВМиллисекундахЛкс() - ВремяНачалаКомпоновкиМакета));
		КонецЕсли;
	Иначе
		// Выполним получение результата предварительного запроса
		КомпоновщикНастроек.Инициализировать(Новый ИсточникДоступныхНастроекКомпоновкиДанных(ПредварительнаяСхема));
		КомпоновщикНастроек.ЗагрузитьНастройки(Настройки);
		ирОбщий.КомпоновщикНастроекВосстановитьЛкс(КомпоновщикНастроек);
		ПредварительныеНастройки = КомпоновщикНастроек.Настройки;
		Если ЛиОтладка Тогда
			ВремяНачалаКомпоновкиМакета = ирОбщий.ТекущееВремяВМиллисекундахЛкс();
		КонецЕсли;
		МакетКомпоновкиДанных = КомпоновщикМакета.Выполнить(ПредварительнаяСхема, ПредварительныеНастройки, ДанныеРасшифровки, СвойМакетОформления,, ПроверятьДоступностьПолей);
		Если ЛиОтладка Тогда
			ирОбщий.СообщитьЛкс(ирОбщий.СтрШаблонИменЛкс("Компоновка макета - %1мс",, ирОбщий.ТекущееВремяВМиллисекундахЛкс() - ВремяНачалаКомпоновкиМакета));
		КонецЕсли;
			
		Для Каждого Параметр Из МакетКомпоновкиДанных.ЗначенияПараметров Цикл
			Запрос.УстановитьПараметр(Параметр.Имя, Параметр.Значение);
		КонецЦикла;
		СтруктураНаборовДанныхЗапросовМакета = ирОбщий.ВсеНаборыДанныхЗапросовКомпоновкиЛкс(МакетКомпоновкиДанных.НаборыДанных);
		Для Каждого ЭлементНаборДанныхМакета Из СтруктураНаборовДанныхЗапросовМакета Цикл
			НаборДанных = ЭлементНаборДанныхМакета.Значение.НаборДанных;
			Запрос.Текст = НаборДанных.Запрос;
			Запрос.Текст = RegExp.Заменить(Запрос.Текст, "$1");
			РезультатЗапроса = ирОбщий.ВыполнитьЗамеритьЗапросЛкс(Запрос, ЛиОтладка, "Предварительный запрос - " + НаборДанных.Имя);
			ВнешниеНаборыДанных.Вставить(НаборДанных.Имя, РезультатЗапроса);
		КонецЦикла;

		// Получение конечного макета
		Для Каждого ЭлементНаборДанных Из СтруктураНаборовДанныхЗапросовМакета Цикл
			КоллекцияВладелец = ЭлементНаборДанных.Значение.КоллекцияВладелец;
			НаборДанныхЗапрос = ЭлементНаборДанных.Значение.НаборДанных;
			
			НаборДанныхОбъект = КоллекцияВладелец.Добавить(Тип("НаборДанныхОбъектМакетаКомпоновкиДанных"));
			// Копируем Свойства набора данных запроса в набор данных объекта
			ЗаполнитьЗначенияСвойств(НаборДанныхОбъект, НаборДанныхЗапрос);
			НаборДанныхОбъект.ИмяОбъекта = НаборДанныхЗапрос.Имя;
			Для Каждого ПолеНабораДанныхОригинала Из НаборДанныхЗапрос.Поля Цикл
				ПолеРезультата = НаборДанныхОбъект.Поля.Добавить();
				ЗаполнитьЗначенияСвойств(ПолеРезультата, ПолеНабораДанныхОригинала);
				ЗаполнитьЗначенияСвойств(ПолеРезультата.Роль, ПолеНабораДанныхОригинала.Роль);
			КонецЦикла;
			КоллекцияВладелец.Удалить(НаборДанныхЗапрос);
		КонецЦикла;
	КонецЕсли;
	
	// Баг платформы. Пустая дата превращается в Неопределено.
	Для Каждого ПараметрСхемы Из ПредварительнаяСхема.Параметры Цикл
		Если ПараметрСхемы.ОграничениеИспользования Тогда
			Если Не ПараметрСхемы.ДоступенСписокЗначений Тогда 
				ЗначениеПараметра = МакетКомпоновкиДанных.ЗначенияПараметров.Найти(ПараметрСхемы.Имя);
				ЗначениеПараметра.Значение = ПараметрСхемы.ТипЗначения.ПривестиЗначение(ЗначениеПараметра.Значение);
			КонецЕсли;
		КонецЕсли;
	КонецЦикла;
	
	Возврат МакетКомпоновкиДанных;
	
КонецФункции

Функция ИмяФормыИзСтрокиИнструментаЛкс(Знач СтрокаИнструмента) Экспорт 
	
	ИмяВыбраннойФормы = СтрокаИнструмента.ПолноеИмя;
	Если Найти(ИмяВыбраннойФормы, "ОбщаяФорма.") <> 1 И Найти(ИмяВыбраннойФормы, ".Форма.") = 0 Тогда
		Если Найти(ИмяВыбраннойФормы, "Справочник.") = 1 Тогда
			ИмяВыбраннойФормы = ИмяВыбраннойФормы + ".ФормаСписка";
		Иначе
			ИмяВыбраннойФормы = ИмяВыбраннойФормы + ".Форма";
		КонецЕсли; 
	КонецЕсли;
	Возврат ИмяВыбраннойФормы;

КонецФункции

Процедура ПодключитьГлобальныйОбработчикОжиданияЛкс(ИмяГлобальногоМетода, Интервал = 0.1, Однократно = Истина) Экспорт 
	
	Если ирКэш.ЛиПортативныйРежимЛкс() Тогда
		ирПортативный.ПолучитьФорму().ПодключитьОбработчикОжидания(ИмяГлобальногоМетода, Интервал, Истина);
	Иначе
		ПодключитьОбработчикОжидания(ИмяГлобальногоМетода, Интервал, Истина);
	КонецЕсли; 

КонецПроцедуры

Процедура ОтключитьГлобальныйОбработчикОжиданияЛкс(ИмяМетода) Экспорт 
	
	Если ирКэш.ЛиПортативныйРежимЛкс() Тогда
		ирПортативный.ПолучитьФорму().ОтключитьОбработчикОжидания(ИмяМетода);
	Иначе
		ОтключитьОбработчикОжидания(ИмяМетода);
	КонецЕсли; 

КонецПроцедуры

// Процедура - Подключить глобальный обработчик ожидания с параметрами лкс
//
// Параметры:
//  ИмяМетодаОбщегоМодуля - Строка - полное имя метода
//  Параметры	 - Структура - 
//  Интервал	 - 	 - 
//  Однократно	 - 	 - 
//
Функция ПодключитьОбработчикОжиданияСПараметрамиЛкс(ИмяМетодаОбщегоМодуля, Знач Параметры = Неопределено, Интервал = 0.1, Однократно = Истина, ВыбрасыватьИсключениеЕслиЗанят = Истина) Экспорт 
	
	мПлатформа = ирКэш.Получить();
	#Если Сервер И Не Сервер Тогда
		мПлатформа = Обработки.ирПлатформа.Создать();
		Параметры = Новый Структура;
	#КонецЕсли
	Если Параметры = Неопределено Тогда
		Параметры = Новый Структура;
	КонецЕсли; 
	Параметры.Вставить("ИмяМетода", ИмяМетодаОбщегоМодуля);
	Если Однократно И Интервал = 0 Тогда
		ОбработчикОжиданияСЯвнымиПараметрамиЛкс(Параметры);
	Иначе
		Если мПлатформа.ПараметрыОбработчикаОжидания <> Неопределено Тогда     
			Если ирОбщий.СравнитьЗначенияСвойствЛкс(мПлатформа.ПараметрыОбработчикаОжидания, Параметры,, Ложь) Тогда 
				// повторный вызов с теми же параметрами
				Возврат Истина;
			КонецЕсли;
			Если ВыбрасыватьИсключениеЕслиЗанят Тогда
				ВызватьИсключение "Обработчик ожидания занят";
			Иначе
				Возврат Ложь;
			КонецЕсли;
		КонецЕсли; 
		#Если Сервер И Не Сервер Тогда
			ГлобальныйОбработчикОжиданияСПараметрамиЛкс();
		#КонецЕсли 
		ПодключитьГлобальныйОбработчикОжиданияЛкс("ГлобальныйОбработчикОжиданияСПараметрамиЛкс", Интервал, Однократно);
		мПлатформа.ПараметрыОбработчикаОжидания = Параметры;
	КонецЕсли;
	Возврат Истина;

КонецФункции

Процедура ОтлючитьОбработчикОжиданияСПараметрамиЛкс(ИмяМетодаОбщегоМодуля = "") Экспорт 
	
	мПлатформа = ирКэш.Получить();
	#Если Сервер И Не Сервер Тогда
		мПлатформа = Обработки.ирПлатформа.Создать();
	#КонецЕсли
	Если ЗначениеЗаполнено(ИмяМетодаОбщегоМодуля) Тогда
		Если Ложь
			Или мПлатформа.ПараметрыОбработчикаОжидания = Неопределено 
			Или ирОбщий.СтрокиРавныЛкс(мПлатформа.ПараметрыОбработчикаОжидания.ИмяМетода, ИмяМетодаОбщегоМодуля)
		Тогда
			Возврат;
		КонецЕсли;
	КонецЕсли;
	мПлатформа.ПараметрыОбработчикаОжидания = Неопределено;
	ОтключитьГлобальныйОбработчикОжиданияЛкс("ГлобальныйОбработчикОжиданияСПараметрамиЛкс");

КонецПроцедуры

Процедура ОбработчикОжиданияСПараметрамиЛкс() Экспорт 
	
	мПлатформа = ирКэш.Получить();
	#Если Сервер И Не Сервер Тогда
		мПлатформа = Обработки.ирПлатформа.Создать();
	#КонецЕсли
	ПараметрыОбработчикаОжидания = мПлатформа.ПараметрыОбработчикаОжидания;
	Если ПараметрыОбработчикаОжидания = Неопределено Тогда
		ирОбщий.СообщитьЛкс("Не удалось выполнить страховочный обработчик ожидания, т.к. обработка ирПлатформа была удалена из кэша", СтатусСообщения.Внимание);
		Возврат;
	КонецЕсли;
	мПлатформа.ПараметрыОбработчикаОжидания = Неопределено;
	ОбработчикОжиданияСЯвнымиПараметрамиЛкс(ПараметрыОбработчикаОжидания);

КонецПроцедуры

Функция ОбработчикОжиданияСЯвнымиПараметрамиЛкс(Знач ПараметрыОбработчикаОжидания)
	
	Выполнить(ПараметрыОбработчикаОжидания.ИмяМетода + "(ПараметрыОбработчикаОжидания)");

КонецФункции

Процедура ВыполнитьМетодОбъектаЛкс(Параметры) Экспорт 
	Выполнить("Параметры.Объект" + "." + Параметры.МетодОбъекта + "()");
КонецПроцедуры

//.
// Параметры:
//  РежимОткрытия - Булево - Истина - Открытие, иначе Сохранение
Функция ВыбратьФайлЛкс(РежимОткрытия = Истина, Расширение = "", ОписаниеФормата = "", Знач ПолноеИмяФайла = "", Знач Каталог = "", Знач КраткоеИмя = "", Знач Заголовок = "") Экспорт
	
	ВыборФайла = ДиалогВыбораФайлаЛкс(РежимОткрытия, Расширение, ОписаниеФормата, ПолноеИмяФайла, Каталог, КраткоеИмя, Заголовок);
	Если Не ВыборФайла.Выбрать() Тогда
		Возврат Неопределено;
	КонецЕсли;
	Возврат ВыборФайла.ПолноеИмяФайла;
	
КонецФункции

Функция ДиалогВыбораФайлаЛкс(РежимОткрытия = Истина, Знач Расширение = "", ОписаниеФормата = "", Знач ПолноеИмяФайла = "", Знач Каталог = "", Знач КраткоеИмя = "", Знач Заголовок = "") Экспорт 
	
	Если РежимОткрытия = Истина Тогда
		РежимДиалога = РежимДиалогаВыбораФайла.Открытие;
	Иначе
		РежимДиалога = РежимДиалогаВыбораФайла.Сохранение;
	КонецЕсли; 
	ВыборФайла = Новый ДиалогВыбораФайла(РежимДиалога);
	ВыборФайла.Заголовок = Заголовок;
	Если ЗначениеЗаполнено(ПолноеИмяФайла) Тогда
		Файл = Новый Файл(ПолноеИмяФайла);
		ВыборФайла.Каталог = Файл.Путь;
		ВыборФайла.ПолноеИмяФайла = Файл.Имя;
	Иначе
		ВыборФайла.Каталог = Каталог;
		ВыборФайла.ПолноеИмяФайла = КраткоеИмя;
	КонецЕсли; 
	ВыборФайла.Расширение = Расширение;
	Если Не ЗначениеЗаполнено(Расширение) Тогда
		Расширение = "*";
	КонецЕсли; 
	ВыборФайла.Фильтр = ирОбщий.ФильтрДляВыбораФайлаЛкс(Расширение, ОписаниеФормата);
	Возврат ВыборФайла;

КонецФункции

Функция ВыбратьКаталогВФормеЛкс(выхКаталог, ФормаДляУстановкиМодифицированности = Неопределено, Заголовок = "") Экспорт

	ВыборФайла = Новый ДиалогВыбораФайла(РежимДиалогаВыбораФайла.ВыборКаталога);
	ВыборФайла.Каталог = выхКаталог;
	ВыборФайла.Заголовок = Заголовок;
	Если Не ВыборФайла.Выбрать() Тогда
		Возврат Неопределено;
	КонецЕсли;
	выхКаталог = ВыборФайла.Каталог;
	Если ФормаДляУстановкиМодифицированности <> Неопределено Тогда
		ФормаДляУстановкиМодифицированности.Модифицированность = Истина;
	КонецЕсли;
	Возврат выхКаталог;

КонецФункции

Функция МассивЗначенийПеретаскиванияЛкс(Знач ПараметрыПеретаскивания, выхМассивЗначений = Неопределено, выхТипЗначенияПервогоЭлемента = Неопределено) Экспорт 
	
	ЗначениеПеретаскивания = ПараметрыПеретаскивания.Значение;
	выхТипЗначенияПервогоЭлемента = ТипЗнч(ЗначениеПеретаскивания);
	Если выхТипЗначенияПервогоЭлемента = Тип("Массив") Тогда
		выхТипЗначенияПервогоЭлемента = ТипЗнч(ЗначениеПеретаскивания[0]);
		выхМассивЗначений = ЗначениеПеретаскивания;
	Иначе
		выхМассивЗначений = Новый Массив;
		выхМассивЗначений.Добавить(ЗначениеПеретаскивания);
	КонецЕсли;
	Возврат выхМассивЗначений;
	
КонецФункции

// Подразумевается, что имена колонок табличного поля и коллекции совпадают
// Параметры:
//  ТабличноеПоле - ТабличноеПоле
//  ИмяКолонкиПометки - Строка - если пустая, то берется текущая колонка типа "Булево" или колонка с именем "Пометка"
//  КлючеваяКолонка - Строка - задается только для таблиц без колонки НомерСтроки при необходимости отобрать строки
//  ПроверятьОформлениеСтроки - Булево - долго
Процедура ИзменитьПометкиВыделенныхИлиОтобранныхСтрокЛкс(Знач ЭтаФорма, Знач ТабличноеПоле, Знач ИмяКолонкиПометки = "", Знач НовоеЗначениеПометки = Истина, КлючеваяКолонка = "НомерСтроки",
	СтруктураОтбора = Неопределено, Знач ИнтерактивнаяУстановка = Ложь) Экспорт 
	
	#Если Сервер И Не Сервер Тогда
		ТабличноеПоле = Новый ТабличноеПоле;
	#КонецЕсли
	Если Не ЗначениеЗаполнено(ИмяКолонкиПометки) Тогда
		КолонкаПометки = КолонкаПометкиТабличногоПоляЛкс(ТабличноеПоле);
		Если КолонкаПометки <> Неопределено Тогда
			ИмяКолонкиПометки = КолонкаПометки.Имя;
		КонецЕсли; 
	КонецЕсли; 
	Если ТабличноеПоле.Колонки.Найти(ИмяКолонкиПометки) = Неопределено Тогда
		Возврат;
	КонецЕсли; 
	Если ТипЗнч(ТабличноеПоле) = Тип("ТабличноеПоле") Тогда
		Колонка = ТабличноеПоле.Колонки[ИмяКолонкиПометки];
	Иначе
		Колонка = ТабличноеПоле.ПодчиненныеЭлементы[ИмяКолонкиПометки];
	КонецЕсли; 
	УстановитьЗначениеВКолонкеТабличногоПоляТЧИлиТЗЛкс(ЭтаФорма, ТабличноеПоле, НовоеЗначениеПометки, "", Колонка, ТабличноеПоле.ВыделенныеСтроки.Количество() > 1, ИнтерактивнаяУстановка,, СтруктураОтбора);
	
КонецПроцедуры

Функция ВыбратьСсылкуЛкс(ИмяТаблицыИлиМДИлиТип, НачальноеЗначениеВыбора = Неопределено, ИспользоватьДинамическийСписокИР = Неопределено) Экспорт
	
	Результат = ОткрытьФормуСпискаЛкс(ИмяТаблицыИлиМДИлиТип,, ИспользоватьДинамическийСписокИР,, Истина,, НачальноеЗначениеВыбора, Истина);
	Возврат Результат;
	
КонецФункции

Процедура ВыбратьИЗаполнитьТабличнуюЧастьОбъектаБДЛкс(ТаблицаИсточник, НачальноеПолноеИмяОбъекта = "") Экспорт 
	
	ФормаВыбораОбъектаБД = ФормаВыбораОбъектаМетаданныхЛкс(,, НачальноеПолноеИмяОбъекта,, Истина,, Истина, Истина,, Истина,,, Истина);
	РезультатВыбора = ФормаВыбораОбъектаБД.ОткрытьМодально();
	Если РезультатВыбора = Неопределено Тогда
		Возврат;
	КонецЕсли; 
	ОбъектМД = ирОбщий.ОбъектМДПоПолномуИмениТаблицыБДЛкс(РезультатВыбора.ПолноеИмяОбъекта);
	ЭтоНаборЗаписей = ирОбщий.ЛиМетаданныеРегистраЛкс(ОбъектМД);
	Если ЭтоНаборЗаписей Тогда 
		ПолноеИмяМДСписка = ОбъектМД.ПолноеИмя();
	Иначе
		ПолноеИмяМДСписка = ОбъектМД.Родитель().ПолноеИмя();
	КонецЕсли; 
	МакетныйОбъект = Неопределено;
	ТекущаяГруппаТипаМетаданных = Неопределено;
	ирОбщий.ПолучитьМакетныйОбъектДанныхТаблицыБДЛкс(ПолноеИмяМДСписка, МакетныйОбъект, ТекущаяГруппаТипаМетаданных);
	Если ЭтоНаборЗаписей Тогда
		СтруктураОбъекта = МакетныйОбъект;
		ТаблицаПриемник = СтруктураОбъекта.Данные;
	Иначе
		ВыбраннаяСтрока = ОткрытьФормуСпискаЛкс(ПолноеИмяМДСписка,,,, Истина,,, Истина);
		Если ВыбраннаяСтрока = Неопределено Тогда
			Возврат;
		КонецЕсли;
		СтруктураОбъекта = ирОбщий.ОбъектДанныхИзСтрокиРезультатаЗапросаЛкс(ВыбраннаяСтрока, МакетныйОбъект, ТекущаяГруппаТипаМетаданных, Истина);
		ТаблицаПриемник = СтруктураОбъекта.Данные[ОбъектМД.Имя];
	КонецЕсли; 
	Если ТаблицаПриемник.Количество() > 0 Тогда
		Если ЭтоНаборЗаписей Тогда
			ТекстВопроса = "Хотите очистить набор записей в памяти перед заполнением?";
		Иначе
			ТекстВопроса = "Выбранная табличная часть объекта не пустая. Хотите очистить ее в памяти перед заполнением?";
		КонецЕсли; 
		Ответ = Вопрос(ТекстВопроса, РежимДиалогаВопрос.ДаНет,, КодВозвратаДиалога.Да);
		Если Ответ = КодВозвратаДиалога.Да Тогда
			ТаблицаПриемник.Очистить();
		КонецЕсли;
	КонецЕсли; 
	ирОбщий.ЗагрузитьВТаблицуЗначенийЛкс(ТаблицаИсточник, ТаблицаПриемник);
	ОбработкаРедактора = ирОбщий.СоздатьОбъектПоИмениМетаданныхЛкс("Обработка.ирРедакторОбъектаБД");
	#Если Сервер И Не Сервер Тогда
	    ОбработкаРедактора = Обработки.ирРедакторОбъектаБД.Создать();
	#КонецЕсли
	ФормаРедактора = ОбработкаРедактора.РедактироватьМодифицированныйОбъект(СтруктураОбъекта);
	ФормаРедактора.ПоказатьЯчейкуДанныхОбъекта(РезультатВыбора.ПолноеИмяОбъекта);
	
КонецПроцедуры

// Функция - Сравнить значения в форме лкс
//
// Параметры:
//  Значение1									 - ТекстовыйДокумент, Строка, ТабличныйДокумент, ТаблицаЗначений - 
//  Значение2									 - 																 - 
//  Модально									 - 																 - 
//  Название1									 - 																 - 
//  Название2									 - 																 - 
//  ПолучатьXMLПредставлениеДляНеизвестныхТипов	 - 																 - 
//  ТекущееСвойство								 - 																 - 
//  КлючУникальностиФормы						 - 																 - 
//  РазрешитьКонвертациюВТаблицуЗначений		 - 																 - 
//  ВариантСинтаксиса							 - Строка - "ВстроенныйЯзык", "ЯзыкЗапросов", "ЯзыкКомпоновки", "XML"
//  ОбщееНазвание								 - 																 - 
//
Процедура Сравнить2ЗначенияВФормеЛкс(Знач Значение1, Знач Значение2, Знач Модально = Ложь, Знач Название1 = Неопределено, Знач Название2 = Неопределено, 
	ПолучатьXMLПредставлениеДляНеизвестныхТипов = Истина, ТекущееСвойство = "", КлючУникальностиФормы = Неопределено, РазрешитьКонвертациюВТаблицуЗначений = Ложь, ВариантСинтаксиса = "",
	ОбщееНазвание = "") Экспорт 

	Если Ложь
		Или ТипЗнч(Значение1) = Тип("ТекстовыйДокумент") 
		Или ТипЗнч(Значение1) = Тип("ТабличныйДокумент") 
		Или ТипЗнч(Значение1) = Тип("Строка")
		Или ТипЗнч(Значение1) = Тип("Дата")
		Или ТипЗнч(Значение1) = Тип("Число")
		Или ТипЗнч(Значение1) = Тип("Булево")
		Или ТипЗнч(Значение1) = Тип("Неопределено")
		Или ТипЗнч(Значение1) = Тип("УникальныйИдентификатор")
	Тогда
		СравнитьЗначенияВФормеЧерезXMLЛкс(Значение1, Значение2, Модально, Название1, Название2, ПолучатьXMLПредставлениеДляНеизвестныхТипов, ВариантСинтаксиса, ОбщееНазвание);
		Возврат;
	КонецЕсли; 
	Если РазрешитьКонвертациюВТаблицуЗначений Тогда 
		Если ирОбщий.ЛиКоллекцияЛкс(Значение1) Тогда 
			Значение1 = ирОбщий.ТаблицаЗначенийИзКоллекцииЛкс(Значение1);
		КонецЕсли; 
		Если ирОбщий.ЛиКоллекцияЛкс(Значение2) Тогда 
			Значение2 = ирОбщий.ТаблицаЗначенийИзКоллекцииЛкс(Значение2);
		КонецЕсли;
	КонецЕсли; 
	Если Истина
		И ТипЗнч(Значение1) = Тип("ТаблицаЗначений") 
		И ТипЗнч(Значение2) = Тип("ТаблицаЗначений") 
	Тогда
		СравнитьТаблицыИнтерактивноЛкс(Значение1, Значение2, Модально);
		Возврат;
	КонецЕсли; 
	Объекты = Новый СписокЗначений;
	Объекты.Добавить(Значение1, Название1);
	Объекты.Добавить(Значение2, Название2);
	СравнитьОбъектыВФормеЛкс(Объекты, Модально, ТекущееСвойство,, КлючУникальностиФормы);
	
КонецПроцедуры

Процедура СравнитьТаблицыИнтерактивноЛкс(Знач Значение1, Знач Значение2, Знач Модально = Ложь, Знач БезКлючевыхКолонок = Ложь) Экспорт 
	
	Обработка = ирОбщий.СоздатьОбъектПоИмениМетаданныхЛкс("Обработка.ирСравнениеТаблиц");
	#Если Сервер И Не Сервер Тогда
		Обработка = Обработки.ирСравнениеТаблиц.Создать();
	#КонецЕсли
	ФормаСравнителя = Обработка.ПолучитьФорму();
	ФормаСравнителя.ПараметрТаблица1 = Значение1;
	ФормаСравнителя.ПараметрТаблица2 = Значение2;
	ФормаСравнителя.ПараметрАвтозапуск = Истина;
	ФормаСравнителя.ПараметрБезКлючевыхКолонок = БезКлючевыхКолонок;
	Если Модально Тогда
		ФормаСравнителя.ОткрытьМодально();
	Иначе
		ФормаСравнителя.Открыть();
		ФормаСравнителя.СравнитьТаблицыВФорме();
	КонецЕсли;

КонецПроцедуры

// Процедура - Сравнить объекты в форме лкс
//
// Параметры:
//  Объекты					 - СписокЗначений	 - 
//  Модально				 - 					 - 
//  ТекущееСвойство			 - 					 - 
//  ТекущийОбъект			 - 					 - 
//  КлючУникальностиФормы	 - 					 - 
//  ПараметрНомерЭталона	 - 					 - 
//
Процедура СравнитьОбъектыВФормеЛкс(Знач Объекты, Знач Модально = Ложь, ТекущееСвойство = "", ТекущийОбъект = Неопределено, КлючУникальностиФормы = Неопределено, Знач НомерЭталона = Неопределено,
	Знач ЭтаФорма = Неопределено) Экспорт 
	
	Если Объекты.Количество() = 0 Тогда
		Возврат;
	ИначеЕсли Объекты.Количество() = 1 Тогда
		ДобавитьОбъектВБуферИПредложитьСравнениеЛкс(ТекущийОбъект, ЭтаФорма);
		Возврат;
	КонецЕсли;
	Если ЭтаФорма <> Неопределено Тогда
		ПредложитьЗакрытьМодальнуюФормуЛкс(ЭтаФорма);
	КонецЕсли; 
	ФормаСравнителя = ирКэш.Получить().ПолучитьФорму("СравнениеОбъектов",, КлючУникальностиФормы);
	ФормаСравнителя.ПараметрОбъекты = Объекты;
	ФормаСравнителя.ПараметрТекущееСвойство = ТекущееСвойство;
	ФормаСравнителя.ПараметрТекущийОбъект = ТекущийОбъект;
	ФормаСравнителя.ПараметрНомерЭталона = НомерЭталона;
	Если Модально Тогда
		ФормаСравнителя.ОткрытьМодально();
	Иначе
		ФормаСравнителя.Открыть();
	КонецЕсли;

КонецПроцедуры

Процедура СравнитьЗначенияВФормеЧерезXMLЛкс(Значение1, Значение2, Знач Модально = Ложь, Название1 = "", Название2 = "", Знач XMLПредставлениеДляНеизвестныхТипов = Истина, ВариантСинтаксиса = "",
	ОбщееНазвание = "", РазрешитьСобственныйСравнитель = Истина) Экспорт 
	
	Если Не ЗначениеЗаполнено(Название1) Тогда
		Название1 = "первое";
	КонецЕсли; 
	Если Не ЗначениеЗаполнено(Название2) Тогда
		Название2 = "второе";
	КонецЕсли; 
	Если Истина
		И РазрешитьСобственныйСравнитель
		И ирКэш.ДоступенРедакторМонакоЛкс() 
		И (Ложь
			Или ТипЗнч(Значение1) = Тип("Строка") 
			Или ТипЗнч(Значение1) = Тип("ТекстовыйДокумент"))
		И (Ложь
			Или ТипЗнч(Значение2) = Тип("Строка") 
			Или ТипЗнч(Значение2) = Тип("ТекстовыйДокумент"))
	Тогда
		Если ТипЗнч(Значение1) = Тип("ТекстовыйДокумент") Тогда
			Значение1 = Значение1.ПолучитьТекст();
		КонецЕсли; 
		Если ТипЗнч(Значение2) = Тип("ТекстовыйДокумент") Тогда
			Значение2 = Значение2.ПолучитьТекст();
		КонецЕсли; 
		ФормаСравнителя = ирКэш.ФормаСравнителяТекстовЛкс();
		Если ФормаСравнителя.Открыта() Тогда
			ФормаСравнителя = НоваяФормаСравнителяТекстовЛкс();
		КонецЕсли; 
		ФормаСравнителя.ВариантСинтаксиса = ВариантСинтаксиса;
		ФормаСравнителя.ОбщееНазвание = ОбщееНазвание;
		ФормаСравнителя.Заголовок1 = Название1;
		ФормаСравнителя.Заголовок2 = Название2;
		ФормаСравнителя.Текст1 = Значение1;
		ФормаСравнителя.Текст2 = Значение2;
		ФормаСравнителя.Открыть();
	Иначе
		Путь1 = ПолучитьФайлЗначенияДляИнтерактивногоСравненияЛкс(Значение1, Название1, XMLПредставлениеДляНеизвестныхТипов);
		Путь2 = ПолучитьФайлЗначенияДляИнтерактивногоСравненияЛкс(Значение2, Название2, XMLПредставлениеДляНеизвестныхТипов);
		// Думал, так будет использовать существующее окно, но этого не происходит.
		//Если СравнениеФайлов = Неопределено Тогда
			СравнениеФайлов = Новый СравнениеФайлов;
		//КонецЕсли;
		СравнениеФайлов.ПервыйФайл = Путь1;
		СравнениеФайлов.ВторойФайл = Путь2;
		СравнениеФайлов.ИгнорироватьПустоеПространство = Ложь;
		Если Истина
			И ТипЗнч(Значение1) = Тип("ТабличныйДокумент") 
			И ТипЗнч(Значение2) = Тип("ТабличныйДокумент") 
		Тогда
			СравнениеФайлов.СпособСравнения = СпособСравненияФайлов.ТабличныйДокумент;
		Иначе
			СравнениеФайлов.СпособСравнения = СпособСравненияФайлов.ТекстовыйДокумент;
		КонецЕсли; 
		Если Не Модально И СравнениеФайлов.Сравнить() Тогда
			ирОбщий.СообщитьЛкс("Файлы идентичны");
		Иначе
			Если Модально Тогда 
				СравнениеФайлов.ПоказатьРазличияМодально();
			Иначе
				СравнениеФайлов.ПоказатьРазличия();
			КонецЕсли;
		КонецЕсли; 
	КонецЕсли;

КонецПроцедуры

Функция ПолучитьФайлЗначенияДляИнтерактивногоСравненияЛкс(Значение, Название, XMLПредставлениеДляНеизвестныхТипов = Истина) Экспорт

	Если Ложь
		Или ТипЗнч(Значение) = Тип("ТабличныйДокумент") 
		Или ТипЗнч(Значение) = Тип("ТекстовыйДокумент")
	Тогда
		Документ = Значение;
	Иначе
		Документ = Новый ТекстовыйДокумент;
		Если ТипЗнч(Значение) = Тип("ХранилищеЗначения") Тогда
			Значение = Значение.Получить(); 
		КонецЕсли;
		Если ТипЗнч(Значение) <> Тип("Строка") И XMLПредставлениеДляНеизвестныхТипов Тогда
			Представление = ирОбщий.ОбъектВСтрокуXMLЛкс(Значение);
			Представление = ирОбщий.ДекодироватьТекстИзXMLЛкс(Представление);
		Иначе
			Представление = Значение;
		КонецЕсли;
		Документ.УстановитьТекст(Представление);
	КонецЕсли; 
	Путь = ПолучитьИмяВременногоФайла(Название);
	Документ.Записать(Путь);
	Возврат Путь;

КонецФункции

Функция НоваяФормаСравнителяТекстовЛкс() Экспорт 
	
	ФормаСравнителя = ирКэш.Получить().ПолучитьФорму("СравнениеТекстов",, Новый УникальныйИдентификатор);
	Возврат ФормаСравнителя;

КонецФункции

// Сравнивает табличный документ, полученный из элемента управления с предыдущим.
//
// Параметры:
//  СравнительТабличныхДокументов - Массив, *Неопределено - переменная для хранения предыдущего табличного документа.
//  ЭлементУправления - ТабличноеПоле, ПолеТабличногоДокумента - откуда получаем содержимое.
//  ВариантСинтаксиса - Строка - "ВстроенныйЯзык", "ЯзыкЗапросов", "ЯзыкКомпоновки", "XML"
//
Процедура ЗапомнитьСодержимоеЭлементаФормыДляСравненияЛкс(ЭтаФорма, ЭлементУправления, ВариантСинтаксиса = "") Экспорт

	Если Ложь
		Или ТипЗнч(ЭлементУправления) = Тип("ПолеТекстовогоДокумента") 
		Или ТипЗнч(ЭлементУправления) = Тип("ПолеHTMLДокумента") 
		Или ТипЗнч(ЭлементУправления) = Тип("ПолеВвода") 
		Или ЛиОболочкаТекстаЛкс(ЭлементУправления) 
	Тогда
		ПолеТекста = ОболочкаПоляТекстаЛкс(ЭлементУправления);
		#Если Сервер И Не Сервер Тогда
			ПолеТекста = Обработки.ирОболочкаПолеТекста.Создать();
		#КонецЕсли
		СравниваемыйДокумент = Новый ТекстовыйДокумент;
		СравниваемыйДокумент.УстановитьТекст(ПолеТекста.ПолучитьТекст());
		ЗаголовокЭлементаФормы = ирОбщий.ПредставлениеИзИдентификатораЛкс(ПолеТекста.ЭлементФормы.Имя);
	ИначеЕсли Ложь
		Или ТипЗнч(ЭлементУправления) = Тип("ТабличноеПоле") 
		Или ТипЗнч(ЭлементУправления) = Тип("ТаблицаФормы")
	Тогда
		СравниваемыйДокумент = ВывестиСтрокиТабличногоПоляСНастройкойЛкс(ЭтаФорма, ЭлементУправления);
		Если СравниваемыйДокумент = Неопределено Тогда
			Возврат;
		КонецЕсли; 
		ЗаголовокЭлементаФормы = ирОбщий.ПредставлениеИзИдентификатораЛкс(ЭлементУправления.Имя);
	ИначеЕсли Ложь
		Или ТипЗнч(ЭлементУправления) = Тип("ПолеТабличногоДокумента") 
		Или (Истина
			И ТипЗнч(ЭлементУправления) = Тип("ПолеФормы") 
			И ЭлементУправления.Вид = ВидПоляФормы.ПолеТабличногоДокумента)
	Тогда 
		ТабличныйДокумент = ирОбщий.ДанныеЭлементаФормыЛкс(ЭлементУправления);
		СравниваемыйДокумент = ПолучитьОбластьТабличногоДокументаИнтерактивноЛкс(ТабличныйДокумент);
		ЗаголовокЭлементаФормы = ирОбщий.ПредставлениеИзИдентификатораЛкс(ЭлементУправления.Имя);
	Иначе
		ирОбщий.СообщитьЛкс("Неподдерживаемый тип элемента управления для сравнения");
		Возврат;
	КонецЕсли;
	ДобавитьОбъектВБуферИПредложитьСравнениеЛкс(СравниваемыйДокумент, ЭтаФорма,, ЗаголовокЭлементаФормы, ВариантСинтаксиса);

КонецПроцедуры

Процедура ТабличноеПолеИлиТаблицаФормы_СравнитьСтрокиЛкс(ЭтаФорма, ТабличноеПоле) Экспорт 
	
	#Если Сервер И Не Сервер Тогда
		ТабличноеПоле = Новый ТабличноеПоле;
	#КонецЕсли
	ВыделенныеСтроки = ТабличноеПоле.ВыделенныеСтроки;
	ПолноеИмяТаблицы = "";
	ОбщийТип = ирОбщий.ОбщийТипДанныхТабличногоПоляЛкс(ТабличноеПоле,,, ПолноеИмяТаблицы);
	Объекты = Новый СписокЗначений;
	ТекущийОбъект = Неопределено;
	Если ОбщийТип = "Список" И ЗначениеЗаполнено(ПолноеИмяТаблицы) Тогда
		//Если Истина
		//	И ТабличноеПоле.ВыделенныеСтроки.Количество() > 2 
		//	И ирОбщий.ЛиКорневойТипСсылкиЛкс(ирОбщий.КорневойТипКонфигурацииЛкс(ПолноеИмяТаблицы)) 
		//Тогда
		//	Объекты = ВыделенныеСтрокиТабличногоПоляЛкс(ТабличноеПоле);
		//	ФормаОбработки = ПолучитьФормуЛкс("Обработка.ирПоискДублейИЗаменаСсылок.Форма");
		//	ФормаОбработки.ОткрытьДляЗаменыПоСпискуСсылок(Объекты,, 0);
		//	Возврат;
		//КонецЕсли;  
		Для Каждого ВыделеннаяСтрока Из ВыделенныеСтроки Цикл
			Объекты.Добавить(ВыделеннаяСтрока);
		КонецЦикла;
		ТекущийОбъект = ТабличноеПоле.ТекущаяСтрока;
	Иначе
		ТаблицаЗначений = ТаблицаИлиДеревоЗначенийИзТаблицыФормыСКоллекциейЛкс(ТабличноеПоле, ВыделенныеСтроки,,,,,, ТекущийОбъект);
		Для Каждого ВыделеннаяСтрока Из ТаблицаЗначений Цикл
			Объекты.Добавить(ВыделеннаяСтрока);
		КонецЦикла;
	КонецЕсли; 
	ТекущаяКолонка = ирОбщий.ПутьКДаннымКолонкиТабличногоПоляЛкс(ТабличноеПоле);
	СравнитьОбъектыВФормеЛкс(Объекты,, ТекущаяКолонка, ТекущийОбъект,,, ЭтаФорма);

КонецПроцедуры

// Ф
// Параметры:
//  ВариантСинтаксиса - Строка - "ВстроенныйЯзык", "ЯзыкЗапросов", "ЯзыкКомпоновки", "XML"
Процедура ДобавитьОбъектВБуферИПредложитьСравнениеЛкс(Знач ЗначениеДляСравнения, Знач ЭтаФорма = Неопределено, Знач ТекущееСвойство = "", ЗаголовокЭлементаФормы = "", ВариантСинтаксиса = "") Экспорт 
	
	МассивСравнения = ДобавитьОбъектВБуферСравненияЛкс(ЗначениеДляСравнения);
	Если МассивСравнения.Количество() = 2 Тогда
		//Если ПолеТекста <> Неопределено Тогда
		//	#Если Сервер И Не Сервер Тогда
		//		ПолеТекста = Обработки.ирОболочкаПолеТекста.Создать();
		//	#КонецЕсли
		//	РедакторHTML = ПолеТекста.РедакторHTML();
		//	Если РедакторHTML <> Неопределено Тогда
		//		РедакторHTML.compare(МассивСравнения[0].ПолучитьТекст());
		//		Возврат;
		//	КонецЕсли;
		//КонецЕсли;
		Ответ = Вопрос("Сравнить с предыдущим?", РежимДиалогаВопрос.ДаНет);
		Если Ответ = КодВозвратаДиалога.Нет Тогда
			МассивСравнения.Удалить(0);
			Возврат;
		КонецЕсли;
		Если ЭтаФорма <> Неопределено Тогда
			ПредложитьЗакрытьМодальнуюФормуЛкс(ЭтаФорма);
		КонецЕсли; 
		СравниваемыйДокумент1 = МассивСравнения[0]; 
		СравниваемыйДокумент2 = МассивСравнения[1]; 
		Сравнить2ЗначенияВФормеЛкс(СравниваемыйДокумент1, СравниваемыйДокумент2,,,,, ТекущееСвойство,,, ВариантСинтаксиса, ЗаголовокЭлементаФормы);
		МассивСравнения.Очистить();
	Иначе
		ирОбщий.СообщитьЛкс("Первое значение для сравнения запомнено. Теперь передайте второе значение.");
	КонецЕсли;

КонецПроцедуры

Функция ДобавитьОбъектВБуферСравненияЛкс(Знач ЗначениеДляСравнения) Экспорт 
	
	МассивСравнения = ирКэш.БуферСравненияЛкс("" + ТипЗнч(ЗначениеДляСравнения));
	#Если Сервер И Не Сервер Тогда
		МассивСравнения = Новый Массив;
	#КонецЕсли
	Если МассивСравнения.Количество() = 2 Тогда
		МассивСравнения.Удалить(0);
	КонецЕсли;
	МассивСравнения.Добавить(ЗначениеДляСравнения);
	Возврат МассивСравнения;

КонецФункции

Функция ПолучитьОбластьТабличногоДокументаИнтерактивноЛкс(ТабличныйДокумент) Экспорт 
	
	#Если Сервер И Не Сервер Тогда
		ТабличныйДокумент = Новый ТабличныйДокумент;
	#КонецЕсли
	Если Не ЛиОбластьЯчеекТабличногоДокументаОбъединенаЛкс(ТабличныйДокумент) Тогда
		Ответ = Вопрос("Использовать только текущую область (Да) иначе будет использован весь документ (Нет)?", РежимДиалогаВопрос.ДаНет);
	Иначе
		Ответ = КодВозвратаДиалога.Нет;
	КонецЕсли; 
	Если Ответ = КодВозвратаДиалога.Да Тогда
		Результат = ТабличныйДокумент.ПолучитьОбласть(ТабличныйДокумент.ТекущаяОбласть.Имя);
		ЗаполнитьЗначенияСвойств(Результат, ТабличныйДокумент,, "ВыделенныеОбласти, ТекущаяОбласть"); 
		Результат.ТекущаяОбласть = Результат.Область();
	Иначе
		Результат = ТабличныйДокумент.ПолучитьОбласть();
		ЗаполнитьЗначенияСвойств(Результат, ТабличныйДокумент); 
	КонецЕсли;
	Возврат Результат;

КонецФункции

Функция ЛиОбластьЯчеекТабличногоДокументаОбъединенаЛкс(Знач ТабличныйДокумент, Знач ТекущаяОбласть = Неопределено) Экспорт 
	
	#Если Сервер И Не Сервер Тогда
		ТабличныйДокумент = Новый ТабличныйДокумент;
	#КонецЕсли
	Если ТекущаяОбласть = Неопределено Тогда
		ТекущаяОбласть = ТабличныйДокумент.ТекущаяОбласть;
	КонецЕсли; 
	Область = ТабличныйДокумент.Область(ТекущаяОбласть.Верх, ТекущаяОбласть.Лево);
	Результат = Ложь
		Или ТипЗнч(ТекущаяОбласть) = Тип("РисунокТабличногоДокумента")
		Или ТекущаяОбласть.Низ = Область.Низ И ТекущаяОбласть.Право = Область.Право;
	Возврат Результат;

КонецФункции

Функция ВывестиСтрокиТабличногоПоляСНастройкойЛкс(Знач ЭтаФорма, Знач ТабличноеПоле, ВыводБезОформления = Истина, Знач НастройкиСписка = Неопределено, выхТекущаяСтрока = Неопределено) Экспорт 
	
	ФормаНастройки = ирКэш.Получить().ПолучитьФорму("ПараметрыВыводаСтрокТаблицы", ЭтаФорма);
	ФормаНастройки.ТабличноеПоле = ТабличноеПоле;
	ФормаНастройки.НастройкиСписка = НастройкиСписка;
	Если ВыводБезОформления <> Неопределено Тогда
		ФормаНастройки.БезОформления = ВыводБезОформления;
	КонецЕсли; 
	РезультатФормы = ФормаНастройки.ОткрытьМодально();
	Если РезультатФормы = Неопределено Тогда
		Возврат Неопределено;
	КонецЕсли; 
	выхТекущаяСтрока = Неопределено;
	Результат = ВывестиСтрокиТабличногоПоляЛкс(ЭтаФорма, ТабличноеПоле, ФормаНастройки,, выхТекущаяСтрока, НастройкиСписка);
	Возврат Результат;

КонецФункции

Функция ВывестиСтрокиТабличногоПоляЛкс(Знач ЭтаФорма, Знач ТабличноеПоле, Знач ПараметрыВывода, Отладка = Ложь, выхТекущаяСтрока = Неопределено, Знач НастройкиСписка = Неопределено) Экспорт
	
	КлючТекущейСтроки = Неопределено;
	ИндексТекущейСтроки = Неопределено;
	ПолноеИмяТаблицыБД = "";
	ДанныеТабличногоПоля = Неопределено;
	ТипИсточника = ирОбщий.ОбщийТипДанныхТабличногоПоляЛкс(ТабличноеПоле,,, ПолноеИмяТаблицыБД, ДанныеТабличногоПоля);
	ВыбранныеКолонки = ПараметрыВывода.КолонкиТабличногоПоля.Выгрузить(Новый Структура("Пометка", Истина));
	МассивСтрок = Неопределено;
	ЗначениеТабличногоПоля = ирОбщий.ДанныеЭлементаФормыЛкс(ТабличноеПоле);
	Если ЗначениеТабличногоПоля = Неопределено Тогда
		КоллекцияСтрок = ТаблицаИлиДеревоЗначенийИзТаблицыФормыСКоллекциейЛкс(ТабличноеПоле,,, Ложь);
	ИначеЕсли ТипЗнч(ЗначениеТабличногоПоля) = Тип("ДанныеФормыДерево") Тогда
		ЗначениеТабличногоПоля = ДанныеФормыВЗначение(ЗначениеТабличногоПоля, Тип("ДеревоЗначений"));
	КонецЕсли; 
	Если ТипИсточника = "Список" И ЗначениеЗаполнено(ПолноеИмяТаблицыБД) Тогда
		КлючТекущейСтроки = ирОбщий.СтруктураКлючаТаблицыБДЛкс(ПолноеИмяТаблицыБД);
		Если ТабличноеПоле.ТекущаяСтрока <> Неопределено Тогда
			ЗаполнитьЗначенияСвойств(КлючТекущейСтроки, ТабличноеПоле.ТекущаяСтрока); 
		КонецЕсли; 
		Если ПараметрыВывода.ТолькоВыделенныеСтроки Тогда
			КоллекцияСтрок = КлючиВыделенныхСтрокИмитатораДинамическогоСпискаЛкс(ТабличноеПоле);
		ИначеЕсли ДанныеТабличногоПоля = Неопределено Тогда 
			Возврат Неопределено;
		КонецЕсли;
	Иначе
		Если ПараметрыВывода.ТолькоВыделенныеСтроки Тогда
			МассивСтрок = ВыделенныеСтрокиТабличногоПоляЛкс(ТабличноеПоле);
		КонецЕсли;
		Если ТипЗнч(ЗначениеТабличногоПоля) = Тип("ДеревоЗначений") Тогда
			Если МассивСтрок <> Неопределено Тогда
				КоллекцияСтрок = МассивСтрок;
				Если ТипЗнч(ТабличноеПоле) = Тип("ТаблицаФормы") Тогда
					КоллекцияСтрок = ТаблицаИлиДеревоЗначенийИзТаблицыФормыСКоллекциейЛкс(ТабличноеПоле, МассивСтрок,, Ложь);
				КонецЕсли; 
			Иначе
				КоллекцияСтрок = ЗначениеТабличногоПоля.Строки;
				Если ТипЗнч(ТабличноеПоле.ТекущаяСтрока) = Тип("СтрокаДереваЗначений") Тогда
					ИндексТекущейСтроки = КоллекцияСтрок.Индекс(ТабличноеПоле.ТекущаяСтрока);
				КонецЕсли;
			КонецЕсли; 
		ИначеЕсли Ложь
			Или ТипИсточника = "ТабличнаяЧасть" 
			Или ТипИсточника = "НаборЗаписей"
			Или ТипИсточника = "ТаблицаЗначений" 
		Тогда
			Если ТабличноеПоле.ТекущаяСтрока <> Неопределено Тогда
				//ИндексТекущейСтроки = ЗначениеТабличногоПоля.Индекс(ТабличноеПоле.ТекущаяСтрока);
				ИндексТекущейСтроки = ЗначениеТабличногоПоля.Индекс(ТабличноеПоле.ТекущиеДанные);
			КонецЕсли;
			Если ПараметрыВывода.БезОформления Тогда
				КоллекцияСтрок = ТаблицаИлиДеревоЗначенийИзТаблицыФормыСКоллекциейЛкс(ТабличноеПоле, МассивСтрок, Истина);
			Иначе
				Если МассивСтрок <> Неопределено Тогда
					КоллекцияСтрок = МассивСтрок;
				ИначеЕсли ТипИсточника = "ТаблицаЗначений" Или Не ирОбщий.ЛиОтборУстановленЛкс(ТабличноеПоле.ОтборСтрок) Тогда 
					КоллекцияСтрок = ТабличноеПоле.Значение;
				Иначе
					КоллекцияСтрок = Новый Массив;
					ТекущаяСтрока = Неопределено;
					КопияСтрок = ТаблицаИлиДеревоЗначенийИзТаблицыФормыСКоллекциейЛкс(ТабличноеПоле, МассивСтрок, Истина,,,,, ТекущаяСтрока);
					Для Каждого КопияСтроки Из КопияСтрок Цикл
						КоллекцияСтрок.Добавить(ТабличноеПоле.Значение[КопияСтроки.НомерСтроки - 1]);
					КонецЦикла;
					Если ТекущаяСтрока <> Неопределено Тогда
						ИндексТекущейСтроки = КопияСтрок.Индекс(ТекущаяСтрока);
					КонецЕсли;
				КонецЕсли; 
			КонецЕсли; 
		ИначеЕсли Ложь
			Или ТипИсточника = "Список" 
		Тогда
			КоллекцияСтрок = ТаблицаИлиДеревоЗначенийИзТаблицыФормыСКоллекциейЛкс(ТабличноеПоле, МассивСтрок, Истина);
		Иначе
			Попытка
				КоллекцияСтрок = ДанныеТабличногоПоля.Элементы; // Для компоновки
			Исключение
			КонецПопытки;
		КонецЕсли; 
	КонецЕсли; 
	Если ПараметрыВывода.БезОформления Тогда
		Иерархия = Ложь;
		Если ТипИсточника = "Список" И ЗначениеЗаполнено(ПолноеИмяТаблицыБД) Тогда
			КоллекцияСтрок = ДанныеСтрокДинамическогоСпискаЛкс(ТабличноеПоле, КоллекцияСтрок, ВыбранныеКолонки, НастройкиСписка, ПараметрыВывода.КоличествоПервых);
			#Если Сервер И Не Сервер Тогда
			    КоллекцияСтрок = Новый ТаблицаЗначений;
			#КонецЕсли
			ВыбранныеКолонки = Неопределено;
			ТекущаяСтрока = КоллекцияСтрок.НайтиСтроки(КлючТекущейСтроки);
			Если ТекущаяСтрока.Количество() > 0 Тогда
				ИндексТекущейСтроки = КоллекцияСтрок.Индекс(ТекущаяСтрока[0]);
			КонецЕсли; 
			Если ирОбщий.ЛиКорневойТипСсылкиЛкс(ирОбщий.ТипТаблицыБДЛкс(ПолноеИмяТаблицыБД)) И ПараметрыВывода.КолонкиИдентификаторов Тогда
				//ВыбранныеКолонки.Добавить("Ссылка"); 
				Если КоллекцияСтрок.Колонки.Найти("ИдентификаторСсылкиЛкс") <> Неопределено Тогда
					КоллекцияСтрок.Колонки.Удалить("ИдентификаторСсылкиЛкс");
				КонецЕсли;
				КоллекцияСтрок.Колонки.Добавить("ИдентификаторСсылкиЛкс",, "Идентификатор ссылки");
				//Если ВыбранныеКолонки.Найти("ИдентификаторСсылкиЛкс") = Неопределено Тогда
				//	ВыбранныеКолонки.Добавить("ИдентификаторСсылкиЛкс");
				//КонецЕсли; 
				Для Каждого СтрокаКоллекции Из КоллекцияСтрок Цикл
					СтрокаКоллекции.ИдентификаторСсылкиЛкс = ирОбщий.ИдентификаторСсылкиЛкс(СтрокаКоллекции.Ссылка);
				КонецЦикла;
			КонецЕсли; 
		ИначеЕсли ТипЗнч(ЗначениеТабличногоПоля) = Тип("ДеревоЗначений") Тогда
			ТаблицаСтрокДерева = Новый ТаблицаЗначений;
			ТаблицаСтрокДерева.Колонки.Добавить("_ИДВетки");
			ТаблицаСтрокДерева.Колонки.Добавить("_ИДВеткиРодителя");
			Иерархия = Истина;
			Для Каждого КолонкаДерева Из ЗначениеТабличногоПоля.Колонки Цикл
				ТаблицаСтрокДерева.Колонки.Добавить(КолонкаДерева.Имя, КолонкаДерева.ТипЗначения, КолонкаДерева.Заголовок, КолонкаДерева.Ширина);
			КонецЦикла;
			Если ТипЗнч(КоллекцияСтрок) = Тип("КоллекцияСтрокДереваЗначений") Тогда
				КоллекцияСтрок = ирОбщий.ВсеСтрокиДереваЗначенийЛкс(ЗначениеТабличногоПоля);
			КонецЕсли; 
			КэшПутей = Новый Соответствие;
			Для Каждого СтрокаДерева Из КоллекцияСтрок Цикл
				СтрокаТаблицы = ТаблицаСтрокДерева.Добавить();
				Если СтрокаДерева.Строки.Количество() = 0 Тогда
					СтрокаТаблицы._ИДВетки = "_";
				Иначе
					ПутьКВетке = КэшПутей[СтрокаДерева];
					Если ПутьКВетке = Неопределено Тогда
						ПутьКВетке = ирОбщий.Дерево_ПутьСтрокойЛкс(СтрокаДерева, "");
						КэшПутей[СтрокаДерева] = ПутьКВетке;
					КонецЕсли;
					СтрокаТаблицы._ИДВетки = ПутьКВетке;
				КонецЕсли;
				Если СтрокаДерева.Родитель <> Неопределено Тогда
					ПутьКРодителю = КэшПутей[СтрокаДерева.Родитель];
					Если ПутьКРодителю = Неопределено Тогда
						ПутьКРодителю = ирОбщий.Дерево_ПутьСтрокойЛкс(СтрокаДерева.Родитель, "");
						КэшПутей[СтрокаДерева.Родитель] = ПутьКРодителю;
					КонецЕсли;
					СтрокаТаблицы._ИДВеткиРодителя = ПутьКРодителю;
				КонецЕсли;
				ЗаполнитьЗначенияСвойств(СтрокаТаблицы, СтрокаДерева);
			КонецЦикла;
			КэшПутей = Неопределено;
			КоллекцияСтрок = ТаблицаСтрокДерева;
		ИначеЕсли ТипЗнч(КоллекцияСтрок) <> Тип("ТаблицаЗначений") Тогда 
			КоллекцияСтрок = ТаблицаИлиДеревоЗначенийИзТаблицыФормыСКоллекциейЛкс(ТабличноеПоле, МассивСтрок, Истина);
		КонецЕсли; 
		Если ВыбранныеКолонки <> Неопределено Тогда
			Для Каждого КолонкаКоллекции Из КоллекцияСтрок.Колонки Цикл
				ВыбраннаяКолонка = ВыбранныеКолонки.Найти(КолонкаКоллекции.Имя, "Данные");
				Если ВыбраннаяКолонка <> Неопределено Тогда
					КолонкаКоллекции.Заголовок = ВыбраннаяКолонка.Заголовок;
				КонецЕсли;
			КонецЦикла;
			ВыбранныеКолонки = ВыбранныеКолонки.ВыгрузитьКолонку("Данные");
		КонецЕсли;
		ИмяТекущейКолонки = ирОбщий.ПутьКДаннымКолонкиТабличногоПоляЛкс(ТабличноеПоле);
		Результат = ирОбщий.ВывестиТаблицуВТабличныйДокументИлиТаблицуЗначенийЛкс(КоллекцияСтрок,,, ПараметрыВывода.ИтогиЧисловыхКолонок,, ПараметрыВывода.ВстроитьЗначенияВРасшифровки, 
			ПараметрыВывода.ОтображатьПустые, ПараметрыВывода.КолонкиИдентификаторов, ПараметрыВывода.КолонкиТипов, ПараметрыВывода.КолонкиЗначений, ВыбранныеКолонки, ИмяТекущейКолонки,
			ПараметрыВывода.ВыводВТаблицуЗначений, Отладка, ПараметрыВывода.КолонкиРазмеров, ПараметрыВывода.СузитьТипы, Иерархия);
	Иначе
		Если ТипИсточника = "Список" Тогда
			КоллекцияСтрок = ДанныеСтрокДинамическогоСпискаЛкс(ТабличноеПоле, КоллекцияСтрок,, НастройкиСписка, ПараметрыВывода.КоличествоПервых);
			#Если Сервер И Не Сервер Тогда
			    КоллекцияСтрок = Новый ТаблицаЗначений;
			#КонецЕсли
			ТекущаяСтрока = КоллекцияСтрок.НайтиСтроки(КлючТекущейСтроки);
			Если ТекущаяСтрока.Количество() > 0 Тогда
				ИндексТекущейСтроки = КоллекцияСтрок.Индекс(ТекущаяСтрока[0]);
			КонецЕсли;
			Если ирОбщий.ЛиКорневойТипСсылкиЛкс(ирОбщий.ТипТаблицыБДЛкс(ПолноеИмяТаблицыБД)) Тогда
				КоллекцияСтрок = КоллекцияСтрок.ВыгрузитьКолонку("Ссылка");
			КонецЕсли; 
		КонецЕсли; 
		Если ПараметрыВывода.ВыводВТаблицуЗначений Тогда
			Результат = Новый ТаблицаЗначений;
			Для Каждого ВыбраннаяКолонка Из ВыбранныеКолонки Цикл
				Колонка = ТабличноеПоле.Колонки[ВыбраннаяКолонка.Имя];
				//Если Колонка.Имя = ирКэш.ИмяКолонкиНомерСтрокиЛкс() Тогда
				//	Продолжить;
				//КонецЕсли; 
				//Если Колонка.Видимость Тогда
					КолонкаПриемник = Результат.Колонки.Добавить(Колонка.Имя, Новый ОписаниеТипов("Строка"), ВыбраннаяКолонка.Заголовок);
				//КонецЕсли; 
			КонецЦикла;
			ВыбранныеКолонки = ВыбранныеКолонки.ВыгрузитьКолонку("Имя");
			ВывестиСтрокиТабличногоПоляСОформлениемЛкс(ЭтаФорма, КоллекцияСтрок,, Результат, ТабличноеПоле,, ПараметрыВывода.ВстроитьЗначенияВРасшифровки, ВыбранныеКолонки);
		Иначе
			Результат = Новый ТабличныйДокумент;
			НомерКолонки = 1;
			НомерСтроки = 1;
			ОбластьТаблицы = Результат.Область();
			ОбластьТаблицы.ЦветРамки = ЦветаСтиля.ЦветРамки;
			ОбластьЗаголовков = Результат.Область(НомерСтроки, 0, НомерСтроки, 0);
			ОбластьЗаголовков.ЦветФона = ТабличноеПоле.ЦветФонаШапки;
			ОбластьЗаголовков.ЦветТекста = ТабличноеПоле.ЦветТекстаШапки;
			Для Каждого ВыбраннаяКолонка Из ВыбранныеКолонки Цикл
				Колонка = ТабличноеПоле.Колонки[ВыбраннаяКолонка.Имя];
				//Если Колонка.Имя = ирКэш.ИмяКолонкиНомерСтрокиЛкс() Тогда
				//	Продолжить;
				//КонецЕсли; 
				//Если Колонка.Видимость Тогда
					ОбластьЗаголовка = Результат.Область(НомерСтроки, НомерКолонки, НомерСтроки, НомерКолонки);
					ОбластьЗаголовка.Текст = ВыбраннаяКолонка.Заголовок;
					ОбластьЗаголовка.ЦветФона = Колонка.ЦветФонаШапки;
					ОбластьЗаголовка.ЦветТекста = Колонка.ЦветТекстаШапки;
					//ШиринаКолонки = Колонка.Ширина;
					//Если ШиринаКолонки <= 0 Тогда
					//	Если ЗначениеЗаполнено(Колонка.Данные) Тогда
					//		ШиринаКолонки = ЗначениеТабличногоПоля.Колонки[Колонка.Данные].Ширина;
					//		Если ШиринаКолонки = 0 Тогда
					//			ШиринаКолонки = 30;
					//		КонецЕсли; 
					//	Иначе
					//		ШиринаКолонки = 30;
					//	КонецЕсли; 
					//КонецЕсли; 
					//ШиринаКолонки = Мин(ШиринаКолонки, 50);
					//ШиринаКолонки = Макс(ШиринаКолонки, 10);
					//ОбластьЗаголовка.ШиринаКолонки = ШиринаКолонки;
					ОбластьЗаголовка.ЦветФона = ЦветаСтиля.ЦветФонаШапкиТаблицы;
					ОбластьЗаголовка.ЦветТекста = ЦветаСтиля.ЦветТекстаШапкиТаблицы;
					УстановитьГраницыОбластиТабличногоДокументаИзТабличногоПоляЛкс(ОбластьЗаголовка, ТабличноеПоле);
					НомерКолонки = НомерКолонки + 1;
				//КонецЕсли; 
			КонецЦикла;
			ВыбранныеКолонки = ВыбранныеКолонки.ВыгрузитьКолонку("Имя");
			ВывестиСтрокиТабличногоПоляСОформлениемЛкс(ЭтаФорма, КоллекцияСтрок, НомерСтроки, Результат, ТабличноеПоле,, ПараметрыВывода.ВстроитьЗначенияВРасшифровки, ВыбранныеКолонки);
			УстановитьАвтоширинуКолонокТабличногоДокументаЛкс(Результат);
			Если ТабличноеПоле.ТекущаяКолонка <> Неопределено Тогда
				ИндексКолонки = ВыбранныеКолонки.Найти(ТабличноеПоле.ТекущаяКолонка.Имя);
				Если ИндексКолонки <> Неопределено Тогда
					Результат.ТекущаяОбласть = Результат.Область(2, ИндексКолонки + 1);
				КонецЕсли; 
			КонецЕсли; 
		КонецЕсли; 
	КонецЕсли;
	Если Результат <> Неопределено Тогда
		Если ПараметрыВывода.ТолькоВыделенныеСтроки Или ИндексТекущейСтроки = Неопределено Тогда
			ИндексТекущейСтроки = 0;
		КонецЕсли;
		Если ТипЗнч(Результат) = Тип("ТабличныйДокумент") Тогда
			НомерСтроки = ИндексТекущейСтроки + 2;
			Результат.ТекущаяОбласть = Результат.Область(НомерСтроки, Результат.ТекущаяОбласть.Лево);
		ИначеЕсли Результат.Количество() > ИндексТекущейСтроки И ИндексТекущейСтроки >= 0 Тогда 
			выхТекущаяСтрока = Результат[ИндексТекущейСтроки];
		КонецЕсли; 
	КонецЕсли;
	Возврат Результат;

КонецФункции

// Функция - Данные строк динамического списка лкс
//
// Параметры:
//  ТабличноеПоле			 - 					 - 
//  КлючиСтрок				 - 					 - 
//  ВыбранныеКолонки		 - Строка, ТаблицаЗначений	 - Если строка, то имена через запятую. Если таблица значений, то ее колонки: Данные, Заголовок
//  НастройкиСписка			 - 							 - 
//  КоличествоПервых		 - 							 - 
//  ЭтаФорма				 - Форма - нужна для кэширования запроса итогов
//  ТолькоСуммируемыеКолонки - Булево - данные только для расчета итогов
// 
// Возвращаемое значение:
//   - 
//
Функция ДанныеСтрокДинамическогоСпискаЛкс(Знач ТабличноеПоле, Знач КлючиСтрок = Неопределено, Знач ВыбранныеКолонки = Неопределено, НастройкиСписка = Неопределено,
	Знач КоличествоПервых = 100000, Знач ЭтаФорма = Неопределено, Знач ТолькоСуммируемыеКолонки = Ложь) Экспорт 
	
	ПолноеИмяТаблицы = ирОбщий.ИмяТаблицыБДДинамическогоСпискаЛкс(ТабличноеПоле);
	Если Истина
		И ирОбщий.ЛиКорневойТипВнешнегоИсточникаДанныхЛкс(ирОбщий.ПервыйФрагментЛкс(ПолноеИмяТаблицы)) 
		И КлючиСтрок <> Неопределено
	Тогда
		// https://www.hostedredmine.com/issues/916752
		Результат = КлючиСтрок;
	Иначе
		СтруктураКлюча = ирОбщий.СтруктураКлючаТаблицыБДЛкс(ПолноеИмяТаблицы,,, Ложь);
		ДинамическийСписок = ирОбщий.ДанныеЭлементаФормыЛкс(ТабличноеПоле);
		СхемаИНастройки = Неопределено;
		Если ТипЗнч(ТабличноеПоле) = Тип("ТаблицаФормы") Тогда
			СхемаИНастройки = ИсполняемыеСхемаИНастройкиСпискаУправляемойФормаЛкс(ирОбщий.РодительЭлементаУправляемойФормыЛкс(ТабличноеПоле), ТабличноеПоле.Имя);
		КонецЕсли; 
		Если СхемаИНастройки <> Неопределено Тогда
			СхемаКомпоновки = СхемаИНастройки.Схема;
			ирОбщий.ДобавитьПоляНабораДанныхЛкс(ПолноеИмяТаблицы, СхемаКомпоновки);
			НастройкаКомпоновки = СхемаИНастройки.Настройки;
		Иначе
			ПсведонимТаблицы = "Таблица" + ирОбщий.СуффиксСлужебногоСвойстваЛкс();
			СхемаКомпоновки = ирОбщий.СоздатьСхемуКомпоновкиТаблицыБДЛкс(ПолноеИмяТаблицы,,,, ПсведонимТаблицы,, Истина, КоличествоПервых);
			НастройкаКомпоновки = Новый НастройкиКомпоновкиДанных;
		КонецЕсли; 
		#Если Сервер И Не Сервер Тогда
			СхемаКомпоновки = Новый СхемаКомпоновкиДанных;
		#КонецЕсли
		Если ДинамическийСписок = Неопределено Тогда
			Если КлючиСтрок = Неопределено Тогда
				Возврат Неопределено;
			КонецЕсли; 
		Иначе
			Если НастройкиСписка = Неопределено Тогда
				НастройкиСписка = ирОбщий.НастройкиДинамическогоСпискаЛкс(ДинамическийСписок);
			КонецЕсли; 
			#Если Сервер И Не Сервер Тогда
				НастройкиСписка = Новый НастройкиКомпоновкиДанных;
			#КонецЕсли
			ирОбщий.СкопироватьОтборЛюбойЛкс(НастройкаКомпоновки.Отбор, НастройкиСписка.Отбор);
			Если Не ирОбщий.ЛиКорневойТипПеречисленияЛкс(ирОбщий.ПервыйФрагментЛкс(ПолноеИмяТаблицы)) Тогда
				ирОбщий.СкопироватьПорядокЛюбойЛкс(НастройкаКомпоновки.Порядок, НастройкиСписка.Порядок);
			КонецЕсли; 
		КонецЕсли; 
		Для Каждого КлючИЗначение Из СтруктураКлюча Цикл
			ирОбщий.НайтиДобавитьЭлементНастроекКомпоновкиПоПолюЛкс(НастройкаКомпоновки.Выбор, КлючИЗначение.Ключ);
			ПолеНабора = СхемаКомпоновки.НаборыДанных[0].Поля.Найти(КлючИЗначение.Ключ);
			Если ПолеНабора = Неопределено Тогда
				ПолеНабора = СхемаКомпоновки.НаборыДанных[0].Поля.Добавить(Тип("ПолеНабораДанныхСхемыКомпоновкиДанных"));
				ПолеНабора.Поле = КлючИЗначение.Ключ;
				ПолеНабора.ПутьКДанным = КлючИЗначение.Ключ;
			КонецЕсли; 
			ПолеНабора.Роль.Обязательное = Истина;
		КонецЦикла;
		Если ВыбранныеКолонки <> Неопределено Тогда
			Если ТипЗнч(ВыбранныеКолонки) = Тип("Строка") Тогда
				// Сюда приходим из различных значений колонки и из расчета итогов табличного поля динамического списка
				ИменаВыбранныхКолонок = ирОбщий.СтрРазделитьЛкс(ВыбранныеКолонки, ",", Истина);
				ВыбранныеКолонки = Новый ТаблицаЗначений;
				ВыбранныеКолонки.Колонки.Добавить("Данные");
				ВыбранныеКолонки.Колонки.Добавить("Заголовок");
				Для Каждого ИмяКолонки Из ИменаВыбранныхКолонок Цикл
					СтрокаКолонки = ВыбранныеКолонки.Добавить();
					СтрокаКолонки.Данные = ИмяКолонки;
				КонецЦикла;
			КонецЕсли; 
			Для Каждого ВыбраннаяКолонка Из ВыбранныеКолонки Цикл
				Если Не ЗначениеЗаполнено(ВыбраннаяКолонка.Данные) Тогда
					Продолжить;
				КонецЕсли; 
				ирОбщий.НайтиДобавитьЭлементНастроекКомпоновкиПоПолюЛкс(НастройкаКомпоновки.Выбор, ВыбраннаяКолонка.Данные);
			КонецЦикла;
		КонецЕсли;
		Если ТипЗнч(ТабличноеПоле) = Тип("ТаблицаФормы") Тогда
			КомпоновщикНастроек = Новый КомпоновщикНастроекКомпоновкиДанных;
			КомпоновщикНастроек.Инициализировать(Новый ИсточникДоступныхНастроекКомпоновкиДанных(СхемаКомпоновки));
			КомпоновщикНастроек.ЗагрузитьНастройки(НастройкаКомпоновки);
			ирОбщий.КомпоновщикНастроекВосстановитьЛкс(КомпоновщикНастроек);
			НастройкаКомпоновки = КомпоновщикНастроек.Настройки;
		КонецЕсли;
		Если Истина
			И КлючиСтрок <> Неопределено 
			И КлючиСтрок.Количество() = 0 
		Тогда
			Запрос = ирОбщий.ЗапросИзКомпоновкиЛкс(СхемаКомпоновки, НастройкаКомпоновки);
			#Если Сервер И Не Сервер Тогда
				Запрос = Новый Запрос;
			#КонецЕсли
			Результат = ирОбщий.ПустаяТаблицаЗначенийИзТекстаЗапросаЛкс(Запрос.Текст);
		Иначе
			Если Истина
				И КлючиСтрок <> Неопределено 
				И ирКэш.ДоступнаСхемаЗапросаЛкс()
				И ирКэш.НомерРежимаСовместимостиЛкс() > 803001 // Антибаг схемы запроса
				И ТолькоСуммируемыеКолонки
			Тогда
				ДопСвойства = ДопСвойстваЭлементаФормыЛкс(ЭтаФорма, ТабличноеПоле);
				Запрос = ДопСвойства.ЗапросИтоговПоТаблицеКлючей;
				Если Запрос = Неопределено Тогда
					Запрос = ирОбщий.ЗапросИзКомпоновкиЛкс(СхемаКомпоновки, НастройкаКомпоновки);
					Запрос = ирОбщий.ЗапросОтбораПоТаблицеКлючейЛкс(Запрос, СтруктураКлюча, Истина);
					ДопСвойства.ЗапросИтоговПоТаблицеКлючей = Запрос;
				КонецЕсли;
				#Если Сервер И Не Сервер Тогда
					Запрос = Новый Запрос;
				#КонецЕсли
				Запрос.Параметры.Вставить("Ключи", ТаблицаКлючейВыделенныхСтрокДинСпискаЛкс(ТабличноеПоле, ПолноеИмяТаблицы));
			Иначе
				Если КлючиСтрок <> Неопределено Тогда
					ГруппаИли = НастройкаКомпоновки.Отбор.Элементы.Добавить(Тип("ГруппаЭлементовОтбораКомпоновкиДанных"));
					ГруппаИли.ТипГруппы = ТипГруппыЭлементовОтбораКомпоновкиДанных.ГруппаИли;
					ГруппаИли.Использование = Истина;
					Для Каждого КлючСтроки Из КлючиСтрок Цикл
						ГруппаИ = ГруппаИли.Элементы.Добавить(Тип("ГруппаЭлементовОтбораКомпоновкиДанных"));
						ГруппаИ.ТипГруппы = ТипГруппыЭлементовОтбораКомпоновкиДанных.ГруппаИ;
						ГруппаИ.Использование = Истина;
						ЗначениеПоляКлюча = Неопределено;
						Для Каждого КлючИЗначение Из СтруктураКлюча Цикл
							Если ирОбщий.ЛиТипСсылкиТочкиМаршрутаЛкс(ТипЗнч(КлючСтроки)) Тогда
								ЗначениеПоляКлюча = КлючСтроки;
							Иначе
								ЗначениеПоляКлюча = КлючСтроки[КлючИЗначение.Ключ];
							КонецЕсли; 
							ирОбщий.НайтиДобавитьЭлементОтбораКомпоновкиЛкс(ГруппаИ, КлючИЗначение.Ключ, ЗначениеПоляКлюча);
						КонецЦикла;
						Если Истина
							И СтруктураКлюча.Количество() = 1 
							И ТипЗнч(ЗначениеПоляКлюча) = Тип("УникальныйИдентификатор")
						Тогда
							// Антибаг платформы https://www.hostedredmine.com/issues/895239
							ирОбщий.НайтиДобавитьЭлементОтбораКомпоновкиЛкс(ГруппаИ);
						КонецЕсли; 
					КонецЦикла;
				КонецЕсли; 
				// https://www.hostedredmine.com/issues/897644
				// Обеспечиваем наличие всех полей ключа. Некоторые могли быть отключены 
				Запрос = ирОбщий.ЗапросИзКомпоновкиЛкс(СхемаКомпоновки, НастройкаКомпоновки, Истина);
			КонецЕсли;
			#Если Сервер И Не Сервер Тогда
				Запрос = Новый Запрос;
			#КонецЕсли
			Результат = Запрос.Выполнить().Выгрузить();
		КонецЕсли;
		Если ВыбранныеКолонки <> Неопределено Тогда
			Для Каждого ВыбраннаяКолонка Из ВыбранныеКолонки Цикл
				Если Не ЗначениеЗаполнено(ВыбраннаяКолонка.Данные) Тогда 
					Продолжить;
				КонецЕсли; 
				ИмяКолонки = СтрЗаменить(ВыбраннаяКолонка.Данные, ".", "");
				КолонкаРезультата = Результат.Колонки.Найти(ИмяКолонки);
				Если КолонкаРезультата = Неопределено Тогда
					Результат.Колонки.Добавить(ИмяКолонки,, ВыбраннаяКолонка.Заголовок);
				Иначе
					КолонкаРезультата.Заголовок = ВыбраннаяКолонка.Заголовок;
				КонецЕсли;
			КонецЦикла;
			// Заполним колонки динамического списка, не являющиеся полями его основной таблицы БД
			Если Истина
				И ТипЗнч(ТабличноеПоле) = Тип("ТаблицаФормы")
				И КлючиСтрок <> Неопределено
				И ЗначениеЗаполнено(ПсведонимТаблицы) // Базовый запрос вместо полного
			Тогда
				Для Каждого КлючСтроки Из КлючиСтрок Цикл
					ЗаполнитьЗначенияСвойств(СтруктураКлюча, КлючСтроки); 
					ДанныеСтроки = ТабличноеПоле.ДанныеСтроки(КлючСтроки);
					ЗаполнитьЗначенияСвойств(Результат.НайтиСтроки(СтруктураКлюча)[0], ДанныеСтроки); 
				КонецЦикла;
			КонецЕсли;
		КонецЕсли;
	КонецЕсли; 
	Возврат Результат;

КонецФункции

Функция ТаблицаКлючейВыделенныхСтрокДинСпискаЛкс(Знач ТабличноеПоле, Знач ПолноеИмяТаблицы = "", выхКлючТекущейСтроки = Неопределено) Экспорт 

	Если Не ЗначениеЗаполнено(ПолноеИмяТаблицы) Тогда
		ПолноеИмяТаблицы = ирОбщий.ИмяТаблицыБДДинамическогоСпискаЛкс(ТабличноеПоле);
	КонецЕсли;
	СтруктураКлюча = ирОбщий.СтруктураКлючаТаблицыБДЛкс(ПолноеИмяТаблицы,,, Ложь);
	ТаблицаКлючей = Новый ТаблицаЗначений;
	Для Каждого КлючИЗначение Из СтруктураКлюча Цикл
		ТаблицаКлючей.Колонки.Добавить(КлючИЗначение.Ключ, КлючИЗначение.Значение);
	КонецЦикла;
	Для Каждого ВыделеннаяСтрока Из ТабличноеПоле.ВыделенныеСтроки Цикл
		Если ТипЗнч(ВыделеннаяСтрока) = Тип("Число") Тогда
			КлючСтроки = ТабличноеПоле.ДанныеСтроки(ВыделеннаяСтрока);
		Иначе
			КлючСтроки = ВыделеннаяСтрока;
		КонецЕсли;
		СтрокаКлюча = ТаблицаКлючей.Добавить();
		ЗаполнитьЗначенияСвойств(СтрокаКлюча, КлючСтроки);
		Если КлючСтроки = ТабличноеПоле.ТекущаяСтрока Тогда
			выхКлючТекущейСтроки = СтрокаКлюча;
		КонецЕсли;
	КонецЦикла;
	Возврат ТаблицаКлючей;

КонецФункции

// .
// Параметры:
//  ТабличноеПоле		 - 	 - 
//  НуженВидимыйПорядок	 - Булево - для динамического списка вычисление видимого порядка - долгое
//  ЭтаФорма			 - Форма - передается для ускорения расчета итогов динамического списка
// 
// Возвращаемое значение:
//   - Массив - ключей выделенных строк
//
Функция ВыделенныеСтрокиТабличногоПоляЛкс(Знач ТабличноеПоле, Знач НуженВидимыйПорядок = Истина, ЭтаФорма = Неопределено) Экспорт
	
	ВыделенныеСтроки = ТабличноеПоле.ВыделенныеСтроки;
	#Если Сервер И Не Сервер Тогда
		ВыделенныеСтроки = Новый Массив;
	#КонецЕсли
	Если Ложь
		Или Не НуженВидимыйПорядок
		Или ВыделенныеСтроки.Количество() <= 1
	Тогда
		Результат = Новый Массив;
		Для Каждого ВыделеннаяСтрока Из ВыделенныеСтроки Цикл
			Результат.Добавить(ВыделеннаяСтрока);
		КонецЦикла;
		Возврат Результат;
	КонецЕсли; 
	// https://partners.v8.1c.ru/forum/t/1928636/m/1928636
	// http://www.hostedredmine.com/issues/881648
	МассивСтрок = Новый Массив;
	ПолноеИмяТаблицыБД = "";
	ДанныеТабличногоПоля = Неопределено;
	ТипИсточника = ирОбщий.ОбщийТипДанныхТабличногоПоляЛкс(ТабличноеПоле,,, ПолноеИмяТаблицыБД, ДанныеТабличногоПоля);
	Если Истина
		И ТипИсточника = "Список" 
		И ЗначениеЗаполнено(ПолноеИмяТаблицыБД) 
		И ДанныеТабличногоПоля <> Неопределено
	Тогда
		КоллекцияСтрок = ДанныеСтрокДинамическогоСпискаЛкс(ТабличноеПоле, ВыделенныеСтроки,,,, ЭтаФорма);
		СтруктураКлюча = Неопределено;
		ОбъектМД = Неопределено;
		Для Каждого ДанныеСтроки Из КоллекцияСтрок Цикл
			МассивСтрок.Добавить(ирОбщий.КлючСтрокиТаблицыБДИзСтрокиТаблицыЗначенийЛкс(ПолноеИмяТаблицыБД, ДанныеСтроки,,,, СтруктураКлюча, ОбъектМД));
		КонецЦикла;
	Иначе
		Если Истина
			И ТипЗнч(ТабличноеПоле) = Тип("ТабличноеПоле")
			И ТипЗнч(ТабличноеПоле.Значение) = Тип("ДеревоЗначений") 
		Тогда
			ВсеСтроки = ирОбщий.ВсеСтрокиДереваЗначенийЛкс(ТабличноеПоле.Значение);
			#Если Сервер И Не Сервер Тогда
				ВсеСтроки = Новый Массив;
			#КонецЕсли
		Иначе
			ВсеСтроки = ДанныеТабличногоПоля;
		КонецЕсли; 
		Если ирОбщий.ЛиКоллекцияЛкс(ВсеСтроки) Тогда
			Для Каждого ЭлементКоллекции Из ВсеСтроки Цикл
				Если ТипЗнч(ЭлементКоллекции) = Тип("ДанныеФормыЭлементКоллекции") Тогда
					ВыделеннаяСтрока = ЭлементКоллекции.ПолучитьИдентификатор();
					СтрокаВыделена = ВыделенныеСтроки.Найти(ВыделеннаяСтрока) <> Неопределено;
				Иначе
					ВыделеннаяСтрока = ЭлементКоллекции;
					СтрокаВыделена = ВыделенныеСтроки.Содержит(ВыделеннаяСтрока);
				КонецЕсли; 
				Если СтрокаВыделена Тогда
					МассивСтрок.Добавить(ВыделеннаяСтрока);
				КонецЕсли; 
			КонецЦикла;
		Иначе
			// Грязно
			ПредПозиция = Неопределено;
			ПорядокНарушен = Ложь;
			ТаблицаСтрок = Новый ТаблицаЗначений;
			ТаблицаСтрок.Колонки.Добавить("Строка");
			ТаблицаСтрок.Колонки.Добавить("Позиция");
			Для Каждого ВыделеннаяСтрока Из ВыделенныеСтроки Цикл
				Если ТипЗнч(ТабличноеПоле) = Тип("ТаблицаФормы") Тогда
					ПозицияСтроки = ВыделеннаяСтрока;
					Если Истина
						И ТипЗнч(ПозицияСтроки) = Тип("Число") // Бывают и другие типы. Для них не будет корректировки порядка
						И ПредПозиция <> Неопределено 
						И ПозицияСтроки < ПредПозиция И ТаблицаСтрок.Количество() > 2 
					Тогда
						ПорядокНарушен = Истина;
					КонецЕсли; 
					ПредПозиция = ПозицияСтроки;
				ИначеЕсли Истина
					И ТипЗнч(ТабличноеПоле) = Тип("ТабличноеПоле")
					И ТипЗнч(ТабличноеПоле.Значение) = Тип("ДеревоЗначений") 
				Тогда 
					ПозицияСтроки = ВсеСтроки.Найти(ВыделеннаяСтрока);
				Иначе
					ПозицияСтроки = Неопределено;
				КонецЕсли; 
				СтрокаТаблицы = ТаблицаСтрок.Добавить();
				СтрокаТаблицы.Строка = ВыделеннаяСтрока;
				СтрокаТаблицы.Позиция = ПозицияСтроки;
			КонецЦикла;
			Если Не ПорядокНарушен Или ТипЗнч(ТабличноеПоле) <> Тип("ТаблицаФормы") Тогда
				ТаблицаСтрок.Сортировать("Позиция");
			КонецЕсли; 
			МассивСтрок = ТаблицаСтрок.ВыгрузитьКолонку("Строка");
		КонецЕсли; 
	КонецЕсли;
	Возврат МассивСтрок;

КонецФункции

Функция ВыделенныеИлиВсеСтрокиТабличногоПоляЛкс(Знач ТабличноеПоле) Экспорт 
	
	Если ТабличноеПоле.ВыделенныеСтроки.Количество() > 1 Тогда
		ВыделенныеСтроки = ТабличноеПоле.ВыделенныеСтроки;
	Иначе
		ВыделенныеСтроки = ТабличноеПоле.Значение;
	КонецЕсли;
	Возврат ВыделенныеСтроки;

КонецФункции

Процедура ВывестиСтрокиТабличногоПоляСОформлениемЛкс(Знач ЭтаФорма, Знач КоллекцияСтрок, НомерСтроки = Неопределено, Знач Результат, Знач ТабличноеПоле, Смещение = "", ВстроитьЗначенияВРасшифровки = Истина,
	Знач ВыбранныеКолонки = Неопределено)
	
	Если ВыбранныеКолонки = Неопределено Тогда
		ВыбранныеКолонки = Новый Массив;
		Для Каждого КолонкаТП Из ТабличноеПоле.Колонки Цикл
			ВыбранныеКолонки.Добавить(КолонкаТП.Имя);
		КонецЦикла;
	КонецЕсли;  
	ДопСвойства = ДопСвойстваЭлементаФормыЛкс(ЭтаФорма, ТабличноеПоле);
	// Уберем разметку вхождений строки поиска
	ДопСвойства.ЗапретРазметкиВхождений = Истина;
	ТабличноеПоле.ОбновитьСтроки(КоллекцияСтрок);
	Индикатор = ирОбщий.ПолучитьИндикаторПроцессаЛкс(КоллекцияСтрок.Количество());
	Для Каждого СтрокаИсточника Из КоллекцияСтрок Цикл
		ирОбщий.ОбработатьИндикаторЛкс(Индикатор);
		Попытка
			ОформлениеСтроки = ТабличноеПоле.ОформлениеСтроки(СтрокаИсточника);
		Исключение
			// Строки уже могли быть сконвертированы в строки ТЗ. Например доступные поля компоновки 
			ОформлениеСтроки = Неопределено;
		КонецПопытки;
		Если ОформлениеСтроки = Неопределено Тогда
			Прервать;
		КонецЕсли; 
		Если ТипЗнч(Результат) = Тип("ТабличныйДокумент") Тогда
			#Если Сервер И Не Сервер Тогда
			    Результат = Новый ТабличныйДокумент;
			#КонецЕсли
			НомерСтроки = НомерСтроки + 1;
			ОбластьСтроки = Результат.Область(НомерСтроки, 0, НомерСтроки, 0);
			//ЗаполнитьЗначенияСвойств(ОбластьСтроки, ОформлениеСтроки, "Шрифт, ЦветТекста, ЦветФона"); 
		ИначеЕсли ТипЗнч(Результат) = Тип("ТаблицаЗначений") Тогда
			#Если Сервер И Не Сервер Тогда
			    Результат = Новый ТаблицаЗначений;
			#КонецЕсли
			ОбластьСтроки = Результат.Добавить();
		КонецЕсли; 
		НомерКолонки = 1;
		Для Каждого ИмяКолонки Из ВыбранныеКолонки Цикл
			Колонка = ТабличноеПоле.Колонки[ИмяКолонки];
			//Если Ложь
			//	Или Не Колонка.Видимость 
			//	//Или Колонка.Имя = ирКэш.ИмяКолонкиНомерСтрокиЛкс() 
			//Тогда
			//	Продолжить;
			//КонецЕсли; 
			ОформлениеЯчейки = ОформлениеСтроки.Ячейки[Колонка.Имя];
			Если ТипЗнч(Результат) = Тип("ТабличныйДокумент") Тогда
				ОбластьЯчейки = Результат.Область(НомерСтроки, НомерКолонки, НомерСтроки, НомерКолонки);
				ЗаполнитьЗначенияСвойств(ОбластьЯчейки, ОформлениеЯчейки, "Шрифт, ЦветТекста, ЦветФона"); 
				Если ОформлениеЯчейки.ОтображатьТекст Тогда
					Если ОформлениеЯчейки.Значение = Истина И Не ЗначениеЗаполнено(ОформлениеЯчейки.Текст) Тогда
						ТекстЯчейки = "Да";
					Иначе
						ТекстЯчейки = ОформлениеЯчейки.Текст;
					КонецЕсли;
					ОбластьЯчейки.Текст = Смещение + ТекстЯчейки;
				ИначеЕсли ОформлениеЯчейки.ОтображатьФлажок Тогда
					ОбластьЯчейки.Текст = Смещение + ОформлениеЯчейки.ЗначениеФлажка;
				КонецЕсли; 
				Если Истина 
					И ВстроитьЗначенияВРасшифровки
					//И ирОбщий.ЛиСсылкаНаОбъектБДЛкс(ОформлениеЯчейки.Значение, Ложь) 
				Тогда
					ОбластьЯчейки.Расшифровка = ОформлениеЯчейки.Значение;
				КонецЕсли; 
				УстановитьГраницыОбластиТабличногоДокументаИзТабличногоПоляЛкс(ОбластьЯчейки, ТабличноеПоле);
				НомерКолонки = НомерКолонки + 1;
			ИначеЕсли ТипЗнч(Результат) = Тип("ТаблицаЗначений") Тогда
				ОбластьСтроки[Колонка.Имя] = ОформлениеЯчейки.Текст;
			КонецЕсли; 
		КонецЦикла;
		Если Истина
			И ТипЗнч(Результат) = Тип("ТабличныйДокумент") 
			И ТипЗнч(СтрокаИсточника) = Тип("СтрокаДереваЗначений")
			И ТабличноеПоле.Развернут(СтрокаИсточника) 
		Тогда
			Результат.НачатьГруппуСтрок();
			ВывестиСтрокиТабличногоПоляСОформлениемЛкс(ЭтаФорма, СтрокаИсточника.Строки, НомерСтроки, Результат, ТабличноеПоле, Смещение + "    ");
			Результат.ЗакончитьГруппуСтрок();
		КонецЕсли;
	КонецЦикла;
	ирОбщий.ОсвободитьИндикаторПроцессаЛкс();
	// Вернем разметку вхождений строки поиска
	ДопСвойства.ЗапретРазметкиВхождений = Ложь;
	ТабличноеПоле.ОбновитьСтроки(КоллекцияСтрок);

КонецПроцедуры

Процедура ВывестиСтрокиТабличногоПоляИПоказатьЛкс(Знач ЭтаФорма, Знач ТабличноеПоле, Знач ВыводБезОформления = Неопределено, Знач НастройкиСписка = Неопределено) Экспорт 
	
	ТекущаяСтрока = Неопределено;
	Результат = ВывестиСтрокиТабличногоПоляСНастройкойЛкс(ЭтаФорма, ТабличноеПоле, ВыводБезОформления, НастройкиСписка, ТекущаяСтрока);
	Если Результат <> Неопределено Тогда
		ОткрытьЗначениеЛкс(Результат,,,, Ложь,, ТабличноеПоле);
	КонецЕсли; 

КонецПроцедуры

Процедура УстановитьГраницыОбластиТабличногоДокументаИзТабличногоПоляЛкс(Знач ОбластьЯчейки, Знач ЭлементУправления) Экспорт
	
	ЛинияСплошная = Новый Линия(ТипЛинииЯчейкиТабличногоДокумента.Сплошная);
	Если ЭлементУправления.ГоризонтальныеЛинии Тогда
		ОбластьЯчейки.ГраницаСверху = ЛинияСплошная;
		ОбластьЯчейки.ГраницаСнизу = ЛинияСплошная;
	КонецЕсли; 
	Если ЭлементУправления.ВертикальныеЛинии Тогда
		ОбластьЯчейки.ГраницаСлева = ЛинияСплошная;
		ОбластьЯчейки.ГраницаСправа = ЛинияСплошная;
	КонецЕсли;
	
КонецПроцедуры // ЛксСравнитьСодержимоеПоля()

Процедура РасширитьКолонкиТабличногоПоляЛкс(ТабличноеПоле, УважатьЗапретИзмененияРазмера = Истина) Экспорт 
	
	//ВведенноеЗначениеШирины = 10;
	//Если ВвестиЧисло(ВведенноеЗначениеШирины, "Введите новую ширину колонки для всех колонок", 5, 0) Тогда
	//	УстановитьСвойствоВКоллекцииЛкс(ТабличноеПоле.Колонки, "-Ширина", ВведенноеЗначениеШирины);
	//КонецЕсли;
	Для Каждого Колонка Из ТабличноеПоле.Колонки Цикл
		Ширина = Колонка.Ширина;
		Если Ширина = 0 Тогда
			// Антибаг платформы.
			Ширина = 10;
		КонецЕсли;
		Если Ложь
			Или Не УважатьЗапретИзмененияРазмера
			Или Колонка.ИзменениеРазмера = ИзменениеРазмераКолонки.Изменять
		Тогда
			НоваяШирина = Ширина + 3;
			Колонка.Ширина = НоваяШирина;
		КонецЕсли;
	КонецЦикла;
	
КонецПроцедуры

// Пропорционально сжимает ширины колонок табличного поля.
//
// Параметры:
//  ТабличноеПоле - ТабличноеПоле;
//  Сжатие        - Число, *2 - коэффициент сжатия;
//  УважатьЗапретИзмененияРазмера - Булево, *Истина - не сжимать колонки с запретом изменения размера;
//
Процедура СжатьКолонкиТабличногоПоляЛкс(ТабличноеПоле, Сжатие = 2, УважатьЗапретИзмененияРазмера = Истина) Экспорт

	Для Каждого Колонка Из ТабличноеПоле.Колонки Цикл
		Ширина = Колонка.Ширина;
		Если Ширина = 0 Тогда
			// Антибаг платформы.
			Ширина = 10;
		КонецЕсли;
		Если Ложь
			Или Не УважатьЗапретИзмененияРазмера
			Или Колонка.ИзменениеРазмера = ИзменениеРазмераКолонки.Изменять
		Тогда
			НоваяШирина = Ширина / Сжатие;
			НоваяШирина = Макс(НоваяШирина, 1);
			Колонка.Ширина = НоваяШирина;
		КонецЕсли;
	КонецЦикла;

КонецПроцедуры

// Интерактивно записывает значение в поле ввода. Интерактивность заключается в срабатывании события ПриИзменении.
//
// Параметры:
//  ЭлементУправления - ЭлементУправления - которому присваиваем значение;
//  Значение     - Произвольный - присваиваемое значение;
//  ФормаИнициатор - Форма, УправляемаяФорма, *Неопределено - которая будет использована в качестве инициатора события;
//               если не указана, то будет создана временная форма-пустышка;
//  КонтролироватьУспех - Булево, *Ложь - проверять успешность установки значения, долго и не надежно для управляемой формы
//
// Результат - Булево, Неопределено - Если КонтролироватьУспех, то успешно ли значение установлено, иначе Неопределено
Функция ИнтерактивноЗаписатьВПолеВводаЛкс(ПолеВвода, Знач Значение = Неопределено, Знач ФормаИнициатор = Неопределено, КонтролироватьУспех = Ложь) Экспорт
	
	Если ФормаИнициатор = Неопределено Тогда
		ФормаИнициатор = ирКэш.ФормаПустышкаЛкс();
	Иначе
		СтарыйВладелец = ФормаИнициатор.ВладелецФормы;
		СтарыйЗакрыватьПриВыборе = ФормаИнициатор.ЗакрыватьПриВыборе;
		ФормаИнициатор.ЗакрыватьПриВыборе = Ложь;
	КонецЕсли;
	ФормаИнициатор.ВладелецФормы = ПолеВвода;
	НовоеЗначение = ПолеВвода.ОграничениеТипа.ПривестиЗначение(Значение);
	Если Ложь
		Или НовоеЗначение <> Значение 
		Или ПолеВвода.ТолькоПросмотр
	Тогда
		Возврат Ложь;
	КонецЕсли; 
	ФормаИнициатор.ОповеститьОВыборе(Значение); 
	Если СтарыйЗакрыватьПриВыборе <> Неопределено Тогда
		ФормаИнициатор.ВладелецФормы = СтарыйВладелец;
		ФормаИнициатор.ЗакрыватьПриВыборе = СтарыйЗакрыватьПриВыборе;
	КонецЕсли; 
	Результат = Истина;
	Если КонтролироватьУспех Тогда
		ЗначениеПоля = ирОбщий.ДанныеЭлементаФормыЛкс(ПолеВвода);
		//Попытка
			Результат = ЗначениеПоля = Значение;
		//Исключение
		//	// Это поле управляемой формы
		//	Результат = Истина;
		//КонецПопытки;
	КонецЕсли;
	Возврат Результат;
	
КонецФункции

// Интерактивно записывает значение в элемент управления (только поле ввода/формы) колонки табличного поля или таблицы формы.
// Интерактивность заключается в срабатывании события ПриИзменении у элемента управления.
// Строка табличного поля или таблицы формы должна находиться в режиме редактирования,
// иначе никаких изменений данных не произойдет.
//
// Параметры:
//  ТабличноеПоле - ТабличноеПоле, ТаблицаФормы - внутри него строка редактируется;
//  Колонка      - КолонкаТабличногоПоля, ПолеФормы - в ее ячейку будем помещать значение;
//  Значение     - Произвольный - присваиваемое значение;
//  *ФормаИнициатор - Форма, УправляемаяФормы, *Неопределено - которая будет использована в качестве инициатора события;
//               если не указана, то будет создана временная форма-пустышка;
//  *ВосстанавитьТекущуюКолонку - Булево, *Истина;
//  *ВключитьРежимРедактирования - Булево, *Истина;
//  КонтролироватьТекущиеДанные - Булево, *Истина - если значение не установилось интерактивно, то установить его программно
//  ПутьКДаннымКолонки - Строка, *"" - имя колонки данных; используется при КонтролироватьТекущиеДанные
// Результат:
//   Булево - Истина, если значение отправлено в поле, иначе оно не прошло проверки по связям и параметрам выбора
//
Функция ИнтерактивноЗаписатьВКолонкуТабличногоПоляЛкс(ТабличноеПоле, Знач Колонка, Знач Значение, Знач ФормаИнициатор = Неопределено, Знач ВосстанавитьТекущуюКолонку = Истина,
	Знач ВключитьРежимРедактирования = Истина, Знач КонтролироватьТекущиеДанные = Истина, Знач ВыключитьРежимРедактирования = Ложь, Знач ПутьКДаннымКолонки = "", Знач МетаданныеВыбора = Неопределено) Экспорт
	
	#Если Сервер И Не Сервер Тогда
		ТабличноеПоле = Новый ТабличноеПоле;
	#КонецЕсли
	Если ТипЗнч(Колонка) = Тип("КолонкаТабличногоПоля") Тогда
		Если Ложь
			Или Не Колонка.Доступность
			Или Колонка.ТолькоПросмотр 
		Тогда
			Возврат Ложь;
		КонецЕсли; 
		ЭлементУправления = Колонка.ЭлементУправления;
		Если ТипЗнч(ЭлементУправления) <> Тип("ПолеВвода") Тогда
			ЭлементУправления = Неопределено;
		КонецЕсли;
	Иначе
		ЭлементУправления = Колонка;
		Если ТипЗнч(ЭлементУправления) <> Тип("ПолеФормы") Тогда
			ЭлементУправления = Неопределено;
		КонецЕсли;
	КонецЕсли; 
	Если ЭлементУправления <> Неопределено Тогда
		Если ВосстанавитьТекущуюКолонку Тогда
			СтараяТекущаяКолонка = ТабличноеПолеТекущаяКолонкаЛкс(ТабличноеПоле);
		КонецЕсли;
		ТабличноеПолеУстановитьТекущуюКолонкуЛкс(ТабличноеПоле, Колонка);
		Если ВключитьРежимРедактирования Тогда
			ТабличноеПоле.ИзменитьСтроку();
		КонецЕсли; 
		
		// Связи и параметры выбора
		Если Истина
			И ирОбщий.ЛиСсылкаНаОбъектБДЛкс(Значение, Ложь)
			И ЗначениеЗаполнено(Значение) 
		Тогда
			МетаданныеКолонки = Неопределено;
			Если ТипЗнч(ЭлементУправления) = Тип("ПолеВвода") Тогда
				ДанныеПоля = ирОбщий.ДанныеЭлементаФормыЛкс(ЭлементУправления);
				ХмлТип = XMLТипЗнч(ДанныеПоля);
				Если Истина
					И ХмлТип <> Неопределено
					И Найти(ХмлТип.ИмяТипа, "CatalogRef.") > 0
			    Тогда
					Если Ложь
						Или (Истина
							И ЗначениеЗаполнено(ЭлементУправления.ВыборПоВладельцу)
							И Значение.Владелец <> ЭлементУправления.ВыборПоВладельцу)
						Или (Истина
							И ЭлементУправления.ВыборГруппИЭлементов = ИспользованиеГруппИЭлементов.Элементы
							И Значение.ЭтоГруппа)
						Или (Истина
							И ЭлементУправления.ВыборГруппИЭлементов = ИспользованиеГруппИЭлементов.Группы
							И Не Значение.ЭтоГруппа)
					Тогда
						Возврат Ложь;
					КонецЕсли;
				КонецЕсли;
				Если МетаданныеВыбора <> Неопределено Тогда
					МетаданныеКолонки = ирОбщий.СвойствоСтруктурыЛкс(МетаданныеВыбора.Колонки, ПутьКДаннымКолонки); 
					ОбъектВладелец = МетаданныеВыбора.РеквизитыВладельца;
					СтруктураТЧ = Новый Структура("ТЧ", ТабличноеПоле.ТекущиеДанные);
				КонецЕсли;
			Иначе 
				МетаданныеКолонки = ЭлементУправления;
				ПутьКДаннымОбъекта = "";
				ОбъектВладелец = Неопределено;
				ирОбщий.ДанныеЭлементаФормыЛкс(ТабличноеПоле, ПутьКДаннымОбъекта, ОбъектВладелец); 
				Если СтрЧислоВхождений(ПутьКДаннымОбъекта, ".") = 1 Тогда
					СтруктураТЧ = Новый Структура(ирОбщий.ПоследнийФрагментЛкс(ПутьКДаннымОбъекта), ТабличноеПоле.ТекущиеДанные);
				Иначе
					ОбъектВладелец = ТабличноеПоле.ТекущиеДанные;
				КонецЕсли;
			КонецЕсли; 
			Если МетаданныеКолонки <> Неопределено Тогда
				СтруктураОтбора = СтруктураОтбораПоСвязямИПараметрамВыбораЛкс(МетаданныеКолонки, ОбъектВладелец, СтруктураТЧ);
				Для Каждого КлючИЗначение Из СтруктураОтбора Цикл
					ЗначениеРеквизита = Значение[КлючИЗначение.Ключ];
					Если Истина
						И ЗначениеРеквизита <> КлючИЗначение.Значение 
						И (Ложь
							Или ТипЗнч(КлючИЗначение.Значение) <> Тип("ФиксированныйМассив")
							Или КлючИЗначение.Значение.Найти(ЗначениеРеквизита) = Неопределено)
					Тогда
						Возврат Ложь;
					КонецЕсли;
				КонецЦикла;
			КонецЕсли;
		КонецЕсли;
		
		РезультатИнтерактивнойЗаписи = ИнтерактивноЗаписатьВПолеВводаЛкс(ЭлементУправления, Значение, ФормаИнициатор);
		//КонтролироватьТекущиеДанные = КонтролироватьТекущиеДанные И РезультатИнтерактивнойЗаписи; // Если раскомментировать, то перестанет работать редактирование ячейки по двойному клику https://www.hostedredmine.com/issues/948448
		Если ВосстанавитьТекущуюКолонку Тогда
			ТабличноеПолеУстановитьТекущуюКолонкуЛкс(ТабличноеПоле, СтараяТекущаяКолонка);                                                                                
		КонецЕсли;
		Если ВыключитьРежимРедактирования Тогда
			ТабличноеПоле.ЗакончитьРедактированиеСтроки(Ложь);
		КонецЕсли; 
	КонецЕсли; 
	Если КонтролироватьТекущиеДанные Тогда // На 8.3.8 значение в свойство строки почему то не попадает 
		Если Не ЗначениеЗаполнено(ПутьКДаннымКолонки) Тогда
			ПутьКДаннымКолонки = ирОбщий.ПутьКДаннымКолонкиТабличногоПоляЛкс(ТабличноеПоле, Колонка);
		КонецЕсли;
		Если ПутьКДаннымКолонки <> "" Тогда
			ДанныеСтроки = ДанныеСтрокиТабличногоПоляЛкс(ТабличноеПоле);
			Попытка
				ЗначениеЯчейки = ДанныеСтроки[ПутьКДаннымКолонки];
				ИмяДанныхПравильное = Истина;
			Исключение
				// В табличных полях компоновки
				ИмяДанныхПравильное = Ложь;
			КонецПопытки;
			Если ИмяДанныхПравильное И ТипЗнч(ДанныеСтроки) <> Тип("ЭлементОтбора") Тогда
				Если Значение <> ЗначениеЯчейки Тогда
					// Такое случается в некоторых состояниях формы (пока Открыта() = Ложь)
					// Также это срабатывает для неподдерживаемых типов в поле ввода
					ДанныеСтроки[ПутьКДаннымКолонки] = Значение;
				КонецЕсли; 
			КонецЕсли; 
		КонецЕсли; 
	КонецЕсли;
	Возврат Истина;

КонецФункции

Функция ИнтерактивноКонвертироватьМассивСтрокЛкс(Знач Массив, ОписаниеТипов = Неопределено) Экспорт 
	
	ЗагрузкаТабличныхДанных = ирОбщий.СоздатьОбъектПоИмениМетаданныхЛкс("Обработка.ирЗагрузкаТабличныхДанных");
	#Если Сервер И Не Сервер Тогда
		ЗагрузкаТабличныхДанных = Обработки.ирЗагрузкаТабличныхДанных.Создать();
	#КонецЕсли
	Форма = ЗагрузкаТабличныхДанных.ПолучитьФорму();
	ТаблицаЗначений = Новый ТаблицаЗначений;
	ТаблицаЗначений.Колонки.Добавить("Значение", ОписаниеТипов);
	Форма.ТаблицаЗначений = ТаблицаЗначений;
	ТабличныйДокумент = Новый ТабличныйДокумент;
	ТабличныйДокумент.Область(1, 1).Текст = "Значение";
	ТабличныйДокумент.Область(1, 1).Шрифт = Новый Шрифт(,, Истина);
	Для Счетчик = 1 По Массив.Количество() Цикл
		ТабличныйДокумент.Область(Счетчик + 1, 1).Текст = Массив[Счетчик - 1];
	КонецЦикла;
	Форма.ПараметрТабличныйДокумент = ТабличныйДокумент;
	Форма.РежимРедактора = Истина;
	РезультатКонвертации = Форма.ОткрытьМодально();
	Если РезультатКонвертации <> Неопределено Тогда
		Массив = Форма.ТаблицаЗначений.ВыгрузитьКолонку("Значение");
	КонецЕсли;
	Возврат Массив;

КонецФункции

Процедура ТабличноеПолеАктивироватьТекущуюСтрокуЕслиНеУстановленаЛкс(Знач ТабличноеПоле) Экспорт 
	
	#Если Сервер И Не Сервер Тогда
		ТабличноеПоле = Новый ТабличноеПоле;
	#КонецЕсли
	Если Истина
		И ТабличноеПоле.ТекущаяСтрока = Неопределено 
		И ТабличноеПоле.Значение.Количество() > 0
	Тогда 
		ТабличноеПоле.ТекущаяСтрока = ТабличноеПоле.Значение[0];
	КонецЕсли;

КонецПроцедуры

// Функция - Табличное поле сдвинуть выделенные строки лкс
//
// Параметры:
//  ТабличноеПоле	 - 	 - 
//  Смещение		 - Число - количество позиций на которые нужно переместить строки вперед (+) или назад (-)
// 
// Возвращаемое значение:
//   Булево - изменен ли порядок строк
//
Функция ТабличноеПолеСдвинутьВыделенныеСтрокиЛкс(Знач ТабличноеПоле, Знач Смещение) Экспорт 
	
	#Если Сервер И Не Сервер Тогда
		ТабличноеПоле = Новый ТабличноеПоле;
	#КонецЕсли
	Если Ложь
		Или ТабличноеПоле.ТолькоПросмотр 
		Или ТипЗнч(ТабличноеПоле.Значение) = Тип("ДеревоЗначений") 
	Тогда
		Возврат Ложь;
	КонецЕсли; 
	ПорядокИзменен = Ложь;
	ВыделенныеСтроки = ВыделенныеСтрокиТабличногоПоляЛкс(ТабличноеПоле);
	#Если Сервер И Не Сервер Тогда
		ВыделенныеСтроки = Новый Массив;
	#КонецЕсли
	Шаг = Смещение;
	Пока Смещение <> 0 Цикл
		БылиСдвиги = Ложь;
		Для Индекс = 0 По ВыделенныеСтроки.ВГраница() Цикл
			Если Смещение < 0 Тогда
				ВыделеннаяСтрока = ВыделенныеСтроки[Индекс];
				Шаг = -1;
			Иначе
				ВыделеннаяСтрока = ВыделенныеСтроки[ВыделенныеСтроки.ВГраница() - Индекс];
				Шаг = +1;
			КонецЕсли; 
			Позиция = ТабличноеПоле.Значение.Индекс(ВыделеннаяСтрока);
			Если Ложь
				Или (Истина
					И Смещение < 0
					И Позиция > 0 + Индекс)
				Или (Истина
					И Смещение > 0
					И Позиция > -1
					И Позиция < ТабличноеПоле.Значение.Количество() - 1 - Индекс)
			Тогда
				ТабличноеПоле.Значение.Сдвинуть(ВыделеннаяСтрока, Шаг);
				БылиСдвиги = Истина;
			КонецЕсли;
		КонецЦикла;
		Если Не БылиСдвиги Тогда
			Прервать;
		КонецЕсли;
		ПорядокИзменен = Истина;
		Смещение = Смещение - Шаг;
	КонецЦикла;
	Возврат ПорядокИзменен;

КонецФункции

Процедура ТабличноеПолеОбновитьТекстыПодваловЛкс(Знач ЭтаФорма, Знач ТабличноеПоле, Принудительно = Истина) Экспорт 
	#Если Сервер И Не Сервер Тогда
		ТабличноеПоле = Новый ТабличноеПоле;
	#КонецЕсли
	ОбщийТип = ирОбщий.ОбщийТипДанныхТабличногоПоляЛкс(ТабличноеПоле);
	Если ОбщийТип = Неопределено Тогда 
		Возврат;
	КонецЕсли; 
	КоличествоВыделенных = ТабличноеПоле.ВыделенныеСтроки.Количество();
	ДопСвойства = ДопСвойстваЭлементаФормыЛкс(ЭтаФорма, ТабличноеПоле);
	ТабличноеПоле.Подвал = Истина
		И ДопСвойства.ЗапретПодвала <> Истина
		И (Ложь
			Или ДопСвойства.КнопкаОтображенияПодвала <> Неопределено И ДопСвойства.КнопкаОтображенияПодвала.Пометка 
			Или КоличествоВыделенных > 1 И КоличествоВыделенных < 1000 // Для малого количества выделенных всегда показываем подвал
			);
	Если Не ТабличноеПоле.Подвал Тогда
		Возврат;
	КонецЕсли; 
	ЭтоКоллекцияСМетаданными = Ложь;
	Если ОбщийТип = "Список" Тогда
		ИменаВидимыхКолонок = Новый Массив;
		Для Каждого Колонка Из ТабличноеПоле.Колонки Цикл
			Если Колонка.Видимость И Колонка.Данные <> "" Тогда
				ИменаВидимыхКолонок.Добавить(Колонка.Данные);
			КонецЕсли;
		КонецЦикла;
		КоллекцияСтрок = ДанныеСтрокДинамическогоСпискаЛкс(ТабличноеПоле, ТабличноеПоле.ВыделенныеСтроки, ирОбщий.СтрСоединитьЛкс(ИменаВидимыхКолонок),,, ЭтаФорма, Истина); // Долго
		КолонкиКоллекции = КоллекцияСтрок.Колонки;
	Иначе
		КоллекцияСтрок = ТабличноеПоле.Значение;
		Если ТипЗнч(КоллекцияСтрок) = Тип("ДеревоЗначений") Тогда
			КоллекцияСтрок = КоллекцияСтрок.Строки;
		КонецЕсли;
		Если ОбщийТип = "ТабличнаяЧасть" Или ОбщийТип = "НаборЗаписей" Тогда
			КолонкиКоллекции = ТабличноеПоле.Значение.ВыгрузитьКолонки().Колонки;
			ЭтоКоллекцияСМетаданными = Истина;
		Иначе
			КолонкиКоллекции = ТабличноеПоле.Значение.Колонки;
		КонецЕсли;
	КонецЕсли;
	Попытка
		Если КоличествоВыделенных = КоллекцияСтрок.Количество() Тогда
			КоличествоВыделенных = 1; // Для ускорения
		КонецЕсли;
	Исключение
	КонецПопытки;
	Если ОбщийТип <> "Список" И КоличествоВыделенных > 1 Тогда
		ВыделенныеСтроки = ВыделенныеСтрокиТабличногоПоляЛкс(ТабличноеПоле, Ложь);
		КопияТаблицы = ТаблицаИлиДеревоЗначенийИзТаблицыФормыСКоллекциейЛкс(ТабличноеПоле, ВыделенныеСтроки,,,,, ЭтаФорма);
	Иначе
		ВыделенныеСтроки = Неопределено;
		КопияТаблицы = КоллекцияСтрок;
	КонецЕсли; 
	#Если Сервер И Не Сервер Тогда
		КопияТаблицы = Новый ТаблицаЗначений;
		КолонкиКоллекции = КопияТаблицы.Колонки;
	#КонецЕсли
	СимволСуммы = "Σ";
	Если Истина
		И Не Принудительно 
		И КоличествоВыделенных <= 1
		И Не ТабличноеПоле.ИзменятьСоставСтрок
		И ИнтерактивныеКолонкиТабличногоПоляЛкс(ТабличноеПоле).Количество() = 0
	Тогда
		Для Каждого Колонка Из ТабличноеПоле.Колонки Цикл
			Если Не Колонка.Видимость Тогда
				Продолжить;
			КонецЕсли;
			Если Лев(Колонка.ТекстПодвала, 1) = СимволСуммы Тогда
				Возврат;
			КонецЕсли;
		КонецЦикла;
	КонецЕсли; 
	ТабличноеПоле.ВертикальныеЛинии = Истина;
	//КопияТаблицы = ирОбщий.ТаблицаСКолонкамиБезТипаNullЛкс(КопияТаблицы); // Если у колонки составной тип, то Итог() не будет считать булевы значения
	КоличествоУжеВыведено = Ложь;
	Для Каждого Колонка Из ТабличноеПоле.Колонки Цикл
		Если Не Колонка.Видимость Тогда
			Продолжить;
		КонецЕсли; 
		ДанныеКолонки = Колонка.Данные;
		СуммаКолонки = ирОбщий.ИтогКолонкиТабличногоПоляЛкс(КопияТаблицы, ДанныеКолонки, КолонкиКоллекции);
		ТекстПодвала = "";
		Если СуммаКолонки = Неопределено Тогда
			Если Истина
				И Не КоличествоУжеВыведено 
				И (Ложь
					Или Колонка.Ширина > 5
					Или Колонка.ИзменениеРазмера = ИзменениеРазмераКолонки.Изменять)
			Тогда
				ТекстПодвала = "N" + КопияТаблицы.Количество();
				КоличествоУжеВыведено = Истина;
			КонецЕсли; 
			Колонка.ТекстПодвала = ТекстПодвала;
			Продолжить;
		КонецЕсли; 
		Если КоличествоВыделенных > 1 Тогда
			ТекстПодвала = "!";
		КонецЕсли; 
		ТекстПодвала = ТекстПодвала + СимволСуммы + СуммаКолонки;
		Колонка.ТекстПодвала = ТекстПодвала;
		Колонка.ГоризонтальноеПоложениеВПодвале = ГоризонтальноеПоложение.Право;
	КонецЦикла; 

КонецПроцедуры

Процедура ТабличноеПолеКнопкаОтображенияИтоговНажатиеЛкс(Знач ЭтаФорма, Знач ТабличноеПоле, Знач Кнопка) Экспорт 
	
	#Если Сервер И Не Сервер Тогда
		ТабличноеПоле = Новый ТабличноеПоле;
	#КонецЕсли
	Кнопка.Пометка = Не Кнопка.Пометка;
	ДопСвойства = ДопСвойстваЭлементаФормыЛкс(ЭтаФорма, ТабличноеПоле);
	ДопСвойства.КнопкаОтображенияПодвала = Кнопка;
	ТабличноеПолеОбновитьТекстыПодваловЛкс(ЭтаФорма, ТабличноеПоле);

КонецПроцедуры

// Проверяет колонку табличного поля на доступность для эмуляции интерактивного изменения.
//
// Параметры:
//  пКолонка     - КолонкаТабличногоПоля.
//
// Возвращаемое значение:
//  Истина - колонка интерактивно доступна;
//  Ложь   - иначе.
//
Функция ЛиВКолонкеДоступнаЭмуляцияИнтерактивногоИзмененияЛкс(КолонкаТабличногоПоля) Экспорт

	Если Истина
		И КолонкаТабличногоПоля <> Неопределено
		И КолонкаТабличногоПоля.Доступность
		И КолонкаТабличногоПоля.Видимость
		И Не КолонкаТабличногоПоля.ТолькоПросмотр
		И (Ложь
			Или (Истина
				И ТипЗнч(КолонкаТабличногоПоля) = Тип("ПолеФормы")
				И КолонкаТабличногоПоля.Вид = ВидПоляФормы.ПолеВвода)
			Или (Истина
				И ТипЗнч(КолонкаТабличногоПоля) = Тип("КолонкаТабличногоПоля")
				И (Ложь
					Или КолонкаТабличногоПоля.ДанныеФлажка <> ""
					Или (Истина
						И ТипЗнч(КолонкаТабличногоПоля.ЭлементУправления) = Тип("ПолеВвода")
						И КолонкаТабличногоПоля.ЭлементУправления.Доступность))))
	Тогда 
		Попытка
			Если КолонкаТабличногоПоля.ЭлементУправления.ТолькоПросмотр Тогда
				Возврат Ложь;
			КонецЕсли; 
		Исключение
		КонецПопытки;
		Возврат Истина;
	КонецЕсли;
	Возврат Ложь;

КонецФункции

// Копирует привязки между элементами форм.
//
// Параметры:
//  пФорма       - Форма - в которую копируем;
//  ЭлементПриемник - ЭлементУправления;
//  ЭлементИсточник - ЭлементУправления.
//
Процедура СкопироватьПривязкиЛкс(пФорма, ЭлементПриемник, ЭлементИсточник) Экспорт

	Перем ПервыйЭлемент, ГраницаПервогоЭлемента, ВторойЭлемент, ГраницаВторогоЭлемента;
	
	Границы = Новый Массив;
	Границы.Добавить(ГраницаЭлементаУправления.Верх);
	Границы.Добавить(ГраницаЭлементаУправления.Низ);
	Границы.Добавить(ГраницаЭлементаУправления.Лево);
	Границы.Добавить(ГраницаЭлементаУправления.Право);
	Для Каждого Граница Из Границы Цикл
		ЭлементИсточник.ПолучитьПривязку( Граница, ПервыйЭлемент, ГраницаПервогоЭлемента, ВторойЭлемент,
										ГраницаВторогоЭлемента);
		Если ПервыйЭлемент <> Неопределено Тогда 
			ПервыйЭлемент = пФорма.ЭлементыФормы.Найти(ПервыйЭлемент.Имя);
			Если ПервыйЭлемент = Неопределено Тогда 
				ПервыйЭлемент = пФорма.Панель;
			КонецЕсли;
		КонецЕсли;
		Если ВторойЭлемент <> Неопределено Тогда 
			ВторойЭлемент = пФорма.ЭлементыФормы.Найти(ВторойЭлемент.Имя);
			Если ВторойЭлемент = Неопределено Тогда 
				ВторойЭлемент = пФорма.Панель;
			КонецЕсли;
		КонецЕсли;				
		ЭлементПриемник.УстановитьПривязку(Граница, ПервыйЭлемент, ГраницаПервогоЭлемента, ВторойЭлемент,
										ГраницаВторогоЭлемента); 
	КонецЦикла;

КонецПроцедуры // СкопироватьПривязкиЛкс()

// Заполняет форму по ее макету. Используется для динамического добавления элементов
// в типовые формы, чтобы облегчить их обновление. Макет формы, если явно не указан,
// ищется среди форм объекта метаданных формы по имени "Лкс"+<ИмяФормы>+"Макет".
// Для измененных элементов в макете к имени следует добавлять через "_" суффиксы
// в соответствии с изменениями: "Привязка", "Размер", "Позиция", "Внутри" (для коллекций).
// Следует вызывать в обработчике ПередОткрытием формы.
//   Ограничения.
// 1. Без явного указания макета работает только для основной формы объекта.
// 2. Нельзя добавлять элементы в панели и поля табличного документа, т.к. у элемента нельзя
// определить родителя.
// 3. Нельзя, чтобы форма и макет имели разные размеры. Обрабатывается.
// 4. Нельзя добавлять и изменять элементы, привязанные косвенно к низу формы.
// 5. Иногда элементы, привязанные косвенно к правой границе формы неверно располагаются.
// 6. Нельзя, чтобы оригинальные имена измененных элементов включали "_". Обрабатывается.
//
// Параметры:
//  пФорма       - Форма - которую настраиваем;
//  *пМакет      - Форма - макет, по которому настраиваем.
//
Процедура НастроитьФормуПоМакетуЛкс(пФорма, пМакетФормы) Экспорт
	
	МакетФормы = пМакетФормы;
	СоответствиеПривязки = Новый Соответствие;
	Если Ложь
		Или пФорма.Высота <> МакетФормы.Высота 
		Или пФорма.Ширина <> МакетФормы.Ширина
	Тогда
		ирОбщий.СообщитьЛкс("Не соответствие размеров формы при заполнении по макету",
			 СтатусСообщения.Важное);
	КонецЕсли;
	//ЗаполнитьЗначенияСвойств(пФорма, МакетФормы, , "ДокументОбъект, Данные, ЭтотОбъект, Панель, ЭлементыФормы");
	//ЗаполнитьЗначенияСвойств(пФорма.Панель, МакетФормы.Панель, , "Данные");
	ЭлементыФормы = пФорма.ЭлементыФормы;
	Для Каждого ЭлементМакета Из МакетФормы.ЭлементыФормы Цикл
		ИмяЭлемента = ЭлементМакета.Имя;
		ЭлементФормы = ЭлементыФормы.Добавить(ТипЗнч(ЭлементМакета), ИмяЭлемента, Ложь, пФорма.Панель);
		Если ТипЗнч(ЭлементМакета) = Тип("КоманднаяПанель") Тогда
			ЗаполнитьЗначенияСвойств(ЭлементФормы, ЭлементМакета, , "Имя, Данные, Кнопки, ИсточникДействий");
			Если ЭлементМакета.ИсточникДействий = пМакетФормы Тогда
				ЭлементФормы.ИсточникДействий = пФорма;
			КонецЕсли;
		ИначеЕсли ТипЗнч(ЭлементМакета) = Тип("ТабличноеПоле") Тогда
			ЗаполнитьЗначенияСвойств(ЭлементФормы, ЭлементМакета, , "Имя, Данные, ТекущаяСтрока");
		Иначе
			ЗаполнитьЗначенияСвойств(ЭлементФормы, ЭлементМакета, , "Имя, Данные");
		КонецЕсли;
		СоответствиеПривязки.Вставить(ЭлементФормы, ЭлементМакета);
	КонецЦикла;
	
	// Установи новые привязки
	Для Каждого Привязка Из СоответствиеПривязки Цикл
		ЭлементФормы  = Привязка.Ключ;
		ЭлементМакета = Привязка.Значение;
		СкопироватьПривязкиЛкс(пФорма, ЭлементФормы, ЭлементМакета);
	КонецЦикла;
	
КонецПроцедуры // НастроитьФормуПоМакетуЛкс()

Процедура ДеревоКонсолиПроверкаПеретаскиванияЛкс(Элемент, ПараметрыПеретаскивания, СтандартнаяОбработка, Строка, Колонка, ИмяТипаСроки) Экспорт
	
	Если ТипЗнч(ПараметрыПеретаскивания.Значение) = Тип("Структура") Тогда
		ЗначениеПеретаскивания = ПараметрыПеретаскивания.Значение;
		Если ЗначениеПеретаскивания.Свойство("Тип") Тогда
			Если НРег(ЗначениеПеретаскивания.Тип) = Нрег(ИмяТипаСроки) Тогда
				ТекущийРодитель = Строка;
				Пока ТекущийРодитель <> Неопределено Цикл
					Если ТекущийРодитель = ЗначениеПеретаскивания.Значение Тогда
						ПараметрыПеретаскивания.ДопустимыеДействия = ДопустимыеДействияПеретаскивания.НеОбрабатывать;
						Возврат;
					КонецЕсли; 
					ТекущийРодитель = ТекущийРодитель.Родитель;
				КонецЦикла;
				СтандартнаяОбработка = Ложь;
				ПараметрыПеретаскивания.ДопустимыеДействия = ДопустимыеДействияПеретаскивания.Копирование;
			КонецЕсли; 
		КонецЕсли; 
	КонецЕсли; 
	
КонецПроцедуры

Процедура ДеревоКонсолиПеретаскиваниеЛкс(ЭтаФорма, Элемент, ПараметрыПеретаскивания, СтандартнаяОбработка, СтрокаПриемник, Колонка, ИмяТипаСроки, ИмяПоляНаименования = "Наименование") Экспорт
	
	#Если Сервер И Не Сервер Тогда
		Элемент = Новый ТабличноеПоле;
	#КонецЕсли
	Если ТипЗнч(ПараметрыПеретаскивания.Значение) = Тип("Структура") Тогда
		ЗначениеПеретаскивания = ПараметрыПеретаскивания.Значение;
		Если ЗначениеПеретаскивания.Свойство("Тип") Тогда
			Если НРег(ЗначениеПеретаскивания.Тип) = Нрег(ИмяТипаСроки) Тогда
				СтандартнаяОбработка = Ложь;
				Если СтрокаПриемник <> Неопределено Тогда
					РодительскаяСтрока = СтрокаПриемник;
				Иначе
					РодительскаяСтрока = Элемент.Значение;
				КонецЕсли; 
				НоваяСтрокаДерева = Неопределено;
				Элемент.ВыделенныеСтроки.Очистить();
				ВыделенныеСтроки = Новый Массив;
				Для Каждого СтрокаИсточника Из ЗначениеПеретаскивания.Значение Цикл
					НоваяСтрокаДерева = РодительскаяСтрока.Строки.Добавить();
					ирОбщий.СкопироватьСтрокиДереваЛкс(СтрокаИсточника, НоваяСтрокаДерева);
					Если Истина
						И СтрокаИсточника.Родитель = НоваяСтрокаДерева.Родитель 
						И ПараметрыПеретаскивания.Действие = ДействиеПеретаскивания.Перемещение
					Тогда
						//
					Иначе
						ДеревоКонсолиПриОкончанииРедактированияЛкс(НоваяСтрокаДерева, ИмяПоляНаименования);
					КонецЕсли; 
					Элемент.ТекущаяСтрока = НоваяСтрокаДерева;
					Если ПараметрыПеретаскивания.Действие = ДействиеПеретаскивания.Перемещение Тогда
						РодительСтроки = СтрокаИсточника.Родитель;
						Если РодительСтроки = Неопределено Тогда
							РодительСтроки = Элемент.Значение;
							Если СтрокаИсточника.Владелец() <> РодительСтроки Тогда
								// Строка другой формы. Не будем ее удалять
								РодительСтроки = Неопределено;
							КонецЕсли;
						КонецЕсли; 
						Если РодительСтроки <> Неопределено Тогда
							РодительСтроки.Строки.Удалить(СтрокаИсточника);
							СтрокаИсточника = Неопределено;
						КонецЕсли;
					КонецЕсли; 
					Если СтрокаИсточника <> Неопределено Тогда
						НоваяСтрокаДерева.ИД = Новый УникальныйИдентификатор;
					КонецЕсли;
					Если Элемент.ИзменяетДанные Тогда
						ЭтаФорма.Модифицированность = Истина;
					КонецЕсли; 
					ВыделенныеСтроки.Добавить(НоваяСтрокаДерева);
				КонецЦикла;
				Для Каждого ВыделеннаяСтрока Из ВыделенныеСтроки Цикл
					Элемент.ВыделенныеСтроки.Добавить(ВыделеннаяСтрока);
				КонецЦикла;
			КонецЕсли; 
		КонецЕсли; 
	КонецЕсли; 
	
КонецПроцедуры

Процедура ДеревоКонсолиПриОкончанииРедактированияЛкс(Знач СтрокаДерева, Знач ИмяПоляНаименования = "Наименование") Экспорт 
	
	РодительСтроки = ирОбщий.РодительСтрокиДереваЛкс(СтрокаДерева);
	СтрокаДерева[ИмяПоляНаименования] = ирОбщий.АвтоУникальноеИмяВКоллекцииЛкс(РодительСтроки.Строки, СтрокаДерева, ИмяПоляНаименования, Ложь);

КонецПроцедуры

Процедура ДеревоКонсолиНачалоПеретаскиванияЛкс(Элемент, ПараметрыПеретаскивания, Выполнение, ИмяТипаСроки) Экспорт
	
	Элемент.ТекущаяСтрока = Элемент.ТекущаяСтрока; // Для сохранения изменений в строке
	ЗначениеПеретаскивания = Новый Структура("Тип, Значение", ИмяТипаСроки, ВыделенныеСтрокиТабличногоПоляЛкс(Элемент));
	ПараметрыПеретаскивания.Значение = ЗначениеПеретаскивания;
	
КонецПроцедуры

Процедура ТабличноеПолеСпискаНастроекКомпоновкиПроверкаПеретаскиванияЛкс(Знач ЭтаФорма, Знач Элемент, Знач ПараметрыПеретаскивания, СтандартнаяОбработка, Знач Строка) Экспорт 
	
	Если Не СтандартнаяОбработка Тогда
		Возврат;
	КонецЕсли; 
	ЗначениеПеретаскивания = ПараметрыПеретаскивания.Значение;
	Если Строка <> Неопределено И ТипЗнч(ЗначениеПеретаскивания) = Тип("Массив") Тогда
		ЗначениеПеретаскивания = ЗначениеПеретаскивания[0];
		//Если Ложь
		//	Или ТипЗнч(ЗначениеПеретаскивания) = Тип("ЭлементОтбораКомпоновкиДанных") 
		//	Или ТипЗнч(ЗначениеПеретаскивания) = Тип("ГруппаЭлементовОтбораКомпоновкиДанных") 
		//	Или ТипЗнч(ЗначениеПеретаскивания) = Тип("ОтборКомпоновкиДанных") 
		//	Или ТипЗнч(ЗначениеПеретаскивания) = Тип("ВыбранноеПолеКомпоновкиДанных") 
		//	Или ТипЗнч(ЗначениеПеретаскивания) = Тип("ГруппаВыбранныхПолейКомпоновкиДанных") 
		//	Или ТипЗнч(ЗначениеПеретаскивания) = Тип("ЭлементПорядкаКомпоновкиДанных") 
		//	Или ТипЗнч(ЗначениеПеретаскивания) = Тип("ЗначениеПараметраНастроекКомпоновкиДанных") 
		//	Или ТипЗнч(ЗначениеПеретаскивания) = Тип("ЭлементУсловногоОформления") 
		//	Или ТипЗнч(ЗначениеПеретаскивания) = Тип("ПользовательскоеПолеВыборКомпоновкиДанных") 
		//	Или ТипЗнч(ЗначениеПеретаскивания) = Тип("ПользовательскоеПолеВыражениеКомпоновкиДанных") 
		//	Или ТипЗнч(ЗначениеПеретаскивания) = Тип("ГруппировкаТаблицыКомпоновкиДанных") 
		//	Или ТипЗнч(ЗначениеПеретаскивания) = Тип("ГруппировкаКомпоновкиДанных") 
		//	Или ТипЗнч(ЗначениеПеретаскивания) = Тип("ГруппировкаДиаграммыКомпоновкиДанных") 
		//	Или ТипЗнч(ЗначениеПеретаскивания) = Тип("ТаблицаКомпоновкиДанных") 
		//Тогда
			Элемент.ТекущаяСтрока = Строка;
			СтандартнаяОбработка = Ложь;
			ПараметрыПеретаскивания.ДопустимыеДействия = ДопустимыеДействияПеретаскивания.НеОбрабатывать;
		//КонецЕсли; 
	КонецЕсли;

КонецПроцедуры

// Для корректной активации при проверке перетаскивания
Процедура ОбновитьТабличноеПолеДереваПослеУстановкиДанныхЛкс(ЭтаФорма, Знач ТабличноеПолеДерева) Экспорт 
	
	#Если Сервер И Не Сервер Тогда
		ТабличноеПолеДерева = Новый ТабличноеПоле;
	#КонецЕсли
	ДанныеТабличногоПоля = ирОбщий.ДанныеЭлементаФормыЛкс(ТабличноеПолеДерева);
	Если ТипЗнч(ДанныеТабличногоПоля) = Тип("ДеревоЗначений") Тогда
		Если Истина
			И ТабличноеПолеДерева.ТекущаяСтрока = Неопределено 
			И ДанныеТабличногоПоля.Строки.Количество() > 0 
		Тогда
			ТабличноеПолеДерева.ТекущаяСтрока = ДанныеТабличногоПоля.Строки[0];
		КонецЕсли; 
		Если ТабличноеПолеДерева.НачальноеОтображениеДерева = НачальноеОтображениеДерева.РаскрыватьВсеУровни Тогда
			ТабличноеПолеДеревоЗначений_РазвернутьВсеСтрокиЛкс(ТабличноеПолеДерева);
		КонецЕсли; 
	Иначе
		Если ТабличноеПолеДерева.ТекущаяСтрока = Неопределено Тогда
			Попытка
				ТабличноеПолеДерева.ТекущаяСтрока = ДанныеТабличногоПоля;
			Исключение
			КонецПопытки; 
		КонецЕсли; 
		Если ТабличноеПолеДерева.НачальноеОтображениеДерева = НачальноеОтображениеДерева.РаскрыватьВсеУровни Тогда
			Попытка
				ТабличноеПолеДерева.Развернуть(ДанныеТабличногоПоля, Истина);
			Исключение
				// Например это ЗначенияПараметровДанныхКомпоновкиДанных
			КонецПопытки;
		КонецЕсли; 
	КонецЕсли; 

КонецПроцедуры

// Процедура - Изменить свернутость лкс
//
// Параметры:
//  ЭтаФорма				 - 	 - 
//  Видимость				 - 	 - 
//  ГлавныйЭлемент			 - 	 - какой элемент будет свернут
//  Разделитель				 - 	 - 
//  Панель					 - 	 - внутри какой панели находится сворачиваемый элемент
//  Направление				 - Строка - "лево", "право", "верх", "низ" - куда будет сдвинута граница
//  ПодчиненныйЭлемент		 - 	 - 
//  ПропорциональныйРазмер	 - 	 - 
//
Процедура ИзменитьСвернутостьЛкс(ЭтаФорма, Видимость, ГлавныйЭлемент, Разделитель, Панель, Направление, ПодчиненныйЭлемент = Неопределено,
	ПропорциональныйРазмер = Истина) Экспорт 
	
	//Если Не ЭтаФорма.Открыта() Тогда
	//	// Антибаг платформы. Иначе после закрытия и затем открытия привязки могут сломаться
	//	ирОбщий.СообщитьЛкс(ирОбщий.СтрШаблонИменЛкс("Изменение свернутости панели вызвано для закрытой формы %1",, ЭтаФорма.Заголовок));
	//	Возврат;
	//КонецЕсли; 
	Если Разделитель = Неопределено Тогда
		Разделитель = ГлавныйЭлемент;
	КонецЕсли;
	Если ТипЗнч(Разделитель) = Тип("Разделитель") Тогда
		Если Разделитель.Ориентация = Ориентация.Авто Тогда
			// возможно это касается только свертки вправо
			ирОбщий.СообщитьЛкс(ирОбщий.СтрШаблонИменЛкс("Корректная работа свертки с разделителем %1 с ориентацией ""Авто"" не гарантируется из-за ошибки платформы",, Разделитель.Имя), СтатусСообщения.Внимание);
		КонецЕсли; 
	КонецЕсли; 
	//ПервыйЭлемент = 0;
	//ГраницаПервогоЭлемента = 0;
	//ВторойЭлемент = 0;
	//ГраницаВторогоЭлемента = 0;
	Если ирОбщий.СтрокиРавныЛкс(Направление, "лево") Тогда
		Если Видимость Тогда
			// откроем 
			Если ПодчиненныйЭлемент <> Неопределено Тогда
				ПодчиненныйЭлемент.УстановитьПривязку(ГраницаЭлементаУправления.Лево, Разделитель, ГраницаЭлементаУправления.Право);
			КонецЕсли;
			Разделитель.Свертка = РежимСверткиЭлементаУправления.Нет;
			Если Разделитель <> ГлавныйЭлемент Тогда
				ГлавныйЭлемент.Свертка = РежимСверткиЭлементаУправления.Нет;
				Разделитель.УстановитьПривязку(ГраницаЭлементаУправления.Лево, Разделитель, ГраницаЭлементаУправления.Право);
				Если ПропорциональныйРазмер Тогда
					Разделитель.УстановитьПривязку(ГраницаЭлементаУправления.Право, Панель, ГраницаЭлементаУправления.Лево, Панель,
					ГраницаЭлементаУправления.Право);
				Иначе
					Разделитель.УстановитьПривязку(ГраницаЭлементаУправления.Право, Панель, ГраницаЭлементаУправления.Право);
				КонецЕсли;	
				ГлавныйЭлемент.УстановитьПривязку(ГраницаЭлементаУправления.Право, Разделитель, ГраницаЭлементаУправления.Лево);
			КонецЕсли;
			//Разделитель.Ширина = ШиринаРазделителя;
		Иначе      
			// скроем 
			Если Разделитель <> ГлавныйЭлемент Тогда
				ГлавныйЭлемент.УстановитьПривязку(ГраницаЭлементаУправления.Право);
				Разделитель.УстановитьПривязку(ГраницаЭлементаУправления.Право);
				Разделитель.УстановитьПривязку(ГраницаЭлементаУправления.Лево, ГлавныйЭлемент, ГраницаЭлементаУправления.Право);
				ГлавныйЭлемент.Свертка = РежимСверткиЭлементаУправления.Лево;
			КонецЕсли;
			Разделитель.Свертка    = РежимСверткиЭлементаУправления.Лево;
			Если ПодчиненныйЭлемент <> Неопределено Тогда
				ПодчиненныйЭлемент.УстановитьПривязку(ГраницаЭлементаУправления.Лево, ГлавныйЭлемент, ГраницаЭлементаУправления.Право);
			КонецЕсли;
		КонецЕсли;
		
	ИначеЕсли ирОбщий.СтрокиРавныЛкс(Направление, "право") Тогда
		Если Видимость Тогда
			// откроем
			Если ПодчиненныйЭлемент <> Неопределено Тогда
				ПодчиненныйЭлемент.УстановитьПривязку(ГраницаЭлементаУправления.Право, Разделитель, ГраницаЭлементаУправления.Лево);
			КонецЕсли;
			Разделитель.Свертка = РежимСверткиЭлементаУправления.Нет;
			Если Разделитель <> ГлавныйЭлемент Тогда
				ГлавныйЭлемент.Свертка = РежимСверткиЭлементаУправления.Нет;
				Если ПропорциональныйРазмер Тогда
					Разделитель.УстановитьПривязку(ГраницаЭлементаУправления.Право, Панель, ГраницаЭлементаУправления.Лево,  Панель,
					ГраницаЭлементаУправления.Право);
				Иначе
					Разделитель.УстановитьПривязку(ГраницаЭлементаУправления.Право, Панель, ГраницаЭлементаУправления.Право);
				КонецЕсли;
				Разделитель.УстановитьПривязку(ГраницаЭлементаУправления.Лево, Разделитель, ГраницаЭлементаУправления.Право);
				ГлавныйЭлемент.УстановитьПривязку(ГраницаЭлементаУправления.Лево, Разделитель, ГраницаЭлементаУправления.Право);
				//Разделитель.Ширина = ШиринаРазделителя;
			КонецЕсли;
		Иначе 
			// Скроем 
			Если Разделитель <> ГлавныйЭлемент Тогда
				ГлавныйЭлемент.УстановитьПривязку(ГраницаЭлементаУправления.Лево);
				Разделитель.УстановитьПривязку(ГраницаЭлементаУправления.Лево);
				Разделитель.УстановитьПривязку(ГраницаЭлементаУправления.Право, ГлавныйЭлемент, ГраницаЭлементаУправления.Лево);
				ГлавныйЭлемент.Свертка = РежимСверткиЭлементаУправления.Право;
			КонецЕсли;
			Разделитель.Свертка    = РежимСверткиЭлементаУправления.Право;
			Если ПодчиненныйЭлемент <> Неопределено Тогда
				ПодчиненныйЭлемент.УстановитьПривязку(ГраницаЭлементаУправления.Право, ГлавныйЭлемент, ГраницаЭлементаУправления.Лево);
			КонецЕсли;
		КонецЕсли;      
		
	ИначеЕсли ирОбщий.СтрокиРавныЛкс(Направление, "низ") Тогда
		Если Видимость Тогда
			// Откроем
			Если ПодчиненныйЭлемент <> Неопределено Тогда
				ПодчиненныйЭлемент.УстановитьПривязку(ГраницаЭлементаУправления.Верх, Разделитель, ГраницаЭлементаУправления.Низ);
			КонецЕсли;
			Разделитель.Свертка    = РежимСверткиЭлементаУправления.Нет;
			Если Разделитель <> ГлавныйЭлемент Тогда
				ГлавныйЭлемент.Свертка = РежимСверткиЭлементаУправления.Нет;
				Разделитель.УстановитьПривязку(ГраницаЭлементаУправления.Верх, Разделитель, ГраницаЭлементаУправления.Низ);
				Если ПропорциональныйРазмер Тогда
					Разделитель.УстановитьПривязку(ГраницаЭлементаУправления.Низ, Панель, ГраницаЭлементаУправления.Верх, Панель,
					ГраницаЭлементаУправления.Низ);
				Иначе
					Разделитель.УстановитьПривязку(ГраницаЭлементаУправления.Низ, Панель, ГраницаЭлементаУправления.Низ);
				КонецЕсли;
				ГлавныйЭлемент.УстановитьПривязку(ГраницаЭлементаУправления.Верх, Разделитель, ГраницаЭлементаУправления.Низ);
			КонецЕсли;
			//Разделитель.Высота = ШиринаРазделителя;
		Иначе // Скроем 
			Если Разделитель <> ГлавныйЭлемент Тогда
				Разделитель.УстановитьПривязку(ГраницаЭлементаУправления.Верх);
				ГлавныйЭлемент.УстановитьПривязку(ГраницаЭлементаУправления.Верх);
				Разделитель.УстановитьПривязку(ГраницаЭлементаУправления.Низ, ГлавныйЭлемент, ГраницаЭлементаУправления.Верх);
				ГлавныйЭлемент.Свертка = РежимСверткиЭлементаУправления.Низ;            
			КонецЕсли;
			Разделитель.Свертка    = РежимСверткиЭлементаУправления.Низ;            
			Если ПодчиненныйЭлемент <> Неопределено Тогда
				ПодчиненныйЭлемент.УстановитьПривязку(ГраницаЭлементаУправления.Низ, ГлавныйЭлемент, ГраницаЭлементаУправления.Верх);
			КонецЕсли;
		КонецЕсли;
		
	ИначеЕсли ирОбщий.СтрокиРавныЛкс(Направление, "верх") Тогда
		Если Видимость Тогда
			// Откроем
			Если ПодчиненныйЭлемент <> Неопределено Тогда
				ПодчиненныйЭлемент.УстановитьПривязку(ГраницаЭлементаУправления.Низ, Разделитель, ГраницаЭлементаУправления.Верх);
			КонецЕсли;
			Разделитель.Свертка    = РежимСверткиЭлементаУправления.Нет;
			Если Разделитель <> ГлавныйЭлемент Тогда
				ГлавныйЭлемент.Свертка = РежимСверткиЭлементаУправления.Нет;
				Разделитель.УстановитьПривязку(ГраницаЭлементаУправления.Верх, Разделитель, ГраницаЭлементаУправления.Низ);
				Если ПропорциональныйРазмер Тогда
					Разделитель.УстановитьПривязку(ГраницаЭлементаУправления.Низ, Панель, ГраницаЭлементаУправления.Верх, Панель,
					ГраницаЭлементаУправления.Низ);
				Иначе
					Разделитель.УстановитьПривязку(ГраницаЭлементаУправления.Низ, Панель, ГраницаЭлементаУправления.Низ);
				КонецЕсли;
				ГлавныйЭлемент.УстановитьПривязку(ГраницаЭлементаУправления.Низ, Разделитель, ГраницаЭлементаУправления.Верх);
				//Разделитель.Высота = ШиринаРазделителя;
			КонецЕсли;
		Иначе // Скроем 
			Если Разделитель <> ГлавныйЭлемент Тогда
				Разделитель.УстановитьПривязку(ГраницаЭлементаУправления.Низ);
				ГлавныйЭлемент.УстановитьПривязку(ГраницаЭлементаУправления.Низ);
				Разделитель.УстановитьПривязку(ГраницаЭлементаУправления.Верх, ГлавныйЭлемент, ГраницаЭлементаУправления.Низ);
				ГлавныйЭлемент.Свертка = РежимСверткиЭлементаУправления.Верх;            
			КонецЕсли;
			Разделитель.Свертка    = РежимСверткиЭлементаУправления.Верх;            
			Если ПодчиненныйЭлемент <> Неопределено Тогда
				ПодчиненныйЭлемент.УстановитьПривязку(ГраницаЭлементаУправления.Верх, ГлавныйЭлемент, ГраницаЭлементаУправления.Низ);
			КонецЕсли;
		КонецЕсли;
		
	КонецЕсли;	
КонецПроцедуры

// <Описание процедуры>
//
// Параметры:
//  Ссылка       - Ссылка, КлючЗаписи, КонстантаМенеджер;
//  ПолноеИмя    - Строка - полное имя метаданных для константы.
//
Процедура ОткрытьСсылкуИзРезультатаПоискаСсылокЛкс(Ссылка, ПолноеИмя = "") Экспорт 

	Если ирОбщий.ЛиКлючЗаписиРегистраЛкс(Ссылка) Тогда 
		ОбъектМетаданных = Метаданные.НайтиПоТипу(ТипЗнч(Ссылка));
		ПолноеИмя = ОбъектМетаданных.ПолноеИмя();
		ФормаСписка = ПолучитьФормуСпискаЛкс(ОбъектМетаданных.ПолноеИмя(),,,,,, Ссылка);
		ФормаСписка.Открыть();
	ИначеЕсли ирОбщий.ЛиКорневойТипКонстантыЛкс(ирОбщий.ПервыйФрагментЛкс(ПолноеИмя)) Тогда
		ОткрытьКонстантуВСпискеЛкс(ирОбщий.ПоследнийФрагментЛкс(ПолноеИмя));
	Иначе
		ОткрытьЗначениеЛкс(Ссылка);
	КонецЕсли;

КонецПроцедуры

Процедура ОткрытьКонстантуВСпискеЛкс(ИмяКонстанты) Экспорт
	
	ФормаСписка = ПолучитьФормуЛкс("Обработка.ирРедакторКонстант.Форма",,, ИмяКонстанты);
	ФормаСписка.НачальноеЗначениеВыбора = ИмяКонстанты;
	ФормаСписка.Открыть();
	
КонецПроцедуры

Функция ПромежуточноеОбновлениеСтроковогоЗначенияПоляВводаЛкс(ЭтаФорма, Знач Элемент, Знач Текст = Неопределено, Знач ВыделитьТекстДоКонца = Ложь) Экспорт
	
	НачалоКолонки = 0; НачалоСтроки = 0; КонецКолонки = 0; КонецСтроки = 0;
	Элемент.ПолучитьГраницыВыделения(НачалоСтроки, НачалоКолонки, КонецСтроки, КонецКолонки);
	Если Текст = Неопределено Тогда
		Текст = Элемент.Значение;
	КонецЕсли;
	Если Истина
		И Не ВыделитьТекстДоКонца
		И Вычислить("ЭтаФорма." + СтрЗаменить(Элемент.Данные, "." + ирОбщий.ПеревестиСтроку("Отбор") + ".", "." + ирОбщий.ПеревестиСтроку("ОтборСтрок") + ".")) = Текст 
	Тогда
		// Блокируем нежелательный повторный вызов события АвтоподборТекста, который возникает в некоторых случаях
		Возврат Ложь;
	КонецЕсли;
	Элемент.Значение = Текст; // Даже при совпадающих значения тут происходит неявная установка значения в связанные данные формы
	//ИнтерактивноЗаписатьВПолеВводаЛкс(Элемент, Текст); // Так делать нельзя, т.к. будет засоряться история последних введенных строк
	Если Текст = "" Тогда 
		Возврат Истина;
	КонецЕсли; 
	// Этот блок вызывает нежелательное повторный вызов события АвтоподборТекста, но он необходим, чтобы событие ПриИзменении сработало при уходе фокуса
	Элемент.УстановитьГраницыВыделения(1, СтрДлина(Текст) + 1);
	Элемент.ВыделенныйТекст = Элемент.ВыделенныйТекст;

	Если ВыделитьТекстДоКонца Тогда
		//Элемент.УстановитьГраницыВыделения(СтрДлина(Текст) + 1, СтрДлина(Текст) + 1); // так будет ошибка, ставить справа от последнего символа можно только 4-мя параметрами
		Элемент.УстановитьГраницыВыделения(НачалоСтроки, СтрДлина(Текст) + 1, КонецСтроки, СтрДлина(Текст) + 1);
	Иначе
		Элемент.УстановитьГраницыВыделения(НачалоСтроки, НачалоКолонки, КонецСтроки, КонецКолонки);
	КонецЕсли; 
	Возврат Истина;
	
КонецФункции

Функция ПрочитатьЗначениеИзФайлаСКонтролемПотерьЛкс(ПолноеИмяФайла) Экспорт
	
	ФайлЗначения = Новый Файл(ПолноеИмяФайла);
	ПолученноеЗначение = Неопределено;
	Если ФайлЗначения.Существует() Тогда 
		Текст = Новый ТекстовыйДокумент;
		Текст.Прочитать(ПолноеИмяФайла);
		Текст = Текст.ПолучитьТекст();
		Попытка
			ПолученноеЗначение = ирОбщий.ЗначениеИзСтрокиВнутрЛкс(Текст);
		Исключение
			ирОбщий.СообщитьЛкс("Ошибка чтения из файла: " + ОписаниеОшибки());
		КонецПопытки;
	КонецЕсли; 
	Если ПолученноеЗначение = Неопределено Тогда
		Возврат ПолученноеЗначение;
	КонецЕсли; 
	СравнениеФайлов = Новый СравнениеФайлов;
	ИмяВременногоФайла = ПолучитьИмяВременногоФайла();
	Если Не ПроверитьСериализациюXMLПередВызовомЗначениеВФайлЛкс(ПолученноеЗначение) Тогда
		//ирОбщий.СообщитьЛкс("Не удалось сериализовать считанные из файла данные: " + ОписаниеОшибки(), СтатусСообщения.Внимание);
		Возврат ПолученноеЗначение;
	КонецЕсли; 
	Попытка
		ЗначениеВФайл(ИмяВременногоФайла, ПолученноеЗначение);
	Исключение
		Возврат ПолученноеЗначение;
	КонецПопытки;
	СравнениеФайлов.ПервыйФайл = ПолноеИмяФайла;
	СравнениеФайлов.ВторойФайл = ИмяВременногоФайла;
	СравнениеФайлов.СпособСравнения = СпособСравненияФайлов.Двоичное;
	Если Не СравнениеФайлов.Сравнить() Тогда 
		//СравнениеФайлов.СпособСравнения = СпособСравненияФайлов.ТекстовыйДокумент;
		//СравнениеФайлов.ПоказатьРазличия(); // Для отладки
		ирОбщий.СообщитьЛкс("При чтении из файла вероятно была потеряна часть информации", СтатусСообщения.Внимание);
	КонецЕсли; 
	УдалитьФайлы(ИмяВременногоФайла);
	Возврат ПолученноеЗначение;
	
КонецФункции

Функция ПроверитьСериализациюXMLПередВызовомЗначениеВФайлЛкс(Знач ПолученноеЗначение) Экспорт 
	
	Если ирКэш.НомерВерсииПлатформыЛкс() >= 803012 Тогда
		СериализацияXMLУспешна = Истина;
	Иначе
		СериализацияXMLУспешна = Ложь;
		Попытка
			// Антибаг платформы https://bugboard.v8.1c.ru/error/000035977.html 
			// ЗначениеВФайл на некоторых ошибках вызывает безусловное завершение работы http://devtool1c.ucoz.ru/forum/2-746-1
			// http://devtool1c.ucoz.ru/forum/2-752-1
			// Выполняется сильно дольше чем ЗначениеВФайл!
			ирОбщий.ОбъектВСтрокуXMLЛкс(ПолученноеЗначение);
			СериализацияXMLУспешна = Истина;
		Исключение
			// Может быть  ошибка - Отсутствует отображение для типа 'ОбходРезультатаЗапроса'. http://devtool1c.ucoz.ru/forum/2-756-1
		КонецПопытки;
	КонецЕсли; 
	Возврат СериализацияXMLУспешна;

КонецФункции

Процедура УстановитьАвтоматическоеРаскрытиеУзловДереваЛкс(Знач ТабличноеПолеДерева, Порог = 30) Экспорт 
	
	Дерево = ТабличноеПолеДерева.Значение;
	#Если Сервер И Не Сервер Тогда
		Дерево = Новый ДеревоЗначений;
	#КонецЕсли
	ДеревоЗначенийСвернутьРазвернутьЛкс(ТабличноеПолеДерева, ирОбщий.ВсеСтрокиДереваЗначенийЛкс(Дерево).Количество() > Порог);
	Если Дерево.Строки.Количество() = 1 Тогда
		ТабличноеПолеДерева.Развернуть(Дерево.Строки[0]);
	КонецЕсли; 

КонецПроцедуры

Функция БазовыйФайлРедактораJSONЛкс() экспорт
	Возврат ирКэш.Получить().БазовыйФайлРедактораJSON();
КонецФункции

Процедура РедакторJSON_ИнициироватьЛкс(РедакторJSON) Экспорт 
	РедакторJSON.menu.style.backgroundColor = "#d0d0d0";
КонецПроцедуры

Процедура ПереключитьРежимДереваРедактораJSONЛкс(РедакторJSON, РежимДерева) Экспорт 
	Если РежимДерева Тогда
		РедакторJSON.setMode("tree");
	Иначе
		РедакторJSON.setMode("code");
	КонецЕсли; 
	РедакторJSON_ИнициироватьЛкс(РедакторJSON);
КонецПроцедуры

Процедура ПоказатьНеуникальныеСтрокиТабличногоПоляЛкс(Знач ТабличноеПоле, Знач СтрокаКлюча = "") Экспорт 
	
	НеуникальныеКлючи = ирОбщий.НеуникальныеКлючиТаблицыЛкс(ТабличноеПоле.Значение, СтрокаКлюча);
	ТекстСообщения = "Найдено " + НеуникальныеКлючи.Количество() + " неуникальных ключей строк";
	Если НеуникальныеКлючи.Количество() > 0 Тогда
		ВыделитьСтрокиТабличногоПоляПоКлючуЛкс(ТабличноеПоле, НеуникальныеКлючи[0], СтрокаКлюча);
		ТекстСообщения = ТекстСообщения + ". Выделены строки первого ключа";
		//ЭтаФорма.ТекущийЭлемент = ТабличноеПоле;
	КонецЕсли;
	ирОбщий.СообщитьЛкс(ТекстСообщения);

КонецПроцедуры
	
Процедура ОтладитьОтложенныйОбъектЛкс(Знач СсылкаИлиИмяФайла = Неопределено, УдалитьОбъектПослеУспешногоОткрытия = Ложь) Экспорт
	
	Если ирОбщий.ПроверитьПлатформаНеWindowsЛкс(,, Истина) Тогда 
		Возврат;
	КонецЕсли; 
	СтруктураПараметров = Неопределено;
	ирПлатформа = ирКэш.Получить();
	#Если Сервер И Не Сервер Тогда
	    Ссылка = Справочники.ирОбъектыДляОтладки.ПустаяСсылка();
		ирПлатформа = Обработки.ирПлатформа.Создать();
	#КонецЕсли
	Если СсылкаИлиИмяФайла = Неопределено Тогда
		ВычислительРегулярныхВыражений = ирПлатформа.RegExp;
		ВычислительРегулярныхВыражений.Pattern = "Объект ""([^""]+)""|Файл ""([^""]+)""|Пользователь ""([^""]+)""";
		СсылкаИлиИмяФайла = ТекстИзБуфераОбменаОСЛкс();
		Результат = ВычислительРегулярныхВыражений.НайтиВхождения(СсылкаИлиИмяФайла);
		ЕстьСправочник = Метаданные.Справочники.Найти("ирОбъектыДляОтладки") <> Неопределено;
		//Если Не ВвестиСтроку(СсылкаИлиИмяФайла, "Введите результат сохранения объекта") Тогда
		ФормаВвода = ирПлатформа.ПолучитьФорму("ОткрытьОбъектДляОтладки");
		Если Результат.Количество() > 0 Тогда
			ФормаВвода.Текст = СсылкаИлиИмяФайла;
		КонецЕсли; 
		СсылкаИлиИмяФайла = ФормаВвода.ОткрытьМодально();
		Если Не ЗначениеЗаполнено(СсылкаИлиИмяФайла) Тогда
			Если ЕстьСправочник Тогда
				СсылкаИлиИмяФайла = ВыбратьСсылкуЛкс(Метаданные.Справочники.ирОбъектыДляОтладки,, Ложь);
			Иначе
				СсылкаИлиИмяФайла = ВыбратьФайлОбъектаДляОтладкиЛкс();
			КонецЕсли;
		КонецЕсли;
		Если Не ЗначениеЗаполнено(СсылкаИлиИмяФайла) Тогда
			Возврат;
		КонецЕсли;
		Если ТипЗнч(СсылкаИлиИмяФайла) = Тип("Строка") Тогда
			Результат = ВычислительРегулярныхВыражений.НайтиВхождения(СсылкаИлиИмяФайла);
			Если Результат.Количество() = 0 Тогда
				ирОбщий.СообщитьЛкс("Введен некорректный результат сохранения объекта для отладки");
				Возврат;
			КонецЕсли; 
			Если Результат[0].SubMatches(0) <> Неопределено Тогда 
				Если ЕстьСправочник Тогда
					ВычислительРегулярныхВыражений.Pattern = "\b(" + ирПлатформа.шGUID + ")\b";
					Результат = ВычислительРегулярныхВыражений.НайтиВхождения(СсылкаИлиИмяФайла);
					Если Результат.Количество() > 0 Тогда
						СсылкаИлиИмяФайла = Результат[0].Value;
					Иначе
						СсылкаИлиИмяФайла = Неопределено;
					КонецЕсли; 
				Иначе
					СсылкаИлиИмяФайла = Неопределено;
				КонецЕсли; 
				Если СсылкаИлиИмяФайла = Неопределено Тогда 
					ирОбщий.СообщитьЛкс("Введен некорректный результат сохранения объекта для отладки");
					Возврат;
				КонецЕсли; 
				СсылкаИлиИмяФайла = Справочники.ирОбъектыДляОтладки.ПолучитьСсылку(Новый УникальныйИдентификатор(СсылкаИлиИмяФайла));
				Если Не ЗначениеЗаполнено(СсылкаИлиИмяФайла) Тогда
					ирОбщий.СообщитьЛкс("Объект для отладки не найден в справочнике");
					Возврат;
				КонецЕсли; 
			ИначеЕсли Результат[0].SubMatches(1) <> Неопределено Тогда 
				СсылкаИлиИмяФайла = Результат[0].SubMatches(1);
				Если ЕстьСправочник Тогда
					// Перекладываем из файла в новый элемент справочника
					ФайлОбъектаДляОтладки = Новый Файл(СсылкаИлиИмяФайла);
					Попытка
						ОбъектДляОтладки = ЗначениеИзФайла(ФайлОбъектаДляОтладки.ПолноеИмя);
					Исключение
						ОбъектДляОтладки = ирОбщий.ОбъектИзСтрокиXMLЛкс(ФайлОбъектаДляОтладки);
					КонецПопытки;
					РезультатОтложения = ирОбщий.ОтложитьУпакованныйОбъектДляОтладкиЛкс(ОбъектДляОтладки, СсылкаИлиИмяФайла);
					ирОбщий.СообщитьЛкс(РезультатОтложения);
					УдалитьФайлы(ФайлОбъектаДляОтладки.ПолноеИмя);
				КонецЕсли; 
			ИначеЕсли Результат[0].SubMatches(2) <> Неопределено Тогда 
				ИмяПользователя = Результат[0].SubMatches(2);
				СтруктураПараметров = ХранилищеОбщихНастроек.Загрузить(ирКэш.ИмяПродукта(), ирОбщий.ИмяНастройкиХраненияОбъектаОтложеннойОтладкиЛкс(),, ИмяПользователя);
				Если СтруктураПараметров = Неопределено Тогда
					ирОбщий.СообщитьЛкс(ирОбщий.СтрШаблонИменЛкс("Объект для отладки не найден в общих настройках пользователя %1",, ИмяПользователя));
					Возврат;
				КонецЕсли; 
			КонецЕсли; 
		КонецЕсли; 
	КонецЕсли; 
	Если СтруктураПараметров = Неопределено Тогда
		//Если ТипЗнч(СсылкаИлиИмяФайла) = Тип("Строка") Тогда
		//	СтрокаРезультата = ПолучитьИзВременногоХранилища(СсылкаИлиИмяФайла);
		//	Если СтрокаРезультата = Неопределено Тогда
		//		ирОбщий.СообщитьЛкс("Временное хранилище пусто. Вероятно отлаживаемый сеанс завершился.");
		//		Возврат;
		//	КонецЕсли; 
		ЧтениеXML = Новый ЧтениеXML;
		Если ТипЗнч(СсылкаИлиИмяФайла) = Тип("Строка") Тогда
			Попытка
				СтруктураПараметров = ЗначениеИзФайла(СсылкаИлиИмяФайла);
			Исключение
				ЧтениеXML.ОткрытьФайл(СсылкаИлиИмяФайла);
			КонецПопытки;
		ИначеЕсли ирОбщий.ЛиСсылкаНаОбъектБДЛкс(СсылкаИлиИмяФайла) Тогда 
			Запрос = Новый Запрос;
			Запрос.Текст = "
			|ВЫБРАТЬ
			|	ирОбъектыДляОтладки.XML
			|ИЗ
			|	Справочник.ирОбъектыДляОтладки КАК ирОбъектыДляОтладки
			|ГДЕ
			|	ирОбъектыДляОтладки.Ссылка = &Ссылка
			|";
			Запрос.УстановитьПараметр("Ссылка", СсылкаИлиИмяФайла);
			ТаблицаРезультата = Запрос.Выполнить().Выгрузить();
			Если ТаблицаРезультата.Количество() = 0 Тогда 
				ирОбщий.СообщитьЛкс("Объект для отладки не найден в справочнике. Вероятно он был удален.");
				Возврат;
			КонецЕсли; 
			СтрокаРезультата = ТаблицаРезультата[0]; 
			СтрокаРезультата = СтрокаРезультата.XML;
			Попытка
				СтруктураПараметров = ЗначениеИзСтрокиВнутр(СтрокаРезультата);
			Исключение
				ЧтениеXML.УстановитьСтроку(СтрокаРезультата);
			КонецПопытки;
		КонецЕсли;
		Если СтруктураПараметров = Неопределено Тогда
			Попытка
				СтруктураПараметров = СериализаторXDTO.ПрочитатьXML(ЧтениеXML);
			Исключение
				ОписаниеОшибки = ОписаниеОшибки();
				ирОбщий.СообщитьЛкс("Некорректный объект для отладки: " + ОписаниеОшибки, СтатусСообщения.Внимание);
				Возврат;
			КонецПопытки; 
		КонецЕсли;
	КонецЕсли; 
	ОтладитьОбъектПоСтруктуреЛкс(СтруктураПараметров);
	Если УдалитьОбъектПослеУспешногоОткрытия Тогда
		Если ТипЗнч(СсылкаИлиИмяФайла) = Тип("Строка") Тогда
			УдалитьФайлы(СсылкаИлиИмяФайла);
		Иначе
			УдалениеОбъекта = Новый УдалениеОбъекта(СсылкаИлиИмяФайла);
			УдалениеОбъекта.ОбменДанными.Загрузка = Истина;
			УдалениеОбъекта.Записать();
		КонецЕсли; 
	КонецЕсли; 

КонецПроцедуры

Функция ВыбратьФайлОбъектаДляОтладкиЛкс() Экспорт 
	
	ПутьДляФайловОбъектовДляОтладки = ирОбщий.ПолучитьКаталогОбъектовДляОтладкиЛкс();
	Расширение = ирОбщий.РасширениеФайловДляОтладкиЛкс();
	Результат = ВыбратьФайлЛкс(, Расширение, "Файлы объектов для отладки",, ПутьДляФайловОбъектовДляОтладки);
	Если Результат <> Неопределено Тогда
		Результат = "Файл """ + Результат + """";
	КонецЕсли;
	Возврат Результат;

КонецФункции

Процедура ОтладитьОбъектПоСтруктуреЛкс(Знач СтруктураПараметров) Экспорт 
	
	#Если Сервер И Не Сервер Тогда
		СтруктураПараметров = Новый Структура;
	#КонецЕсли
	Объект = СтруктураПараметров.Объект;
	Если СтруктураПараметров.Свойство("ИмяПользователя") Тогда
		ИмяПользователя = СтруктураПараметров.ИмяПользователя;
		Если ИмяПользователя <> ИмяПользователя() Тогда
			ирОбщий.СообщитьЛкс(ирОбщий.СтрШаблонЛкс("Загружаемый снимок объекта для отладки был сделан под другим пользователем (%1)", ИмяПользователя));
		КонецЕсли; 
	КонецЕсли; 
	Если СтруктураПараметров.Свойство("Транзакция") Тогда
		ирОбщий.СообщитьЛкс("Загружаемый снимок объекта для отладки сделан в транзакции. Если она не зафиксирована, поведение объекта может отличаться. Показан неполный список незафиксированных на тот момент изменений.");
		АнализЖурналаРегистрации = ирОбщий.СоздатьОбъектПоИмениМетаданныхЛкс("Обработка.ирАнализЖурналаРегистрации");
		#Если Сервер И Не Сервер Тогда
			АнализЖурналаРегистрации = Обработки.ирАнализЖурналаРегистрации.Создать();
		#КонецЕсли  
		ОтборЖурнала = СтруктураПараметров.Транзакция;
		Начало = ОтборЖурнала.Начало;
		Конец = ОтборЖурнала.Конец;
		ОтборЖурнала.Удалить("Начало");
		ОтборЖурнала.Удалить("Конец");
		АнализЖурналаРегистрации.ОткрытьСОтбором(Начало, Конец, ОтборЖурнала);
	КонецЕсли; 
	ТипОперации = СтруктураПараметров.ТипОперации;
	Если ТипОперации = "Отладить" Тогда
		Объект2 = СтруктураПараметров.НастройкаКомпоновки;
		Если СтруктураПараметров.Свойство("ТипОбъекта") И СтруктураПараметров.ТипОбъекта = "HttpСоединение" Тогда
			// Параметр ИспользоватьАутентификациюОС появился в 8.3.7
			Если Объект.Защищенное Тогда
				ЗащищенноеСоединение = Новый ЗащищенноеСоединениеOpenSSL;
			Иначе
				ЗащищенноеСоединение = Неопределено;
			КонецЕсли; 
			Объект = Вычислить("Новый HTTPСоединение(Объект.Сервер, Объект.Порт, Объект.Пользователь, Объект.Пароль,, Объект.Таймаут, ЗащищенноеСоединение, Объект.ИспользоватьАутентификациюОС)");
			ЗаполнитьЗначенияСвойств(Объект, СтруктураПараметров.Объект);
			Объект2 = Новый HTTPЗапрос;
			ЗаполнитьЗначенияСвойств(Объект2, СтруктураПараметров.НастройкаКомпоновки);
			Если СтруктураПараметров.НастройкаКомпоновки.ТелоДвоичныеДанные <> Неопределено Тогда
				Объект2.УстановитьТелоИзДвоичныхДанных(СтруктураПараметров.НастройкаКомпоновки.ТелоДвоичныеДанные);
			КонецЕсли; 
		ИначеЕсли ТипЗнч(Объект) = Тип("Структура") Тогда
			СтруктураЗапроса = Объект;
			Если Истина
				И СтруктураЗапроса.Свойство("ВременныеТаблицы") 
				И СтруктураЗапроса.ВременныеТаблицы <> Неопределено
			Тогда
				ИменаВременныхТаблиц = Неопределено;
				МенеджерВременныхТаблиц = ирОбщий.ВосстановитьМенеджерВременныхТаблицЛкс(СтруктураЗапроса.ВременныеТаблицы, Объект2);
			КонецЕсли;
			Объект = Новый Запрос;
			Объект.МенеджерВременныхТаблиц = МенеджерВременныхТаблиц; 
			Объект.Текст = СтруктураЗапроса.Текст;
			
			// Антибаг платформы 8.2.18. Некорректная сериализация моментов времени http://partners.v8.1c.ru/forum/thread.jsp?id=1159525#1159525
			//ирОбщий.СкопироватьУниверсальнуюКоллекциюЛкс(СтруктураЗапроса.Параметры, Объект.Параметры);
			Для Каждого КлючИЗначение Из СтруктураЗапроса.Параметры Цикл
				Объект.Параметры.Вставить(КлючИЗначение.Ключ, ирОбщий.ЗначениеИзСтрокиВнутрЛкс(КлючИЗначение.Значение));
			КонецЦикла;
			Если Объект.Параметры.Свойство("_ОбъектыДанныхТранзакции") Тогда
				ОбъектыДанных = Новый Массив;
				Для Каждого СнимокОбъекта Из Объект.Параметры._ОбъектыДанныхТранзакции Цикл
					ОбъектыДанных.Добавить(ирОбщий.ОбъектИзСнимкаЛкс(СнимокОбъекта));
				КонецЦикла;
				Объект.Параметры.Вставить("_ОбъектыДанныхТранзакции", ОбъектыДанных);
			КонецЕсли; 
		Иначе
			Если Истина
				И СтруктураПараметров.Свойство("ВременныеТаблицы") 
				И СтруктураПараметров.ВременныеТаблицы <> Неопределено
			Тогда
				МенеджерВременныхТаблиц = ирОбщий.ВосстановитьМенеджерВременныхТаблицЛкс(СтруктураПараметров.ВременныеТаблицы);
			КонецЕсли;
		КонецЕсли; 
		ирОбщий.ОтладитьЛкс(Объект, , Объект2, СтруктураПараметров.ВнешниеНаборыДанных,,,,, МенеджерВременныхТаблиц);
	ИначеЕсли ТипОперации = "Исследовать" Тогда
		Если СтруктураПараметров.Свойство("СериализацияФабрикой") Тогда 
			Если СтруктураПараметров.СериализацияФабрикой = Истина Тогда
				Объект = ирОбщий.ОбъектXDTOИзСтрокиXMLЛкс(Объект, Истина);
			ИначеЕсли СтруктураПараметров.СериализацияФабрикой = "Внутр" Тогда
				Объект = ирОбщий.ЗначениеИзСтрокиВнутрЛкс(Объект);
				ирОбщий.СообщитьЛкс("Из-за неуспешной сериализации XML применена ЗначениеВСтрокуВнутр(), которая допускает потери (например очищает ссылки на строки таблицы/дерева значений)");
			КонецЕсли; 
		КонецЕсли; 
		ирОбщий.ИсследоватьЛкс(Объект, , СтруктураПараметров.КакКоллекцию);
	КонецЕсли;

КонецПроцедуры

Функция ПолеВвода_ОкончаниеВводаТекстаЛкс(Элемент, Текст, выхСписокПодобранных, СтандартнаяОбработка, РасширенноеЗначение = Null, ЛиТипСтрокаСлужебный = Ложь, ЭтаФорма = Неопределено,
	Знач СтруктураОтбора = Неопределено, ТекстАвтоПодбора = Неопределено) Экспорт
	
	выхСписокПодобранных = Новый СписокЗначений;
	Если Не ЗначениеЗаполнено(Текст) Тогда
		Возврат Неопределено;
	КонецЕсли;
	Если ТипЗнч(Элемент.Значение) = Тип("ПолеКомпоновкиДанных") Тогда
		выхСписокПодобранных = ПодобратьВариантыПоляКомпоновкиЛкс(ЭтаФорма.ТекущийЭлемент, Текст, СтандартнаяОбработка);
	Иначе
		Менеджер = Неопределено;
		ТекущеееЗначение = ирОбщий.ДанныеЭлементаФормыЛкс(Элемент);
		Если ТипЗнч(ТекущеееЗначение) = Тип("Строка") Тогда
			// Опасно. Сбрасывает позицию каретки (при вызове из АвтоподборТекста)
			// Восстановим значение, т.к. при чтении из него в режиме пароля оно меняется на "*************"
			ирОбщий.ПрисвоитьЕслиНеРавноЛкс(Элемент.Значение, Текст); 
			Попытка
				ТипЗначенияПоля = ирОбщий.ТипЗначенияЭлементаФормыЛкс(Элемент);
			Исключение
				Если ТипЗнч(Элемент) = Тип("ПолеВвода") Тогда
					ВызватьИсключение;
				Иначе
					// Для поля формы игнорируем
					Возврат выхСписокПодобранных;
				КонецЕсли; 
			КонецПопытки; 
			Типы = ТипЗначенияПоля.Типы();
			Если Типы.Количество() > 1 Тогда
				ЗначениеСсылки = ирОбщий.НавигационнаяСсылкаВЗначениеЛкс(ТекущеееЗначение);
				Если Не ЗначениеЗаполнено(ЗначениеСсылки) Тогда
					ЗначениеСсылки = ирОбщий.ПреобразоватьЗначениеИзSDBLЛкс(ТекущеееЗначение);
				КонецЕсли; 
				Если Истина
					И ЗначениеСсылки <> Неопределено
					И ТипЗнч(ЗначениеСсылки) <> Тип("Строка")
					И Элемент.ТипЗначения.СодержитТип(ТипЗнч(ЗначениеСсылки)) 
				Тогда
					Ответ = КодВозвратаДиалога.Да;
					Если Не ЛиТипСтрокаСлужебный Тогда
						Ответ = Вопрос("Хотите вставить строку как ссылку?", РежимДиалогаВопрос.ДаНет,, КодВозвратаДиалога.Нет);
					КонецЕсли; 
					Если Ответ = КодВозвратаДиалога.Да Тогда
						выхСписокПодобранных = ЗначениеСсылки;
						СтандартнаяОбработка = Ложь;
					КонецЕсли;
				КонецЕсли;
				Если Не ЗначениеЗаполнено(ЗначениеСсылки) Тогда
					Фрагменты = ирОбщий.СтрРазделитьЛкс(ТекущеееЗначение);
					Если Фрагменты.Количество() > 1 Тогда
						ИмяТипа = Фрагменты[0] + "." + Фрагменты[1];
						Попытка
							ОписаниеТипов = Новый ОписаниеТипов(ИмяТипа);
						Исключение
							ОписаниеТипов = Неопределено;
						КонецПопытки; 
						Если ОписаниеТипов <> Неопределено Тогда
							выхСписокПодобранных = ОписаниеТипов.ПривестиЗначение();
							Менеджер = ирОбщий.ПолучитьМенеджерЛкс(выхСписокПодобранных); 
							СтандартнаяОбработка = Ложь;
						КонецЕсли; 
					КонецЕсли; 
				КонецЕсли; 
				Если Истина
					И ЛиТипСтрокаСлужебный
					И СтандартнаяОбработка
					И ЗначениеЗаполнено(ТекущеееЗначение) 
				Тогда
					выхСписокПодобранных = ""; 
					СтандартнаяОбработка = Ложь;
				КонецЕсли; 
			КонецЕсли; 
		КонецЕсли;
		Если ирОбщий.ЛиТипСсылкиБДЛкс(ТипЗнч(ТекущеееЗначение)) Тогда 
			Менеджер = ирОбщий.ПолучитьМенеджерЛкс(ТекущеееЗначение);
		КонецЕсли; 
		Если Менеджер <> Неопределено Тогда
			выхСписокПодобранных = ирОбщий.ПреобразоватьПредставлениеВСсылкуЛкс(Менеджер, Текст);
			Если выхСписокПодобранных <> Неопределено Тогда
				СтандартнаяОбработка = Ложь;
			Иначе
				ПараметрыВыбора = Новый Структура;
				ПараметрыВыбора.Вставить("СтрокаПоиска", Текст);
				ПараметрыВыбора.Вставить("Отбор", СтруктураОтбора);
				ирОбщий.СсылочныйМенеджерОбработкаПолученияДанныхВыбораЛкс(Менеджер, выхСписокПодобранных, ПараметрыВыбора, СтандартнаяОбработка);
			КонецЕсли; 
		ИначеЕсли Не Элемент.ОграничениеТипа.СодержитТип(Тип("ПолеКомпоновкиДанных")) Тогда 
			Если Ложь
				Или (Истина
					И РасширенноеЗначение <> Null
					И ТипЗнч(РасширенноеЗначение) <> ТипЗнч(ТекущеееЗначение))
				Или Элемент.ОграничениеТипа.ПривестиЗначение(ТекущеееЗначение) <> ТекущеееЗначение 
			Тогда
				// Откат
				СтандартнаяОбработка = Ложь;
				выхСписокПодобранных = Новый СписокЗначений;
			КонецЕсли; 
		КонецЕсли;
	КонецЕсли;
	Если ТекстАвтоПодбора = "" Тогда
		СтандартнаяОбработка = Ложь;
		Если выхСписокПодобранных.Количество() = 1 Тогда 
			ПредставлениеСсылки = "" + выхСписокПодобранных[0].Значение;
			Если ирОбщий.СтрНачинаетсяСЛкс(ПредставлениеСсылки, Текст) Тогда
				ТекстАвтоподбора = ПредставлениеСсылки;
				СтандартнаяОбработка = Истина;
			КонецЕсли;
		КонецЕсли;
	КонецЕсли;
	
КонецФункции

// Процедура - Поле ввода с историей выбора при изменении
//
// Параметры:
//  ПолеВвода						 - 	 - 
//  КлючИстории						 - Строка, Форма - 
//  ЗапоминатьПоследние				 - 	 - 
//  НеЗапоминатьПустыеТипизированные - 	 - 
//  ДополнительныйКлючИстории		 - Строка - используется только если КлючИстории не ялвяется строкой
//
Процедура ПолеВводаСИсториейВыбора_ПриИзмененииЛкс(Знач ЭлементФормыИлиЭлементОтбора, Знач КлючИстории, Знач ЗапоминатьПоследние = 20, Знач _НеЗапоминатьПустыеТипизированные = Истина,
	ДополнительныйКлючИстории = "", Знач ЗначениеПоля = Неопределено) Экспорт
	
	Если ЗначениеПоля = Неопределено Тогда
		Если ТипЗнч(ЭлементФормыИлиЭлементОтбора) = Тип("ЭлементОтбора") Тогда
			ЗначениеПоля = ЭлементФормыИлиЭлементОтбора.Значение;
		ИначеЕсли ТипЗнч(ЭлементФормыИлиЭлементОтбора) = Тип("ЭлементОтбораКомпоновкиДанных") Тогда
			ЗначениеПоля = ЭлементФормыИлиЭлементОтбора.ПравоеЗначение;
		ИначеЕсли ТипЗнч(ЭлементФормыИлиЭлементОтбора) = Тип("КолонкаТабличногоПоля") Тогда
			ПолеВвода = ЭлементФормыИлиЭлементОтбора.ЭлементУправления;
			ЗначениеПоля = ПолеВвода.Значение;
		Иначе
			ПолеВвода = ЭлементФормыИлиЭлементОтбора; 
			ЗначениеПоля = ирОбщий.ДанныеЭлементаФормыЛкс(ПолеВвода);
		КонецЕсли; 
	КонецЕсли; 
	Если ЗначениеЗаполнено(ЗначениеПоля) Тогда
		НовоеЗначениеXML = ирОбщий.ОбъектВСтрокуXMLЛкс(ЗначениеПоля);
		Если СтрДлина(НовоеЗначениеXML) > 1000 Тогда
			Возврат;
		КонецЕсли; 
		КлючИстории = ирОбщий.КлючИсторииВыбораПоляВводаЛкс(ЭлементФормыИлиЭлементОтбора, КлючИстории, ДополнительныйКлючИстории);
		ПоследниеЗначения = ирОбщий.ВосстановитьЗначениеЛкс(КлючИстории);
		Если ТипЗнч(ПоследниеЗначения) <> Тип("Массив") Тогда
			ПоследниеЗначения = Новый Массив;
		КонецЕсли;
		ПоследниеЗначенияXML = Новый Массив;
		Для Каждого Значение Из ПоследниеЗначения Цикл
			ПоследниеЗначенияXML.Добавить(ирОбщий.ОбъектВСтрокуXMLЛкс(Значение));
		КонецЦикла;
		Индекс = ПоследниеЗначенияXML.Найти(НовоеЗначениеXML);
		Если Индекс <> Неопределено Тогда
			ПоследниеЗначения.Удалить(Индекс);
		КонецЕсли;
		ПоследниеЗначения.Вставить(0, ЗначениеПоля);
		Для Счетчик = ЗапоминатьПоследние По ПоследниеЗначения.ВГраница() Цикл
			ПоследниеЗначения.Удалить(ЗапоминатьПоследние);
		КонецЦикла;
		ирОбщий.СохранитьЗначениеЛкс(КлючИстории, ПоследниеЗначения);
		Если Ложь
			Или ТипЗнч(ПолеВвода) = Тип("ПолеФормы") 
			Или ТипЗнч(ПолеВвода) = Тип("ПолеВвода") 
		Тогда
			// https://partners.v8.1c.ru/forum/topic/1150632
			ПолеВвода.СписокВыбора.ЗагрузитьЗначения(ПоследниеЗначения);
			Если Истина
				И ТипЗнч(ЗначениеПоля) = Тип("СписокЗначений")
				И ПолеВвода.ПолучитьДействие("ОбработкаВыбора") = Неопределено
			Тогда
				// Без этого обработчика выбор из списка не устанавливает значение
				ирОбщий.СообщитьЛкс("В поле ввода отсутствует обработчик ОбработкаВыбора");
			КонецЕсли; 
		КонецЕсли; 
	КонецЕсли;
	
КонецПроцедуры

// .
// Параметры:
//   РедактированиеРазрешено - Булево - для открытия ссылки надо установить Ложь
//   ЭлементУправления - Неопределено - значение этого элемента управления открываем, при открытии значения из ячейки табличного поля должно быть Неопределено
//   ЭлементУправленияРодитель - ТабличноеПоле - чью ячейку открываем
// Результат:
//	Булево - Истина если значение было изменено
Функция ОткрытьЗначениеЛкс(РасширенноеЗначение, РедактированиеРазрешено = Истина, СтандартнаяОбработка = Истина, ЗаголовокФормы = "", РедактироватьМодально = Истина,
	ПринудительноВОтдельнойФорме = Истина, ЭлементУправления = Неопределено, ЭлементУправленияРодитель = Неопределено, Знач ИскомаяСтрока = "", Знач КлючУникальности = Неопределено) Экспорт 
	
	Результат = Ложь;
	ТипРасширенногоЗначения = ТипЗнч(РасширенноеЗначение);
	ХмлТип = XMLТипЗнч(РасширенноеЗначение); 
	ЭтоКлючЗаписиРегистра = ирОбщий.ЛиКлючЗаписиРегистраЛкс(РасширенноеЗначение);
	ЭтоСсылка = ирОбщий.ЛиТипСсылкиБДЛкс(ТипРасширенногоЗначения, Ложь);
	Если Ложь
		Или ТипРасширенногоЗначения = Тип("ТаблицаЗначений") 
		Или ТипРасширенногоЗначения = Тип("ДеревоЗначений") 
		Или ТипРасширенногоЗначения = Тип("МоментВремени")
		Или ТипРасширенногоЗначения = Тип("ТабличныйДокумент")
		Или ТипРасширенногоЗначения = Тип("Массив")
		Или ТипРасширенногоЗначения = Тип("ФиксированныйМассив")
		Или ТипРасширенногоЗначения = Тип("Граница")
		Или ТипРасширенногоЗначения = Тип("УникальныйИдентификатор")
		Или ТипРасширенногоЗначения = Тип("Тип")
		Или ТипРасширенногоЗначения = Тип("ОписаниеТипов")
		Или ТипРасширенногоЗначения = Тип("СписокЗначений")
		Или ТипРасширенногоЗначения = Тип("ДвоичныеДанные")
		Или ТипРасширенногоЗначения = Тип("ХранилищеЗначения")
		Или ТипРасширенногоЗначения = Тип("Картинка")
		Или (Истина
			И ТипРасширенногоЗначения = Тип("Строка")
			И (Ложь
				Или ПринудительноВОтдельнойФорме
				Или СтрДлина(РасширенноеЗначение) > 100
				Или Найти(РасширенноеЗначение, "://") > 00 // есть гиперссылки
				//Или Не РедактированиеРазрешено
				))
	Тогда 
		Если Не ЗначениеЗаполнено(КлючУникальности) Тогда
			КлючУникальности = Новый УникальныйИдентификатор;
		КонецЕсли;
		СтандартнаяОбработка = Ложь;
		ЕстьРастягивающиесяВертикальноЭлементы = Истина;
		мПлатформа = ирКэш.Получить();
		#Если Сервер И Не Сервер Тогда
		    мПлатформа = Обработки.ирПлатформа.Создать();
		#КонецЕсли
		Если Ложь
			Или ТипРасширенногоЗначения = Тип("ТаблицаЗначений") 
			Или ТипРасширенногоЗначения = Тип("ДеревоЗначений") 
		Тогда
			ФормаРедактирования = мПлатформа.ПолучитьФорму("ТаблицаЗначений", , РасширенноеЗначение);
			ФормаРедактирования.ПараметрТабличноеПоле = ЭлементУправления;
		ИначеЕсли ТипРасширенногоЗначения = Тип("МоментВремени") Тогда
			ФормаРедактирования = мПлатформа.ПолучитьФорму("МоментВремени", , РасширенноеЗначение);
			ЕстьРастягивающиесяВертикальноЭлементы = Ложь;
		ИначеЕсли ТипРасширенногоЗначения = Тип("ТабличныйДокумент") Тогда
			ФормаРедактирования = мПлатформа.ПолучитьФорму("ТабличныйДокумент", , РасширенноеЗначение);
			Если ЭлементУправления <> Неопределено Тогда
				ФормаРедактирования.ПолеТабличногоДокумента = ЭлементУправления;
			Иначе
				ФормаРедактирования.ПолеТабличногоДокумента = РасширенноеЗначение;
			КонецЕсли; 
		ИначеЕсли ТипРасширенногоЗначения = Тип("Граница") Тогда
			ФормаРедактирования = мПлатформа.ПолучитьФорму("Граница", , РасширенноеЗначение);
			ЕстьРастягивающиесяВертикальноЭлементы = Ложь;
		ИначеЕсли Ложь
			Или ТипРасширенногоЗначения = Тип("Массив")
			Или ТипРасширенногоЗначения = Тип("ФиксированныйМассив") 
		Тогда
			ФормаРедактирования = мПлатформа.ПолучитьФорму("Массив", , РасширенноеЗначение);
		ИначеЕсли ТипРасширенногоЗначения = Тип("УникальныйИдентификатор") Тогда
			ФормаРедактирования = мПлатформа.ПолучитьФорму("УникальныйИдентификатор", , РасширенноеЗначение);
			ЕстьРастягивающиесяВертикальноЭлементы = Ложь;
		ИначеЕсли ТипРасширенногоЗначения = Тип("СписокЗначений") Тогда
			ФормаРедактирования = мПлатформа.ПолучитьФорму("СписокЗначений", , РасширенноеЗначение);
		ИначеЕсли ТипРасширенногоЗначения = Тип("Строка") Тогда
			ФормаРедактирования = ПолучитьФормуТекстаЛкс(,, "",, КлючУникальности);
			ФормаРедактирования.ПараметрСтрокаПоиска = ИскомаяСтрока;
		ИначеЕсли ТипРасширенногоЗначения = Тип("Тип") Тогда
			ФормаРедактирования = мПлатформа.ПолучитьФорму("ВыборРедактируемыхТипов", , ТипРасширенногоЗначения);
			ФормаРедактирования.РежимВыбора = Истина;
			ФормаРедактирования.МножественныйВыбор = Ложь;
		ИначеЕсли ТипРасширенногоЗначения = Тип("ОписаниеТипов") Тогда
			ФормаРедактирования = мПлатформа.ПолучитьФорму("ВыборРедактируемыхТипов", , РасширенноеЗначение);
			ФормаРедактирования.РежимВыбора = Истина;
			ФормаРедактирования.МножественныйВыбор = Истина;
		ИначеЕсли ТипРасширенногоЗначения = Тип("ХранилищеЗначения") Тогда
			ФормаРедактирования = мПлатформа.ПолучитьФорму("ХранилищеЗначения", , КлючУникальности);
			ЕстьРастягивающиесяВертикальноЭлементы = Ложь;
		ИначеЕсли ТипРасширенногоЗначения = Тип("ДвоичныеДанные") Тогда
			ФормаРедактирования = мПлатформа.ПолучитьФорму("ДвоичныеДанные", , КлючУникальности);
		ИначеЕсли ТипРасширенногоЗначения = Тип("Картинка") Тогда
			ФормаРедактирования = мПлатформа.ПолучитьФорму("Картинка", , КлючУникальности);
		КонецЕсли;
		Если ФормаРедактирования.Открыта() Тогда
			Форма_АктивироватьОткрытьЛкс(ФормаРедактирования);
			Возврат Результат;
		КонецЕсли; 
		Если ЗначениеЗаполнено(ЗаголовокФормы) Тогда
			ФормаРедактирования.Заголовок = ЗаголовокФормы;
		КонецЕсли; 
		ФормаРедактирования.ТолькоПросмотр = Не РедактированиеРазрешено;
		Если РедактированиеРазрешено И РедактироватьМодально Тогда
			Если Ложь
				Или ТипРасширенногоЗначения = Тип("ТаблицаЗначений") 
				Или ТипРасширенногоЗначения = Тип("ДеревоЗначений") 
			Тогда 
				ФормаРедактирования.НачальноеЗначениеВыбора = РасширенноеЗначение.Скопировать(); // Неглубокая копия, зато с полным сохранением содержимого, включая объекты метаданных
			Иначе
				ФормаРедактирования.НачальноеЗначениеВыбора = ирОбщий.КопияОбъектаЛкс(РасширенноеЗначение, ); // Универсально, но с потерей несериализуемых типов
			КонецЕсли; 
		Иначе
			ФормаРедактирования.НачальноеЗначениеВыбора = РасширенноеЗначение;
		КонецЕсли;
		Если Ложь
			#Если ТолстыйКлиентУправляемоеПриложение Тогда
			Или Не ЕстьРастягивающиесяВертикальноЭлементы // https://www.hostedredmine.com/issues/901852
			#КонецЕсли
			Или РедактированиеРазрешено И РедактироватьМодально 
		Тогда
			РезультатВыбора = ФормаРедактирования.ОткрытьМодально();
			Если РезультатВыбора <> Неопределено Тогда
				РасширенноеЗначение = РезультатВыбора;
				Результат = Истина;
			КонецЕсли; 
		Иначе
			ФормаРедактирования.Открыть();
		КонецЕсли; 
	ИначеЕсли ТипРасширенногоЗначения = Тип("Цвет") Тогда
		СтандартнаяОбработка = Ложь;
		ДиалогВыбораЦвета = Новый ДиалогВыбораЦвета;
		ДиалогВыбораЦвета.Цвет = РасширенноеЗначение;
		Результат = ДиалогВыбораЦвета.Выбрать();
		Если Результат Тогда
			РасширенноеЗначение = ДиалогВыбораЦвета.Цвет;
		КонецЕсли; 
	ИначеЕсли ТипРасширенногоЗначения = Тип("Шрифт") Тогда
		СтандартнаяОбработка = Ложь;
		ДиалогВыбораШрифта = Новый ДиалогВыбораШрифта;
		ДиалогВыбораШрифта.Шрифт = РасширенноеЗначение;
		Результат = ДиалогВыбораШрифта.Выбрать();
		Если Результат Тогда
			РасширенноеЗначение = ДиалогВыбораШрифта.Шрифт;
		КонецЕсли; 
	ИначеЕсли ТипРасширенногоЗначения = Тип("СхемаКомпоновкиДанных") Тогда
		СтандартнаяОбработка = Ложь;
		Редактор = ирОбщий.СоздатьОбъектПоИмениМетаданныхЛкс("Обработка.ирКонсольКомпоновокДанных");
		#Если Сервер И Не Сервер Тогда
			Редактор = Обработки.ирКонсольКомпоновокДанных.Создать();
		#КонецЕсли
		ДанныеРедактора = Новый Структура("СхемаКомпоновки", РасширенноеЗначение);
		Если ЗначениеЗаполнено(ЗаголовокФормы) Тогда
			ДанныеРедактора.Вставить("Имя", ЗаголовокФормы);
		КонецЕсли;
		Результат = Редактор.РедактироватьСтруктуруСхемы(, ДанныеРедактора, Истина); // Всегда модально, т.к. пользователю будет неочевидно что изменения не будут сохранены в источник
		Если Результат <> Неопределено Тогда
			РасширенноеЗначение = Результат.СхемаКомпоновки;
			Результат = Истина;
		Иначе
			Результат = Ложь;
		КонецЕсли; 
	ИначеЕсли Ложь
		Или ТипРасширенногоЗначения = Тип("Число")
		Или ТипРасширенногоЗначения = Тип("Строка")
		Или ТипРасширенногоЗначения = Тип("Дата")
		Или ТипРасширенногоЗначения = Тип("Булево")
		Или ТипРасширенногоЗначения = Тип("Неопределено")
		Или ТипРасширенногоЗначения = Тип("Null")
		Или ТипРасширенногоЗначения = Тип("ПолеКомпоновкиДанных")
		Или ТипРасширенногоЗначения = Тип("СтандартнаяДатаНачала")
		Или ТипРасширенногоЗначения = Тип("СтандартныйПериод")
		Или ТипРасширенногоЗначения = Тип("ОтборКомпоновкиДанных")
		Или ТипРасширенногоЗначения = Тип("ВидДвиженияНакопления")
		Или ТипРасширенногоЗначения = Тип("ВидДвиженияБухгалтерии")
		Или ТипРасширенногоЗначения = Тип("ВидСчета")
		Или ЭтоКлючЗаписиРегистра
		Или (Истина
			И ХмлТип <> Неопределено
			И Найти(ХмлТип.ИмяТипа, "Ref.") > 0)
			
	Тогда
		ОбъектБДСуществует = Истина;
		Если Истина
			И ЭтоСсылка 
			И ЗначениеЗаполнено(РасширенноеЗначение) 
		Тогда
			ОбъектБДСуществует = ирОбщий.ЛиСуществуетОбъектПоСсылкеЛкс(РасширенноеЗначение);
			Если Не ОбъектБДСуществует И Не ПринудительноВОтдельнойФорме Тогда
				//ОткрытьСсылкуЯчейкиВРедактореОбъектаБДЛкс(ТабличноеПоле);
				ОткрытьСсылкуВРедактореОбъектаБДЛкс(РасширенноеЗначение);
				СтандартнаяОбработка = Ложь;
			КонецЕсли; 
		КонецЕсли; 
		Если Ложь
			Или Не СтандартнаяОбработка
			Или Не РедактированиеРазрешено 
			Или ЭлементУправленияРодитель = Неопределено
		Тогда
			Если Ложь
				Или ЭтоСсылка 
				Или ЭтоКлючЗаписиРегистра
			Тогда
				Если Истина
					И ЗначениеЗаполнено(РасширенноеЗначение) 
					И ОбъектБДСуществует
				Тогда
					Если Не ирОбщий.ЛиДоступноРедактированиеВФормеОбъектаЛкс(Метаданные.НайтиПоТипу(ТипРасширенногоЗначения)) Тогда
						ФормаСсылки = ОткрытьСсылкуВРедактореОбъектаБДЛкс(РасширенноеЗначение);
					Иначе
						Если Истина
							И Не ирКэш.ЛиСеансТолстогоКлиентаУПЛкс()
							И Не ЭтоКлючЗаписиРегистра
							И Не ирОбщий.ЛиТипСсылкиВнешнейТаблицыЛкс(ТипРасширенногоЗначения) // https://www.hostedredmine.com/issues/917016
						Тогда
							ФормаСсылки = РасширенноеЗначение.ПолучитьФорму();
							ФормаСсылки.Открыть();
						Иначе
							ОткрытьЗначение(РасширенноеЗначение);
							ФормаСсылки = АктивнаяФормаЛкс(); // В обычном приложении не работает
						КонецЕсли;
					КонецЕсли; 
					НачатьОтслеживаниеФормыЛкс(ФормаСсылки);
				КонецЕсли; 
				СтандартнаяОбработка = Ложь;
			КонецЕсли; 
			Если СтандартнаяОбработка Тогда
				Если ПримитивныеТипыЛкс().Найти(ТипЗнч(РасширенноеЗначение)) = Неопределено Тогда
					ОткрытьЗначение(РасширенноеЗначение);
				КонецЕсли;
				СтандартнаяОбработка = Ложь;
			КонецЕсли;
		КонецЕсли; 
	Иначе
		//Если Истина
		//	И ТипЗначения1 <> Неопределено
		//	И ТипЗначения1.ПривестиЗначение(РасширенноеЗначение) <> РасширенноеЗначение 
		//Тогда
			ирОбщий.ИсследоватьЛкс(РасширенноеЗначение);
			СтандартнаяОбработка = Ложь;
		//КонецЕсли; 
	КонецЕсли;
	Возврат Результат;
	
КонецФункции 

Процедура НачатьОтслеживаниеФормыЛкс(Форма, РазрешитьСвоюФорму = Ложь) Экспорт 
	Если Форма = Неопределено Тогда
		Возврат;
	КонецЕсли;
	Если Не РазрешитьСвоюФорму И ирКэш.ОткрытыеФормыПодсистемыЛкс().Найти(Форма) <> Неопределено Тогда
		Возврат;
	КонецЕсли;
	ОткрытыеФормыВсе = ирКэш.ОткрытыеФормыВсеЛкс();
	#Если Сервер И Не Сервер Тогда
		ОткрытыеФормыВсе = Новый Соответствие;
	#КонецЕсли
	ПараметрыСлежения = ОткрытыеФормыВсе[Форма];
	НоваяСсылка = ирОбщий.КлючОсновногоОбъектаФормыЛкс(Форма);
	Если ПараметрыСлежения = Неопределено Тогда
		ПараметрыСлежения = Новый Структура;
		ПараметрыСлежения.Вставить("ДобавленаВИсторию", Ложь);
		ПараметрыСлежения.Вставить("МоментОткрытия", ТекущаяДата());
		ПараметрыСлежения.Вставить("Ссылка", НоваяСсылка);
	Иначе
		Если НоваяСсылка <> ПараметрыСлежения.Ссылка Тогда
			ПараметрыСлежения.ДобавленаВИсторию = Ложь;
			ПараметрыСлежения.Ссылка = НоваяСсылка;
			ПараметрыСлежения.МоментОткрытия = ТекущаяДата();
		КонецЕсли;
	КонецЕсли;
	ОткрытыеФормыВсе[Форма] = ПараметрыСлежения;
	Если ОткрытыеФормыВсе.Количество() = 1 Тогда
		ПодключитьПроверкуЧужихФормЛкс();
	КонецЕсли;
КонецПроцедуры

Процедура ПроверитьФормыСсылокЛкс() Экспорт 
	
	ОткрытыеФормыВсе = ирКэш.ОткрытыеФормыВсеЛкс();
	#Если Сервер И Не Сервер Тогда
		ОткрытыеФормыВсе = Новый Соответствие;
	#КонецЕсли
	МинДлительность = ирКлиент.МинДлительностьАктивностиФормыСсылкиЛкс();
	КлючиУдалить = Новый Массив;
	ТекущаяДата = ТекущаяДата();
	//ИсторияПлатформыИзменена = Ложь;
	Для Каждого КлючИЗначение Из ОткрытыеФормыВсе Цикл
		ФормаСсылки = КлючИЗначение.Ключ;
		ПараметрыСлежения = КлючИЗначение.Значение;
		Если Истина
			И ТекущаяДата - ПараметрыСлежения.МоментОткрытия >= МинДлительность 
			И ирКлиент.Форма_ВводДоступенЛкс(ФормаСсылки) 
		Тогда 
			Ссылка = ирОбщий.КлючОсновногоОбъектаФормыЛкс(ФормаСсылки);
			Если ЗначениеЗаполнено(Ссылка) Тогда 
				Если Ложь
					Или Не ЗначениеЗаполнено(ПараметрыСлежения.Ссылка) // Записан новый объект
					Или ПараметрыСлежения.Ссылка = Ссылка И Не ПараметрыСлежения.ДобавленаВИсторию
				Тогда 
					ПараметрыСлежения.Ссылка = Ссылка;
					ПараметрыСлежения.ДобавленаВИсторию = Истина;
					ПараметрыСлежения.МоментОткрытия = ТекущаяДата;
					ИсторияПлатформыИзменена = Не ирКэш.ЛиСеансТолстогоКлиентаУПЛкс();
					ирКлиент.ДобавитьСсылкуВИсториюРаботыЛкс(Ссылка, ИсторияПлатформыИзменена);
				ИначеЕсли ПараметрыСлежения.Ссылка <> Ссылка Тогда
					// Отслеживание аналогов редактора объекта БД
					ирКлиент.НачатьОтслеживаниеФормыЛкс(ФормаСсылки);
				КонецЕсли;
			КонецЕсли;
		КонецЕсли;
		Если Не ФормаСсылки.Открыта() Тогда 
			// Удерживаем ссылки пока формы видимы
			КлючиУдалить.Добавить(КлючИЗначение.Ключ);
		КонецЕсли;
	КонецЦикла;
	Для Каждого Ключ Из КлючиУдалить Цикл
		ОткрытыеФормыВсе.Удалить(Ключ);
	КонецЦикла;
	АктивнаяФорма = ирКлиент.АктивнаяУправляемаяФормаЛкс();
	Если АктивнаяФорма <> Неопределено Тогда
		Ссылка = ирОбщий.КлючОсновногоОбъектаФормыЛкс(АктивнаяФорма);
		Если ирОбщий.ЛиСсылкаНаОбъектБДЛкс(Ссылка) Тогда
			ирКлиент.НачатьОтслеживаниеФормыЛкс(АктивнаяФорма);
		КонецЕсли;
	КонецЕсли;
	Если Ложь
		Или ОткрытыеФормыВсе.Количество() > 0 
		Или ирКэш.ЛиСеансТолстогоКлиентаУПЛкс() 
	Тогда
		ирКлиент.ПодключитьПроверкуЧужихФормЛкс();
	КонецЕсли;
	//Если ИсторияПлатформыИзменена И ирКэш.ЛиСеансТолстогоКлиентаУПЛкс() Тогда 
	//  // При первом вызове теряется накопленная история https://www.hostedredmine.com/issues/956694
	//	ОбновитьИнтерфейс();
	//КонецЕсли;

КонецПроцедуры

Процедура ПодключитьПроверкуЧужихФормЛкс() Экспорт 
	
	#Если Сервер И Не Сервер Тогда
		ПроверитьФормыСсылокОтложенноЛкс();
	#КонецЕсли
	ПодключитьГлобальныйОбработчикОжиданияЛкс("ПроверитьФормыСсылокОтложенноЛкс", МинДлительностьАктивностиФормыСсылкиЛкс(), Истина);

КонецПроцедуры

Функция МинДлительностьАктивностиФормыСсылкиЛкс() Экспорт 
	
	Возврат 5;

КонецФункции

Функция ПримитивныеТипыЛкс() Экспорт 
	ПримитивныеТипы = Новый Массив;
	ПримитивныеТипы.Добавить(Тип("Число"));
	ПримитивныеТипы.Добавить(Тип("Строка"));
	ПримитивныеТипы.Добавить(Тип("Дата"));
	ПримитивныеТипы.Добавить(Тип("Булево"));
	ПримитивныеТипы.Добавить(Тип("Неопределено"));
	ПримитивныеТипы.Добавить(Тип("Null"));
	Возврат ПримитивныеТипы;
КонецФункции

Функция ОткрытьФормуВМинимальномРазмереЛкс(Форма) Экспорт 
	
	Если ирКэш.ЛиСеансТолстогоКлиентаУПЛкс() Тогда 
		Форма.ОткрытьМодально();
	Иначе
		Форма.Открыть();
	КонецЕсли;
	
КонецФункции

Процедура ОткрытьКонсольСерверов1СБезПараметровЛкс() Экспорт 
	ОткрытьКонсольСерверов1СЛкс();
КонецПроцедуры

Процедура ОткрытьКонсольСерверов1СЛкс(Знач СборкаПлатформы = Неопределено, ТаблицаСерверов = Неопределено) Экспорт 
	
	Если ирОбщий.ПроверитьПлатформаНеWindowsЛкс() Тогда
		Возврат;
	КонецЕсли; 
	ОбработкаРегистрации = ирОбщий.СоздатьОбъектПоИмениМетаданныхЛкс("Обработка.ирУправлениеCOMКлассами1С");
	#Если Сервер И Не Сервер Тогда
		ОбработкаРегистрации = Обработки.ирУправлениеCOMКлассами1С.Создать();
		ТекущаяСтрокаТаблицыСерверов = Обработки.ирУправлениеСлужбамиСервера1С.Создать().СлужбыАгентовСерверов.Добавить();
	#КонецЕсли
	ОбработкаРегистрации.ЗаполнитьТипыCOMКлассов();
	ирОбщий.ЗаполнитьДоступныеСборкиПлатформыЛкс(ОбработкаРегистрации.СборкиПлатформы,, ОбработкаРегистрации.ТипыComКлассов);
	ТипКласса = "ServerAdminScope";
	Если Не ЗначениеЗаполнено(СборкаПлатформы) Тогда
		СборкаПлатформы = ОбработкаРегистрации.ТекущаяСборкаПлатформы;
	КонецЕсли; 
	СтрокаСборкиПлатформы = ОбработкаРегистрации.СборкиПлатформы.НайтиСтроки(Новый Структура("СборкаПлатформы," + ТипКласса, СборкаПлатформы, Истина));
	Если СтрокаСборкиПлатформы.Количество() = 0 Тогда
		Возврат;
	КонецЕсли; 
	СтрокаСборкиПлатформы = СтрокаСборкиПлатформы[0];
	#Если Сервер И Не Сервер Тогда
		СтрокаСборкиПлатформы = ОбработкаРегистрации.СборкиПлатформы[0];
	#КонецЕсли
	ПолноеИмяФайлаКонсоли = "";
	Если ирКэш.НомерИзданияПлатформыЛкс() = "81" Тогда
		КаталогПрограммныхФайлов = ирОбщий.КаталогПрограммныхФайловОСЛкс(СтрокаСборкиПлатформы.x64);
		ПолноеИмяФайлаКонсоли = КаталогПрограммныхФайлов + СтрЗаменить("\1cv81\bin\1CV8 Servers.msc", "\", ирОбщий.РазделительПутиКФайлуЛкс());
		Файл = Новый Файл(ПолноеИмяФайлаКонсоли);
		Если Не Файл.Существует() Тогда
			ПолноеИмяФайлаКонсоли = "";
		КонецЕсли; 
	Иначе
		ПолноеИмяФайлаКонсоли = ирОбщий.КаталогОбщихФайловВсехВерсийПлатформыЛкс(СтрокаСборкиПлатформы.x64);
		Если СтрокаСборкиПлатформы.x64 Тогда
			ПолноеИмяФайлаКонсоли = ПолноеИмяФайлаКонсоли + "1CV8 Servers (x86-64).msc";
		Иначе
			ПолноеИмяФайлаКонсоли = ПолноеИмяФайлаКонсоли + "1CV8 Servers.msc";
		КонецЕсли; 
		Файл = Новый Файл(ПолноеИмяФайлаКонсоли);
		Если Не Файл.Существует() Тогда
			ПолноеИмяФайлаКонсоли = "";
		КонецЕсли; 
	КонецЕсли; 
	Если ЗначениеЗаполнено(ПолноеИмяФайлаКонсоли) Тогда
		Если ТаблицаСерверов <> Неопределено Тогда
			ТаблицаСерверов = ПолучитьТаблицуСерверовИзСпискаПользователя(ТаблицаСерверов);
			ПоместитьТаблицуСерверовВСписокПользователя(ТаблицаСерверов);
		КонецЕсли; 
		//ОбработкаРегистрации = ирОбщий.СоздатьОбъектПоИмениМетаданныхЛкс("Обработка.ирУправлениеCOMКлассами1С");
		//#Если Сервер И Не Сервер Тогда
		//	ОбработкаРегистрации = Обработки.ирУправлениеCOMКлассами1С.Создать();
		//#КонецЕсли
		//ОбработкаРегистрации.ЗаполнитьТипыCOMКлассов();
		//ОбработкаРегистрации.СборкиПлатформы.Загрузить(СборкиПлатформы.Выгрузить());
		СтрокаТипаКласса = ОбработкаРегистрации.ТипыComКлассов.Найти(ТипКласса, "Имя");
		ОбработкаРегистрации.ЗарегистрироватьCOMКлассСборкиПлатформы(СтрокаТипаКласса, СтрокаСборкиПлатформы.x64, СтрокаСборкиПлатформы.СборкаПлатформы);
		ЗапуститьПриложение("""" + ПолноеИмяФайлаКонсоли + """");
		Если ЗначениеЗаполнено(ИмяПользователя()) Тогда
			ТекстВБуферОбменаОСЛкс(ИмяПользователя(), "");
		КонецЕсли; 
	Иначе
		Если СтрокаСборкиПлатформы.x64 Тогда
			ПредставлениеРазрядности = "64";
		Иначе
			ПредставлениеРазрядности = "32";
		КонецЕсли; 
		Сообщить("Файл консоли серверов 1С " + ирКэш.НомерИзданияПлатформыЛкс() + " " + ПредставлениеРазрядности + "б не найден по пути """ + ПолноеИмяФайлаКонсоли + """");
	КонецЕсли;

КонецПроцедуры

Функция ОткрытьЗапросСУБДЛкс(ТекстЗапроса, ИмяЗапроса = "Запрос для отладки", Параметры = Неопределено, Автоподключение = Ложь) Экспорт
	
	КонсольЗапросов = ирОбщий.СоздатьОбъектПоИмениМетаданныхЛкс("Обработка.ирКонсольЗапросов");
	#Если Сервер И Не Сервер Тогда
		КонсольЗапросов = Обработки.ирКонсольЗапросов.Создать();
	#КонецЕсли
	КонсольЗапросов.ОткрытьЗапросБД(ТекстЗапроса, ИмяЗапроса, Параметры, Автоподключение);
	
КонецФункции

Процедура ЗапуститьПриложение1СЛкс(РежимКонфигуратора, СтрокаСоединения, ИмяВСпискеБазПользователя = "", ОткрытьПортативныеИнструменты = Истина) Экспорт 
	ПараметрыЗапуска = ирОбщий.ПараметрыЗапускаПриложения1СЛкс(,,, РежимКонфигуратора,,,,,, СтрокаСоединения, ОткрытьПортативныеИнструменты,,,,,, ИмяВСпискеБазПользователя);
	ирОбщий.ВыполнитьКомандуОСЛкс("""" + ирОбщий.ПолноеИмяИсполняемогоФайлаСтартераЛкс() + """ " + ПараметрыЗапуска);
КонецПроцедуры

Функция ПолучитьПолноеИмяФайлаСпискаСерверов1С() Экспорт 
	
	КаталогФайловыхКэшей = ирКэш.КаталогИзданияПлатформыВПрофилеЛкс();
	ПолноеИмяФайлаСпискаСерверов = КаталогФайловыхКэшей + ирОбщий.РазделительПутиКФайлуЛкс() + "appsrvrs.lst";
	Возврат ПолноеИмяФайлаСпискаСерверов;
	
КонецФункции

Функция ПолучитьТаблицуСерверовИзСпискаПользователя(ТаблицаСерверов = Неопределено) Экспорт 
	
	ТаблицаСерверовИзФайла = Новый ТаблицаЗначений;
	ТаблицаСерверовИзФайла.Колонки.Добавить("Протокол");
	ТаблицаСерверовИзФайла.Колонки.Добавить("Компьютер");
	ТаблицаСерверовИзФайла.Колонки.Добавить("НКомпьютер");
	ТаблицаСерверовИзФайла.Колонки.Добавить("Порт");
	ТаблицаСерверовИзФайла.Колонки.Добавить("Наименование");
	//ТаблицаСерверовИзФайла.Колонки.Добавить("ИзданиеПлатформы");
		ТаблицаСерверов.Колонки.Добавить("НКомпьютер");
		Для Каждого СтрокаСервера Из ТаблицаСерверов Цикл
			СтрокаСервера.НКомпьютер = НРег(СтрокаСервера.Компьютер);
		КонецЦикла;
		ПолноеИмяФайлаСпискаСерверов = ПолучитьПолноеИмяФайлаСпискаСерверов1С();
		Файл = Новый Файл(ПолноеИмяФайлаСпискаСерверов);
		Если Файл.Существует() Тогда
			ТекстовыйДокумент = Новый ТекстовыйДокумент;
			ТекстовыйДокумент.Прочитать(ПолноеИмяФайлаСпискаСерверов);
			ТекстФайла = ТекстовыйДокумент.ПолучитьТекст();
			// {2,
			// {"tcp","pcname",1540,""},
			// {"tcp","pcname",1740,""}
			// }
			ДокументDOM = ирОбщий.ДокументDOMИзСтрокиВнутрЛкс(ТекстФайла);
			РазыменовательПИ = Новый РазыменовательПространствИменDOM(ДокументDOM);
			ИмяЭлемента = "/elem/elem";
			РезультатXPath = ДокументDOM.ирОбщий.ВычислитьВыражениеXPath(ИмяЭлемента, ДокументDOM, РазыменовательПИ, ТипРезультатаDOMXPath.УпорядоченныйИтераторУзлов);
			Пока 1 = 1 Цикл
				Узел = РезультатXPath.ПолучитьСледующий();
				Если Узел = Неопределено Тогда
					Прервать;
				КонецЕсли;
				ДочерниеУзлы = Узел.ДочерниеУзлы;
				// Здесь есть пробельный узел, который сместит индексы н начиная с 2, если отключить игнорирование пробельных символов при построении документа DOM
				Порт = Вычислить(ДочерниеУзлы[2].ТекстовоеСодержимое);
				Компьютер = ирОбщий.ПоследнийФрагментЛкс(Вычислить(ДочерниеУзлы[1].ТекстовоеСодержимое), "/"); // Имя компьютера может быть указано в виде "REMOTE/GOMER"
				КлючПоиска = Новый Структура("НКомпьютер, Порт", НРег(Компьютер), Порт); 
				Если ТаблицаСерверовИзФайла.НайтиСтроки(КлючПоиска).Количество() > 0 Тогда
					Продолжить;
				КонецЕсли; 
				ОписаниеСервера = ТаблицаСерверовИзФайла.Добавить();
				ЗаполнитьЗначенияСвойств(ОписаниеСервера, КлючПоиска); 
				ОписаниеСервера.Протокол = Вычислить(ДочерниеУзлы[0].ТекстовоеСодержимое);
				ОписаниеСервера.Компьютер = Компьютер;
				ОписаниеСервера.Наименование = Вычислить(ДочерниеУзлы[3].ТекстовоеСодержимое);
				Если Не ЗначениеЗаполнено(ОписаниеСервера.Наименование) Тогда
					ОписаниеСервера.Наименование = ОписаниеСервера.Компьютер + ":" + XMLСтрока(ОписаниеСервера.Порт);
				КонецЕсли; 
				СтрокиСервера = ТаблицаСерверов.НайтиСтроки(Новый Структура("НКомпьютер, Порт", ОписаниеСервера.НКомпьютер, ОписаниеСервера.Порт));
			КонецЦикла;
		КонецЕсли;
		Если ТаблицаСерверов <> Неопределено Тогда
			Для Каждого СтрокаСервера Из ТаблицаСерверов Цикл
				СтрокаСервераИзФайла = ТаблицаСерверовИзФайла.Добавить();
				ЗаполнитьЗначенияСвойств(СтрокаСервераИзФайла, СтрокаСервера); 
				СтрокаСервераИзФайла.Протокол = "tcp";
			КонецЦикла;
		КонецЕсли; 
	Возврат ТаблицаСерверовИзФайла;
		
КонецФункции

Процедура ПоместитьТаблицуСерверовВСписокПользователя(ТаблицаСерверов) Экспорт

	#Если _ Тогда
		ТаблицаСерверов = Новый ТаблицаЗначений;
		ТаблицаСерверов.Колонки.Добавить("Протокол");
		ТаблицаСерверов.Колонки.Добавить("Компьютер");
		ТаблицаСерверов.Колонки.Добавить("Порт");
		ТаблицаСерверов.Колонки.Добавить("Наименование");
	#КонецЕсли
	// {2,
	// {"tcp","pyramid",1540,""},
	// {"tcp","pyramid",1740,""}
	// }
	Текст = "";
	Для Каждого СтрокаСервера Из ТаблицаСерверов Цикл
		Если Текст <> "" Тогда
			Текст = Текст + "," + Символы.ПС;
		КонецЕсли; 
		Текст = Текст + "{" 
			+ """" + СтрокаСервера.Протокол + ""","
			+ """" + СтрокаСервера.Компьютер + ""","
			+ XMLСтрока(СтрокаСервера.Порт) + ","
			+ """" + СтрокаСервера.Наименование + """"
			+ "}";
	КонецЦикла;
	Текст = "{" + XMLСтрока(ТаблицаСерверов.Количество()) + "," + Символы.ПС + Текст + "}";
	ПолноеИмяФайлаСпискаСерверов = ПолучитьПолноеИмяФайлаСпискаСерверов1С();
	Файл = Новый Файл(ПолноеИмяФайлаСпискаСерверов);
	ТекстовыйДокумент = Новый ТекстовыйДокумент;
	ТекстовыйДокумент.УстановитьТекст(Текст);
	ТекстовыйДокумент.Записать(ПолноеИмяФайлаСпискаСерверов);
	УстановитьТекущийПутьВДеревеКонсолиСерверов(ТаблицаСерверов);

КонецПроцедуры

Процедура УстановитьТекущийПутьВДеревеКонсолиСерверов(ТаблицаСерверов) Экспорт 
	
	МассивПути = ПолучитьМассивПутиКСсылкеВКонсолиСерверов();
	ПолноеИмяФайлаНастроекКонсолиСерверов = ирОбщий.КаталогПеремещаемыхДанныхПриложенийЛкс() + "\Microsoft\MMC\1CV8 Servers";
	ПолноеИмяФайлаНастроекКонсолиСерверов = СтрЗаменить(ПолноеИмяФайлаНастроекКонсолиСерверов, "\", ирОбщий.РазделительПутиКФайлуЛкс());
	Файл = Новый Файл(ПолноеИмяФайлаНастроекКонсолиСерверов);
	Если Не Файл.Существует() Тогда
		Возврат;
	КонецЕсли; 
	ДокументDOM = ирОбщий.ПрочитатьФайлВДокументDOMЛкс(ПолноеИмяФайлаНастроекКонсолиСерверов);
	РазыменовательПИ = Новый РазыменовательПространствИменDOM(ДокументDOM);
	ИмяЭлемента = "/MMC_ConsoleFile/Views/View/BookMark[2]";
	РезультатXPath = ДокументDOM.ирОбщий.ВычислитьВыражениеXPath(ИмяЭлемента, ДокументDOM, РазыменовательПИ);
	ЭлементДом = РезультатXPath.ПолучитьСледующий();
	КорневыеЭлементы = ЭлементДом.ПолучитьЭлементыПоИмени("DynamicPath");
	Если КорневыеЭлементы.Количество() > 0 Тогда
		КорневойЭлемент = КорневыеЭлементы[0];
	Иначе
		КорневойЭлемент = ДокументDOM.СоздатьЭлемент("DynamicPath");
		ЭлементДом.ДобавитьДочерний(КорневойЭлемент);
	КонецЕсли; 
	Пока КорневойЭлемент.ПервыйДочерний <> Неопределено Цикл
		КорневойЭлемент.УдалитьДочерний(КорневойЭлемент.ПервыйДочерний);
	КонецЦикла; 
	Для Каждого ЭлементПути Из МассивПути Цикл
		ЭлементСегмент = ДокументDOM.СоздатьЭлемент("Segment");
		ЭлементСегмент.УстановитьАтрибут("String", ЭлементПути);
		КорневойЭлемент.ДобавитьДочерний(ЭлементСегмент);
	КонецЦикла;
	ЗаписьXML = Новый ЗаписьXML;
	ЗаписьXML.ОткрытьФайл(ПолноеИмяФайлаНастроекКонсолиСерверов);
	ЗаписьДом = Новый ЗаписьDOM;
	ЗаписьДом.Записать(ДокументDOM, ЗаписьXML); 
	
КонецПроцедуры

Функция ПолучитьМассивПутиКСсылкеВКонсолиСерверов(Знач ИмяСервера = "")
	
	Если Не ЗначениеЗаполнено(ИмяСервера) Тогда
		ИмяСервера = ирОбщий.ИмяКомпьютераКластераЛкс();
	КонецЕсли; 
	Если Не ЗначениеЗаполнено(ИмяСервера) Тогда
		ИмяСервера = ИмяКомпьютера();
	КонецЕсли; 
	// <Segment String="(*)ServerName"/>
	// <Segment String="Кластеры"/>
	// <Segment String="Интеграция"/>
	// <Segment String="Информационные базы"/>
	// <Segment String="IBName"/>
	МассивПути = Новый Массив;
	ЭлементПути = ИмяСервера;
	Если ирОбщий.ЭтоИмяЛокальногоКомпьютераЛкс(ЭлементПути) Тогда
		ЭлементПути = "(*)" + ЭлементПути;
	КонецЕсли; 
	МассивПути.Добавить(ЭлементПути);
	Возврат МассивПути;

КонецФункции

Функция ОткрытьТаблицуЗначенийЛкс(Знач ТаблицаЗначений, Знач ТекущаяСтрока = Неопределено, Модально = Истина, Заголовок = "", РежимВыбора = Ложь, ТолькоПросмотр = Истина,
	ОтключитьОформление = Ложь, КлючУникальности = Неопределено) Экспорт 
	
	Если КлючУникальности = Неопределено Тогда
		КлючУникальности = ТаблицаЗначений;
	КонецЕсли;
	мПлатформа = ирКэш.Получить();
	#Если Сервер И Не Сервер Тогда
		мПлатформа = Обработки.ирПлатформа.Создать();
	#КонецЕсли
	ИмитаторТабличногоПоля = Новый Структура;
	ИмитаторТабличногоПоля.Вставить("Имя");
	ИмитаторТабличногоПоля.Вставить("ТекущаяКолонка");
	ИмитаторТабличногоПоля.Вставить("ТекущаяСтрока", ТекущаяСтрока);
	ИмитаторТабличногоПоля.Вставить("Значение", ТаблицаЗначений);
	ИмитаторТабличногоПоля.Вставить("ВыделенныеСтроки", Новый Массив);
	ИмитаторТабличногоПоля.Вставить("Подвал", Ложь);
	ФормаРедактирования = мПлатформа.ПолучитьФорму("ТаблицаЗначений", , КлючУникальности);
	ФормаРедактирования.ПараметрТабличноеПоле = ИмитаторТабличногоПоля;
	ФормаРедактирования.ПараметрОтключитьОформление = ОтключитьОформление;
	ФормаРедактирования.НачальноеЗначениеВыбора = ТаблицаЗначений;
	//ФормаРедактирования.КлючСохраненияПоложенияОкна = КлючСохраненияПоложенияОкна; // Программно добавленные колонки всегда НЕ сохраняются платформой
	ФормаРедактирования.ТолькоПросмотр = ТолькоПросмотр;
	Если ЗначениеЗаполнено(Заголовок) Тогда
		ФормаРедактирования.Заголовок = Заголовок;
	КонецЕсли; 
	ФормаРедактирования.РежимВыбора = РежимВыбора;
	Если Модально Тогда
		Результат = ФормаРедактирования.ОткрытьМодально();
	Иначе
		ФормаРедактирования.Открыть(); 
		Результат = ФормаРедактирования;
	КонецЕсли; 
	Возврат Результат;

КонецФункции

Функция ВыбратьЭлементСпискаЗначенийЛкс(Знач СписокЗначений, Знач ТекущийЭлемент = Неопределено, Модально = Истина, Заголовок = "", МножественныйВыбор = Ложь) Экспорт 
	
	мПлатформа = ирКэш.Получить();
	#Если Сервер И Не Сервер Тогда
		мПлатформа = Обработки.ирПлатформа.Создать();
	#КонецЕсли
	ФормаРедактирования = мПлатформа.ПолучитьФорму("СписокЗначений", , СписокЗначений);
	ФормаРедактирования.НачальноеЗначениеВыбора = СписокЗначений;
	ФормаРедактирования.НачальныйЭлементСписка = ТекущийЭлемент;
	ФормаРедактирования.МножественныйВыбор = МножественныйВыбор;
	Если ЗначениеЗаполнено(Заголовок) Тогда
		ФормаРедактирования.Заголовок = Заголовок;
	КонецЕсли; 
	ФормаРедактирования.РежимВыбора = Истина;
	Если Модально Тогда
		Результат = ФормаРедактирования.ОткрытьМодально();
	Иначе
		ФормаРедактирования.Открыть();
	КонецЕсли; 
	Возврат Результат;

КонецФункции

Функция ОткрытьСписокЗначенийЛкс(выхСписок, Знач СтруктураОтбора = Неопределено, Знач Заголовок = "") Экспорт 
	мПлатформа = ирКэш.Получить();
	#Если Сервер И Не Сервер Тогда
		мПлатформа = Обработки.ирПлатформа.Создать();
	#КонецЕсли
	ФормаРедактирования = мПлатформа.ПолучитьФорму("СписокЗначений");
	ФормаРедактирования.НачальноеЗначениеВыбора = выхСписок;
	ФормаРедактирования.СтруктураОтбора = СтруктураОтбора;   
	Если ЗначениеЗаполнено(Заголовок) Тогда
		ФормаРедактирования.Заголовок = Заголовок;
	КонецЕсли;
	РезультатФормы = ФормаРедактирования.ОткрытьМодально();
	Если РезультатФормы <> Неопределено Тогда 
		выхСписок = РезультатФормы;
		Возврат Истина;
	Иначе
		Возврат Ложь;
	КонецЕсли;
		
КонецФункции

Функция ОткрытьРедакторИзПоляТабличногоДокументаЛкс(ПолеТабличногоДокумента) Экспорт 
	
	Копия = Новый ТабличныйДокумент;
	Копия.Вывести(ПолеТабличногоДокумента);
	ЗаполнитьЗначенияСвойств(Копия, ПолеТабличногоДокумента); 
	Результат = ОткрытьЗначениеЛкс(Копия,,,, Ложь);
	Возврат Результат;

КонецФункции

Функция ОткрытьРедакторСтрокиТаблицыЛкс(ЭтаФорма, ТабличноеПоле, ИмяТаблицыБДТабличногоПоля = Неопределено, СвязиИПараметрыВыбора = Истина, Знач СтруктураВладельца = Неопределено) Экспорт 
	
	мПлатформа = ирКэш.Получить();
	#Если Сервер И Не Сервер Тогда
	    мПлатформа = Обработки.ирПлатформа.Создать();
	#КонецЕсли
	Форма = мПлатформа.ПолучитьФорму("СтрокаТаблицы", ЭтаФорма, ТабличноеПоле);
	Форма.ИмяТаблицыБД = ИмяТаблицыБДТабличногоПоля;
	Форма.СвязиИПараметрыВыбора = СвязиИПараметрыВыбора;
	Форма.СтруктураВладельца = СтруктураВладельца;
	Форма.Открыть();
	Возврат Форма;

КонецФункции

Процедура ОткрытьФайлВПроводникеЛкс(Знач ИмяФайла) Экспорт 
	
	ЗапуститьПриложение("explorer /select, """ + ИмяФайла + """");

КонецПроцедуры

// Результат - Булево - Истина если значение было изменено
Функция ЯчейкаТабличногоПоляРасширенногоЗначения_ВыборЛкс(ЭтаФорма, ТабличноеПоле, СтандартнаяОбработка = Ложь, РасширенноеЗначение = Null,
	РедактированиеРазрешено = Истина, ПринудительноВОтдельнойФорме = Ложь, Данные = "", Знач Заголовок = "", Знач СтрокаПоиска = "") Экспорт 

	Если ТипЗнч(ТабличноеПоле) = Тип("ТабличноеПоле") Тогда
		Колонка = ТабличноеПоле.ТекущаяКолонка;
		ЭлементУправления = Колонка.ЭлементУправления;
	Иначе
		Колонка = ТабличноеПоле.ТекущийЭлемент;
		ЭлементУправления = Колонка;
	КонецЕсли; 
	Если Не ЗначениеЗаполнено(Данные) Тогда
		Данные = ирОбщий.ПутьКДаннымКолонкиТабличногоПоляЛкс(ТабличноеПоле);
	КонецЕсли; 
	Если РасширенноеЗначение = Null Тогда
		Если Не ЗначениеЗаполнено(Данные) Тогда
			Возврат Ложь;
		КонецЕсли; 
		РасширенноеЗначение = ТабличноеПоле.ТекущиеДанные[Данные];
	КонецЕсли;
	КлючУникальности = ""; 
	Если ТабличноеПоле.ТекущаяСтрока <> Неопределено Тогда 
		ДобавитьКлючСтрокиВЗаголовок = Ложь;
		Если ТипЗнч(ТабличноеПоле) = Тип("ТабличноеПоле") Тогда
			ОформлениеСтроки = ТабличноеПоле.ОформлениеСтроки(ТабличноеПоле.ТекущаяСтрока);
			Ячейка = ОформлениеСтроки.Ячейки[Колонка.Имя];
			РедактированиеРазрешено = РедактированиеРазрешено И Не Ячейка.ТолькоПросмотр;
			Если Не ЗначениеЗаполнено(Заголовок) Тогда
				Заголовок = Колонка.ТекстШапки;
				ДобавитьКлючСтрокиВЗаголовок = Истина;
			КонецЕсли;
			Попытка
				КлючУникальности = ТабличноеПоле.Значение.Индекс(ТабличноеПоле.ТекущаяСтрока);
			Исключение
			КонецПопытки;
		Иначе
			Если Не ЗначениеЗаполнено(Заголовок) Тогда
				Заголовок = Колонка.Заголовок;
				ДобавитьКлючСтрокиВЗаголовок = Истина;
			КонецЕсли;
			Попытка
				КлючУникальности = ТабличноеПоле.ПолучитьИдентификатор(ТабличноеПоле.ТекущаяСтрока);
			Исключение
			КонецПопытки;
		КонецЕсли; 
		Если ДобавитьКлючСтрокиВЗаголовок И КлючУникальности <> "" Тогда
			КлючУникальности = Формат(КлючУникальности, "ЧН=");
			Заголовок = Заголовок + " [" + КлючУникальности + "]";
		КонецЕсли;
		КлючУникальности = "" + ирОбщий.ИдентификаторФормыЛкс(ЭтаФорма) + ";" + Колонка.Имя + ";" + КлючУникальности;
	КонецЕсли; 
	РедактированиеРазрешено = Истина
		И РедактированиеРазрешено
		И Не ТабличноеПоле.ТолькоПросмотр
		И Не Колонка.ТолькоПросмотр
		И (Ложь
			Или ЭлементУправления = Неопределено
			Или ТипЗнч(ЭлементУправления) = Тип("Флажок")
			Или Не ЭлементУправления.ТолькоПросмотр);
	Если РедактированиеРазрешено И ПринудительноВОтдельнойФорме Тогда
		мПлатформа = ирКэш.Получить();
		#Если Сервер И Не Сервер Тогда
			мПлатформа = Обработки.ирПлатформа.Создать();
		#КонецЕсли
		СтруктураТипа = мПлатформа.СтруктураТипаИзЗначения(РасширенноеЗначение);
		Попытка
			СвойствоГлобальногоКонтекста = Вычислить(СтруктураТипа.ИмяОбщегоТипа);
		Исключение
			СвойствоГлобальногоКонтекста = Неопределено;
		КонецПопытки; 
		Если Истина
			И СвойствоГлобальногоКонтекста <> Неопределено 
			И СвойствоГлобальногоКонтекста <> Null 
		Тогда
			мПлатформа.ИнициализацияОписанияМетодовИСвойств();
			СписокВыбора = Новый СписокЗначений;
			#Если Сервер И Не Сервер Тогда
				СписокВыбора = Новый СписокЗначений;
			#КонецЕсли
			НачальныйВыбор = Неопределено;
			СтрокиЗначений = мПлатформа.ТаблицаКонтекстов.НайтиСтроки(Новый Структура("ТипКонтекста, ЯзыкПрограммы", "Перечисление" + СтруктураТипа.ИмяОбщегоТипа, 0));
			Для Каждого СтрокаЗначения Из СтрокиЗначений Цикл
				ЗначениеПеречисления = Вычислить(СтруктураТипа.ИмяОбщегоТипа + "." + СтрокаЗначения.Слово);
				ЭлементСписка = СписокВыбора.Добавить(ЗначениеПеречисления);
				Если РасширенноеЗначение = ЗначениеПеречисления Тогда
					НачальныйВыбор = ЭлементСписка;
				КонецЕсли; 
			КонецЦикла;
			Если СписокВыбора.Количество() > 0 Тогда
				РезультатВыбора = ЭтаФорма.ВыбратьИзСписка(СписокВыбора, ЭлементУправления, НачальныйВыбор);
				Результат = РезультатВыбора <> Неопределено;
				Если Результат Тогда
					РасширенноеЗначение = РезультатВыбора.Значение;
				КонецЕсли; 
				СтандартнаяОбработка = Ложь;
			КонецЕсли; 
		КонецЕсли; 
	КонецЕсли;
	Если Результат = Неопределено Тогда
		Если Не ЗначениеЗаполнено(СтрокаПоиска) Тогда
			СтрокаПоиска = ТабличноеПолеСтрокаПоискаЛкс(ЭтаФорма, ТабличноеПоле);
		КонецЕсли;
		Результат = ОткрытьЗначениеЛкс(РасширенноеЗначение, РедактированиеРазрешено, СтандартнаяОбработка, Заголовок,, ПринудительноВОтдельнойФорме,, ТабличноеПоле, СтрокаПоиска, КлючУникальности);
	КонецЕсли; 
	Если Результат Тогда
		НовоеЗначение = РасширенноеЗначение; // Сохраняем значение, т.к. оно может испортиться следующей строкой
		ИнтерактивноЗаписатьВКолонкуТабличногоПоляЛкс(ТабличноеПоле, Колонка, НовоеЗначение); // Почему то запрещенные для поля ввода значения здесь превращаются в строку (например МоментВремени, УникальныйИдентификатор)
		РасширенноеЗначение = НовоеЗначение;
	КонецЕсли; 
	Возврат Результат;

КонецФункции

// Результат - Булево - Истина если значение было изменено
Функция ПолеВводаРасширенногоЗначения_НачалоВыбораЛкс(Знач Элемент, СтандартнаяОбработка, РасширенноеЗначение = Null, Знач СтруктураОтбора = Неопределено) Экспорт
	
	Если РасширенноеЗначение = Null Тогда
		РасширенноеЗначение = Элемент.Значение;
	КонецЕсли; 
	ЗначениеИзменено = Ложь;
	Если РасширенноеЗначение = Неопределено Тогда
		СтандартнаяОбработка = Ложь;
		ОграничениеТипа = ирОбщий.ПересечьОписанияТиповЛкс(Элемент.ОграничениеТипа, Элемент.ТипЗначения);
		НовыйТипИлиЗначение = ВыбратьРедактируемыйТипЛкс(ОграничениеТипа);
		Если НовыйТипИлиЗначение <> Неопределено Тогда
			Если ТипЗнч(НовыйТипИлиЗначение) = Тип("Тип") Тогда
				МассивТипов = ирОбщий.ЗначенияВМассивЛкс(НовыйТипИлиЗначение);
				НовоеОписаниеТипов = Новый ОписаниеТипов(МассивТипов);
				НовоеЗначение = НовоеОписаниеТипов.ПривестиЗначение(Неопределено);
			Иначе
				НовоеЗначение = НовыйТипИлиЗначение;
			КонецЕсли; 
			РасширенноеЗначение = НовоеЗначение;
			Элемент.Значение = РасширенноеЗначение; //
			ЗначениеИзменено = Истина;
		КонецЕсли;
	Иначе
		Если Истина
			И ТипЗнч(Элемент) = Тип("ПолеВвода") 
			И ТипЗнч(Элемент.Значение) = Тип("СписокЗначений") 
			И ТипЗнч(РасширенноеЗначение) = Тип("СписокЗначений") 
		Тогда
			РасширенноеЗначение.ТипЗначения = Элемент.ТипЗначенияСписка;
		КонецЕсли;
		Если ТипЗнч(РасширенноеЗначение) = Тип("Булево") Тогда
			РасширенноеЗначение = Не РасширенноеЗначение;
			ЗначениеИзменено = Истина;
			СтандартнаяОбработка = Ложь;
		ИначеЕсли Истина
			И ТипЗнч(РасширенноеЗначение) <> Тип("Дата")
			И ТипЗнч(РасширенноеЗначение) <> Тип("Число")
			И Не ирОбщий.ЛиСсылкаНаОбъектБДЛкс(РасширенноеЗначение, Ложь)
		Тогда
			ЗначениеИзменено = ОткрытьЗначениеЛкс(РасширенноеЗначение, Истина, СтандартнаяОбработка);
			Если ЗначениеИзменено И ТипЗнч(Элемент) = Тип("ПолеВвода") Тогда
				Элемент.Значение = РасширенноеЗначение;
			КонецЕсли; 
		КонецЕсли;
		// Вредно для колонки вариантов значений в таблице параметров в консоли кода при отмене редактирования нового списка
		//Если Не СтандартнаяОбработка Тогда
		//	Элемент.Значение = РасширенноеЗначение;
		//КонецЕсли; 
		Если СтандартнаяОбработка Тогда
			ОткрытьФормуВыбораСсылкиЛкс(РасширенноеЗначение, СтруктураОтбора, Элемент, СтандартнаяОбработка);
		КонецЕсли;
	КонецЕсли;
	Возврат ЗначениеИзменено;
	
КонецФункции

// Результат - Булево - Истина если значение было изменено
Функция ПолеВводаКолонкиРасширенногоЗначения_НачалоВыбораЛкс(ЭтаФорма, ТабличноеПоле, СтандартнаяОбработка, РасширенноеЗначение = Null, ИспользоватьОграничениеТипа = Ложь,
	СтруктураОтбора = Неопределено, Данные = "", Знач СтрокаПоиска = "", Знач Заголовок = "") Экспорт
	
	Если ТипЗнч(ТабличноеПоле) = Тип("ТабличноеПоле") Тогда
		Колонка = ТабличноеПоле.ТекущаяКолонка;
		ЭлементУправления = Колонка.ЭлементУправления;
	Иначе
		Колонка = ТабличноеПоле.ТекущийЭлемент;
		ЭлементУправления = Колонка;
	КонецЕсли; 
	Если Не ЗначениеЗаполнено(Данные) Тогда
		Данные = ирОбщий.ПутьКДаннымКолонкиТабличногоПоляЛкс(ТабличноеПоле);
		РазрешитьВыборТипа = Истина;
	Иначе
		РазрешитьВыборТипа = Ложь;
	КонецЕсли; 
	Если РасширенноеЗначение = Null Тогда
		РасширенноеЗначение = ДанныеСтрокиТабличногоПоляЛкс(ТабличноеПоле)[Данные];
	КонецЕсли; 
	ЗначениеИзменено = Ложь;
	Если РасширенноеЗначение = Неопределено Или РасширенноеЗначение = Null Тогда
		Если Не РазрешитьВыборТипа Тогда
			Возврат ЗначениеИзменено;
		КонецЕсли; 
		СтандартнаяОбработка = Ложь;
		ОграничениеТипа = Неопределено;
		Если ИспользоватьОграничениеТипа Тогда
			ОграничениеТипа = ЭлементУправления.ОграничениеТипа;
			Если Истина
				И ОграничениеТипа.Типы().Количество() = 0 
				И ТипЗнч(ЭлементУправления) = Тип("ПолеФормы")
				И ЗначениеЗаполнено(ЭлементУправления.СвязьПоТипу.ПутьКДанным) 
			Тогда
				ЭтаФорма = ирОбщий.РодительЭлементаУправляемойФормыЛкс(ЭлементУправления);
				Попытка
					ОграничениеТипа = Вычислить("ЭтаФорма." + ЭлементУправления.СвязьПоТипу.ПутьКДанным);
				Исключение
					ВызватьИсключение "Ошибка вычисления влияющего типа поля: " + ОписаниеОшибки();
				КонецПопытки; 
			КонецЕсли; 
			Если ОграничениеТипа.Типы().Количество() = 0 Тогда
				ОграничениеТипа = ирОбщий.ТипЗначенияЭлементаФормыЛкс(ЭлементУправления); // Очень большое количество типов будет замедлять работу формы выбора типа https://www.hostedredmine.com/issues/923113
			КонецЕсли; 
		КонецЕсли; 
		НовыйТипИлиЗначение = ВыбратьРедактируемыйТипЛкс(ОграничениеТипа,,,,, Заголовок);
		Если НовыйТипИлиЗначение <> Неопределено Тогда
			Если ТипЗнч(НовыйТипИлиЗначение) = Тип("Тип") Тогда
				МассивТипов = ирОбщий.ЗначенияВМассивЛкс(НовыйТипИлиЗначение);
				НовоеОписаниеТипов = Новый ОписаниеТипов(МассивТипов);
				НовоеЗначение = НовоеОписаниеТипов.ПривестиЗначение(Неопределено);
			Иначе
				НовоеЗначение = НовыйТипИлиЗначение;
			КонецЕсли; 
			ИнтерактивноЗаписатьВКолонкуТабличногоПоляЛкс(ТабличноеПоле, Колонка, НовоеЗначение); // Почему то запрещенные для поля ввода значения здесь превращаются в строку (например МоментВремени)
			РасширенноеЗначение = НовоеЗначение; 
			ЗначениеИзменено = Истина;
			//// http://www.hostedredmine.com/issues/884276
			//ОткрытьФормуВыбораСсылкиЛкс(РасширенноеЗначение, СтруктураОтбора, ЭлементУправления);
		КонецЕсли;
	КонецЕсли; 
	Если РасширенноеЗначение <> Неопределено Тогда
		ДанныеТабличногоПоля = ирОбщий.ДанныеЭлементаФормыЛкс(ТабличноеПоле);
		Если ТипЗнч(ДанныеТабличногоПоля) = Тип("ОтборКомпоновкиДанных") Тогда
			#Если Сервер И Не Сервер Тогда
				ДанныеТабличногоПоля = Новый ОтборКомпоновкиДанных;
			#КонецЕсли
			ДоступноеПолеОтбора = ДанныеТабличногоПоля.ДоступныеПоляОтбора.НайтиПоле(ТабличноеПоле.ТекущиеДанные.ЛевоеЗначение);
			Если ДоступноеПолеОтбора <> Неопределено Тогда
				СтруктураОтбора = СтруктураОтбораЗначенийДоступногоПоляКомпоновкиЛкс(ДоступноеПолеОтбора);
			КонецЕсли;
		КонецЕсли;
		Если ТипЗнч(РасширенноеЗначение) = Тип("СписокЗначений") Тогда
			СтандартнаяОбработка = Ложь;
			ЗначениеИзменено = ОткрытьСписокЗначенийЛкс(РасширенноеЗначение, СтруктураОтбора, Заголовок);
			Если ЗначениеИзменено Тогда
				ИнтерактивноЗаписатьВКолонкуТабличногоПоляЛкс(ТабличноеПоле, Колонка, РасширенноеЗначение); // Нужно для управляемой формы https://www.hostedredmine.com/issues/956333
			КонецЕсли;
		Иначе
			Если Истина
				И Не ирОбщий.ЛиСсылкаНаОбъектБДЛкс(РасширенноеЗначение, Ложь)
				И ТипЗнч(РасширенноеЗначение) <> Тип("ПорядокКомпоновкиДанных")
				И ТипЗнч(РасширенноеЗначение) <> Тип("ОтборКомпоновкиДанных")
				И ТипЗнч(РасширенноеЗначение) <> Тип("УсловноеОформлениеКомпоновкиДанных")
				И ТипЗнч(РасширенноеЗначение) <> Тип("СтруктураНастроекКомпоновкиДанных")
			Тогда
				ЗначениеИзменено = ЯчейкаТабличногоПоляРасширенногоЗначения_ВыборЛкс(ЭтаФорма, ТабличноеПоле, СтандартнаяОбработка, РасширенноеЗначение, Истина, Истина, Данные, Заголовок, СтрокаПоиска) Или ЗначениеИзменено;
			КонецЕсли; 
		КонецЕсли;
		//Если ЗначениеИзменено Тогда
		Если Не СтандартнаяОбработка И ЗначениеЗаполнено(Данные) Тогда
			ТабличноеПоле.ТекущиеДанные[Данные] = РасширенноеЗначение;//
		КонецЕсли; 
		Если СтандартнаяОбработка Тогда
			ОткрытьФормуВыбораСсылкиЛкс(РасширенноеЗначение, СтруктураОтбора, ЭлементУправления, СтандартнаяОбработка);
		КонецЕсли;
	КонецЕсли;
	Возврат ЗначениеИзменено;
	
КонецФункции

Процедура ОткрытьФормуВыбораСсылкиЛкс(Знач РасширенноеЗначение, Знач СтруктураОтбора, Знач ЭлементУправления, СтандартнаяОбработка) Экспорт 
	
	Если ирОбщий.ЛиСсылкаНаОбъектБДЛкс(РасширенноеЗначение, Ложь) Тогда
		ОткрытьФормуСпискаЛкс(ирОбщий.ПолучитьПолноеИмяМДТипаЛкс(ТипЗнч(РасширенноеЗначение)), СтруктураОтбора,, ЭлементУправления, Истина,, РасширенноеЗначение);
		СтандартнаяОбработка = Ложь;
	КонецЕсли;

КонецПроцедуры

Функция СтруктураОтбораЗначенийДоступногоПоляКомпоновкиЛкс(Знач ДоступноеПолеОтбора) Экспорт 
	
	МетаданныеРеквизита = СтруктураСвязейИПараметровВыбораЛкс();
	МетаданныеРеквизита.ПараметрыВыбора = ДоступноеПолеОтбора.ПолучитьПараметрыВыбора();
	СтруктураОтбора = СтруктураОтбораПоСвязямИПараметрамВыбораЛкс(МетаданныеРеквизита);
	Возврат СтруктураОтбора;

КонецФункции

Функция СтруктураСвязейИПараметровВыбораЛкс() Экспорт 
	
	МетаданныеРеквизита = Новый Структура("ПараметрыВыбора, СвязиПараметровВыбора", Новый Массив, Новый Массив);
	Возврат МетаданныеРеквизита;

КонецФункции

// Получить структуру отбора по связям И параметрам выбора
//
// Параметры:
//  ЭтотОбъект						 - 	 - <тип> -
//  ПолеФормыИлиРеквизитМетаданных	 - 	 - <тип> -
//  СтруктураТЧ						 - Структура - один элемент, ключ не играет роли (оставлено для совместимости)
//  ДляОчистки						 - 	 - <тип>, Ложь -
// 
// Возвращаемое значение:
//   - 
//
Функция СтруктураОтбораПоСвязямИПараметрамВыбораЛкс(ПолеФормыИлиРеквизитМетаданных, ЭтотОбъект = Неопределено, СтруктураТЧ = Неопределено, ДляОчистки = Ложь) Экспорт

	Попытка
		СвязиПараметровВыбора = ПолеФормыИлиРеквизитМетаданных.СвязиПараметровВыбора;
	Исключение
		Возврат Новый Структура();
	КонецПопытки; 
	ПараметрыВыбора = ПолеФормыИлиРеквизитМетаданных.ПараметрыВыбора;
	Результат = Новый Структура("Отбор", Новый Структура);
	Для Каждого СвязьПараметраВыбора Из СвязиПараметровВыбора Цикл
		#Если Сервер И Не Сервер Тогда
		    СвязьПараметраВыбора = Новый СвязьПараметраВыбора;
		#КонецЕсли
		Если Истина
			И ДляОчистки
			И СвязьПараметраВыбора.ИзменениеЗначения = РежимИзмененияСвязанногоЗначения.НеИзменять
		Тогда
			Продолжить;
		КонецЕсли;
		ПолныйПутьКДанным = "ЭтотОбъект." + СвязьПараметраВыбора.ПутьКДанным;
		Если СтруктураТЧ <> Неопределено Тогда
			КлючИЗначениеТЧ = Неопределено;
			Для Каждого КлючИЗначение Из СтруктураТЧ Цикл
				КлючИЗначениеТЧ = КлючИЗначение;
				Прервать;
			КонецЦикла;
			//Если ирОбщий.СтрокиРавныЛкс(ирОбщий.ПервыйФрагментЛкс(СвязьПараметраВыбора.ПутьКДанным), КлючИЗначениеТЧ.Ключ) Тогда
			//	ПолныйПутьКДанным = "СтруктураТЧ." + СвязьПараметраВыбора.ПутьКДанным;
			//КонецЕсли;
			Если СтрЧислоВхождений(СвязьПараметраВыбора.ПутьКДанным, ".") = 1 Тогда
				ПолныйПутьКДанным = "СтруктураТЧ." + КлючИЗначениеТЧ.Ключ + "." + ирОбщий.ПоследнийФрагментЛкс(СвязьПараметраВыбора.ПутьКДанным);
			КонецЕсли; 
		КонецЕсли; 
		Попытка
			ЗначениеДанных = Вычислить(ПолныйПутьКДанным);
		Исключение
			// Например поле таблицы или на сервере текущая строка таблицы
			Продолжить;
		КонецПопытки; 
		ирОбщий.УстановитьВложенноеСвойствоСтруктурыЛкс(Результат, СвязьПараметраВыбора.Имя, ЗначениеДанных);
	КонецЦикла;
	Для Каждого ПараметрВыбора Из ПараметрыВыбора Цикл
		#Если Сервер И Не Сервер Тогда
		    ПараметрВыбора = Новый ПараметрВыбора;
		#КонецЕсли
		ирОбщий.УстановитьВложенноеСвойствоСтруктурыЛкс(Результат, ПараметрВыбора.Имя, ПараметрВыбора.Значение);
	КонецЦикла;
	Результат = Результат.Отбор; // Возможно потом перейдем везде на передачу полной структуры
	Возврат Результат;

КонецФункции

// .
// Параметры:
//    ЭтаФорма - Форма - 
//    ТабличноеПоле - ТабличноеПоле - 
//    ИмяКолонкиИмениРеквизита - Примитивный - 
//    ПолноеИмяТаблицы - Строка - 
//    СвязиИПараметрыВыбора - Булево - 
//    СтандартнаяОбработка - Булево - 
Функция ПолеВводаКолонкиЗначенияРеквизита_НачалоВыбораЛкс(ЭтаФорма, ТабличноеПоле, ПолноеИмяТаблицы, ИмяКолонкиИмениРеквизита = "Имя", ИмяКолонкиЗначения = "Значение",
	СвязиИПараметрыВыбора = Истина, СтандартнаяОбработка = Истина, Ссылка = Неопределено, Знач ВладелецТЧ = Неопределено, Знач СтрокаПоиска = "") Экспорт 
	
	Заголовок = ТабличноеПоле.ТекущиеДанные[ИмяКолонкиИмениРеквизита]; 
	Если СвязиИПараметрыВыбора Тогда
		СтруктураОтбора = ПолеВводаКолонкиЗначенияРеквизита_ОтборВыбораЛкс(ТабличноеПоле, ПолноеИмяТаблицы, ИмяКолонкиИмениРеквизита, ИмяКолонкиЗначения, Ссылка, ВладелецТЧ);
		ТекущиеДанные = ТабличноеПоле.ТекущаяСтрока;
		Если ЗначениеЗаполнено(ТекущиеДанные.ДопРеквизит) Тогда
			ДопРеквизит = ТекущиеДанные.ДопРеквизит;
			#Если Сервер И Не Сервер Тогда
				ДопРеквизит = ПланыВидовХарактеристик.ДополнительныеРеквизитыИСведения.ПустаяСсылка();
			#КонецЕсли
			ПриведенноеЗначение = ДопРеквизит.ТипЗначения.ПривестиЗначение(ТекущиеДанные[ИмяКолонкиЗначения]);
			Если ПриведенноеЗначение <> ТекущиеДанные[ИмяКолонкиЗначения] Тогда
				СтандартнаяОбработка = Ложь;
				ИнтерактивноЗаписатьВКолонкуТабличногоПоляЛкс(ТабличноеПоле, ТабличноеПоле.Колонки[ИмяКолонкиЗначения], ПриведенноеЗначение);
				Возврат Ложь;
			КонецЕсли; 
		КонецЕсли; 
	КонецЕсли; 
	УспехВыбора = ПолеВводаКолонкиРасширенногоЗначения_НачалоВыбораЛкс(ЭтаФорма, ТабличноеПоле, СтандартнаяОбработка, , Истина, СтруктураОтбора,, СтрокаПоиска, Заголовок);
	Возврат УспехВыбора;
КонецФункции 

Функция ПолеВводаКолонкиЗначенияРеквизита_ОкончаниеВводаТекстаЛкс(ЭтаФорма, ТабличноеПоле, ПолноеИмяТаблицы, ИмяКолонкиИмениРеквизита = "Имя", ИмяКолонкиЗначения = "Значение",
	СвязиИПараметрыВыбора = Истина, Знач Текст = "", Значение = Неопределено, СтандартнаяОбработка = Истина, Ссылка = Неопределено, Знач ВладелецТЧ = Неопределено, ТекстАвтоПодбора = Неопределено) Экспорт 
	
	Заголовок = ТабличноеПоле.ТекущиеДанные[ИмяКолонкиИмениРеквизита]; 
	Если СвязиИПараметрыВыбора Тогда
		СтруктураОтбора = ПолеВводаКолонкиЗначенияРеквизита_ОтборВыбораЛкс(ТабличноеПоле, ПолноеИмяТаблицы, ИмяКолонкиИмениРеквизита, ИмяКолонкиЗначения, Ссылка, ВладелецТЧ);
	КонецЕсли; 
	ПолеВвода_ОкончаниеВводаТекстаЛкс(ТабличноеПоле.Колонки[ИмяКолонкиЗначения].ЭлементУправления, Текст, Значение, СтандартнаяОбработка, ТабличноеПоле.ТекущиеДанные[ИмяКолонкиЗначения],,, СтруктураОтбора, ТекстАвтоПодбора);
КонецФункции

// Функция - Поле ввода колонки значения реквизита отбор выбора лкс
//
// Параметры:
//  ТабличноеПоле			 - 	 - 
//  ПолноеИмяТаблицы		 - 	 - 
//  ИмяКолонкиИмениРеквизита - 	 - 
//  ИмяКолонкиЗначения		 - 	 - 
//  Ссылка					 - 	 - 
//  ВладелецТЧ				 - Ссылка, Структура - 
// 
// Возвращаемое значение:
//   Структура - отбор для выбора ссылочного значения
//
Функция ПолеВводаКолонкиЗначенияРеквизита_ОтборВыбораЛкс(Знач ТабличноеПоле, Знач ПолноеИмяТаблицы, Знач ИмяКолонкиИмениРеквизита = "Имя", Знач ИмяКолонкиЗначения = "Значение",
	Знач Ссылка = Неопределено, Знач ВладелецТЧ = Неопределено) Экспорт
	
	ПоляТаблицыБД = ирКэш.ПоляТаблицыБДЛкс(ПолноеИмяТаблицы);
	ТекущиеДанные = ТабличноеПоле.ТекущаяСтрока;
	ПолеТаблицы = ПоляТаблицыБД.Найти(ТекущиеДанные[ИмяКолонкиИмениРеквизита], "Имя");
	Если ПолеТаблицы <> Неопределено Тогда
		#Если Сервер И Не Сервер Тогда
			ПолеТаблицы = Обработки.ирТипПолеБД.Создать();
		#КонецЕсли
		МетаРеквизит = ПолеТаблицы.Метаданные;
		СтруктураРеквизитов = Новый Структура;
		Для Каждого СтрокаРеквизита Из ТабличноеПоле.Значение Цикл
			ИмяРеквизита = СтрокаРеквизита[ИмяКолонкиИмениРеквизита];
			Если Не ирОбщий.ЛиИмяПеременнойЛкс(ИмяРеквизита) Тогда
				// Доп. реквизит БСП
				Продолжить;
			КонецЕсли; 
			ЗначениеРеквизита = СтрокаРеквизита[ИмяКолонкиЗначения];
			Если ИмяРеквизита = "ИдентификаторСсылкиЛкс" Тогда
				ИмяРеквизита = "Ссылка";
				ЗначениеРеквизита = Ссылка;
			КонецЕсли; 
			СтруктураРеквизитов.Вставить(ИмяРеквизита, ЗначениеРеквизита);
		КонецЦикла;
		Если ирОбщий.ЛиТипВложеннойТаблицыБДЛкс(ирОбщий.ТипТаблицыБДЛкс(ПолноеИмяТаблицы)) Тогда
			ОсновныеДанные = ВладелецТЧ;
			СтруктураТЧ = Новый Структура(ирОбщий.ПоследнийФрагментЛкс(ПолноеИмяТаблицы), СтруктураРеквизитов);
		Иначе
			ОсновныеДанные = СтруктураРеквизитов;
			СтруктураТЧ = Неопределено;
		КонецЕсли; 
		СтруктураОтбора = СтруктураОтбораПоСвязямИПараметрамВыбораЛкс(МетаРеквизит, ОсновныеДанные, СтруктураТЧ);
	ИначеЕсли ЗначениеЗаполнено(ТекущиеДанные.ДопРеквизит) Тогда
		ДопРеквизит = ТекущиеДанные.ДопРеквизит;
		#Если Сервер И Не Сервер Тогда
			ДопРеквизит = ПланыВидовХарактеристик.ДополнительныеРеквизитыИСведения.ПустаяСсылка();
		#КонецЕсли
		СтруктураОтбора = Новый Структура("Владелец", ДопРеквизит);
	КонецЕсли;
	Возврат СтруктураОтбора;

КонецФункции

Процедура ПолеВводаПорядкаРеквизитовИнициироватьЛкс(ПолеВвода, ИмяКолонкиИмениРеквизита = "ИмяРеквизита") Экспорт 
	СписокВыбора = ПолеВвода.СписокВыбора;
	СписокВыбора.Добавить("ПорядокРоли, " + ИмяКолонкиИмениРеквизита, "Роль, Имя/Представление");
	СписокВыбора.Добавить("Порядок, " + ИмяКолонкиИмениРеквизита, "Метаданные");
	СписокВыбора.Добавить(ИмяКолонкиИмениРеквизита, "Имя/Представление");
	ПолеВвода.Значение = СписокВыбора[0].Значение;
КонецПроцедуры

// Вызывать после установки признака ТолькоПросмотр ячеек.
//
// Параметры:
//  ЭтаФорма								 - 		 - 
//  Элемент									 - 	 - 
//  ОформлениеСтроки						 - 		 - 
//  ДанныеСтроки							 - 		 - 
//  КнопкаРежимаОтображения					 - 		 - 
//  КолонкиСПиктограммамиТипов				 - Строка, Структура - 
//  РасширенныеКолонки						 - Структура		 - 
//  РасширенноеПредставлениеХранилищЗначений - 					 - 
//  РасширенныеДанныеСтроки					 - 					 - 
//  КолонкиДляРежимаОтображения				 - 					 - 
//  РасширенноеПредставлениеДат				 - Булево - введен для ускорения 
//
Процедура ТабличноеПолеПриВыводеСтрокиЛкс(Знач ЭтаФорма, Знач Элемент, Знач ОформлениеСтроки, Знач ДанныеСтроки, Знач КнопкаРежимаОтображения = Неопределено, Знач КолонкиСПиктограммамиТипов = "",
	Знач РасширенныеКолонки = Неопределено, Знач РасширенноеПредставлениеХранилищЗначений = Ложь, Знач РасширенныеДанныеСтроки = Неопределено, Знач КолонкиДляРежимаОтображения = Неопределено,
	Знач РасширенноеПредставлениеДат = Ложь, Знач КлючСтроки = Неопределено) Экспорт 

	#Если Сервер И Не Сервер Тогда
		Элемент = Новый ТабличноеПоле;
	#КонецЕсли
	Если Ложь
		Или ДанныеСтроки = Неопределено 
		Или ирКэш = Неопределено // Портативный режим при закрытии всех форм http://devtool1c.ucoz.ru/forum/2-1616-1
	Тогда
		Возврат;
	КонецЕсли; 
	ДопСвойства = ДопСвойстваЭлементаФормыЛкс(ЭтаФорма, Элемент);
	Если ДопСвойства.ЗапретОтображения = Истина Тогда
		Возврат;
	КонецЕсли;
	Если ДопСвойства.ЗапретРазметкиВхождений <> Истина Тогда
		ШаблонРазметкиВхождений = ирОбщий.ШаблонРазметкиВхожденийЛкс();
		МенеджерПоиска = ДопСвойства.МенеджерПоиска;
		ПрефиксСтрокиПоиска = "";
		Если МенеджерПоиска <> Неопределено Тогда
			ПрефиксСтрокиПоиска = МенеджерПоиска.ПрефиксСтрокиПоиска;
			Если МенеджерПоиска.НайденныеСтроки.Найти(ДанныеСтроки) <> Неопределено Тогда
				ОформлениеСтроки.ЦветФона = ирОбщий.ЦветФонаТекущегоЗначенияЛкс();
			КонецЕсли; 
		КонецЕсли;
		СтрокаПоиска = ТабличноеПолеСтрокаПоискаЛкс(ЭтаФорма, Элемент, ПрефиксСтрокиПоиска);
		Если МенеджерПоиска <> Неопределено Тогда
			МенеджерПоиска.ПрефиксСтрокиПоиска = ПрефиксСтрокиПоиска; // для ускорения будущих обращений
		КонецЕсли;
		КолонкиПоиска = Неопределено;
		ИскатьСРодителем = Ложь;
		Если ЗначениеЗаполнено(СтрокаПоиска) Тогда
			РазрешитьОкраскуПоиска = Истина;
			Если МенеджерПоиска <> Неопределено Тогда
				КолонкиПоиска = МенеджерПоиска.КолонкиПоиска;
				РазрешитьОкраскуПоиска = МенеджерПоиска.РазрешитьОкраску;
				ИскатьСРодителем = МенеджерПоиска.ИскатьСРодителем;
			КонецЕсли; 
			ВычислительРегВыражений = ирКэш.ВычислительРегВыраженийЛкс();
			#Если Сервер И Не Сервер Тогда
				ВычислительРегВыражений = Обработки.ирОболочкаРегВыражение.Создать();
			#КонецЕсли
			ВычислительРегВыражений.Global = Истина;
			СловаПоиска = ирОбщий.РазделитьСтрокуПоискаНаСловаПоискаЛкс(НРег(СтрокаПоиска), ИскатьСРодителем);
			Если ИскатьСРодителем Тогда
				Если ДанныеСтроки.Уровень() = 0 Тогда
					Пока СловаПоиска.Количество() > 1 Цикл
						СловаПоиска.Удалить(1);
					КонецЦикла;
				Иначе
					СловаПоиска.Удалить(0);
				КонецЕсли;
			КонецЕсли;
			ВычислительРегВыражений.Pattern = ирОбщий.РегВыражениеСтрокиПоискаЛкс(СловаПоиска, Ложь);
		ИначеЕсли ТипЗнч(Элемент.Значение) <> Тип("НастройкиКомпоновкиДанных") Тогда 
			РазрешитьОкраскуПоиска = Ложь;
			Если ДопСвойства.Отбор <> Неопределено Тогда
				КолонкиПоиска = СловаПоискаПоКолонкамИзОтбораПостроителяЛкс(Элемент, ДопСвойства.Отбор);
				Если КолонкиПоиска.Количество() > 0 Тогда
					СтрокаПоиска = "Ё"; // любая непустая строка
					ВычислительРегВыражений = ирКэш.ВычислительРегВыраженийЛкс();
					Для Каждого КлючИЗначение Из КолонкиПоиска Цикл
						КлючИЗначение.Значение[0] = "(" + ирОбщий.ПреобразоватьТекстДляРегулярныхВыраженийЛкс(КлючИЗначение.Значение[0]) + ")";
					КонецЦикла;
				КонецЕсли;
			КонецЕсли;
		КонецЕсли;
	КонецЕсли;
	ТолькоПросмотрТабличногоПоля = Элемент.ТолькоПросмотр Или ЭтаФорма.ТолькоПросмотр И Элемент.ИзменяетДанные;
	КолонкиТаблицы = Элемент.Колонки;
	Если КнопкаРежимаОтображения <> Неопределено Тогда
		ВариантОтображенияИдентификаторов = КнопкаРежимаОтображения.Текст;
	КонецЕсли; 
	Ячейки = ОформлениеСтроки.Ячейки;
	Если РасширенныеДанныеСтроки = Неопределено Тогда
		РасширенныеДанныеСтроки = ДанныеСтроки;
	КонецЕсли; 
	Если КолонкиДляРежимаОтображения <> Неопределено Тогда
		КолонкиДляРежимаОтображения = Новый Структура(КолонкиДляРежимаОтображения);
	КонецЕсли; 
	СостоянияКнопки = ирОбщий.СостоянияКнопкиОтображатьПустыеИИдентификаторыЛкс();
	ЛиОтбражатьПустые = Ложь
		Или ВариантОтображенияИдентификаторов = СостоянияКнопки[1]
		Или ВариантОтображенияИдентификаторов = СостоянияКнопки[2];
	ОтображатьИдентификаторы = ВариантОтображенияИдентификаторов = СостоянияКнопки[2];
	ирПлатформа = ирКэш.Получить();
	#Если Сервер И Не Сервер Тогда
	    ирПлатформа = Обработки.ирПлатформа.Создать();
	#КонецЕсли
	Если ТипЗнч(КолонкиСПиктограммамиТипов) = Тип("Строка") Тогда
		КолонкиСПиктограммамиТипов = Новый Структура(КолонкиСПиктограммамиТипов); 
	КонецЕсли; 
	ЦветФонаПустогоЗначения = ирОбщий.ЦветФонаПустогоЗначенияЛкс();
	ЦветТекстаПустогоЗначения = ирОбщий.ЦветТекстаПустогоЗначенияЛкс();
	Если ТипЗнч(ДанныеСтроки) = Тип("ТекущиеДанныеСписка") Тогда
		Если КлючСтроки = Неопределено Тогда
			ИмяТаблицыБД = ирОбщий.ИмяТаблицыБДДинамическогоСпискаЛкс(Элемент);
			КлючСтроки = ирОбщий.КлючСтрокиТаблицыБДИзСтрокиТаблицыЗначенийЛкс(ИмяТаблицыБД, ДанныеСтроки);
		КонецЕсли;
	Иначе
		Если ТипЗнч(ДанныеСтроки) = Тип("ТекущиеДанныеСтруктурыНастроекКомпоновкиДанных") Тогда
			КлючСтроки = ДанныеСтроки.Строка;
		Иначе
			КлючСтроки = ДанныеСтроки;
		КонецЕсли;
	КонецЕсли;
	ЭтоВыводТекущейСтроки = КлючСтроки = Элемент.ТекущаяСтрока;
	ЭтоВыводВыделеннойСтроки = Элемент.ВыделенныеСтроки.Содержит(КлючСтроки);
	ЦветФонаТекущегоЗначения = ирОбщий.ЦветФонаТекущегоЗначенияЛкс();
	Если ЛиОтбражатьПустые Тогда
		ТекущееЗначение = ТабличноеПолеЗначениеТекущейЯчейкиЛкс(Элемент);
		ДопСвойства.КнопкаРежимаОтображения = КнопкаРежимаОтображения;
		ДопСвойства.ЗначениеТекущейЯчейки = ТекущееЗначение;
	КонецЕсли; 
	ВсеТипыСсылокДокументов = Документы.ТипВсеСсылки();
	ЗначенияНизкойВажности = Новый Массив;
	ЗначенияНизкойВажности.Добавить(0);
	_РежимОтладки = ирКэш.РежимОтладкиЛкс();
	Если _РежимОтладки Тогда 
		// Пассивный оригинал расположенного ниже однострочного кода. Выполняйте изменения синхронно в обоих вариантах. ирОбщий.ПрЛкс(_РежимОтладки, 1, 1)
		Для Каждого Колонка Из КолонкиТаблицы Цикл
			Если Не Колонка.Видимость Тогда
				Продолжить;
			КонецЕсли; 
			ИмяКолонки = Колонка.Имя; 
			ИмяКолонкиДанных = Колонка.Данные;
			Ячейка = Ячейки[ИмяКолонки];
			//Если Не Ячейка.Видимость Тогда // Почему то здесь платформа тратит много времени. Поэтому в среднем это лишние траты времени.
			//	Продолжить;
			//КонецЕсли; 
			КартинкаЯчейки = Неопределено;
			КолонкаРасширенныхДанных = Неопределено;
			Если РасширенныеКолонки <> Неопределено Тогда
				РасширенныеКолонки.Свойство(ИмяКолонки, КолонкаРасширенныхДанных);
			КонецЕсли;
			ПрименятьРежимОтображения = Ложь
				Или КолонкиДляРежимаОтображения = Неопределено
				Или КолонкиДляРежимаОтображения.Свойство(ИмяКолонки);
			КолонкаРедактируетДанныеФлажка = Ложь;
			Если КолонкаРасширенныхДанных <> Неопределено Тогда
				ЗначениеЯчейки = РасширенныеДанныеСтроки[КолонкаРасширенныхДанных];
			Иначе
				Если Истина
					И Не ЗначениеЗаполнено(ИмяКолонкиДанных)
					И ЗначениеЗаполнено(Колонка.ДанныеФлажка)
				Тогда 
					ЗначениеЯчейки = Ячейка.ЗначениеФлажка;
					КолонкаРедактируетДанныеФлажка = Не Ячейка.ТолькоПросмотр;
				Иначе
					ЗначениеЯчейки = Ячейка.Значение;
				КонецЕсли; 
			КонецЕсли;
			ТипЗначенияЯчейки = ТипЗнч(ЗначениеЯчейки);
			ТипЗначенияЯчейкиXML = XMLТипЗнч(ЗначениеЯчейки);
			Если Истина
				И Не КолонкаРедактируетДанныеФлажка
				И ТипЗначенияЯчейки = Тип("Булево") 
				И ТипЗнч(Колонка.ЭлементУправления) <> Тип("ПолеВыбора") // Колонка "Вид" таблицы "Параметры" в консоли запросов
			Тогда 
				Если Истина
					И Не ЛиОтбражатьПустые 
					И Не ОтображатьИдентификаторы 
					И Не КолонкиСПиктограммамиТипов.Свойство(ИмяКолонки)
				Тогда
					Ячейка.ОтображатьТекст = Ложь; // текст нужен для вывода на печать
				Иначе
					Ячейка.УстановитьТекст("" + ЗначениеЯчейки);
				КонецЕсли; 
				Если Не Ячейка.ТолькоПросмотр И Колонка.ЭлементУправления <> Неопределено И Не ТолькоПросмотрТабличногоПоля Тогда
					Ячейка.УстановитьФлажок(ЗначениеЯчейки);
				ИначеЕсли Не Ячейка.ОтображатьТекст Тогда 
					Ячейка.ОтображатьФлажок = Ложь;
					Если Колонка.КартинкиСтрок.Вид <> ВидКартинки.Пустая Тогда
						Ячейка.ИндексКартинки = Не ЗначениеЯчейки;
						Ячейка.ОтображатьКартинку = Истина;
					Иначе
						Если ЗначениеЯчейки = Истина Тогда
							КартинкаЯчейки = ирКэш.КартинкаПоИмениЛкс("ирФлажокТолькоПросмотр");
							// Так почему то в некоторых местах выводится квадратик для флажка, как будто его можно изменять. Например в открытой в режиме ТолькоПросмотр ссылки форме выбора редактируемых типов.
							//Ячейка.УстановитьФлажок(ЗначениеЯчейки);
							//Ячейка.ТолькоПросмотр = Истина;
						КонецЕсли;
					КонецЕсли;
				КонецЕсли;
			КонецЕсли; 
			ПредставлениеЗначения = "";
			Если Истина
				И Ячейка.ОтображатьТекст
				И Не КолонкаРедактируетДанныеФлажка
				И ТипЗначенияЯчейки <> Тип("Строка") 
				И ЗначениеЯчейки <> Неопределено
				И (Ложь
					Или РасширенноеПредставлениеХранилищЗначений 
					Или ТипЗначенияЯчейки = Тип("ОписаниеТипов")
					Или РасширенноеПредставлениеДат И ТипЗначенияЯчейки = Тип("Дата")
					Или ТипЗначенияЯчейкиXML = Неопределено)
			Тогда
				ПредставлениеЗначения = ирОбщий.РасширенноеПредставлениеЗначенияЛкс(ЗначениеЯчейки, Колонка,, РасширенноеПредставлениеХранилищЗначений, Ложь);
			КонецЕсли; 
			НовыйЦветФона = Неопределено;
			НовыйЦветТекста = Неопределено;
			ТекстЯчейки = Ячейка.Текст;
			ФорматКолонки = Колонка.Формат;
			
			// Мультиметка62441127
			Если ЛиОтбражатьПустые И ПрименятьРежимОтображения Тогда
				Если ТипЗначенияЯчейки = Тип("Строка") Тогда
					Если Не ЗначениеЗаполнено(ЗначениеЯчейки) Тогда
						ПредставлениеЗначения = ирПлатформа.ПредставлениеПустогоЗначенияЛкс(ЗначениеЯчейки);
						НовыйЦветФона = ЦветФонаПустогоЗначения;
					ИначеЕсли ОтображатьИдентификаторы Тогда
						ПредставлениеЗначения = """" + ЗначениеЯчейки + """";
					КонецЕсли; 
				ИначеЕсли Не ирОбщий.ЛиКоллекцияЛкс(ЗначениеЯчейки) Тогда 
					Попытка
						ЗначениеНепустое = ЗначениеЗаполнено(ЗначениеЯчейки) И ЗначениеЯчейки <> Ложь;
					Исключение
						ЗначениеНепустое = Истина;
					КонецПопытки;
					Если Не ЗначениеНепустое Тогда
						ПредставлениеЗначения = ирПлатформа.ПредставлениеПустогоЗначенияЛкс(ЗначениеЯчейки);
						НовыйЦветФона = ЦветФонаПустогоЗначения;
					КонецЕсли;
				КонецЕсли; 
				Если Истина
					И ТекущееЗначение = ЗначениеЯчейки 
					И ТипЗнч(ТекущееЗначение) = ТипЗначенияЯчейки // защита от слияния Истина=1
				Тогда 
					НовыйЦветФона = ЦветФонаТекущегоЗначения;
				КонецЕсли; 
			Иначе
				Если Истина
					И ЗначенияНизкойВажности.Найти(ЗначениеЯчейки) <> Неопределено 
					И ФорматКолонки = "" 
					И ИмяКолонки <> "ИдентификаторСсылкиЛкс" 
				Тогда 
					Если ТипЗнч(ЗначениеЯчейки) = Тип("Число") Тогда
						ПредставлениеЗначения = "0";
					Иначе
						ПредставлениеЗначения = "" + ЗначениеЯчейки; // Ложь
					КонецЕсли;
					НовыйЦветТекста = ЦветТекстаПустогоЗначения;
				КонецЕсли;
				// Результаты поиска слов
				Если Истина
					И ЗначениеЗаполнено(СтрокаПоиска) 
					И ЗначениеЗаполнено(ИмяКолонкиДанных)
					И (Ложь
						Или КолонкиПоиска = Неопределено
						Или КолонкиПоиска.Свойство(ИмяКолонкиДанных))
					И ТипЗначенияЯчейкиXML <> Неопределено
					И (Ложь
						Или ТипЗначенияЯчейки = Тип("Строка")
						Или (Истина
							И Найти(ТипЗначенияЯчейкиXML.ИмяТипа, "Ref.") > 0
							И Не ВсеТипыСсылокДокументов.СодержитТип(ТипЗначенияЯчейки)))
				Тогда
					Если КолонкиПоиска <> Неопределено Тогда
						КолонкаПоиска = КолонкиПоиска[ИмяКолонкиДанных];
						Если КолонкаПоиска <> Неопределено Тогда
							// Это отбор и значение ему точно удовлетворяет
							ВычислительРегВыражений.Pattern = КолонкаПоиска[0];
						КонецЕсли;
					Иначе
						КолонкаПоиска = Неопределено;
					КонецЕсли;
					Если Ложь
						Или КолонкаПоиска <> Неопределено
						Или ирОбщий.ЛиСтрокаСодержитВсеПодстрокиЛкс(ТекстЯчейки, СловаПоиска) 
					Тогда
						ПредставлениеЗначения = ВычислительРегВыражений.Заменить(ТекстЯчейки, ШаблонРазметкиВхождений);
						Если РазрешитьОкраскуПоиска Тогда
							НовыйЦветФона = ЦветФонаТекущегоЗначения;
						КонецЕсли;
					КонецЕсли;
				КонецЕсли;
			КонецЕсли;
			
			Если НовыйЦветФона <> Неопределено Тогда
				Ячейка.ЦветФона = НовыйЦветФона;
			КонецЕсли;
			Если НовыйЦветТекста <> Неопределено Тогда
				Ячейка.ЦветТекста = НовыйЦветТекста;
			КонецЕсли;
			Если Ячейка.ОтображатьТекст И ПредставлениеЗначения <> "" Тогда
				Если Ложь
					Или КолонкаРедактируетДанныеФлажка
					Или Формат(ЗначениеЯчейки, ФорматКолонки) = ТекстЯчейки // Здесь могут быть обращения к БД
				Тогда
					Ячейка.УстановитьТекст(ПредставлениеЗначения);
				КонецЕсли; 
			КонецЕсли; 
			Если Истина
				И ОтображатьИдентификаторы 
				И ПрименятьРежимОтображения 
				И ТипЗначенияЯчейки <> Тип("Строка") 
				И ЗначениеЯчейки <> Неопределено
				И ЗначениеЯчейки <> Null
			Тогда
				ИдентификаторСсылки = ирОбщий.СтроковыйИдентификаторЗначенияЛкс(ЗначениеЯчейки, Истина);
				Если ИдентификаторСсылки <> Неопределено Тогда
					Ячейка.УстановитьТекст(ИдентификаторСсылки);
				КонецЕсли; 
			КонецЕсли; 
			Если КартинкаЯчейки = Неопределено И КолонкиСПиктограммамиТипов.Свойство(ИмяКолонки) Тогда
				Если ТипЗначенияЯчейки <> Тип("ПолеКомпоновкиДанных") Тогда
					Если Не (Истина
						И ТипЗначенияЯчейки = Тип("Булево")
						И Ячейка.ОтображатьФлажок)
					Тогда
						КартинкаТипа = КартинкаТипаЛкс(ТипЗначенияЯчейки);
						Если КартинкаТипа <> Неопределено Тогда
							КартинкаЯчейки = КартинкаТипа;
						КонецЕсли;
					КонецЕсли;
				КонецЕсли;
			КонецЕсли; 
			Если КартинкаЯчейки <> Неопределено Тогда
				Ячейка.УстановитьКартинку(КартинкаЯчейки);
			КонецЕсли; 
		КонецЦикла;  
	Иначе
		// Однострочный код использован для ускорения. Выше расположен оригинал. Выполняйте изменения синхронно в обоих вариантах. Преобразовано консолью кода из подсистемы "Инструменты разработчика" (http://devtool1c.ucoz.ru)
		Для Каждого Колонка Из КолонкиТаблицы Цикл  			Если Не Колонка.Видимость Тогда  				Продолжить;  			КонецЕсли;  			ИмяКолонки = Колонка.Имя;  			ИмяКолонкиДанных = Колонка.Данные;  			Ячейка = Ячейки[ИмяКолонки];        			КартинкаЯчейки = Неопределено;  			КолонкаРасширенныхДанных = Неопределено;  			Если РасширенныеКолонки <> Неопределено Тогда  				РасширенныеКолонки.Свойство(ИмяКолонки, КолонкаРасширенныхДанных);  			КонецЕсли;  			ПрименятьРежимОтображения = Ложь  				Или КолонкиДляРежимаОтображения = Неопределено  				Или КолонкиДляРежимаОтображения.Свойство(ИмяКолонки);  			КолонкаРедактируетДанныеФлажка = Ложь;  			Если КолонкаРасширенныхДанных <> Неопределено Тогда  				ЗначениеЯчейки = РасширенныеДанныеСтроки[КолонкаРасширенныхДанных];  			Иначе  				Если Истина  					И Не ЗначениеЗаполнено(ИмяКолонкиДанных)  					И ЗначениеЗаполнено(Колонка.ДанныеФлажка)  				Тогда  					ЗначениеЯчейки = Ячейка.ЗначениеФлажка;  					КолонкаРедактируетДанныеФлажка = Не Ячейка.ТолькоПросмотр;  				Иначе  					ЗначениеЯчейки = Ячейка.Значение;  				КонецЕсли;  			КонецЕсли;  			ТипЗначенияЯчейки = ТипЗнч(ЗначениеЯчейки);  			ТипЗначенияЯчейкиXML = XMLТипЗнч(ЗначениеЯчейки);  			Если Истина  				И Не КолонкаРедактируетДанныеФлажка  				И ТипЗначенияЯчейки = Тип("Булево")  				И ТипЗнч(Колонка.ЭлементУправления) <> Тип("ПолеВыбора")  			Тогда  				Если Истина  					И Не ЛиОтбражатьПустые  					И Не ОтображатьИдентификаторы  					И Не КолонкиСПиктограммамиТипов.Свойство(ИмяКолонки)  				Тогда  					Ячейка.ОтображатьТекст = Ложь;  				Иначе  					Ячейка.УстановитьТекст("" + ЗначениеЯчейки);  				КонецЕсли;  				Если Не Ячейка.ТолькоПросмотр И Колонка.ЭлементУправления <> Неопределено И Не ТолькоПросмотрТабличногоПоля Тогда  					Ячейка.УстановитьФлажок(ЗначениеЯчейки);  				ИначеЕсли Не Ячейка.ОтображатьТекст Тогда  					Ячейка.ОтображатьФлажок = Ложь;  					Если Колонка.КартинкиСтрок.Вид <> ВидКартинки.Пустая Тогда  						Ячейка.ИндексКартинки = Не ЗначениеЯчейки;  						Ячейка.ОтображатьКартинку = Истина;  					Иначе  						Если ЗначениеЯчейки = Истина Тогда  							КартинкаЯчейки = ирКэш.КартинкаПоИмениЛкс("ирФлажокТолькоПросмотр");        						КонецЕсли;  					КонецЕсли;  				КонецЕсли;  			КонецЕсли;  			ПредставлениеЗначения = "";  			Если Истина  				И Ячейка.ОтображатьТекст  				И Не КолонкаРедактируетДанныеФлажка  				И ТипЗначенияЯчейки <> Тип("Строка")  				И ЗначениеЯчейки <> Неопределено  				И (Ложь  					Или РасширенноеПредставлениеХранилищЗначений  					Или ТипЗначенияЯчейки = Тип("ОписаниеТипов")  					Или РасширенноеПредставлениеДат И ТипЗначенияЯчейки = Тип("Дата")  					Или ТипЗначенияЯчейкиXML = Неопределено)  			Тогда  				ПредставлениеЗначения = ирОбщий.РасширенноеПредставлениеЗначенияЛкс(ЗначениеЯчейки, Колонка,, РасширенноеПредставлениеХранилищЗначений, Ложь);  			КонецЕсли;  			НовыйЦветФона = Неопределено;  			НовыйЦветТекста = Неопределено;  			ТекстЯчейки = Ячейка.Текст;  			ФорматКолонки = Колонка.Формат;      			Если ЛиОтбражатьПустые И ПрименятьРежимОтображения Тогда  				Если ТипЗначенияЯчейки = Тип("Строка") Тогда  					Если Не ЗначениеЗаполнено(ЗначениеЯчейки) Тогда  						ПредставлениеЗначения = ирПлатформа.ПредставлениеПустогоЗначенияЛкс(ЗначениеЯчейки);  						НовыйЦветФона = ЦветФонаПустогоЗначения;  					ИначеЕсли ОтображатьИдентификаторы Тогда  						ПредставлениеЗначения = """" + ЗначениеЯчейки + """";  					КонецЕсли;  				ИначеЕсли Не ирОбщий.ЛиКоллекцияЛкс(ЗначениеЯчейки) Тогда  					Попытка  						ЗначениеНепустое = ЗначениеЗаполнено(ЗначениеЯчейки) И ЗначениеЯчейки <> Ложь;  					Исключение  						ЗначениеНепустое = Истина;  					КонецПопытки;  					Если Не ЗначениеНепустое Тогда  						ПредставлениеЗначения = ирПлатформа.ПредставлениеПустогоЗначенияЛкс(ЗначениеЯчейки);  						НовыйЦветФона = ЦветФонаПустогоЗначения;  					КонецЕсли;  				КонецЕсли;  				Если Истина  					И ТекущееЗначение = ЗначениеЯчейки  					И ТипЗнч(ТекущееЗначение) = ТипЗначенияЯчейки  				Тогда  					НовыйЦветФона = ЦветФонаТекущегоЗначения;  				КонецЕсли;  			Иначе  				Если Истина  					И ЗначенияНизкойВажности.Найти(ЗначениеЯчейки) <> Неопределено  					И ФорматКолонки = ""  					И ИмяКолонки <> "ИдентификаторСсылкиЛкс"  				Тогда  					Если ТипЗнч(ЗначениеЯчейки) = Тип("Число") Тогда  						ПредставлениеЗначения = "0";  					Иначе  						ПредставлениеЗначения = "" + ЗначениеЯчейки;  					КонецЕсли;  					НовыйЦветТекста = ЦветТекстаПустогоЗначения;  				КонецЕсли;    				Если Истина  					И ЗначениеЗаполнено(СтрокаПоиска)  					И ЗначениеЗаполнено(ИмяКолонкиДанных)  					И (Ложь  						Или КолонкиПоиска = Неопределено  						Или КолонкиПоиска.Свойство(ИмяКолонкиДанных))  					И ТипЗначенияЯчейкиXML <> Неопределено  					И (Ложь  						Или ТипЗначенияЯчейки = Тип("Строка")  						Или (Истина  							И Найти(ТипЗначенияЯчейкиXML.ИмяТипа, "Ref.") > 0  							И Не ВсеТипыСсылокДокументов.СодержитТип(ТипЗначенияЯчейки)))  				Тогда  					Если КолонкиПоиска <> Неопределено Тогда  						КолонкаПоиска = КолонкиПоиска[ИмяКолонкиДанных];  						Если КолонкаПоиска <> Неопределено Тогда    							ВычислительРегВыражений.Pattern = КолонкаПоиска[0];  						КонецЕсли;  					Иначе  						КолонкаПоиска = Неопределено;  					КонецЕсли;  					Если Ложь  						Или КолонкаПоиска <> Неопределено  						Или ирОбщий.ЛиСтрокаСодержитВсеПодстрокиЛкс(ТекстЯчейки, СловаПоиска)  					Тогда  						ПредставлениеЗначения = ВычислительРегВыражений.Заменить(ТекстЯчейки, ШаблонРазметкиВхождений);  						Если РазрешитьОкраскуПоиска Тогда  							НовыйЦветФона = ЦветФонаТекущегоЗначения;  						КонецЕсли;  					КонецЕсли;  				КонецЕсли;  			КонецЕсли;    			Если НовыйЦветФона <> Неопределено Тогда  				Ячейка.ЦветФона = НовыйЦветФона;  			КонецЕсли;  			Если НовыйЦветТекста <> Неопределено Тогда  				Ячейка.ЦветТекста = НовыйЦветТекста;  			КонецЕсли;  			Если Ячейка.ОтображатьТекст И ПредставлениеЗначения <> "" Тогда  				Если Ложь  					Или КолонкаРедактируетДанныеФлажка  					Или Формат(ЗначениеЯчейки, ФорматКолонки) = ТекстЯчейки  				Тогда  					Ячейка.УстановитьТекст(ПредставлениеЗначения);  				КонецЕсли;  			КонецЕсли;  			Если Истина  				И ОтображатьИдентификаторы  				И ПрименятьРежимОтображения  				И ТипЗначенияЯчейки <> Тип("Строка")  				И ЗначениеЯчейки <> Неопределено  				И ЗначениеЯчейки <> Null  			Тогда  				ИдентификаторСсылки = ирОбщий.СтроковыйИдентификаторЗначенияЛкс(ЗначениеЯчейки, Истина);  				Если ИдентификаторСсылки <> Неопределено Тогда  					Ячейка.УстановитьТекст(ИдентификаторСсылки);  				КонецЕсли;  			КонецЕсли;  			Если КартинкаЯчейки = Неопределено И КолонкиСПиктограммамиТипов.Свойство(ИмяКолонки) Тогда  				Если ТипЗначенияЯчейки <> Тип("ПолеКомпоновкиДанных") Тогда  					Если Не (Истина  						И ТипЗначенияЯчейки = Тип("Булево")  						И Ячейка.ОтображатьФлажок)  					Тогда  						КартинкаТипа = КартинкаТипаЛкс(ТипЗначенияЯчейки);  						Если КартинкаТипа <> Неопределено Тогда  							КартинкаЯчейки = КартинкаТипа;  						КонецЕсли;  					КонецЕсли;  				КонецЕсли;  			КонецЕсли;  			Если КартинкаЯчейки <> Неопределено Тогда  				Ячейка.УстановитьКартинку(КартинкаЯчейки);  			КонецЕсли;  		КонецЦикла;  
	КонецЕсли; 
	ИмяКолонкиНомерСтроки = ирКэш.ИмяКолонкиНомерСтрокиЛкс();
	Если Ячейки.Найти(ИмяКолонкиНомерСтроки) <> Неопределено Тогда
		Если ТипЗнч(ДанныеСтроки) = Тип("СтрокаДереваЗначений") Тогда
			ИндексСтроки = ирОбщий.РодительСтрокиДереваЛкс(ДанныеСтроки, ДанныеСтроки.Владелец()).Строки.Индекс(ДанныеСтроки);
		Иначе
			ИндексСтроки = ДанныеСтроки.Владелец().Индекс(ДанныеСтроки);
		КонецЕсли;
		Ячейки[ИмяКолонкиНомерСтроки].УстановитьТекст(XMLСтрока(ИндексСтроки + 1));
		Ячейки[ИмяКолонкиНомерСтроки].ЦветТекста = Новый Цвет(128, 128, 128);
	КонецЕсли; 
	Если Истина
		И (ЭтоВыводТекущейСтроки Или ЭтоВыводВыделеннойСтроки)
		И Элемент.ПолучитьДействие("ПриАктивизацииСтроки") <> Неопределено
	Тогда
		Если ЭтоВыводТекущейСтроки Тогда
			СмещениеЦвета = -25;
		Иначе
			СмещениеЦвета = -15;
		КонецЕсли; 
		ТекущийЦветФона = ОформлениеСтроки.ЦветФона;
		Если ТекущийЦветФона.Вид = ВидЦвета.АвтоЦвет Тогда
			ТекущийЦветФона = Элемент.ЦветФонаПоля;
		КонецЕсли; 
		ОформлениеСтроки.ЦветФона = ирОбщий.СмещенныйЦветЛкс(ТекущийЦветФона, СмещениеЦвета,, СмещениеЦвета);
		Для Каждого Ячейка Из ОформлениеСтроки.Ячейки Цикл
			ТекущийЦветФона = Ячейка.ЦветФона;
			Если ТекущийЦветФона.Вид = ВидЦвета.АвтоЦвет Тогда
				Продолжить;
			КонецЕсли; 
			Ячейка.ЦветФона = ирОбщий.СмещенныйЦветЛкс(ТекущийЦветФона, СмещениеЦвета,, СмещениеЦвета);
		КонецЦикла;
	КонецЕсли; 
	
КонецПроцедуры

Функция СловаПоискаПоКолонкамИзОтбораПостроителяЛкс(Знач ТабличноеПоле = Неопределено, Знач Отбор = Неопределено) Экспорт 

	СловаПоСвойствам = Новый Структура;
	Если Отбор = Неопределено Тогда
		Отбор = ОтборТабличногоПоляЛкс(ТабличноеПоле);
	КонецЕсли;
	Если Отбор = Неопределено Тогда
		Возврат СловаПоСвойствам;
	КонецЕсли;
	#Если Сервер И Не Сервер Тогда
		Отбор = Новый ПостроительЗапроса;
		Отбор = Отбор.Отбор;
	#КонецЕсли
	ОбщийЭлементОтбора = Отбор.Найти("ДанныеПоиска");
	ОбщееСлово = "";
	Если Истина
		И ОбщийЭлементОтбора <> Неопределено
		И ОбщийЭлементОтбора.Использование
		И ОбщийЭлементОтбора.ВидСравнения = ВидСравнения.Содержит 
		И ОбщийЭлементОтбора.Значение <> ""
	Тогда
		ОбщееСлово = ОбщийЭлементОтбора.Значение;
	КонецЕсли;
	Для Каждого ЭлементОтбора Из Отбор Цикл
		Если Истина
			И ОбщееСлово <> ""
			И ирОбщий.ЛиОписаниеТиповПростогоСтроковогоТипаЛкс(ЭлементОтбора.ТипЗначения, Ложь)
		Тогда
			ирОбщий.ДобавитьСловаПоискаВСтруктуруРеквизитовЛкс("" + ЭлементОтбора.Имя, ОбщееСлово, СловаПоСвойствам);
		КонецЕсли;
		Если Истина
			И ЭлементОтбора.Использование
			И ЭлементОтбора.ВидСравнения = ВидСравнения.Содержит 
			И ЭлементОтбора.Значение <> ""
		Тогда
			ирОбщий.ДобавитьСловаПоискаВСтруктуруРеквизитовЛкс("" + ЭлементОтбора.Имя, ЭлементОтбора.Значение, СловаПоСвойствам);
			Если ирОбщий.СтрКончаетсяНаЛкс(ЭлементОтбора.Имя, "Представление") Тогда
				// Для ирРазличныеЗначенияКолонки
				ЭлементОтбораРодитель = Отбор.Найти(ирОбщий.СтрокаБезПоследнегоФрагментаЛкс(ЭлементОтбора.Имя, "Представление"));
				Если Истина
					И ЭлементОтбораРодитель <> Неопределено
					И Не ЭлементОтбораРодитель.Использование
				Тогда
					ирОбщий.ДобавитьСловаПоискаВСтруктуруРеквизитовЛкс("" + ЭлементОтбораРодитель.Имя, ЭлементОтбора.Значение, СловаПоСвойствам);
				КонецЕсли;
			КонецЕсли;
		КонецЕсли;
	КонецЦикла;
	Возврат СловаПоСвойствам;

КонецФункции

Процедура ТабличноеПолеСДаннымиПоискаУстановитьОтборПоПодстрокеЛкс(Знач ЭтаФорма, Знач ТабличноеПоле, Знач ЗначениеОтбора, Знач КолонкиПоиска = Неопределено, Знач РазрешитьОкраску = Ложь) Экспорт 
	
	Если ТабличноеПоле.Значение.Количество() > 0 Тогда
		СтрокаТаблицы = ТабличноеПоле.Значение[0];
		ДанныеПоиска = ДанныеПоискаСтрокиТаблицыЛкс(ТабличноеПоле, СтрокаТаблицы, КолонкиПоиска);
		ДопСвойства = ДопСвойстваЭлементаФормыЛкс(ЭтаФорма, ТабличноеПоле);
		ДопСвойства.МенеджерПоиска = СоздатьМенеджерПоискаВТабличномПолеЛкс(КолонкиПоиска,,, РазрешитьОкраску);
		Если СтрокаТаблицы.ДанныеПоиска <> ДанныеПоиска Тогда
			Для Каждого СтрокаТаблицы Из ТабличноеПоле.Значение Цикл
				СтрокаТаблицы.ДанныеПоиска = ДанныеПоискаСтрокиТаблицыЛкс(ТабличноеПоле, СтрокаТаблицы, КолонкиПоиска);
			КонецЦикла;
		КонецЕсли;
	КонецЕсли;
	ирОбщий.УстановитьОтборПоПодстрокеЛкс(ТабличноеПоле.ОтборСтрок.ДанныеПоиска, ЗначениеОтбора);

КонецПроцедуры

Процедура ТабличноеПолеРегистраОбновитьКолонкиОстатковЛкс(Знач ТабличноеПолеРегистра, Знач ОбъектМД, Знач Кнопка, НоваяПометка = Неопределено) Экспорт 
	
	#Если Сервер И Не Сервер Тогда
		ОбъектМД = Метаданные.РегистрыНакопления.ОстаткиДнейДополнительныхОтпусков;
	#КонецЕсли
	Если НоваяПометка = Неопределено Тогда
		НоваяПометка = Кнопка.Пометка;
	Иначе
		Кнопка.Пометка = НоваяПометка;
	КонецЕсли;
	ШиринаКолонки = ирОбщий.ШиринаОписанияТиповЛкс(Новый ОписаниеТипов("Число"));
	Для Каждого Ресурс Из ОбъектМД.Ресурсы Цикл
		ИмяКолонки = Ресурс.Имя + "Остаток";
		КолонкаРесурса = ТабличноеПолеРегистра.Колонки.Найти(Ресурс.Имя);
		КолонкаОстатка = ТабличноеПолеРегистра.Колонки.Найти(ИмяКолонки);
		Если КолонкаОстатка = Неопределено Тогда
			КолонкаОстатка = ТабличноеПолеРегистра.Колонки.Вставить(ТабличноеПолеРегистра.Колонки.Индекс(КолонкаРесурса));
			КолонкаОстатка.Имя = ИмяКолонки;
			ТабличноеПолеРегистра.Колонки.Сдвинуть(КолонкаОстатка, 1);
			КолонкаОстатка.Положение = ПоложениеКолонки.ВТойЖеКолонке;
			КолонкаОстатка.ТекстШапки = "->Остаток";
			КолонкаОстатка.ЦветТекстаПоля = ирОбщий.ЦветТекстаИзмененныхДанныхЛкс();
			КолонкаОстатка.ПодсказкаВШапке = Ресурс.Представление() + " Остаток на текущую дату";
			КолонкаОстатка.ТолькоПросмотр = Истина;
			КолонкаОстатка.Ширина = ШиринаКолонки;
		КонецЕсли;
		КолонкаОстатка.Видимость = КолонкаРесурса.Видимость И НоваяПометка;
	КонецЦикла;
	Если НоваяПометка Тогда
		ТабличноеПолеРегистра.ОбновитьСтроки();
	КонецЕсли;

КонецПроцедуры

// .
// Параметры:
//    ОформленияСтрок - ? - 
//    Кнопка - ? - 
//    ОбъектМД - ОбъектМетаданных: РегистрНакопления - 
//    ИмяТаблицыБДРегистра - ? - 
//    ТипВыхода - Строка - Служебный параметр для перехода после вызова метода
Функция ТабличноеПолеРегистраОтобразитьОстаткиЛкс(Знач ОформленияСтрок, Знач ОбъектМД, Знач Кнопка, Знач ИмяТаблицыБДРегистра = Неопределено) Экспорт 
	Если Не Кнопка.Доступность Или Не Кнопка.Пометка Тогда
		Возврат Неопределено;
	КонецЕсли;
	#Если Сервер И Не Сервер Тогда
		ОбъектМД = Метаданные.РегистрыНакопления.ОстаткиДнейДополнительныхОтпусков;
	#КонецЕсли
	ИменаИзмерений = Новый Массив;
	ТаблицаКлючей = Новый ТаблицаЗначений;
	ИмяОстаток = ирОбщий.ПеревестиСтроку("Остаток");
	Для Каждого ПолеТаблицы Из ирОбщий.ПоляТаблицыБДЛкс(ИмяТаблицыБДРегистра + ".Остатки") Цикл
		#Если Сервер И Не Сервер Тогда
			ПолеТаблицы = Обработки.ирТипПолеБД.Создать();
		#КонецЕсли
		Если ирОбщий.СтрКончаетсяНаЛкс(ПолеТаблицы.Имя, ИмяОстаток) Тогда // Грязно
			Продолжить;
		КонецЕсли;
		ИменаИзмерений.Добавить(ПолеТаблицы.Имя);
		ТаблицаКлючей.Колонки.Добавить(ПолеТаблицы.Имя, ПолеТаблицы.ТипЗначения);
	КонецЦикла;
	СтрокаИменИзмерений = ирОбщий.СтрСоединитьЛкс(ИменаИзмерений, ",");
	Запрос = Новый Запрос("ВЫБРАТЬ Т.* ИЗ " + ИмяТаблицыБДРегистра + ".Остатки(, (" + СтрокаИменИзмерений + ") В (&ТЗ)) КАК Т");
	Для Каждого ОформлениеСтроки Из ОформленияСтрок Цикл
		ЗаполнитьЗначенияСвойств(ТаблицаКлючей.Добавить(), ОформлениеСтроки.ДанныеСтроки);
	КонецЦикла;
	Запрос.УстановитьПараметр("ТЗ", ТаблицаКлючей);
	РезультатЗапроса = Запрос.Выполнить().Выгрузить();
	КлючСтроки = Новый Структура(СтрокаИменИзмерений);
	Для Каждого ОформлениеСтроки Из ОформленияСтрок Цикл
		ЗаполнитьЗначенияСвойств(КлючСтроки, ОформлениеСтроки.ДанныеСтроки);
		СтрокаРезультата = РезультатЗапроса.НайтиСтроки(КлючСтроки);
		Если СтрокаРезультата.Количество() > 0 Тогда
			СтрокаРезультата = СтрокаРезультата[0];
			Для Каждого Ресурс Из ОбъектМД.Ресурсы Цикл
				ИмяРесурса = Ресурс.Имя;
				Ячейка = ОформлениеСтроки.Ячейки.Найти(ИмяРесурса + ИмяОстаток);
				Если Ячейка = Неопределено Тогда
					Продолжить;
				КонецЕсли;
				Ячейка.Значение = СтрокаРезультата[ИмяРесурса + ИмяОстаток];
			КонецЦикла;
		КонецЕсли;
	КонецЦикла;
КонецФункции

Функция ДанныеПоискаСтрокиТаблицыЛкс(Знач ТабличноеПоле, Знач СтрокаТаблицы, КолонкиПоиска = Неопределено) Экспорт 
	
	#Если Сервер И Не Сервер Тогда
		ТабличноеПоле = Новый ТабличноеПоле;
	#КонецЕсли
	ДанныеПоиска = Новый Массив;
	Если КолонкиПоиска = Неопределено Тогда
		КолонкиПоиска = Новый Структура;
		Для Каждого Колонка Из ТабличноеПоле.Колонки Цикл
			Если Не ЗначениеЗаполнено(Колонка.Данные) Тогда
				Продолжить;
			КонецЕсли;
			ЗначениеЯчейки = СтрокаТаблицы[Колонка.Данные];
			Если ТипЗнч(ЗначениеЯчейки) <> Тип("Строка") Тогда
				Продолжить;
			КонецЕсли;
			ДанныеПоиска.Добавить(ЗначениеЯчейки);
			КолонкиПоиска.Вставить(Колонка.Данные);
		КонецЦикла;
	Иначе
		Для Каждого КлючИЗначение Из КолонкиПоиска Цикл
			ДанныеПоиска.Добавить(СтрокаТаблицы[КлючИЗначение.Ключ]);
		КонецЦикла;
	КонецЕсли;
	ДанныеПоиска = ирОбщий.СтрСоединитьЛкс(ДанныеПоиска, "#");
	Возврат ДанныеПоиска;

КонецФункции

Функция ТабличноеПолеЗначениеТекущейЯчейкиЛкс(Знач Элемент) Экспорт 
	
	// Медленный способ
	//Если ЭтоВыводВыделеннойСтроки Тогда
	//	ЯчейкиТекущейСтроки = Ячейки;
	//Иначе
	//	ЯчейкиТекущейСтроки = Элемент.ОформлениеСтроки(Элемент.ТекущаяСтрока).Ячейки;
	//КонецЕсли; 
	//ТекущееЗначение = ЯчейкиТекущейСтроки[Элемент.ТекущаяКолонка.Имя].Значение;  
	//
	ПутьКДанным = ирОбщий.ПутьКДаннымКолонкиТабличногоПоляЛкс(Элемент);
	Если ЗначениеЗаполнено(ПутьКДанным) И Элемент.ТекущиеДанные <> Неопределено Тогда
		ТекущееЗначение = Элемент.ТекущиеДанные[ПутьКДанным];
	КонецЕсли;
	Возврат ТекущееЗначение;

КонецФункции

Функция ТабличноеПолеПриАктивацииКолонкиЛкс(Знач ЭтаФорма, Знач ТабличноеПоле) Экспорт 
	
	Если ТабличноеПоле.ТекущаяКолонка = Неопределено Тогда
		Возврат Ложь;
	КонецЕсли; 
	//Возврат Ложь; // Временно
	ВсеСтрокиОбновлены = Ложь;
	ДопСвойства = ДопСвойстваЭлементаФормыЛкс(ЭтаФорма, ТабличноеПоле);
	КнопкаРежимаОтображения = ДопСвойства.КнопкаРежимаОтображения;
	Если КнопкаРежимаОтображения <> Неопределено Тогда
		СостоянияКнопки = ирОбщий.СостоянияКнопкиОтображатьПустыеИИдентификаторыЛкс();
		Если КнопкаРежимаОтображения.Текст <> СостоянияКнопки[0] Тогда 
			СтароеТекущееЗначение = ТабличноеПолеЗначениеТекущейЯчейкиЛкс(ТабличноеПоле);
			Если Ложь
				Или ТипЗнч(ТабличноеПоле.ТекущиеДанные) = Тип("ТекущиеДанныеСписка") 
			Тогда 
				// У динамического списка почему то обновление всех строк вызывает платформа. Так что нет смысла его звать второй раз.
				// Также такое происходит в форме таблицы значений, но почему то не происходит в результате консоли запросов
				ВсеСтрокиОбновлены = Истина;
			ИначеЕсли Ложь
				Или СтароеТекущееЗначение <> ДопСвойства.ЗначениеТекущейЯчейки 
				Или ТипЗнч(СтароеТекущееЗначение) <> ТипЗнч(ДопСвойства.ЗначениеТекущейЯчейки)
			Тогда
				ТабличноеПоле.ОбновитьСтроки(); // Для окраски текущего значения
				ВсеСтрокиОбновлены = Истина;
			КонецЕсли;
		КонецЕсли;
	КонецЕсли; 
	Возврат ВсеСтрокиОбновлены;

КонецФункции

Процедура ПолеТабличногоДокументаОформитьТекущиеСтрокиЛкс(ЭтаФорма, ПолеТД) Экспорт 
	#Если Сервер И Не Сервер Тогда
		ПолеТД = Новый ТабличныйДокумент;
	#КонецЕсли
	ДопСвойства = ДопСвойстваЭлементаФормыЛкс(ЭтаФорма, ПолеТД);
	Если Ложь
		Или ДопСвойства = Неопределено 
		Или ТипЗнч(ПолеТД.ТекущаяОбласть) = Тип("РисунокТабличногоДокумента")
	Тогда
		Возврат;
	КонецЕсли; 
	ТекВерх = ПолеТД.ТекущаяОбласть.Верх;
	ТекНиз = Мин(ПолеТД.ТекущаяОбласть.Низ, ПолеТД.ВысотаТаблицы);
	Если Ложь
		Или ТекНиз < ТекВерх 
		Или ПолеТД.ТекущаяОбласть.Низ > ПолеТД.ВысотаТаблицы
		Или ПолеТД.ТекущаяОбласть.Лево > ПолеТД.ШиринаТаблицы
	Тогда
		Возврат;
	КонецЕсли; 
	Если ДопСвойства.ВременноОформленныеСтроки = Неопределено Тогда
		ДопСвойства.ВременноОформленныеСтроки = Новый Структура;
	Иначе
		//2. Если выделенные строки не менялись - делаем ничего
		Если Истина
			И ДопСвойства.ВременноОформленныеСтроки.Количество() > 0
			И ТекВерх = ДопСвойства.ВременноОформленныеСтроки.Верх 
			И ТекНиз = ДопСвойства.ВременноОформленныеСтроки.Низ
		Тогда
			Возврат;
		КонецЕсли;
		ПолеТабличногоДокументаВосстановитьОформлениеТекущихСтрокЛкс(ЭтаФорма, ПолеТД);
	КонецЕсли;
	
	ОбластьТекСтроки = ПолеТД.Область(ТекНиз,, ТекВерх);
	// 3. При выделении всего документа, дальнейшие действия не требуются.
	// Более того, если не сделать эту проверку, то дальше упадём с ошибкой, при попытке получения ячейки с координатами (0,х,0,х)
	ВыделенВесьТабДок = ТекВерх = 0 Или ТекНиз = 0;
	Если ВыделенВесьТабДок Тогда
		// обработка выделенных строк на прошлом шаге для случая, когда ВыделенВесьТабДок = Истина, инициирует событие ПриАктивизации.
		// Чтобы не заходить в бесконечный цикл, очистим данные выделенных строк.
		ДопСвойства.ВременноОформленныеСтроки = Неопределено;
		Возврат;
	КонецЕсли;
	
	// 4. Запомним текущие значения обведённости строк
	ВременноОформленныеСтроки = ДопСвойства.ВременноОформленныеСтроки;
	ВременноОформленныеСтроки.Вставить("Верх", ТекВерх);
	ВременноОформленныеСтроки.Вставить("Низ", ТекНиз);
	ВременноОформленныеСтроки.Вставить("ГраницаСверху", ОбластьТекСтроки.ГраницаСверху);
	ВременноОформленныеСтроки.Вставить("ГраницаСнизу", ОбластьТекСтроки.ГраницаСнизу);
	ВременноОформленныеСтроки.Вставить("ЦветРамки", ОбластьТекСтроки.ЦветРамки);
	
	// У разных ячеек строки могут быть разные настройки Границ (настройки обведения) и чтобы вернуть их назад, их надо запомнить.
	// Свойство ГраницаСверху (и все остальные границы) для области будет иметь значение неопределено,
	// если для разных ячеек области у этой границы будут отличаться толщина или тип границы
	// ЦветРамки при этом, может отличаться, и на Границы это никак не повлияет, т.к. ЦветРамки является самостоятельным свойством области, как и сама Граница.
	
	ЕстьТекст = Ложь;
	ЕстьОформление = Ложь;
	УникальныеГраницыВерх = Новый Массив;
	ВременноОформленныеСтроки.Вставить("УникальныеГраницыВерх", УникальныеГраницыВерх);
	УникальныеГраницыНиз = Новый Массив;
	ВременноОформленныеСтроки.Вставить("УникальныеГраницыНиз", УникальныеГраницыНиз);
	Для НомерКолонки = 1 По ПолеТД.ШиринаТаблицы Цикл
		ЯчейкаВерх = ПолеТД.Область(ТекВерх, НомерКолонки, ТекВерх, НомерКолонки);
		Если ЗначениеЗаполнено(ЯчейкаВерх.Текст) Тогда
			ЕстьТекст = Истина;
		КонецЕсли; 
		Если Ложь
			Или ЯчейкаВерх.ЦветРамки.Вид <> ВидЦвета.АвтоЦвет
			Или ЯчейкаВерх.ГраницаСверху.ТипЛинии <> ТипЛинииЯчейкиТабличногоДокумента.НетЛинии
		Тогда 
			ЕстьОформление = Истина;
		КонецЕсли; 
		НастройкиЯчейки = Новый Структура("НомерКолонки, ГраницаСверху, ЦветРамки");
		НастройкиЯчейки.НомерКолонки = НомерКолонки;
		НастройкиЯчейки.ГраницаСверху = ЯчейкаВерх.ГраницаСверху;
		НастройкиЯчейки.ЦветРамки = ЯчейкаВерх.ЦветРамки;
		УникальныеГраницыВерх.Добавить(НастройкиЯчейки);
		ЯчейкаНиз = ПолеТД.Область(ТекНиз, НомерКолонки, ТекНиз, НомерКолонки);
		Если ЗначениеЗаполнено(ЯчейкаНиз.Текст) Тогда
			ЕстьТекст = Истина;
		КонецЕсли; 
		Если Ложь
			Или ЯчейкаНиз.ЦветРамки.Вид <> ВидЦвета.АвтоЦвет
			Или ЯчейкаНиз.ГраницаСнизу.ТипЛинии <> ТипЛинииЯчейкиТабличногоДокумента.НетЛинии
		Тогда 
			ЕстьОформление = Истина;
		КонецЕсли; 
		НастройкиЯчейки = Новый Структура("НомерКолонки, ГраницаСнизу, ЦветРамки");
		НастройкиЯчейки.НомерКолонки = НомерКолонки;
		НастройкиЯчейки.ГраницаСнизу = ЯчейкаНиз.ГраницаСнизу;
		НастройкиЯчейки.ЦветРамки = ЯчейкаНиз.ЦветРамки;
		УникальныеГраницыНиз.Добавить(НастройкиЯчейки);
	КонецЦикла;
	Если ЕстьОформление Тогда
		ТолщинаЛинии = 2; // максимум 3 - ограничение платформы
	ИначеЕсли ЕстьТекст Тогда 
		ТолщинаЛинии = 1;
	Иначе
		ВременноОформленныеСтроки.Очистить();
		Возврат;
	КонецЕсли; 
	Линия = Новый Линия(ТипЛинииЯчейкиТабличногоДокумента.Сплошная, ТолщинаЛинии);
	ЦветРамки = Новый Цвет(250, 204, 31); // Из управляемого приложения
	ВременныеСвойства = Новый Структура("Линия, ЦветРамки", Линия, ЦветРамки);
	ВременноОформленныеСтроки.Вставить("ВременныеСвойства", ВременныеСвойства);
	СтрокаНиз = ПолеТД.Область(ТекВерх, 1, ТекВерх, ПолеТД.ШиринаТаблицы);
	СтрокаНиз.ГраницаСверху = Линия;
	СтрокаНиз.ЦветРамки = ЦветРамки;
	СтрокаВерх = ПолеТД.Область(ТекНиз, 1, ТекНиз, ПолеТД.ШиринаТаблицы);
	СтрокаВерх.ГраницаСнизу = Линия;
	СтрокаВерх.ЦветРамки = ЦветРамки;
	Если Истина
		И ПолеТД.ТекущаяОбласть.Низ - ПолеТД.ТекущаяОбласть.Верх > 0
		И Найти(ПолеТД.ТекущаяОбласть.Имя, "R") > 0 
		И Найти(ПолеТД.ТекущаяОбласть.Имя, "C") = 0 
	Тогда
		// Это диапазон строк
		// Антибаг платформы 8.3.21 https://www.hostedredmine.com/issues/949285  
		ПараметрыОбработчика = Новый Структура;
		ПараметрыОбработчика.Вставить("ТекущаяОбласть", ПолеТД.ТекущаяОбласть.Имя);
		ПараметрыОбработчика.Вставить("ПолеТД", ПолеТД);
		#Если Сервер И Не Сервер Тогда
			ВосстановитьТекущуюОбластьПоляТабличногоДокументаЛкс();
		#КонецЕсли
		ПодключитьОбработчикОжиданияСПараметрамиЛкс("ВосстановитьТекущуюОбластьПоляТабличногоДокументаЛкс", ПараметрыОбработчика,,, Ложь);
	КонецЕсли;
КонецПроцедуры

Процедура ВосстановитьТекущуюОбластьПоляТабличногоДокументаЛкс(Знач ПараметрыОбработчика) Экспорт 
	
	ПолеТД = ПараметрыОбработчика.ПолеТД;
	#Если Сервер И Не Сервер Тогда
		ПолеТД = Новый ТабличныйДокумент;
	#КонецЕсли
	СтараяОбласть = ПолеТД.Область(ПараметрыОбработчика.ТекущаяОбласть);
	Если Истина
		И СтараяОбласть.Верх = ПолеТД.ТекущаяОбласть.Верх 
		И ПолеТД.ТекущаяОбласть.Низ - ПолеТД.ТекущаяОбласть.Верх = 0
	Тогда
		СтарыйОбработчик = ПолеТД.ПолучитьДействие("ПриАктивизацииОбласти");
		ПолеТД.УстановитьДействие("ПриАктивизацииОбласти", Неопределено); // Иначе будет циклическое переключение https://www.hostedredmine.com/issues/956183
		ПолеТД.ТекущаяОбласть = СтараяОбласть;
		ПолеТД.УстановитьДействие("ПриАктивизацииОбласти", СтарыйОбработчик);
	КонецЕсли;

КонецПроцедуры

Процедура ПолеТабличногоДокументаВосстановитьОформлениеТекущихСтрокЛкс(Знач ЭтаФорма, Знач ПолеТД) Экспорт 
	
	#Если Сервер И Не Сервер Тогда
		ПолеТД = Новый ТабличныйДокумент;
	#КонецЕсли
	ДопСвойстваЭлементаФормы = ДопСвойстваЭлементаФормыЛкс(ЭтаФорма, ПолеТД);
	Если ДопСвойстваЭлементаФормы = Неопределено Тогда
		Возврат;
	КонецЕсли;
	ВременноОформленныеСтроки = ДопСвойстваЭлементаФормы.ВременноОформленныеСтроки;
	Если ВременноОформленныеСтроки = Неопределено Тогда
		Возврат;
	КонецЕсли;
	#Если Сервер И Не Сервер Тогда
		ВременноОформленныеСтроки = Новый Структура;
	#КонецЕсли
	Если ВременноОформленныеСтроки.Количество() = 0 Тогда
		Возврат;
	КонецЕсли; 
	ВременныеСвойства = ВременноОформленныеСтроки.ВременныеСвойства;
	Для Каждого НастройкиЯчейки Из ВременноОформленныеСтроки.УникальныеГраницыВерх Цикл
		ТекЯчейкаВерх = ПолеТД.Область(ВременноОформленныеСтроки.Верх, НастройкиЯчейки.НомерКолонки, ВременноОформленныеСтроки.Верх, НастройкиЯчейки.НомерКолонки);
		Если ТекЯчейкаВерх.ГраницаСверху = ВременныеСвойства.Линия Тогда
			ТекЯчейкаВерх.ГраницаСверху = НастройкиЯчейки.ГраницаСверху;
		КонецЕсли;
		Если ТекЯчейкаВерх.ЦветРамки = ВременныеСвойства.ЦветРамки Тогда
			ТекЯчейкаВерх.ЦветРамки = НастройкиЯчейки.ЦветРамки;
		КонецЕсли;
	КонецЦикла;
	Для Каждого НастройкиЯчейки Из ВременноОформленныеСтроки.УникальныеГраницыНиз Цикл
		ТекЯчейкаНиз = ПолеТД.Область(ВременноОформленныеСтроки.Низ, НастройкиЯчейки.НомерКолонки, ВременноОформленныеСтроки.Низ, НастройкиЯчейки.НомерКолонки);
		Если ТекЯчейкаНиз.ГраницаСнизу = ВременныеСвойства.Линия Тогда
			ТекЯчейкаНиз.ГраницаСнизу = НастройкиЯчейки.ГраницаСнизу;
		КонецЕсли;
		Если ТекЯчейкаНиз.ЦветРамки = ВременныеСвойства.ЦветРамки Тогда
			ТекЯчейкаНиз.ЦветРамки = НастройкиЯчейки.ЦветРамки;
		КонецЕсли;
	КонецЦикла;
	ВременноОформленныеСтроки.Очистить();

КонецПроцедуры

Функция ДопСвойстваЭлементаФормыЛкс(Знач ЭтаФорма, Знач ЭлементФормы) Экспорт 
	СлужебныеДанныеФормы = ирОбщий.СлужебныеДанныеФормыЛкс(ЭтаФорма);
	Если СлужебныеДанныеФормы = Неопределено Тогда
		Возврат Неопределено;
	КонецЕсли;
	#Если Сервер И Не Сервер Тогда
		СлужебныеДанныеФормы = Новый Структура;
	#КонецЕсли
	СвойстваЭлементов = Неопределено;
	Если Не СлужебныеДанныеФормы.Свойство("СвойстваЭлементов", СвойстваЭлементов) Тогда
		СвойстваЭлементов = Новый Структура;
		СлужебныеДанныеФормы.Вставить("СвойстваЭлементов", СвойстваЭлементов);
	КонецЕсли;
	СвойстваЭлемента = Неопределено;
	Если Не СвойстваЭлементов.Свойство(ЭлементФормы.Имя, СвойстваЭлемента) Тогда
		СвойстваЭлемента = Новый Структура("КнопкаРежимаОтображения, ВременноОформленныеСтроки, ЗначениеТекущейЯчейки, ЗапретРазметкиВхождений, МенеджерПоиска, Отбор, НеинтерактивноеИзменение,
		|ЗапретОтображения, КнопкаОтображенияПодвала, ЗапретПодвала, КнопкаОформленияТекущихСтрок, ЗапросИтоговПоТаблицеКлючей");
		СвойстваЭлементов.Вставить(ЭлементФормы.Имя, СвойстваЭлемента);
		СвойстваЭлемента.Отбор = ОтборТабличногоПоляЛкс(ЭлементФормы);
	КонецЕсли;
	Возврат СвойстваЭлемента;
КонецФункции

// Основным элементом страницы считается одноименный с ней элемент формы.
//
Функция Форма_ОбновлениеОтображенияЛкс(ЭтаФорма) Экспорт

	Если ТипЗнч(ЭтаФорма) = Тип("УправляемаяФорма") Тогда
		ЭлементыФормы = ЭтаФорма.Элементы;
	Иначе
		ЭлементыФормы = ЭтаФорма.ЭлементыФормы;
		//Если ЭтаФорма.ВводДоступен() Тогда
		//	СлужебныеДанныеФормы = ирОбщий.СлужебныеДанныеФормыЛкс(ЭтаФорма);
		//	Если СлужебныеДанныеФормы.Свойство("ОбновитьПриАктивации") Тогда
		//		СлужебныеДанныеФормы.Удалить("ОбновитьПриАктивации");
		//		//ЭтаФорма.Обновить();
		//	КонецЕсли; 
		//КонецЕсли; 
	КонецЕсли; 
	Для Каждого ЭлементФормы Из ЭлементыФормы Цикл
		Если Истина
			#Если Клиент Тогда
			И ТипЗнч(ЭлементФормы) <> Тип("Панель") 
			#КонецЕсли 
			И Не (Истина
				И ТипЗнч(ЭлементФормы) = Тип("ГруппаФормы")
				И ЭлементФормы.Вид = ВидГруппыФормы.Страницы)
		Тогда
			Продолжить;
		КонецЕсли;
		ирОбщий.ОбновитьЗаголовкиСтраницПанелиЛкс(ЭтаФорма, ЭлементыФормы, ЭлементФормы);
	КонецЦикла;
	Возврат Истина;
		
КонецФункции

Функция Форма_ВосстановитьЗаголовокЛкс(ЭтаФорма) Экспорт

	СлужебныеДанные = ирОбщий.СлужебныеДанныеФормыЛкс(ЭтаФорма);
	ЭтаФорма.Заголовок = СлужебныеДанные.ОригинальныйЗаголовок;
	
КонецФункции

Процедура ФормаОбъекта_ОбновитьЗаголовокЛкс(ЭтаФорма, ПредставлениеОбъекта = "") Экспорт 
	
	СлужебныеДанные = ирОбщий.СлужебныеДанныеФормыЛкс(ЭтаФорма);  
	НовыйЗаголовок = СлужебныеДанные.ОригинальныйЗаголовок;
	Если Ложь
		Или Не ЗначениеЗаполнено(ПредставлениеОбъекта) 
		Или ПредставлениеОбъекта = НовыйЗаголовок 
	Тогда
		Если ирОбщий.МетодРеализованЛкс(ЭтаФорма, "ПредставлениеОбъектаДанных") Тогда
			ПредставлениеОбъекта = ЭтаФорма.ПредставлениеОбъектаДанных();
		ИначеЕсли ЭтаФорма.АвтоЗаголовок И ЭтаФорма.Заголовок <> НовыйЗаголовок Тогда
			ПредставлениеОбъекта = ЭтаФорма.Заголовок;
		ИначеЕсли Не ЭтаФорма.МодальныйРежим Тогда 
			ПредставлениеОбъекта = ирОбщий.ТекущееВремяЛкс();
		КонецЕсли;
	КонецЕсли;
	Если Истина
		И ЗначениеЗаполнено(ПредставлениеОбъекта) 
		И Не ЭтаФорма.МодальныйРежим 
		И СтрДлина(НовыйЗаголовок) > 6
	Тогда
		Фрагменты = ирОбщий.СтрРазделитьЛкс(НовыйЗаголовок, " ");
		НовыеФрагменты = Новый Массив;
		Для Каждого Фрагмент Из Фрагменты Цикл
			НовыеФрагменты.Добавить(ВРег(Лев(Фрагмент, 1)));
			Если НовыеФрагменты.Количество() = 2 Тогда
				Прервать;
			КонецЕсли; 
		КонецЦикла;
		НовыйЗаголовок = ирОбщий.СтрСоединитьЛкс(НовыеФрагменты, "") + "(ИР)";
	КонецЕсли;
	Если ЭтаФорма.КлючУникальности = "Связанный" Тогда
		НовыйЗаголовок = НовыйЗаголовок + " (связь)";
	КонецЕсли; 
	Если ЭтаФорма.РежимВыбора Тогда
		НовыйЗаголовок = НовыйЗаголовок + " (выбор)";
	КонецЕсли;
	Если ЗначениеЗаполнено(ПредставлениеОбъекта) Тогда
		НовыйЗаголовок = НовыйЗаголовок + ": " + ПредставлениеОбъекта;
	КонецЕсли; 
	Если ЭтаФорма.КлючУникальности = "Связанный" Тогда
		Если ЭтаФорма.ВладелецФормы <> Неопределено Тогда
			НовыйЗаголовок = НовыйЗаголовок + " <- """ + ЭтаФорма.ВладелецФормы.Заголовок + """";
		КонецЕсли;
	КонецЕсли; 
	ЭтаФорма.Заголовок = НовыйЗаголовок;

КонецПроцедуры

Процедура ДописатьРежимВыбораВЗаголовокФормыЛкс(ЭтаФорма) Экспорт 
	
	Если ЭтаФорма.РежимВыбора Тогда
		ЭтаФорма.Заголовок = ЭтаФорма.Заголовок + " (выбор)";
	КонецЕсли;

КонецПроцедуры

Процедура УстановитьРежимПриемаОбъектаФормеЛкс(Знач ЭтаФорма, Знач Кнопка, Знач НовыйПриемОбъекта = Неопределено, Знач ОсновнойКлючУникальности = Неопределено) Экспорт 
	#Если Сервер И Не Сервер Тогда
		ЭтаФорма = ОткрытьФорму();
	#КонецЕсли
	Если НовыйПриемОбъекта = Ложь Тогда
		Если ОсновнойКлючУникальности = Неопределено Тогда
			ОсновнойКлючУникальности = Новый УникальныйИдентификатор
		КонецЕсли;
		ЭтаФорма.КлючУникальности = ОсновнойКлючУникальности;
	ИначеЕсли НовыйПриемОбъекта = Истина Тогда
		ЭтаФорма.КлючУникальности = "Связанный";
	КонецЕсли;
	Кнопка.Доступность = Истина
		И (Ложь
			Или ТипЗнч(ЭтаФорма.ВладелецФормы) = Тип("Форма")
			Или ТипЗнч(ЭтаФорма.ВладелецФормы) = Тип("УправляемаяФорма"))
		И ЭтаФорма.ВладелецФормы.Открыта();
	Если Кнопка.Доступность Тогда
		Если ТипЗнч(Кнопка) = Тип("КнопкаФормы") Тогда
		Иначе
			ирОбщий.ОбновитьТекстПослеМаркераВСтрокеЛкс(Кнопка.Подсказка,, "Отправитель - """ + ЭтаФорма.ВладелецФормы.Заголовок + """", Символы.ПС); // Достаточно одного раза
		КонецЕсли;
	Иначе
		Если ТипЗнч(Кнопка) = Тип("КнопкаФормы") Тогда
			Кнопка.Видимость = Ложь;
		КонецЕсли;
	КонецЕсли;
	Кнопка.Пометка = ЭтаФорма.КлючУникальности = "Связанный";
	Если Истина
		И Кнопка.Пометка  
		И ТипЗнч(ЭтаФорма) = Тип("Форма")
		И ЭтаФорма.СоединяемоеОкно
		И ЭтаФорма.ВладелецФормы.СостояниеОкна <> ВариантСостоянияОкна.Прикрепленное
		И ЭтаФорма.СостояниеОкна <> ВариантСостоянияОкна.Прикрепленное
	Тогда 
		ЭтаФорма.Закрыть();
		ЭтаФорма.СостояниеОкна = ВариантСостоянияОкна.Прикрепленное;
		ЭтаФорма.Открыть();
	КонецЕсли;
	ФормаОбъекта_ОбновитьЗаголовокЛкс(ЭтаФорма);

КонецПроцедуры

// Не используется
Процедура ТабличноеПолеПриПолученииДанныхЛкс(ЭтаФорма, Знач Элемент, Знач ОформленияСтрок) Экспорт 
	
	СлужебныеДанныеФормы = ирОбщий.СлужебныеДанныеФормыЛкс(ЭтаФорма);
	Если СлужебныеДанныеФормы.Свойство("ОбработчикиПриВыводеСтроки") Тогда
		ОбработчикиПриВыводеСтроки = СлужебныеДанныеФормы.ОбработчикиПриВыводеСтроки;
		ОбработчикПриВыводеСтроки = ОбработчикиПриВыводеСтроки[Элемент.Имя];
	КонецЕсли; 
	Если Истина
		И ОбработчикПриВыводеСтроки <> Неопределено 
		И Не ирОбщий.МетодРеализованЛкс(ЭтаФорма, ОбработчикПриВыводеСтроки) // Сообщение о его отсутствии выдаем в общем обработчике Форма_ПриОткрытии
	Тогда
		ОбработчикПриВыводеСтроки = Неопределено;
	КонецЕсли; 
	Для Каждого ОформлениеСтроки Из ОформленияСтрок Цикл
		ДанныеСтроки = ОформлениеСтроки.ДанныеСтроки;
		Если ДанныеСтроки = Неопределено Тогда
			Продолжить;
		КонецЕсли; 
		Если ОбработчикПриВыводеСтроки = Неопределено Тогда
			ТабличноеПолеПриВыводеСтрокиЛкс(ЭтаФорма, Элемент, ОформлениеСтроки, ДанныеСтроки);
		Иначе
			Выполнить("ЭтаФорма." + ОбработчикПриВыводеСтроки + "(Элемент, ОформлениеСтроки, ДанныеСтроки);");
		КонецЕсли; 
	КонецЦикла;
	//Сообщить("" + ТекущаяДата() + " обновлено табличное поле """ + Элемент.Имя + """");

КонецПроцедуры

// Процедура - Табличное поле при активизации строки лкс
//
// Параметры:
//  ЭтаФорма		 - 	 - 
//  ТабличноеПоле	 - 	 - 
//  ОбновлятьПодвал	 - 	 - 
//  ОбновлятьСтроки	 - Булево - имеет смысл установить Ложь, если далее в коде будет обязательно выполнено обновление всех строк табличного поля
//
Процедура ТабличноеПолеПриАктивизацииСтрокиЛкс(Знач ЭтаФорма, Знач ТабличноеПоле, Знач ОбновлятьПодвал = Истина) Экспорт 
	
	#Если Сервер И Не Сервер Тогда
		ТабличноеПоле = Новый ТабличноеПоле;
	#КонецЕсли
	Если ТабличноеПоле = Неопределено Тогда
		Возврат;
	КонецЕсли; 
	ТабличноеПоле.РежимВыделенияСтроки = РежимВыделенияСтрокиТабличногоПоля.Ячейка;
	ВсеСтрокиОбновлены = ТабличноеПолеПриАктивацииКолонкиЛкс(ЭтаФорма, ТабличноеПоле);
	Если Не ВсеСтрокиОбновлены Тогда
		ДопСвойства = ДопСвойстваЭлементаФормыЛкс(ЭтаФорма, ТабличноеПоле);
		#Если Сервер И Не Сервер Тогда
			ТабличноеПоле = Новый ТабличноеПоле;
		#КонецЕсли
		НовыеВыделенныеСтроки = ВыделенныеСтрокиТабличногоПоляЛкс(ТабличноеПоле, Ложь);
		// ТекущаяСтрока должна всегда быть последней 
		Если ТабличноеПоле.ТекущаяСтрока <> Неопределено Тогда
			ИндексТекущейСтроки = НовыеВыделенныеСтроки.Найти(ТабличноеПоле.ТекущаяСтрока);
			Если ИндексТекущейСтроки <> Неопределено Тогда
				НовыеВыделенныеСтроки.Удалить(ИндексТекущейСтроки);
			КонецЕсли;
			НовыеВыделенныеСтроки.Добавить(ТабличноеПоле.ТекущаяСтрока);
		КонецЕсли;
		СтарыеВыделенныеСтроки = ДопСвойства.ВременноОформленныеСтроки;
		Если СтарыеВыделенныеСтроки = Неопределено Или СтарыеВыделенныеСтроки.Количество() = 0 Тогда
			СтрокиОбновленияОформления1 = НовыеВыделенныеСтроки;
		Иначе
			СтрокиОбновленияОформления1 = Новый Массив;
			ирОбщий.ПересечьМассивыЛкс(СтарыеВыделенныеСтроки, НовыеВыделенныеСтроки, СтрокиОбновленияОформления1);
			СтрокиОбновленияОформления2 = Новый Массив;
			ирОбщий.ПересечьМассивыЛкс(НовыеВыделенныеСтроки, СтарыеВыделенныеСтроки, СтрокиОбновленияОформления2);
			ирОбщий.ДополнитьМассивЛкс(СтрокиОбновленияОформления1, СтрокиОбновленияОформления2);
			СтараяТекущаяСтрока = СтарыеВыделенныеСтроки[СтарыеВыделенныеСтроки.Вграница()]; 
			Если СтрокиОбновленияОформления1.Найти(СтараяТекущаяСтрока) = Неопределено Тогда
				СтрокиОбновленияОформления1.Добавить(СтараяТекущаяСтрока);
			КонецЕсли;
		КонецЕсли;
		ТабличноеПоле.ОбновитьСтроки(СтрокиОбновленияОформления1);
		ДопСвойства.ВременноОформленныеСтроки = НовыеВыделенныеСтроки;
	КонецЕсли;
	ИндексКолонки = 0;
	Пока ТабличноеПоле.ТекущаяКолонка = Неопределено И ТабличноеПоле.Колонки.Количество() > ИндексКолонки Цикл 
		// Антибаг платформы 8.3.17 https://partners.v8.1c.ru/forum/t/1919341/m/1919341 http://www.hostedredmine.com/issues/877079
		КолонкаТП = ТабличноеПоле.Колонки[ИндексКолонки];
		Если КолонкаТП.Доступность И КолонкаТП.Видимость Тогда
			ТабличноеПоле.ТекущаяКолонка = КолонкаТП;
		КонецЕсли; 
		ИндексКолонки = ИндексКолонки + 1;
	КонецЦикла;
	ТабличноеПолеВключитьСтаруюЦветовуюСхемуЛкс(ТабличноеПоле);
	Если ОбновлятьПодвал Тогда
		ПараметрыОбработчика = Новый Структура;
		ПараметрыОбработчика.Вставить("ЭтаФорма", ЭтаФорма);
		ПараметрыОбработчика.Вставить("ТабличноеПоле", ТабличноеПоле);
		Если ТабличноеПоле.ВыделенныеСтроки.Количество() < 50 Тогда 
			Задержка = 0;
		Иначе
			Задержка = 0.1;
		КонецЕсли;
		#Если Сервер И Не Сервер Тогда
			ирКлиент.ТабличноеПолеОбновитьТекстыПодваловОтложенноЛкс();
		#КонецЕсли
		ПодключитьОбработчикОжиданияСПараметрамиЛкс("ирКлиент.ТабличноеПолеОбновитьТекстыПодваловОтложенноЛкс", ПараметрыОбработчика, Задержка,, Ложь);
	КонецЕсли; 
	ТабличноеПолеОповеститьОбАктивацииСтрокиЛкс(ЭтаФорма, ТабличноеПоле);
	
КонецПроцедуры

Процедура ТабличноеПолеОбновитьТекстыПодваловОтложенноЛкс(Параметры) Экспорт 
	ТабличноеПолеОбновитьТекстыПодваловЛкс(Параметры.ЭтаФорма, Параметры.ТабличноеПоле, Ложь);
КонецПроцедуры

Процедура ТабличноеПолеОповеститьОбАктивацииСтрокиЛкс(Знач ЭтаФорма, Знач ТабличноеПоле) Экспорт 
	
	ОповеститьФормыПодсистемыЛкс("ПриАктивизацииСтроки",, ТабличноеПоле, ЭтаФорма);

КонецПроцедуры

Процедура ТабличноеПолеВключитьСтаруюЦветовуюСхемуЛкс(Знач Элемент) Экспорт 
	
	// Переключаем цветовую схему на старый вариант (без градиентов и с подсветкой текущей колонки) https://partners.v8.1c.ru/forum/t/898034/m/898082
	Если Элемент.Колонки.Количество() > 0 И Элемент.Колонки[0].ЦветФонаШапки <> ЦветаСтиля.ЦветФонаКнопки Тогда
		Элемент.Колонки[0].ЦветФонаШапки = ЦветаСтиля.ЦветФонаКнопки;
	КонецЕсли;

КонецПроцедуры

Процедура ИнтерактивноЗаписатьВКолонкуФлажкаЛкс(Знач Элемент, Знач Колонка, Знач НовоеЗначение = Неопределено, ВосстанавитьТекущуюКолонку = Истина) Экспорт 
	
	#Если Сервер И Не Сервер Тогда
		Элемент = Новый ТабличноеПоле;
		Колонка = Элемент.Колонки.Добавить();
	#КонецЕсли
	Если НовоеЗначение = Неопределено Тогда
		НовоеЗначение = Не Элемент.ТекущаяСтрока[Колонка.Данные];
	КонецЕсли; 
	ИнтерактивноЗаписатьВКолонкуТабличногоПоляЛкс(Элемент, Колонка, НовоеЗначение,, ВосстанавитьТекущуюКолонку,,, Истина); 

КонецПроцедуры

Процедура ТабличноеПоле_ИнтерактивноУстановитьПометкуТекущейСтрокиЛкс(ТабличноеПоле, КолонкаПометки, НоваяПометка = Неопределено) Экспорт 
	#Если Сервер И Не Сервер Тогда
		ТабличноеПоле = Новый ТабличноеПоле;
	#КонецЕсли
	ТекущаяСтрока = ТабличноеПоле.ТекущаяСтрока;
	Если ТекущаяСтрока = Неопределено Тогда
		Возврат;
	КонецЕсли; 
	Если КолонкаПометки = Неопределено Тогда
		КолонкаПометки = КолонкаПометкиТабличногоПоляЛкс(ТабличноеПоле);
	КонецЕсли; 
	Если КолонкаПометки = Неопределено Тогда
		Возврат;
	КонецЕсли; 
	ИнтерактивноЗаписатьВКолонкуФлажкаЛкс(ТабличноеПоле, КолонкаПометки, НоваяПометка);
КонецПроцедуры

Функция КолонкаПометкиТабличногоПоляЛкс(Знач ТабличноеПоле)
	
	#Если Сервер И Не Сервер Тогда
		ТабличноеПоле = Новый ТабличноеПоле;
	#КонецЕсли
	КолонкаТекущая = ТабличноеПоле.ТекущаяКолонка;
	Если КолонкаТекущая = Неопределено Тогда
		Возврат Неопределено;
	КонецЕсли;
	Если Истина
		//И ТабличноеПоле.ТекущаяКолонка <> Неопределено
		//И ТабличноеПоле.Значение.Количество() > 0
		//И ТипЗнч(ТабличноеПоле.Значение[0][ТабличноеПоле.ТекущаяКолонка.Данные]) = Тип("Булево")
		И КолонкаТекущая.ЭлементУправления <> Неопределено 
		И ТипЗнч(КолонкаТекущая.ЭлементУправления.Значение) = Тип("Булево") 
	Тогда
		Колонка = ТабличноеПоле.ТекущаяКолонка;
	КонецЕсли; 
	Если Колонка = Неопределено Тогда
		Колонка = ТабличноеПоле.Колонки.Найти("Пометка");
	КонецЕсли; 
	Если Колонка = Неопределено Тогда
		Колонка = ТабличноеПоле.Колонки.Найти("Использование");
	КонецЕсли;
	Если Колонка = Неопределено Тогда
		КолонкаПервая = ТабличноеПоле.Колонки[0];
		Если КолонкаПервая.Имя = "НомерСтроки" И ТабличноеПоле.Колонки.Количество() > 1 Тогда
			КолонкаПервая = ТабличноеПоле.Колонки[1];
		КонецЕсли; 
		Если Истина
			И КолонкаПервая.ЭлементУправления <> Неопределено 
			И ТипЗнч(КолонкаПервая.ЭлементУправления.Значение) = Тип("Булево") 
		Тогда
			Колонка = КолонкаПервая;
		КонецЕсли; 
	КонецЕсли;
	Возврат Колонка;

КонецФункции

Процедура УстановитьФокусВводаФормеЛкс(ФормаВладелец = Неопределено, ИспользоватьЭмуляциюНажатияКлавиш = Ложь) Экспорт 
	
	// Для обхода ошибок платформы 8.3. Форма при закрытии может вернуть фокус ввода главному окну вместо отображаемому на переднем плане дочернему окну.
	Если ФормаВладелец <> Неопределено Тогда
		ФормаВладелец.Открыть(); 
	КонецЕсли; 
	мПлатформа = ирКэш.Получить();
	#Если Сервер И Не Сервер Тогда
		мПлатформа = Обработки.ирПлатформа.Создать();
	#КонецЕсли
	Если Истина
		И мПлатформа.ИспользоватьЭмуляциюНажатияКлавиш() 
		И мПлатформа.МодальныеГруппы.Количество() = 0 // https://www.hostedredmine.com/issues/938929
	Тогда
		ВосстановитьФокусВводаОткрытиемПустышкиЛкс(); // https://www.hostedredmine.com/issues/949043
		// Так отображается индикатор изменения NumLock, если он был включен
		ОтправитьНажатияКлавишЛкс("%"); // Alt
		ОтправитьНажатияКлавишЛкс("%"); // Alt
	Иначе
		// Так может переставать мигать каретка https://www.hostedredmine.com/issues/936823
		#Если Сервер И Не Сервер Тогда
			ВосстановитьФокусВводаГлЛкс();
		#КонецЕсли
		ВыполнитьОтдельноЛкс("ВосстановитьФокусВводаГлЛкс", ФормаВладелец);
	КонецЕсли; 

КонецПроцедуры

Процедура ВосстановитьФокусВводаОткрытиемПустышкиЛкс() Экспорт 
	
	ФормаПустышка = ирКэш.ФормаПустышкаЛкс();
	Попытка
		ФормаПустышка.Открыть();
		ФормаПустышка.Закрыть(); 
	Исключение
		// Главное окно уже закрыто https://www.hostedredmine.com/issues/956380
	КонецПопытки;
	
КонецПроцедуры

Процедура ТабличноеПолеОтбораКомпоновкиПеретаскиваниеЛкс(ЭтаФорма, Элемент, ПараметрыПеретаскивания, СтандартнаяОбработка, Строка, Колонка) Экспорт 
	
	Если Истина
		И ТипЗнч(ПараметрыПеретаскивания.Значение) = Тип("Массив") 
		И ПараметрыПеретаскивания.Действие = ДействиеПеретаскивания.Перемещение
	Тогда
		ТипЭлемента = ТипЗнч(ПараметрыПеретаскивания.Значение[0]);
		Если Ложь
			Или ТипЭлемента = Тип("ДоступноеПолеКомпоновкиДанных")
			Или ТипЭлемента = Тип("ДоступноеПолеОтбораКомпоновкиДанных")
		Тогда
			Если Истина
				И Строка <> Неопределено
				И Колонка <> Неопределено
				И Найти(Колонка.Данные, "ПравоеЗначение") = 1
			Тогда
				СтароеЗначение = Строка.ПравоеЗначение;
				Строка.ПравоеЗначение = ПараметрыПеретаскивания.Значение[0].Поле;
				Если ЛиЗапрещенныйЭлементОтбораКомпоновкиЛкс(Строка) Тогда
					Строка.ПравоеЗначение = СтароеЗначение;
				Иначе
					СтандартнаяОбработка = Ложь;
				КонецЕсли;
				//ИначеЕсли Найти(Колонка.Данные, "ЛевоеЗначение") = 1 Тогда // Удобнее штатным способом добавлять новый элемент сразу в нужную позицию
				//	СтандартнаяОбработка = Ложь;
				//	Строка.ЛевоеЗначение = ПараметрыПеретаскивания.Значение[0].Поле;
			Иначе 
				//Если ТипЗнч(Строка) = Тип("ЭлементОтбораКомпоновкиДанных") Тогда
				//	Родитель = ирОбщий.РодительСтрокиДереваЛкс(Строка, Элемент.Значение);
				//ИначеЕсли ТипЗнч(Строка) = Тип("ГруппаЭлементовОтбораКомпоновкиДанных") Тогда
				//	Родитель = Строка;
				//Иначе
				//	Родитель = Элемент.Значение;
				//КонецЕсли; 
				//Для Каждого ДоступноеПоле Из ПараметрыПеретаскивания.Значение Цикл
				//	#Если Сервер И Не Сервер Тогда
				//		ДоступноеПоле = Новый НастройкиКомпоновкиДанных;
				//		ДоступноеПоле = ДоступноеПоле.Выбор.ДоступныеПоляВыбора.НайтиПоле();
				//	#КонецЕсли
				//	НовыйЭлемент = Родитель.Элементы.Добавить(Тип("ЭлементОтбораКомпоновкиДанных"));
				//	НовыйЭлемент.Использование = Истина;
				//	НовыйЭлемент.ЛевоеЗначение = ДоступноеПоле.Поле;
				//	Элемент.ТекущаяСтрока = НовыйЭлемент;
				//КонецЦикла;
			КонецЕсли; 
		КонецЕсли; 
	КонецЕсли;

КонецПроцедуры

Функция ЛиЗапрещенныйЭлементОтбораКомпоновкиЛкс(Знач ДанныеСтроки, Знач Сообщить = Ложь) Экспорт 
	
	Результат = Истина
		И ТипЗнч(ДанныеСтроки) = Тип("ЭлементОтбораКомпоновкиДанных")
		И ТипЗнч(ДанныеСтроки.ПравоеЗначение) = Тип("ПолеКомпоновкиДанных")
		И (Ложь
			Или ДанныеСтроки.ВидСравнения = ВидСравненияКомпоновкиДанных.НеВИерархии 
			Или ДанныеСтроки.ВидСравнения = ВидСравненияКомпоновкиДанных.ВИерархии);
	Если Результат И Сообщить Тогда 
		ирОбщий.СообщитьЛкс("В правом значении иерархического вида сравнения должна быть значение", СтатусСообщения.Внимание);
	КонецЕсли;
	Возврат Результат

КонецФункции

Процедура ТабличноеПолеВставитьКолонкуНомерСтрокиЛкс(Знач ТабличноеПоле) Экспорт 
	
	ИмяКолонкиНомерСтроки = ирКэш.ИмяКолонкиНомерСтрокиЛкс();
	КолонкаТП = ТабличноеПоле.Колонки.Найти(ИмяКолонкиНомерСтроки);
	Если КолонкаТП = Неопределено Тогда
		КолонкаТП = ТабличноеПоле.Колонки.Вставить(0); 
		КолонкаТП.Имя = ИмяКолонкиНомерСтроки;
		КолонкаТП.ТекстШапки = "№";
		КолонкаТП.ПодсказкаВШапке = "Номер элемента в пределах родителя (служебная)";
		КолонкаТП.ТолькоПросмотр = Истина;
		КолонкаТП.Ширина = ирОбщий.МинимальнаяШиринаКолонкиЛкс();
	Иначе
		ТабличноеПоле.Колонки.Сдвинуть(КолонкаТП, - ТабличноеПоле.Колонки.Индекс(КолонкаТП));
	КонецЕсли;

КонецПроцедуры

Процедура _РасширенныйВыборПравогоЗначенияОтбораКомпоновкиЛкс(ТабличноеПолеОтбора) Экспорт 
	
	ТекущаяСтрока = ТабличноеПолеОтбора.ТекущаяСтрока;
	Если Ложь
		Или ТекущаяСтрока = Неопределено 
		Или ТипЗнч(ТекущаяСтрока) = Тип("ОтборКомпоновкиДанных")
		Или ТипЗнч(ТекущаяСтрока) = Тип("ГруппаЭлементовОтбораКомпоновкиДанных")
	Тогда
		Возврат;
	КонецЕсли; 
	ЗначениеОтбора = ТекущаяСтрока.ПравоеЗначение;
	КолонкаТП = ТабличноеПолеОтбора.Колонки.ПравоеЗначениеДляКраткогоОтображенияЭлемента;
	ТабличноеПолеОтбора.ТекущаяКолонка = КолонкаТП;
	Если ТипЗнч(ЗначениеОтбора) <> Тип("СписокЗначений") Тогда
		Если ирОбщий.ЛиСсылкаНаОбъектБДЛкс(ЗначениеОтбора, Ложь) Тогда
			ТабличноеПолеОтбора.ИзменитьСтроку();
			ОткрытьФормуСпискаЛкс(ирОбщий.ПолучитьПолноеИмяМДТипаЛкс(ТипЗнч(ЗначениеОтбора)),,, КолонкаТП.ЭлементУправления, Истина,, ЗначениеОтбора);
		КонецЕсли;
	Иначе
		Результат = ОткрытьЗначениеЛкс(ЗначениеОтбора, Истина);
		Если Результат Тогда
			ТекущаяСтрока.ПравоеЗначение = ЗначениеОтбора;
			ТекущаяСтрока.Использование = Истина;
		КонецЕсли; 
	КонецЕсли; 
	
КонецПроцедуры

Функция ПоказатьДоступноеПолеЭлементаНастроекКомпоновкиЛкс(ЭтаФорма, Знач ТабличноеПолеДоступныхПолей, Знач ТабличноеПолеНастроек) Экспорт 
	
	ТекущаяСтрока = ТабличноеПолеНастроек.ТекущаяСтрока;
	Если ТипЗнч(ТекущаяСтрока) = Тип("ЭлементОтбораКомпоновкиДанных") Тогда
		ИскомоеПоле = ТекущаяСтрока.ЛевоеЗначение;
		Если ТабличноеПолеНастроек.ТекущаяКолонка = ТабличноеПолеНастроек.Колонки.ПравоеЗначениеДляКраткогоОтображенияЭлемента Тогда
			ИскомоеПоле = ТекущаяСтрока.ПравоеЗначение;
		КонецЕсли; 
	ИначеЕсли Ложь
		Или ТипЗнч(ТекущаяСтрока) = Тип("ЭлементПорядкаКомпоновкиДанных")
		Или ТипЗнч(ТекущаяСтрока) = Тип("ВыбранноеПолеКомпоновкиДанных")
		Или ТипЗнч(ТекущаяСтрока) = Тип("ПолеГруппировкиКомпоновкиДанных")
	Тогда
		ИскомоеПоле = ТекущаяСтрока.Поле;
	Иначе
		Возврат Неопределено;
	КонецЕсли; 
	ДоступноеПоле = ТабличноеПолеДоступныхПолей.Значение.НайтиПоле(Новый ПолеКомпоновкиДанных(ИскомоеПоле));
	Если ДоступноеПоле <> Неопределено Тогда
		ТабличноеПолеДоступныхПолей.ТекущаяСтрока = ДоступноеПоле;
		ЭтаФорма.ТекущийЭлемент = ТабличноеПолеДоступныхПолей;
	КонецЕсли;
	Возврат ДоступноеПоле;

КонецФункции

Процедура КнопкаОтображатьПустыеИИдентификаторыНажатиеЛкс(Кнопка) Экспорт 
	
	МассивСостояний = ирОбщий.СостоянияКнопкиОтображатьПустыеИИдентификаторыЛкс();
	Если ТипЗнч(Кнопка) = Тип("КнопкаКоманднойПанели") Тогда
		ТекстКнопки = Кнопка.Текст;
	Иначе
		ТекстКнопки = Кнопка.Заголовок;
	КонецЕсли;
	Если ТекстКнопки = МассивСостояний[2] Тогда
		Кнопка.Пометка = Ложь;
		НовыйТекстКнопки = МассивСостояний[0];
		Кнопка.Картинка = ирКэш.КартинкаПоИмениЛкс("ирПусто");
	ИначеЕсли ТекстКнопки = МассивСостояний[1] Тогда
		Кнопка.Пометка = Истина;
		НовыйТекстКнопки = МассивСостояний[2];
		Кнопка.Картинка = ирКэш.КартинкаПоИмениЛкс("ирИдентификатор");
	Иначе//Если ТекстКнопки = МассивСостояний[0] Тогда
		Кнопка.Пометка = Истина;
		НовыйТекстКнопки = МассивСостояний[1];
		Кнопка.Картинка = ирКэш.КартинкаПоИмениЛкс("ирПусто");
	КонецЕсли; 
	Если ТипЗнч(Кнопка) = Тип("КнопкаКоманднойПанели") Тогда
		Кнопка.Текст = НовыйТекстКнопки;
	Иначе
		Кнопка.Заголовок = НовыйТекстКнопки;
	КонецЕсли;
	
КонецПроцедуры

Процедура ПрименитьИзмененияИЗакрытьФормуЛкс(ЭтаФорма, ЗначениеВыбора = Неопределено) Экспорт

	ЭтаФорма.Модифицированность = Ложь;
	Если Ложь
		Или ЭтаФорма.ВладелецФормы <> Неопределено 
		Или Не ЭтаФорма.Открыта()
	Тогда
		ЭтаФорма.ОповеститьОВыборе(ЗначениеВыбора);
	КонецЕсли; 
	Если ЭтаФорма.Открыта() Тогда
		ЭтаФорма.Закрыть(ЗначениеВыбора);
	КонецЕсли; 
	//Если ЭтаФорма.Открыта() Тогда
	//	ЭтаФорма.Закрыть(ЗначениеВыбора);
	//Иначе//Если ЭтаФорма.МодальныйРежим Тогда
	//	ЭтаФорма.ОповеститьОВыборе(ЗначениеВыбора);
	//КонецЕсли; 

КонецПроцедуры

//
// Параметры:
//   ЯзыкПрограммы - Число - 0 - встроенный язык, 1 - язык запросов, 2 - язык выражений СКД
Функция НайтиВозможныеСтрокиОписанияСловаВСинтаксПомощникеЛкс(Знач Слово, ЯзыкПрограммы = 0, ПоискСУчетомТипаСлова = Истина) Экспорт

	мПлатформа = ирКэш.Получить();
	мПлатформа.ИнициализацияОписанияМетодовИСвойств();
	МассивВозможныхТиповСлова = Новый Массив;
	МассивВозможныхТиповСлова.Добавить("Конструктор");
	Слово = НРег(Слово);
	Если Ложь
		Или Не ПоискСУчетомТипаСлова
		Или Прав(Слово, 1) = "(" 
	Тогда
		Если Прав(Слово, 1) = "(" Тогда
			Слово = ирОбщий.СтрокаБезКонцаЛкс(Слово, 1);
		КонецЕсли; 
		МассивВозможныхТиповСлова.Добавить("Метод");
	КонецЕсли; 
	Если Ложь
		Или Не ПоискСУчетомТипаСлова
		Или Прав(Слово, 1) <> "(" 
	Тогда
		МассивВозможныхТиповСлова.Добавить("Свойство");
		МассивВозможныхТиповСлова.Добавить("Конструкция");
		МассивВозможныхТиповСлова.Добавить("Событие");
		МассивВозможныхТиповСлова.Добавить("Таблица");
	КонецЕсли;
	ТаблицаСтруктурВозможныхТиповКонтекста = мПлатформа.НоваяТаблицаСтруктурТипа();
	Для Каждого ВозможныйТипСлова Из МассивВозможныхТиповСлова Цикл
		Если ВозможныйТипСлова = "Конструктор" Тогда
			КлючПоиска = Новый Структура("ТипКонтекста, ТипСлова, ЯзыкПрограммы, ТипЯзыка", Слово, ВозможныйТипСлова, ЯзыкПрограммы, "");
		Иначе
			КлючПоиска = Новый Структура("НСлово, ТипСлова, ЯзыкПрограммы, ТипЯзыка", Слово, ВозможныйТипСлова, ЯзыкПрограммы, "");
		КонецЕсли;
		НайденныеСтроки = мПлатформа.ТаблицаКонтекстов.НайтиСтроки(КлючПоиска);
		Для Каждого НайденнаяСтрока Из НайденныеСтроки Цикл
			ЗаполнитьЗначенияСвойств(ТаблицаСтруктурВозможныхТиповКонтекста.Добавить(), Новый Структура("СтрокаОписания", НайденнаяСтрока));
		КонецЦикла;
		НайденныеСтроки = мПлатформа.ТаблицаШаблоновКонтекстов.НайтиСтроки(КлючПоиска);
		Для Каждого НайденнаяСтрока Из НайденныеСтроки Цикл
			ЗаполнитьЗначенияСвойств(ТаблицаСтруктурВозможныхТиповКонтекста.Добавить(), Новый Структура("СтрокаОписания", НайденнаяСтрока));
		КонецЦикла;
	КонецЦикла;
	КлючПоиска = Новый Структура("НСлово, ЯзыкПрограммы", Слово, ЯзыкПрограммы);
	НайденныеСтроки = мПлатформа.ТаблицаОбщихТипов.НайтиСтроки(КлючПоиска);
	Для Каждого НайденнаяСтрока Из НайденныеСтроки Цикл
		ЗаполнитьЗначенияСвойств(ТаблицаСтруктурВозможныхТиповКонтекста.Добавить(), Новый Структура("СтрокаОписания", НайденнаяСтрока));
	КонецЦикла;
	Возврат ТаблицаСтруктурВозможныхТиповКонтекста;

КонецФункции

// Открывает форму синтакс-помощника и загружает в нее нужную страницу, подсвечивая заданную строку.
//
// Параметры:
//  ВнутреннийПутьКОписанию - Строка - внутренний путь к странице синтакс-помощника;
//  СтрокаДляПодсветки - Строка - которую нужно подсветить в тексте страницы.
//
// Возвращаемое значение:
//  Форма.
//
Функция ОткрытьСтраницуСинтаксПомощникаЛкс(ВнутреннийПутьКОписанию, СтрокаДляПодсветки = "", ВладелецФормы = Неопределено, КлючУникальности = Неопределено) Экспорт

	Если ирОбщий.ПроверитьПлатформаНеWindowsЛкс() Тогда
		Возврат Неопределено;
	КонецЕсли; 
	Если ВнутреннийПутьКОписанию = "" Тогда
		Возврат Неопределено; 
	КонецЕсли; 
	ФормаСправка = ПолучитьФормуЛкс("Обработка.ирСинтаксПомощник.Форма", , , КлючУникальности);
	ФормаСправка.ВладелецФормы = ВладелецФормы;
	ФормаСправка.ОткрытьАдрес(ВнутреннийПутьКОписанию, СтрокаДляПодсветки);
	ФормаСправка.ВладелецФормы = Неопределено;
	Возврат ФормаСправка;

КонецФункции

// Параметры:
//    ЭтаФорма - Форма - для возвращения фокуса ввода 
Функция ОткрытьОписаниеТипаПоТипуЛкс(Знач Тип, Знач ЭтаФорма = Неопределено) Экспорт 
	
	мПлатформа = ирКэш.Получить();
	#Если Сервер И Не Сервер Тогда
		мПлатформа = Обработки.ирПлатформа.Создать();
	#КонецЕсли
	СтруктураТипа = мПлатформа.СтруктураТипаИзКонкретногоТипа(Тип);
	ИмяОбщегоТипа = СтруктураТипа.ИмяОбщегоТипа;
	Результат = ОткрытьОписаниеТипаПоИмениТипаЛкс(ИмяОбщегоТипа, ЭтаФорма);
	Возврат Результат;
	
КонецФункции

Функция ОткрытьОписаниеТипаПоИмениТипаЛкс(Знач ИмяОбщегоТипа, Знач ЭтаФорма = Неопределено) Экспорт 
	
	мПлатформа = ирКэш.Получить();
	#Если Сервер И Не Сервер Тогда
		мПлатформа = Обработки.ирПлатформа.Создать();
	#КонецЕсли
	СтрокаОбщегоТипа = мПлатформа.ТаблицаОбщихТипов.Найти(НРег(ИмяОбщегоТипа), "НСлово");
	Если СтрокаОбщегоТипа = Неопределено Тогда
		Возврат Неопределено;
	КонецЕсли;
	Результат = ОткрытьСтраницуСинтаксПомощникаЛкс(СтрокаОбщегоТипа.ПутьКОписанию, , ЭтаФорма);
	Возврат Результат;

КонецФункции

// Обходит строки табличного поля и имитирует редактирование и выбор пользователем заданного значения.
//
// Параметры:
//  ТабличноеПоле			 - ТабличноеПоле;
//  ЗначениеОбработки		 - Произвольные - значение, которое будем записывать в ячейки; Структура(Параметры, Формула)
//  ТипИсточника - Строка, *Неопределено - "ТаблицаЗначений", "ТабличнаяЧасть";
//  Колонка      - КолонкаТабличногоПоля, *Неопределено - колонка в которой обходим ячейки, по умолчанию текущая;
//  ТолькоВыделенныеСтроки - Булево, *Истина - обходить только выделенные строки.
//  ИнтерактивнаяУстановка	 - Булево, *Истина - 
//  НаСервере				 - Булево, *Ложь - Вычислять формулу на сервере
//  СтруктураОтбора			 - Структура, *Неопределено - 
//
Процедура УстановитьЗначениеВКолонкеТабличногоПоляТЧИлиТЗЛкс(ЭтаФорма, ТабличноеПоле, ЗначениеОбработки, Знач ТипИсточника = Неопределено, Знач Колонка = Неопределено, Знач ТолькоВыделенныеСтроки = Истина,
	Знач ИнтерактивнаяУстановка = Истина, Знач НаСервере = Ложь, Знач СтруктураОтбора = Неопределено, Знач МетаданныеВыбора = Неопределено) Экспорт

	#Если Сервер И Не Сервер Тогда
		ТабличноеПоле = Новый ТабличноеПоле;
	#КонецЕсли
	Если ТабличноеПоле.ТолькоПросмотр Тогда
		Возврат;
	КонецЕсли; 
	Если Истина
		//И ИнтерактивнаяУстановка
		И Колонка <> Неопределено
		И Не Колонка.Видимость 
	Тогда
		ирОбщий.СообщитьЛкс(ирОбщий.СтрШаблонИменЛкс("Колонка %1 не видима. Поэтому изменение значений в ней не может быть выполнено.",, Колонка.ТекстШапки));
		Возврат;
	КонецЕсли; 
	ДопСвойства = ДопСвойстваЭлементаФормыЛкс(ЭтаФорма, ТабличноеПоле);
	ЗначениеТабличногоПоля = ирОбщий.ДанныеЭлементаФормыЛкс(ТабличноеПоле);
	Если ТипИсточника = "" Тогда
		ТипИсточника = ирОбщий.ОбщийТипДанныхТабличногоПоляЛкс(ТабличноеПоле);
	КонецЕсли; 
	СтарыеВключенныеЭлементыОтбора = Новый Массив;
	ЕстьОтборСтрок = Ложь
		Или ТипИсточника = "ТабличнаяЧасть" 
		Или ТипИсточника = "НаборЗаписей";
	ТекстВопросаУчетаОтбора = "";
	Если ЕстьОтборСтрок Тогда
		ТекстВопросаУчетаОтбора = " отобранные";
	КонецЕсли;
	Если ТолькоВыделенныеСтроки Тогда
		Если Истина
			И ТабличноеПоле.ВыделенныеСтроки.Количество() = 1
			И ТипИсточника <> "ДеревоЗначений"
		Тогда
			Ответ = Вопрос("Выделена только одна строка. Хотите обработать все" + ТекстВопросаУчетаОтбора + " строки?", РежимДиалогаВопрос.ДаНет);
			Если Ответ = КодВозвратаДиалога.Да Тогда
				ТолькоВыделенныеСтроки = Ложь;
			КонецЕсли;
		КонецЕсли;
	ИначеЕсли ЕстьОтборСтрок Тогда
		Если ирОбщий.ЛиОтборУстановленЛкс(ТабличноеПоле.ОтборСтрок) Тогда
			Ответ = Вопрос("Хотите обработать" + ТекстВопросаУчетаОтбора + " (Да) или все (Нет) строки?", РежимДиалогаВопрос.ДаНет,, КодВозвратаДиалога.Да);
			Если Ответ = КодВозвратаДиалога.Нет Тогда
				Для Каждого ЭлементОтбора Из ТабличноеПоле.ОтборСтрок Цикл
					Если ЭлементОтбора.Использование Тогда
						ЭлементОтбора.Использование = Ложь;
						СтарыеВключенныеЭлементыОтбора.Добавить(ЭлементОтбора.Имя);
					КонецЕсли; 
				КонецЦикла;
			КонецЕсли;
		КонецЕсли; 
	КонецЕсли;
	СтараяТекущаяСтрока = ТабличноеПоле.ТекущаяСтрока;
	СтараяТекущаяКолонка = ТабличноеПолеТекущаяКолонкаЛкс(ТабличноеПоле);
	СтарыеВыделенныеСтроки = ВыделенныеСтрокиТабличногоПоляЛкс(ТабличноеПоле);
	//ТабличноеПолеСостояниеСтрокЛкс(ТабличноеПоле, ?); // Неизвестна ключевая колонка
	Если Колонка = Неопределено Тогда
		Колонка = СтараяТекущаяКолонка;
	Иначе
		ирОбщий.УстановитьТекущуюКолонкуТаблицыФормыЛкс(ТабличноеПоле, Колонка);
	КонецЕсли;
	КлючиСтрокДляОбработки = Новый Массив;
	Если ТолькоВыделенныеСтроки Тогда
		Для Каждого ВыделеннаяСтрока Из ТабличноеПоле.ВыделенныеСтроки Цикл
			КлючиСтрокДляОбработки.Добавить(ВыделеннаяСтрока);
		КонецЦикла;
	Иначе
		Если ЕстьОтборСтрок Или СтруктураОтбора <> Неопределено Тогда
			КлючеваяКолонка = ирОбщий.ПеревестиСтроку("НомерСтроки");
			Построитель = ПостроительТабличногоПоляСОтборомКлиентаЛкс(ТабличноеПоле, СтруктураОтбора);
			#Если Сервер И Не Сервер Тогда
			    Построитель = Новый ПостроительЗапроса;
			#КонецЕсли
			Построитель.ВыбранныеПоля.Очистить();
			Построитель.ВыбранныеПоля.Добавить(КлючеваяКолонка);
			ТаблицаРезультата = Построитель.Результат.Выгрузить();
			Для Каждого СтрокаРезультата Из ТаблицаРезультата Цикл
				КлючиСтрокДляОбработки.Добавить(СтрокаРезультата[КлючеваяКолонка] - 1); 
			КонецЦикла;
		ИначеЕсли ТипИсточника = "ТаблицаЗначений" Тогда 
			Для Каждого СтрокаТаблицы Из ЗначениеТабличногоПоля Цикл
				Если ТипЗнч(ТабличноеПоле) = Тип("ТаблицаФормы") Тогда
					КлючСтроки = СтрокаТаблицы.ПолучитьИдентификатор();
				Иначе
					КлючСтроки = СтрокаТаблицы;
				КонецЕсли; 
				КлючиСтрокДляОбработки.Добавить(КлючСтроки);
			КонецЦикла;
		ИначеЕсли ТипЗнч(ЗначениеТабличногоПоля) = Тип("ВыбранныеПоляКомпоновкиДанных") Тогда 
			КлючиСтрокДляОбработки = ирОбщий.ВсеВыбранныеПоляГруппировкиКомпоновкиЛкс(ЗначениеТабличногоПоля);
		КонецЕсли;
	КонецЕсли;
	Если ТипЗнч(ТабличноеПоле) = Тип("ТабличноеПоле") Тогда
		ЭлементУправления = Колонка.ЭлементУправления;
		ИнтерактивнаяУстановка = Истина
			И ИнтерактивнаяУстановка
			И ДопСвойства.НеинтерактивноеИзменение <> Истина
			И (Ложь
				Или ЗначениеЗаполнено("" + ЭлементУправления.ПолучитьДействие("ПриИзменении"))
				Или ЗначениеЗаполнено("" + ТабличноеПоле.ПолучитьДействие("ПриНачалеРедактирования")));
		ПроверятьОформлениеСтроки = ДопСвойства.НеинтерактивноеИзменение <> Истина;
		ДействиеПриВыводеСтроки = ТабличноеПоле.ПолучитьДействие("ПриВыводеСтроки");
	Иначе
		ЭлементУправления = Колонка;
	КонецЕсли;
	ПутьКДаннымКолонки = ирОбщий.ПутьКДаннымКолонкиТабличногоПоляЛкс(ТабличноеПоле, Колонка);
	ИспользоватьИндикатор = ПроверятьОформлениеСтроки Или ИнтерактивнаяУстановка; 
	Индикатор = ирОбщий.ПолучитьИндикаторПроцессаЛкс(КлючиСтрокДляОбработки.Количество(), "Групповая установка значения");
	ПоследняяОбработаннаяСтрока = Неопределено; 
	ОформлениеСтроки = Неопределено;
	КоличествоПропущенных = 0;
	Для Каждого КлючСтроки Из КлючиСтрокДляОбработки Цикл
		ОбработкаПрерыванияПользователя();
		Если ИспользоватьИндикатор Тогда
			ирОбщий.ОбработатьИндикаторЛкс(Индикатор);
		КонецЕсли; 
		Если ТипЗнч(ТабличноеПоле) = Тип("ТаблицаФормы") Тогда
			ДанныеСтроки = ТабличноеПоле.ДанныеСтроки(КлючСтроки);
			ТекущаяСтрока = КлючСтроки;
		Иначе
			Если ТипЗнч(КлючСтроки) = Тип("Число") Тогда
				ТекущаяСтрока = ЗначениеТабличногоПоля[КлючСтроки];
			Иначе
				ТекущаяСтрока = КлючСтроки;
			КонецЕсли;
			ДанныеСтроки = ТекущаяСтрока;
			Если ПроверятьОформлениеСтроки Тогда
				Если ОформлениеСтроки = Неопределено Тогда
					//ТабличноеПоле.ОбновитьСтроки(ДанныеСтроки); // Чтобы функция ОформлениеСтроки() гарантировано вернула актуальное оформление
					ОформлениеСтроки = ТабличноеПоле.ОформлениеСтроки(ДанныеСтроки); // Каждый раз это вызывать очень долго
				КонецЕсли;
				Если ДействиеПриВыводеСтроки <> Неопределено Тогда
					ДопСвойства.ЗапретОтображения = Истина;
					Выполнить("ЭтаФорма." + ДействиеПриВыводеСтроки + "(ТабличноеПоле, ОформлениеСтроки, ДанныеСтроки)");
					ДопСвойства.ЗапретОтображения = Ложь;
				КонецЕсли;
				Если ОформлениеСтроки.Ячейки[Колонка.Имя].ТолькоПросмотр Тогда
					ОформлениеСтроки.Ячейки[Колонка.Имя].ТолькоПросмотр = Ложь;
					Продолжить;
				КонецЕсли; 
			КонецЕсли; 
		КонецЕсли; 
		Если ТипЗнч(ЗначениеОбработки) = Тип("Структура") Тогда
			ЗаполнитьЗначенияСвойств(ЗначениеОбработки.Параметры, ДанныеСтроки); 
			НовоеЗначение = ирОбщий.ВычислитьВыражение(ЗначениеОбработки.Формула, ЗначениеОбработки.Параметры, НаСервере);
		Иначе
			НовоеЗначение = ЗначениеОбработки;
		КонецЕсли; 
		Если ИнтерактивнаяУстановка Тогда
			Если ТипЗнч(ТабличноеПоле) = Тип("ТабличноеПоле") Тогда
				ДействиеПриАктивизацииСтроки = ТабличноеПоле.ПолучитьДействие("ПриАктивизацииСтроки");
				ДействиеПриВыводеСтроки = ТабличноеПоле.ПолучитьДействие("ПриВыводеСтроки");
				ТабличноеПоле.УстановитьДействие("ПриАктивизацииСтроки", Неопределено);
				ТабличноеПоле.УстановитьДействие("ПриВыводеСтроки", Неопределено);
				ТабличноеПоле.ТекущаяСтрока = ТекущаяСтрока;
			Иначе
				ТабличноеПоле.ТекущаяСтрока = КлючСтроки;
			КонецЕсли;
			РезультатОтправки = ИнтерактивноЗаписатьВКолонкуТабличногоПоляЛкс(ТабличноеПоле, Колонка, НовоеЗначение,, Ложь,,, Истина, ПутьКДаннымКолонки, МетаданныеВыбора);
			Если Не РезультатОтправки Тогда
				КоличествоПропущенных = КоличествоПропущенных + 1;
			КонецЕсли;
			Если ТипЗнч(ТабличноеПоле) = Тип("ТабличноеПоле") Тогда
				ТабличноеПоле.УстановитьДействие("ПриАктивизацииСтроки", ДействиеПриАктивизацииСтроки);
				ТабличноеПоле.УстановитьДействие("ПриВыводеСтроки", ДействиеПриВыводеСтроки);
				//ТабличноеПоле.ОбновитьСтроки(ТекущаяСтрока);
			КонецЕсли;
		Иначе
			Попытка
				ТекущаяСтрока[ПутьКДаннымКолонки] = НовоеЗначение;
			Исключение
				// настройка компоновки
			КонецПопытки; 
		КонецЕсли; 
		ПоследняяОбработаннаяСтрока = ТекущаяСтрока;
	КонецЦикла; 
	ирОбщий.ОсвободитьИндикаторПроцессаЛкс(Индикатор);
	Если Истина
		И ТипЗнч(ТабличноеПоле) = Тип("ТабличноеПоле") 
		И Не ИнтерактивнаяУстановка 
		И ПоследняяОбработаннаяСтрока <> Неопределено
		И ТабличноеПоле.ПроверитьСтроку(ПоследняяОбработаннаяСтрока)
	Тогда
		// Переустановим значение ради срабатывания события ПриИзменении без его фактического изменения, чтобы сработали механизмы подсчета количества помеченных
		ТабличноеПоле.ТекущаяСтрока = ПоследняяОбработаннаяСтрока;
		ИнтерактивноЗаписатьВКолонкуТабличногоПоляЛкс(ТабличноеПоле, Колонка, ПоследняяОбработаннаяСтрока[ирОбщий.ПутьКДаннымКолонкиТабличногоПоляЛкс(ТабличноеПоле, Колонка)],,,,, Истина, ПутьКДаннымКолонки, МетаданныеВыбора); 
	КонецЕсли; 
	Если КоличествоПропущенных > 0 Тогда
		ирОбщий.СообщитьЛкс(ирОбщий.СтрШаблонЛкс("Пропущено %1 ячеек из-за несогласованности строки с новым значением", КоличествоПропущенных));
	КонецЕсли;
	Для Каждого СтарыйЭлементОтбора Из СтарыеВключенныеЭлементыОтбора Цикл
		ТабличноеПоле.ОтборСтрок[СтарыйЭлементОтбора].Использование = Истина;
	КонецЦикла;
	ТабличноеПоле.ВыделенныеСтроки.Очистить();
	Если СтараяТекущаяСтрока <> Неопределено Тогда
		ТабличноеПоле.ТекущаяСтрока = СтараяТекущаяСтрока;
	КонецЕсли; 
	Если СтараяТекущаяКолонка <> Неопределено Тогда
		ирОбщий.УстановитьТекущуюКолонкуТаблицыФормыЛкс(ТабличноеПоле, СтараяТекущаяКолонка);
	КонецЕсли; 
	Для Каждого СтрокаЦикл Из СтарыеВыделенныеСтроки Цикл
		ТабличноеПоле.ВыделенныеСтроки.Добавить(СтрокаЦикл);
	КонецЦикла;
	Если ТипЗнч(ТабличноеПоле) = Тип("ТабличноеПоле") Тогда
		ТабличноеПоле.ОбновитьСтроки(); // Антибаг платформы. Без этого иногда некоторые строки были недорисованы
	КонецЕсли; 
	
КонецПроцедуры

// Предоставляет пользователю редактор таблицы значений. Затем загружает добавленные туда пользователем данные в табличное поле с эмуляцией интерактивных событий
//
// Параметры:
//  Форма - Форма
//  ТабличноеПоле - ТабличноеПоле;
//  РазрешитьИнтерактивнуюУстановку - Булево - вызывать обработчики событий формы
// 
// Возвращаемое значение:
//  Булево - успех
Функция ЗагрузитьСтрокиВТабличноеПолеЛкс(Знач Форма, Знач ТабличноеПоле, Знач РазрешитьИнтерактивнуюУстановку = Истина, Знач МетаданныеКолонок = Неопределено, ЛиТЧ = Истина,
	Знач РеквизитыВладельца = Неопределено) Экспорт

	#Если Сервер И Не Сервер Тогда
		ТабличноеПоле = Новый ТабличноеПоле;
		МетаданныеКолонок = Новый Структура;
	#КонецЕсли
	Если ТабличноеПоле.ТолькоПросмотр Или Не ТабличноеПоле.ИзменятьСоставСтрок Тогда
		Возврат Ложь;
	КонецЕсли;
	СтараяТекущаяСтрока = ТабличноеПоле.ТекущаяСтрока;
	ТабличноеПоле.ДобавитьСтроку();
	Если СтараяТекущаяСтрока = ТабличноеПоле.ТекущаяСтрока Тогда 
		ирОбщий.СообщитьЛкс("Добавление строк заблокировано обработчиком перед добавлением строки");
		Возврат Ложь;
	КонецЕсли;
	ИнтерактивныеКолонки = ИнтерактивныеКолонкиТабличногоПоляЛкс(ТабличноеПоле);
	#Если Сервер И Не Сервер Тогда
		ИнтерактивныеКолонки = Новый СписокЗначений;
	#КонецЕсли
	КоллекцияСтрокПоля = ирОбщий.ДанныеЭлементаФормыЛкс(ТабличноеПоле);
	Если ТипЗнч(КоллекцияСтрокПоля) = Тип("ДеревоЗначений") Тогда
		КоллекцияСтрокПоля = ирОбщий.РодительСтрокиДереваЛкс(ТабличноеПоле.ТекущаяСтрока, КоллекцияСтрокПоля).Строки;
	ИначеЕсли ТипЗнч(КоллекцияСтрокПоля) = Тип("ДанныеФормыДерево") Тогда
		КоллекцияСтрокПоля = ирОбщий.РодительСтрокиДереваЛкс(ТабличноеПоле.ТекущаяСтрока, КоллекцияСтрокПоля).ПолучитьЭлемент();
	КонецЕсли;
	Если ИнтерактивныеКолонки.Количество() = 0 Тогда
		КоллекцияСтрокПоля.Удалить(ДанныеСтрокиТабличногоПоляЛкс(ТабличноеПоле));
		ирОбщий.СообщитьЛкс("В табличном поле отсутствуют интерактивно доступные колонки");
		Возврат Ложь;
	КонецЕсли;
	ИменаКолонокДанных = ирОбщий.СтрСоединитьЛкс(ирОбщий.ВыгрузитьСвойствоКоллекцииЛкс(ИнтерактивныеКолонки, "Представление"));
	ЗагружаемаяТаблица = ТаблицаИлиДеревоЗначенийИзТаблицыФормыСКоллекциейЛкс(ТабличноеПоле, Новый Массив,,,, ИменаКолонокДанных);
	#Если Сервер И Не Сервер Тогда
		ЗагружаемаяТаблица = Новый ТаблицаЗначений;
	#КонецЕсли
	СтрокаКоллекции = ДанныеСтрокиТабличногоПоляЛкс(ТабличноеПоле);
	ТабличноеПоле.ЗакончитьРедактированиеСтроки(Истина);
	Попытка
		// Табличное поле могло выйти из режима редактирования строки из-за смены текущей колонки. Поэтому для подстраховки попробуем удалить строку из коллекции
		КоллекцияСтрокПоля.Удалить(СтрокаКоллекции); 
	Исключение
	КонецПопытки;
	ТабличноеПоле.ТекущаяСтрока = СтараяТекущаяСтрока;
	Заголовок = "Заполните строки для загрузки";
	Если Не ОткрытьЗначениеЛкс(ЗагружаемаяТаблица,,, Заголовок) Тогда 
		Возврат Ложь;
	КонецЕсли;
	
	БылиДобавленыСтроки = ЗагрузитьТаблицуВТабличноеПолеЛкс(Форма, ТабличноеПоле, ЗагружаемаяТаблица, КоллекцияСтрокПоля, РазрешитьИнтерактивнуюУстановку, МетаданныеКолонок,
		ЛиТЧ, РеквизитыВладельца, ИнтерактивныеКолонки);
	Возврат БылиДобавленыСтроки;
	
КонецФункции

// Загружает переданную таблицу значений в табличное поле. Перед загрузкой в непустой приемник задается вопрос об очистке.
// Параметры:
//  Форма - Форма
//  ТабличноеПоле - ТабличноеПоле;
//  ЗагружаемаяТаблица - ТаблицаЗначений;
//  РазрешитьИнтерактивнуюУстановку - Булево - вызывать обработчики событий формы
//
// Возвращаемое значение:
//  Булево - успех
Функция ЗагрузитьТаблицуВТабличноеПолеЛкс(Знач Форма, Знач ТабличноеПоле, Знач ЗагружаемаяТаблица, Знач КоллекцияСтрокПоля = Неопределено, Знач РазрешитьИнтерактивнуюУстановку = Истина,
	Знач МетаданныеКолонок = Неопределено, ЛиТЧ = Истина, Знач РеквизитыВладельца = Неопределено, Знач ИнтерактивныеКолонки = Неопределено, Знач ПредлагатьОчистку = Истина) Экспорт 
	
	Если ИнтерактивныеКолонки = Неопределено Тогда
		ИнтерактивныеКолонки = ИнтерактивныеКолонкиТабличногоПоляЛкс(ТабличноеПоле);
	КонецЕсли;    
	Если КоллекцияСтрокПоля = Неопределено Тогда
		КоллекцияСтрокПоля = ирОбщий.ДанныеЭлементаФормыЛкс(ТабличноеПоле);
	КонецЕсли;
	ИменаКолонокДанных = ирОбщий.СтрСоединитьЛкс(ирОбщий.ВыгрузитьСвойствоКоллекцииЛкс(ИнтерактивныеКолонки, "Представление"));
	НесопоставленныеКолонки = Новый СписокЗначений;
	ИменаКолонокДанных = Новый Структура(ИменаКолонокДанных);
	Для Каждого КолонкаНовая Из ЗагружаемаяТаблица.Колонки Цикл
		Если Истина
			И Не ИменаКолонокДанных.Свойство(КолонкаНовая.Имя) 
			И КолонкаНовая.Имя <> "_КлючИсточника"
		Тогда
			НесопоставленныеКолонки.Добавить(КолонкаНовая.Имя);
		КонецЕсли;
	КонецЦикла;
	Если НесопоставленныеКолонки.Количество() > 0 Тогда   
		НесопоставленныеКолонки.СортироватьПоЗначению();
		ирОбщий.СообщитьЛкс("В таблице-источнике обнаружены лишние колонки: " + ирОбщий.СтрСоединитьЛкс(НесопоставленныеКолонки), СтатусСообщения.Внимание);
	КонецЕсли;
	Если ПредлагатьОчистку И КоллекцияСтрокПоля.Количество() > 0 Тогда
		Ответ = Вопрос("Очистить строки таблицы перед загрузкой новых строк?", РежимДиалогаВопрос.ДаНет);
		Если Ответ = КодВозвратаДиалога.Да Тогда
			КоллекцияСтрокПоля.Очистить();
		КонецЕсли;
	КонецЕсли;
	ТипИсточника = ирОбщий.ОбщийТипДанныхТабличногоПоляЛкс(ТабличноеПоле);
	СтарыеВключенныеЭлементыОтбора = Новый Массив;
	ЕстьОтборСтрок = Ложь
		Или ТипИсточника = "ТабличнаяЧасть" 
		Или ТипИсточника = "НаборЗаписей";
	Если ЕстьОтборСтрок И ирОбщий.ЛиОтборУстановленЛкс(ТабличноеПоле.ОтборСтрок) Тогда
		Для Каждого ЭлементОтбора Из ТабличноеПоле.ОтборСтрок Цикл
			Если ЭлементОтбора.Использование Тогда
				ЭлементОтбора.Использование = Ложь;
				СтарыеВключенныеЭлементыОтбора.Добавить(ЭлементОтбора.Имя);
			КонецЕсли; 
		КонецЦикла;
	КонецЕсли;
	Если ТипЗнч(ТабличноеПоле) = Тип("ТабличноеПоле") Тогда
		ЕстьОбработчикНачалаРедактирования = РазрешитьИнтерактивнуюУстановку И ЗначениеЗаполнено("" + ТабличноеПоле.ПолучитьДействие("ПриНачалеРедактирования"));
		ЕстьОбработчикИзменения = Ложь;
		Если РазрешитьИнтерактивнуюУстановку Тогда
			Для Каждого ИнтерактивнаяКолонка Из ИнтерактивныеКолонки Цикл
				Если ЗначениеЗаполнено("" + ИнтерактивнаяКолонка.Значение.ЭлементУправления.ПолучитьДействие("ПриИзменении")) Тогда 
					ЕстьОбработчикИзменения = Истина;
					Прервать;
				КонецЕсли; 
			КонецЦикла;
		КонецЕсли;
	Иначе
		ЕстьОбработчикНачалаРедактирования = РазрешитьИнтерактивнуюУстановку;
		ЕстьОбработчикИзменения = РазрешитьИнтерактивнуюУстановку;
	КонецЕсли;
	КолонкиСПроверками = Новый Структура; 
	Для Каждого ИнтерактивнаяКолонка Из ИнтерактивныеКолонки Цикл
		ИмяКолонки = ИнтерактивнаяКолонка.Представление; 
		КолонкаСПроверками = Новый Структура("Имя, СвязиПараметровВыбора, ПараметрыВыбора");
		КолонкаСПроверками.Имя = ИмяКолонки; 
		Если ТипЗнч(ТабличноеПоле) = Тип("ТабличноеПоле") Тогда
			Если МетаданныеКолонок <> Неопределено И МетаданныеКолонок.Свойство(ИмяКолонки) Тогда
				МетаданныеКолонки = МетаданныеКолонок[ИмяКолонки];
			Иначе
				Продолжить;
			КонецЕсли;
		Иначе
			МетаданныеКолонки = ИнтерактивнаяКолонка.Значение;
		КонецЕсли;
		ЗаполнитьЗначенияСвойств(КолонкаСПроверками, МетаданныеКолонки, "СвязиПараметровВыбора, ПараметрыВыбора");
		КолонкиСПроверками.Вставить(ИмяКолонки, КолонкаСПроверками);
	КонецЦикла;
	КолонкиСНарушениями = Новый Структура;  
	ПоляСУсловиями = Новый ТаблицаЗначений;
	ПропускатьНесогласованныеЗначения = Неопределено;
	Если Не ирОбщий.ПроверитьТаблицуЗначенийНаСогласованностьЛкс(ЗагружаемаяТаблица, КолонкиСПроверками, КолонкиСНарушениями, ТабличноеПоле, ПропускатьНесогласованныеЗначения,
		ПоляСУсловиями, ЛиТЧ, РеквизитыВладельца) Тогда
		Возврат Ложь;
	КонецЕсли;
	Форма.Активизировать();
	Индикатор = ирОбщий.ПолучитьИндикаторПроцессаЛкс(ЗагружаемаяТаблица.Количество(), "Загрузка строк");
	ПоследняяОбработаннаяСтрока = Неопределено;
	КоличествоПропущенных = 0;
	Для Каждого СтрокаТаблицы Из ЗагружаемаяТаблица Цикл
		ОбработкаПрерыванияПользователя();
		Если ЕстьОбработчикНачалаРедактирования Или ЕстьОбработчикИзменения Тогда
			ирОбщий.ОбработатьИндикаторЛкс(Индикатор);
			ТабличноеПоле.ДобавитьСтроку();
			НоваяСтрока = ТабличноеПоле.ТекущиеДанные;
		Иначе
			НоваяСтрока = КоллекцияСтрокПоля.Добавить();
		КонецЕсли;
		Для Каждого ИнтерактивнаяКолонка Из ИнтерактивныеКолонки Цикл
			ИмяКолонки = ИнтерактивнаяКолонка.Представление;
			Если ЗагружаемаяТаблица.Колонки.Найти(ИмяКолонки) = Неопределено Тогда
				Продолжить;
			КонецЕсли;
			//Если Истина
			//	И ПропускатьНесогласованныеЗначения
			//	И КолонкиСНарушениями.Свойство(ИмяКолонки) 
			//Тогда
			//	ПолеСУсловиями = ПоляСУсловиями.Найти(ИмяКолонки, "ИмяКолонки");
			//	Если СтрокаТаблицы["Несогласовано_" + ИмяКолонки] Тогда
			//		Продолжить;
			//	КонецЕсли;
			//КонецЕсли; 
			НовоеЗначение = СтрокаТаблицы[ИмяКолонки]; 
			Если ЕстьОбработчикИзменения Тогда
				РезультатОтправки = ИнтерактивноЗаписатьВКолонкуТабличногоПоляЛкс(ТабличноеПоле, ИнтерактивнаяКолонка.Значение, НовоеЗначение, , Ложь,,,, ИмяКолонки);
				Если Не РезультатОтправки Тогда
					КоличествоПропущенных = КоличествоПропущенных + 1;
				КонецЕсли;
			Иначе
				НоваяСтрока[ИмяКолонки] = НовоеЗначение;
			КонецЕсли;
		КонецЦикла;
		Если ЕстьОбработчикИзменения Тогда
			ТабличноеПолеУстановитьТекущуюКолонкуЛкс(ТабличноеПоле, ИнтерактивныеКолонки[0].Значение);
		КонецЕсли;
	КонецЦикла; 
	ирОбщий.ОсвободитьИндикаторПроцессаЛкс(Индикатор);
	Если КоличествоПропущенных > 0 Тогда
		ирОбщий.СообщитьЛкс(ирОбщий.СтрШаблонЛкс("Пропущено %1 ячеек из-за несогласованности строки с новым значением", КоличествоПропущенных));
	КонецЕсли;
	ТабличноеПоле.ЗакончитьРедактированиеСтроки(Ложь);
	Для Каждого СтарыйЭлементОтбора Из СтарыеВключенныеЭлементыОтбора Цикл
		ТабличноеПоле.ОтборСтрок[СтарыйЭлементОтбора].Использование = Истина;
	КонецЦикла;
	Если ТипЗнч(ТабличноеПоле) = Тип("ТабличноеПоле") Тогда
		ТабличноеПоле.ОбновитьСтроки(); // Антибаг платформы. Без этого иногда некоторые строки были недорисованы
	КонецЕсли; 
	БылиДобавленыСтроки = ЗагружаемаяТаблица.Количество() > 0;
	Возврат БылиДобавленыСтроки;

КонецФункции

Функция ИнтерактивныеКолонкиТабличногоПоляЛкс(Знач ТабличноеПоле) Экспорт 
	
	#Если Сервер И Не Сервер Тогда
		ТабличноеПоле = Новый ТабличноеПоле;
	#КонецЕсли
	СтараяТекущаяКолонка = ТабличноеПолеТекущаяКолонкаЛкс(ТабличноеПоле);
	ИнтерактивныеКолонки = Новый СписокЗначений;
	КолонкиТП = КолонкиТаблицыФормыИлиТабличногоПоляЛкс(ТабличноеПоле);
	Для Каждого КолонкаТП Из КолонкиТП Цикл
		ПутьКДаннымКолонки = ирОбщий.ПутьКДаннымКолонкиТабличногоПоляЛкс(ТабличноеПоле, КолонкаТП);
		Если Истина
			И ЗначениеЗаполнено(ПутьКДаннымКолонки) 
			И ЛиВКолонкеДоступнаЭмуляцияИнтерактивногоИзмененияЛкс(КолонкаТП) 
			И (Ложь 
				Или ТипЗнч(ТабличноеПоле) = Тип("ТабличноеПоле")
				Или ТабличноеПолеУстановитьТекущуюКолонкуЛкс(ТабличноеПоле, КолонкаТП) // Только так можно проверить видимость по функциональным опциям у таблицы формы
				)
		Тогда
			ИнтерактивныеКолонки.Добавить(КолонкаТП, ПутьКДаннымКолонки);
		КонецЕсли; 
	КонецЦикла;
	Если СтараяТекущаяКолонка <> Неопределено Тогда
		ТабличноеПолеУстановитьТекущуюКолонкуЛкс(ТабличноеПоле, СтараяТекущаяКолонка);
	КонецЕсли;
	Возврат ИнтерактивныеКолонки;

КонецФункции

// Получает копию данных таблицы формы
//
// Параметры:
//  ИсточникДействий			 - 	 - 
//  МассивСтрок					 - Массив - 
//  СУчетомОтбора				 - Булево - 
//  ПреобразоватьДеревоВТаблицу	 - Булево - 
//  КолонкаПолученияТекстаЯчеек	 - Структура - "Источник,Применик", источник - откуда брать текст, приемник - куда помещать
//  ИменаКолонокРезультата		 - Строка - 
// 
// Возвращаемое значение:
//  Неопределено, ТаблицаЗначений, ДеревоЗначений
//
Функция ТаблицаИлиДеревоЗначенийИзТаблицыФормыСКоллекциейЛкс(Знач ТабличноеПоле, Знач МассивСтрок = Неопределено, Знач СУчетомОтбора = Ложь, Знач ПреобразоватьДеревоВТаблицу = Истина,
	Знач КолонкаПолученияТекстаЯчеек = Неопределено, Знач ИменаКолонокРезультата = "", ЭтаФорма = Неопределено, выхТекущаяСтрока = Неопределено, Знач БезОтбораРавноТекущейКолонки = Ложь) Экспорт 
	
	ОчиститьТаблицу = Ложь;
	Если Истина
		И МассивСтрок <> Неопределено
		И МассивСтрок.Количество() = 0
		И ТабличноеПоле.ТекущаяСтрока <> Неопределено 
	Тогда
		МассивСтрок.Добавить(ТабличноеПоле.ТекущаяСтрока);
		ОчиститьТаблицу = Истина;
	КонецЕсли;
	ПолноеИмяТаблицыБД = "";
	ДанныеТабличногоПоля = Неопределено;
	ТипИсточника = ирОбщий.ОбщийТипДанныхТабличногоПоляЛкс(ТабличноеПоле,,, ПолноеИмяТаблицыБД, ДанныеТабличногоПоля);
	Если ТипИсточника = "Список" И ЗначениеЗаполнено(ПолноеИмяТаблицыБД) Тогда
		Возврат Неопределено;
	КонецЕсли; 
	Если ТипЗнч(МассивСтрок) = Тип("ВыделенныеСтрокиТабличногоПоля") Тогда
		МассивСтрок = ВыделенныеСтрокиТабличногоПоляЛкс(ТабличноеПоле);
	КонецЕсли; 
	Если Ложь
		#Если Клиент Тогда
		Или ТипЗнч(ТабличноеПоле) = Тип("ТабличноеПоле") 
		#КонецЕсли 
	Тогда
		#Если Сервер И Не Сервер Тогда
			ТабличноеПоле = Новый ТабличноеПоле;
		#КонецЕсли
		ВыгрузкаРезультата = ирОбщий.ДанныеЭлементаФормыЛкс(ТабличноеПоле,, ЭтаФорма, СУчетомОтбора);
		#Если Сервер И Не Сервер Тогда
			ВыгрузкаРезультата = Новый ТаблицаЗначений;
		#КонецЕсли
		Если КолонкаПолученияТекстаЯчеек <> Неопределено Тогда
			// Медленнее в разы
			Результат = Новый ТаблицаЗначений;
			Если ирОбщий.ЛиТабличнаяЧастьЛкс(ВыгрузкаРезультата) Тогда
				ирОбщий.СкопироватьКолонкиКоллекцииЛкс(ВыгрузкаРезультата.ВыгрузитьКолонки(), Результат, Истина, ИменаКолонокРезультата);
			Иначе
				ирОбщий.СкопироватьКолонкиКоллекцииЛкс(ВыгрузкаРезультата                   , Результат, Истина, ИменаКолонокРезультата);
			КонецЕсли; 
			Результат.Колонки.Добавить(КолонкаПолученияТекстаЯчеек.Приемник, Новый ОписаниеТипов("Строка"));
			Если МассивСтрок = Неопределено Тогда
				Если ТипЗнч(ВыгрузкаРезультата) = Тип("ДеревоЗначений") Тогда
					МассивСтрок = ирОбщий.ВсеСтрокиДереваЗначенийЛкс(ВыгрузкаРезультата);
				Иначе
					МассивСтрок = ВыгрузкаРезультата;
				КонецЕсли; 
			КонецЕсли; 
			Индикатор = ирОбщий.ПолучитьИндикаторПроцессаЛкс(МассивСтрок.Количество(), "Получение оформлений ячеек");
			Для Каждого ДанныеСтроки Из МассивСтрок Цикл
				ирОбщий.ОбработатьИндикаторЛкс(Индикатор);
				СтрокаРезультата = Результат.Добавить();
				ЗаполнитьЗначенияСвойств(СтрокаРезультата, ДанныеСтроки); 
				ОформлениеСтроки = ТабличноеПоле.ОформлениеСтроки(ДанныеСтроки);
				Если ОформлениеСтроки <> Неопределено Тогда
					ТекстЯчейки = ОформлениеСтроки.Ячейки.Найти(КолонкаПолученияТекстаЯчеек.Источник).Текст;
				Иначе
					// Строка отброшена отбором. Поэтому для платформа не вычисляет для нее оформление
					ТекстЯчейки = ДанныеСтроки[КолонкаПолученияТекстаЯчеек.Источник];
				КонецЕсли; 
				СтрокаРезультата[КолонкаПолученияТекстаЯчеек.Приемник] = ТекстЯчейки;
			КонецЦикла;
			ирОбщий.ОсвободитьИндикаторПроцессаЛкс();
			ВыгрузкаРезультата = Результат;
		Иначе
			Если ТипЗнч(ВыгрузкаРезультата) = Тип("ТаблицаЗначений") Тогда
				Если ТабличноеПоле.ТекущаяСтрока <> Неопределено Тогда
					Если МассивСтрок <> Неопределено Тогда
						ИндексТекущейСтроки = МассивСтрок.Найти(ТабличноеПоле.ТекущаяСтрока);
					Иначе
						ИндексТекущейСтроки = ВыгрузкаРезультата.Индекс(ТабличноеПоле.ТекущаяСтрока);
						Если ИндексТекущейСтроки = -1 Тогда
							ИндексТекущейСтроки = Неопределено;
						КонецЕсли;
					КонецЕсли;
				КонецЕсли;
				ВыгрузкаРезультата = ВыгрузкаРезультата.Скопировать(МассивСтрок, ИменаКолонокРезультата);
				Если ИндексТекущейСтроки <> Неопределено Тогда
					выхТекущаяСтрока = ВыгрузкаРезультата[ИндексТекущейСтроки];
				КонецЕсли;
			ИначеЕсли ТипЗнч(ВыгрузкаРезультата) = Тип("ДеревоЗначений") Тогда
				Если ПреобразоватьДеревоВТаблицу Тогда
					ВыгрузкаРезультата = ирОбщий.ДеревоЗначенийВТаблицуЛкс(ВыгрузкаРезультата, МассивСтрок, ИменаКолонокРезультата);
				КонецЕсли; 
			Иначе
				Если Истина
					И (Ложь
						Или ТипИсточника = "НаборЗаписей"
						Или ТипИсточника = "ТабличнаяЧасть")
					И (Ложь
						Или МассивСтрок <> Неопределено 
						Или Не СУчетомОтбора)
				Тогда
					ВыгрузкаРезультата = ВыгрузкаРезультата.Выгрузить(МассивСтрок, ИменаКолонокРезультата);
				Иначе
					Построитель = ПостроительТабличногоПоляСОтборомКлиентаЛкс(ТабличноеПоле);
					#Если Сервер И Не Сервер Тогда
						Построитель = Новый ПостроительЗапроса;
					#КонецЕсли
					Если БезОтбораРавноТекущейКолонки Тогда
						ирОбщий.ОтключитьЭлементОтбораРавноЛкс(Построитель.Отбор, ирОбщий.ПутьКДаннымКолонкиТабличногоПоляЛкс(ТабличноеПоле));
					КонецЕсли;
					Если Построитель.ВыбранныеПоля.Количество() > 0 Тогда
						ВыгрузкаРезультата = Построитель.Результат.Выгрузить();
						Если Истина
							И ТабличноеПоле.ТекущаяСтрока <> Неопределено 
							И Построитель.ДоступныеПоля.Найти("НомерСтроки") <> Неопределено
						Тогда
							выхТекущаяСтрока = ВыгрузкаРезультата.Найти(ТабличноеПоле.ТекущаяСтрока.НомерСтроки, "НомерСтроки");
						КонецЕсли;
					ИначеЕсли ирОбщий.ЛиКоллекцияКомпоновкиЛкс(ВыгрузкаРезультата) Тогда 
						Если ТабличноеПоле.ТекущаяСтрока <> Неопределено Тогда
							выхТекущаяСтрока = ВыгрузкаРезультата.Элементы.Индекс(ТабличноеПоле.ТекущаяСтрока);
						КонецЕсли;
						ВыгрузкаРезультата = ирОбщий.ТаблицаЗначенийИзКоллекцииЛкс(ВыгрузкаРезультата.Элементы);
						Если ТабличноеПоле.ТекущаяСтрока <> Неопределено Тогда 
							Если выхТекущаяСтрока = -1 Тогда 
								// Например некорневая строка доступного поля компоновки
								выхТекущаяСтрока = Неопределено;
							Иначе
								выхТекущаяСтрока = ВыгрузкаРезультата[выхТекущаяСтрока];
							КонецЕсли;
						КонецЕсли;
					Иначе
						Если ТабличноеПоле.ТекущаяСтрока <> Неопределено Тогда
							выхТекущаяСтрока = ВыгрузкаРезультата.Индекс(ТабличноеПоле.ТекущаяСтрока);
						КонецЕсли;
						ВыгрузкаРезультата = ирОбщий.ТаблицаЗначенийИзКоллекцииЛкс(ВыгрузкаРезультата);
						Если ТабличноеПоле.ТекущаяСтрока <> Неопределено Тогда 
							Если выхТекущаяСтрока = -1 Тогда 
								// Например некорневая строка доступного поля компоновки
								выхТекущаяСтрока = Неопределено;
							Иначе
								выхТекущаяСтрока = ВыгрузкаРезультата[выхТекущаяСтрока];
							КонецЕсли;
						КонецЕсли;
						//ВызватьИсключение ирОбщий.СтрШаблонЛкс("Неподдерживаемый тип данных табличного поля (%1)", ТипЗнч(ДанныеТабличногоПоля));
					КонецЕсли; 
				КонецЕсли; 
			КонецЕсли; 
		КонецЕсли; 
		Счетчик = 0;
		Для Каждого КолонкаТП Из ТабличноеПоле.Колонки Цикл
			ПутьКДанным = ирОбщий.ПутьКДаннымКолонкиТабличногоПоляЛкс(ТабличноеПоле, КолонкаТП);
			Если ЗначениеЗаполнено(ПутьКДанным) Тогда
				КолонкаТЗ = ВыгрузкаРезультата.Колонки.Найти(ПутьКДанным);
				Если КолонкаТЗ <> Неопределено Тогда
					ВыгрузкаРезультата.Колонки.Сдвинуть(КолонкаТЗ, Счетчик - ВыгрузкаРезультата.Колонки.Индекс(КолонкаТЗ));
					Счетчик = Счетчик + 1;
				КонецЕсли; 
			КонецЕсли; 
		КонецЦикла;
	Иначе // ТипЗнч(ИсточникДействий) = Тип("ТаблицаФормы") 
		ТаблицаФормы = ТабличноеПоле;
		ДанныеЭлемента = ирОбщий.ДанныеЭлементаФормыЛкс(ТаблицаФормы);
		ОтборСтрок = Неопределено;
		Если ТипЗнч(ДанныеЭлемента) = Тип("ДинамическийСписок") Тогда
			ДанныеЭлемента = Неопределено; 
		Иначе
			Если ТипЗнч(ДанныеЭлемента) = Тип("ДанныеФормыКоллекция") Тогда
				ОтборСтрок = ТабличноеПоле.ОтборСтрок;
				#Если Сервер И Не Сервер Тогда
					ОтборСтрок = Новый ФиксированнаяСтруктура;
				#КонецЕсли
			КонецЕсли;
		КонецЕсли;
		Если МассивСтрок = Неопределено И ТипЗнч(ДанныеЭлемента) = Тип("ДанныеФормыДерево") Тогда
			Результат = ДанныеФормыВЗначение(ДанныеЭлемента, Тип("ДеревоЗначений")); // Для табличных частей не работает
		Иначе
			Если ДанныеЭлемента = Неопределено Тогда 
				Если МассивСтрок = Неопределено Тогда
					МассивСтрок = ВыделенныеСтрокиТабличногоПоляЛкс(ТаблицаФормы);
					ирОбщий.СообщитьЛкс("Эта таблица позволяет выводить только выделенные строки",,, Истина, Ложь);
				КонецЕсли; 
			Иначе
				//ТипЗначенияТаблицы = ирОбщий.ТипЗначенияЭлементаФормыЛкс(ТаблицаФормы, Ложь);
				//Если ТипЗначенияТаблицы <> Неопределено Тогда
				//	ТипЗначенияТаблицы = ТипЗначенияТаблицы.Типы()[0];
				//	ИмяОбщегоТипа = ирОбщий.ОбщийТипДанныхТабличногоПоляЛкс(ТаблицаФормы, Истина);
				//	ОбъектМДТаблицы = Метаданные.НайтиПоТипу(ТипЗначенияТаблицы);
				//	Если ОбъектМДТаблицы <> Неопределено Тогда
				//		ВыгрузкаРезультата = Новый ТаблицаЗначений;
				//		Если ИмяОбщегоТипа = "ТабличнаяЧасть" Тогда
				//			// Через поля таблицы БД нельзя, т.к. у ТЧ может не быть проекции в БД
				//			Для Каждого МетаРеквизит Из ОбъектМДТаблицы.Реквизиты Цикл
				//				Результат.Колонки.Добавить(МетаРеквизит.Имя, МетаРеквизит.Тип, МетаРеквизит.Представление());
				//			КонецЦикла; 
				//		Иначе
				//			ПоляТаблицыБД = ирОбщий.ПоляТаблицыМДЛкс(ОбъектМДТаблицы);
				//			Для Каждого ПолеБД Из ПоляТаблицыБД Цикл
				//				Результат.Колонки.Добавить(ПолеБД.Имя, ПолеБД.ТипЗначения, ПолеБД.Заголовок);
				//			КонецЦикла; 
				//		КонецЕсли; 
				//	КонецЕсли; 
				//КонецЕсли; 
				Если МассивСтрок = Неопределено Тогда
					Попытка
						МассивСтрок = ДанныеЭлемента.Элементы; // Настройка компоновки
					Исключение
						МассивСтрок = ДанныеЭлемента;
					КонецПопытки;
				КонецЕсли; 
			КонецЕсли; 
			#Если Сервер И Не Сервер Тогда
				МассивСтрок = Новый Массив;
			#КонецЕсли
			Результат = Новый ТаблицаЗначений;
			Если МассивСтрок.Количество() > 0 Тогда
				КолонкиДобавлены = Ложь;
				Колонка_КлючИсточникаДобавлена = Ложь;
				КолонкаСРеквизитом = "";
				СтараяТекущаяСтрока = ТаблицаФормы.ТекущаяСтрока;
				Для Каждого СтрокаТаблицы Из МассивСтрок Цикл
					Попытка 
						ДанныеСтроки = ТаблицаФормы.ДанныеСтроки(СтрокаТаблицы);
						ИДСтроки = СтрокаТаблицы;
					Исключение
						ДанныеСтроки = Неопределено;
					КонецПопытки; 
					Если ДанныеСтроки = Неопределено Тогда
						ДанныеСтроки = СтрокаТаблицы;
						Попытка
							ИДСтроки = СтрокаТаблицы.ПолучитьИдентификатор();
						Исключение
						КонецПопытки;
					КонецЕсли; 
					Если Не КолонкиДобавлены Тогда
						Если Истина
							И Не ОчиститьТаблицу
							И ТипЗнч(ИДСтроки) = Тип("Число") 
							И Результат.Колонки.Найти("_КлючИсточника") = Неопределено
						Тогда
							Результат.Колонки.Добавить("_КлючИсточника");
							Колонка_КлючИсточникаДобавлена = Истина;
						КонецЕсли; 
						ДобавитьКолонкиГруппыФормыВТаблицуЗначенийЛкс(ТаблицаФормы.ПодчиненныеЭлементы, Результат, ДанныеСтроки, ИменаКолонокРезультата);
						Если Не ЗначениеЗаполнено(ИменаКолонокРезультата) Тогда
							ТекущееПоле = ТаблицаФормы.ТекущийЭлемент;
							Если ТекущееПоле <> Неопределено Тогда
								ПутьКДаннымПоля = ирОбщий.НайтиПутьКДаннымПоляТаблицыФормыЛкс(ДанныеСтроки, ТекущееПоле.Имя);
								Если ЗначениеЗаполнено(ПутьКДаннымПоля) Тогда
									ИмяРеквизитаКоллекции = ПутьКДаннымПоля;
									Если Найти(ПутьКДаннымПоля, ".") > 0 Тогда
										КолонкаСРеквизитом = ПутьКДаннымПоля;
										ИмяРеквизитаКоллекции = СтрЗаменить(КолонкаСРеквизитом, ".", "_");
									КонецЕсли; 
									Если Результат.Колонки.Найти(ИмяРеквизитаКоллекции) = Неопределено Тогда
										Результат.Колонки.Добавить(ИмяРеквизитаКоллекции);
									КонецЕсли;
								КонецЕсли;
							КонецЕсли;
						КонецЕсли;
						КолонкиДобавлены = Истина;
					КонецЕсли;
					Если ОтборСтрок <> Неопределено Тогда
						ОтборПройден = Истина;
						Для Каждого КлючИЗначение Из ОтборСтрок Цикл
							Если ДанныеСтроки[КлючИЗначение.Ключ] <> КлючИЗначение.Значение Тогда
								ОтборПройден = Ложь;
								Прервать;
							КонецЕсли;
						КонецЦикла;
						Если Не ОтборПройден Тогда
							Продолжить;
						КонецЕсли;
					КонецЕсли;
					Если СУчетомОтбора Тогда 
						//Если МассивСтрок.Количество() < 500 Тогда // Не будем тратить более 5сек на дорогую проверку пользовательского фильтра
						//	// долго - 10мс https://www.hostedredmine.com/issues/947570
						//	Если Не ирОбщий.ПрисвоитьЕслиНеРавноЛкс(ТаблицаФормы.ТекущаяСтрока, ИДСтроки) Тогда
						//		Продолжить;
						//	КонецЕсли;
						//КонецЕсли; 
						Если Не ТаблицаФормы.ПроверитьСтроку(ИДСтроки) Тогда
							Продолжить;
						КонецЕсли;
					КонецЕсли;
					НоваяСтрока = Результат.Добавить();
					Если ТипЗнч(ИДСтроки) = Тип("Число") И Колонка_КлючИсточникаДобавлена Тогда
						НоваяСтрока._КлючИсточника = ИДСтроки;
					КонецЕсли; 
					ЗаполнитьЗначенияСвойств(НоваяСтрока, ДанныеСтроки); 
				КонецЦикла; 
				ТабличноеПоле.ТекущаяСтрока = СтараяТекущаяСтрока;
				Если ЗначениеЗаполнено(КолонкаСРеквизитом) Тогда
					ЗначенияКолонкиСРеквизитом = ПрочитатьРеквизитПоМассивуСсылокЛкс(Результат.ВыгрузитьКолонку(ирОбщий.ПервыйФрагментЛкс(КолонкаСРеквизитом)), ирОбщий.ПоследнийФрагментЛкс(КолонкаСРеквизитом));
					Результат.ЗагрузитьКолонку(ЗначенияКолонкиСРеквизитом, СтрЗаменить(КолонкаСРеквизитом, ".", "_"));
				КонецЕсли; 
				Результат = ирОбщий.СузитьТипыКолонокТаблицыБезПотериДанныхЛкс(Результат);
			ИначеЕсли ДанныеЭлемента <> Неопределено Тогда 
				ДобавитьКолонкиГруппыФормыВТаблицуЗначенийЛкс(ТаблицаФормы.ПодчиненныеЭлементы, Результат, ДанныеЭлемента, ИменаКолонокРезультата);
			КонецЕсли; 
			//Если ВыделенныеСтрокиВосстановить <> Неопределено Тогда
			//	ТаблицаФормы.ВыделенныеСтроки.Очистить();
			//	Для Каждого ВыделеннаяСтрока Из ВыделенныеСтрокиВосстановить Цикл
			//		ТаблицаФормы.ВыделенныеСтроки.Добавить(ВыделеннаяСтрока);
			//	КонецЦикла; 
			//КонецЕсли; 
		КонецЕсли; 
		ВыгрузкаРезультата = Результат;
		Если ПреобразоватьДеревоВТаблицу И ТипЗнч(ВыгрузкаРезультата) = Тип("ДеревоЗначений") Тогда
			ВыгрузкаРезультата = ирОбщий.ДеревоЗначенийВТаблицуЛкс(ВыгрузкаРезультата);
		КонецЕсли; 
	КонецЕсли;
	Если ОчиститьТаблицу И ТипЗнч(ВыгрузкаРезультата) = Тип("ТаблицаЗначений") Тогда
		ВыгрузкаРезультата.Очистить();
	КонецЕсли;
	Возврат ВыгрузкаРезультата;

КонецФункции

Процедура ОбновитьПодменюПоследнихОтборовЛкс(ЭтаФорма, Знач КоманднаяПанель, Знач ТабличноеПоле) Экспорт 
	
	ПоследниеВыбранныеЗаполнитьПодменюЛкс(ЭтаФорма, КоманднаяПанель.Кнопки.ПоследниеОтборы, ТабличноеПоле, Новый Действие("КлсКомандаНажатие"), "Отборы");
	ЭтаФорма.ОбработчикИзмененияДанных("ЭлементыФормы." + ТабличноеПоле.Имя + ".Отбор");

КонецПроцедуры

Процедура ПоследниеВыбранныеНажатиеЛкс(Знач ЭтаФорма, Знач ТабличноеПолеИлиКлюч, Знач КлючевоеПоле = "Ссылка", Знач Кнопка, Знач ТипКлюча = "Выбранные", ДопКлючХранения = "") Экспорт 
	
	КлючСтроки = ВыбранныйЭлементПоследнихЗначенийЛкс(ЭтаФорма, ТабличноеПолеИлиКлюч, Кнопка, ТипКлюча,, ДопКлючХранения);
	СтрокаНайдена = УстановитьТекущуюСтрокуСКонтролемУспешностиЛкс(ЭтаФорма, ТабличноеПолеИлиКлюч, КлючевоеПоле, КлючСтроки,, Истина);
	Если СтрокаНайдена И ЭтаФорма.РежимВыбора Тогда
		Ответ = Вопрос("Выбрать установленную строку?", РежимДиалогаВопрос.ОКОтмена);
		Если Ответ = КодВозвратаДиалога.ОК Тогда
			//ЭтаФорма.ОповеститьОВыборе(КлючСтроки);
			//Если Этаформа.ВводДоступен() Тогда
				ОтправитьНажатияКлавишЛкс("{ENTER}");
			//КонецЕсли; 
		КонецЕсли;
	КонецЕсли;
	
КонецПроцедуры

// Параметры:
//   ЭтаФорма - Форма
//   ТабличноеПоле - ТабличноеПоле
//   КлючевоеПоле - Строка 
//   ЗначениеКлюча - 
//   СообщатьОбУспехе - Булево
//
Функция УстановитьТекущуюСтрокуСКонтролемУспешностиЛкс(Знач ЭтаФорма, Знач ТабличноеПоле, Знач КлючевоеПоле = "Ссылка", Знач ЗначениеКлюча = Неопределено, Знач СообщатьОбУспехе = Ложь,
	АктивизироватьТабличноеПолеПриУспехе = Ложь, ВыводитьСообщения = Истина) Экспорт
	
	ПолноеИмяТаблицыБД = "";
	ДанныеТабличногоПоля = Неопределено;
	ТипИсточника = ирОбщий.ОбщийТипДанныхТабличногоПоляЛкс(ТабличноеПоле,,, ПолноеИмяТаблицыБД, ДанныеТабличногоПоля);
	Если Ложь
		Или ТипИсточника = "ТаблицаЗначений" 
		Или ТипИсточника = "ТабличнаяЧасть"
		Или ТипИсточника = "НаборЗаписей"
	Тогда
		ДанныеТабличногоПоля = ирОбщий.ДанныеЭлементаФормыЛкс(ТабличноеПоле);
		#Если Сервер И Не Сервер Тогда
		    ДанныеТабличногоПоля = Новый ТаблицаЗначений;
		#КонецЕсли
		Если КлючевоеПоле <> Неопределено Тогда
			НайденныеСтроки = ДанныеТабличногоПоля.НайтиСтроки(Новый Структура(КлючевоеПоле, ЗначениеКлюча));
		Иначе
			НайденныеСтроки = ДанныеТабличногоПоля;
		КонецЕсли; 
		Если НайденныеСтроки.Количество() > 0 Тогда
			НайденнаяСтрока = НайденныеСтроки[0];
			Если ТипЗнч(ТабличноеПоле) = Тип("ТаблицаФормы") Тогда
				НайденнаяСтрока = НайденнаяСтрока.ПолучитьИдентификатор();
			КонецЕсли; 
		КонецЕсли; 
		ЭтоКлиентскийИсточникДанных = Истина;
	ИначеЕсли ТипИсточника = "ДеревоЗначений" Тогда
		НайденнаяСтрока = ТабличноеПоле.Значение.Строки.Найти(ЗначениеКлюча, КлючевоеПоле, Истина);
		ЭтоКлиентскийИсточникДанных = Истина;
	Иначе
		НайденнаяСтрока = ЗначениеКлюча;
		Если ДанныеТабличногоПоля <> Неопределено Тогда
			Отбор = ДанныеТабличногоПоля.Отбор;
			ЭтоКлиентскийИсточникДанных = Ложь;
			ПостроительЗапроса = Новый ПостроительЗапроса;
			ПостроительЗапроса.Текст = "ВЫБРАТЬ РАЗРЕШЕННЫЕ * ИЗ " + ПолноеИмяТаблицыБД;
			ПостроительЗапроса.ЗаполнитьНастройки();
			СтруктураКлюча = ирОбщий.СтруктураКлючаТаблицыБДЛкс(ПолноеИмяТаблицыБД,,, Ложь);
			ЗаполнитьЗначенияСвойств(СтруктураКлюча, ЗначениеКлюча); 
			ирОбщий.УстановитьОтборПоСтруктуреЛкс(ПостроительЗапроса.Отбор, СтруктураКлюча);
			СтрокаЕстьВИсточникеДанных = Не ПостроительЗапроса.Результат.Пустой();
		Иначе
			СтрокаЕстьВИсточникеДанных = Истина; // Немного криво
		КонецЕсли; 
	КонецЕсли;
	Если ЭтоКлиентскийИсточникДанных Тогда
		СтрокаЕстьВИсточникеДанных = НайденнаяСтрока <> Неопределено;
	КонецЕсли;
	Если СтрокаЕстьВИсточникеДанных Тогда
		ТабличноеПоле.ТекущаяСтрока = НайденнаяСтрока;
	ИначеЕсли ВыводитьСообщения Тогда 
		ирОбщий.СообщитьЛкс("Строка не найдена в источнике данных");
	КонецЕсли;
	Если ТабличноеПоле.ТекущаяСтрока = НайденнаяСтрока Тогда
		Если АктивизироватьТабличноеПолеПриУспехе Тогда
			ЭтаФорма.ТекущийЭлемент = ТабличноеПоле;
		КонецЕсли; 
		Результат = Истина;
	Иначе
		Если ВыводитьСообщения И СтрокаЕстьВИсточникеДанных Тогда
			ТекстСообщения = "Строка найдена в источнике данных, но не найдена в табличном поле";
			Если Отбор <> Неопределено Тогда
				ТекстСообщения = ТекстСообщения + " с учетом отбора " + Отбор;
			КонецЕсли;
			ирОбщий.СообщитьЛкс(ТекстСообщения, СтатусСообщения.Внимание);
		КонецЕсли; 
		Результат = Ложь;
	КонецЕсли;
	Возврат Результат;
	
КонецФункции

Функция ВыбранныйЭлементПоследнихЗначенийЛкс(Знач ЭтаФорма, Знач ТабличноеПоле, Знач Кнопка, Знач ТипКлюча = "Выбранные", Знач Десериализовать = Ложь, ДопКлючХранения = "") Экспорт 
	
	КлючЗначения = ирОбщий.КлючСохраненияСпискаПоследнихЗначенийФормыЛкс(ЭтаФорма, ТабличноеПоле, ТипКлюча, ДопКлючХранения);
	ПоследниеВыбранные = ирОбщий.ВосстановитьЗначениеЛкс(КлючЗначения);
	Если ТипЗнч(ПоследниеВыбранные) <> Тип("СписокЗначений") Тогда
		Возврат Неопределено;
	КонецЕсли;
	ИндексЭлементаСписка = Число(Сред(Кнопка.Имя, СтрДлина(ирОбщий.НачалоИмениКнопкиПодменюПоследнихВыбранныхЛкс(ТипКлюча)) + 1));
	Если ПоследниеВыбранные.Количество() <= ИндексЭлементаСписка Тогда
		Возврат Неопределено;
	КонецЕсли; 
	Результат = ПоследниеВыбранные[ИндексЭлементаСписка].Значение;
	Если Десериализовать Тогда
		Результат = ирОбщий.ОбъектИзСтрокиXMLЛкс(Результат);
	КонецЕсли; 
	Возврат Результат;

КонецФункции

// Функция - Последние выбранные добавить лкс
//
// Параметры:
//  ЭтаФорма				 - 	 - 
//  ВыбранноеЗначение		 - 	 - 
//  ПредставлениеЗначения	 - 	 - 
//  ТабличноеПолеИлиКлюч	 - 	 - 
//  ТипКлюча				 - 	 - 
//  Сериализовать			 - 	 - 
// 
// Возвращаемое значение:
//   - Булево - Истина если значение было добавлено в список
//
Функция ПоследниеВыбранныеДобавитьЛкс(ЭтаФорма, Знач ВыбранноеЗначение, Знач ПредставлениеЗначения = "", Знач ТабличноеПолеИлиКлюч = Неопределено, Знач ТипКлюча = "Выбранные",
	Знач Сериализовать = Ложь, ДопКлючХранения = "") Экспорт 
	
	ЗапоминатьПоследниеВыбранные = ирОбщий.КоличествоЗапоминаемыхПоследнихВыбранныхЛкс();
	Если Истина
		И ЗапоминатьПоследниеВыбранные <> Неопределено 
		И ЗапоминатьПоследниеВыбранные > 0
	Тогда
		КлючЗначения = ирОбщий.КлючСохраненияСпискаПоследнихЗначенийФормыЛкс(ЭтаФорма, ТабличноеПолеИлиКлюч, ТипКлюча, ДопКлючХранения);
		ПоследниеВыбранные = ирОбщий.ВосстановитьЗначениеЛкс(КлючЗначения);
		Если ТипЗнч(ПоследниеВыбранные) <> Тип("СписокЗначений") Тогда
			ПоследниеВыбранные = Новый СписокЗначений;
		КонецЕсли;
		Если ТипЗнч(ВыбранноеЗначение) = Тип("Массив") Тогда
			Если ВыбранноеЗначение.Количество() = 0 Тогда
				Возврат Ложь;
			КонецЕсли; 
			ВыбранноеЗначение = ВыбранноеЗначение[0];
		КонецЕсли;
		Если Не ЗначениеЗаполнено(ПредставлениеЗначения) Тогда
			ПредставлениеЗначения = ирОбщий.ПредставлениеКлючаСтрокиБДЛкс(ВыбранноеЗначение);
		КонецЕсли; 
		Если Сериализовать Тогда
			ВыбранноеЗначение = ирОбщий.ОбъектВСтрокуXMLЛкс(ВыбранноеЗначение);
		КонецЕсли; 
		Индекс = ПоследниеВыбранные.НайтиПоЗначению(ВыбранноеЗначение);
		Если Индекс = 0 Тогда 
			Возврат Ложь;
		ИначеЕсли Индекс <> Неопределено Тогда
			ПоследниеВыбранные.Удалить(Индекс);
		Иначе
			Пустышка = 0;
		КонецЕсли;
		КлючСтроки = ВыбранноеЗначение;
		ПоследниеВыбранные.Вставить(0, КлючСтроки, ПредставлениеЗначения);
		ирОбщий.СохранитьЗначениеЛкс(КлючЗначения, ПоследниеВыбранные);
		Возврат Истина;
	Иначе
		Возврат Ложь;
	КонецЕсли;
		
КонецФункции

// .
// Параметры:
//   ЭтаФорма - Форма
//   КнопкаПодменю - Кнопка - подменю, в которое будут добавлены кнопки
//
Процедура ПоследниеВыбранныеЗаполнитьПодменюЛкс(Знач ЭтаФорма, Знач КнопкаПодменю, Знач ТабличноеПолеИлиКлюч = Неопределено, Знач ОбработчикКнопки = Неопределено,
	Знач ТипКлюча = "Выбранные", Знач ДопКлючХранения = "") Экспорт
	
	КлючЗначения = ирОбщий.КлючСохраненияСпискаПоследнихЗначенийФормыЛкс(ЭтаФорма, ТабличноеПолеИлиКлюч, ТипКлюча, ДопКлючХранения);
	ПоследниеВыбранные = ирОбщий.ВосстановитьЗначениеЛкс(КлючЗначения);
	Если ТипЗнч(КнопкаПодменю) = Тип("ГруппаФормы") Тогда
		//ирОбщий.ОчиститьПодчиненныеЭлементыФормыЛкс(КнопкаПодменю, 0);
		ирОбщий.УстановитьСвойствоВКоллекцииЛкс(КнопкаПодменю.ПодчиненныеЭлементы, "Видимость", Ложь);
	Иначе
		КнопкаПодменю.Кнопки.Очистить();
	КонецЕсли; 
	Если ТипЗнч(ПоследниеВыбранные) <> Тип("СписокЗначений") Тогда
		Возврат;
	КонецЕсли;
	#Если Сервер И Не Сервер Тогда
		ПоследниеВыбранные = Новый СписокЗначений;
	#КонецЕсли
	ЧислоЯчеекПамяти = ирОбщий.КоличествоЗапоминаемыхПоследнихВыбранныхЛкс();
	Для Счетчик = ЧислоЯчеекПамяти По ПоследниеВыбранные.Количество() - 1 Цикл
		ПоследниеВыбранные.Удалить(ЧислоЯчеекПамяти);
	КонецЦикла;
	#Если Клиент Тогда
	Если ТипЗнч(ЭтаФорма) = Тип("Форма") Тогда
		КомандныеПанелиКнопок = ирОбщий.СлужебныеДанныеФормыЛкс(ЭтаФорма).КомандныеПанелиКнопок;
	КонецЕсли; 
	#КонецЕсли
	ПодсказкаКнопки = "Активировать выбранный элемент в списке";
	Для каждого ЭлементСписка Из ПоследниеВыбранные Цикл
		ИмяКнопки = ирОбщий.НачалоИмениКнопкиПодменюПоследнихВыбранныхЛкс(ТипКлюча) + ПоследниеВыбранные.Индекс(ЭлементСписка);
		Если ТипЗнч(КнопкаПодменю) = Тип("ГруппаФормы") Тогда
			// При создании формы надо вызвать ирСервер.СоздатьКнопкиПоследнихВыбранныхЛкс()
			Кнопка = ЭтаФорма.Элементы.Найти(КнопкаПодменю.Имя + ИмяКнопки);
			Если Кнопка = Неопределено Тогда
				Прервать;
			КонецЕсли;
			//Кнопка.Отображение = ОтображениеКнопкиКоманднойПанели.Авто;
			Кнопка.Заголовок = ЭлементСписка.Представление; // Могут быть неявные серверные вызовы. Например при смене таблицы в дин. списке
			Кнопка.Видимость = Истина;
		Иначе
			#Если Клиент Тогда
			Кнопка = КнопкаПодменю.Кнопки.Добавить();
			Кнопка.ТипКнопки = ТипКнопкиКоманднойПанели.Действие;
			Кнопка.Имя = ИмяКнопки;
			//Кнопка.Отображение = ОтображениеКнопкиКоманднойПанели.Авто;
			ТекстКнопки = ЭлементСписка.Представление;
			ирОбщий.ЗаменитьФигурныеСкобкиЛкс(ТекстКнопки); // https://www.hostedredmine.com/issues/946247
			Кнопка.Текст = ТекстКнопки;
			Кнопка.Подсказка = ПодсказкаКнопки;
			Кнопка.Пояснение = Кнопка.Подсказка;
			Если ОбработчикКнопки = Неопределено Тогда
				ОбработчикКнопки = Новый Действие("ПоследниеВыбранныеНажатие");
			КонецЕсли; 
			Попытка
				Кнопка.Действие = ОбработчикКнопки;
			Исключение
				Прервать;
			КонецПопытки; 
			КомандныеПанелиКнопок[Кнопка] = КнопкаПодменю;
			#КонецЕсли
		КонецЕсли; 
	КонецЦикла;
	
КонецПроцедуры

Процедура НайденныеСтандартноСсылкиПриВыводеСтрокиЛкс(Знач ОформлениеСтроки, Знач ПолучатьПредставленияСсылок = Ложь, Знач ПолноеИмяМД = "") Экспорт 
	
	ДанныеСтроки = ОформлениеСтроки.ДанныеСтроки;
	#Если Сервер И Не Сервер Тогда
		ДанныеСтроки = Обработки.ирИсторияДанных.Создать().Версии.Добавить();
		ДанныеСтроки = Обработки.ирРедакторОбъектаБД.Создать().СсылкиНаОбъект.Добавить();
	#КонецЕсли
	Ячейки = ОформлениеСтроки.Ячейки;
	Если Не ЗначениеЗаполнено(ПолноеИмяМД) Тогда
		ПолноеИмяМД = ДанныеСтроки.Метаданные;
	КонецЕсли; 
	КорневойТип = ирОбщий.ПервыйФрагментЛкс(ПолноеИмяМД);
	КлючОбъекта = КлючОбъектаСтрокиВерсииДанныхЛкс(ДанныеСтроки, ПолноеИмяМД);
	Ячейки.Данные.Текст = ирОбщий.ПредставлениеКлючаСтрокиБДЛкс(КлючОбъекта, ПолучатьПредставленияСсылок);

КонецПроцедуры

Функция НадоСериализоватьКлючДанныхДляОтображенияЛкс(ТипМетаданных) Экспорт 
	
	НадоСериализоватьКлюч = ирОбщий.ЛиКорневойТипРегистраСведенийЛкс(ТипМетаданных);
	Возврат НадоСериализоватьКлюч;

КонецФункции

Процедура ОформитьФонТекущейСтрокиЛкс(Элемент, ОформлениеСтроки, ДанныеСтроки) Экспорт
	
	Если Элемент.ТекущаяСтрока = ДанныеСтроки Тогда
		ОформлениеСтроки.ЦветФона = WebЦвета.СветлоНебесноГолубой;
	КонецЕсли; 

КонецПроцедуры

Функция ПроверитьЗапуститьОтладчик(Знач ВремяОжиданияЗапуска = 5) Экспорт
	
	Платформа = ирКэш.Получить();
	#Если Сервер И Не Сервер Тогда
		Платформа = Обработки.ирПлатформа.Создать();
	#КонецЕсли
	ИдентификаторыОтладчиков = Неопределено;
	АдресОтладчика = Платформа.ПортДляПодключенияОтладчика(ИдентификаторыОтладчиков);
	#Если Сервер И Не Сервер Тогда
		ИдентификаторыОтладчиков = Новый Массив;
	#КонецЕсли
	Если ИдентификаторыОтладчиков.Количество() = 0 Тогда
		//СеансКонфигуратора = ирОбщий.СеансКонфигуратора(); // может быть долго
		//Если СеансКонфигуратора <> Неопределено Тогда
		//	ирОбщий.СообщитьЛкс("Конфигуратор уже открыт, но отладка не подключена. Выполните подключение отладчика вручную");
		//	Возврат Неопределено;
		//КонецЕсли;
		// Антибаг 8.2.15 http://partners.v8.1c.ru/forum/thread.jsp?id=1003164#1003164
		Если ирКэш.НомерВерсииПлатформыЛкс() = 802015 Тогда 
			ирОбщий.СообщитьЛкс("Из-за ошибки платформы 8.2.15 запуск и подключение отладчика необходимо выполнять вручную");
			Возврат Неопределено;
		КонецЕсли; 
		Если АдресОтладчика = Неопределено Тогда
			ирОбщий.СообщитьЛкс("Если используется TCP отладка, включите разрешение отладки в главном меню ""Сервис/Параметры/Системные"" и повторите операцию снова");
			Возврат Неопределено;
		КонецЕсли;
		//Если Найти(НРег(АдресОтладчика), "http") > 0 Тогда
		//	ирОбщий.СообщитьЛкс("Используется http отладка.");
		//КонецЕсли; 
		ПараметрыЗапуска = "CONFIG /DEBUG /DEBUGTARGET""" + АдресОтладчика + """";
		ЗапуститьСистему(ПараметрыЗапуска);
		ирОбщий.ПаузаЛкс(ВремяОжиданияЗапуска);
		Пока Истина Цикл
			Платформа.ПортДляПодключенияОтладчика(ИдентификаторыОтладчиков);
			Если ИдентификаторыОтладчиков.Количество() = 0 Тогда
				Ответ = Вопрос("Отладчик еще не подключился. Повторить снова?", РежимДиалогаВопрос.ОКОтмена);
				Если Ответ = КодВозвратаДиалога.ОК Тогда
					Продолжить;
				КонецЕсли;
			КонецЕсли;
			Прервать;
		КонецЦикла;
		Если ИдентификаторыОтладчиков.Количество() > 0 Тогда
			ВыбранныйИдентификатор = Число(ИдентификаторыОтладчиков[0]);
		КонецЕсли;
	Иначе
		Если ИдентификаторыОтладчиков.Количество() = 1 Тогда
			ВыбранныйИдентификатор = ИдентификаторыОтладчиков[0];
		Иначе
			ВыбранныйИдентификатор = Платформа.ВыбратьПроцессКонфигуратора(ИдентификаторыОтладчиков);
		КонецЕсли; 
		Если ВыбранныйИдентификатор <> Неопределено Тогда
			Платформа.АктивизироватьОкноПроцесса1С8(Число(ВыбранныйИдентификатор));
		КонецЕсли; 
	КонецЕсли;
	Возврат ВыбранныйИдентификатор;
	
КонецФункции

Процедура ОткрытьСсылкуЯчейкиВРедактореОбъектаБДЛкс(ТабличноеПоле, ИмяКолонки = "") Экспорт
	
	Если ТабличноеПоле.ТекущаяСтрока = Неопределено Тогда
		Возврат;
	КонецЕсли;
	Если Не ЗначениеЗаполнено(ИмяКолонки) Тогда
		ТекущаяКолонка = ТабличноеПолеТекущаяКолонкаЛкс(ТабличноеПоле);
		Если ТекущаяКолонка = Неопределено Тогда
			Возврат;
		КонецЕсли; 
		Если ТипЗнч(ТабличноеПоле) = Тип("ТаблицаФормы") Тогда
			ИмяКолонки = ирОбщий.ПутьКДаннымЭлементаУправляемойФормыЛкс(ТекущаяКолонка, Истина);
		Иначе
			ИмяКолонки = ТекущаяКолонка.Данные;
		КонецЕсли; 
	КонецЕсли; 
	Если Не ЗначениеЗаполнено(ИмяКолонки) Тогда
		Возврат;
	КонецЕсли; 
	ДанныеСтроки = ДанныеСтрокиТабличногоПоляЛкс(ТабличноеПоле);
	ЗначениеЯчейки = ДанныеСтроки[ИмяКолонки];
	XMLТип = XMLТипЗнч(ЗначениеЯчейки);
	Если XMLТип = Неопределено Тогда
		Возврат;
	КонецЕсли; 
	Если Найти(XMLТип.ИмяТипа, "Ref.") = 0 Тогда
		Возврат;
	КонецЕсли; 
	//Если Ложь
	//	Или Найти(XMLТип.ИмяТипа, "EnumRef.") > 0 
	//	Или Найти(XMLТип.ИмяТипа, "BusinessProcessRoutePointRef.") > 0 
	//Тогда
	//	ОткрытьФормуСпискаЛкс(ирОбщий.ПолучитьПолноеИмяМДТипаЛкс(ТипЗнч(ЗначениеЯчейки)),, Истина,,,, ЗначениеЯчейки);
	//Иначе
		ОткрытьСсылкуВРедактореОбъектаБДЛкс(ЗначениеЯчейки);
	//КонецЕсли; 
	
КонецПроцедуры

// Параметры
//   КлючИлиОбъект - СтруктураОбъектаБД, Ссылка, ОбъектБД
Функция ОткрытьСсылкуВРедактореОбъектаБДЛкс(КлючОбъекта, ИскомоеЗначение = Неопределено, ИмяТабличнойЧасти = "", ИмяПоля = "", КлючСтроки = Неопределено, НайденныеСсылки = Неопределено) Экспорт 

	ФормаРедактора = ПолучитьФормуСсылки(КлючОбъекта, ИскомоеЗначение);
	ФормаРедактора.Открыть();
	Если НайденныеСсылки <> Неопределено Тогда
		ФормаРедактора.НайтиИПоказатьСсылкиВФорме(НайденныеСсылки);
	КонецЕсли;
	Если ЗначениеЗаполнено(ИмяПоля) Тогда
		Если ЗначениеЗаполнено(ИмяТабличнойЧасти) Тогда
			ИмяДочернейТаблицыБД = КлючОбъекта.Метаданные().ПолноеИмя();
			ИмяДочернейТаблицыБД = ИмяДочернейТаблицыБД + "." + ИмяТабличнойЧасти;
		КонецЕсли; 
		ФормаРедактора.ПоказатьЯчейкуДанныхОбъекта(ИмяДочернейТаблицыБД, ИмяПоля, КлючСтроки);
	КонецЕсли; 
	Возврат ФормаРедактора;

КонецФункции 

Функция ОткрытьОбъектВРедактореОбъектаБДЛкс(ОбъектБД, ИскомоеЗначение = Неопределено, КлючУникальности = Неопределено, Знач Модально = Ложь) Экспорт 

	Если ирОбщий.ЛиСсылкаНаОбъектБДЛкс(ОбъектБД) Тогда
		ВызватьИсключение "Вместо ссылки ожидался объект";
	КонецЕсли; 
	Если КлючУникальности = Неопределено Тогда
		КлючУникальности = Новый УникальныйИдентификатор;
	КонецЕсли; 
	ПараметрыФормы = Новый Структура;
	ПараметрыФормы.Вставить("ПараметрКлючИлиОбъект", ОбъектБД);
	ПараметрыФормы.Вставить("ПараметрПрочитатьОбъект", Ложь);
	ПараметрыФормы.Вставить("ПараметрИскомоеЗначение", ИскомоеЗначение);
	Форма = ПолучитьФормуЛкс("Обработка.ирРедакторОбъектаБД.Форма", ПараметрыФормы,, КлючУникальности);
	#Если Сервер И Не Сервер Тогда
	    Форма = Обработки.ирРедакторОбъектаБД.Создать();
	#КонецЕсли
	ЗаполнитьЗначенияСвойств(Форма.фОбъект, ПараметрыФормы, "ПараметрКлючИлиОбъект, ПараметрПрочитатьОбъект, ПараметрИскомоеЗначение"); 
	Если Модально Тогда
		Форма.ОткрытьМодально();
	Иначе
		Форма.Открыть();
	КонецЕсли;
	Возврат Форма;

КонецФункции

// Параметры
//   КлючИлиОбъект - СтруктураОбъектаБД, Ссылка, ОбъектБД
Функция ПолучитьФормуСсылки(КлючОбъекта, ИскомоеЗначение = Неопределено) 

	ПараметрыФормы = Новый Структура;
	ПараметрыФормы.Вставить("ПараметрКлючИлиОбъект", КлючОбъекта);
	ПараметрыФормы.Вставить("ПараметрПрочитатьОбъект", Истина);
	ПараметрыФормы.Вставить("ПараметрИскомоеЗначение", ИскомоеЗначение);
	Форма = ПолучитьФормуЛкс("Обработка.ирРедакторОбъектаБД.Форма", ПараметрыФормы,, КлючОбъекта);
	#Если Сервер И Не Сервер Тогда
	    Форма = Обработки.ирРедакторОбъектаБД.Создать();
	#КонецЕсли
	ЗаполнитьЗначенияСвойств(Форма, ПараметрыФормы); 
	Возврат Форма;

КонецФункции 

Процедура НайтиИПоказатьСсылкиНаОбъектБД(СсылкаНаКоторуюИщемСсылки) Экспорт

	ПараметрыФормы = Новый Структура;
	ПараметрыФормы.Вставить("ПараметрКлючИлиОбъект", СсылкаНаКоторуюИщемСсылки);
	Форма = ПолучитьФормуЛкс("Обработка.ирРедакторОбъектаБД.Форма", ПараметрыФормы);
	#Если Сервер И Не Сервер Тогда
	    Форма = Обработки.ирРедакторОбъектаБД.Создать();
	#КонецЕсли
	ЗаполнитьЗначенияСвойств(Форма, ПараметрыФормы); 
	Форма.Открыть();
	Форма.НайтиИПоказатьСсылкиВФорме();

КонецПроцедуры // НайтиСсылки()

Функция НоваяФормаТекстаЛкс(ВладелецФормы = Неопределено, КлючУникальности = Неопределено) Экспорт 
	
	ФормаТекста = ирКэш.Получить().ПолучитьФорму("Текст", ВладелецФормы, КлючУникальности);
	Возврат ФормаТекста;

КонецФункции

// .
// Параметры:
//  ВариантПросмотра - Строка - если пусто, то автоматически, иначе "Обычный", "Компактный", "ЯзыкЗапросов", "ВстроенныйЯзык", "XML", "JSON", "Дерево", "РезультатыПоиска"...
Функция ПолучитьФормуТекстаЛкс(Текст, Знач Заголовок = "", ВариантПросмотра = "Компактный", ТолькоПросмотр = Ложь, Знач КлючУникальности = Неопределено, ВладелецФормы = Неопределено, ВыделитьВсе = Ложь) Экспорт

	Если КлючУникальности = Неопределено Тогда
		КлючУникальности = Новый УникальныйИдентификатор();
	КонецЕсли; 
	//ФормаТекста = ирКэш.ФормаТекстаЛкс(); // Толку от кэширования нет, т.к. HTML редактор все равно заново загружается платформой
	//Если ФормаТекста.Открыта() Тогда
		ФормаТекста = НоваяФормаТекстаЛкс(ВладелецФормы, КлючУникальности);
	//Иначе
	//	ФормаТекста.КлючУникальности = КлючУникальности;
	//	ФормаТекста.ВладелецФормы = ВладелецФормы;
	//КонецЕсли;
	ФормаТекста.НачальноеЗначениеВыбора = Текст;
	ФормаТекста.ВариантПросмотра = ВариантПросмотра;
	ФормаТекста.ТолькоПросмотр = ТолькоПросмотр;
	ФормаТекста.ПараметрВыделитьВсе = ВыделитьВсе;
	Если Не ЗначениеЗаполнено(Заголовок) Тогда
		//Заголовок = ФормаПросмотра.Заголовок;
		Заголовок = "Текст"; // Чтобы при повторном открытии не оставался старый текст
	КонецЕсли; 
	ФормаТекста.Заголовок = Заголовок;
	Возврат ФормаТекста;

КонецФункции

// .
// Параметры:
//  ВариантПросмотра - Строка - если пусто, то автоматически, иначе "Обычный", "Компактный", "ЯзыкЗапросов", "ВстроенныйЯзык", "XML", "JSON", "Дерево", "РезультатыПоиска"...
Функция ОткрытьТекстЛкс(Текст, Знач Заголовок = "", ВариантПросмотра = "Компактный", ТолькоПросмотр = Ложь, Знач КлючУникальности = Неопределено, ВладелецФормы = Неопределено, ВыделитьВсе = Ложь) Экспорт
	
	ФормаТекста = ПолучитьФормуТекстаЛкс(Текст, Заголовок, ВариантПросмотра, ТолькоПросмотр, КлючУникальности, ВладелецФормы, ВыделитьВсе);
	ФормаТекста.Открыть();
	Возврат ФормаТекста;

КонецФункции

Функция ОткрытьПросмотрДереваJSONЛкс(Знач Текст, Знач Заголовок = "", Знач КлючУникальности = Неопределено, ВладелецФормы = Неопределено, Знач РежимВыбораМассива = Ложь) Экспорт 
	
	Если Не ЗначениеЗаполнено(Текст) Тогда
		Возврат Неопределено;
	КонецЕсли;
	ФормаПросмотра = ПолучитьФормуТекстаЛкс(Текст, Заголовок, "Дерево",, КлючУникальности, ВладелецФормы);
	ФормаПросмотра.ПараметрРежимВыбораМассива = РежимВыбораМассива;
	Если ЗначениеЗаполнено(Заголовок) Тогда
		Результат = ФормаПросмотра.ОткрытьМодально();
	Иначе
		ФормаПросмотра.Открыть();
	КонецЕсли;
	Возврат Результат;

КонецФункции

Функция ФормаПросмотраHTMLЛкс(Текст) Экспорт 
	
	Форма = ирКэш.Получить().ПолучитьФорму("HTML");
	Форма.ЭлементыФормы.ПолеHtmlДокумента.УстановитьТекст(Текст);
	Возврат Форма;

КонецФункции

Процедура ПолеВводаТекста_НачалоВыбораЛкс(Элемент, СтандартнаяОбработка) Экспорт

	Если ТипЗнч(Элемент.Значение) = Тип("Строка") Тогда
		СтандартнаяОбработка = Ложь;
		ФормаРедактора = ирКэш.Получить().ПолучитьФорму("Текст", Элемент, Новый УникальныйИдентификатор);
		ФормаРедактора.РежимВыбора = Истина;
		ФормаРедактора.НачальноеЗначениеВыбора = Элемент.Значение;
		ФормаРедактора.Открыть();
	КонецЕсли;

КонецПроцедуры

// Функция - проверяет тип поля формы (обычной или управялемой)
//
// Параметры:
//  ЭлементФормы - ЭлементФормы  - Элемент обычной или управляемой формы
//  ТипПоля      - Тип - тип поля обычной формы
// 
// Возвращаемое значение:
//   Булево - Истина, если поле соответсвует типу 
//
Функция ЛиПолеФормыИмеетТипЛкс(Знач ЭлементФормы, ТипПоля) Экспорт 
	
	мПлатформа = ирКэш.Получить();
	#Если Сервер И Не Сервер Тогда
		мПлатформа = Обработки.ирПлатформа.Создать();
	#КонецЕсли
	Результат = Ложь
		Или ТипЗнч(ЭлементФормы) = ТипПоля
		Или (Истина
			И ТипЗнч(ЭлементФормы) = Тип("ПолеФормы") 
			И ЭлементФормы.Вид = ПредопределенноеЗначение("ВидПоляФормы." + мПлатформа.СтруктураТипаИзКонкретногоТипа(ТипПоля).ИмяОбщегоТипа));
	Возврат Результат;

КонецФункции

// Функция - Построитель табличного поля с отбором клиента
//
// Параметры:
//  ТабличноеПоле	 - ТабличноеПоле - табличной части или таблицы значений
//  СтруктураОтбора	 - 	 - 
// 
// Возвращаемое значение:
//   - 
//
Функция ПостроительТабличногоПоляСОтборомКлиентаЛкс(Знач ТабличноеПоле, Знач СтруктураОтбора = Неопределено) Экспорт

	#Если Сервер И Не Сервер Тогда
		ТабличноеПоле = Новый ТабличноеПоле;
	#КонецЕсли
	ПостроительЗапроса = Новый ПостроительЗапроса;
	ПостроительЗапроса.ИсточникДанных = Новый ОписаниеИсточникаДанных(ТабличноеПоле.Значение);
	Попытка
		ОтборСтрок = ТабличноеПоле.ОтборСтрок;
	Исключение
	КонецПопытки; 
	Если ОтборСтрок <> Неопределено Тогда
		ирОбщий.СкопироватьОтборПостроителяЛкс(ПостроительЗапроса.Отбор, ОтборСтрок);
	КонецЕсли; 
	Если СтруктураОтбора <> Неопределено Тогда
		Для Каждого КлючИЗначение Из СтруктураОтбора Цикл
			ирОбщий.УстановитьЭлементОтбораЛкс(ПостроительЗапроса.Отбор.Добавить(КлючИЗначение.Ключ),, КлючИЗначение.Значение);
		КонецЦикла;
	КонецЕсли; 
	Возврат ПостроительЗапроса;

КонецФункции

// Параметры:
//  ТабличноеПоле		 - ТабличноеПоле - 
//  ОтборПоЗначению		 - Булево - Истина - отбирать по значению, Ложь - отбирать без значения
//  Отбор				 - ОтборКомпоновкиДанных, Отбор - 
//  СообщитьОДобавлении	 - Булево - 
//  ТабличноеПолеОтбора	 - ТабличноеПоле - 
//  ЭтаФорма			 - Форма - 
// 
// Возвращаемое значение:
//   - 
//
Функция ТабличноеПолеОтборДляЗначенияВТекущейКолонкеЛкс(Знач ТабличноеПоле, Знач ОтборПоЗначению = Ложь, Знач Отбор = Неопределено, Знач СообщитьОДобавлении = Ложь,
	ТабличноеПолеОтбора = Неопределено, ЭтаФорма = Неопределено, Знач НазначитьПользовательскийИдентификатор = Истина) Экспорт 
	
	#Если Сервер И Не Сервер Тогда
		ТабличноеПоле = Новый ТабличноеПоле;
		ТабличноеПолеОтбора = Новый ТабличноеПоле;
	#КонецЕсли
	Если ТабличноеПоле.ТекущаяСтрока = Неопределено Тогда
		Возврат Ложь;
	КонецЕсли; 
	ДанныеКолонки = ирОбщий.ПутьКДаннымКолонкиТабличногоПоляЛкс(ТабличноеПоле);
	Если Не ЗначениеЗаполнено(ДанныеКолонки) Тогда
		Возврат Ложь;
	КонецЕсли;
	КомпоновкаТП = КомпоновкаТабличногоПоляЛкс(ЭтаФорма, ТабличноеПоле);
	Если Отбор = Неопределено Тогда
		Если КомпоновкаТП <> Неопределено Тогда
			Отбор = КомпоновкаТП.Компоновщик.Настройки.Отбор;
		Иначе
			ДанныеТабличногоПоля = ирОбщий.ДанныеЭлементаФормыЛкс(ТабличноеПоле);
			НастройкиСписка = ирОбщий.НастройкиДинамическогоСпискаЛкс(ДанныеТабличногоПоля, "Пользовательские");
			Попытка
				Отбор = НастройкиСписка.Отбор;
			Исключение
				Отбор = ТабличноеПоле.ОтборСтрок;
			КонецПопытки;
		КонецЕсли; 
	КонецЕсли;
	Если ТипЗнч(Отбор) = Тип("Отбор") Тогда
		#Если Сервер И Не Сервер Тогда
			Отбор = Новый ПостроительЗапроса;
			Отбор = Отбор.Отбор;
		#КонецЕсли
		ЭлементОтбора = Отбор.Найти(ДанныеКолонки);
		Если ЭлементОтбора = Неопределено Тогда
			// Например "Предопределенный"
			Возврат Ложь;
		КонецЕсли; 
		ДоступноеПоле = ЭлементОтбора;
		ТекущееЗначениеОтбора = ЭлементОтбора.Значение;
		ЗначениеЯчейки = ТабличноеПоле.ТекущиеДанные[ДанныеКолонки];
		ДоступноСравнениеРавно = Не ирОбщий.ЛиОписаниеТиповНеограниченнойСтрокиЛкс(ДоступноеПоле.ТипЗначения);
	Иначе // Компоновка
		#Если Сервер И Не Сервер Тогда
			НастройкиСписка = Новый НастройкиКомпоновкиДанных;
			Отбор = Отбор.НастройкиСписка;
		#КонецЕсли
		ДоступноеПоле = ирОбщий.НайтиДоступноеПолеКомпоновкиПоИмениКолонкиЛкс(Отбор.ДоступныеПоляОтбора, ДанныеКолонки);
		#Если Сервер И Не Сервер Тогда
			ДоступноеПоле = НастройкиСписка.ДоступныеПоляВыбора.НайтиПоле(); 
		#КонецЕсли
		Если ДоступноеПоле = Неопределено Тогда
			Возврат Ложь;
		КонецЕсли; 
		ЭлементОтбора = ирОбщий.НайтиДобавитьЭлементОтбораКомпоновкиЛкс(Отбор, ДоступноеПоле.Поле,,,,, Ложь);
		ТекущееЗначениеОтбора = ЭлементОтбора.ПравоеЗначение;
		ЗначениеЯчейки = ТабличноеПоле.ТекущиеДанные["" + ДоступноеПоле.Поле];
		ДоступноСравнениеРавно = ДоступноеПоле.ДоступныеВидыСравнения.НайтиПоЗначению(ВидСравненияКомпоновкиДанных.Равно) <> Неопределено;
	КонецЕсли; 
	Если ОтборПоЗначению Тогда
		Если Истина
			И Не СообщитьОДобавлении
			И ЭлементОтбора.Использование
			И (Ложь
				Или ЭлементОтбора.ВидСравнения = ВидСравнения.Равно 
				Или ЭлементОтбора.ВидСравнения = ВидСравненияКомпоновкиДанных.Равно)
		Тогда
			ЭлементОтбора.Использование = Ложь;
		Иначе
			Если ТипЗнч(ЭлементОтбора) = Тип("ЭлементОтбора") Тогда
				Если ДоступноСравнениеРавно Тогда
					НовыйВидСравения = ВидСравнения.Равно;
				Иначе
					НовыйВидСравения = ВидСравнения.Содержит;
				КонецЕсли;
			Иначе
				Если ДоступноСравнениеРавно Тогда
					НовыйВидСравения = ВидСравненияКомпоновкиДанных.Равно;
				Иначе
					НовыйВидСравения = ВидСравненияКомпоновкиДанных.Содержит;
				КонецЕсли;
			КонецЕсли; 
			ЭлементОтбора.Использование = Истина;
			ЭлементОтбора.ВидСравнения = НовыйВидСравения;
			Если ТипЗнч(ЭлементОтбора) = Тип("ЭлементОтбора") Тогда
				// Привести значение нужно например для NULL в динамическом списке регистра бухгалтерии
				ЭлементОтбора.Значение = ЭлементОтбора.ТипЗначения.ПривестиЗначение(ЗначениеЯчейки);
			Иначе
				ЭлементОтбора.ПравоеЗначение = ЗначениеЯчейки;
			КонецЕсли; 
		КонецЕсли; 
	Иначе
		Если ЭлементОтбора.Использование Тогда
			Если Ложь
				Или ЭлементОтбора.ВидСравнения = ВидСравнения.НеРавно 
				Или ЭлементОтбора.ВидСравнения = ВидСравненияКомпоновкиДанных.НеРавно 
			Тогда
				Если Ложь
					Или (Истина
						И ТипЗнч(ЗначениеЯчейки) <> Тип("Булево")
						И (Ложь
							Или ТипЗнч(ЭлементОтбора) <> Тип("ЭлементОтбора")
							Или ТипЗнч(ЗначениеЯчейки) <> Тип("УникальныйИдентификатор")))
					Или ДоступноеПоле.ТипЗначения.Типы().Количество() > 1
				Тогда
					СписокЗначений = Новый СписокЗначений;
					Если ТипЗнч(ЭлементОтбора) = Тип("ЭлементОтбора") Тогда
						НовыйВидСравения = ВидСравнения.НеВСписке;
					Иначе
						НовыйВидСравения = ВидСравненияКомпоновкиДанных.НеВСписке;
					КонецЕсли; 
					СписокЗначений.Добавить(ТекущееЗначениеОтбора);
					СписокЗначений.Добавить(ЗначениеЯчейки);
					ЭлементОтбора.ВидСравнения = НовыйВидСравения;
					Если ТипЗнч(ЭлементОтбора) = Тип("ЭлементОтбора") Тогда
						ЭлементОтбора.Значение = СписокЗначений;
					Иначе
						ЭлементОтбора.ПравоеЗначение = СписокЗначений;
					КонецЕсли; 
				КонецЕсли;
			ИначеЕсли Ложь
				Или ЭлементОтбора.ВидСравнения = ВидСравнения.НеВСписке 
				Или ЭлементОтбора.ВидСравнения = ВидСравненияКомпоновкиДанных.НеВСписке
			Тогда
				СписокЗначений = ТекущееЗначениеОтбора;
				#Если Сервер И Не Сервер Тогда
					СписокЗначений = Новый СписокЗначений;
				#КонецЕсли
				Если СписокЗначений.НайтиПоЗначению(ЗначениеЯчейки) = Неопределено Тогда
					СписокЗначений.Добавить(ЗначениеЯчейки);
				КонецЕсли; 
				// Для обновления отбора
				ЭлементОтбора.Использование = Ложь; 
				ЭлементОтбора.Использование = Истина;
			ИначеЕсли Ложь
				Или ЭлементОтбора.ВидСравнения = ВидСравнения.ВСписке 
				Или ЭлементОтбора.ВидСравнения = ВидСравненияКомпоновкиДанных.ВСписке
			Тогда
				СписокЗначений = ТекущееЗначениеОтбора;
				СписокЗначений.Удалить(СписокЗначений.НайтиПоЗначению(ЗначениеЯчейки));
				// Для обновления отбора
				ЭлементОтбора.Использование = Ложь; 
				ЭлементОтбора.Использование = Истина;
			Иначе
				ЭлементОтбора.Использование = Ложь;
			КонецЕсли;
		КонецЕсли; 
		Если Не ЭлементОтбора.Использование Тогда
			ЭлементОтбора.Использование = Истина;
			Если Не ДоступноСравнениеРавно Тогда
				Если Не ЗначениеЗаполнено(ЗначениеЯчейки) Тогда
					// Особенность платформы
					Если ТипЗнч(ЭлементОтбора) = Тип("ЭлементОтбора") Тогда
						//ЭлементОтбора.ВидСравнения = ВидСравнения.Содержит;
						ЭлементОтбора.Использование = Ложь;
						ирОбщий.СообщитьЛкс("В этом отборе невозможно отбросить пустое значение в строковой колонке неограниченной длины");
						Возврат Ложь;
					Иначе
						//ЭлементОтбора.ВидСравнения = ВидСравненияКомпоновкиДанных.Содержит;
						ЭлементОтбора.ВидСравнения = ВидСравненияКомпоновкиДанных.Заполнено;
					КонецЕсли; 
				Иначе
					Если ТипЗнч(ЭлементОтбора) = Тип("ЭлементОтбора") Тогда
						ЭлементОтбора.ВидСравнения = ВидСравнения.НеСодержит;
					Иначе
						ЭлементОтбора.ВидСравнения = ВидСравненияКомпоновкиДанных.НеСодержит;
					КонецЕсли; 
				КонецЕсли;
			Иначе
				Если ТипЗнч(ЭлементОтбора) = Тип("ЭлементОтбора") Тогда
					ЭлементОтбора.ВидСравнения = ВидСравнения.НеРавно;
				Иначе
					ЭлементОтбора.ВидСравнения = ВидСравненияКомпоновкиДанных.НеРавно;
				КонецЕсли; 
			КонецЕсли;
			Если ТипЗнч(ЭлементОтбора) = Тип("ЭлементОтбора") Тогда
				// Привести значение нужно например для NULL в динамическом списке регистра бухгалтерии
				ЭлементОтбора.Значение = ЭлементОтбора.ТипЗначения.ПривестиЗначение(ЗначениеЯчейки);
			Иначе
				ЭлементОтбора.ПравоеЗначение = ЗначениеЯчейки;
			КонецЕсли; 
		КонецЕсли;
	КонецЕсли;
	Если СообщитьОДобавлении Тогда
		ирОбщий.СообщитьЛкс(ирОбщий.СтрШаблонИменЛкс("В отбор установлен элемент %1",, ирОбщий.ПредставлениеЭлементаОтбораЛкс(ЭлементОтбора)));
	КонецЕсли; 
	Если ТипЗнч(ЭлементОтбора) = Тип("ЭлементОтбораКомпоновкиДанных") И НазначитьПользовательскийИдентификатор Тогда
		ирОбщий.ПроверитьВключитьЭлементНастроекКомпоновкиВПользовательскиеНастройки(ЭлементОтбора);
	КонецЕсли;
	Если ТабличноеПолеОтбора <> Неопределено Тогда
		ТабличноеПолеОтбора.ТекущаяСтрока = ЭлементОтбора;
	КонецЕсли; 
	Если КомпоновкаТП <> Неопределено Тогда
		ТабличноеПолеСОтборомПросмотраОтобратьЛкс(ЭтаФорма, ТабличноеПоле,,, Истина);
	КонецЕсли;
	Возврат Истина;
КонецФункции

Процедура ТабличноеПолеСОтборомПросмотраОтобратьЛкс(Знач ЭтаФорма, Знач ТабличноеПоле, Знач ИмяКолонкиНомерСтроки = "", Знач РежимОтладки = Ложь, Знач НовоеИспользованиеОтбора = Неопределено) Экспорт 
	
	ИмяТП = ПрефиксРеквизитовКомпоновкиТабличногоПоляЛкс(ЭтаФорма, ТабличноеПоле);
	Если НовоеИспользованиеОтбора <> Неопределено Тогда
		ЭтаФорма[ИмяТП + "ИспользоватьОтбор"] = НовоеИспользованиеОтбора;
	КонецЕсли; 
	ТаблицаЗначений = ЭтаФорма[ИмяТП];
	#Если Сервер И Не Сервер Тогда
		ТаблицаЗначений = Новый ТаблицаЗначений;
		ТабличноеПоле = Новый ТабличноеПоле;
	#КонецЕсли
	Компоновщик = ЭтаФорма[ИмяТП + "Компоновщик"];
	#Если Сервер И Не Сервер Тогда
		Компоновщик = Новый КомпоновщикНастроекКомпоновкиДанных;
	#КонецЕсли
	Попытка
		СтрокаПоиска = ЭтаФорма[ИмяТП + "СтрокаПоиска"];
	Исключение
	КонецПопытки;  
	ИскатьВПредставленияхСсылок = ТаблицаЗначений.Количество() < 30000;
	ИдентификаторГруппыОтбора = "Любое %1 поле содержит все искомые слова";
	ПредставлениеГруппыОтбора = ирОбщий.СтрШаблонЛкс(ИдентификаторГруппыОтбора, ?(ИскатьВПредставленияхСсылок, "", "строковое "));
	Если Не ЗначениеЗаполнено(ИмяКолонкиНомерСтроки) Тогда
		ИмяКолонкиНомерСтроки = ирОбщий.ИмяКолонкиВнутреннегоИДСтрокиЛкс();
	КонецЕсли; 
	ГруппаИли = ирОбщий.НайтиЭлементКоллекцииЛкс(Компоновщик.Настройки.Отбор.Элементы, "ПредставлениеПользовательскойНастройки", ИдентификаторГруппыОтбора);
	Если ЗначениеЗаполнено(СтрокаПоиска) Тогда
		Если ТаблицаЗначений.Количество() < 1000 Тогда
			// Оптимизация для ускорения компоновки макета
			ЕстьБольшиеТипы = Ложь;
			НеСужаемыеКолонки = Новый Массив; // Для ускорения
			Для Каждого Колонка Из ТаблицаЗначений.Колонки Цикл
				КоличествоТипов = Колонка.ТипЗначения.Типы().Количество();
				Если КоличествоТипов = 0 Или КоличествоТипов > 10 Тогда
					ЕстьБольшиеТипы = Истина;
				Иначе
					НеСужаемыеКолонки.Добавить(Колонка.Имя);
				КонецЕсли;
			КонецЦикла;
			Если ЕстьБольшиеТипы Тогда
				ТаблицаБезДанныхСУзкимиТипами = ирОбщий.СузитьТипыКолонокТаблицыБезПотериДанныхЛкс(ТаблицаЗначений,,,,,, НеСужаемыеКолонки, Истина);
			КонецЕсли;
		КонецЕсли;
		ТабличноеПолеСОтборомПросмотраОбновитьКомпоновщикЛкс(ЭтаФорма, ТабличноеПоле, Ложь, ТаблицаБезДанныхСУзкимиТипами);
		СловаПоиска = ирОбщий.РазделитьСтрокуПоискаНаСловаПоискаЛкс(СтрокаПоиска);
		Если ГруппаИли = Неопределено Тогда
			ГруппаИли = Компоновщик.Настройки.Отбор.Элементы.Добавить(Тип("ГруппаЭлементовОтбораКомпоновкиДанных"));
			ГруппаИли.ПредставлениеПользовательскойНастройки  = ИдентификаторГруппыОтбора;
		КонецЕсли;
		ГруппаИли.Представление  = ПредставлениеГруппыОтбора;
		ГруппаИли.ТипГруппы = ТипГруппыЭлементовОтбораКомпоновкиДанных.ГруппаИли;
		ГруппаИли.Элементы.Очистить();
		Запрос = Новый Запрос;
		УсловияИЛИПоДочернимПолямСсылок = Новый Массив;
		ТаблицаСсылок = Новый ТаблицаЗначений;
		// Антибаг платформы 8.3 https://www.hostedredmine.com/issues/950769
		ирОбщий.НайтиДобавитьЭлементОтбораКомпоновкиЛкс(ГруппаИли, ирОбщий.ИмяФиктивногоПоляСхемыКомпоновкиЛкс(), "й",,, Ложь);
		Для Каждого ДоступноеПоле Из Компоновщик.Настройки.ДоступныеПоляОтбора.Элементы Цикл
			ОписаниеТипов = Новый ОписаниеТипов(ДоступноеПоле.ТипЗначения,, ирОбщий.ЗначенияВМассивЛкс(Тип("Null")));
			ПутьКПолю = "";
			Если ОписаниеТипов.СодержитТип(Тип("Строка")) Тогда
				ПутьКПолю = "" + ДоступноеПоле.Поле;
			КонецЕсли;
			Если ОписаниеТипов.Типы().Количество() > 0 Тогда 
				ТипСсылки = ОписаниеТипов.Типы()[0];
				Если Истина 
					И ирОбщий.ЛиТипСсылкиБДЛкс(ТипСсылки) 
					И ирОбщий.ПоляТаблицыМДЛкс(Метаданные.НайтиПоТипу(ТипСсылки)).Найти("Наименование", "Имя") <> Неопределено
				Тогда 
					ПутьКПолю = "" + ДоступноеПоле.Поле + ".Наименование";
				КонецЕсли;
			КонецЕсли;
			Если ПутьКПолю = "" Тогда
				Продолжить;
			КонецЕсли;
			Если Найти(ПутьКПолю, ".") > 0 Тогда
				// Антибаг платформы. Очень долгая компоновка при отборе по дочернему полю https://www.hostedredmine.com/issues/951093 
				Если Не ИскатьВПредставленияхСсылок Тогда
					Продолжить;
				КонецЕсли;
				ТаблицаСсылок.Колонки.Добавить("" + ДоступноеПоле.Поле, ОписаниеТипов);
				УсловияИПоСловам = Новый Массив;
				НомерСлова = 1;
				Для Каждого Слово Из СловаПоиска Цикл
					ИмяПараметраСлова = "Слово" + (УсловияИПоСловам.Количество() + 1);
					УсловияИПоСловам.Добавить(ирОбщий.СтрокаПовторомЛкс(Символы.Таб, 2) + "И " + ПутьКПолю + " ПОДОБНО &" + ИмяПараметраСлова);
					НомерСлова = НомерСлова + 1;
					Запрос.УстановитьПараметр(ИмяПараметраСлова, "%" + Слово + "%");
				КонецЦикла;
				УсловияИЛИПоДочернимПолямСсылок.Добавить(ирОбщий.СтрокаПовторомЛкс(Символы.Таб, 1) + "ИЛИ (ИСТИНА 
				|" + ирОбщий.СтрСоединитьЛкс(УсловияИПоСловам, Символы.ПС) + ")");
			Иначе
				ГруппаИ = ГруппаИли.Элементы.Добавить(Тип("ГруппаЭлементовОтбораКомпоновкиДанных"));
				Для Каждого Слово Из СловаПоиска Цикл
					ирОбщий.НайтиДобавитьЭлементОтбораКомпоновкиЛкс(ГруппаИ, ПутьКПолю, Слово, ВидСравненияКомпоновкиДанных.Содержит,, Ложь);
				КонецЦикла;
			КонецЕсли;
		КонецЦикла;
		Если ТаблицаСсылок.Колонки.Количество() > 0 Тогда
			// Антибаг платформы. Очень долгая компоновка при отборе по дочернему полю https://www.hostedredmine.com/issues/951093
			ирОбщий.НайтиДобавитьКолонкуНомераСтрокиЛкс(ТаблицаЗначений, ИмяКолонкиНомерСтроки, ТаблицаБезДанныхСУзкимиТипами);
			ТаблицаСсылок.Колонки.Добавить(ИмяКолонкиНомерСтроки, Новый ОписаниеТипов("Число"));
			ирОбщий.ЗагрузитьВТаблицуЗначенийЛкс(ТаблицаЗначений, ТаблицаСсылок);
			ИмяПараметра = "ВТ";
			Запрос.Текст = ирОбщий.ТекстЗапросаПоместитьИзПараметраЛкс(ИмяПараметра, ИмяПараметра,, ТаблицаСсылок.Колонки);
			Запрос.Текст = Запрос.Текст + ";
			|ВЫБРАТЬ " + ИмяКолонкиНомерСтроки + " ИЗ " + ИмяПараметра + " ГДЕ ЛОЖЬ
			|" + ирОбщий.СтрСоединитьЛкс(УсловияИЛИПоДочернимПолямСсылок, Символы.ПС);
			Запрос.УстановитьПараметр(ИмяПараметра, ТаблицаСсылок);
			Попытка
				РезультатЗапроса = Запрос.Выполнить();
			Исключение
				// В типах колонок есть недопустимые для запроса типы
				Запрос.УстановитьПараметр(ИмяПараметра, ирОбщий.СузитьТипыКолонокТаблицыБезПотериДанныхЛкс(ТаблицаСсылок));
				РезультатЗапроса = Запрос.Выполнить();
			КонецПопытки;
			НомераСтрок = РезультатЗапроса.Выгрузить().ВыгрузитьКолонку(0);
			ирОбщий.НайтиДобавитьЭлементОтбораКомпоновкиЛкс(ГруппаИли, ИмяКолонкиНомерСтроки, НомераСтрок,,, Ложь);
		КонецЕсли;
		Если ГруппаИли.Элементы.Количество() = 0 Тогда
			Компоновщик.Настройки.Отбор.Элементы.Удалить(ГруппаИли);
			СтрокаПоиска = "";
			ЭтаФорма[ИмяТП + "СтрокаПоиска"] = СтрокаПоиска;
		Иначе
			ГруппаИли.Использование = Истина;
		КонецЕсли;
	Иначе
		Если ГруппаИли <> Неопределено Тогда
			ГруппаИли.Использование = Ложь;
		КонецЕсли;
	КонецЕсли;
	Если Не ирОбщий.ЛиОтборУстановленЛкс(Компоновщик.Настройки.Отбор) И Не ЗначениеЗаполнено(СтрокаПоиска) Тогда
		ЭтаФорма[ИмяТП + "ИспользоватьОтбор"] = Ложь;
	КонецЕсли; 
	ИспользоватьОтбор = ЭтаФорма[ИмяТП + "ИспользоватьОтбор"];
	Если ИспользоватьОтбор Тогда
		ирОбщий.НайтиДобавитьКолонкуНомераСтрокиЛкс(ТаблицаЗначений, ИмяКолонкиНомерСтроки, ТаблицаБезДанныхСУзкимиТипами);
		КлючТекущейСтроки = ТабличноеПолеКлючСтрокиЛкс(ТабличноеПоле, ИмяКолонкиНомерСтроки);
		ИндексТекущейСтроки = ТабличноеПолеПозицияТекущейСтрокиЛкс(ТабличноеПоле); 
		ТаблицаОтобранное = ирОбщий.ОтобратьТаблицуЗначенийКомпоновкойЛкс(ТаблицаЗначений, Компоновщик.Настройки, РежимОтладки,, ТаблицаБезДанныхСУзкимиТипами);
		//ТаблицаЗначенийОтобранное1 = ирОбщий.СузитьТипыКолонокТаблицыБезПотериДанныхЛкс(ТаблицаЗначенийОтобранное1,,,, Истина);
		Если РежимОтладки Тогда
			Возврат;
		КонецЕсли; 
		ТабличноеПоле.ИзменятьСоставСтрок = Ложь;
		ТабличноеПоле.Значение = ТаблицаОтобранное;
		ЭтаФорма[ИмяТП + "Отобранное"] = ТаблицаОтобранное;
		Если КлючТекущейСтроки <> Неопределено Тогда 
			ирОбщий.ДобавитьИндексВТаблицуЛкс(ТаблицаЗначений, ИмяКолонкиНомерСтроки);
			ТекущаяСтрока = ирОбщий.СтрокаТабличнойКоллекцииПоКлючуЛкс(ТаблицаЗначений, КлючТекущейСтроки);
			Для ИндексПроверяемойСтроки = ТаблицаЗначений.Индекс(ТекущаяСтрока) По Мин(ИндексТекущейСтроки + 1000, ТаблицаЗначений.Количество() - 1)  Цикл
				ПроверяемаяСтрока = ТаблицаЗначений[ИндексПроверяемойСтроки];
				КлючТекущейСтроки = ТабличноеПолеКлючСтрокиЛкс(ТабличноеПоле, ИмяКолонкиНомерСтроки, ПроверяемаяСтрока);
				ПроекцияСтроки = ирОбщий.СтрокаТабличнойКоллекцииПоКлючуЛкс(ТабличноеПоле.Значение, КлючТекущейСтроки);
				Если ПроекцияСтроки <> Неопределено Тогда
					ТабличноеПоле.ТекущаяСтрока = ПроекцияСтроки;
					Прервать;
				КонецЕсли; 
			КонецЦикла;
		КонецЕсли; 
	Иначе
		ирОбщий.УстановитьСвойствоВКоллекцииЛкс(Компоновщик.Настройки.Отбор.Элементы, "Использование", Ложь);
		Если ТабличноеПоле.Значение = ТаблицаЗначений Тогда 
			Возврат;
		КонецЕсли;                                
		ДопСвойства = ДопСвойстваЭлементаФормыЛкс(ЭтаФорма, ТабличноеПоле);
		Если ДопСвойства.НачальноеИзменятьСоставСтрок Тогда
			ТабличноеПоле.ИзменятьСоставСтрок = Истина;
		КонецЕсли;
		//КлючТекущейСтроки = ТабличноеПолеКлючСтрокиЛкс(ТабличноеПоле, ИмяКолонкиНомерСтроки);
		СостояниеСтрок = ТабличноеПолеСостояниеСтрокЛкс(ТабличноеПоле, ИмяКолонкиНомерСтроки);
		//ирОбщий.ЗагрузитьВТаблицуЗначенийЛкс(ТаблицаЗначений, ТаблицаОтобранное);
		ЭтаФорма[ИмяТП + "Отобранное"] = ТаблицаЗначений;
		ТабличноеПоле.Значение = ТаблицаЗначений;
		//ТабличноеПолеВосстановитьТекущуюСтрокуЛкс(ТабличноеПоле, КлючТекущейСтроки);
		ТабличноеПолеВосстановитьСостояниеСтрокЛкс(ТабличноеПоле, СостояниеСтрок);
	КонецЕсли;
	ТабличноеПолеОбновитьТекстыПодваловЛкс(ЭтаФорма, ТабличноеПоле);
	ИмяМетода = ИмяТП + "ПослеОтбора";
	Если ирОбщий.МетодРеализованЛкс(ЭтаФорма, ИмяМетода) Тогда
		Выполнить("ЭтаФорма." + ИмяМетода + "()");
	КонецЕсли; 

КонецПроцедуры

Процедура ТабличноеПолеСОтборомПросмотраПриОкончанииРедактированияЛкс(Знач ЭтаФорма, Знач ТабличноеПоле, Знач ИмяКолонкиНомерСтроки = "") Экспорт 
	
	ИмяТП = ПрефиксРеквизитовКомпоновкиТабличногоПоляЛкс(ЭтаФорма, ТабличноеПоле);
	Если Не ЭтаФорма[ИмяТП + "ИспользоватьОтбор"] Тогда 
		Возврат;
	КонецЕсли;
	Если Не ЗначениеЗаполнено(ИмяКолонкиНомерСтроки) Тогда
		ИмяКолонкиНомерСтроки = ирОбщий.ИмяКолонкиВнутреннегоИДСтрокиЛкс();
	КонецЕсли; 
	ТаблицаЗначений = ЭтаФорма[ИмяТП];
	#Если Сервер И Не Сервер Тогда
		ТаблицаЗначений = Новый ТаблицаЗначений;
	#КонецЕсли
	ТаблицаПолная = ЭтаФорма[ИмяТП];
	ТекущаяСтрокаПолная = ТаблицаПолная[ТабличноеПоле.ТекущиеДанные[ИмяКолонкиНомерСтроки] - 1];
	ЗаполнитьЗначенияСвойств(ТекущаяСтрокаПолная, ТабличноеПоле.ТекущиеДанные);

КонецПроцедуры

// Функция - Табличное поле состояние строк лкс
//
// Параметры:
//  ТабличноеПоле		 - 	 - 
//  ИменаКлючевыхКолонок - Строка, 0[число] - если 0, то используется логический номер строки
// 
// Возвращаемое значение:
//   - 
//
Функция ТабличноеПолеСостояниеСтрокЛкс(Знач ТабличноеПоле, Знач ИменаКлючевыхКолонок = 0) Экспорт 
	
	СтруктураСостояния = Новый Структура("ТекущаяКолонка, ТекущаяСтрока, ВыделенныеСтроки");
	СтруктураСостояния.ТекущаяСтрока = ТабличноеПолеКлючСтрокиЛкс(ТабличноеПоле, ИменаКлючевыхКолонок);
	СтруктураСостояния.ВыделенныеСтроки = ТабличноеПолеКлючиСтрокЛкс(ТабличноеПоле, ИменаКлючевыхКолонок);
	Если ТабличноеПоле.ТекущаяКолонка <> Неопределено Тогда
		СтруктураСостояния.ТекущаяКолонка = ТабличноеПоле.ТекущаяКолонка.Имя;
	КонецЕсли; 
	Возврат СтруктураСостояния;

КонецФункции

Функция ТабличноеПолеВосстановитьСостояниеСтрокЛкс(Знач ТабличноеПоле, Знач СтруктураСостояния, ВременноОтключитьОтображение = Истина) Экспорт 
	
	#Если Сервер И Не Сервер Тогда
		СтруктураСостояния = Новый Структура;
		ТабличноеПоле = Новый ТабличноеПоле;
	#КонецЕсли
	Если ВременноОтключитьОтображение Тогда
		// Предотвращаем двойную (синхронную и затем асинхронную) перерисовку видимых строк табличного поля при установке текущих колонки и строки.
		// Такое происходит например в обработчике ПриАктивацииСтраницы в ирЗагрузкаТабличныхДанных. В остальных случаях пользы от этого вероятно нет.
		ОбработчикПриВыводеСтроки = ТабличноеПолеОтключитьОтображениеЛкс(ТабличноеПоле);
	КонецЕсли; 
	Если ЗначениеЗаполнено(СтруктураСостояния.ТекущаяКолонка) Тогда
		ТекущаяКолонка = ТабличноеПоле.Колонки.Найти(СтруктураСостояния.ТекущаяКолонка);
		Если ТекущаяКолонка <> Неопределено И ТекущаяКолонка.Видимость Тогда
			ТабличноеПоле.ТекущаяКолонка = ТекущаяКолонка;
		КонецЕсли; 
	КонецЕсли; 
	ТекущаяСтрокаУстановлена = ТабличноеПолеВосстановитьТекущуюСтрокуЛкс(ТабличноеПоле, СтруктураСостояния.ТекущаяСтрока);
	ТабличноеПолеВосстановитьВыделенныеСтрокиЛкс(ТабличноеПоле, СтруктураСостояния.ВыделенныеСтроки);
	Если ВременноОтключитьОтображение Тогда 
		ТабличноеПолеВключитьОтображениеЛкс(ТабличноеПоле, ОбработчикПриВыводеСтроки);
	КонецЕсли; 
	Возврат ТекущаяСтрокаУстановлена;

КонецФункции

// Параметры:
//  ТаблицаФормы		 - ТаблицаФормы, ТабличноеПоле	 - 
//  ИменаКлючевыхКолонок - Строка, 0[число] - если 0, то используется логический номер строки
//  СтрокаТаблицы		 -  - 
// 
// Результат:
//  Структура
//
Функция ТабличноеПолеКлючСтрокиЛкс(ТаблицаФормы, ИменаКлючевыхКолонок = "Ссылка", Знач СтрокаТаблицы = Неопределено) Экспорт
	
	Если СтрокаТаблицы = Неопределено Тогда
		СтрокаТаблицы = ТаблицаФормы.ТекущиеДанные;
	КонецЕсли; 
	Если СтрокаТаблицы <> Неопределено Тогда
		Если ИменаКлючевыхКолонок = 0 Тогда
			ИмяНомерСтроки = ирОбщий.ПеревестиСтроку("НомерСтроки");
			КлючТекущейСтроки = Новый Структура(ИмяНомерСтроки);
			КлючТекущейСтроки[ИмяНомерСтроки] = СтрокаТаблицы.Владелец().Индекс(СтрокаТаблицы) + 1;
		Иначе
			КлючТекущейСтроки = Новый Структура(ИменаКлючевыхКолонок);
			ЗаполнитьЗначенияСвойств(КлючТекущейСтроки, СтрокаТаблицы, ИменаКлючевыхКолонок); 
		КонецЕсли; 
	КонецЕсли;
	Возврат КлючТекущейСтроки;

КонецФункции

// Функция - Табличное поле ключи строк лкс
//
// Параметры:
//  ТаблицаФормы		 - 	 - 
//  ИменаКлючевыхКолонок - Строка, 0[число] - если 0, то используется логический номер строки
//  СтрокиТаблицы		 - 	 - 
// 
// Возвращаемое значение:
//   - 
//
Функция ТабличноеПолеКлючиСтрокЛкс(ТаблицаФормы, ИменаКлючевыхКолонок = "Ссылка", Знач СтрокиТаблицы = Неопределено) Экспорт
	
	Если СтрокиТаблицы = Неопределено Тогда
		СтрокиТаблицы = ТаблицаФормы.ВыделенныеСтроки;
	КонецЕсли; 
	Результат = Новый Массив;
	Для Каждого СтрокаТаблицы Из СтрокиТаблицы Цикл
		Если СтрокаТаблицы = Неопределено Тогда
			// Случается в дереве формы ирРедакторИзмененийНаУзлах
			Продолжить;
		КонецЕсли; 
		КлючТекущейСтроки = ТабличноеПолеКлючСтрокиЛкс(ТаблицаФормы, ИменаКлючевыхКолонок, СтрокаТаблицы);
		Результат.Добавить(КлючТекущейСтроки);
	КонецЦикла;
	Возврат Результат;

КонецФункции

// Функция - Восстановить текущую строку таблицы формы лкс
//
// Параметры:
//  ТабличноеПоле		 - ТабличноеПоле, ТаблицаФормы - 
//  КлючТекущейСтроки	 - Структура - 
//  ДанныеТаблицы		 - 	 - 
// 
// Возвращаемое значение:
//   - Булево - успешность установки текущей строки
//
Функция ТабличноеПолеВосстановитьТекущуюСтрокуЛкс(ТабличноеПоле, Знач КлючТекущейСтроки, Знач ДанныеТаблицы = Неопределено) Экспорт
	
	#Если Сервер И Не Сервер Тогда
		ТабличноеПоле = Новый ТабличноеПоле;
	#КонецЕсли
	Если КлючТекущейСтроки <> Неопределено Тогда
		Если ДанныеТаблицы = Неопределено Тогда
			ДанныеТаблицы = ирОбщий.ДанныеЭлементаФормыЛкс(ТабличноеПоле);
		КонецЕсли; 
		Строка = ирОбщий.СтрокаТабличнойКоллекцииПоКлючуЛкс(ДанныеТаблицы, КлючТекущейСтроки);
		Если Строка <> Неопределено Тогда
			Попытка
				ИдентификаторСтроки = Строка.ПолучитьИдентификатор();
			Исключение
				ИдентификаторСтроки = Строка;
			КонецПопытки;
			ТабличноеПоле.ТекущаяСтрока = ИдентификаторСтроки;
			Возврат Истина;
		КонецЕсли; 
	КонецЕсли; 
	Возврат Ложь;

КонецФункции

Функция ТабличноеПолеВосстановитьВыделенныеСтрокиЛкс(ТабличноеПоле, Знач КлючиВыделенныхСтрок, Знач ДанныеТаблицы = Неопределено) Экспорт
	
	#Если Сервер И Не Сервер Тогда
		ТабличноеПоле = Новый ТабличноеПоле;
	#КонецЕсли
	ВыделенныеСтроки = ТабличноеПоле.ВыделенныеСтроки;
	Если КлючиВыделенныхСтрок.Количество() > 0 Тогда
		ВыделенныеСтроки.Очистить();
	КонецЕсли; 
	Для Каждого КлючВыделеннойСтроки Из КлючиВыделенныхСтрок Цикл
		Если ДанныеТаблицы = Неопределено Тогда
			ДанныеТаблицы = ТабличноеПоле.Значение;
		КонецЕсли; 
		Строка = ирОбщий.СтрокаТабличнойКоллекцииПоКлючуЛкс(ДанныеТаблицы, КлючВыделеннойСтроки);
		Если Строка <> Неопределено Тогда
			Попытка
				ИдентификаторСтроки = Строка.ПолучитьИдентификатор();
			Исключение
				ИдентификаторСтроки = Строка;
			КонецПопытки;
			ВыделенныеСтроки.Добавить(ИдентификаторСтроки);
		КонецЕсли; 
	КонецЦикла;

КонецФункции

Процедура ТабличноеПолеВключитьОтображениеЛкс(Знач ТабличноеПоле, Знач ОбработчикПриВыводеСтроки) Экспорт 
	
	ТабличноеПоле.УстановитьДействие("ПриВыводеСтроки", ОбработчикПриВыводеСтроки);
	ТабличноеПоле.Видимость = Истина;

КонецПроцедуры

Функция ТабличноеПолеОтключитьОтображениеЛкс(Знач ТабличноеПоле)
	
	ОбработчикПриВыводеСтроки = ТабличноеПоле.ПолучитьДействие("ПриВыводеСтроки");
	ТабличноеПоле.УстановитьДействие("ПриВыводеСтроки", Неопределено);
	ТабличноеПоле.Видимость = Ложь;
	Возврат ОбработчикПриВыводеСтроки;

КонецФункции

Функция ТабличноеПолеТекущаяКолонкаЛкс(ТаблицаФормы, выхЭлементУправления = Неопределено, выхДоступноРедактирование = Неопределено) Экспорт 
	Если ТипЗнч(ТаблицаФормы) = Тип("ТаблицаФормы") Тогда
		Результат = ТаблицаФормы.ТекущийЭлемент;
		выхЭлементУправления = Результат;
	ИначеЕсли ТипЗнч(ТаблицаФормы) = Тип("ТабличноеПоле") Тогда
		Результат = ТаблицаФормы.ТекущаяКолонка;
		Если Результат <> Неопределено Тогда
			выхЭлементУправления = Результат.ЭлементУправления;
		КонецЕсли; 
	Иначе
		ВызватьИсключение "Неверный тип (" + ТипЗнч(ТаблицаФормы) + ") параметра";
	КонецЕсли; 
	выхДоступноРедактирование = Истина
		И (Ложь
			Или ТипЗнч(выхЭлементУправления) = Тип("ПолеВвода")
			Или ТипЗнч(выхЭлементУправления) = Тип("ПолеФормы"))
		И Не выхЭлементУправления.ТолькоПросмотр;
	Возврат Результат;
КонецФункции

Функция ТабличноеПолеУстановитьТекущуюКолонкуЛкс(Знач ТабличноеПоле, Знач НоваяТекущаяКолонка) Экспорт 
	
	#Если Сервер И Не Сервер Тогда
		ТабличноеПоле = Новый ТабличноеПоле;
	#КонецЕсли
	Если ТипЗнч(ТабличноеПоле) = Тип("ТабличноеПоле") Тогда
		Невидимые = Новый Массив;
		// Антибаг платформы. В табличном поле не делается горизонтальная прокрутка при программной активации колонки из-за невидимых колонок https://www.hostedredmine.com/issues/957225
		Колонки = ТабличноеПоле.Колонки;
		КоличествоВидимыхСлева = 0;
		Для Каждого Колонка Из Колонки Цикл
			Если Колонка = НоваяТекущаяКолонка Тогда
				Прервать;
			КонецЕсли;
			Если Не Колонка.Видимость Тогда
				Невидимые.Добавить(Колонка);
			Иначе
				КоличествоВидимыхСлева = КоличествоВидимыхСлева + 1;
			КонецЕсли;
		КонецЦикла;
		Если КоличествоВидимыхСлева > 5 Тогда // При переходе от крайней правой колонки к крайней левой возникает аналогичная описанной выше проблема. Этим условием мы ее исправляем. 
			ирОбщий.УстановитьСвойствоВКоллекцииЛкс(Невидимые, "Видимость", Истина);
		Иначе
			Невидимые.Очистить();
		КонецЕсли;
		//ДействиеПриВыводеСтроки = ТабличноеПоле.ПолучитьДействие("ПриВыводеСтроки");
		//ДействиеПриПриПолученииДанных = ТабличноеПоле.ПолучитьДействие("ПриПолученииДанных");
		//ТабличноеПоле.УстановитьДействие("ПриВыводеСтроки", Неопределено); // Если не отключить, будет тройное обновление строк
		//ТабличноеПоле.УстановитьДействие("ПриПолученииДанных", Неопределено); // Если не отключить, будет тройное обновление строк
		Если Невидимые.Количество() > 0 Тогда
			ТабличноеПоле.Ширина = ТабличноеПоле.Ширина - 1;
		КонецЕсли;
		Результат = ирОбщий.ПрисвоитьЕслиНеРавноЛкс(ТабличноеПоле.ТекущаяКолонка, НоваяТекущаяКолонка);
		Если Невидимые.Количество() > 0 Тогда
			ТабличноеПоле.Ширина = ТабличноеПоле.Ширина + 1;
			ирОбщий.УстановитьСвойствоВКоллекцииЛкс(Невидимые, "Видимость", Ложь);
		КонецЕсли;
		//ТабличноеПоле.УстановитьДействие("ПриВыводеСтроки", ДействиеПриВыводеСтроки);
		//ТабличноеПоле.УстановитьДействие("ПриПолученииДанных", ДействиеПриПриПолученииДанных);
	Иначе
		Результат = ирОбщий.ПрисвоитьЕслиНеРавноЛкс(ТабличноеПоле.ТекущийЭлемент, НоваяТекущаяКолонка);
	КонецЕсли;
	Возврат Результат;

КонецФункции

Функция ТабличноеПолеСтрокаПоискаЛкс(Знач ЭтаФорма, Знач ТабличноеПоле, ПрефиксСтрокиПоиска = "", выхПутьКДанным = "") Экспорт 
	
	//Префикс = ПрефиксРеквизитовКомпоновкиТабличногоПоляЛкс(ЭтаФорма, ТабличноеПоле);
	Если ПрефиксСтрокиПоиска = Неопределено Тогда
		Возврат "";
	КонецЕсли;
	Если Не ЗначениеЗаполнено(ПрефиксСтрокиПоиска) Тогда
		ПрефиксСтрокиПоиска = ТабличноеПоле.Имя;
	КонецЕсли;
	Попытка
		выхПутьКДанным = ПрефиксСтрокиПоиска + "СтрокаПоиска";
		СтрокаПоиска = ЭтаФорма[выхПутьКДанным]; // Долгая операция
	Исключение
		ПрефиксСтрокиПоиска = Неопределено;
		СтрокаПоиска = "";
	КонецПопытки;
	Возврат СтрокаПоиска;

КонецФункции

Функция ТабличноеПолеСОтборомПросмотраОбновитьПредставлениеЛкс(Знач ЭтаФорма, Знач ТабличноеПоле, Знач РазрешитьРучноеВключение = Ложь) Экспорт 
	
	КомпоновкаТП = КомпоновкаТабличногоПоляЛкс(ЭтаФорма, ТабличноеПоле);
	Если КомпоновкаТП = Неопределено Тогда
		Возврат Неопределено;
	КонецЕсли; 
	Компоновщик = КомпоновкаТП.Компоновщик;
	ТаблицаЗначений = КомпоновкаТП.ТаблицаЗначений;
	ТаблицаОтобранное = КомпоновкаТП.ТаблицаОтобранное;
	ИспользоватьОтбор = КомпоновкаТП.ИспользоватьОтбор;
	НадписьОтборПросмотра = КомпоновкаТП.НадписьОтборПросмотра;
	ФлажокИспользоватьОтбор = КомпоновкаТП.ФлажокИспользоватьОтбор;
	#Если Сервер И Не Сервер Тогда
		Компоновщик = Новый КомпоновщикНастроекКомпоновкиДанных;
		ТаблицаЗначений = Новый ТаблицаЗначений;
		ТаблицаОтобранное = Новый ТаблицаЗначений;
	#КонецЕсли
	Пустой = Ложь;
	Результат = ирОбщий.ПредставлениеОтбораЛкс(Компоновщик.Настройки.Отбор, Пустой);
	Если Не Пустой Тогда
		Результат = XMLСтрока(ТаблицаОтобранное.Количество()) + "/" + XMLСтрока(ТаблицаЗначений.Количество() - ТаблицаОтобранное.Количество()) + " - " + Результат;
	КонецЕсли; 
	ирОбщий.ПрисвоитьЕслиНеРавноЛкс(НадписьОтборПросмотра.Заголовок, Результат);
	Если Не РазрешитьРучноеВключение Тогда
		ФлажокИспользоватьОтбор.Доступность = ИспользоватьОтбор;
	КонецЕсли; 
	Возврат Результат;

КонецФункции 

Функция ПрефиксРеквизитовКомпоновкиТабличногоПоляЛкс(Знач ЭтаФорма, Знач ТабличноеПоле, выхКомпоновщик = Неопределено) Экспорт 
	
	Префикс = "" + ТабличноеПоле.Имя; // Тут может быть имитатор табличного поля
	выхКомпоновщик = Неопределено;
	Для Счетчик = 1 По 2 Цикл
		Попытка
			выхКомпоновщик = ЭтаФорма[Префикс + "Компоновщик"];
		Исключение
		КонецПопытки;
		Если выхКомпоновщик = Неопределено И Найти(Префикс, "_") > 0 Тогда
			Префикс = ирОбщий.ПервыйФрагментЛкс(Префикс, "_"); // Редактор объекта БД
		Иначе
			Прервать;
		КонецЕсли; 
	КонецЦикла;
	Если выхКомпоновщик = Неопределено Тогда
		Возврат Неопределено;
	КонецЕсли;
	Возврат Префикс;

КонецФункции

Процедура ТабличноеПолеСОтборомПросмотраУстановитьДанныеЛкс(Знач ЭтаФорма, Знач ТабличноеПоле, Знач ОтключитьОтбор = Истина) Экспорт 

	ИмяТП = ПрефиксРеквизитовКомпоновкиТабличногоПоляЛкс(ЭтаФорма, ТабличноеПоле);
	Если ОтключитьОтбор Тогда
		ЭтаФорма[ИмяТП + "ИспользоватьОтбор"] = Ложь;
	КонецЕсли;
	ТабличноеПоле.Значение = ЭтаФорма[ИмяТП];
	ТабличноеПолеСОтборомПросмотраОбновитьКомпоновщикЛкс(ЭтаФорма, ТабличноеПоле);
	ТабличноеПолеСОтборомПросмотраОтобратьЛкс(ЭтаФорма, ТабличноеПоле);

КонецПроцедуры

Процедура ТабличноеПолеСОтборомПросмотраОбновитьКомпоновщикЛкс(Знач ЭтаФорма, Знач ТабличноеПоле, Знач УстановитьПодсказкуФлажка = Истина, Знач ТаблицаБезДанныхСУзкимиТипами = Неопределено) Экспорт 
	
	КомпоновкаТП = КомпоновкаТабличногоПоляЛкс(ЭтаФорма, ТабличноеПоле);
	Если ТаблицаБезДанныхСУзкимиТипами = Неопределено Тогда
		ТаблицаБезДанныхСУзкимиТипами = КомпоновкаТП.ТаблицаЗначений;
	КонецЕсли;
	СхемаКомпоновки = ирОбщий.СоздатьСхемуПоТаблицеЗначенийЛкс(ТаблицаБезДанныхСУзкимиТипами);
	Компоновщик = КомпоновкаТП.Компоновщик;
	#Если Сервер И Не Сервер Тогда
		Компоновщик = Новый КомпоновщикНастроекКомпоновкиДанных;
	#КонецЕсли
	Компоновщик.Инициализировать(Новый ИсточникДоступныхНастроекКомпоновкиДанных(СхемаКомпоновки));
	Компоновщик.Настройки.Выбор.Элементы.Очистить();
	Если КомпоновкаТП.НадписьОтборПросмотра <> Неопределено Тогда
		КомпоновкаТП.НадписьОтборПросмотра.Подсказка = "<Количество отобрано>/<Количество отброшено> - <Условия отбора>";
	КонецЕсли;
	Если КомпоновкаТП.ФлажокИспользоватьОтбор <> Неопределено И УстановитьПодсказкуФлажка Тогда
		КомпоновкаТП.ФлажокИспользоватьОтбор.Подсказка = 
		"Отбор просмотра включает режим отображения в табличном поле только строк, отвечающих условиям отбора. 
		|При этом отключается возможность добавления/удаления строк данных табличного поля.";
	КонецЕсли; 
	ирОбщий.КомпоновщикНастроекВосстановитьЛкс(Компоновщик);
	ДопСвойства = ДопСвойстваЭлементаФормыЛкс(ЭтаФорма, ТабличноеПоле);
	ДопСвойства.Вставить("НачальноеИзменятьСоставСтрок", ТабличноеПоле.ИзменятьСоставСтрок);
	
КонецПроцедуры

Функция КомпоновкаТабличногоПоляЛкс(Знач ЭтаФорма, Знач ТабличноеПоле) Экспорт 
	
	КомпоновкаТП = Новый Структура;
	Компоновщик = Неопределено;
	Префикс = ПрефиксРеквизитовКомпоновкиТабличногоПоляЛкс(ЭтаФорма, ТабличноеПоле, Компоновщик);
	Если Префикс = Неопределено Тогда
		Возврат Неопределено;
	КонецЕсли; 
	КомпоновкаТП.Вставить("Компоновщик", Компоновщик);
	КомпоновкаТП.Вставить("ТаблицаОтобранное", ЭтаФорма[Префикс + "Отобранное"]);
	КомпоновкаТП.Вставить("ТаблицаЗначений", ЭтаФорма[Префикс]);
	КомпоновкаТП.Вставить("ИспользоватьОтбор", ЭтаФорма[Префикс + "ИспользоватьОтбор"]);
	КомпоновкаТП.Вставить("НадписьОтборПросмотра", ЭтаФорма.ЭлементыФормы.Найти(Префикс + "НадписьОтборПросмотра"));
	КомпоновкаТП.Вставить("ФлажокИспользоватьОтбор", ЭтаФорма.ЭлементыФормы.Найти(Префикс + "ИспользоватьОтбор"));
	Возврат КомпоновкаТП;

КонецФункции

Функция ЗагрузитьЗначениеИзФайлаИнтерактивноЛкс(Знач Расширение = "", Знач ОписаниеФормата = "", Знач Сжатие = Истина) Экспорт
	
	Если Не ЗначениеЗаполнено(Расширение) И Сжатие Тогда
		Расширение = "zip";
	КонецЕсли; 
	ПолноеИмяФайла = ВыбратьФайлЛкс(, Расширение, ОписаниеФормата);
	Если ПолноеИмяФайла = Неопределено Тогда
		Возврат Неопределено;
	КонецЕсли;
	Результат = ирОбщий.ЗагрузитьЗначениеИзФайлаЛкс(ПолноеИмяФайла, Сжатие);
	Возврат Результат;
	
КонецФункции

Функция СохранитьЗначениеВФайлИнтерактивноЛкс(Знач Значение, Знач Расширение = "", Знач ОписаниеФормата = "", Знач Сжатие = Истина, Знач УровеньСжатия = Неопределено, Знач Заголовок = "") Экспорт
	
	Если Не ЗначениеЗаполнено(Расширение) И Сжатие Тогда
		Расширение = "zip";
	КонецЕсли; 
	ПолноеИмяФайла = ВыбратьФайлЛкс(Ложь, Расширение, ОписаниеФормата,,,, Заголовок);
	Если ПолноеИмяФайла = Неопределено Тогда
		Возврат Ложь;
	КонецЕсли;
	Результат = ирОбщий.СохранитьЗначениеВФайлЛкс(Значение, ПолноеИмяФайла, Сжатие, УровеньСжатия);
	Возврат Результат;
	
КонецФункции

Функция ВыбратьРедактируемыйТипЛкс(Знач ОграничениеТипа = Неопределено, Знач ТолькоПросмотр = Ложь, Знач НачальноеЗначениеВыбора = Неопределено, Знач ВладелецФормы = Неопределено,
	ЗакрыватьПриВыборе = Истина, Знач Заголовок = "") Экспорт

	Если ОграничениеТипа = Неопределено Тогда
		ОграничениеТипа = Новый ОписаниеТипов;
	КонецЕсли; 
	ФормаРедактора = ирКэш.Получить().ПолучитьФорму("ВыборРедактируемыхТипов", ВладелецФормы);
	ФормаРедактора.ОграничениеТипа = ОграничениеТипа;
	ФормаРедактора.ЗакрыватьПриВыборе = ЗакрыватьПриВыборе;
	ФормаРедактора.НачальноеЗначениеВыбора = НачальноеЗначениеВыбора;
	ФормаРедактора.РежимВыбора = Истина;
	ФормаРедактора.МножественныйВыбор = Ложь;
	Если ЗначениеЗаполнено(Заголовок) Тогда
		ФормаРедактора.Заголовок = Заголовок;
	КонецЕсли;
	ФормаРедактора.ТолькоПросмотр = ТолькоПросмотр;
	РезультатВыбора = ФормаРедактора.ОткрытьМодально();
	Возврат РезультатВыбора;

КонецФункции

Функция РедактироватьОписаниеРедактируемыхТиповЛкс(Знач ОграничениеТипаИлиПолеВвода = Неопределено, Знач ТолькоПросмотр = Ложь) Экспорт

	Если ОграничениеТипаИлиПолеВвода = Неопределено Тогда
		ОграничениеТипа = Новый ОписаниеТипов
	ИначеЕсли ТипЗнч(ОграничениеТипаИлиПолеВвода) = Тип("ОписаниеТипов") Тогда
		ВладелецФормы = Неопределено;
		ОграничениеТипа = ОграничениеТипаИлиПолеВвода;
	Иначе
		ВладелецФормы = ОграничениеТипаИлиПолеВвода;
		ОграничениеТипа = ОграничениеТипаИлиПолеВвода.Значение;
	КонецЕсли; 
	ФормаРедактора = ирКэш.Получить().ПолучитьФорму("ВыборРедактируемыхТипов", ВладелецФормы);
	//ФормаРедактора.ОграничениеТипа = ОграничениеТипа;
	ФормаРедактора.НачальноеЗначениеВыбора = ОграничениеТипа;
	ФормаРедактора.РежимВыбора = Истина;
	ФормаРедактора.МножественныйВыбор = Истина;
	ФормаРедактора.ТолькоПросмотр = ТолькоПросмотр;
	РезультатВыбора = ФормаРедактора.ОткрытьМодально();
	Возврат РезультатВыбора;

КонецФункции

// ПолноеИмяНачальногоТипаВыбора - Строка - полное имя метаданного
Функция ОткрытьПодборСВыборомТипаЛкс(ВладелецФормы, Знач ОписаниеТипов = Неопределено, Знач НачальноеЗначениеВыбора = Неопределено, Знач ИспользоватьДинамическийСписокИР = Истина,
	Знач ПриПустомОписанииТиповРазрешатьВсе = Ложь, Знач СтруктураОтбора = Неопределено) Экспорт

	ЕстьТипТип = Ложь;
	Если ТипЗнч(ОписаниеТипов) = Тип("Строка") Тогда
		ДоступныеОбъекты = ирОбщий.СтрРазделитьЛкс(ОписаниеТипов, ",", Истина);
	ИначеЕсли ОписаниеТипов <> Неопределено Тогда
		ДоступныеОбъекты = Новый Массив();
		ЕстьТипТип = Ложь;
		Для Каждого Тип Из ОписаниеТипов.Типы() Цикл
			Если Тип = Тип("Тип") Тогда
				ЕстьТипТип = Истина;
			Иначе
				ПолноеИмяМД = ирОбщий.ПолучитьПолноеИмяМДТипаЛкс(Тип);
				Если ЗначениеЗаполнено(ПолноеИмяМД) Тогда
					ДоступныеОбъекты.Добавить(ПолноеИмяМД);
				КонецЕсли; 
			КонецЕсли; 
		КонецЦикла;
		Если ДоступныеОбъекты.Количество() = 0 И ПриПустомОписанииТиповРазрешатьВсе Тогда
			ДоступныеОбъекты = Неопределено;
		КонецЕсли; 
	КонецЕсли;
	Если Истина
		И ДоступныеОбъекты = Неопределено
		И (Ложь
			Или ЕстьТипТип 
			Или (Истина
				И ОписаниеТипов = Неопределено
				И ТипЗнч(НачальноеЗначениеВыбора) = Тип("Тип")))
	Тогда
		Возврат ВыбратьРедактируемыйТипЛкс(,, НачальноеЗначениеВыбора, ВладелецФормы, Ложь);
	КонецЕсли; 
	Если НачальноеЗначениеВыбора <> Неопределено Тогда
		ТипНачальногоЗначенияВыбора = ирОбщий.ТипОбъектаБДЛкс(НачальноеЗначениеВыбора);
		ПолноеИмяНачальногоТипаВыбора = ирОбщий.ПолучитьПолноеИмяМДТипаЛкс(ТипНачальногоЗначенияВыбора);
	КонецЕсли; 
	Если Ложь
		Или ДоступныеОбъекты = Неопределено
		Или ДоступныеОбъекты.Количество() = 0 
		Или ДоступныеОбъекты.Количество() > 1 
	Тогда
		Форма = ирКэш.Получить().ПолучитьФорму("ВыборОбъектаМетаданных", ВладелецФормы);
		лСтруктураПараметров = Новый Структура;
		лСтруктураПараметров.Вставить("ДоступныеОбъекты", ДоступныеОбъекты);
		лСтруктураПараметров.Вставить("ОтображатьСсылочныеОбъекты", Истина);
		лСтруктураПараметров.Вставить("ОтображатьВнешниеИсточникиДанных", Истина);
		лСтруктураПараметров.Вставить("НачальноеЗначениеВыбора", ПолноеИмяНачальногоТипаВыбора);
		Форма.НачальноеЗначениеВыбора = лСтруктураПараметров;
		Результат = Форма.ОткрытьМодально();
		Если Результат = Неопределено Тогда
			Возврат Неопределено;
		КонецЕсли;
		ПолноеИмяМД = Результат.ПолноеИмяОбъекта;
	Иначе
		ПолноеИмяМД = ДоступныеОбъекты[0];
	КонецЕсли;
	Если Не ЗначениеЗаполнено(ПолноеИмяМД) Тогда
		Возврат Неопределено;
	КонецЕсли; 
	Если ПолноеИмяНачальногоТипаВыбора <> ПолноеИмяМД Тогда
		НачальноеЗначениеВыбора = Неопределено;
	КонецЕсли; 
	ТекущаяСтрока = Неопределено;
	Отбор = СтруктураОтбора;
	Если НачальноеЗначениеВыбора <> Неопределено Тогда
		ИмяXMLТипа = СериализаторXDTO.XMLТип(ТипНачальногоЗначенияВыбора).ИмяТипа;
		Если Ложь
			Или Найти(ИмяXMLТипа, "Ref.") > 0
			Или Найти(ИмяXMLТипа, "RecordKey.") > 0
		Тогда
			ТекущаяСтрока = НачальноеЗначениеВыбора;
		Иначе
			Отбор = НачальноеЗначениеВыбора.Методы.Отбор;
		КонецЕсли; 
	КонецЕсли; 
	ФормаВыбора = ОткрытьФормуСпискаЛкс(ПолноеИмяМД, Отбор, ИспользоватьДинамическийСписокИР, ВладелецФормы, Истина, Истина, ТекущаяСтрока);
	Возврат ФормаВыбора;

КонецФункции

Функция ФормаВыбораОбъектаМетаданныхЛкс(Знач ВладелецФормы, Знач КлючУникальности, Знач НачальноеЗначениеВыбора, МножественныйВыбор = Ложь, ОтображатьСсылочныеОбъекты = Ложь,
	ОтображатьВыборочныеТаблицы = Ложь, ОтображатьРегистры = Ложь, ОтображатьПоследовательности = Ложь, ОтображатьКонстанты = Ложь, ОтображатьТабличныеЧасти = Ложь,
	ОтображатьТаблицыИзменений = Ложь, ОтображатьВнешниеИсточникиДанных = Ложь, ЗапретитьВыбиратьСсылочныеОбъекты = Ложь, ТолькоИспользованиеПолнотекстовогоПоиска = Ложь,
	ОтображатьПеречисления = Ложь, Знач Фильтр = "", ОтображатьОбработки = Ложь, ОтображатьОтчеты = Ложь, ОтображатьПерерасчеты = Ложь, ОтображатьРегламентныеЗадания = Ложь,
	ОтображатьСетевыеСервисы = Ложь, ОтображатьРоли = Ложь) Экспорт 
	
	лСтруктураПараметров = ПараметрыВыбораОбъектаМетаданныхЛкс(ОтображатьСсылочныеОбъекты, ОтображатьВыборочныеТаблицы, ОтображатьРегистры, ОтображатьПоследовательности,
		ОтображатьКонстанты, ОтображатьТабличныеЧасти, ОтображатьТаблицыИзменений, ОтображатьВнешниеИсточникиДанных, ЗапретитьВыбиратьСсылочныеОбъекты, ТолькоИспользованиеПолнотекстовогоПоиска,
		ОтображатьПеречисления, ОтображатьОбработки, ОтображатьОтчеты, ОтображатьПерерасчеты, МножественныйВыбор, ОтображатьРегламентныеЗадания, ОтображатьСетевыеСервисы, ОтображатьРоли);
	Форма = ПолучитьФормуВыбораОбъектаМетаданныхСтруктуройЛкс(ВладелецФормы, КлючУникальности, НачальноеЗначениеВыбора, лСтруктураПараметров, Фильтр);
	Возврат Форма;
	
КонецФункции

Функция ПолучитьФормуВыбораОбъектаМетаданныхСтруктуройЛкс(Знач ВладелецФормы, Знач КлючУникальности, Знач НачальноеЗначениеВыбора, Знач лСтруктураПараметров, Знач Фильтр = "") Экспорт 
	
	Форма = ирКэш.Получить().ПолучитьФорму("ВыборОбъектаМетаданных", ВладелецФормы, КлючУникальности);
	лСтруктураПараметров.Вставить("НачальноеЗначениеВыбора", НачальноеЗначениеВыбора);
	лСтруктураПараметров.Вставить("Фильтр", Фильтр);
	Форма.НачальноеЗначениеВыбора = лСтруктураПараметров;
	Возврат Форма;

КонецФункции

Функция ФормаВыбораКолонокБДЛкс(Знач ВладелецФормы, Знач НачальноеЗначениеВыбора = Неопределено, Знач Отбор = Неопределено, Знач МножественныйВыбор = Ложь, Знач КлючУникальности = Неопределено) Экспорт 
	
	Форма = ПолучитьФормуЛкс("Обработка.ирКолонкиБД.Форма",, ВладелецФормы, КлючУникальности);
	Форма.РежимВыбора = Истина;
	Форма.ПараметрОтбор = Отбор;
	Форма.МножественныйВыбор = МножественныйВыбор;
	Форма.НачальноеЗначениеВыбора = НачальноеЗначениеВыбора;
	Возврат Форма;

КонецФункции

Функция ФормаСтруктурыХраненияТаблицыБДЛкс() Экспорт 
	
	СтруктураХраненияСРазмерами = ирОбщий.СтруктураХраненияБДСРазмерамиЛкс();
	СтруктураХраненияСРазмерами.ОбщаяТаблицаИндексов = Ложь; // Так быстрее 
	СтруктураХраненияСРазмерами.ОбщаяТаблицаПолей = Ложь; // Так быстрее 
	Форма = СтруктураХраненияСРазмерами.ПолучитьФорму(,, "ПоОбъекту");
	//Форма.ПараметрПоказыватьSDBL = Истина;
	//Форма.ПараметрПоказыватьСУБД = Истина;
	Если Форма.Открыта() Тогда
		Форма.Закрыть();
	КонецЕсли; 
	Возврат Форма;

КонецФункции

Функция ПараметрыВыбораОбъектаМетаданныхЛкс(ОтображатьСсылочныеОбъекты = Ложь, ОтображатьВыборочныеТаблицы = Ложь, ОтображатьРегистры = Ложь, ОтображатьПоследовательности = Ложь,
	ОтображатьКонстанты = Ложь, ОтображатьТабличныеЧасти = Ложь, ОтображатьТаблицыИзменений = Ложь, ОтображатьВнешниеИсточникиДанных = Ложь, ЗапретитьВыбиратьСсылочныеОбъекты = Ложь,
	ТолькоИспользованиеПолнотекстовогоПоиска = Ложь, ОтображатьПеречисления = Ложь, ОтображатьОбработки = Ложь, ОтображатьОтчеты = Ложь, ОтображатьПерерасчеты = Ложь, МножественныйВыбор = Ложь,
	ОтображатьРегламентныеЗадания = Ложь, ОтображатьСетевыеСервисы = Ложь, ОтображатьРоли = Ложь, ОтображатьПодсистемы = Ложь, ОтображатьВиртуальныеТаблицы = Ложь) Экспорт 
	
	Параметры = Новый Структура;
	Параметры.Вставить("ОтображатьКонстанты", ОтображатьКонстанты);
	Параметры.Вставить("ОтображатьВыборочныеТаблицы", ОтображатьВыборочныеТаблицы);
	Параметры.Вставить("ОтображатьТаблицыИзменений", ОтображатьТаблицыИзменений);
	Параметры.Вставить("ОтображатьТабличныеЧасти", ОтображатьТабличныеЧасти);
	Параметры.Вставить("ОтображатьРегистры", ОтображатьРегистры);
	Параметры.Вставить("ОтображатьПерерасчеты", ОтображатьПерерасчеты);
	Параметры.Вставить("ОтображатьПоследовательности", ОтображатьПоследовательности);
	Параметры.Вставить("ОтображатьСсылочныеОбъекты", ОтображатьСсылочныеОбъекты);
	Параметры.Вставить("ОтображатьВнешниеИсточникиДанных", ОтображатьВнешниеИсточникиДанных);
	Параметры.Вставить("ОтображатьПеречисления", ОтображатьПеречисления);
	Параметры.Вставить("ОтображатьОбработки", ОтображатьОбработки);
	Параметры.Вставить("ОтображатьОтчеты", ОтображатьОтчеты);
	Параметры.Вставить("ТолькоИспользованиеПолнотекстовогоПоиска", ТолькоИспользованиеПолнотекстовогоПоиска);
	Параметры.Вставить("ЗапретитьВыбиратьСсылочныеОбъекты", ЗапретитьВыбиратьСсылочныеОбъекты);
	Параметры.Вставить("МножественныйВыбор", МножественныйВыбор);
	Параметры.Вставить("ОтображатьРегламентныеЗадания", ОтображатьРегламентныеЗадания);
	Параметры.Вставить("ОтображатьСетевыеСервисы", ОтображатьСетевыеСервисы);
	Параметры.Вставить("ОтображатьРоли", ОтображатьРоли);
	Параметры.Вставить("ОтображатьПодсистемы", ОтображатьПодсистемы);
	Параметры.Вставить("ОтображатьВиртуальныеТаблицы", ОтображатьВиртуальныеТаблицы);
	Возврат Параметры;
	
КонецФункции

Процедура ОбъектМетаданныхНачалоВыбораЛкс(Знач Элемент, Знач ПараметрыВыбораОбъектаМетаданных, СтандартнаяОбработка) Экспорт 
	
	СтандартнаяОбработка = Ложь;
	ФормаВыбора = ПолучитьФормуВыбораОбъектаМетаданныхСтруктуройЛкс(,, ирОбщий.ДанныеЭлементаФормыЛкс(Элемент), ПараметрыВыбораОбъектаМетаданных);
	РезультатВыбора = ФормаВыбора.ОткрытьМодально();
	Если РезультатВыбора <> Неопределено Тогда
		ИнтерактивноЗаписатьВПолеВводаЛкс(Элемент, РезультатВыбора.ПолноеИмяОбъекта);
	КонецЕсли;

КонецПроцедуры

Процедура ОбъектМетаданныхОкончаниеВводаТекстаЛкс(Знач Элемент, Знач ПараметрыВыбораОбъектаМетаданных, Текст, Значение, СтандартнаяОбработка) Экспорт 
	
	Если ЗначениеЗаполнено(Текст) Тогда
		СтандартнаяОбработка = Ложь;
		Значение = Новый СписокЗначений;
		Если ирОбщий.ЛиТаблицаБДСуществуетЛкс(Текст) Тогда
			Значение.Добавить(Текст);
		Иначе
			ФормаВыбора = ПолучитьФормуВыбораОбъектаМетаданныхСтруктуройЛкс(Элемент,, ирОбщий.ДанныеЭлементаФормыЛкс(Элемент), ПараметрыВыбораОбъектаМетаданных, Текст);
			РезультатВыбора = ФормаВыбора.ОткрытьМодально();
			Если РезультатВыбора <> Неопределено Тогда 
				Значение.Добавить(РезультатВыбора.ПолноеИмяОбъекта);
			КонецЕсли; 
		КонецЕсли; 
	КонецЕсли;

КонецПроцедуры

Функция ПолучитьФормуВыбораТаблицыСтруктурыБДЛкс(ЛиИменаБД, ИмяТаблицыХранения = "") Экспорт 
	
	Форма = ПолучитьФормуЛкс("Обработка.ирСтруктураХраненияБД.Форма",,, Истина);
	Форма.РежимВыбора = Истина;
	Форма.ПараметрИмяТаблицыХранения = ИмяТаблицыХранения;
	Форма.ПараметрПоказыватьSDBL = Не ЛиИменаБД;
	Форма.ПараметрПоказыватьСУБД = ЛиИменаБД;
	Возврат Форма

КонецФункции

Функция РедактироватьАлгоритмЧерезСтрокуXMLЛкс(СтрокаXMLАлгоритма, ВнешниеПараметры = Неопределено, НаСервере = Ложь, ИмяАлгоритма = "", Знач ТекстНового = "") Экспорт
	
	СтруктураАлгоритма = ирОбщий.ОбъектИзСтрокиXMLЛкс(СтрокаXMLАлгоритма);
	Результат = РедактироватьАлгоритмЧерезСтруктуруЛкс(СтруктураАлгоритма, ВнешниеПараметры,, НаСервере, ИмяАлгоритма, ТекстНового);
	Если Результат Тогда
		Если СтруктураАлгоритма = Неопределено Тогда
			СтрокаXMLАлгоритма = "";
		Иначе
			СтрокаXMLАлгоритма = ирОбщий.ОбъектВСтрокуXMLЛкс(СтруктураАлгоритма);
		КонецЕсли;
	КонецЕсли;
	Возврат Результат;

КонецФункции

// Открыть редактирование текста алгоритма с параметрами в консоли кода
// Парамерты:
//   СтруктураАлгоритма - Структура - возвращаемый
//      "ТекстАлгоритма" - Строка - текст алгоритма,
//      "ВнутренниеПараметры" - ТаблицаЗначений - таблица с конструктором НоваяТаблицаПараметровАлгоритмаЛкс с внутренними (значения определяются при редактировании) параметрами алгоритма;
//   ВнешниеПараметры* - ТаблицаЗначений - таблица с конструктором НоваяТаблицаПараметровАлгоритмаЛкс с внешними (значения определяются при каждом выполнении) параметрами алгоритма;
//   Методы* - ТаблицаЗначений - таблица с конструктором НоваяТаблицаМетодовПодсказкиЛкс с дополнительными методами доступными в алгоритме;
// Результат - Булево - принял ли изменения пользователь
Функция РедактироватьАлгоритмЧерезСтруктуруЛкс(СтруктураАлгоритма, ВнешниеПараметры = Неопределено, Методы = Неопределено, НаСервере = Ложь, ИмяАлгоритма = "", Знач ТекстНового = "") Экспорт 
	
	#Если Сервер И Не Сервер Тогда
		ВнешниеПараметры = Новый ТаблицаЗначений;
	#КонецЕсли
	мПлатформа = ирКэш.Получить();
	#Если Сервер И Не Сервер Тогда
	    мПлатформа = Обработки.ирПлатформа.Создать();
	#КонецЕсли
	ОбработкаКонсольКода = ирОбщий.СоздатьОбъектПоИмениМетаданныхЛкс("Обработка.ирКонсольКода");
	ФормаКонсоли = ОбработкаКонсольКода.ПолучитьФорму();
	Если ВнешниеПараметры <> Неопределено Тогда
		КопияПараметров = ВнешниеПараметры.Скопировать();
		Если КопияПараметров.Колонки.Найти("ТаблицаСтруктурТипов") = Неопределено Тогда
			КопияПараметров.Колонки.Добавить("ТаблицаСтруктурТипов");
		КонецЕсли; 
		Если КопияПараметров.Колонки.Найти("Значение") = Неопределено Тогда
			КопияПараметров.Колонки.Добавить("Значение");
		КонецЕсли; 
		Если КопияПараметров.Колонки.Найти("Фиксированный") = Неопределено Тогда
			КопияПараметров.Колонки.Добавить("Фиксированный");
		КонецЕсли; 
		Для Каждого СтрокаПараметра Из КопияПараметров Цикл
			Если Истина
				И ТипЗнч(СтрокаПараметра.ТипЗначения) = Тип("ОписаниеТипов") 
				И СтрокаПараметра.ТаблицаСтруктурТипов = Неопределено
			Тогда
				СтрокаПараметра.ТаблицаСтруктурТипов = мПлатформа.ТаблицаСтруктурТиповИзОписанияТипов(СтрокаПараметра.ТипЗначения);
			КонецЕсли; 
		КонецЦикла;
		КопияПараметров.ЗаполнитьЗначения(Истина, "Фиксированный");
		ФормаКонсоли.мСписокВнешнихПараметров = КопияПараметров;
	КонецЕсли; 
	Если СтруктураАлгоритма <> Неопределено Тогда
		Если СтруктураАлгоритма.Свойство("ТекстАлгоритма") Тогда
			ФормаКонсоли.ПараметрТекст = СтруктураАлгоритма.ТекстАлгоритма;
		КонецЕсли; 
		Если СтруктураАлгоритма.Свойство("ВнутренниеПараметры") Тогда
			ирОбщий.ЗагрузитьВТаблицуЗначенийЛкс(СтруктураАлгоритма.ВнутренниеПараметры, КопияПараметров, Новый Структура("Вход", Истина));
		КонецЕсли; 
	Иначе
		ФормаКонсоли.ПараметрТекст = ТекстНового;
	КонецЕсли; 
	ФормаКонсоли.ПараметрНаСервере = НаСервере;
	ФормаКонсоли.мМетоды = Методы;
	ФормаКонсоли.мРежимРедактора = Истина;
	ФормаКонсоли.мИмяАлгоритмаДляРедактора = ИмяАлгоритма;
	ФормаКонсоли.ОткрытьМодально();
	РезультатФормы = ФормаКонсоли.РезультатФормы;
	Результат = РезультатФормы <> Неопределено;
	Если Результат Тогда
		ВнутренниеПараметры = РезультатФормы.Параметры.Скопировать(Новый Структура("Вход, Фиксированный", Истина, Ложь), "Имя, Значение");
		Если Истина
			И ВнутренниеПараметры.Количество() = 0
			И Не ЗначениеЗаполнено(РезультатФормы.Текст)
		Тогда
			СтруктураАлгоритма = Неопределено;
		Иначе
			СтруктураАлгоритма = Новый Структура("ТекстАлгоритма, ВнутренниеПараметры", РезультатФормы.Текст, ВнутренниеПараметры);
		КонецЕсли;
	КонецЕсли;
	Возврат Результат;

КонецФункции

// Конструктор таблицы параметров алгоритма
// Результат - ТаблицаЗначений - колонки "Имя, Значение, Вход, Выход, ТипЗначения, Комментарий"
Функция НоваяТаблицаПараметровАлгоритмаЛкс() Экспорт
	
	Результат = Новый ТаблицаЗначений;
	Результат.Колонки.Добавить("Имя", Новый ОписаниеТипов("Строка"));
	Результат.Колонки.Добавить("Значение");
	Результат.Колонки.Добавить("Вход", Новый ОписаниеТипов("Булево"));
	Результат.Колонки.Добавить("Выход", Новый ОписаниеТипов("Булево"));
	Результат.Колонки.Добавить("ТипЗначения", Новый ОписаниеТипов("ОписаниеТипов"));
	Результат.Колонки.Добавить("Комментарий", Новый ОписаниеТипов("Строка"));
	Результат.Колонки.Добавить("ТаблицаСтруктурТипов");
	Возврат Результат;

КонецФункции

// Конструктор таблицы методов контекстной подсказки
// Результат - ТаблицаЗначений - колонки "Имя, ТипЗначения"
Функция НоваяТаблицаМетодовПодсказкиЛкс() Экспорт
	
	Результат = Новый ТаблицаЗначений;
	Результат.Колонки.Добавить("Имя", Новый ОписаниеТипов("Строка"));
	Результат.Колонки.Добавить("ТипЗначения", Новый ОписаниеТипов("ОписаниеТипов"));
	Результат.Колонки.Добавить("ТаблицаСтруктурТипов");
	Возврат Результат;

КонецФункции

Функция СтрокаСобытияАлгоритмНачалоВыбораЛкс(Знач СтрокаСобытия, НаСервере = Ложь) Экспорт 
	
	АлгоритмИзменен = РедактироватьАлгоритмЧерезСтрокуXMLЛкс(СтрокаСобытия.Алгоритм, СтрокаСобытия.Параметры, НаСервере, СтрокаСобытия.СинонимСобытия);
	Если СтрокаСобытия.Параметры.Колонки.Найти("Значение") <> Неопределено Тогда
		СтрокаСобытия.Параметры.ЗаполнитьЗначения(, "Значение");
	КонецЕсли; 
	Если СтрокаСобытия.Владелец().Колонки.Найти("АлгоритмОбъект") <> Неопределено Тогда
		СтрокаСобытия.АлгоритмОбъект = Неопределено;
	КонецЕсли; 
	Если СтрокаСобытия.Владелец().Колонки.Найти("ТаблицаСтруктурТипов") <> Неопределено Тогда
		СтрокаСобытия.Параметры.ЗаполнитьЗначения(Неопределено, "ТаблицаСтруктурТипов");
	КонецЕсли; 
	Возврат АлгоритмИзменен;

КонецФункции

Процедура ОформитьЯчейкуАлгоритмаВТабличномПолеЛкс(Знач ОформлениеСтроки, ИмяКолонки = "Алгоритм", ОтображатьКартинку = Ложь) Экспорт 
	
	Если ЗначениеЗаполнено(ОформлениеСтроки.ДанныеСтроки[ИмяКолонки]) Тогда
		СтруктураАлгоритма = ирОбщий.ОбъектИзСтрокиXMLЛкс(ОформлениеСтроки.ДанныеСтроки[ИмяКолонки],,, Ложь);
		Если СтруктураАлгоритма <> Неопределено И СтруктураАлгоритма.Свойство("ТекстАлгоритма") Тогда
			ОформлениеСтроки.Ячейки[ИмяКолонки].УстановитьТекст(СокрП(СтруктураАлгоритма.ТекстАлгоритма));
		КонецЕсли; 
	КонецЕсли;
	Если ОтображатьКартинку Тогда
		ОформлениеСтроки.Ячейки[ИмяКолонки].УстановитьКартинку(ирКэш.КартинкаПоИмениЛкс("ирАлгоритм"));
	КонецЕсли; 

КонецПроцедуры

// ИсторияФайлов - СписокЗначений
// Кнопки - КнопкиКоманднойПанели
Процедура ОбновитьПодменюИсторииФайловЛкс(ИсторияФайлов, Кнопки, ИмяДействия = "ОткрытьФайлИзИстории") Экспорт
	
	Кнопки.Очистить();
	ДлинаПредставления = 100;
	ДействиеКнопки = Новый Действие(ИмяДействия);
	Для Каждого СтрокаФайла Из ИсторияФайлов Цикл
		Файл = Новый Файл(СтрокаФайла.Значение);
		ДлинаПути = ДлинаПредставления - СтрДлина(Файл.Имя);
		Представление = Лев(Файл.Имя, ДлинаПредставления);
		Если ДлинаПути > 0 Тогда
			Если ДлинаПути < СтрДлина(Файл.Путь) + 3 Тогда
				Представление = Лев(Файл.Путь, ДлинаПути) + "…\" + Представление;
			Иначе
				Представление = Файл.Путь + Представление;
			КонецЕсли; 
		КонецЕсли; 
		КнопкаФайла = Кнопки.Добавить("_" + Формат(ИсторияФайлов.Индекс(СтрокаФайла), "ЧГ=;ЧН="), ТипКнопкиКоманднойПанели.Действие, Представление, ДействиеКнопки);
	КонецЦикла;
	
КонецПроцедуры

Процедура ДобавитьФайлВИсториюФормыЛкс(СписокИстории, ЗначениеЭлемента, РазмерИстории = 20) Экспорт
	
	ЭлементИстории = СписокИстории.НайтиПоЗначению(ЗначениеЭлемента);
	Если ЭлементИстории <> Неопределено Тогда
		СписокИстории.Удалить(ЭлементИстории);
	КонецЕсли; 
	СписокИстории.Вставить(0, ЗначениеЭлемента);
	Пока СписокИстории.Количество() > РазмерИстории Цикл
		СписокИстории.Удалить(РазмерИстории);
	КонецЦикла;
	
КонецПроцедуры

Процедура УстановитьДоступностьПодменюЛкс(Знач Подменю, НоваяДоступность = Ложь) Экспорт 
	
	Для Каждого Кнопка Из Подменю.Кнопки Цикл
		Кнопка.Доступность = НоваяДоступность;
	КонецЦикла;

КонецПроцедуры

// Процедура - Текст в буфер обмена ОСЛкс
// Для ВариантПросмотра = "ВстроенныйЯзык" или ВариантПросмотра = "ЯзыкЗапросов" не помещает текст в буфер обмена, а только открывает окно с тектом
//
// Параметры:
//  Значение		 - Текст - 
//  ВариантПросмотра - Текст - см ОткрытьТекстЛкс()
//
Процедура ТекстВБуферОбменаОСЛкс(Знач Значение, ВариантПросмотра = "ВстроенныйЯзык") Экспорт
	
	Если Ложь
		Или ВариантПросмотра = "ВстроенныйЯзык"
		//ИЛи ВариантПросмотра = "ЯзыкЗапросов"
	Тогда 
	    ОткрытьТекстЛкс(Значение,, ВариантПросмотра,,,, Истина);
	Иначе
		// http://partners.v8.1c.ru/forum/thread.jsp?id=1075241#1075241
		Попытка
			//Документ = ирКэш.Получить().СлужебноеПолеHtmlДокумента.Документ; // Так выбрасывается исключение после нескольких вызовов и сразу на 8.3.14+
			Документ = Новый COMОбъект("HTMLFILE"); // 10мс
			Окно = Документ.parentWindow;
			Окно.ClipboardData.SetData("text", Значение);  // Другие форматы не поддерживаются
		Исключение
			ОписаниеОшибки = ОписаниеОшибки(); // Для отладки
		КонецПопытки;
		Если ТекстИзБуфераОбменаОСЛкс() <> Значение Тогда
			ОткрытьТекстЛкс(Значение,, ВариантПросмотра,,,, Истина);
		КонецЕсли; 
	КонецЕсли;
	
Конецпроцедуры

Функция ТекстИзБуфераОбменаОСЛкс(выхЗначение = Неопределено) Экспорт
	
	// http://partners.v8.1c.ru/forum/thread.jsp?id=1075241#1075241
	Попытка
		//Документ = ирКэш.Получить().СлужебноеПолеHtmlДокумента.Документ; // Так выбрасывается исключение после нескольких вызовов и сразу на 8.3.14+
		Документ = Новый COMОбъект("HTMLFILE"); // 10мс
		Окно = Документ.parentWindow;
		Результат = "" + Окно.ClipboardData.GetData("text"); // Похоже здесь может вернуться не строка
	Исключение
		ОписаниеОшибки = ОписаниеОшибки(); // Для отладки
		Результат = "";
	КонецПопытки; 
	Возврат Результат;
	
КонецФункции

Функция ЛиЕстьИнтерактивныйДоступКИнструментамЛкс() Экспорт 
	Возврат ПравоДоступа("Просмотр", Метаданные.Подсистемы.ИнструментыРазработчикаTormozit);
КонецФункции

// .
// Параметры:
//   Отбор - Структура, Отбор, *Неопределено - фиксированный отбор
//   ИспользоватьДинамическийСписокИР - Булево, "Обычная" 
Функция ОткрытьФормуСпискаЛкс(ИмяТаблицыИлиМДИлиТип, ФиксОтбор = Неопределено, ИспользоватьДинамическийСписокИР = Неопределено, ВладелецФормы = Неопределено, РежимВыбора = Ложь,
	МножественныйВыбор = Ложь, ТекущаяСтрока = Неопределено, Модально = Ложь, ПользовательскийОтбор = Неопределено, ТекущаяКолонка = Неопределено, Знач КлючУникальности = Неопределено) Экспорт
	
	ФормаСписка = ПолучитьФормуСпискаЛкс(ИмяТаблицыИлиМДИлиТип, ФиксОтбор, ИспользоватьДинамическийСписокИР, ВладелецФормы, РежимВыбора, МножественныйВыбор, ТекущаяСтрока, ПользовательскийОтбор,
		КлючУникальности, ТекущаяКолонка);
	Если ФормаСписка = Неопределено Тогда
		Возврат Неопределено;
	КонецЕсли; 
	Если Модально Тогда
		Если ФормаСписка.Открыта() Тогда
			ФормаСписка = ПолучитьФормуСпискаЛкс(ИмяТаблицыИлиМДИлиТип, ФиксОтбор, ИспользоватьДинамическийСписокИР, ВладелецФормы, РежимВыбора, МножественныйВыбор, ТекущаяСтрока, ПользовательскийОтбор,
				Новый УникальныйИдентификатор, ТекущаяКолонка);
		КонецЕсли; 
		Результат = ФормаСписка.ОткрытьМодально();
		Возврат Результат;
	Иначе
		ФормаСписка.Открыть();
		Возврат ФормаСписка;
	КонецЕсли; 

КонецФункции

// .
// Параметры:
//   Отбор - Структура, Отбор, *Неопределено
//   ИспользоватьДинамическийСписокИР - Булево, "Обычная" 
Функция ПолучитьФормуСпискаЛкс(Знач ИмяТаблицыИлиМДИлиТип, Знач ФиксОтбор = Неопределено, Знач ИспользоватьДинамическийСписокИР = Неопределено, Знач ВладелецФормы = Неопределено, Знач РежимВыбора = Ложь,
	Знач МножественныйВыбор = Ложь, Знач ТекущаяСтрока = Неопределено, Знач ПользовательскийОтбор = Неопределено, Знач КлючУникальности = Неопределено, Знач ТекущаяКолонка = Неопределено) Экспорт
	
	мПлатформа = ирКэш.Получить();
	Если ТипЗнч(ИмяТаблицыИлиМДИлиТип) = Тип("ОбъектМетаданных") Тогда
		ИмяТаблицы = ИмяТаблицыИлиМДИлиТип.ПолноеИмя();
	ИначеЕсли ТипЗнч(ИмяТаблицыИлиМДИлиТип) = Тип("Тип") Тогда
		ИмяТаблицы = ирОбщий.ПолучитьПолноеИмяМДТипаЛкс(ИмяТаблицыИлиМДИлиТип);
	Иначе
		ИмяТаблицы = ИмяТаблицыИлиМДИлиТип;
	КонецЕсли; 
	ТипТаблицы = ирОбщий.ТипТаблицыБДЛкс(ИмяТаблицы);
	//МассивФрагментов = ирОбщий.СтрРазделитьЛкс(ПолноеИмяМД);
	ТаблицеНедоступенОбычныйДинамическийСписок = Ложь
		Или ирОбщий.ЛиТипВложеннойТаблицыБДЛкс(ТипТаблицы)
		Или ТипТаблицы = "Изменения"
		Или ТипТаблицы = "Перерасчет"
		//Или ТипТаблицы = "Точки" // В обычной форме динамического списка ИР эмулируется через таблицу значений
		Или ТипТаблицы = "Внешняя" 
		Или ТипТаблицы = "ВиртуальнаяТаблица";
	Если Истина
		И ирКэш.ЛиПортативныйРежимЛкс()
		И Не ирКэш.ЛиСеансТолстогоКлиентаУПЛкс() 
		И ТаблицеНедоступенОбычныйДинамическийСписок
	Тогда
		ирОбщий.СообщитьЛкс(ирОбщий.СтрШаблонИменЛкс("Для таблицы %1 динамический список в режиме обычного приложения не предусмотрен",, ИмяТаблицы));
		ФормаСписка = ПолучитьФормуЛкс("Обработка.ирПодборИОбработкаОбъектов.Форма",,, ИмяТаблицы);
		Возврат ФормаСписка;
	КонецЕсли;
	Если ИспользоватьДинамическийСписокИР = Неопределено Тогда
		ИспользоватьДинамическийСписокИР = ирОбщий.ИспользованиеДинамическогоСпискаВместоОсновнойФормыЛкс(ИмяТаблицы);
	КонецЕсли; 
	Если Ложь
		Или ТаблицеНедоступенОбычныйДинамическийСписок
		Или (Истина
			// Потому что у форм списков регистров режим выбора можно включить только через основной элемент управления
			И РежимВыбора = Истина
			И ирОбщий.ЛиКорневойТипРегистраБДЛкс(ТипТаблицы))
	Тогда
		ИспользоватьДинамическийСписокИР = Истина;
	КонецЕсли; 
	Если ИспользоватьДинамическийСписокИР = Неопределено Тогда
		Ответ = Вопрос("Хотите использовать Динамический список (ИР)?", РежимДиалогаВопрос.ДаНет, , КодВозвратаДиалога.Нет);
		ИспользоватьДинамическийСписокИР = Ответ = КодВозвратаДиалога.Да;
	КонецЕсли; 
	Если ПользовательскийОтбор <> Неопределено Тогда
		ПользовательскиеНастройки = Новый ПользовательскиеНастройкиКомпоновкиДанных;
		ПользовательскийОтборКомпоновки = ПользовательскиеНастройки.Элементы.Добавить(Тип("ОтборКомпоновкиДанных"));
		Если ТипЗнч(ПользовательскийОтбор) = Тип("Отбор") Тогда
			Для Каждого ЭлементОтбора Из ПользовательскийОтбор Цикл
				Если ЭлементОтбора.Использование Тогда 
					СтрокаВидаСравнения = мПлатформа.СоответствиеВидовСравнения.Найти(ЭлементОтбора.ВидСравнения, "Построитель");
					Если СтрокаВидаСравнения = Неопределено Тогда
						// %%%% Здесь можно добавить интеллекта
						Продолжить;
					КонецЕсли;
					ЭлементОтбора = ирОбщий.НайтиДобавитьЭлементОтбораКомпоновкиЛкс(ПользовательскийОтборКомпоновки, ЭлементОтбора.Имя, ЭлементОтбора.Значение, СтрокаВидаСравнения.Компоновка);
					ирОбщий.ПроверитьВключитьЭлементНастроекКомпоновкиВПользовательскиеНастройки(ЭлементОтбора);
				КонецЕсли; 
			КонецЦикла;
		Иначе
			ирОбщий.СкопироватьОтборЛюбойЛкс(ПользовательскийОтборКомпоновки, ПользовательскийОтбор);
		КонецЕсли; 
		// Важно: установка идентификатора должна выполняться в конце настройки элемента,
		// иначе он будет скопирован в пользовательские настройки частично заполненным.
		// Идентификатор установлен экспериментально https://partners.v8.1c.ru/forum/t/1644571/m/1644571, также подтвержден тут http://forum.infostart.ru/forum9/topic163501/message2246750/#message2246750
		ирОбщий.ПроверитьВключитьЭлементНастроекКомпоновкиВПользовательскиеНастройки(ПользовательскийОтборКомпоновки, "dfcece9d-5077-440b-b6b3-45a5cb4538eb");
	КонецЕсли; 
	Если ТипЗнч(ФиксОтбор) = Тип("Отбор") Тогда
		СтруктураОтбора = Новый Структура;
		Для Каждого ЭлементОтбора Из ФиксОтбор Цикл
			Если ЭлементОтбора.Использование Тогда 
				Если ЭлементОтбора.ВидСравнения = ВидСравнения.Равно Тогда
					СтруктураОтбора.Вставить(ЭлементОтбора.Имя, ЭлементОтбора.Значение);
				КонецЕсли; 
			КонецЕсли; 
		КонецЦикла;
	Иначе
		СтруктураОтбора = ФиксОтбор;
	КонецЕсли; 
	ПараметрыФормы = Новый Структура("РежимВыбора, МножественныйВыбор, ЗакрыватьПриВыборе, ТекущаяСтрока, Отбор, ПользовательскиеНастройки, ТекущаяКолонка", 
		РежимВыбора, МножественныйВыбор, Не МножественныйВыбор, ТекущаяСтрока, СтруктураОтбора, ПользовательскиеНастройки, ТекущаяКолонка);
	МожноИспользоватьДинамическийСписокИР = Истина;
	#Если ТолстыйКлиентОбычноеПриложение Тогда
	МожноИспользоватьДинамическийСписокИР = Ложь
		Или Не ТаблицеНедоступенОбычныйДинамическийСписок
		Или Не ирКэш.ЛиПортативныйРежимЛкс();
	#КонецЕсли  
	Если Истина
		И ИспользоватьДинамическийСписокИР <> Ложь 
		И МожноИспользоватьДинамическийСписокИР
	Тогда
		КлючУникальности = ирОбщий.КлючУникальностиДинамическогоСпискаЛкс(ИмяТаблицы, КлючУникальности);
		ПараметрыФормы.Вставить("ИмяТаблицы", ИмяТаблицы);
		//Если Не РежимВыбора Тогда
		//	КлючУникальности = Новый УникальныйИдентификатор;
		//КонецЕсли; 
		Если ТаблицеНедоступенОбычныйДинамическийСписок Тогда
			ТипФормы = "Управляемая";
		ИначеЕсли ИспользоватьДинамическийСписокИР = "Обычная" Тогда 
			ТипФормы = "Обычная";
		Иначе
			ТипФормы = Неопределено;
		КонецЕсли;
		Попытка
			ФормаСписка = ФормаДинамическогоСпискаЛкс(ПараметрыФормы, ВладелецФормы, КлючУникальности, ТипФормы);
			Если ТипЗнч(ФормаСписка) = Тип("Форма") Тогда
				ФормаСписка.РежимВыбора = РежимВыбора; // Чтобы заголовок сразу правильный сформировался
				ФормаСписка.УстановитьОбъектМетаданных(ИмяТаблицы);
				//Попытка
				//	ФормаСписка.ПараметрВыборГруппИЭлементов = ИспользованиеГруппИЭлементов.ГруппыИЭлементы; // Такого параметра у этой формы нет
				//Исключение
				//КонецПопытки;
			КонецЕсли;
		Исключение
			ирОбщий.СообщитьЛкс("Ошибка динамического списка ИР: " + ОписаниеОшибки());
			ФормаСписка = ПолучитьФормуСпискаЛкс(ИмяТаблицыИлиМДИлиТип, ФиксОтбор, Ложь, ВладелецФормы, РежимВыбора, МножественныйВыбор, ТекущаяСтрока, ПользовательскийОтбор, КлючУникальности, ТекущаяКолонка);
			Возврат ФормаСписка;
		КонецПопытки;
		ОтборДинамическогоСписка = ФормаСписка.Отбор();
		ПользовательскийОтборДинамическогоСписка = ФормаСписка.ПользовательскийОтбор();
	Иначе
		Если РежимВыбора Тогда
			Попытка
				ФормаСписка = ПолучитьФормуЛкс(ИмяТаблицы + ".ФормаВыбора", ПараметрыФормы, ВладелецФормы, КлючУникальности); 
			Исключение
				// Например у регистров нет форм выбора
			КонецПопытки;
		КонецЕсли; 
		Если ФормаСписка = Неопределено Тогда
			ФормаСписка = ПолучитьФормуЛкс(ИмяТаблицы + ".ФормаСписка", ПараметрыФормы, ВладелецФормы, КлючУникальности); 
		КонецЕсли; 
		Если ТипЗнч(ФормаСписка) = Тип("Форма") Тогда
			Попытка
				ОтборДинамическогоСписка = ФормаСписка.Отбор;
			Исключение
			КонецПопытки; 
			ПользовательскийОтборДинамическогоСписка = ОтборДинамическогоСписка;
		КонецЕсли; 
	КонецЕсли; 
	Если ТипЗнч(ФормаСписка) = Тип("Форма") Тогда
		ФормаСписка.РежимВыбора = РежимВыбора;
		ФормаСписка.ЗакрыватьПриВыборе = Не МножественныйВыбор;
		ФормаСписка.НачальноеЗначениеВыбора = ТекущаяСтрока;
		Попытка
			ФормаСписка.МножественныйВыбор = МножественныйВыбор;
		Исключение
			// Есть не у всех форм
		КонецПопытки;
		Попытка
			ФормаСписка.ПараметрТекущаяСтрока = ТекущаяСтрока;
		Исключение
			// Есть не у всех форм
		КонецПопытки;
		Попытка
			ФормаСписка.ПараметрТекущаяКолонка = ТекущаяКолонка;
		Исключение
			// Есть не у всех форм
		КонецПопытки;
	КонецЕсли; 
	Если Истина
		И ОтборДинамическогоСписка <> Неопределено 
		И ФиксОтбор <> Неопределено
	Тогда
		ирОбщий.СкопироватьОтборЛюбойЛкс(ОтборДинамическогоСписка, ФиксОтбор,, Истина);
	КонецЕсли;
	Если Истина
		И ПользовательскийОтборДинамическогоСписка <> Неопределено 
		И ПользовательскийОтбор <> Неопределено
	Тогда
		ирОбщий.СкопироватьОтборЛюбойЛкс(ПользовательскийОтборДинамическогоСписка, ПользовательскийОтбор);
	КонецЕсли;
	Возврат ФормаСписка;

КонецФункции

Функция ФормаДинамическогоСпискаЛкс(ПараметрыФормы = Неопределено, ВладелецФормы = Неопределено, КлючУникальности = Неопределено, Знач ТипФормы = Неопределено) Экспорт 
	
	ИмяФормы = "Обработка.ирДинамическийСписок.Форма";
	Если Истина
		И Не ирКэш.ЛиПортативныйРежимЛкс() 
		И (Ложь
			Или ТипФормы = "Управляемая"
			Или ТипФормы = Неопределено И Не ирКэш.Получить().НеИспользоватьУправляемыеФормыИнструментов)
	Тогда
		ИмяФормы = ИмяФормы + ".ФормаУпр";
	Иначе
		ИмяФормы = ИмяФормы + ".Форма";
	КонецЕсли;
	Если ПараметрыФормы = Неопределено Тогда
		ПараметрыФормы = Новый Структура;
	КонецЕсли;
	ПараметрыФормы.Вставить("КлючУникальности", КлючУникальности);
	ФормаСписка = ПолучитьФормуЛкс(ИмяФормы, ПараметрыФормы, ВладелецФормы, КлючУникальности);
	Возврат ФормаСписка;

КонецФункции

Процедура ПолеФайловогоКаталога_НачалоВыбораЛкс(Элемент, СтандартнаяОбработка) Экспорт 
	
	СтандартнаяОбработка = Ложь;
	ВыборФайла = Новый ДиалогВыбораФайла(РежимДиалогаВыбораФайла.ВыборКаталога);
	ВыборФайла.Каталог = Элемент.Значение;
	Если Не ВыборФайла.Выбрать() Тогда
		Возврат;
	КонецЕсли;
	ИнтерактивноЗаписатьВПолеВводаЛкс(Элемент, ВыборФайла.Каталог);

КонецПроцедуры

Функция ОткрытьСсылкуВСпискеЛкс(Ссылка) Экспорт
	
	ПолноеИмяМД = Метаданные.НайтиПоТипу(ТипЗнч(Ссылка)).ПолноеИмя();
	СтруктураПараметры = Новый Структура;
	СтруктураПараметры.Вставить("ТекущаяСтрока", Ссылка);
	ФормаСписка = ПолучитьФормуЛкс(ПолноеИмяМД + ".ФормаСписка", СтруктураПараметры, , Новый УникальныйИдентификатор);
	ФормаСписка.Открыть();
	Возврат ФормаСписка;

КонецФункции

// ИменаКолонок - Строка - имена колонок через запятую
Процедура ТабличноеПолеОтобразитьФлажкиЛкс(ОформлениеСтроки, Знач ИменаКолонок) Экспорт

	Если ТипЗнч(ИменаКолонок) = Тип("Строка") Тогда
		ИменаКолонок = ирОбщий.СтрРазделитьЛкс(ИменаКолонок, ",", Истина); 
	КонецЕсли; 
	Для Каждого ИмяКолонки Из ИменаКолонок Цикл
		Ячейка = ОформлениеСтроки.Ячейки[ИмяКолонки];
		//Если Ячейка.ТолькоПросмотр Тогда
		//	Продолжить;
		//КонецЕсли;
		Если ТипЗнч(Ячейка.Значение) = Тип("Булево") Тогда
			Ячейка.УстановитьФлажок(Ячейка.Значение);
			Ячейка.УстановитьТекст("");
		КонецЕсли; 
	КонецЦикла;

КонецПроцедуры

Процедура ТабличноеПолеПриИзмененииФлажкаЛкс(Этаформа, ТабличноеПоле, Знач Колонка, Знач КнопкаРежимаОтбораПомеченных = Неопределено) Экспорт
	
	#Если Сервер И Не Сервер Тогда
		ТабличноеПоле = Новый ТабличноеПоле;
	#КонецЕсли
	Если ТипЗнч(Колонка.ЭлементУправления) = Тип("ПолеВвода") Тогда
		ОформлениеСтроки = ТабличноеПоле.ОформлениеСтроки(ТабличноеПоле.ТекущаяСтрока);
		Ячейка = ОформлениеСтроки.Ячейки[Колонка.Имя];
		Если Не Ячейка.ТолькоПросмотр Тогда
			Если Истина
				И Колонка.Данные = ""
				И Колонка.ДанныеФлажка = ""
			Тогда
				Колонка.ЭлементУправления.Значение = Не Ячейка.Значение;
				//ИнтерактивноЗаписатьВКолонкуТабличногоПоляЛкс(Элемент, Колонка, Не ОформлениеСтроки.Ячейки[Колонка.Имя].Значение);
			Иначе
				//МетаданныеТипа = глПолучитьМетаданныеТипа(ТипЗнч(Элемент.Значение), "ТипСписка", Истина);
				//РедактированиеВДиалоге = Ложь;
				//Если Истина 
				//	И МетаданныеТипа <> Неопределено
				//	И МетаданныеТипа.КлассМетаданных.Предок = оСсылочный
				//Тогда
				//	Попытка
				//		ВыбранныйСпособРедактирования = Элемент.СпособРедактирования;
				//	Исключение
				//	КонецПопытки;
				//	РедактированиеВДиалоге = ВыбранныйСпособРедактирования <> СпособРедактированияСписка.ВСписке;
				//КонецЕсли;
				//РазрешитьИзменение = Истина;
				//Если РедактированиеВДиалоге Тогда
				//Иначе
					//Элемент.ЗакончитьРедактированиеСтроки(Ложь);
					ТабличноеПоле.ИзменитьСтроку();
					ЗначениеЯчейки = Колонка.ЭлементУправления.Значение;
					Если ТипЗнч(ЗначениеЯчейки) = Тип("Булево") Тогда
						//ИнтерактивноЗаписатьВКолонкуТабличногоПоляЛкс(Элемент, Колонка, Не ЗначениеЯчейки, , , Ложь); // Так возникает рассогласование флажка и данных в колонке формы ИсследовательКоллекций
						ИнтерактивноЗаписатьВКолонкуТабличногоПоляЛкс(ТабличноеПоле, Колонка, Не ЗначениеЯчейки, , , Ложь, Ложь);
						//Элемент.ТекущаяКолонка = Колонка;
					КонецЕсли;
					ТабличноеПоле.ЗакончитьРедактированиеСтроки(Ложь);
					ТабличноеПолеОбновитьТекстыПодваловЛкс(ЭтаФорма, ТабличноеПоле);
				//КонецЕсли;
			КонецЕсли;
		КонецЕсли;
	КонецЕсли;
	Если Истина
		И КнопкаРежимаОтбораПомеченных <> Неопределено 
		И ТабличноеПоле.Значение.Найти(Истина, Колонка.Данные) = Неопределено 
	Тогда
		// Сняли последний флажок. Надо снять отбор по нему
		КнопкаРежимаОтбораПомеченных.Пометка = Ложь;
		ТабличноеПоле.ОтборСтрок[Колонка.Данные].Использование = Ложь;
	КонецЕсли;
	
КонецПроцедуры

Функция СоздатьМенеджерСохраненияНастроекФормыЛкс(ЭтаФорма, КлючНазначенияИспользования = "", Знач ЗагружатьСохранятьНастройкуПоУмолчанию = Истина, ПараметрыЗагрузкиНастройкиПоУмолчанию = Неопределено,
	РасширениеФайла = "", СоставНастройкиФормы = Неопределено) Экспорт 
	
	СлужебныеДанныеФормы = ирОбщий.СлужебныеДанныеФормыЛкс(ЭтаФорма);
	#Если Сервер И Не Сервер Тогда
		СлужебныеДанныеФормы = Новый Структура;
	#КонецЕсли
	МенеджерСохраненияНастроек = Новый Структура("СохраненныеНастройки, ПоследняяНастройка, КлючНастроек, ЗагружатьСохранятьНастройкуПоУмолчанию, РасширениеФайла, СоставНастройкиФормы");
	МенеджерСохраненияНастроек.КлючНастроек = ирОбщий.КлючХраненияНастроекФормыЛкс(ЭтаФорма) + ".Настройки";
	МенеджерСохраненияНастроек.ЗагружатьСохранятьНастройкуПоУмолчанию = ЗагружатьСохранятьНастройкуПоУмолчанию;
	МенеджерСохраненияНастроек.РасширениеФайла = РасширениеФайла;
	МенеджерСохраненияНастроек.СоставНастройкиФормы = СоставНастройкиФормы;
	Если ЗначениеЗаполнено(КлючНазначенияИспользования) Тогда
		МенеджерСохраненияНастроек.КлючНастроек = МенеджерСохраненияНастроек.КлючНастроек + "." + КлючНазначенияИспользования;
	КонецЕсли; 
	МенеджерСохраненияНастроек.КлючНастроек = Лев(МенеджерСохраненияНастроек.КлючНастроек, 128);
	СохраненныеНастройкиНовые = Новый ТаблицаЗначений;
	СохраненныеНастройкиНовые.Колонки.Добавить("Представление", Новый ОписаниеТипов("Строка"));
	СохраненныеНастройкиНовые.Колонки.Добавить("Значение");
	СохраненныеНастройкиНовые.Колонки.Добавить("Пометка", Новый ОписаниеТипов("Булево"));
	СохраненныеНастройкиНовые.Колонки.Добавить("ДатаИзменения", Новый ОписаниеТипов("Дата"));
	МенеджерСохраненияНастроек.СохраненныеНастройки = СохраненныеНастройкиНовые;
	СлужебныеДанныеФормы.МенеджерСохраненияНастроек = МенеджерСохраненияНастроек;
	Попытка
		СчитанныеСохраненныеНастройки = ирОбщий.ВосстановитьЗначениеЛкс(МенеджерСохраненияНастроек.КлючНастроек);
		Если СчитанныеСохраненныеНастройки = Неопределено Тогда
			СтарыйКлючХранения = ирОбщий.КлючХраненияНастроекФормыЛкс(ЭтаФорма) + ".СохраненныеНастройки";
			СчитанныеСохраненныеНастройки = ирОбщий.ВосстановитьЗначениеЛкс(СтарыйКлючХранения);
			Если СчитанныеСохраненныеНастройки <> Неопределено Тогда
				ирОбщий.УдалитьХранимуюНастройкуЛкс(СтарыйКлючХранения);
			КонецЕсли; 
		КонецЕсли; 
		Если ТипЗнч(СчитанныеСохраненныеНастройки) = Тип("ТаблицаЗначений") Тогда
			Для Каждого СтрокаСтаройНастройки Из СчитанныеСохраненныеНастройки Цикл
				Если СтрокаСтаройНастройки.Значение <> Неопределено Тогда
					ЗаполнитьЗначенияСвойств(СохраненныеНастройкиНовые.Добавить(), СтрокаСтаройНастройки); 
				КонецЕсли; 
			КонецЦикла;
		КонецЕсли;
		ЗагрузитьНастройкуФормыПоУмолчаниюЛкс(ЭтаФорма, Не ЗагружатьСохранятьНастройкуПоУмолчанию, ПараметрыЗагрузкиНастройкиПоУмолчанию);
	Исключение
		ирОбщий.СообщитьЛкс(ОписаниеОшибки(), СтатусСообщения.Внимание);
		Ответ = Вопрос("При загрузке последней настройки """ + ирОбщий.ПервыйФрагментЛкс(ЭтаФорма.Заголовок, ":") + """ возникла ошибка. Хотите загрузить пустую настройку?", РежимДиалогаВопрос.ОКОтмена);
		Если Ответ = КодВозвратаДиалога.ОК Тогда
			ЗагрузитьНастройкуФормыПоУмолчаниюЛкс(ЭтаФорма, Истина, ПараметрыЗагрузкиНастройкиПоУмолчанию);
		Иначе
			ВызватьИсключение;
		КонецЕсли;
	КонецПопытки; 

КонецФункции

Процедура ЗагрузитьНастройкуФормыПоУмолчаниюЛкс(Знач ЭтаФорма, Знач ЗагрузитьПустуюНастройку = Ложь, Знач ПараметрыЗагрузкиНастройкиПоУмолчанию = Неопределено) Экспорт 
	
	Если ЗагрузитьПустуюНастройку Тогда
		НастройкаФормы = Неопределено;
	Иначе
		МенеджерСохраненияНастроек = ирОбщий.СлужебныеДанныеФормыЛкс(ЭтаФорма).МенеджерСохраненияНастроек;
		НастройкаПоУмолчанию = ПолучитьНастройкуПоУмолчаниюИзСпискаСохраненныхНастроекЛкс(МенеджерСохраненияНастроек.СохраненныеНастройки);
		Если НастройкаПоУмолчанию.Значение = Неопределено Тогда
			СохранитьНастройкуФормыЛкс(ЭтаФорма);
			НастройкаПоУмолчанию = ПолучитьНастройкуПоУмолчаниюИзСпискаСохраненныхНастроекЛкс(МенеджерСохраненияНастроек.СохраненныеНастройки);
		КонецЕсли; 
		НастройкаФормы = НастройкаПоУмолчанию.Значение;
	КонецЕсли; 
	//ПоследняяНастройка = МенеджерСохраненияНастроек.СохраненныеНастройки.Индекс(НастройкаПоУмолчанию);
	ЗагрузитьНастройкуФормыЧерезОбработчикЛкс(ЭтаФорма, НастройкаФормы, ПараметрыЗагрузкиНастройкиПоУмолчанию);
	
КонецПроцедуры

Процедура ЗагрузитьНастройкуФормыЧерезОбработчикЛкс(Знач ЭтаФорма, Знач НастройкаФормы, Знач ПараметрыЗагрузкиНастройкиПоУмолчанию = Неопределено) Экспорт 
	
	Если ПараметрыЗагрузкиНастройкиПоУмолчанию = Неопределено Тогда
		ПараметрыЗагрузкиНастройкиПоУмолчанию = Новый Структура;
	КонецЕсли; 
	Если Форма_ВводДоступенЛкс(ЭтаФорма) Тогда 
		МенеджерСохраненияНастроек = ирОбщий.СлужебныеДанныеФормыЛкс(ЭтаФорма).МенеджерСохраненияНастроек;
		СоставНастройкиФормы = МенеджерСохраненияНастроек.СоставНастройкиФормы;
		Если СоставНастройкиФормы <> Неопределено Тогда
			#Если Сервер И Не Сервер Тогда
				СоставНастройкиФормы = Новый СписокЗначений;
			#КонецЕсли
			Если Не СоставНастройкиФормы.ОтметитьЭлементы("Выберите состав загружаемой настройки") Тогда 
				Возврат;
			КонецЕсли;
		КонецЕсли; 
	КонецЕсли; 
	ПараметрыЗагрузкиНастройкиПоУмолчанию.Вставить("СоставНастройкиФормы", СоставНастройкиФормы);
	Если ирОбщий.МетодРеализованЛкс(ЭтаФорма, "ЗагрузитьНастройкуВФорме") Тогда
		ЭтаФорма.ЗагрузитьНастройкуВФорме(НастройкаФормы, ПараметрыЗагрузкиНастройкиПоУмолчанию);
	Иначе
		ЗагрузитьНастройкуФормыЛкс(ЭтаФорма, НастройкаФормы);
	КонецЕсли;

КонецПроцедуры

Процедура ЗагрузитьНастройкуФормыЛкс(Знач ЭтаФорма, Знач НастройкаФормы, БелыеСвойства = Неопределено, ЧерныеСвойства = Неопределено, ЗагружатьОстальные = Истина) Экспорт 
	
	#Если Сервер И Не Сервер Тогда
		БелыеСвойства = Новый Структура;
		ЧерныеСвойства = Новый Структура;
	#КонецЕсли
	Если НастройкаФормы = Неопределено Тогда
		Возврат;
	КонецЕсли; 
	//ЗаполнитьЗначенияСвойств(ЭтаФорма, НастройкаФормы); 
	Для Каждого КлючИЗначение Из НастройкаФормы Цикл
		Если Ложь
			Или Не ирОбщий.ЕстьСвойствоОбъектаЛкс(ЭтаФорма, КлючИЗначение.Ключ) 
			Или (Истина
				И ЧерныеСвойства <> Неопределено
				И ЧерныеСвойства.Свойство(КлючИЗначение.Ключ))
			Или (Истина
				И БелыеСвойства <> Неопределено
				И Не БелыеСвойства.Свойство(КлючИЗначение.Ключ) 
				И Не ЗагружатьОстальные)
		Тогда 
			Продолжить;
		КонецЕсли; 
		ТипЗначения = ТипЗнч(ЭтаФорма[КлючИЗначение.Ключ]);
		Если ирОбщий.ЛиТабличнаяЧастьЛкс(ТипЗначения) Тогда
			Если КлючИЗначение.Значение = Неопределено Тогда
				ЭтаФорма[КлючИЗначение.Ключ].Очистить();
			Иначе
				ЭтаФорма[КлючИЗначение.Ключ].Загрузить(КлючИЗначение.Значение);
			КонецЕсли; 
		ИначеЕсли ТипЗначения = Тип("КомпоновщикНастроекКомпоновкиДанных") Тогда
			ЭтаФорма[КлючИЗначение.Ключ].ЗагрузитьНастройки(КлючИЗначение.Значение);
		ИначеЕсли ТипЗначения = Тип("ТаблицаЗначений") Тогда
			ирОбщий.ЗагрузитьВТаблицуЗначенийЛкс(КлючИЗначение.Значение, ЭтаФорма[КлючИЗначение.Ключ],,, Истина);
		ИначеЕсли ТипЗначения = Тип("ДеревоЗначений") Тогда
			ирОбщий.ЗагрузитьВДеревоЗначенийЛкс(КлючИЗначение.Значение, ЭтаФорма[КлючИЗначение.Ключ],,, Истина);
		Иначе
			ЗначениеСвойства = КлючИЗначение.Значение;
			ЗначениеСвойства = ирОбщий.КопияОбъектаЛкс(ЗначениеСвойства);
			ЭтаФорма[КлючИЗначение.Ключ] = ЗначениеСвойства;
		КонецЕсли; 
	КонецЦикла;

КонецПроцедуры

Процедура СохранитьНастройкуФормыЛкс(Знач ЭтаФорма) Экспорт 
	
	МенеджерСохраненияНастроек = ирОбщий.СлужебныеДанныеФормыЛкс(ЭтаФорма).МенеджерСохраненияНастроек;
	Если МенеджерСохраненияНастроек <> Неопределено И МенеджерСохраненияНастроек.ЗагружатьСохранятьНастройкуПоУмолчанию Тогда
		НастройкаПоУмолчанию = ПолучитьНастройкуПоУмолчаниюИзСпискаСохраненныхНастроекЛкс(МенеджерСохраненияНастроек.СохраненныеНастройки);
		НастройкаПоУмолчанию.Значение = СохраняемаяНастройкаФормыЛкс(ЭтаФорма);
		ирОбщий.СохранитьЗначениеЛкс(МенеджерСохраненияНастроек.КлючНастроек, МенеджерСохраненияНастроек.СохраненныеНастройки);
	КонецЕсли;

КонецПроцедуры

Функция ПолучитьНастройкуПоУмолчаниюИзСпискаСохраненныхНастроекЛкс(СписокСохраненныхНастроек) Экспорт
	
	ИмяОсновнойНастройки = "Основная";
	СтрокаСписка = СписокСохраненныхНастроек.Найти(Истина, "Пометка");
	Если СтрокаСписка = Неопределено Тогда
		СтрокаСписка = СписокСохраненныхНастроек.Найти(ИмяОсновнойНастройки, "Представление");
	КонецЕсли; 
	Если СтрокаСписка = Неопределено Тогда
		СтрокаСписка = СписокСохраненныхНастроек.Добавить();
		СтрокаСписка.Представление = ИмяОсновнойНастройки;
	КонецЕсли;
	СтрокаСписка.Пометка = Истина;
	Возврат СтрокаСписка;
	
КонецФункции

Функция ВыбратьИСохранитьНастройкуФормыЛкс(ЭтаФорма) Экспорт 
	
	МенеджерСохраненияНастроек = ирОбщий.СлужебныеДанныеФормыЛкс(ЭтаФорма).МенеджерСохраненияНастроек;
	НовоеНаименование = Неопределено;
    СохраняемаяНастройкаФормы = СохраняемаяНастройкаФормыЛкс(ЭтаФорма, НовоеНаименование);
	мПлатформа = ирКэш.Получить();
	#Если Сервер И Не Сервер Тогда
	    мПлатформа = Обработки.ирПлатформа.Создать();
	#КонецЕсли
	ФормаСохраненияНастройки = мПлатформа.ПолучитьФорму("ВыборНастройкиДляСохранения");
	ФормаСохраненияНастройки.НачальноеЗначениеВыбора = МенеджерСохраненияНастроек.ПоследняяНастройка;
	ФормаСохраненияНастройки.НовоеНаименование = НовоеНаименование;
	Если МенеджерСохраненияНастроек.СохраненныеНастройки <> Неопределено Тогда
		ФормаСохраненияНастройки.СписокНастроек = МенеджерСохраненияНастроек.СохраненныеНастройки;
	КонецЕсли;
	ТекущиеДанные = ФормаСохраненияНастройки.ОткрытьМодально();
	МенеджерСохраненияНастроек.СохраненныеНастройки = ФормаСохраненияНастройки.СписокНастроек;
	МенеджерСохраненияНастроек.ПоследняяНастройка = ФормаСохраненияНастройки.НачальноеЗначениеВыбора;
	Если ТекущиеДанные <> Неопределено Тогда
		ТекущиеДанные.Значение = СохраняемаяНастройкаФормы;
	КонецЕсли;
	СохранитьНастройкуФормыЛкс(ЭтаФорма);

КонецФункции

// Параметры:
//  КопироватьЗначения - Булево - Ложь сильно ускоряет
//
// Параметры:
//  ЭтаФорма			 - Форма - 
//  выхНовоеНаименование - Строка - 
//  ПорогТаблицыЗначений - Число - Чтобы не засорять БД
// 
// Возвращаемое значение:
//   - 
//
Функция СохраняемаяНастройкаФормыЛкс(Знач ЭтаФорма, выхНовоеНаименование = "", ПорогТаблицыЗначений = 100000) Экспорт 
	
	выхНовоеНаименование = "";
	ИменаСвойств = "";
	СохраняемаяНастройкаФормы = ЭтаФорма.СохраняемаяНастройкаФормы(выхНовоеНаименование, ИменаСвойств);
	Если ЗначениеЗаполнено(ИменаСвойств) Тогда
		Если СохраняемаяНастройкаФормы = Неопределено Тогда
			СохраняемаяНастройкаФормы = Новый Структура;
		КонецЕсли; 
		ИменаСвойств = СтрЗаменить(ИменаСвойств, "Реквизит.", "");
		ИменаСвойств = СтрЗаменить(ИменаСвойств, "Форма.", "");
		ИменаСвойств = СтрЗаменить(ИменаСвойств, "Табличная часть.", "");
		МассивИмен = ирОбщий.СтрРазделитьЛкс(ИменаСвойств, ",", Истина, Ложь);
		ЗначенияСвойств = Новый Структура();
		Для Каждого ИмяСвойства Из МассивИмен Цикл
			Если Не ЗначениеЗаполнено(ИмяСвойства) Или СохраняемаяНастройкаФормы.Свойство(ИмяСвойства) Тогда
				Продолжить;
			КонецЕсли; 
			ЗначенияСвойств.Вставить(ИмяСвойства);
			ТипЗначения = ТипЗнч(ЭтаФорма[ИмяСвойства]);
			Если ирОбщий.ЛиТабличнаяЧастьЛкс(ТипЗначения) Тогда
				ЗначенияСвойств[ИмяСвойства] = ЭтаФорма[ИмяСвойства].Выгрузить();
			ИначеЕсли ТипЗначения = Тип("КомпоновщикНастроекКомпоновкиДанных") Тогда
				ЗначенияСвойств[ИмяСвойства] = ЭтаФорма[ИмяСвойства].ПолучитьНастройки();
			Иначе
				ЗначениеСвойства = ЭтаФорма[ИмяСвойства];
				ЗначениеСвойства = ирОбщий.КопияОбъектаЛкс(ЗначениеСвойства);
				ЗначенияСвойств[ИмяСвойства] = ЗначениеСвойства;
			КонецЕсли; 
			Если ТипЗнч(ЗначенияСвойств[ИмяСвойства]) = Тип("ТаблицаЗначений") Тогда
				ТаблицаЗначений = ЗначенияСвойств[ИмяСвойства];
				Если ТаблицаЗначений.Количество() > ПорогТаблицыЗначений Тогда
					ирОбщий.СообщитьЛкс(ирОбщий.СтрШаблонИменЛкс("Сохраняемая таблица %1 настройки формы обрезана %2 -> %3 строк",, ИмяСвойства, 2, ТаблицаЗначений.Количество(), 3, ПорогТаблицыЗначений));
					Пока ТаблицаЗначений.Количество() > ПорогТаблицыЗначений Цикл
						ТаблицаЗначений.Удалить(ТаблицаЗначений.Количество() - 1);
					КонецЦикла;
				КонецЕсли; 
			КонецЕсли; 
		КонецЦикла;
		ирОбщий.СкопироватьУниверсальнуюКоллекциюЛкс(ЗначенияСвойств, СохраняемаяНастройкаФормы);
	КонецЕсли;
	Возврат СохраняемаяНастройкаФормы;

КонецФункции

Функция ВыбратьИЗагрузитьНастройкуФормыЛкс(ЭтаФорма) Экспорт 
	
	МенеджерСохраненияНастроек = ирОбщий.СлужебныеДанныеФормыЛкс(ЭтаФорма).МенеджерСохраненияНастроек;
	Если МенеджерСохраненияНастроек.СохраненныеНастройки = Неопределено Тогда
		Возврат Неопределено;
	КонецЕсли; 
	Если Не ПроверитьЗавершениеФоновыхЗаданийФормыЛкс(ЭтаФорма) Тогда 
		ирОбщий.СообщитьЛкс("Нельзя выполнять загрузку настроек, пока форма выполняет фоновые задания");
		Возврат Неопределено;
	КонецЕсли; 
	мПлатформа = ирКэш.Получить();
	#Если Сервер И Не Сервер Тогда
	    мПлатформа = Обработки.ирПлатформа.Создать();
	#КонецЕсли
	ФормаСохраненияНастройки = мПлатформа.ПолучитьФорму("ВыборНастройкиДляЗагрузки");
	ФормаСохраненияНастройки.НачальноеЗначениеВыбора = МенеджерСохраненияНастроек.ПоследняяНастройка;
	Если МенеджерСохраненияНастроек.СохраненныеНастройки <> Неопределено Тогда
		ФормаСохраненияНастройки.СписокНастроек = МенеджерСохраненияНастроек.СохраненныеНастройки;
	КонецЕсли;
	ТекущиеДанные = ФормаСохраненияНастройки.ОткрытьМодально();
	МенеджерСохраненияНастроек.СохраненныеНастройки = ФормаСохраненияНастройки.СписокНастроек;
	МенеджерСохраненияНастроек.ПоследняяНастройка = ФормаСохраненияНастройки.НачальноеЗначениеВыбора;
	Если ТекущиеДанные <> Неопределено И ТекущиеДанные.Значение <> Неопределено Тогда
		ЗагрузитьНастройкуФормыЧерезОбработчикЛкс(ЭтаФорма, ТекущиеДанные.Значение);
	КонецЕсли;
	СохранитьНастройкуФормыЛкс(ЭтаФорма);

КонецФункции

Функция КартинкаТипаЛкс(Тип) Экспорт 
	
	ИмяОбщегоТипа = Неопределено;
	ПоляПоиска = "ИД";
	КлючПоиска = Новый Структура(ПоляПоиска);
	КлючПоиска.ИД = ирОбщий.ИдентификаторТипаЛкс(Тип);
	//КлючПоиска.ТипТипа = "Основной";
	мПлатформа = ирКэш.Получить();
	#Если Сервер И Не Сервер Тогда
		мПлатформа = Обработки.ирПлатформа.Создать();
	#КонецЕсли
	мПлатформа.ИнициализацияОписанияОбщихТипов();
	//ирОбщий.ДобавитьИндексВТаблицуЛкс(мПлатформа.ТаблицаОбщихТипов, ПоляПоиска);
	НайденныеСтроки = мПлатформа.ТаблицаОбщихТипов.НайтиСтроки(КлючПоиска);
	Если НайденныеСтроки.Количество() > 0 Тогда
		ИмяОбщегоТипа = НайденныеСтроки[0].Слово;
	Иначе
		//СтруктураТипа = ирКэш.Получить().СтруктураТипаИзКонкретногоТипа(Тип);
		//ИмяОбщегоТипа = СтруктураТипа.ИмяОбщегоТипа;
		ОбъектМД = Метаданные.НайтиПоТипу(Тип);
		Если ОбъектМД <> Неопределено Тогда
			ТекущееИмяТипа = ОбъектМД.ПолноеИмя();
			ИмяОбщегоТипа = ирОбщий.ПервыйФрагментЛкс(ТекущееИмяТипа);
		КонецЕсли; 
	КонецЕсли;
	Картинка = Неопределено;
	Если ИмяОбщегоТипа <> Неопределено Тогда
		ИмяКартинки = "ир" + ирОбщий.ПервыйФрагментЛкс(ИмяОбщегоТипа);
		Картинка = ирКэш.КартинкаПоИмениЛкс(ИмяКартинки);
		Если Картинка.Вид = ВидКартинки.Пустая Тогда
			ИмяКартинки = ИмяОбщегоТипа;
			Попытка
				Картинка = БиблиотекаКартинок[ИмяКартинки];
			Исключение
				Картинка = ирКэш.КартинкаПоИмениЛкс("ирНеизвестныйТип");
			КонецПопытки; 
		КонецЕсли;
	КонецЕсли;
	Возврат Картинка;
		
КонецФункции

Функция ПрочитатьДополнительныеПоляСсылающихсяОбъектовЛкс(Знач ТабличноеПоле, Знач КомпоновщикДопПолей, Знач ТаблицаДанных = Неопределено, ИмяПоляСсылки = "Данные") Экспорт 
	
	#Если Сервер И Не Сервер Тогда
	    КомпоновщикДопПолей = Новый КомпоновщикНастроекКомпоновкиДанных;
	#КонецЕсли
	Если ТаблицаДанных = Неопределено Тогда
		ТаблицаДанных = ирОбщий.ДанныеЭлементаФормыЛкс(ТабличноеПоле);
	КонецЕсли; 
	КомпоновщикДопПолей.Восстановить(СпособВосстановленияНастроекКомпоновкиДанных.Полное);
	МассивДопПолей = Новый Структура();
	ДопустимоеЧислоДопПолей = 5;
	Счетчик = 1;
	СтрокаПорядка = "";
	СтрокаВыбора = "";
	Для Каждого ПолеПорядка Из КомпоновщикДопПолей.Настройки.Порядок.Элементы Цикл
		Если ПолеПорядка.Использование Тогда
			ИмяПоля = "" + ПолеПорядка.Поле;
			ИмяКолонки = "Реквизит" + Счетчик;
			ДоступноеПоле = КомпоновщикДопПолей.Настройки.ДоступныеПоляПорядка.НайтиПоле(ПолеПорядка.Поле);
			Если Счетчик > ДопустимоеЧислоДопПолей Тогда
				ирОбщий.СообщитьЛкс(ирОбщий.СтрШаблонИменЛкс("Дополнительное поле %1 пропущено, т.к. допускается не более %2 полей",, ДоступноеПоле.Заголовок, 2, ДопустимоеЧислоДопПолей));
				Продолжить;
			КонецЕсли; 
			МассивДопПолей.Вставить(ИмяКолонки, ИмяПоля);
			КолонкаТП = ТабличноеПоле.Колонки[ИмяКолонки];
			КолонкаТП.Видимость = Истина;
			КолонкаТП.ТекстШапки = ДоступноеПоле.Заголовок;
			Если СтрокаПорядка <> "" Тогда
				СтрокаПорядка = СтрокаПорядка + ",";
			КонецЕсли; 
			СтрокаПорядка = СтрокаПорядка + ИмяКолонки + " ";
			Если ПолеПорядка.ТипУпорядочивания = НаправлениеСортировкиКомпоновкиДанных.Возр Тогда
				СтрокаПорядка = СтрокаПорядка + "Возр";
			Иначе
				СтрокаПорядка = СтрокаПорядка + "Убыв";
			КонецЕсли;
			СтрокаВыбора = СтрокаВыбора + ",
			|	Т." + ИмяПоля + " КАК " + ИмяКолонки;
			Счетчик = Счетчик + 1;
		КонецЕсли; 
	КонецЦикла;
	Если Не ЗначениеЗаполнено(СтрокаПорядка) Тогда
		СтрокаПорядка = "Дата";
	КонецЕсли; 
	Для Счетчик = Счетчик По ДопустимоеЧислоДопПолей Цикл
		ИмяКолонки = "Реквизит" + Счетчик;
		Если ТипЗнч(ТабличноеПоле) = Тип("ТаблицаФормы") Тогда
			КолонкаТП = ТабличноеПоле.ПодчиненныеЭлементы[ТабличноеПоле.Имя + ИмяКолонки];
		Иначе
			КолонкаТП = ТабличноеПоле.Колонки[ИмяКолонки];
		КонецЕсли; 
		КолонкаТП.Видимость = Ложь;
	КонецЦикла;
		
	СтандартныеРеквизиты = Новый Структура;
	СтандартныеРеквизиты.Вставить("ПометкаУдаления", "ЛОЖЬ");
	СтандартныеРеквизиты.Вставить("Проведен", "ЛОЖЬ");
	СтандартныеРеквизиты.Вставить("ЭтоГруппа", "ЛОЖЬ");
	СтандартныеРеквизиты.Вставить("Дата", "ДАТАВРЕМЯ(1,1,1)");
	Для Каждого КлючИЗначение Из СтандартныеРеквизиты Цикл
		ИмяРеквизита = КлючИЗначение.Ключ;
		Если КомпоновщикДопПолей.Настройки.ДоступныеПоляПорядка.НайтиПоле(Новый ПолеКомпоновкиДанных("Объект." + ИмяРеквизита)) = Неопределено Тогда
			Продолжить;
		КонецЕсли; 
		СтрокаВыбора = СтрокаВыбора + ",
		|	ЕСТЬNULL(Т.Объект." + ИмяРеквизита + ", " + КлючИЗначение.Значение + ") КАК " + ИмяРеквизита;
	КонецЦикла;
	Если ТипЗнч(ТаблицаДанных) <> Тип("ТаблицаЗначений") Тогда
		//КопияТаблицыДанных = ТаблицаДанных.Выгрузить(, ИмяПоляСсылки);
		КопияТаблицыДанных = ТаблицаИлиДеревоЗначенийИзТаблицыФормыСКоллекциейЛкс(ТабличноеПоле);
	Иначе
		КопияТаблицыДанных = ТаблицаДанных;
	КонецЕсли; 
	КопияТаблицыДанных = ирОбщий.СузитьТипыКолонокТаблицыБезПотериДанныхЛкс(КопияТаблицыДанных,, ИмяПоляСсылки);
	#Если Сервер И Не Сервер Тогда
		КопияТаблицыДанных = Новый ТаблицаЗначений;
	#КонецЕсли
	ОписаниеТиповСсылки = КопияТаблицыДанных.Колонки[ИмяПоляСсылки].ТипЗначения;
	ПорцияОбъектов = Новый ТаблицаЗначений;
	ПорцияОбъектов.Колонки.Добавить("Объект", ОписаниеТиповСсылки);
	ПорцияОбъектов.Колонки.Добавить("Индекс", Новый ОписаниеТипов("Число"));
	РазмерПорции = 10000;
	КоличествоПорций = Цел(ТаблицаДанных.Количество() / РазмерПорции) + 1;
	Запрос = Новый Запрос;
	ТекстЗапроса = "
	|ВЫБРАТЬ Т.* ПОМЕСТИТЬ Т ИЗ &Т КАК Т;
	|ВЫБРАТЬ Т.Объект, Т.Индекс" + СтрокаВыбора + "
	|ИЗ Т КАК Т";
	Запрос.Текст = ТекстЗапроса;
	ИндексСтроки = 0;
	Индикатор = ирОбщий.ПолучитьИндикаторПроцессаЛкс(КоличествоПорций, "Чтение дополнительных полей");
	ДоступноеПолеОбъект = КомпоновщикДопПолей.Настройки.ДоступныеПоляПорядка.НайтиПоле(Новый ПолеКомпоновкиДанных("Объект"));
	Для СчетчикПорций = 1 По КоличествоПорций Цикл
		ирОбщий.ОбработатьИндикаторЛкс(Индикатор);
		ПорцияОбъектов.Очистить();
		Для Счетчик = 1 По РазмерПорции Цикл
			Если ИндексСтроки = ТаблицаДанных.Количество() Тогда
				Прервать;
			КонецЕсли; 
			СтрокаОбъекта = ТаблицаДанных[ИндексСтроки];
			ИндексСтроки = ИндексСтроки + 1;
			Если Ложь
				Или ТипЗнч(СтрокаОбъекта[ИмяПоляСсылки]) = Тип("Строка") 
				Или СтрокаОбъекта[ИмяПоляСсылки] = Неопределено
				Или ДоступноеПолеОбъект = Неопределено
				Или Не ДоступноеПолеОбъект.ТипЗначения.СодержитТип(ТипЗнч(СтрокаОбъекта[ИмяПоляСсылки]))
			Тогда
				СтрокаОбъекта.ИндексКартинки = 12; // Регистр сведений
				Продолжить;
			КонецЕсли; 
			СтрокаПорции = ПорцияОбъектов.Добавить();
			СтрокаПорции.Объект = СтрокаОбъекта[ИмяПоляСсылки];
			СтрокаПорции.Индекс = ИндексСтроки - 1;
		КонецЦикла;
		Запрос.УстановитьПараметр("Т", ПорцияОбъектов);
		РезультатЗапроса = Запрос.Выполнить();
		РеквизитыПорции = РезультатЗапроса.Выгрузить();
		Для Каждого СтрокаПорции Из РеквизитыПорции Цикл
			СтрокаОбъекта = ТаблицаДанных[СтрокаПорции.Индекс];
			СтрокаОбъекта.ИндексКартинки = ирОбщий.ИндексКартинкиСсылкиЛкс(СтрокаПорции.Объект, Истина, СтрокаПорции);
			ЗаполнитьЗначенияСвойств(СтрокаОбъекта, СтрокаПорции);
		КонецЦикла;
	КонецЦикла;
	ирОбщий.ОсвободитьИндикаторПроцессаЛкс();

	СтрокаПорядка = "Метаданные," + СтрокаПорядка;
	Возврат СтрокаПорядка;

КонецФункции

Процедура ОбновитьДоступныеПоляДляДополнительныхПолейЛкс(Знач ТаблицаДанных, Знач КомпоновщикДопПолей, Знач ТабличноеПолеДоступныхПолей) Экспорт 
	
	//Если КомпоновщикДопПолей.Настройки.ДоступныеПоляПорядка.Элементы.Количество() = 0 Тогда
		Если ТипЗнч(ТаблицаДанных) = Тип("ТаблицаЗначений") Тогда
			ПолныеИменаМД = ТаблицаДанных.Скопировать(, "Метаданные");
		Иначе
			ПолныеИменаМД = ТаблицаДанных.Выгрузить(, "Метаданные");
		КонецЕсли; 
		ПолныеИменаМД.Свернуть("Метаданные");
		ПолныеИменаМД = ПолныеИменаМД.ВыгрузитьКолонку(0);
		МассивТипов = Новый Массив();
		Для Каждого ПолноеИмяМД Из ПолныеИменаМД Цикл
			Если ТипЗнч(ПолноеИмяМД) = Тип("ОбъектМетаданных") Тогда
				ПолноеИмяМД = ПолноеИмяМД.ПолноеИмя();
			КонецЕсли; 
			Попытка
				Тип = Тип(ирОбщий.ИмяТипаИзПолногоИмениТаблицыБДЛкс(ПолноеИмяМД));
			Исключение
				Продолжить;
			КонецПопытки;
			МассивТипов.Добавить(Тип);
		КонецЦикла;
		Если МассивТипов.Количество() > 0 Тогда
			КоллекцияПолей = Новый Массив();
			КоллекцияПолей.Добавить(Новый Структура("Имя, ТипЗначения", "Объект", Новый ОписаниеТипов(МассивТипов)));
			ТекстЗапроса = ирОбщий.ЗапросИмитаторКоллекцииПолейЛкс(КоллекцияПолей);
			СхемаКомпоновки = ирОбщий.СоздатьСхемуКомпоновкиПоЗапросу(ТекстЗапроса); 
		Иначе
			СхемаКомпоновки = Новый СхемаКомпоновкиДанных;
		КонецЕсли; 
		Если ТипЗнч(ТабличноеПолеДоступныхПолей) = Тип("ТаблицаФормы") Тогда
			ЭтаФорма = ирОбщий.РодительЭлементаУправляемойФормыЛкс(ТабличноеПолеДоступныхПолей);
			ИсточникДоступныхНастроек = Новый ИсточникДоступныхНастроекКомпоновкиДанных(ПоместитьВоВременноеХранилище(СхемаКомпоновки), ЭтаФорма.УникальныйИдентификатор);
		Иначе
			ИсточникДоступныхНастроек = Новый ИсточникДоступныхНастроекКомпоновкиДанных(СхемаКомпоновки);
		КонецЕсли; 
		КомпоновщикДопПолей.Инициализировать(ИсточникДоступныхНастроек);
		Если КомпоновщикДопПолей.Настройки.ДоступныеПоляПорядка.Элементы.Количество() > 0 Тогда
			#Если Клиент И Не Сервер Тогда
			ТабличноеПолеДоступныхПолей.Развернуть(КомпоновщикДопПолей.Настройки.ДоступныеПоляПорядка.Элементы[0]);
			#КонецЕсли 
		КонецЕсли; 
	//КонецЕсли;

КонецПроцедуры

// ИменаКолонок - Строка - имена колонок через запятую
Процедура ТабличноеПолеОтобразитьПиктограммыТиповЛкс(ОформлениеСтроки, ИменаКолонок) Экспорт
	
	Если ТипЗнч(ИменаКолонок) = Тип("Строка") Тогда
		ИменаКолонок = ирОбщий.СтрРазделитьЛкс(ИменаКолонок, ",", Истина); 
	КонецЕсли; 
	Для Каждого ИмяКолонки Из ИменаКолонок Цикл
		Ячейка = ОформлениеСтроки.Ячейки.Найти(ИмяКолонки);
		//:Ячейка = Новый("ОформлениеЯчейки")
		Если Ячейка <> Неопределено Тогда
			ДанныеКартинки = Ячейка.Значение;
			Если ТипЗнч(ДанныеКартинки) = Тип("ПолеКомпоновкиДанных") Тогда
				Продолжить;
			КонецЕсли;
			СсылкаКартинка = Неопределено;
			ТипЗначения = ТипЗнч(ДанныеКартинки);
			Если Истина
				И ТипЗначения = Тип("Булево")
				И Ячейка.ОтображатьФлажок
			Тогда
				Продолжить;
			КонецЕсли;
			КартинкаТипа = КартинкаТипаЛкс(ТипЗначения);
			Если КартинкаТипа <> Неопределено Тогда
				Ячейка.УстановитьКартинку(КартинкаТипа);
			КонецЕсли;
		КонецЕсли;
	КонецЦикла;

КонецПроцедуры

Функция ОткрытьТекущуюСтрокуТабличногоПоляТаблицыБДВРедактореОбъектаБДЛкс(ТабличноеПоле, ПолноеИмяМД = Неопределено, ДоступныеПоляВыбора = Неопределено, Связанный = Ложь,
	ФормаРедактора = Неопределено, ОбъектыНаСервере = Неопределено, ДляНабораЗаписейРегистраСведений = Истина, ПриОтсутствииСтрокиОткрытьНовыйОбъект = Ложь,
	ИмяКолонкиДанных = Неопределено, Знач НайденныеСсылки = Неопределено, Знач ВладелецФормы = Неопределено) Экспорт
	
	ТекущаяСтрока = ТабличноеПоле.ТекущаяСтрока;
	Если Не ПриОтсутствииСтрокиОткрытьНовыйОбъект И ТекущаяСтрока = Неопределено Тогда
		Возврат Неопределено;
	КонецЕсли; 
	Если ТипЗнч(ТабличноеПоле) = Тип("ТаблицаФормы") Тогда
		Если ПолноеИмяМД = Неопределено Тогда
			ПолноеИмяМД = ирОбщий.ДанныеЭлементаФормыЛкс(ТабличноеПоле).ОсновнаяТаблица;
		КонецЕсли;
		Если ИмяКолонкиДанных = Неопределено Тогда
			ТекущаяКолонка = ТабличноеПоле.ТекущийЭлемент;
			Если ТекущаяКолонка <> Неопределено Тогда
				ИмяКолонкиДанных = ирОбщий.ПутьКДаннымЭлементаУправляемойФормыЛкс(ТекущаяКолонка, Истина);
			КонецЕсли; 
		КонецЕсли; 
	Иначе
		Если ПолноеИмяМД = Неопределено Тогда
			ПолноеИмяМД = Метаданные.НайтиПоТипу(ТипЗнч(ТабличноеПоле.Значение)).ПолноеИмя();
		КонецЕсли; 
		Если ИмяКолонкиДанных = Неопределено Тогда
			ТекущаяКолонка = ТабличноеПоле.ТекущаяКолонка;
			Если ТекущаяКолонка <> Неопределено Тогда
				ИмяКолонкиДанных = ТекущаяКолонка.Данные;
			КонецЕсли;
		КонецЕсли; 
	КонецЕсли; 
	Если Истина
		И ИмяКолонкиДанных <> Неопределено 
		И (Ложь
			Или ДоступныеПоляВыбора = Неопределено
			Или ДоступныеПоляВыбора.НайтиПоле(Новый ПолеКомпоновкиДанных(ИмяКолонкиДанных)) <> Неопределено)
	Тогда
		ИмяКолонки = ИмяКолонкиДанных;
	Иначе
		ИмяКолонки = "";
	КонецЕсли; 
	ПолноеИмяТаблицы = ирКэш.ИмяТаблицыИзМетаданныхЛкс(ПолноеИмяМД,, Ложь);
	ТипТаблицы = ирОбщий.ТипТаблицыБДЛкс(ПолноеИмяТаблицы);
	ЭтоТаблицаИзменений = ТипТаблицы = "Изменения";
	Если ЭтоТаблицаИзменений Тогда
		ПолноеИмяТаблицы = ирОбщий.СтрокаБезПоследнегоФрагментаЛкс(ПолноеИмяТаблицы);
	КонецЕсли;
	КорневойТип = ирОбщий.ПервыйФрагментЛкс(ПолноеИмяТаблицы);
	Если ирОбщий.ЛиКорневойТипКонстантыЛкс(КорневойТип) Тогда
		КлючОбъекта = ирОбщий.КлючОбъектаКонстантыЛкс(ирОбщий.ПоследнийФрагментЛкс(ПолноеИмяМД));
		ОткрытьРедакторОбъектаБДЛкс(ПолноеИмяТаблицы,, Связанный, КлючОбъекта, ОбъектыНаСервере,,, ФормаРедактора,,,,, ВладелецФормы);
	Иначе
		Если Не ДляНабораЗаписейРегистраСведений И ирОбщий.ЛиКлючЗаписиРегистраЛкс(ТабличноеПоле.ТекущаяСтрока) Тогда
			ДанныеСтрокиТаблицы = ТабличноеПоле.ТекущаяСтрока; // Так обходим проблему неполных ключей из-за функциональных опций и прочего
		Иначе
			ДанныеСтрокиТаблицы = ТабличноеПоле.ТекущиеДанные;
		КонецЕсли;
		Если ЭтоТаблицаИзменений Тогда
			АктивироватьУзел = ДанныеСтрокиТаблицы.Узел; 
		КонецЕсли;
		Если ДанныеСтрокиТаблицы <> Неопределено Тогда
			КлючОбъекта = ирОбщий.КлючСтрокиТаблицыБДИзСтрокиТаблицыЗначенийЛкс(ПолноеИмяТаблицы, ДанныеСтрокиТаблицы, ДляНабораЗаписейРегистраСведений,, ОбъектыНаСервере);
		КонецЕсли; 
		Если КлючОбъекта = Неопределено Тогда
			Если Ложь
				Или ирОбщий.ЛиКорневойТипСсылкиЛкс(КорневойТип) 
				Или ирОбщий.ЛиКорневойТипЖурналаДокументовЛкс(КорневойТип)
			Тогда
				Если ТекущаяСтрока <> Неопределено Тогда
					ТипКлюча = ТипЗнч(ТекущаяСтрока.Ссылка);
				Иначе
					Фрагменты = ирОбщий.СтрРазделитьЛкс(ПолноеИмяМД);  // Тут может быть имя ТЧ
					ТипКлюча = Тип(ирОбщий.ИмяТипаИзПолногоИмениМДЛкс(Фрагменты[0] + "." + Фрагменты[1]));
				КонецЕсли; 
				КлючОбъекта = Новый (ТипКлюча);
				ПолноеИмяТаблицы = Метаданные.НайтиПоТипу(ТипКлюча).ПолноеИмя();
			Иначе
				КлючОбъекта = ирОбщий.ОбъектБДПоКлючуЛкс(ПолноеИмяТаблицы,,, Ложь, ОбъектыНаСервере);
			КонецЕсли;
		КонецЕсли;
		Если ЗначениеЗаполнено(ПолноеИмяМД) Тогда
			Если ТипЗнч(ТабличноеПоле) = Тип("ТаблицаФормы") Тогда
				СтрокиПоиска = Новый Структура;
				СхемаИНастройки = ИсполняемыеСхемаИНастройкиСпискаУправляемойФормаЛкс(ирОбщий.РодительЭлементаУправляемойФормыЛкс(ТабличноеПоле));
				Если СхемаИНастройки <> Неопределено Тогда
					НастройкиСписка = СхемаИНастройки.Настройки;
				Иначе
					НастройкиСписка = ирОбщий.НастройкиДинамическогоСпискаЛкс(ирОбщий.ДанныеЭлементаФормыЛкс(ТабличноеПоле));
				КонецЕсли;
				Для Каждого ЭлементОтбора Из ирОбщий.ВсеЭлементыИерарихииНастроекКомпоновкиЛкс(НастройкиСписка.Отбор,, Истина) Цикл 
					Если Истина
						И ЭлементОтбора.ВидСравнения = ВидСравненияКомпоновкиДанных.Содержит 
					Тогда
						ирОбщий.ДобавитьСловаПоискаВСтруктуруРеквизитовЛкс(ирОбщий.ПервыйФрагментЛкс(ЭлементОтбора.ЛевоеЗначение), ЭлементОтбора.ПравоеЗначение, СтрокиПоиска);
					КонецЕсли;
				КонецЦикла;
			Иначе
				СтрокиПоиска = СловаПоискаПоКолонкамИзОтбораПостроителяЛкс(ТабличноеПоле);
			КонецЕсли;
		КонецЕсли;
		ОткрытьРедакторОбъектаБДЛкс(ПолноеИмяТаблицы, ИмяКолонки, Связанный, КлючОбъекта, ОбъектыНаСервере, ТабличноеПоле.ТекущиеДанные, ТабличноеПоле.ТекущаяСтрока, ФормаРедактора,
			НайденныеСсылки, СтрокиПоиска,, АктивироватьУзел, ВладелецФормы);
	КонецЕсли; 
	Возврат ФормаРедактора;
	
КонецФункции

Функция ОтборТабличногоПоляЛкс(Знач ТабличноеПоле) Экспорт 
	
	Попытка
		Отбор = ТабличноеПоле.ОтборСтрок;
	Исключение
		Попытка
			Отбор = ТабличноеПоле.Значение.Отбор;
		Исключение
		КонецПопытки;
	КонецПопытки;
    Возврат Отбор;
	
КонецФункции

Функция ОткрытьРедакторОбъектаБДЛкс(ПолноеИмяТаблицы, Знач ИмяРеквизита = "", Знач Связанный = Ложь, Знач КлючОбъекта = Неопределено, Знач ОбъектыНаСервере = Неопределено,
	Знач ДанныеСтрокиТаблицы = Неопределено, КлючУникальностиНовойФормы = Неопределено, ФормаРедактора = Неопределено, Знач НайденныеСсылки = Неопределено, Знач СтрокиПоиска = Неопределено,
	Знач ПоказатьСвязанныеКолонкиБД = Ложь, Знач АктивироватьУзел = Неопределено, Знач ВладелецФормы = Неопределено) Экспорт 
	
	Если ФормаРедактора = Неопределено Тогда
		КлючУникальности = КлючУникальностиНовойФормы;
		Если Связанный Тогда
			КлючУникальности = "Связанный";
		КонецЕсли; 
		ФормаРедактора = ПолучитьФормуЛкс("Обработка.ирРедакторОбъектаБД.Форма",,, КлючУникальности);
	КонецЕсли; 
	Фрагменты = ирОбщий.СтрРазделитьЛкс(ПолноеИмяТаблицы);
	Если ирОбщий.ЛиКорневойТипСсылкиЛкс(Фрагменты[0]) Тогда
		ИмяОсновнойТаблицы = Фрагменты[0] + "." + Фрагменты[1];
	Иначе
		ИмяОсновнойТаблицы = ПолноеИмяТаблицы;
	КонецЕсли;
	Если КлючОбъекта <> Неопределено Тогда
		Если Не ФормаРедактора.Открыта() Тогда
			ПараметрыФормы = Новый Структура("ПараметрКлючИлиОбъект, ПараметрПрочитатьОбъект", КлючОбъекта, Истина);
			ЗаполнитьЗначенияСвойств(ФормаРедактора.фОбъект, ПараметрыФормы); 
		Иначе 
			ФормаРедактора.ЗагрузитьОбъектПоКлючу(КлючОбъекта);
		КонецЕсли; 
	Иначе
		ФормаРедактора.УстановитьТаблицуБД(ИмяОсновнойТаблицы);
	КонецЕсли;
	БылаОткрыта = ФормаРедактора.Открыта();
	ФормаРедактора.ПараметрСтрокиПоиска = СтрокиПоиска;
	Форма_АктивироватьОткрытьЛкс(ФормаРедактора);
	Если НайденныеСсылки <> Неопределено Тогда
		ФормаРедактора.НайтиИПоказатьСсылкиВФорме(НайденныеСсылки, Не БылаОткрыта);
	КонецЕсли;
	СтруктураЛокальногоКлючаСтроки = Неопределено;
	Если ДанныеСтрокиТаблицы <> Неопределено Тогда
		ирОбщий.КлючСтрокиТаблицыБДИзСтрокиТаблицыЗначенийЛкс(ПолноеИмяТаблицы, ДанныеСтрокиТаблицы, Истина, СтруктураЛокальногоКлючаСтроки, ОбъектыНаСервере);
	КонецЕсли; 
	Если Ложь
		Или ЗначениеЗаполнено(ИмяРеквизита) 
		Или СтруктураЛокальногоКлючаСтроки <> Неопределено
	Тогда
		ФормаРедактора.ПоказатьЯчейкуДанныхОбъекта(ПолноеИмяТаблицы, ИмяРеквизита, СтруктураЛокальногоКлючаСтроки, Ложь);
	КонецЕсли; 
	Если ПоказатьСвязанныеКолонкиБД Тогда
		ФормаРедактора.ПоказатьСвязанныеКолонкиБД();
	КонецЕсли;
	Если ЗначениеЗаполнено(АктивироватьУзел) Тогда
		ФормаРедактора.АктивироватьУзел(АктивироватьУзел);
	КонецЕсли;
	Возврат ФормаРедактора;

КонецФункции

Функция ОткрытьКолонкуБДЛкс(Знач ИмяТаблицы, Знач ИмяПоля = "") Экспорт 
	Если Не ЗначениеЗаполнено(ИмяПоля) Тогда
		ИмяПоля = ирОбщий.ПоследнийФрагментЛкс(ИмяТаблицы);
		ИмяТаблицы = ирОбщий.СтрокаБезПоследнегоФрагментаЛкс(ИмяТаблицы);
	КонецЕсли;
	Если ирКэш.ПоляТаблицыБДЛкс(ИмяТаблицы).Найти(ИмяПоля, "Имя") = Неопределено Тогда 
		Возврат Неопределено;
	КонецЕсли;
	ФормаПоля = ирКэш.Получить().ПолучитьФорму("КолонкаБД",, ИмяТаблицы + "." + ИмяПоля);
	ФормаПоля.ИмяТаблицы = ИмяТаблицы;
	ФормаПоля.ИмяПоля = ИмяПоля;
	ФормаПоля.Открыть();
	Возврат ФормаПоля;
КонецФункции


Процедура Форма_АктивироватьОткрытьЛкс(Знач Форма) Экспорт 
	
	Если ирКэш.ЛиСеансТолстогоКлиентаУПЛкс() Тогда 
		НужноОткрытьФорму = ТипЗнч(Форма) = Тип("Форма"); // Антибаг платформы https://www.hostedredmine.com/issues/923135 
	Иначе
		НужноОткрытьФорму = Не Форма.Открыта();
	КонецЕсли;
	Если НужноОткрытьФорму Тогда
		Форма.Открыть(); // В открытой форме платформа при этом тоже выполняет перерисовку табличных текущих страниц панелей формы
	Иначе
		Форма.Активизировать();
	КонецЕсли;

КонецПроцедуры

Функция _КонтрольРазмераВыборкиПользователемЛкс(ЗапросИлиПостроитель, МаксимальноеЧислоСтрок = 500000) Экспорт

	КоличествоСтрокРезультата = ирКэш.Получить().ПолучитьГрубоКоличествоСтрокВРезультатеЗапроса(ЗапросИлиПостроитель);
	Если Истина
		И ТипЗнч(КоличествоСтрокРезультата) = Тип("Число")
		И КоличествоСтрокРезультата > МаксимальноеЧислоСтрок 
	Тогда
		Кнопки = Новый СписокЗначений;
		Кнопки.Добавить("Все", "Все");
		Кнопки.Добавить("Часть", "Первые " + Формат(МаксимальноеЧислоСтрок, "ЧГ="));
		Ответ = Вопрос("Загружаемая таблица содержит " + КоличествоСтрокРезультата + " строк. Сколько строк загружать?", Кнопки, , "Часть");
		//Если Ответ <> КодВозвратаДиалога.ОК Тогда
		//	Возврат;
		//КонецЕсли;
		Если Ответ = "Все" Тогда
			МаксимальноеЧислоСтрок = 0;
		КонецЕсли;
	Иначе
		МаксимальноеЧислоСтрок = 0;
	КонецЕсли;
	Возврат МаксимальноеЧислоСтрок;

КонецФункции

Процедура ОбновитьСтатистикуПоТаблицеОбъектаМДВРезультатеПакетаЛкс(РезультатПакета, ПолноеИмяМД, ИмяКлючевойКолонки = "ПолноеИмяОбъекта", ИмяКолонкиКоличества = "КоличествоСтрок", ЛиТаблицыИзменений = Ложь,
	СтруктураОтбора = Неопределено, ТолькоРазрешенные = Истина) Экспорт
	
	ТекстЗапроса = ирОбщий.ПолучитьТекстЗапросаСтатистикиПоТаблицеЛкс(ПолноеИмяМД, ИмяКлючевойКолонки, ИмяКолонкиКоличества, ЛиТаблицыИзменений, СтруктураОтбора, ТолькоРазрешенные);
	Если Не ЗначениеЗаполнено(ТекстЗапроса) Тогда
		// В запрос попали только недоступные таблицы
		Возврат;
	КонецЕсли; 
	Запрос = Новый Запрос(ТекстЗапроса);
	Если СтруктураОтбора <> Неопределено Тогда
		ирОбщий.СкопироватьУниверсальнуюКоллекциюЛкс(СтруктураОтбора, Запрос.Параметры);
	КонецЕсли; 
	СтруктураКлюча = Новый Структура(ИмяКлючевойКолонки);
	КолонкиКоличества = Новый Массив();
	КолонкиКоличества.Добавить(ИмяКолонкиКоличества);
	Если ЛиТаблицыИзменений Тогда
		СтруктураКлюча.Вставить("Узел");
		КолонкиКоличества.Добавить("КоличествоВыгруженных");
		КолонкиКоличества.Добавить("КоличествоНевыгруженных");
	КонецЕсли; 
	СтатистикаПоТаблице = Запрос.Выполнить().Выгрузить();
	СтатистикаПоТаблице.Колонки.Добавить("Найдена", Новый ОписаниеТипов("булево"));
	Для Каждого ЭлементПакета Из РезультатПакета Цикл
		СтрокиРезультата = ЭлементПакета.НайтиСтроки(Новый Структура(ИмяКлючевойКолонки, ПолноеИмяМД));
		Если СтрокиРезультата.Количество() > 0 Тогда
			Для Каждого СтрокаРезультата Из СтрокиРезультата Цикл
				ЗаполнитьЗначенияСвойств(СтруктураКлюча, СтрокаРезультата); 
				Для Каждого ИмяКолонкиКоличества Из КолонкиКоличества Цикл
					СтрокаРезультата[ИмяКолонкиКоличества] = 0;
				КонецЦикла; 
				Для Каждого СтрокаСтатистики Из СтатистикаПоТаблице.НайтиСтроки(СтруктураКлюча) Цикл
					СтрокаСтатистики.Найдена = Истина;
					Для Каждого ИмяКолонкиКоличества Из КолонкиКоличества Цикл
						СтрокаРезультата[ИмяКолонкиКоличества] = СтрокаСтатистики[ИмяКолонкиКоличества];
					КонецЦикла; 
				КонецЦикла;
			КонецЦикла;
			Прервать;
		КонецЕсли; 
	КонецЦикла;
	Для Каждого СтрокаСтатистики Из СтатистикаПоТаблице.НайтиСтроки(Новый Структура("Найдена", Ложь)) Цикл
		СтрокаРезультата = ЭлементПакета.Добавить();
		ЗаполнитьЗначенияСвойств(СтрокаРезультата, СтрокаСтатистики);
	КонецЦикла;
	
КонецПроцедуры

Процедура ЗаполнитьКоличествоСтрокТаблицВДеревеМетаданныхЛкс(ДеревоМетаданных, РезультатПакета = Неопределено, ИмяКлючевойКолонки = "ПолноеИмяОбъекта",
	СуммируемыеКолонки = "КоличествоСтрок", СтруктураОтбора = Неопределено, КлючеваяКолонкаСодержитИмяТаблицы = Ложь) Экспорт
	
	#Если Сервер И Не Сервер Тогда
	    ДеревоМетаданных = Новый ДеревоЗначений
	#КонецЕсли
	ВсеСтрокиДерева = ирОбщий.ВсеСтрокиДереваЗначенийЛкс(ДеревоМетаданных);
	СтруктураСуммируемыхКолонок = Новый Структура(СуммируемыеКолонки);
	МассивСуммируемыхКолонок = Новый Массив();
	Для Каждого КлючИЗначение Из СтруктураСуммируемыхКолонок Цикл
		МассивСуммируемыхКолонок.Добавить(КлючИЗначение.Ключ);
	КонецЦикла; 
	Для Каждого СтрокаДерева Из ВсеСтрокиДерева Цикл
		Для Каждого ИмяСуммируемойКолонки Из МассивСуммируемыхКолонок Цикл
			СтрокаДерева[ИмяСуммируемойКолонки] = Неопределено;
		КонецЦикла;
	КонецЦикла;
	Если РезультатПакета = Неопределено Тогда
		ТаблицаКоличества = ирКэш.ТаблицаВсехТаблицБДЛкс();
		Если КлючеваяКолонкаСодержитИмяТаблицы Тогда
			ИмяКлючевойКолонкиИсточника = "ПолноеИмя";
		Иначе
			ИмяКлючевойКолонкиИсточника = "ПолноеИмяМД";
		КонецЕсли; 
		ИмяСуммируемойКолонки = "КоличествоСтрок";
	Иначе
		ИмяСуммируемойКолонки = МассивСуммируемыхКолонок[0];
		ИмяКлючевойКолонкиИсточника = ИмяКлючевойКолонки;
		Для Каждого ТаблицаРезультата Из РезультатПакета Цикл
			Для Каждого СтрокаРезультата Из ТаблицаРезультата Цикл
				Если ТаблицаКоличества = Неопределено Тогда
					ТаблицаКоличества = ТаблицаРезультата.СкопироватьКолонки();
					ТаблицаКоличества.Колонки.Удалить(ИмяКлючевойКолонкиИсточника);
					ТаблицаКоличества.Колонки.Добавить(ИмяКлючевойКолонкиИсточника); // Чтобы убрать ограничение на длину строки, которое может быть разным в результатах запросов пакета
				КонецЕсли;
				Если СтруктураОтбора <> Неопределено Тогда
					ПодходитФильтру = Истина;
					Для Каждого КлючИЗначение Из СтруктураОтбора Цикл
						ЗначениеРезультата = СтрокаРезультата[КлючИЗначение.Ключ];
						Если ТипЗнч(КлючИЗначение.Значение) = Тип("Массив") Тогда
							Если КлючИЗначение.Значение.Найти(ЗначениеРезультата) = Неопределено Тогда
								ПодходитФильтру = Ложь;
								Прервать;
							КонецЕсли; 
						Иначе 
							Если КлючИЗначение.Значение <> ЗначениеРезультата Тогда
								ПодходитФильтру = Ложь;
								Прервать;
							КонецЕсли; 
						КонецЕсли; 
					КонецЦикла; 
					Если Не ПодходитФильтру Тогда
						Продолжить;
					КонецЕсли; 
				КонецЕсли; 
				ЗаполнитьЗначенияСвойств(ТаблицаКоличества.Добавить(), СтрокаРезультата); 
			КонецЦикла;
		КонецЦикла;
	КонецЕсли; 
	Если ТаблицаКоличества <> Неопределено Тогда
		#Если Сервер И Не Сервер Тогда
			ТаблицаКоличества = Новый ТаблицаЗначений;
		#КонецЕсли
		//Для Каждого СтрокаКоличества Из ТаблицаКоличества Цикл
		//	Если СтрокаКоличества[ИмяСуммируемойКолонки] = Неопределено Тогда
		//		Продолжить;
		//	КонецЕсли; 
		//	СтрокаДерева = ДеревоМетаданных.Строки.Найти(СтрокаКоличества[ИмяКлючевойКолонкиИсточника], ИмяКлючевойКолонки, Истина);
		//	Если СтрокаДерева <> Неопределено Тогда
		//		Для Каждого ИмяСуммируемойКолонки Из МассивСуммируемыхКолонок Цикл
		//			ДобавитьКоличествоСтрокСРодителемЛкс(СтрокаДерева, СтрокаКоличества[ИмяСуммируемойКолонки], ИмяСуммируемойКолонки);
		//		КонецЦикла; 
		//	КонецЕсли; 
		//КонецЦикла;
		ирОбщий.ДобавитьИндексВТаблицуЛкс(ТаблицаКоличества, ИмяКлючевойКолонкиИсточника);
		ИменаСуммируемыхКолонок = ирОбщий.СтрСоединитьЛкс(МассивСуммируемыхКолонок);
		Для Каждого СтрокаДерева Из ВсеСтрокиДерева Цикл
			СтрокаКоличества = ТаблицаКоличества.Скопировать(Новый Структура(ИмяКлючевойКолонкиИсточника, СтрокаДерева[ИмяКлючевойКолонки]), ИменаСуммируемыхКолонок);
			Если СтрокаКоличества.Количество() > 0 Тогда
				СтрокаКоличества.Свернуть(, ИменаСуммируемыхКолонок);
				СтрокаКоличества = СтрокаКоличества[0];
				Если СтрокаКоличества[ИмяСуммируемойКолонки] <> Неопределено Тогда 
					Для Каждого ИмяКолонкиЦикл Из МассивСуммируемыхКолонок Цикл
						ДобавитьКоличествоСтрокСРодителемЛкс(СтрокаДерева, СтрокаКоличества[ИмяКолонкиЦикл], ИмяКолонкиЦикл);
					КонецЦикла; 
				КонецЕсли;
			КонецЕсли; 
		КонецЦикла;
	КонецЕсли; 

КонецПроцедуры

Процедура ДобавитьКоличествоСтрокСРодителемЛкс(Знач СтрокаДерева, Знач ДобавкаККоличеству, Знач ИмяСуммируемойКолонки = "КоличествоСтрок") Экспорт
	
	СтароеКоличество = СтрокаДерева[ИмяСуммируемойКолонки];
	Если СтароеКоличество = Неопределено Тогда
		СтароеКоличество = 0;
	КонецЕсли; 
	Если ТипЗнч(ДобавкаККоличеству) = Тип("Число") Тогда
		НовоеКоличество = ?(ТипЗнч(СтрокаДерева[ИмяСуммируемойКолонки]) <> Тип("Число"), 0, СтрокаДерева[ИмяСуммируемойКолонки]) + ДобавкаККоличеству;
	Иначе
		НовоеКоличество = "?";
	КонецЕсли; 
	СтрокаДерева[ИмяСуммируемойКолонки] = НовоеКоличество;
	Если СтрокаДерева.Уровень() > 1 Тогда
		Возврат;
	КонецЕсли; 
	Родитель = СтрокаДерева.Родитель;
	Пока Родитель <> Неопределено Цикл
		Если ТипЗнч(НовоеКоличество) <> Тип("Число") Тогда
			Родитель[ИмяСуммируемойКолонки] = "?";
		КонецЕсли; 
		КоличествоРодителя = Родитель[ИмяСуммируемойКолонки];
		Если КоличествоРодителя = "?" Тогда
			Прервать;
		КонецЕсли; 
		Если ТипЗнч(КоличествоРодителя) <> Тип("Число") Тогда
			КоличествоРодителя = 0;
		КонецЕсли; 
		Родитель[ИмяСуммируемойКолонки] = КоличествоРодителя - СтароеКоличество + НовоеКоличество;
		Родитель = Родитель.Родитель;
	КонецЦикла;

КонецПроцедуры 

Процедура ОбновитьКоличествоСтрокТаблицВДеревеМетаданныхЛкс(ДеревоМетаданных, ИмяКлючевойКолонки = "ПолноеИмяОбъекта", ИмяКолонкиКоличества = "КоличествоСтрок",
	ЛиТаблицыИзменений = Ложь, СтруктураОтбора = Неопределено) Экспорт
	
	#Если Сервер И Не Сервер Тогда
	    ДеревоМетаданных = Новый ДеревоЗначений
	#КонецЕсли
	РезультатПакета = ирОбщий.ВычислитьКоличествоСтрокТаблицВДеревеМетаданныхЛкс(ДеревоМетаданных, ИмяКлючевойКолонки, ИмяКолонкиКоличества, ЛиТаблицыИзменений, СтруктураОтбора);
	ЗаполнитьКоличествоСтрокТаблицВДеревеМетаданныхЛкс(ДеревоМетаданных, РезультатПакета, ИмяКлючевойКолонки, ИмяКолонкиКоличества);

КонецПроцедуры

Процедура УстановитьЗначениеКолонкиДереваЛкс(ДеревоЗначений, ИмяКолонки = "Пометка", НовоеЗначение = Истина) Экспорт
	
	ВсеСтроки = ирОбщий.ВсеСтрокиДереваЗначенийЛкс(ДеревоЗначений);
	Для Каждого СтрокаДерева Из ВсеСтроки Цикл
		СтрокаДерева.Пометка = НовоеЗначение;
	КонецЦикла; 

КонецПроцедуры

// НовыйРежим - Булево - Имя/Синоним
Процедура ТабличноеПолеОбновитьКолонкиИмяСинонимЛкс(ТабличноеПоле, НовыйРежим, ИмяКолонкиИмя = "Имя", ИмяКолонкиСиноним = "Представление") Экспорт

	#Если Сервер И Не Сервер Тогда
		ТабличноеПоле = Новый ТабличноеПоле;
	#КонецЕсли
	КолонкиТП = ТабличноеПоле.Колонки;
	КолонкаИмя = КолонкиТП[ИмяКолонкиИмя];
	КолонкаСиноним = КолонкиТП[ИмяКолонкиСиноним];
	КолонкаИмя.Видимость = НовыйРежим;
	КолонкаСиноним.Видимость = Не НовыйРежим;
	Если ТипЗнч(ТабличноеПоле.Значение) = Тип("ДеревоЗначений") Тогда
		КолонкаИмя.ОтображатьИерархию = НовыйРежим;
		КолонкаСиноним.ОтображатьИерархию = Не НовыйРежим;
	КонецЕсли;
	ИндексКолонкиИмя = КолонкиТП.Индекс(КолонкаИмя);
	ИндексКолонкиСиноним = КолонкиТП.Индекс(КолонкаСиноним);
	Если НовыйРежим = (ИндексКолонкиИмя > ИндексКолонкиСиноним) Тогда
		КолонкиТП.Сдвинуть(КолонкаИмя, ИндексКолонкиСиноним - ИндексКолонкиИмя);
	КонецЕсли; 
	Если НовыйРежим Тогда
		ТабличноеПоле.ТекущаяКолонка = ТабличноеПоле.Колонки.Имя;
	Иначе
		ТабличноеПоле.ТекущаяКолонка = ТабличноеПоле.Колонки.Представление;
	КонецЕсли;

КонецПроцедуры

Процедура ТабличноеПолеОформитьЯчейкиИмяСинонимЛкс(ТабличноеПоле, ОформлениеСтроки,
	ИмяКолонкиИмя = "Имя", ИмяКолонкиСиноним = "Представление", ИмяКолонкиИндексКартинки = "ИндексКартинки", ДанныеФлажка = "") Экспорт

	#Если Сервер И Не Сервер Тогда
		ТабличноеПоле = Новый ТабличноеПоле;
	#КонецЕсли
	ДанныеСтроки = ОформлениеСтроки.ДанныеСтроки;
	Если ДанныеСтроки = Неопределено Тогда
		// Свернутое табличное поле может такое присылать
		Возврат;
	КонецЕсли; 
	Если ТабличноеПоле.Колонки[ИмяКолонкиИмя].Видимость Тогда
		ВедущаяКолонка = ТабличноеПоле.Колонки[ИмяКолонкиИмя];
		ВедущийИндекс = ТабличноеПоле.Колонки.Индекс(ВедущаяКолонка);
	КонецЕсли; 
	Если ТабличноеПоле.Колонки[ИмяКолонкиСиноним].Видимость Тогда
		Если Ложь
			Или ВедущаяКолонка = Неопределено 
			Или ТабличноеПоле.Колонки.Индекс(ТабличноеПоле.Колонки[ИмяКолонкиСиноним]) < ВедущийИндекс
		Тогда
			ВедущаяКолонка = ТабличноеПоле.Колонки[ИмяКолонкиСиноним];
		КонецЕсли; 
	КонецЕсли;
	Если ВедущаяКолонка <> Неопределено Тогда
		Ячейка = ОформлениеСтроки.Ячейки[ВедущаяКолонка.Имя];
		Если ЗначениеЗаполнено(ИмяКолонкиИндексКартинки) Тогда
			ИндексКартинки = ДанныеСтроки[ИмяКолонкиИндексКартинки];
			Если ИндексКартинки >= 0 Тогда
				Ячейка.ОтображатьКартинку = Истина;
				Ячейка.ИндексКартинки = ИндексКартинки;
			КонецЕсли; 
		КонецЕсли; 
		Если ДанныеФлажка <> "" Тогда
			Ячейка.ОтображатьФлажок = Истина;
			Ячейка.Флажок = ДанныеСтроки[ДанныеФлажка];
		КонецЕсли;
		Если ТипЗнч(ДанныеСтроки) = Тип("СтрокаДереваЗначений") Тогда
			КоличествоДочерних = ДанныеСтроки.Строки.Количество();
			Если КоличествоДочерних > 0 Тогда
				Ячейка.УстановитьТекст(Ячейка.Текст + " (" + КоличествоДочерних + ")");
			КонецЕсли; 
		КонецЕсли;
	КонецЕсли; 

КонецПроцедуры

Функция ТабличноеПолеПозицияТекущейСтрокиЛкс(Знач ТабличноеПоле) Экспорт 
	
	#Если Сервер И Не Сервер Тогда
		ТабличноеПоле = Новый ТабличноеПоле;
	#КонецЕсли
	СтарыйИндекс = Неопределено;
	Если ТабличноеПоле.ТекущаяСтрока <> Неопределено Тогда
		СтарыйИндекс = ТабличноеПоле.Значение.Индекс(ТабличноеПоле.ТекущаяСтрока);
	КонецЕсли;
	Возврат СтарыйИндекс;

КонецФункции

Процедура ПолеВводаРоли_НачалоВыбораЛкс(Элемент, СтандартнаяОбработка) Экспорт 
	
	Если ТипЗнч(Элемент.Значение) = Тип("СписокЗначений") Тогда
		//Заголовок = "Выберите роли";
		МножественныйВыбор = Истина;
	Иначе
		//Заголовок = "Выберите роль";
		МножественныйВыбор = Ложь;
	КонецЕсли; 
	СтандартнаяОбработка = Ложь;
	//СписокВыбора = Новый СписокЗначений;
	//СписокВыбора.ТипЗначения = Новый ОписаниеТипов("Строка");
	//Для Каждого РольЛ Из Метаданные.Роли Цикл
	//	#Если Сервер И Не Сервер Тогда
	//		РольЛ = Метаданные.Роли.Пользователь;
	//	#КонецЕсли
	//	НовыйЭлемент = СписокВыбора.Добавить(РольЛ.Имя, РольЛ.Представление());
	//	Если МножественныйВыбор Тогда
	//		НовыйЭлемент.Пометка = Элемент.Значение.НайтиПоЗначению(РольЛ.Имя) <> Неопределено;
	//		Если НовыйЭлемент.Пометка Тогда
	//			НачальныйВыбор = НовыйЭлемент;
	//		КонецЕсли; 
	//	Иначе
	//		Если РольЛ.Имя = Элемент.Значение Тогда
	//			НачальныйВыбор = НовыйЭлемент;
	//		КонецЕсли; 
	//	КонецЕсли; 
	//КонецЦикла;
	СписокИмен = Новый СписокЗначений;
	Префикс = "Роль";
	Если МножественныйВыбор Тогда
		НачальныйВыбор = Новый Массив;
		Для Каждого ЭлементСписка Из Элемент.Значение Цикл
			НачальныйВыбор.Добавить(Префикс + "." + ЭлементСписка.Значение);
		КонецЦикла;
	Иначе
		НачальныйВыбор = Префикс + "." + Элемент.Значение;
	КонецЕсли; 
	//РезультатВыбора = ВыбратьЭлементСпискаЗначенийЛкс(СписокВыбора, НачальныйВыбор, Истина, Заголовок, МножественныйВыбор);
	ФормаВыбораОбъектаБД = ФормаВыбораОбъектаМетаданныхЛкс(,, НачальныйВыбор, МножественныйВыбор,,,,,,,,,,,,,,,,,, Истина);
	РезультатВыбора = ФормаВыбораОбъектаБД.ОткрытьМодально();
	
	Если РезультатВыбора <> Неопределено Тогда
		Если МножественныйВыбор Тогда
			СписокИмен = Новый СписокЗначений;
			Для Каждого ВыбранныйЭлемент Из РезультатВыбора Цикл
				//СписокИмен.Добавить(ВыбранныйЭлемент.Значение);
				СписокИмен.Добавить(ирОбщий.ПоследнийФрагментЛкс(ВыбранныйЭлемент));
			КонецЦикла;
			РезультатВыбора = СписокИмен;
		Иначе
			//РезультатВыбора = РезультатВыбора.Значение;
			РезультатВыбора = ирОбщий.ПоследнийФрагментЛкс(РезультатВыбора.ПолноеИмяОбъекта);
		КонецЕсли; 
		ИнтерактивноЗаписатьВПолеВводаЛкс(Элемент, РезультатВыбора);
	КонецЕсли;

КонецПроцедуры

Процедура ПолеВводаПользователя_НачалоВыбораЛкс(Элемент, СтандартнаяОбработка) Экспорт 
	
	СтандартнаяОбработка = Ложь;
	Если Не ПравоДоступа("Администрирование", Метаданные) Тогда
		ирОбщий.СообщитьЛкс("Из-за отстуствия права ""Администрирование"" просмотр списка пользователей не доступен");
		РезультатВыбора = ИмяПользователя();
	Иначе
		ФормаВыбора = ПолучитьФормуЛкс("Обработка.ирРедакторПользователей.Форма",, Элемент);
		ФормаВыбора.РежимВыбора = Истина;
		ФормаВыбора.НачальноеЗначениеВыбора = Элемент.Значение;
		РезультатВыбора = ФормаВыбора.ОткрытьМодально();
	КонецЕсли;
	Если РезультатВыбора <> Неопределено Тогда
		ИнтерактивноЗаписатьВПолеВводаЛкс(Элемент, РезультатВыбора);
	КонецЕсли;

КонецПроцедуры

Процедура ПолеВводаПользователяОСНачалоВыбораЛкс(Знач Элемент, СтандартнаяОбработка, ДобавлятьЛидирующиеСлеши = Ложь) Экспорт 
	
	СтандартнаяОбработка = Ложь;
	НачальноеЗначение = Элемент.Значение;
	НачальноеЗначение = СтрЗаменить(НачальноеЗначение, ".\", "\\" + ИмяКомпьютера() + "\");
	Маркер = "\\";
	Если Не ирОбщий.СтрНачинаетсяСЛкс(НачальноеЗначение, Маркер) Тогда
		НачальноеЗначение = Маркер + НачальноеЗначение;
	КонецЕсли; 
	ФормаВыбораПользователяWindows = ирКэш.Получить().ПолучитьФорму("ВыборПользователяWindows",, Элемент);
	ФормаВыбораПользователяWindows.ВыбранныйПользовательWindows = НачальноеЗначение;
	Результат = ФормаВыбораПользователяWindows.ОткрытьМодально();
	Если Результат <> Неопределено Тогда
		Если Не ДобавлятьЛидирующиеСлеши И ирОбщий.СтрНачинаетсяСЛкс(Результат, Маркер) Тогда
			Результат = Сред(Результат, СтрДлина(Маркер) + 1);
		КонецЕсли; 
		//Результат = СтрЗаменить(Результат, ИмяКомпьютера() + "\", ".\");
		ИнтерактивноЗаписатьВПолеВводаЛкс(Элемент, Результат);
	КонецЕсли;

КонецПроцедуры

Процедура ПолеВводаСтрокиСоединенияADODBНачалоВыбораЛкс(Знач Элемент, СтандартнаяОбработка) Экспорт 
	
	СтандартнаяОбработка = Ложь;
	СоединениеADO = Новый COMОбъект("ADODB.Connection");
	СоединениеADO.ConnectionString = Элемент.Значение;
	ДатаЛинк = Новый COMОбъект("DataLinks");
	Если ДатаЛинк.PromptEdit(СоединениеADO) Тогда
		ИнтерактивноЗаписатьВПолеВводаЛкс(Элемент, СоединениеADO.ConnectionString);
	КонецЕсли;

КонецПроцедуры

Функция ОпределитьВедущуюСтроковуюКолонкуТабличногоПоляЛкс(ТабличноеПолеДерева) Экспорт
	
	Если Истина
		И ТабличноеПолеДерева.ТекущаяКолонка <> Неопределено
		И ЗначениеЗаполнено(ТабличноеПолеДерева.ТекущаяКолонка.Данные)
		И ТабличноеПолеДерева.Значение.Колонки[ТабличноеПолеДерева.ТекущаяКолонка.Данные].ТипЗначения.СодержитТип(Тип("Строка"))
	Тогда
		ТекущаяКолонкаТП = ТабличноеПолеДерева.ТекущаяКолонка;
	Иначе
		Для Каждого КолонкаТП Из ТабличноеПолеДерева.Колонки Цикл
			Если Не КолонкаТП.Видимость Тогда
				Продолжить;
			КонецЕсли; 
			КолонкаДерева = ТабличноеПолеДерева.Значение.Колонки[КолонкаТП.Данные];
			Если КолонкаДерева.ТипЗначения.СодержитТип(Тип("Строка")) Тогда
				ТекущаяКолонкаТП = КолонкаТП;
				Прервать;
			КонецЕсли; 
		КонецЦикла;
	КонецЕсли; 
	Возврат ТекущаяКолонкаТП; 
	
КонецФункции

Функция _НайтиСтрокуТабличногоПоляДереваЗначенийСоСложнымФильтромЛкс(ТабличноеПолеДерева, ПолеВводаФильтра, Подстроки = "") Экспорт
	
	ТекущаяКолонкаТП = ОпределитьВедущуюСтроковуюКолонкуТабличногоПоляЛкс(ТабличноеПолеДерева);
	Если ТекущаяКолонкаТП = Неопределено Тогда
		Возврат Неопределено;
	КонецЕсли; 
	ИмяТекущейКолонки = ТекущаяКолонкаТП.Данные;
	Если Не ЗначениеЗаполнено(ИмяТекущейКолонки) Тогда
		Возврат Неопределено;
	КонецЕсли; 
	ВсеСтроки = ирОбщий.ВсеСтрокиДереваЗначенийЛкс(ТабличноеПолеДерева.Значение);
	ТекущаяСтрока = ТабличноеПолеДерева.ТекущаяСтрока;
	Если Подстроки = "" Тогда
		Подстроки = ПолеВводаФильтра.Значение;
	КонецЕсли; 
	Фрагменты = ирОбщий.СтрРазделитьЛкс(НРег(Подстроки), " ", Истина);
	ИндексСтроки = 0;
	Если ТекущаяСтрока <> Неопределено Тогда
		Если ирОбщий.ЛиСтрокаСодержитВсеПодстрокиЛкс(ТекущаяСтрока[ИмяТекущейКолонки], Фрагменты) Тогда
			ИндексСтроки = ВсеСтроки.Найти(ТекущаяСтрока) + 1;
		КонецЕсли; 
	КонецЕсли; 
	Успех = Ложь;
	Для ИндексСтроки = ИндексСтроки По ВсеСтроки.Количество() - 1 Цикл
		ТекущаяСтрока = ВсеСтроки[ИндексСтроки];
		Если ирОбщий.ЛиСтрокаСодержитВсеПодстрокиЛкс(ТекущаяСтрока[ИмяТекущейКолонки], Фрагменты) Тогда
			ТабличноеПолеДерева.ТекущаяСтрока = ТекущаяСтрока;
			ТабличноеПолеДерева.ТекущаяКолонка = ТекущаяКолонкаТП;
			Успех = Истина;
			Прервать;
		КонецЕсли; 
	КонецЦикла;
	Если Успех Тогда
		ПолеВводаФильтра.ЦветФонаПоля = Новый Цвет();
	Иначе
		ТекущаяСтрока = Неопределено;
		ПолеВводаФильтра.ЦветФонаПоля = ирОбщий.ЦветСтиляЛкс("ирЦветФонаОшибки");
	КонецЕсли;
	Возврат ТекущаяСтрока;
	
КонецФункции

Процедура ВыделитьСтрокиТабличногоПоляПоКлючуЛкс(ТабличноеПоле, СтруктураИлиСтрокаТаблицы, Знач СтрокаКлюча = "", Сортировать = Истина) Экспорт 
	
	Если СтруктураИлиСтрокаТаблицы = Неопределено Тогда
		Возврат;
	КонецЕсли; 
	#Если Сервер И Не Сервер Тогда
		СтруктураИлиСтрокаТаблицы = Новый Структура;
	#КонецЕсли
	Если Не ЗначениеЗаполнено(СтрокаКлюча) Тогда
		СтрокаКлюча = ирОбщий.ИменаСвойствСтруктурыЛкс(СтруктураИлиСтрокаТаблицы);
	КонецЕсли; 
	КлючПоиска = Новый Структура(СтрокаКлюча);
	ЗаполнитьЗначенияСвойств(КлючПоиска, СтруктураИлиСтрокаТаблицы); 
	КоллекцияСтрок = ТабличноеПоле.Значение;
	Если ТипЗнч(КоллекцияСтрок) = Тип("ДеревоЗначений") Тогда
		КоллекцияСтрок = КоллекцияСтрок.Строки;
	КонецЕсли; 
	Если ЗначениеЗаполнено(СтрокаКлюча) И Сортировать Тогда
		Если ПредупреждениеПередСортировкойПоСсылочнымКолонкамЛкс(СтрокаКлюча, ТабличноеПоле) Тогда
			КоллекцияСтрок.Сортировать(СтрокаКлюча);
		КонецЕсли; 
	КонецЕсли; 
	ТабличноеПоле.ВыделенныеСтроки.Очистить();
	ТекущаяСтрокаУстановлена = Ложь;
	Если ТипЗнч(КоллекцияСтрок) = Тип("КоллекцияСтрокДереваЗначений") Тогда
		НайденныеСтроки = КоллекцияСтрок.НайтиСтроки(КлючПоиска, Истина);
	Иначе
		НайденныеСтроки = КоллекцияСтрок.НайтиСтроки(КлючПоиска);
	КонецЕсли; 
	Для Каждого НайденнаяСтрока Из НайденныеСтроки Цикл
		ТабличноеПоле.ВыделенныеСтроки.Добавить(НайденнаяСтрока);
		Если Не ТекущаяСтрокаУстановлена Тогда
			ТабличноеПоле.ТекущаяСтрока = НайденнаяСтрока;
			ТекущаяСтрокаУстановлена = Истина;
		КонецЕсли; 
	КонецЦикла;
	//ТабличноеПоле.ОбновитьСтроки();

КонецПроцедуры

Процедура ТабличноеПолеДеревоЗначений_РазвернутьВсеСтрокиЛкс(ТабличноеПоле, ЧислоПервыхИгнорируемыхСтрок = 0) Экспорт
	
	Счетчик = 0;
	Для Каждого Строка Из ТабличноеПоле.Значение.Строки Цикл
		Счетчик = Счетчик + 1;
		Если Счетчик > ЧислоПервыхИгнорируемыхСтрок Тогда
			ТабличноеПоле.Развернуть(Строка, Истина);
		КонецЕсли; 
	КонецЦикла;
	
КонецПроцедуры

Процедура ТабличноеПолеДеревоЗначений_СвернутьВсеСтрокиЛкс(ТабличноеПоле, ВосстановитьТекущуюСтроку = Ложь) Экспорт
	
	#Если Сервер И Не Сервер Тогда
		ТабличноеПоле = Новый ТабличноеПоле;
	#КонецЕсли
	МассивТекущихУзлов = Новый Массив;
	ТекущаяСтрока = ТабличноеПоле.ТекущаяСтрока;
	Пока ТекущаяСтрока <> Неопределено Цикл
		МассивТекущихУзлов.Добавить(ТекущаяСтрока);
		ТекущаяСтрока = ТекущаяСтрока.Родитель;
	КонецЦикла;
	Если Не ВосстановитьТекущуюСтроку Тогда
		ТабличноеПоле.ТекущаяСтрока = МассивТекущихУзлов[МассивТекущихУзлов.ВГраница()];
		МассивТекущихУзлов.Очистить();
	КонецЕсли;
	ВсеСтрокиДерева = ирОбщий.ВсеСтрокиДереваЗначенийЛкс(ТабличноеПоле.Значение);
	Индикатор = ирОбщий.ПолучитьИндикаторПроцессаЛкс(ВсеСтрокиДерева.Количество());
	Для Каждого СтрокаДерева Из ВсеСтрокиДерева Цикл
		ирОбщий.ОбработатьИндикаторЛкс(Индикатор);
		Если Истина
			И ТабличноеПоле.Развернут(СтрокаДерева) 
			И СтрокаДерева.Строки.Количество() > 0 
			И МассивТекущихУзлов.Найти(СтрокаДерева) = Неопределено 
		Тогда
			ТабличноеПоле.Свернуть(СтрокаДерева);
		КонецЕсли; 
	КонецЦикла;
	ирОбщий.ОсвободитьИндикаторПроцессаЛкс();
	
КонецПроцедуры

// Изменяет свернутость строк табличного поля дерева значений.
//
// Параметры:
//  Дерево   - ТабличноеПоле - связанное с деревом значений и включенным режимом "Дерево";
//  Свернуть - Булево, *Истина - новое значение свернутости
//  Строки   - СтрокиДереваЗначений, *Неопределено - если Неопределено, то обрабатываются все строки дерева
//
Процедура ДеревоЗначенийСвернутьРазвернутьЛкс(Дерево, Свернуть = Ложь, Строки = Неопределено, СПодчиненными = Истина) Экспорт
	
	Если Свернуть Тогда
		ПредставлениеПроцесса = "Сворачиваем строки дерева";
	Иначе
		ПредставлениеПроцесса = "Разворачиваем строки дерева";
	КонецЕсли; 
	Если Строки = Неопределено Тогда
		Строки = Дерево.Значение.Строки;
	КонецЕсли; 
	Индикатор = ирОбщий.ПолучитьИндикаторПроцессаЛкс(Строки.Количество(), ПредставлениеПроцесса);
	Для Каждого СтрокаДерева Из Строки Цикл
		ирОбщий.ОбработатьИндикаторЛкс(Индикатор);
		Если Истина
			И Свернуть 
			И Дерево.Развернут(СтрокаДерева)
		Тогда
			Дерево.Свернуть(СтрокаДерева);
		ИначеЕсли Истина 
			И Не Свернуть
			И Не Дерево.Развернут(СтрокаДерева)
		Тогда
			Дерево.Развернуть(СтрокаДерева, СПодчиненными);
		КонецЕсли;
	КонецЦикла;
	ирОбщий.ОсвободитьИндикаторПроцессаЛкс(Индикатор);
	
КонецПроцедуры

Процедура ТабличноеПолеДеревоЗначений_АвтоРазвернутьВсеСтрокиЛкс(ТабличноеПоле, МаксимальноеЧислоСтрок = 30, ТекущаяСтрокаУстановлена = Ложь) Экспорт
	
	ВсеСтроки = ирОбщий.ВсеСтрокиДереваЗначенийЛкс(ТабличноеПоле.Значение);
	ЧислоДинамическихСтрок = ВсеСтроки.Количество();
	Если ЧислоДинамическихСтрок > 0 Тогда
		Если ЧислоДинамическихСтрок <= МаксимальноеЧислоСтрок Тогда
			ТабличноеПолеДеревоЗначений_РазвернутьВсеСтрокиЛкс(ТабличноеПоле);
			Если Не ТекущаяСтрокаУстановлена Тогда
				ТабличноеПоле.ТекущаяСтрока = ТабличноеПоле.Значение.Строки[0].Строки[0];
			КонецЕсли; 
		Иначе
			Если Не ТекущаяСтрокаУстановлена Тогда
				ТабличноеПоле.ТекущаяСтрока = ТабличноеПоле.Значение.Строки[0];
				Если ТабличноеПоле.Значение.Строки.Количество() = 1 Тогда
					ТабличноеПоле.Развернуть(ТабличноеПоле.ТекущаяСтрока);
				КонецЕсли; 
			КонецЕсли; 
		КонецЕсли; 
	КонецЕсли; 
	
КонецПроцедуры

Процедура ТабличноеПолеРезультатаЗапросаНастроитьКолонкиЛкс(Знач ТабличноеПолеРезультата, Знач СтарыеКолонкиТабличногоПоля = Неопределено, Знач ШиринаПустойКолонки = Неопределено,
	МаксКоличествоСтрокДляАнализа = 10000, Знач ТолькоПросмотр = Истина) Экспорт 
	
	#Если Сервер И Не Сервер Тогда
		ТабличноеПолеРезультата = Новый ТабличноеПоле;
	#КонецЕсли
	МинимальнаяШиринаКолонки = ирОбщий.МинимальнаяШиринаКолонкиЛкс();
	Если ШиринаПустойКолонки = Неопределено Тогда
		ШиринаПустойКолонки = МинимальнаяШиринаКолонки;
	КонецЕсли;
	Если ТипЗнч(ТабличноеПолеРезультата.Значение) = Тип("ДеревоЗначений") Тогда
		// КоличествоСтрокВТаблице = ирОбщий.ВсеСтрокиДереваЗначенийЛкс(ТабличноеПолеРезультата.Значение); // Долго
		КоличествоСтрокВТаблице = 10000000;
	Иначе
		КоличествоСтрокВТаблице = ТабличноеПолеРезультата.Значение.Количество();
	КонецЕсли;
	ВыполнятьАнализДанных = КоличествоСтрокВТаблице < МаксКоличествоСтрокДляАнализа;
	Для Каждого Колонка Из ТабличноеПолеРезультата.Колонки Цикл
		ДанныеКолонки = Колонка.Данные;
		Если Не ЗначениеЗаполнено(ДанныеКолонки) Тогда
			ДанныеКолонки = Колонка.ДанныеФлажка; // Здесь по крайней мере в 8.3 уже всегда пусто
		КонецЕсли; 
		Если Не ЗначениеЗаполнено(ДанныеКолонки) Тогда
			Продолжить;
		КонецЕсли;
		Если ТолькоПросмотр <> Неопределено Тогда
			Колонка.ТолькоПросмотр = ТолькоПросмотр;
		КонецЕсли;
		//Колонка.Формат = "ЧН="; 
		КолонкаТЗ = ТабличноеПолеРезультата.Значение.Колонки[ДанныеКолонки];
		Если СтарыеКолонкиТабличногоПоля <> Неопределено Тогда
			СохраненныеНастройкиКолонки = СтарыеКолонкиТабличногоПоля[КлючХраненияНастроекКолонкиРезультатаЗапросаЛкс(ТабличноеПолеРезультата, Колонка)];
		КонецЕсли; 
		Если СохраненныеНастройкиКолонки <> Неопределено Тогда
			Колонка.Ширина = СохраненныеНастройкиКолонки.Ширина;
			Колонка.АвтоВысотаЯчейки = СохраненныеНастройкиКолонки.АвтоВысотаЯчейки;
			Колонка.ВысотаЯчейки = СохраненныеНастройкиКолонки.ВысотаЯчейки;
		Иначе
			Если Истина
				И КолонкаТЗ.ТипЗначения.СодержитТип(Тип("Строка"))
				И (Ложь
					Или КолонкаТЗ.ТипЗначения.КвалификаторыСтроки.Длина = 0 
					Или КолонкаТЗ.ТипЗначения.КвалификаторыСтроки.Длина > 50)
			Тогда
				Колонка.Ширина = 50;
			ИначеЕсли Колонка.ИзменениеРазмера = ИзменениеРазмераКолонки.Изменять Тогда 
				Колонка.Ширина = Макс(Колонка.Ширина, МинимальнаяШиринаКолонки);
			КонецЕсли; 
		КонецЕсли;
		Если ВыполнятьАнализДанных Тогда
			ОписаниеТиповБезNull = Новый ОписаниеТипов(КолонкаТЗ.ТипЗначения, , "NUll");
			ПустыеСтрокиБезNUll = ТабличноеПолеРезультата.Значение.НайтиСтроки(Новый Структура(ДанныеКолонки, ОписаниеТиповБезNull.ПривестиЗначение()));
			ПустыеСтрокиNull = ТабличноеПолеРезультата.Значение.НайтиСтроки(Новый Структура(ДанныеКолонки, Null));
			Если ПустыеСтрокиБезNUll.Количество() + ПустыеСтрокиNull.Количество() = КоличествоСтрокВТаблице Тогда
				Колонка.Ширина = ШиринаПустойКолонки;
			КонецЕсли; 
		КонецЕсли; 
	КонецЦикла;

КонецПроцедуры

Функция _БезопасноеОписаниеТиповЛкс(ОписаниеТипов) Экспорт 
	#Если Сервер И Не Сервер Тогда
		ОписаниеТипов = Новый ОписаниеТипов;
	#КонецЕсли
	Типы = ОписаниеТипов.Типы();
	Если Типы.Количество() > 0 Тогда
		ПростойТип = Типы[0];
		Если Истина
			И Типы.Количество() = 1
			//// Антибаг платформы 8.2.15 http://partners.v8.1c.ru/forum/thread.jsp?id=1015693#1015693
			//И (Ложь
			//	Или ПростойТип = Тип("КоллекцияАтрибутовDOM")
			//	Или ПростойТип = Тип("ДокументDOM")
			//	Или ПростойТип = Тип("СписокУзловDOM")
			//	Или ПростойТип = Тип("АтрибутDOM")
			//	Или ПростойТип = Тип("ТипУзлаDOM")
			//	Или ПростойТип = Тип("ЭлементDOM")
			//	Или ПростойТип = Тип("КонфигурацияДокументаDOM")
			//	Или ПростойТип = Тип("ОпределениеТипаДокументаDOM")
			//	Или ПростойТип = Тип("КоллекцияНотацийDOM")
			//	Или ПростойТип = Тип("КоллекцияСущностейDOM")
			//	Или ПростойТип = Тип("ТипЗначенияXDTO")
			//	Или ПростойТип = Тип("ТипОбъектаXDTO")
			//	// Эти актуальны и в 8.3.18
			//	Или ПростойТип = Тип("ЗначениеXDTO")
			//	Или ПростойТип = Тип("ПакетXDTO"))
		Тогда
			ВсеРедактируемыеТипы = ирОбщий.ОписаниеТиповВсеРедактируемыеТипыЛкс();
			#Если Сервер И Не Сервер Тогда
				ВсеРедактируемыеТипы = Новый ОписаниеТипов;
			#КонецЕсли
			Если Не ВсеРедактируемыеТипы.СодержитТип(Типы[0]) Тогда
				// Антибаг платформы 8.2-8.3.6 https://partners.v8.1c.ru/forum/t/1401671/m/1401671
				ОписаниеТипов = Новый ОписаниеТипов;
			КонецЕсли; 
		КонецЕсли; 
	КонецЕсли; 
	Возврат ОписаниеТипов;
КонецФункции

Функция КлючХраненияНастроекКолонкиРезультатаЗапросаЛкс(Знач ТабличноеПолеРезультата, Знач СтараяКолонкаТП) Экспорт 
	
	#Если Сервер И Не Сервер Тогда
		ТабличноеПолеРезультата = Новый ТабличноеПоле;
	#КонецЕсли
	СтараяКолонкаТЗ = ТабличноеПолеРезультата.Значение.Колонки[СтараяКолонкаТП.Имя];
	Возврат СтараяКолонкаТП.Имя + " // " + Лев(СтараяКолонкаТЗ.ТипЗначения, 300);

КонецФункции

Функция ТабличноеПолеСортироватьЛкс(ЭтаФорма, ТабличноеПоле, ПоВозрастанию = Истина, Знач ПроверятьСортировкуСсылок = Истина) Экспорт 
	Если ТабличноеПоле.ТолькоПросмотр Тогда
		Возврат Неопределено;
	КонецЕсли; 
	ТекущаяКолонка = ТабличноеПоле.ТекущаяКолонка;
	Если ТекущаяКолонка = Неопределено Тогда
		Возврат Неопределено;
	КонецЕсли;
	ИмяКолонки = ирОбщий.ПутьКДаннымКолонкиТабличногоПоляЛкс(ТабличноеПоле);
	Если Не ЗначениеЗаполнено(ИмяКолонки) Тогда
		ирОбщий.СообщитьЛкс("Сортировка по этой колонке невозможна");
		Возврат Неопределено;
	КонецЕсли; 
	Если ПроверятьСортировкуСсылок Тогда
		Продолжаем = ПредупреждениеПередСортировкойПоСсылочнымКолонкамЛкс(ИмяКолонки, ТабличноеПоле);
		Если Не Продолжаем Тогда
			Возврат Неопределено;
		КонецЕсли; 
	КонецЕсли;
	Если ПоВозрастанию Тогда
		СтрокаСортировки = ИмяКолонки + " Возр";
	Иначе
		СтрокаСортировки = ИмяКолонки + " Убыв";
	КонецЕсли; 
	Если ТипЗнч(ТабличноеПоле.Значение) = Тип("ДеревоЗначений") Тогда 
		Родитель = ирОбщий.РодительСтрокиДереваЛкс(ТабличноеПоле.ТекущаяСтрока);
		КоллекцияСтрок = Родитель.Строки;
	Иначе
		КоллекцияСтрок = ТабличноеПоле.Значение;
	КонецЕсли; 
	КоллекцияСтрок.Сортировать(СтрокаСортировки);
	Возврат СтрокаСортировки;
КонецФункции

// http://www.hostedredmine.com/issues/877327 https://partners.v8.1c.ru/forum/t/1919734/m/1919734
Функция ПредупреждениеПередСортировкойПоСсылочнымКолонкамЛкс(Знач ИменаКолонок, Знач ТабличноеПоле, ОпасноеКоличествоСсылок = 5000) Экспорт 
	
	Если ТипЗнч(ТабличноеПоле.Значение) = Тип("ДеревоЗначений") Тогда 
		Родитель = ирОбщий.РодительСтрокиДереваЛкс(ТабличноеПоле.ТекущаяСтрока);
		КоллекцияСтрок = Родитель.Строки;
	Иначе
		КоллекцияСтрок = ТабличноеПоле.Значение;
	КонецЕсли; 
	#Если Сервер И Не Сервер Тогда
		КоллекцияСтрок = Новый ТаблицаЗначений;
	#КонецЕсли
	Продолжаем = Истина;
	МассивИмен = ирОбщий.СтрРазделитьЛкс(ИменаКолонок, ",", Истина);
	Если КоллекцияСтрок.Количество() * МассивИмен.Количество() > ОпасноеКоличествоСсылок Тогда
		Если ирОбщий.ЛиТабличнаяЧастьЛкс(ТипЗнч(КоллекцияСтрок)) Тогда
			Колонки = ТабличноеПоле.Значение.ВыгрузитьКолонки().Колонки;
		Иначе
			Колонки = КоллекцияСтрок[0].Владелец().Колонки;
		КонецЕсли; 
		КоличествоСсылочныхКолонок = 0;
		НепустыеЗначенияПростыхСсылочныхКолонок = Новый СписокЗначений;
		Для Каждого ИмяКолонки Из МассивИмен Цикл
			КоличествоСсылочныхТипов = 0;
			Для Каждого Тип Из Колонки[ИмяКолонки].ТипЗначения.Типы() Цикл
				Если ирОбщий.ЛиТипСсылкиБДЛкс(Тип) Тогда
					КоличествоСсылочныхТипов = КоличествоСсылочныхТипов + 1;
					Если КоличествоСсылочныхТипов > 1 Тогда
						Прервать;
					КонецЕсли; 
				КонецЕсли; 
			КонецЦикла;
			Если КоличествоСсылочныхТипов = 1 Тогда
				НепустыеЗначенияПростыхСсылочныхКолонок.Добавить(, ИмяКолонки);
			КонецЕсли; 
			Если КоличествоСсылочныхТипов > 0 Тогда
				КоличествоСсылочныхКолонок = КоличествоСсылочныхКолонок + 1;
			КонецЕсли; 
		КонецЦикла;
		Если КоличествоСсылочныхКолонок * КоллекцияСтрок.Количество() > ОпасноеКоличествоСсылок Тогда
			Ответ = Вопрос("Сортировка в памяти большого числа ссылочных значений может длиться долго, если для них задано динамическое представление. Сортировать?", РежимДиалогаВопрос.ДаНет,
				10, КодВозвратаДиалога.Да);
			Если Ответ = КодВозвратаДиалога.Нет Тогда
				Продолжаем = Ложь;
			КонецЕсли;
		КонецЕсли; 
	КонецЕсли;
	Возврат Продолжаем;

КонецФункции

Процедура ТабличноеПолеПорядкаКомпоновкиВыборЛкс(Знач Элемент, Знач ВыбраннаяСтрока, Знач Колонка, СтандартнаяОбработка) Экспорт 
	
	Если ТипЗнч(ВыбраннаяСтрока) = Тип("АвтоЭлементПорядкаКомпоновкиДанных") Тогда
		Возврат;
	КонецЕсли; 
	Если Колонка = Элемент.Колонки.ТипУпорядочивания Тогда 
		Если ВыбраннаяСтрока.ТипУпорядочивания = НаправлениеСортировкиКомпоновкиДанных.Возр Тогда
			ВыбраннаяСтрока.ТипУпорядочивания = НаправлениеСортировкиКомпоновкиДанных.Убыв;
		Иначе
			ВыбраннаяСтрока.ТипУпорядочивания = НаправлениеСортировкиКомпоновкиДанных.Возр;
		КонецЕсли;
		СтандартнаяОбработка = Ложь;
	КонецЕсли;

КонецПроцедуры

Процедура ТабличноеПолеЭлементовКомпоновкиПеретаскиваниеЛкс(Знач Элемент, Знач ПараметрыПеретаскивания, СтандартнаяОбработка, Знач Строка, Знач Колонка) Экспорт 
	
	ЭлементыКомпоновки = Элемент.Значение;
	#Если Сервер И Не Сервер Тогда
		Пустышка = Новый НастройкиКомпоновкиДанных;
		ЭлементыКомпоновки = Пустышка.Порядок;
	#КонецЕсли
	ЗначениеПеретаскивания = ПараметрыПеретаскивания.Значение;
	Если ТипЗнч(ЗначениеПеретаскивания) = Тип("Массив") Тогда
		Если ТипЗнч(ЗначениеПеретаскивания[0]) = Тип("ДоступноеПолеКомпоновкиДанных") Тогда
			СтандартнаяОбработка = Ложь;
			Для Каждого ЭлементПеретаскивания Из ЗначениеПеретаскивания Цикл
				КоллекцияПриемник = ЭлементыКомпоновки.Элементы;
				Если Строка <> Неопределено Тогда
					Попытка
						КоллекцияПриемник = Строка.Элементы;
					Исключение
					КонецПопытки;
				КонецЕсли; 
				НовыйЭлемент = ирОбщий.НайтиДобавитьЭлементНастроекКомпоновкиПоПолюЛкс(КоллекцияПриемник, ЭлементПеретаскивания.Поле, ПараметрыПеретаскивания.Действие = ДействиеПеретаскивания.Перемещение);
				Если Строка <> Неопределено Тогда
					СдвинутьЭлементКоллекцииНаПозициюДругогоЭлементаЛкс(КоллекцияПриемник, НовыйЭлемент, Строка);
				КонецЕсли; 
			КонецЦикла;  
			Элемент.ТекущаяСтрока = НовыйЭлемент;
		КонецЕсли; 
	КонецЕсли;

КонецПроцедуры

Процедура СдвинутьЭлементКоллекцииНаПозициюДругогоЭлементаЛкс(Знач Коллекция, Знач СдвигаемыйЭлемент, Знач ЭлементСЦелевойПозицией) Экспорт 
	
	#Если Сервер И Не Сервер Тогда
		Коллекция = Новый ТаблицаЗначений;
	#КонецЕсли
	Коллекция.Сдвинуть(СдвигаемыйЭлемент, Коллекция.Индекс(ЭлементСЦелевойПозицией) - Коллекция.Индекс(СдвигаемыйЭлемент));

КонецПроцедуры

Функция ПрименитьСтрокуПоискаКТабличномуПолюЛкс(ЭтаФорма, ТабличноеПоле, СтрокаПоиска, Знач ИменаКолонокДанныхДляПоиска = "", Знач АктивироватьНайденнуюСтроку = Истина,
	Знач ТабличноеПолеНайденных = Неопределено, Знач Кнопки = Неопределено, Знач ИскатьСНачала = Истина) Экспорт 
	
	ДеревоЗначений = ТабличноеПоле.Значение;
	#Если Сервер И Не Сервер Тогда
		ДеревоЗначений = Новый ДеревоЗначений;
	#КонецЕсли
	ЭтоТаблица = ТипЗнч(ДеревоЗначений) = Тип("ТаблицаЗначений");
	Если ЭтоТаблица Тогда
		Дочерние = ДеревоЗначений;
	Иначе
		Дочерние = ирОбщий.ДочерниеЭлементыДереваЛкс(ДеревоЗначений);
		Если Дочерние.Количество() = 0 Тогда
			Возврат Неопределено;
		КонецЕсли;
		Если ЗначениеЗаполнено(СтрокаПоиска) И Дочерние.Количество() = 1 Тогда
			КорневаяСтрока = Дочерние[0];
			Если Не ТабличноеПоле.Развернут(КорневаяСтрока) Тогда
				ТабличноеПоле.Развернуть(КорневаяСтрока);
			КонецЕсли;
		КонецЕсли;
	КонецЕсли;
	Если Не ЗначениеЗаполнено(ИменаКолонокДанныхДляПоиска) Тогда
		ИменаКолонокДанныхДляПоиска = ирОбщий.СтрСоединитьЛкс(ирОбщий.ВыгрузитьСвойствоКоллекцииЛкс(ДеревоЗначений.Колонки));
	КонецЕсли;
	СтруктураКолонок = Новый Структура(ИменаКолонокДанныхДляПоиска);
	Если ТабличноеПолеНайденных <> Неопределено Тогда
		НайденныеСтроки = ТабличноеПолеНайденных.Значение;
		НайденныеСтроки.Очистить();
	Иначе
		НайденныеСтроки = Новый ТаблицаЗначений;
		НайденныеСтроки.Колонки.Добавить("СтрокаДанных");
	КонецЕсли; 
	ТекущийИндексНайденнойСтроки = 0;
	Если ЗначениеЗаполнено(СтрокаПоиска) Тогда 
		СловаПоиска = ирОбщий.РазделитьСтрокуПоискаНаСловаПоискаЛкс(НРег(СтрокаПоиска));
		Если ТипЗнч(ДеревоЗначений) = Тип("ДеревоЗначений") Тогда
			ВсеСтроки = ирОбщий.ВсеСтрокиДереваЗначенийЛкс(ДеревоЗначений);
		Иначе
			ВсеСтроки = Дочерние;
		КонецЕсли;
		Если ИскатьСНачала Тогда
			НачальнаяСтрока = ДеревоЗначений;
			#Если Сервер И Не Сервер Тогда
				НачальнаяСтрока = Новый ДеревоЗначений;
			#КонецЕсли
			Если Не ЭтоТаблица И Дочерние.Количество() = 1 Тогда
				НачальнаяСтрока = Дочерние[0];
				Дочерние2 = ирОбщий.ДочерниеЭлементыДереваЛкс(НачальнаяСтрока);
				Если Дочерние2.Количество() > 0 Тогда
					НачальнаяСтрока = Дочерние2[0];
				КонецЕсли;
				ИндексТекущейСтроки = ВсеСтроки.Найти(НачальнаяСтрока);
			КонецЕсли;
		Иначе
			ИндексТекущейСтроки = ВсеСтроки.Найти(ТабличноеПоле.ТекущаяСтрока);
		КонецЕсли;
		ИндексАктивизируемойСтроки = Неопределено;
		Для Каждого СтрокаДанных Из ВсеСтроки Цикл
			Для Каждого КлючИЗначение Из СтруктураКолонок Цикл
				ИнтереснаяКолонка = КлючИЗначение.Ключ;
				Если Не ЭтоТаблица Тогда
					Попытка
						Пустышка = СтрокаДанных.Родитель;
					Исключение
						// Строка дерева удалена. Например в исследователе объектов
						Прервать;
					КонецПопытки;
				КонецЕсли;
				Значение = СтрокаДанных[ИнтереснаяКолонка];
				Если Истина
					И ТипЗнч(Значение) = Тип("Строка") 
				 	И ирОбщий.ЛиСтрокаСодержитВсеПодстрокиЛкс(Значение, СловаПоиска) 
				Тогда
					СтрокаРезультата = НайденныеСтроки.Добавить();
					ЗаполнитьЗначенияСвойств(СтрокаРезультата, СтрокаДанных); 
					СтрокаРезультата.СтрокаДанных = СтрокаДанных;
					Если ИндексТекущейСтроки <> Неопределено И ВсеСтроки.Найти(СтрокаДанных) >= ИндексТекущейСтроки И ИндексАктивизируемойСтроки = Неопределено Тогда
						ИндексАктивизируемойСтроки = НайденныеСтроки.Количество() - 1;
					КонецЕсли; 
					Родитель = СтрокаДанных;
					Пока Не ЭтоТаблица И Родитель <> Неопределено Цикл
						// В большом дереве вредно сразу разворачивать строки, т.к. много времени тратится на отрисовку строк
						//Если Родитель <> СтрокаДанных И Не ТабличноеПоле.Развернут(Родитель) Тогда
						//	ТабличноеПоле.Развернуть(Родитель);
						//КонецЕсли; 
						Родитель = Родитель.Родитель;
					КонецЦикла; 
					Прервать;
				КонецЕсли; 
			КонецЦикла;
			Если НайденныеСтроки.Количество() > 1000 Тогда
				Прервать;
			КонецЕсли; 
		КонецЦикла;
		Если НайденныеСтроки.Количество() > 0 Тогда
			Если АктивироватьНайденнуюСтроку Тогда
				Если ИндексАктивизируемойСтроки = Неопределено Тогда
					ИндексАктивизируемойСтроки = 0;
				КонецЕсли; 
				Если ТабличноеПолеНайденных = Неопределено Тогда
					ТабличноеПоле.ТекущаяСтрока = НайденныеСтроки[ИндексАктивизируемойСтроки].СтрокаДанных;
				Иначе
					ТабличноеПолеНайденных.ТекущаяСтрока = НайденныеСтроки[ИндексАктивизируемойСтроки];
				КонецЕсли;
			КонецЕсли; 
			Если ТабличноеПоле.ТекущаяСтрока <> Неопределено Тогда 
				НайденнаяТекущаяСтрока = НайденныеСтроки.Найти(ТабличноеПоле.ТекущаяСтрока, "СтрокаДанных");
				Если НайденнаяТекущаяСтрока <> Неопределено Тогда
					ТекущийИндексНайденнойСтроки = НайденныеСтроки.Индекс(НайденнаяТекущаяСтрока);
				КонецЕсли; 
			КонецЕсли; 
		КонецЕсли; 
	КонецЕсли;
	Если Кнопки <> Неопределено Тогда
		Для Каждого Кнопка Из Кнопки Цикл
			Кнопка.Доступность = НайденныеСтроки.Количество() > 0;
		КонецЦикла;
	КонецЕсли;
	МенеджерПоиска = ДопСвойстваЭлементаФормыЛкс(ЭтаФорма, ТабличноеПоле).МенеджерПоиска;
	Если МенеджерПоиска = Неопределено Тогда
		МенеджерПоиска = СоздатьМенеджерПоискаВТабличномПолеЛкс();
		ДопСвойстваЭлементаФормыЛкс(ЭтаФорма, ТабличноеПоле).МенеджерПоиска = МенеджерПоиска;
	КонецЕсли;
	МенеджерПоиска.КолонкиПоиска = Новый Структура(ИменаКолонокДанныхДляПоиска);
	МенеджерПоиска.НайденныеСтроки = НайденныеСтроки;
	МенеджерПоиска.ТекущийИндексНайденнойСтроки = ТекущийИндексНайденнойСтроки;
	ТабличноеПоле.ОбновитьСтроки();
	Возврат МенеджерПоиска;
	
КонецФункции

// Функция - Создать менеджер поиска в табличном поле лкс
//
// Параметры:
//  КолонкиПоиска				 - Структура - 
//  НайденныеСтроки				 - Массив - 
//  ТекущийИндексНайденнойСтроки - Число - 
//  РазрешитьОкраску			 - Булево - 
//  ИскатьСРодителем			 - Булево - 
//  ПрефиксСтрокиПоиска			 - Строка - 
// 
// Возвращаемое значение:
//   - 
//
Функция СоздатьМенеджерПоискаВТабличномПолеЛкс(Знач КолонкиПоиска = Неопределено, Знач НайденныеСтроки = Неопределено, Знач ТекущийИндексНайденнойСтроки = Неопределено,
	Знач РазрешитьОкраску = Ложь, Знач ИскатьСРодителем = Ложь, Знач ПрефиксСтрокиПоиска = "") Экспорт 
	
	Если НайденныеСтроки = Неопределено Тогда
		НайденныеСтроки = Новый Массив;
	КонецЕсли;
	МенеджерПоиска = Новый Структура;
	МенеджерПоиска.Вставить("ТекущийИндексНайденнойСтроки", ТекущийИндексНайденнойСтроки);
	МенеджерПоиска.Вставить("НайденныеСтроки", НайденныеСтроки);
	МенеджерПоиска.Вставить("КолонкиПоиска", КолонкиПоиска);
	МенеджерПоиска.Вставить("РазрешитьОкраску", РазрешитьОкраску);
	МенеджерПоиска.Вставить("ИскатьСРодителем", ИскатьСРодителем); // Это разрешение такого поиска. Фактический режим определяется с учетом искомой строки
	МенеджерПоиска.Вставить("ПрефиксСтрокиПоиска", ПрефиксСтрокиПоиска); // По умолчанию используем имя табличного поля
	Возврат МенеджерПоиска;

КонецФункции

Процедура СледующееВхождениеСтрокиПоискаВТабличномПолеЛкс(ЭтаФорма, ТабличноеПоле) Экспорт 
	
	МенеджерПоиска = ДопСвойстваЭлементаФормыЛкс(ЭтаФорма, ТабличноеПоле).МенеджерПоиска;
	Если МенеджерПоиска = Неопределено Тогда
		Возврат;
	КонецЕсли; 
	Если МенеджерПоиска.НайденныеСтроки.Количество() > 0 Тогда
		МенеджерПоиска.ТекущийИндексНайденнойСтроки = МенеджерПоиска.ТекущийИндексНайденнойСтроки + 1;
		Если МенеджерПоиска.ТекущийИндексНайденнойСтроки >= МенеджерПоиска.НайденныеСтроки.Количество() Тогда
			МенеджерПоиска.ТекущийИндексНайденнойСтроки = 0;
		КонецЕсли; 
		ТабличноеПоле.ТекущаяСтрока = МенеджерПоиска.НайденныеСтроки[МенеджерПоиска.ТекущийИндексНайденнойСтроки].СтрокаДанных;
	КонецЕсли; 
	
КонецПроцедуры

Процедура ПредыдущееВхождениеСтрокиПоискаВТабличномПолеЛкс(ЭтаФорма, ТабличноеПоле) Экспорт 
	
	МенеджерПоиска = ДопСвойстваЭлементаФормыЛкс(ЭтаФорма, ТабличноеПоле).МенеджерПоиска;
	Если МенеджерПоиска = Неопределено Тогда
		Возврат;
	КонецЕсли; 
	Если МенеджерПоиска.НайденныеСтроки.Количество() > 0 Тогда
		МенеджерПоиска.ТекущийИндексНайденнойСтроки = МенеджерПоиска.ТекущийИндексНайденнойСтроки - 1;
		Если МенеджерПоиска.ТекущийИндексНайденнойСтроки < 0 Тогда
			МенеджерПоиска.ТекущийИндексНайденнойСтроки = МенеджерПоиска.НайденныеСтроки.Количество() - 1;
		КонецЕсли; 
		ТабличноеПоле.ТекущаяСтрока = МенеджерПоиска.НайденныеСтроки[МенеджерПоиска.ТекущийИндексНайденнойСтроки].СтрокаДанных;
	КонецЕсли; 
	
КонецПроцедуры

Процедура ДобавитьСсылкуВИсториюРаботыЛкс(Ссылка, ДобавлятьВИсториюРаботыПлатформы = Истина, ДобавлятьВИсториюИнтерфейснойПанели = Истина) Экспорт
	
	Если ДобавлятьВИсториюРаботыПлатформы Тогда
		ИсторияРаботыПользователя.Добавить(ПолучитьНавигационнуюСсылку(Ссылка));
	КонецЕсли; 
	Если ДобавлятьВИсториюИнтерфейснойПанели Тогда
		ФормаИнтерфейснойПанели = ПолучитьФормуЛкс("Обработка.ирИнтерфейснаяПанель.Форма");
		СтруктураЭлемента = Новый Структура();
		СтруктураЭлемента.Вставить("Вид", Ссылка.Метаданные().ПолноеИмя());
		СтруктураЭлемента.Вставить("Имя", Ссылка);
		ФормаИнтерфейснойПанели.ДобавитьСтрокуВСтатическуюВетку(СтруктураЭлемента, Ложь);
	КонецЕсли;
	
КонецПроцедуры

Процедура ДобавитьИнструментВИсториюРаботыЛкс(Форма, ДобавлятьВИсториюРаботыПлатформы = Истина, ДобавлятьВИсториюИнтерфейснойПанели = Истина) Экспорт
	
	мПлатформа = ирКэш.Получить();
	#Если Сервер И Не Сервер Тогда
		мПлатформа = Обработки.ирПлатформа.Создать();
	#КонецЕсли
	ИмяФормы = ирОбщий.ПолноеИмяФормыЛкс(Форма);
	Если Не ЗначениеЗаполнено(ИмяФормы) Тогда
		Возврат;
	КонецЕсли; 
	Попытка
		ОсновнойОбъект = Форма.ЭтотОбъект;
	Исключение
		Возврат;
	КонецПопытки;
	Если ТипЗнч(ОсновнойОбъект) = Тип("УправляемаяФорма") Тогда
		ПолноеИмяМД = ИмяФормы;
	Иначе
		ПолноеИмяМД = ОсновнойОбъект.Метаданные().ПолноеИмя();
	КонецЕсли;
	Фрагменты = ирОбщий.СтрРазделитьЛкс(ПолноеИмяМД);
	Если Ложь
		Или Фрагменты[1] = "ирДинамическийСписок"
		Или Фрагменты[1] = "ирРедакторОбъектаБД"
		Или Фрагменты[1] = "ирИнтерфейснаяПанель"
		Или Фрагменты[1] = "ирИсследовательОбъектов"
	Тогда
		Возврат;
	КонецЕсли; 
	Фрагменты[0] = ирОбщий.ПеревестиВРусский(Фрагменты[0]);
	мПлатформа.ЗаполнитьСписокИнструментов();
	СтрокаИнструмента = мПлатформа.СписокИнструментов.НайтиСтроки(Новый Структура("Видимость, ПолноеИмя", Истина, Фрагменты[0] + "." + Фрагменты[1]));
	Если СтрокаИнструмента.Количество() > 0 Тогда
		Если ДобавлятьВИсториюИнтерфейснойПанели Тогда
			ФормаИнтерфейснойПанели = ПолучитьФормуЛкс("Обработка.ирИнтерфейснаяПанель.Форма");
			СтруктураЭлемента = Новый Структура();
			СтруктураЭлемента.Вставить("Вид", ирОбщий.МножественноеИмяМДЛкс(Фрагменты[0]));
			СтруктураЭлемента.Вставить("Имя", Фрагменты[1]);
			ФормаИнтерфейснойПанели.ДобавитьСтрокуВСтатическуюВетку(СтруктураЭлемента, Ложь);
		КонецЕсли;
	КонецЕсли; 
	
КонецПроцедуры

Процедура ДобавитьСсылкуВИзбранноеЛкс(Ссылка, ДобавлятьВИзбранноеРаботыПользователя = Истина, ДобавлятьВИзрабнноеИнтерфейснойПанели = Истина) Экспорт
	
	//Если ДобавлятьВИзбранноеРаботыПользователя И ирОбщий.ЛиСсылкаНаОбъектБДЛкс(Ссылка) Тогда
	//	// e1cib/command/Справочник.ирАлгоритмы.ОткрытьСписок
	//	// e1cib/command/Обработка.ирДинамическийСписок.Открыть
	//	// e1cib/command/Обработка.ирКонсольЗапросов.Команда1
	//	Избранное = ХранилищеСистемныхНастроек.Загрузить("Общее/ИзбранноеРаботыПользователя");
	//	Если Избранное = Неопределено Тогда
	//		Избранное = Новый ИзбранноеРаботыПользователя;
	//	КонецЕсли; 
	//	ЭлементИзбранного = Новый ЭлементИзбранногоРаботыПользователя;
	//	ЭлементИзбранного.НавигационнаяСсылка = ПолучитьНавигационнуюСсылку(Ссылка);
	//	Избранное.Добавить(ЭлементИзбранного);
	//	ХранилищеСистемныхНастроек.Сохранить("Общее/ИзбранноеРаботыПользователя", "", Избранное);
	//	ОбновитьИнтерфейс();
	//КонецЕсли; 
	Если ДобавлятьВИзрабнноеИнтерфейснойПанели Тогда
		ФормаИнтерфейснойПанели = ПолучитьФормуЛкс("Обработка.ирИнтерфейснаяПанель.Форма");
		СтруктураЭлемента = Новый Структура();
		СтруктураЭлемента.Вставить("Вид", Ссылка.Метаданные().ПолноеИмя());
		СтруктураЭлемента.Вставить("Имя", Ссылка);
		ФормаИнтерфейснойПанели.ДобавитьСтрокуВСтатическуюВетку(СтруктураЭлемента, Истина);
	КонецЕсли;
	
КонецПроцедуры

Процедура ДобавитьТаблицуВИзбранноеЛкс(ИмяТаблицыБД, ДобавлятьВИзбранноеРаботыПользователя = Истина, ДобавлятьВИзрабнноеИнтерфейснойПанели = Истина) Экспорт
	
	//Если ДобавлятьВИзбранноеРаботыПользователя Тогда
	//	Избранное = ХранилищеСистемныхНастроек.Загрузить("Общее/ИзбранноеРаботыПользователя");
	//	Если Избранное = Неопределено Тогда
	//		Избранное = Новый ИзбранноеРаботыПользователя;
	//	КонецЕсли; 
	//	ЭлементИзбранного = Новый ЭлементИзбранногоРаботыПользователя;
	//	ЭлементИзбранного.НавигационнаяСсылка = ПолучитьНавигационнуюСсылку(Ссылка);
	//	Избранное.Добавить(ЭлементИзбранного);
	//	ХранилищеСистемныхНастроек.Сохранить("Общее/ИзбранноеРаботыПользователя", "", Избранное);
	//	ОбновитьИнтерфейс();
	//КонецЕсли; 
	Если ДобавлятьВИзрабнноеИнтерфейснойПанели Тогда
		ОбъектМД = ирОбщий.ОбъектМДПоПолномуИмениТаблицыБДЛкс(ИмяТаблицыБД);
		Если ОбъектМД = Неопределено Тогда
			Возврат;
		КонецЕсли; 
		ФормаИнтерфейснойПанели = ПолучитьФормуЛкс("Обработка.ирИнтерфейснаяПанель.Форма");
		мПлатформа = ирКэш.Получить();
		#Если Сервер И Не Сервер Тогда
			ОбъектМД = Метаданные.Справочники.Валюты;
			мПлатформа = Обработки.ирПлатформа.Создать();
		#КонецЕсли
		КорневойТип = ирОбщий.ПеревестиВРусский(ирОбщий.ПервыйФрагментЛкс(ОбъектМД.ПолноеИмя()));
		СтрокаТипаМетаОбъектов = мПлатформа.ОписаниеТипаМетаОбъектов(КорневойТип);
		СтруктураЭлемента = Новый Структура();
		Если ирОбщий.ЛиКорневойТипВнешнегоИсточникаДанныхЛкс(КорневойТип) Тогда
			СтруктураЭлемента.Вставить("Вид", ОбъектМД.Родитель().ПолноеИмя());
		Иначе
			СтруктураЭлемента.Вставить("Вид", СтрокаТипаМетаОбъектов.Единственное);
		КонецЕсли;
		СтруктураЭлемента.Вставить("Имя", ОбъектМД.Имя);
		ФормаИнтерфейснойПанели.ДобавитьСтрокуВСтатическуюВетку(СтруктураЭлемента);
	КонецЕсли;
	
КонецПроцедуры

// 

Процедура ОткрытьОбъектыИзВыделенныхЯчеекВПодбореИОбработкеОбъектовЛкс(ТабличноеПоле, Знач ИмяКолонки = "", Знач ЭтаФорма = Неопределено, Знач ПолноеИмяТаблицыБД = "") Экспорт 

	Если ЗначениеЗаполнено(ПолноеИмяТаблицыБД) Тогда
		Ответ = Вопрос("Использовать значения текущей колонки (да) или ключи строк (нет)?", РежимДиалогаВопрос.ДаНет, , КодВозвратаДиалога.Нет);
		СобиратьКлючи = Ответ = КодВозвратаДиалога.Нет;
	Иначе
		СобиратьКлючи = Ложь;
	КонецЕсли; 
	Если СобиратьКлючи Тогда
		МассивСсылок = Новый Массив();
		Для Каждого ВыделеннаяСтрока Из ТабличноеПоле.ВыделенныеСтроки Цикл
			КлючОбъекта = ирОбщий.КлючСтрокиТаблицыБДИзСтрокиТаблицыЗначенийЛкс(ПолноеИмяТаблицыБД, ВыделеннаяСтрока);
			МассивСсылок.Добавить(КлючОбъекта);
		КонецЦикла;
		КлючТекущейСтроки = ирОбщий.КлючСтрокиТаблицыБДИзСтрокиТаблицыЗначенийЛкс(ПолноеИмяТаблицыБД, ТабличноеПоле.ТекущаяСтрока);
	Иначе
		МассивСсылок = СсылкиИзВыделенныхЯчеекТабличногоПоляЛкс(ТабличноеПоле, ИмяКолонки);
	КонецЕсли;
	ОткрытьМассивОбъектовВПодбореИОбработкеОбъектовЛкс(МассивСсылок,, ЭтаФорма,, КлючТекущейСтроки);

КонецПроцедуры

Функция СсылкиИзВыделенныхЯчеекТабличногоПоляЛкс(ТабличноеПоле, ИмяКолонки = "") Экспорт 
	
	МассивСсылок = Новый Массив;
	ВыделенныеСтроки = ВыделенныеСтрокиТабличногоПоляЛкс(ТабличноеПоле);
	Если ВыделенныеСтроки.Количество() = 0 Тогда
		Возврат МассивСсылок;
	КонецЕсли; 
	Если Не ЗначениеЗаполнено(ИмяКолонки) Тогда
		ИмяКолонки = ирОбщий.ПутьКДаннымКолонкиТабличногоПоляЛкс(ТабличноеПоле);
	КонецЕсли;
	Если Не ЗначениеЗаполнено(ИмяКолонки) Тогда
		Возврат МассивСсылок;
	КонецЕсли; 
	ДанныеПоля = Неопределено;
	Для Каждого КлючСтроки Из ВыделенныеСтроки Цикл
		ДанныеСтроки = ДанныеСтрокиТабличногоПоляЛкс(ТабличноеПоле, КлючСтроки, ДанныеПоля);
		ЗначениеСтроки = ДанныеСтроки[ИмяКолонки];
		ТипЗначения = ТипЗнч(ЗначениеСтроки);
		Если Метаданные.НайтиПоТипу(ТипЗначения) = Неопределено Тогда
			Продолжить;
		КонецЕсли; 
		МассивСсылок.Добавить(ЗначениеСтроки);
	КонецЦикла;
	Возврат МассивСсылок;

КонецФункции

Функция ОткрытьПодборИОбработкуОбъектовИзДинамическогоСпискаЛкс(ТабличноеПоле, Знач НастройкиСписка = Неопределено, Знач ВыделенныеСтроки = Неопределено, Знач ИмяТаблицы = "") Экспорт 

	#Если Сервер И Не Сервер Тогда
		ТабличноеПоле = Новый ТабличноеПоле;
	#КонецЕсли
	ДинамическийСписок = ирОбщий.ДанныеЭлементаФормыЛкс(ТабличноеПоле);
	Если Не ЗначениеЗаполнено(ИмяТаблицы) Тогда
		ИмяТаблицы = "";
		ирОбщий.ИмяТаблицыБДДинамическогоСпискаЛкс(ТабличноеПоле, ИмяТаблицы);
	КонецЕсли;
	Если ТабличноеПоле.ВыделенныеСтроки.Количество() = 1 И ЗначениеЗаполнено(ИмяТаблицы) Тогда
		Ответ = Вопрос("Обработать только выделенные строки (Да) иначе будет использован текущий отбор (Нет)?", РежимДиалогаВопрос.ДаНет);
	Иначе
		Ответ = КодВозвратаДиалога.Да;
	КонецЕсли;
	ВыбранныеПоля = Новый Массив;
	МассивКолонок = КолонкиТаблицыФормыИлиТабличногоПоляЛкс(ТабличноеПоле);
	ТекущееПолеТаблицы = ирОбщий.ПутьКДаннымКолонкиТабличногоПоляЛкс(ТабличноеПоле);
	Для Каждого КолонкаТП Из МассивКолонок Цикл
		Если Не КолонкаТП.Видимость Тогда
			Продолжить;
		КонецЕсли;
		ДанныеКолонки = ирОбщий.ПутьКДаннымКолонкиТабличногоПоляЛкс(ТабличноеПоле, КолонкаТП);
		Если Не ЗначениеЗаполнено(ДанныеКолонки) Тогда
			Продолжить;
		КонецЕсли;
		ВыбранныеПоля.Добавить(ДанныеКолонки);
	КонецЦикла;
	Если Ответ = КодВозвратаДиалога.Да Тогда
		Если ВыделенныеСтроки = Неопределено Тогда
			ВыделенныеСтроки = ВыделенныеСтрокиТабличногоПоляЛкс(ТабличноеПоле);
		КонецЕсли; 
		ТекущаяСтрока = ТабличноеПоле.ТекущаяСтрока;
		Если Не ЗначениеЗаполнено(ИмяТаблицы) Тогда
			ВыделенныеСтроки = КлючиВыделенныхСтрокИмитатораДинамическогоСпискаЛкс(ТабличноеПоле, ВыделенныеСтроки);
			ТекущаяСтрока = КлючиВыделенныхСтрокИмитатораДинамическогоСпискаЛкс(ТабличноеПоле, ирОбщий.ЗначенияВМассивЛкс(ТекущаяСтрока))[0];
		ИначеЕсли ТипЗнч(ТекущаяСтрока) = Тип("Число") Тогда
			ВыделенныеСтроки = ТаблицаКлючейВыделенныхСтрокДинСпискаЛкс(ТабличноеПоле, ИмяТаблицы, ТекущаяСтрока);
			КлючУникальности = ИмяТаблицы;
		КонецЕсли; 
		Форма = ОткрытьМассивОбъектовВПодбореИОбработкеОбъектовЛкс(ВыделенныеСтроки, ВыбранныеПоля,, ТекущееПолеТаблицы, ТекущаяСтрока, КлючУникальности);
	Иначе
		Форма = ПолучитьФормуЛкс("Обработка.ирПодборИОбработкаОбъектов.Форма",,, ИмяТаблицы);
		Форма.ПараметрВыбранныеПоля = ВыбранныеПоля;
		Форма.ПараметрТекущееПоле = ТекущееПолеТаблицы;
		Форма.ПараметрКлючТекущейСтроки = ТабличноеПоле.ТекущаяСтрока;
		Если НастройкиСписка = Неопределено Тогда
			НастройкиСписка = ирОбщий.НастройкиДинамическогоСпискаЛкс(ДинамическийСписок);
		КонецЕсли; 
		Форма.ПараметрНастройкаКомпоновки = НастройкиСписка;
		Форма.Открыть();
	КонецЕсли;
	Возврат Форма;

КонецФункции

// Параметры:
//  ТабличноеПолеИлиТаблицаФормы - ТабличноеПоле, ТаблицаФормы, ГруппаФормы - 
//  выхТекущаяКолонка			 - КолонкаТабличногоПоля, ПолеФормы - 
//  выхМассивКолонок			 - Массив - все колоноки табличного поля
// 
// Возвращаемое значение:
//   Массив - все колоноки табличного поля 
//
Функция КолонкиТаблицыФормыИлиТабличногоПоляЛкс(Знач ТабличноеПолеИлиТаблицаФормы, выхТекущаяКолонка = Неопределено, выхМассивКолонок = Неопределено) Экспорт 
	
	Если выхМассивКолонок = Неопределено Тогда
		выхМассивКолонок = Новый Массив;
	КонецЕсли;
	Если ТипЗнч(ТабличноеПолеИлиТаблицаФормы) = Тип("ТабличноеПоле") Тогда
		Колонки = ТабличноеПолеИлиТаблицаФормы.Колонки;
		выхТекущаяКолонка = ТабличноеПолеИлиТаблицаФормы.ТекущаяКолонка;
	ИначеЕсли Ложь
		Или ТипЗнч(ТабличноеПолеИлиТаблицаФормы) = Тип("ТаблицаФормы") 
		Или ТипЗнч(ТабличноеПолеИлиТаблицаФормы) = Тип("ГруппаФормы")
	Тогда
		Колонки = ТабличноеПолеИлиТаблицаФормы.ПодчиненныеЭлементы;
	КонецЕсли;
	Для Каждого Элемент Из Колонки Цикл
		Если ТипЗнч(Элемент) = Тип("ГруппаФормы") Тогда
			КолонкиТаблицыФормыИлиТабличногоПоляЛкс(Элемент,, выхМассивКолонок);
		Иначе
			выхМассивКолонок.Добавить(Элемент);
		КонецЕсли;
	КонецЦикла;
	Если ТипЗнч(ТабличноеПолеИлиТаблицаФормы) = Тип("ТаблицаФормы") Тогда
		выхТекущаяКолонка = ТабличноеПолеИлиТаблицаФормы.ТекущийЭлемент;
		Если выхТекущаяКолонка <> Неопределено И выхМассивКолонок.Найти(выхТекущаяКолонка) = Неопределено Тогда
			// Пользовательская колонка
			выхМассивКолонок.Добавить(выхТекущаяКолонка);
		КонецЕсли;
	КонецЕсли;
	Возврат выхМассивКолонок;

КонецФункции

// Антибаг платформы. Текущая строка пропадает из выделенных в управляемой форме.
Процедура ВосстановитьВыделеннуюСтрокуТаблицыФормыЛкс(Знач ТаблицаФормы) Экспорт 
	
	Если Истина
		И ТаблицаФормы.ТекущаяСтрока <> Неопределено
		И ТаблицаФормы.ВыделенныеСтроки.Количество() = 0 
	Тогда
		ТаблицаФормы.ВыделенныеСтроки.Добавить(ТаблицаФормы.ТекущаяСтрока);
	КонецЕсли;

КонецПроцедуры 

// В обычной форме "Динамический список ИР" для перечислений сделан статический список через таблицу значений
Функция КлючиВыделенныхСтрокИмитатораДинамическогоСпискаЛкс(Знач ТабличноеПоле, ВыделенныеСтроки = Неопределено)
	
	Если ВыделенныеСтроки = Неопределено Тогда
		ВыделенныеСтроки = ТабличноеПоле.ВыделенныеСтроки; 
	КонецЕсли; 
	ПараметрКоманды = Новый Массив();
	Для Каждого Строка Из ВыделенныеСтроки Цикл
		Если ТипЗнч(Строка) = Тип("СтрокаТаблицыЗначений") Тогда
			КлючСтроки = Строка.Ссылка;
		Иначе
			КлючСтроки = Строка;
		КонецЕсли; 
		ПараметрКоманды.Добавить(КлючСтроки);
	КонецЦикла;
	Возврат ПараметрКоманды;

КонецФункции

// Параметры:
//    ВыбранныеПоля - Массив, *Неопределено
Функция ОткрытьМассивОбъектовВПодбореИОбработкеОбъектовЛкс(Знач МассивСсылок, Знач ВыбранныеПоля = Неопределено, Знач ЭтаФорма = Неопределено, Знач ТекущееПолеТаблицы = Неопределено,
	Знач КлючТекущейСтроки = Неопределено, Знач КлючУникальности = "") Экспорт 

	Если МассивСсылок.Количество() = 0 Тогда
		Возврат Неопределено;
	КонецЕсли; 
	Если ЭтаФорма <> Неопределено Тогда
		ПредложитьЗакрытьМодальнуюФормуЛкс(ЭтаФорма);
	КонецЕсли;
	Если Не ЗначениеЗаполнено(КлючУникальности) Тогда
		КлючУникальности = Новый УникальныйИдентификатор;
	КонецЕсли;
	Форма = ПолучитьФормуЛкс("Обработка.ирПодборИОбработкаОбъектов.Форма",,, КлючУникальности);
	Форма.ПараметрМассивСсылок = МассивСсылок;
	Форма.ПараметрВыбранныеПоля = ВыбранныеПоля;
	Форма.ПараметрТекущееПоле = ТекущееПолеТаблицы;
	Форма.ПараметрКлючТекущейСтроки = КлючТекущейСтроки;
	Форма.Открыть();
	//Форма.ЗагрузитьОбъектыДляОбработки(РазличныеЗначенияМассиваЛкс(МассивСсылок),, ВыбранныеПоля);
	Возврат Форма;

КонецФункции

Функция ПолучитьСтруктуруВосстановленияКонсолиЛкс(ИмяИлиОбъектКонсоли) Экспорт 

	Если ТипЗнч(ИмяИлиОбъектКонсоли) = Тип("Строка") Тогда
		ИмяКонсоли = ИмяИлиОбъектКонсоли;
	Иначе
		ИмяКонсоли = ИмяИлиОбъектКонсоли.Метаданные().Имя;
	КонецЕсли; 
	Структура = Новый Структура();
	Структура.Вставить("БлокировкаВосстановления", Неопределено);
	ПрефиксИмениФайлаВосстановления = ИмяКонсоли + "_" + ИмяПользователя() + "_";
	Структура.Вставить("ПрефиксИмениФайлаВосстановления", ПрефиксИмениФайлаВосстановления);
	ИмяФайлаВосстановления = ИмяФайлаВосстановленияКонсолиЛкс(Структура.ПрефиксИмениФайлаВосстановления);
	Структура.Вставить("ФайлВосстановления", Новый Файл(ИмяФайлаВосстановления));
	Возврат Структура;

КонецФункции

Функция ИмяФайлаВосстановленияКонсолиЛкс(Знач ПрефиксИмениФайлаВосстановления, Знач ИмяОткрытогоФайла = "")
	
	Если ЗначениеЗаполнено(ИмяОткрытогоФайла) Тогда
		лФайл = Новый Файл(ИмяОткрытогоФайла);
		ИмяОткрытогоФайла = лФайл.ИмяБезРасширения;
	КонецЕсли; 
	ИмяФайлаВосстановления = ирКэш.Получить().КаталогФайловогоКэша + ирОбщий.РазделительПутиКФайлуЛкс() + ПрефиксИмениФайлаВосстановления + Лев(ИмяОткрытогоФайла, 40) + "_" + Новый УникальныйИдентификатор + ".tmp";
	Возврат ИмяФайлаВосстановления;

КонецФункции

// Функция - Сохранить файл в консоли с восстановлением лкс
//
// Параметры:
//  ДиалогВыбораФайла			 - 	 - 
//  ИмяСохраняемогоФайла		 - 	 - 
//  ИмяОткрытогоФайла			 - Строка - при успешном выборе файла получает новое значение
//  ДанныеДляФайла				 - 	 - 
//  СтруктураВосстановления		 - 	 - 
//  ЗапрашиватьИмяФайла			 - 	 - 
//  ФайлВосстановленияОбрезан	 - 	 - 
// 
// Возвращаемое значение:
//   - 
//
Функция СохранитьФайлВКонсолиСВосстановлениемЛкс(Знач ДиалогВыбораФайла, Знач ИмяСохраняемогоФайла, ИмяОткрытогоФайла = "", Знач ДанныеДляФайла, Знач СтруктураВосстановления,
	Знач ЗапрашиватьИмяФайла = Ложь, Знач ФайлВосстановленияОбрезан = Ложь) Экспорт

	#Если Сервер И Не Сервер Тогда
	    ДиалогВыбораФайла = Новый ДиалогВыбораФайла();
	#КонецЕсли
	ФайлВосстановления = СтруктураВосстановления.ФайлВосстановления;
	#Если Сервер И Не Сервер Тогда
		ФайлВосстановления = Новый Файл;
	#КонецЕсли
	ПрефиксИмениФайлаВосстановления = СтруктураВосстановления.ПрефиксИмениФайлаВосстановления;
	СохранитьФайл = Истина;
	Если Не ирОбщий.СтрокиРавныЛкс(ИмяСохраняемогоФайла, ФайлВосстановления.ПолноеИмя) Тогда
		// Здесь можно вставить проверочную сериализацию+десериализацию
		ФайлВыбран = Истина;
		лФайл = Новый Файл(ИмяОткрытогоФайла);
		ДиалогВыбораФайла.ПолноеИмяФайла = ИмяСохраняемогоФайла;
		Если Ложь
			Или ПустаяСтрока(ИмяСохраняемогоФайла) 
			Или ЗапрашиватьИмяФайла 
			Или Найти(Нрег(лФайл.Имя), НРег(ПрефиксИмениФайлаВосстановления)) = 1
		Тогда
			Пока Истина Цикл
				Если ДиалогВыбораФайла.Выбрать() Тогда
					лФайл = Новый Файл(ДиалогВыбораФайла.ПолноеИмяФайла);
					Если Найти(Нрег(лФайл.Имя), НРег(ПрефиксИмениФайлаВосстановления)) = 1 Тогда
						КодОтвета = Вопрос("Это имя файла зарезервировано. Хотите выбрать другое?", РежимДиалогаВопрос.ОКОтмена);
						Если КодОтвета = КодВозвратаДиалога.ОК Тогда
							Продолжить;
						Иначе
							ФайлВыбран = Ложь;
							Прервать;
						КонецЕсли; 
					КонецЕсли;
					ИмяСохраняемогоФайла = ДиалогВыбораФайла.ПолноеИмяФайла;
					ФайлВыбран = Истина;
					Прервать;
				Иначе
					ФайлВыбран = Ложь;
					СохранитьФайл = Ложь;
					Прервать;
				КонецЕсли;
			КонецЦикла; 
		КонецЕсли;
	Иначе
		ФайлВыбран = Ложь;
	КонецЕсли; 
	Если СохранитьФайл Тогда
		МоментНачала = ТекущаяДата();
		Если НРег(ИмяСохраняемогоФайла) = НРег(ФайлВосстановления.ПолноеИмя) Тогда 
			СтруктураВосстановления.БлокировкаВосстановления = Неопределено;
			УдалитьФайлы(ФайлВосстановления.Путь, ФайлВосстановления.ИмяБезРасширения + ".*");
			ФайлВосстановления = Новый Файл(ИмяФайлаВосстановленияКонсолиЛкс(ПрефиксИмениФайлаВосстановления, ИмяОткрытогоФайла));
			ИмяСохраняемогоФайла = ФайлВосстановления.ПолноеИмя;
			ЗначениеВФайл(ФайлВосстановления.Путь + ФайлВосстановления.ИмяБезРасширения + ".inf", Новый Структура("ИмяОткрытогоФайла, Обрезан", ИмяОткрытогоФайла, ФайлВосстановленияОбрезан));
			СтруктураВосстановления.ФайлВосстановления = ФайлВосстановления;
		КонецЕсли;
		ПроверитьСериализациюXMLПередВызовомЗначениеВФайлЛкс(ДанныеДляФайла);
		Если Не ЗначениеВФайл(ИмяСохраняемогоФайла, ДанныеДляФайла) Тогда 
			ирОбщий.СообщитьЛкс(ирОбщий.СтрШаблонИменЛкс("Ошибка записи файла %1",, ИмяСохраняемогоФайла), СтатусСообщения.Внимание);
			ФайлВыбран = Ложь;
		КонецЕсли; 
		Если НРег(ИмяСохраняемогоФайла) = НРег(ФайлВосстановления.ПолноеИмя) Тогда
			выхДлительность = ТекущаяДата() - МоментНачала;
			Если выхДлительность > 1 Тогда
				ирОбщий.СообщитьЛкс("Автосохранение файла восстановления выполнено за " + выхДлительность + " секунд");
			КонецЕсли; 
			СтруктураВосстановления.БлокировкаВосстановления = Новый ЗаписьТекста(ИмяСохраняемогоФайла,,, Истина);
		КонецЕсли; 
	КонецЕсли;   
	Если ФайлВыбран Тогда
		ИмяОткрытогоФайла = ДиалогВыбораФайла.ПолноеИмяФайла;
	КонецЕсли;
	Возврат ФайлВыбран;

КонецФункции

Функция ПроверитьВыбратьФайлВосстановленияКонсолиЛкс(СтруктураВосстановления, выхОписаниеФайла = Ложь) Экспорт

	ПрефиксИмениФайлаВосстановления = СтруктураВосстановления.ПрефиксИмениФайлаВосстановления;
	СписокВосстановления = Новый СписокЗначений; 
	КаталогФайлов = ирКэш.Получить().КаталогФайловогоКэша;
	ФайлыВосстановления = НайтиФайлы(КаталогФайлов, ПрефиксИмениФайлаВосстановления + "*.tmp");
	Для Каждого Файл Из ФайлыВосстановления Цикл
		#Если Сервер И Не Сервер Тогда
			Файл = Новый Файл;
		#КонецЕсли
		СписокВосстановления.Добавить(Файл.ПолучитьВремяИзменения() + ирКэш.ПолучитьСмещениеВремениЛкс(), Файл.Имя);
	КонецЦикла;
	СписокВосстановления.СортироватьПоЗначению(НаправлениеСортировки.Убыв);
	СписокВыбора = Новый СписокЗначений;
	Разделитель = ирОбщий.РазделительПутиКФайлуЛкс();
	Для Каждого ЭлементСписка Из СписокВосстановления Цикл
		ДатаИзменения = ЭлементСписка.Значение;
	    Файл = Новый Файл(КаталогФайлов + Разделитель + ЭлементСписка.Представление);
		Попытка
			//Файл.УстановитьВремяИзменения(ДатаИзменения); // Так не срабатывает блокировка
			Пустышка = Новый ЗаписьТекста(Файл.ПолноеИмя, , , Истина);
			Пустышка = Неопределено;
		Исключение
			// Файла заблокирован и значит сессия продолжается.
			Продолжить;
		КонецПопытки;
		ИмяФайлаИнформации = Файл.Путь + Файл.ИмяБезРасширения + ".inf";
		Попытка
			ОписаниеФайла = ЗначениеИзФайла(ИмяФайлаИнформации);
		Исключение
			// Файл восстановления старого формата (без файла информации)
			Продолжить;
		КонецПопытки; 
		ОписаниеФайла.Вставить("ИмяФайлаИнформации", ИмяФайлаИнформации);
		ОписаниеФайла.Вставить("ФайлВосстановления", Файл);
		ОписаниеФайла.Вставить("Устарел", Ложь);
		ОригнальныйФайл = Новый Файл(ОписаниеФайла.ИмяОткрытогоФайла);
		Если ОригнальныйФайл.Существует() Тогда
			ОписаниеФайла.Устарел = ОригнальныйФайл.ПолучитьВремяИзменения() > Файл.ПолучитьВремяИзменения();
		КонецЕсли; 
		Если ОписаниеФайла.Устарел Тогда
			ТекстАктуальности = "Старее";
		Иначе
			ТекстАктуальности = "Новее";
		КонецЕсли; 
		Если ОписаниеФайла.Обрезан Тогда
			ТекстПолноты = "Обрезан";
		Иначе
			ТекстПолноты = "Полный";
		КонецЕсли; 
		СписокВыбора.Добавить(ОписаниеФайла, "" + ДатаИзменения + " - [" + ТекстАктуальности + ", " + ТекстПолноты + "] - " + ОписаниеФайла.ИмяОткрытогоФайла);
	КонецЦикла;
	ИмяФайлаВосстановления = "";
	Если СписокВыбора.Количество() > 0 Тогда
		СписокВыбора.Добавить("<Удалить все файлы восстановления>");
		ФормаЗащиты = Неопределено;
		#Если ТолстыйКлиентУправляемоеПриложение Тогда 
			Если ирКэш.НомерИзданияПлатформыЛкс() > "82" Тогда
				// Антибаг платформы https://www.hostedredmine.com/issues/901181
				ФормаЗащиты = ОткрытьФорму("Обработка.ирПлатформа.Форма.Пустышка");
			КонецЕсли;
		#КонецЕсли
		ВыбранныйЭлемент = СписокВыбора.ВыбратьЭлемент("Открыть файл восстановления прерванной сессии");
		Если ФормаЗащиты <> Неопределено Тогда
			ФормаЗащиты.Закрыть();  
		КонецЕсли;
		Если ВыбранныйЭлемент <> Неопределено Тогда
			Если ВыбранныйЭлемент.Значение = "<Удалить все файлы восстановления>" Тогда
				Для Каждого ЭлементСписка Из СписокВыбора Цикл
					Если ВыбранныйЭлемент = ЭлементСписка Тогда
						Продолжить;
					КонецЕсли; 
					ФайлВосстановления = ЭлементСписка.Значение.ФайлВосстановления;
					УдалитьФайлы(ФайлВосстановления.Путь, ФайлВосстановления.ИмяБезРасширения + ".*");
				КонецЦикла;
			Иначе
				ОписаниеФайла = ВыбранныйЭлемент.Значение;
				выхОписаниеФайла = ОписаниеФайла;
				ИмяФайлаВосстановления = ОписаниеФайла.ФайлВосстановления.ПолноеИмя;
			КонецЕсли; 
		КонецЕсли;
	КонецЕсли;
	Возврат ИмяФайлаВосстановления;

КонецФункции

Функция ПослеВосстановленияФайлаКонсолиЛкс(Знач ОписаниеФайла) Экспорт 
	
	ФайлВосстановления = ОписаниеФайла.ФайлВосстановления;
	#Если Сервер И Не Сервер Тогда
		ФайлВосстановления = Новый Файл;
	#КонецЕсли
	Результат = ФайлВосстановления.ПолноеИмя;
	Если Не ОписаниеФайла.Обрезан И Не ОписаниеФайла.Устарел Тогда
		Результат = ОписаниеФайла.ИмяОткрытогоФайла;
	ИначеЕсли ОписаниеФайла.Обрезан Тогда 
		ирОбщий.СообщитьЛкс(ирОбщий.СтрШаблонИменЛкс("Загружена обрезанная версия файла %1",, ОписаниеФайла.ИмяОткрытогоФайла));
	Иначе
		ирОбщий.СообщитьЛкс(ирОбщий.СтрШаблонИменЛкс("Загружена старая версия файла %1",, ОписаниеФайла.ИмяОткрытогоФайла));
	КонецЕсли; 
	УдалитьФайлы(ФайлВосстановления.Путь, ФайлВосстановления.ИмяБезРасширения + ".*");
	Возврат Результат;

КонецФункции

Процедура УдалитьФайлВосстановленияКонсолиСБлокировкойЛкс(СтруктураВосстановления) Экспорт
	
	СтруктураВосстановления.БлокировкаВосстановления = Неопределено;
	ФайлВосстановления = СтруктураВосстановления.ФайлВосстановления;
	Попытка
		УдалитьФайлы(ФайлВосстановления.Путь, ФайлВосстановления.ИмяБезРасширения + ".*");
	Исключение
	КонецПопытки; 

КонецПроцедуры

Процедура СчитатьПорциюВыборкиВТаблицуЛкс(Выборка, ТаблицаПриемник, Знач РазмерПорции = 9999, СчитыватьЧерезКопиюТаблицы = Истина, СсылкаНаБуфернуюТаблицу = Неопределено) Экспорт

	#Если Сервер И Не Сервер Тогда
	    Пустышка = Новый Запрос;
		Выборка = Пустышка.Выполнить();
	#КонецЕсли
	Если СчитыватьЧерезКопиюТаблицы Тогда
		// Иначе добавление и заполнение строк при связи с табличным полем будет дольше выполняться
		КопияТаблицыПриемника = ТаблицаПриемник.Скопировать();
		Если СсылкаНаБуфернуюТаблицу <> Неопределено Тогда
			СсылкаНаБуфернуюТаблицу.Вставить("Таблица", КопияТаблицыПриемника);
		КонецЕсли;
	Иначе
		КопияТаблицыПриемника = ТаблицаПриемник;
	КонецЕсли; 
	КоличествоРезультата = Выборка.Количество();
	Несчитано = КоличествоРезультата - КопияТаблицыПриемника.Количество();
	Если Ложь
		Или РазмерПорции > Несчитано 
		Или РазмерПорции = 0
	Тогда
		РазмерПорции = Несчитано;
	КонецЕсли; 
	Если Несчитано = РазмерПорции Тогда
		ПредставлениеПроцесса = "Загрузка выборки";
	Иначе
		ПредставлениеПроцесса = "Загрузка порции выборки";
	КонецЕсли;
	Индикатор = ирОбщий.ПолучитьИндикаторПроцессаЛкс(РазмерПорции, ПредставлениеПроцесса);
	КолонкиВложенныхТаблиц = Новый Массив();
	Для Каждого Колонка Из Выборка.Владелец().Колонки Цикл
		Если Колонка.ТипЗначения.СодержитТип(Тип("РезультатЗапроса")) Тогда
			КолонкиВложенныхТаблиц.Добавить(Колонка.Имя);
		КонецЕсли; 
	КонецЦикла;
	ЕстьКолонкиВложенныхТаблиц = КолонкиВложенныхТаблиц.Количество() > 0;
	РазмерПорцииОсталось = РазмерПорции;
	_РежимОтладки = Ложь;
	Если _РежимОтладки Тогда // Можно менять на Истина в точке останова
		// Пассивный оригинал расположенного ниже однострочного кода. Выполняйте изменения синхронно в обоих вариантах.
		Пока Выборка.Следующий() Цикл
			НоваяСтрока = КопияТаблицыПриемника.Добавить();
			ЗаполнитьЗначенияСвойств(НоваяСтрока, Выборка);
			Если ЕстьКолонкиВложенныхТаблиц Тогда
				Для Каждого КолонкаВложеннойТаблицы Из КолонкиВложенныхТаблиц Цикл
					НоваяСтрока[КолонкаВложеннойТаблицы] = Выборка[КолонкаВложеннойТаблицы].Выгрузить();
				КонецЦикла; 
			КонецЕсли; 
			Если РазмерПорцииОсталось > 0 Тогда
				РазмерПорцииОсталось = РазмерПорцииОсталось - 1;
				Если РазмерПорцииОсталось = 0 Тогда
					Прервать;
				КонецЕсли; 
			КонецЕсли; 
			ирОбщий.ОбработатьИндикаторЛкс(Индикатор);
		КонецЦикла;
	Иначе
		// Однострочный код использован для ускорения. Выше расположен оригинал. Выполняйте изменения синхронно в обоих вариантах. Преобразовано консолью кода из подсистемы "Инструменты разработчика" (http://devtool1c.ucoz.ru)
		Пока Выборка.Следующий() Цикл  		НоваяСтрока = КопияТаблицыПриемника.Добавить();  		ЗаполнитьЗначенияСвойств(НоваяСтрока, Выборка);  		Если ЕстьКолонкиВложенныхТаблиц Тогда  			Для Каждого КолонкаВложеннойТаблицы Из КолонкиВложенныхТаблиц Цикл  				НоваяСтрока[КолонкаВложеннойТаблицы] = Выборка[КолонкаВложеннойТаблицы].Выгрузить();  			КонецЦикла;  		КонецЕсли;  		Если РазмерПорцииОсталось > 0 Тогда  			РазмерПорцииОсталось = РазмерПорцииОсталось - 1;  			Если РазмерПорцииОсталось = 0 Тогда  				Прервать;  			КонецЕсли;  		КонецЕсли;  		ирОбщий.ОбработатьИндикаторЛкс(Индикатор);  	КонецЦикла;  
	КонецЕсли;
	Если РазмерПорции = Несчитано Тогда
		Выборка = Неопределено;
	КонецЕсли; 
	ирОбщий.ОсвободитьИндикаторПроцессаЛкс();
	ТаблицаПриемник = КопияТаблицыПриемника;

КонецПроцедуры

// ТабличноеПоле определяется как источник действий командной панели.
// Параметру ВыборкаРезультата внутри присваивается значение!
Процедура ЗагрузитьВыборкуВТабличноеПолеПервуюПорциюЛкс(ЭтаФорма, РезультатЗапроса, ВыборкаРезультата, КоманднаяПанель,
	ИмяОбработчикаОбновления = "ОбновитьРазмерДинамическойТаблицы", БезопасныйПорогКоличестваСтрок = 100000, СсылкаНаБуфернуюТаблицу = Неопределено) Экспорт

	#Если Сервер И Не Сервер Тогда
		лЗапрос = Новый Запрос;
	    РезультатЗапроса = лЗапрос.Выполнить();
	#КонецЕсли
	//БезопасныйПорогКоличестваСтрок = 1; // Для отладки
	ВыборкаРезультата = РезультатЗапроса.Выбрать();
	ТабличноеПоле = КоманднаяПанель.ИсточникДействий;
	НачалоЗагрузки = ТекущаяДата();
	Если Ложь
		Или БезопасныйПорогКоличестваСтрок = 0
		Или ВыборкаРезультата.Количество() < БезопасныйПорогКоличестваСтрок 
	Тогда
		ВыборкаРезультата = Неопределено;
		КоманднаяПанель.Кнопки.ЗагрузитьПолностью.Доступность = Ложь;
		ТабличноеПоле.Значение = РезультатЗапроса.Выгрузить(ОбходРезультатаЗапроса.Прямой);
		Попытка
			Выполнить("ЭтаФорма." + ИмяОбработчикаОбновления + "()");
		Исключение
			ВызватьИсключение ОписаниеОшибки();
		КонецПопытки;
	Иначе
		ТабличноеПоле.Значение = Новый ТаблицаЗначений;
		Для Каждого Колонка Из РезультатЗапроса.Колонки Цикл
			ТипЗначения = Колонка.ТипЗначения;
			Если ТипЗначения.СодержитТип(Тип("РезультатЗапроса")) Тогда
				ТипЗначения = Новый ОписаниеТипов("ТаблицаЗначений");
			КонецЕсли; 
			ТабличноеПоле.Значение.Колонки.Добавить(Колонка.Имя, ТипЗначения, Колонка.Имя, Колонка.Ширина);
		КонецЦикла;
		ВыполнитьОтдельноЛкс(ИмяОбработчикаОбновления, ЭтаФорма);
		СчитатьПорциюВыборкиВТаблицуЛкс(ВыборкаРезультата, ТабличноеПоле.Значение, БезопасныйПорогКоличестваСтрок, , СсылкаНаБуфернуюТаблицу);
	КонецЕсли; 
	Длительность = ТекущаяДата() - НачалоЗагрузки;
	Если Длительность > 30 Тогда
		ирОбщий.СообщитьЛкс(ирОбщий.СтрШаблонИменЛкс("Загрузка выборки выполнена за %1с",, Длительность));
	КонецЕсли; 

КонецПроцедуры

Процедура ВыполнитьОтдельноЛкс(Знач ИмяМетода, Знач ЭтаФорма = Неопределено) Экспорт 
	
	Если ЭтаФорма = Неопределено Тогда
		ПодключитьГлобальныйОбработчикОжиданияЛкс(ИмяМетода);
	Иначе
		ЭтаФорма.ПодключитьОбработчикОжидания(ИмяМетода, 0.1, Истина);
	КонецЕсли;

КонецПроцедуры

// ТабличноеПоле определяется как источник действий командной панели.
Процедура ЗагрузитьВыборкуВТабличноеПолеПолностьюЛкс(ЭтаФорма, мВыборкаРезультата, КоманднаяПанель,
	ИмяОбработчикаОбновления = "ОбновитьРазмерДинамическойТаблицы", СсылкаНаБуфернуюТаблицу = Неопределено) Экспорт

	ВыполнитьОтдельноЛкс(ИмяОбработчикаОбновления, ЭтаФорма);
	ТабличноеПоле = КоманднаяПанель.ИсточникДействий;
	СчитатьПорциюВыборкиВТаблицуЛкс(мВыборкаРезультата, ТабличноеПоле.Значение, 0, , СсылкаНаБуфернуюТаблицу);

КонецПроцедуры

// Параметру КоличествоРезультата внутри присваивается значение!
Процедура ПослеЗагрузкиВыборкиВТабличноеПолеЛкс(ЭтаФорма, мВыборкаРезультата, КоманднаяПанель, ПолеСтрокиКоличестваРезультата, СсылкаНаБуфернуюТаблицу = Неопределено) Экспорт
	
	ТабличноеПоле = КоманднаяПанель.ИсточникДействий;
	Если ТипЗнч(ТабличноеПоле.Значение) = Тип("ДеревоЗначений") Тогда
		КоличествоСтрокВТабличномПоле = ирОбщий.ВсеСтрокиДереваЗначенийЛкс(ТабличноеПоле.Значение).Количество();
	Иначе
		КоличествоСтрокВТабличномПоле = ТабличноеПоле.Значение.Количество();
	КонецЕсли; 
	Если ТипЗнч(мВыборкаРезультата) = Тип("COMОбъект") Тогда
		КоличествоРезультата = 0;
		Попытка
			КоличествоРезультата = мВыборкаРезультата.Count;
		Исключение
			Если мВыборкаРезультата.State <> 0 Тогда
				КоличествоРезультата = мВыборкаРезультата.RecordCount;
			КонецЕсли; 
		КонецПопытки; 
		//ВсеСчитано = КоличествоРезультата = КоличествоСтрокВТабличномПоле;
	ИначеЕсли ТипЗнч(мВыборкаРезультата) = Тип("ВыборкаИзРезультатаЗапроса") Тогда
		КоличествоРезультата = мВыборкаРезультата.Количество();
		Если СсылкаНаБуфернуюТаблицу <> Неопределено И СсылкаНаБуфернуюТаблицу.Свойство("Таблица") Тогда
			ТабличноеПоле.Значение = СсылкаНаБуфернуюТаблицу.Таблица;
			КоличествоСтрокВТабличномПоле = ТабличноеПоле.Значение.Количество();
		КонецЕсли; 
		//ВсеСчитано = Ложь;
	Иначе
		КоличествоРезультата = КоличествоСтрокВТабличномПоле;
		//ВсеСчитано = Истина;
	КонецЕсли; 
	ВсеСчитано = КоличествоРезультата = КоличествоСтрокВТабличномПоле;
	ОбновитьЧислоЗагруженныхЭлементовВыборкиЛкс(ТабличноеПоле, КоманднаяПанель, ПолеСтрокиКоличестваРезультата, КоличествоСтрокВТабличномПоле,
		КоличествоРезультата, ВсеСчитано);

КонецПроцедуры

Функция ЗагрузитьСвязанныеСтрокиТаблицыБДЛкс(ЭтаФорма, ТабличноеПолеСвязанныхКолонок, ТабличноеПолеСвязанныхСтрок, КоманднаяПанельСвязанныхСтрок, мВыборкаРезультатаСтрокиТаблицы,
	ЗначениеОтбора, Знач ВидСравненияНовый = Неопределено, МаксимальнаяПорция = 500000) Экспорт 
	
	СтрокаСвязаннойКолонки = ТабличноеПолеСвязанныхКолонок.ТекущаяСтрока;
	ЭтаФорма.СтрокиТаблицыБД = Новый ТаблицаЗначений;
	ТабличноеПолеСвязанныхСтрок.СоздатьКолонки();
	Если СтрокаСвязаннойКолонки = Неопределено Тогда
		Возврат Неопределено;
	КонецЕсли; 
	Запрос = ЗапросСтрокСоЗначениемВКолонкеБДЛкс(СтрокаСвязаннойКолонки, ЗначениеОтбора, ВидСравненияНовый, МаксимальнаяПорция);
	#Если Сервер И Не Сервер Тогда
		Запрос = Новый Запрос;
	#КонецЕсли
	Попытка
		РезультатСтрокиТаблицы = Запрос.Выполнить();
	Исключение
		// Антибаг платформы 8.2.14 http://partners.v8.1c.ru/forum/thread.jsp?id=1031481#1031481
		ирОбщий.СообщитьЛкс(ОписаниеОшибки());
		Возврат Неопределено;
	КонецПопытки; 
	ЗагрузитьВыборкуВТабличноеПолеПервуюПорциюЛкс(ЭтаФорма, РезультатСтрокиТаблицы, мВыборкаРезультатаСтрокиТаблицы, КоманднаяПанельСвязанныхСтрок);
	
	//Если СтрокиТаблицыБД.Количество() = МаксимальныйРазмер Тогда
	//	ирОбщий.СообщитьЛкс("Были выбраны первые " + МаксимальныйРазмер + " строк таблицы");
	//КонецЕсли; 
	СтруктураОтбора = Новый Структура("ПолноеИмяТаблицы, ИмяКолонки", СтрокаСвязаннойКолонки.ПолноеИмяТаблицы, СтрокаСвязаннойКолонки.ИмяКолонки);
	ЗаполнитьЗначенияСвойств(СтруктураОтбора, СтрокаСвязаннойКолонки); 
	ТабличноеПолеСвязанныхСтрок.СоздатьКолонки();
	Для Каждого КолонкаТП Из ТабличноеПолеСвязанныхСтрок.Колонки Цикл
		КолонкаТП.ТолькоПросмотр = Истина;
	КонецЦикла;
	Попытка
		ИскомаяСсылка = СтрокаСвязаннойКолонки.Ссылка
	Исключение
		ИскомаяСсылка = Неопределено;
	КонецПопытки;
	Если ИскомаяСсылка <> Неопределено Тогда
		ТекущаяСтрока = ТабличноеПолеСвязанныхСтрок.Значение.Найти(ИскомаяСсылка, СтрокаСвязаннойКолонки.ИмяКолонки);
		Если ТекущаяСтрока <> Неопределено Тогда
			ТабличноеПолеСвязанныхСтрок.ТекущаяСтрока = ТекущаяСтрока;
		КонецЕсли; 
	КонецЕсли;
	ирОбщий.НастроитьДобавленныеКолонкиТабличногоПоляЛкс(ТабличноеПолеСвязанныхСтрок,,,, Истина);
	ТабличноеПолеСвязанныхСтрок.ТекущаяКолонка = ТабличноеПолеСвязанныхСтрок.Колонки[СтрокаСвязаннойКолонки.ИмяКолонки];
	Возврат СтрокаСвязаннойКолонки.ПолноеИмяТаблицы;

КонецФункции

Функция ЗапросСтрокСоЗначениемВКолонкеБДЛкс(Знач СтрокаСвязаннойКолонки, Знач ЗначениеОтбора, Знач ВидСравненияНовый = Неопределено, Знач МаксимальнаяПорция = 0) Экспорт 
	
	// Антибаг 8.2.14 http://partners.v8.1c.ru/forum/thread.jsp?id=1017264#1017264
	Если Истина
		И СтрокаСвязаннойКолонки.ТипТаблицы = "Изменения" 
		И Найти(СтрокаСвязаннойКолонки.ПолноеИмяТаблицы, "РегистрСведений.") = 1
		И ирКэш.ДоступныОбщиеРеквизитыЛкс()
	Тогда
		Если Метаданные.ОбщиеРеквизиты.Количество() > 0 Тогда
			Возврат Неопределено;
		КонецЕсли; 
	КонецЕсли; 
	//Если ЗначениеОтбора = Неопределено Тогда
	//	ЗначениеОтбора = СтрокаСвязаннойКолонки.Ссылка;
	//КонецЕсли; 
	ПоляТаблицыБД = ирКэш.ПоляТаблицыБДЛкс(СтрокаСвязаннойКолонки.ПолноеИмяТаблицы);
	ТекстПоля = "";
	Для Каждого ПолеТаблицыБД Из ПоляТаблицыБД Цикл
		#Если Сервер И Не Сервер Тогда
			ПолеТаблицы = Обработки.ирТипПолеБД.Создать();
		#КонецЕсли
		Если Ложь
			Или ПолеТаблицыБД.ТипЗначения.СодержитТип(Тип("ХранилищеЗначения"))
			Или ПолеТаблицыБД.ТипЗначения.СодержитТип(Тип("ТаблицаЗначений"))
		Тогда
			Продолжить;
		КонецЕсли; 
		Если ЗначениеЗаполнено(ТекстПоля) Тогда
			ТекстПоля = ТекстПоля + ", ";
		КонецЕсли; 
		ТекстПоля = ТекстПоля + "Т." + ПолеТаблицыБД.Имя;
	КонецЦикла;
	ТекстПервые = "";
	Если МаксимальнаяПорция > 0 Тогда
		ТекстПервые = " ПЕРВЫЕ " + Формат(МаксимальнаяПорция, "ЧГ=") + " ";
	КонецЕсли; 
	ТекстЗапроса = "
	|ВЫБРАТЬ " + ТекстПервые + " " + ТекстПоля + "
	|ИЗ " + ирКэш.ИмяТаблицыИзМетаданныхЛкс(СтрокаСвязаннойКолонки.ПолноеИмяТаблицы) + " КАК Т";
	
	// Очень долгий способ
	//ТекстЗапроса = ТекстЗапроса + "
	//|{ГДЕ " + ПсевдонимТаблицы + "." + СтрокаСвязаннойКолонки.ИмяКолонки + "}";
	//Схема = СоздатьСхемуКомпоновкиПоЗапросу(ТекстЗапроса);
	//НастройкаКомпоновки = Новый НастройкиКомпоновкиДанных;
	//ирОбщий.НайтиДобавитьЭлементОтбораКомпоновкиЛкс(НастройкаКомпоновки, СтрокаСвязаннойКолонки.ИмяКолонки, ЗначениеОтбора, ВидСравненияНовый); 
	//Запрос = ирОбщий.ЗапросИзКомпоновкиЛкс(Схема, НастройкаКомпоновки);
	//
	ВыражениеСравнения = ирОбщий.ВыражениеСравненияСПараметромВЗапросеЛкс(ПоляТаблицыБД.Найти(СтрокаСвязаннойКолонки.ИмяКолонки, "Имя"), ВидСравненияНовый, "ЗначениеОтбора");
	ТекстЗапроса = ТекстЗапроса + "
	|ГДЕ Т." + СтрокаСвязаннойКолонки.ИмяКолонки + " " + ВыражениеСравнения;
	ПостроительПорядка = ирОбщий.ОсновнойПорядокТаблицыБДЛкс(СтрокаСвязаннойКолонки.ПолноеИмяТаблицы,,,, Истина);
	Если ЗначениеЗаполнено(ПостроительПорядка.Порядок) Тогда
		ТекстЗапроса = ТекстЗапроса + "
		|УПОРЯДОЧИТЬ ПО " + ирОбщий.ПорядокВСтрокуЛкс(ПостроительПорядка.Порядок);
	КонецЕсли;
	Запрос = Новый Запрос(ТекстЗапроса);
	Запрос.Параметры.Вставить("ЗначениеОтбора", ЗначениеОтбора);
	Возврат Запрос;

КонецФункции

Процедура ОбновитьЧислоЗагруженныхЭлементовВыборкиЛкс(ТабличноеПоле, КоманднаяПанель, ПолеСтрокиКоличестваРезультата, КоличествоЗагружено, КоличествоРезультата, ВсеСчитано) Экспорт
	
	Если ВсеСчитано Тогда
		СтрокаКоличествоРезультата = "" + КоличествоЗагружено;
		ПолеСтрокиКоличестваРезультата.ЦветФона = Новый Цвет();
	Иначе
		СтрокаКоличествоРезультата = "" + КоличествоЗагружено + "/" + КоличествоРезультата;
		ПолеСтрокиКоличестваРезультата.ЦветФона = ирОбщий.ЦветСтиляЛкс("ирЦветФонаВычисляемогоЗначения");
	КонецЕсли;
	ПолеСтрокиКоличестваРезультата.Значение = СтрокаКоличествоРезультата;
	КоманднаяПанель.Кнопки.ЗагрузитьПолностью.Доступность = Не ВсеСчитано;

КонецПроцедуры

// Заменяет текущее выделение в поле текстового документа новым текстом. 
// После этого устанавливает выделение на вставленный фрагмент.
//
// Параметры:
//  ПолеТекста - ПолеТекста;
//  НовыйТекст   - Строка.
//
Процедура ЗаменитьВыделенныйТекстСохраняяГраницыВыделенияЛкс(Знач ПолеТекста, Знач НовыйТекст) Экспорт

	Перем НачальнаяСтрока;
	Перем НачальнаяКолонка;
	Перем КонечнаяСтрока;
	Перем КонечнаяКолонка;
	
	ПолеТекста = ОболочкаПоляТекстаЛкс(ПолеТекста);
	#Если Сервер И Не Сервер Тогда
		ПолеТекста = Обработки.ирОболочкаПолеТекста.Создать();
	#КонецЕсли
	ПолеТекста.ПолучитьГраницыВыделения(НачальнаяСтрока, НачальнаяКолонка, КонечнаяСтрока, КонечнаяКолонка);
	ПолеТекста.УстановитьГраницыВыделения(1, 1, НачальнаяСтрока, НачальнаяКолонка);
	НачальнаяГраница = СтрДлина(ПолеТекста.ВыделенныйТекст()) + 1;
	ПолеТекста.УстановитьГраницыВыделения(НачальнаяСтрока, НачальнаяКолонка, КонечнаяСтрока, КонечнаяКолонка);
	ПолеТекста.ВыделенныйТекст(НовыйТекст);
	КонечнаяГраница = НачальнаяГраница + СтрДлина(НовыйТекст);
	Если КонечнаяГраница > СтрДлина(ПолеТекста.ПолучитьТекст()) Тогда
		КонечнаяГраница = КонечнаяГраница - 1;
	КонецЕсли; 
	ПолеТекста.УстановитьГраницыВыделения(НачальнаяГраница, КонечнаяГраница);

КонецПроцедуры

Процедура УстановитьТекстСОткатомЛкс(Знач ПолеТекста, Знач Текст) Экспорт

	ПолеТекста = ОболочкаПоляТекстаЛкс(ПолеТекста);
	#Если Сервер И Не Сервер Тогда
		ПолеТекста = Обработки.ирОболочкаПолеТекста.Создать();
	#КонецЕсли
	СтарыйТекст = ПолеТекста.ПолучитьТекст();
	ПолеТекста.УстановитьГраницыВыделения(1, СтрДлина(СтарыйТекст) + 1);
	ПолеТекста.ВыделенныйТекст(Текст);

КонецПроцедуры

Функция ОболочкаПоляТекстаЛкс(Знач ПолеТекста) Экспорт 
	ТипПоля = ТипЗнч(ПолеТекста);
	Если Ложь
		Или ТипПоля = Тип("ПолеВвода")
		Или ТипПоля = Тип("ПолеТекстовогоДокумента")
		Или ТипПоля = Тип("ПолеHTMLДокумента")
		Или (Истина
			И ТипПоля = Тип("ПолеФормы") 
			И (Ложь
				Или ПолеТекста.Вид = ВидПоляФормы.ПолеВвода
				Или ПолеТекста.Вид = ВидПоляФормы.ПолеТекстовогоДокумента
				Или ПолеТекста.Вид = ВидПоляФормы.ПолеHTMLДокумента))
	Тогда
		ОболочкаПолеТекста = ирОбщий.СоздатьОбъектПоИмениМетаданныхЛкс("Обработка.ирОболочкаПолеТекста");
		#Если Сервер И Не Сервер Тогда
			ОболочкаПолеТекста = Обработки.ирОболочкаПолеТекста.Создать();
		#КонецЕсли
		ОболочкаПолеТекста.ЭлементФормы = ПолеТекста;
	Иначе
		ОболочкаПолеТекста = ПолеТекста;
	КонецЕсли;
	Возврат ОболочкаПолеТекста;
КонецФункции

Функция ЛиОболочкаТекстаЛкс(Объект) Экспорт 
	
	Результат = Ложь
		Или (Истина
			И ирКэш.ЛиПортативныйРежимЛкс()
			И ирОбщий.ЛиВнешняяОбработкаЛкс(Объект))
		Или (Истина
			И Не ирКэш.ЛиПортативныйРежимЛкс()
			И ТипЗнч(Объект) = Тип("ОбработкаОбъект.ирОболочкаПолеТекста"));
	Возврат Результат;
	
КонецФункции

Процедура ЗаменитьИВыделитьВыделенныйТекстПоляЛкс(Знач ЭтаФорма, Знач ПолеТекстаВыражения, Знач НовыйВыделенныйТекст = "") Экспорт 
	
	Перем Граница1, Граница2, Граница3, Граница4;
	ПолеТекстаВыражения = ОболочкаПоляТекстаЛкс(ПолеТекстаВыражения);
	#Если Сервер И Не Сервер Тогда
		ПолеТекстаВыражения = Обработки.ирОболочкаПолеТекста.Создать();
	#КонецЕсли
	Граница1 = 0; Граница2 = 0; Граница3 = 0; Граница4 = 0;
	ПолеТекстаВыражения.ПолучитьГраницыВыделения(Граница1, Граница2, Граница3, Граница4);
	Если Не ЗначениеЗаполнено(НовыйВыделенныйТекст) Тогда
		Если ТипЗнч(ПолеТекстаВыражения) = Тип("ПолеВвода") Тогда
			НовыйВыделенныйТекст = ПолеТекстаВыражения.Значение;
		Иначе
			НовыйВыделенныйТекст = ПолеТекстаВыражения.ПолучитьТекст();
		КонецЕсли;
		Граница2 = 1;
	Иначе
		ПолеТекстаВыражения.ВыделенныйТекст(НовыйВыделенныйТекст);
	КонецЕсли; 
	ПолеТекстаВыражения.УстановитьГраницыВыделения(Граница1, Граница2, Граница1, Граница2 + СтрДлина(НовыйВыделенныйТекст));
	ЭтаФорма.ТекущийЭлемент = ПолеТекстаВыражения.ЭлементФормы;

КонецПроцедуры

// Функция - Найти показать строку в поле текстового документа лкс
//
// Параметры:
//  Форма					 - 	 - 
//  ПолеТекста               - ПолеТекста, ПолеВвода - 
//  СтрокаПоиска			 - 	 - 
//  СловоЦеликом	 - Булево, Строка - если строка, то регулярное выражение с подстановкой "#Слово#"
// 
// Возвращаемое значение:
//   - Булево - была ли найдена и выделена строка
//
Функция НайтиПоказатьСтрокуВПолеТекстаЛкс(Форма = Неопределено, Знач ПолеТекста, Знач СтрокаПоиска, Знач СловоЦеликом = Ложь, Знач ИскатьСНачала = Ложь) Экспорт
	
	ПолеТекста = ОболочкаПоляТекстаЛкс(ПолеТекста);
	#Если Сервер И Не Сервер Тогда
		ПолеТекста = Обработки.ирОболочкаПолеТекста.Создать();
	#КонецЕсли
	НачальнаяПозиция = 0;
	КонечнаяПозиция = 0;
	Если Не ИскатьСНачала Тогда
		ПолеТекста.ВыделениеОдномерное(НачальнаяПозиция, КонечнаяПозиция);
	КонецЕсли;
	Позиция = ирОбщий.СтрНайтиСловоЛкс(ПолеТекста.ПолучитьТекст(), СтрокаПоиска, КонечнаяПозиция, СловоЦеликом);
	Если Позиция > 0 Тогда
		Если Форма <> Неопределено Тогда
			Форма.ТекущийЭлемент = ПолеТекста.ЭлементФормы;
		КонецЕсли; 
		ПолеТекста.УстановитьГраницыВыделения(Позиция, Позиция + СтрДлина(СтрокаПоиска),,,, Форма);
		Результат = Истина;
	Иначе
		Если СтрДлина(ПолеТекста.ВыделенныйТекст()) > 0 Тогда
			ПолеТекста.УстановитьГраницыВыделения(1, 1);
		КонецЕсли; 
		Результат = Ложь;
	КонецЕсли;
	Возврат Результат;

КонецФункции

// Функция - Открыть гиперссылку из поля HTMLЛкс
//
// Параметры:
//  htmlElement		 - 	 - 
//  МодификаторCTRL	 - 	 - 
// 
// Возвращаемое значение:
//   - Булево - гиперссылка открыта
//
Функция ОткрытьГиперссылкуИзПоляHTMLЛкс(Знач htmlElement, Знач МодификаторCTRL = Истина) Экспорт 
	
	Пока htmlElement <> Неопределено И htmlElement <> Null И ВРег(htmlElement.tagName) <> "A" Цикл
		htmlElement = htmlElement.parentElement;
	КонецЦикла;
	Если htmlElement = Неопределено Или htmlElement = Null Тогда
		Возврат Ложь;
	КонецЕсли;
	Если htmlElement.hasAttribute("data-href") Тогда
		Если Не МодификаторCTRL Тогда
			Возврат Ложь;
		КонецЕсли;
		//НовыйАдрес = htmlElement.getAttribute("data-href");
		НовыйАдрес = htmlElement.textContent;
	Иначе
		НовыйАдрес = htmlElement.href;
	КонецЕсли;
	Если ЗначениеЗаполнено(НовыйАдрес) Тогда
	//Если Ложь
	//	Или ирОбщий.СтрНачинаетсяСЛкс(НовыйАдрес, "http://")
	//	Или ирОбщий.СтрНачинаетсяСЛкс(НовыйАдрес, "https://")
	//	Или ирОбщий.СтрНачинаетсяСЛкс(НовыйАдрес, "e1c://")
	//	Или ирОбщий.СтрНачинаетсяСЛкс(НовыйАдрес, "ftp://")
	//	Или ирОбщий.СтрНачинаетсяСЛкс(НовыйАдрес, "file://")
	//Тогда
		ЗапуститьПриложение(НовыйАдрес);
		Возврат Истина;
	КонецЕсли;
	Возврат Ложь;

КонецФункции

// .
// Параметры:
//   Элемент - ПолеТабличногоДокумента
//
Функция ПолеТабличногоДокумента_ПредставлениеСуммыВыделенныхЯчеекЛкс(Знач ПолеТД, Знач Принудительно = Ложь) Экспорт

	#Если Сервер И Не Сервер Тогда
		ПолеТД = Новый ТабличныйДокумент;
	#КонецЕсли
	ВыделенныеОбласти = ПолеТД.ВыделенныеОбласти;
	НачальноеКоличество = ВыделенныеОбласти.Количество();
	Если Истина
		И Не Принудительно
		И НачальноеКоличество = 1
		И (Ложь
			Или ТипЗнч(ВыделенныеОбласти[0]) = Тип("РисунокТабличногоДокумента")
			Или ПолеТД.Область(ВыделенныеОбласти[0].Низ, ВыделенныеОбласти[0].Право).Имя = ВыделенныеОбласти[0].Имя)
	Тогда
		Возврат "";
	КонецЕсли;
	Сумма = 0;
	СчетчикЯчеекСуммы = 0;
	СчетчикЯчеекОбщий = 0;
	ЕстьИгнорированныеОбласти = Ложь;
	Для СчетчикВыделенныеОбласти = 1 По НачальноеКоличество Цикл
		Область = ВыделенныеОбласти[НачальноеКоличество - СчетчикВыделенныеОбласти];
		Если ТипЗнч(Область) = Тип("РисунокТабличногоДокумента") Тогда
			Продолжить;
		КонецЕсли;
		Право = Область.Право;
		Если Право = 0 Тогда
			Право = ПолеТД.ШиринаТаблицы;
		КонецЕсли;
		ПлощадьОбласти = (Право - Область.Лево + 1) * (Область.Низ - Область.Верх + 1);
		СчетчикЯчеекОбщий = СчетчикЯчеекОбщий + ПлощадьОбласти;
		Если Ложь
			Или ПлощадьОбласти < 1000 
			Или Принудительно И ПлощадьОбласти < 10000 
		Тогда
			Для НомерКолонки = Область.Лево по Право Цикл
				Для НомерСтроки = Область.Верх по Область.Низ Цикл
					ОбластьЯчейки = ПолеТД.Область(НомерСтроки, НомерКолонки);
					Если ОбластьЯчейки.Лево <> НомерКолонки Или ОбластьЯчейки.Верх <> НомерСтроки Тогда
						// Данная ячейка принадлежит объединенным ячейкам и не является начальной ячейкой
						Продолжить;
					КонецЕсли;
					Попытка
						Число = Число(ОбластьЯчейки.Текст);
					Исключение 
						Продолжить;
					КонецПопытки; 
					Сумма = Сумма + Число;
					СчетчикЯчеекСуммы = СчетчикЯчеекСуммы + 1;
				КонецЦикла;
			КонецЦикла;
		Иначе
			ЕстьИгнорированныеОбласти = Истина;
		КонецЕсли;
	КонецЦикла;
	СчетчикЯчеекСуммы = "" + СчетчикЯчеекСуммы;
	Сумма = "" + Сумма;
	Если ЕстьИгнорированныеОбласти Тогда
		СчетчикЯчеекСуммы = СчетчикЯчеекСуммы + "+?";
		Сумма = Сумма + "+?";
	КонецЕсли;
	Текст = "" + СчетчикЯчеекСуммы + " из " + СчетчикЯчеекОбщий + " яч. = " + Сумма + "";
	Возврат Текст;
	
КонецФункции

Процедура ПолеТабличногоДокументаПриАктивизацииОбластиЛкс(Знач ЭтаФорма, Знач ПолеТД) Экспорт 
	
	#Если Сервер И Не Сервер Тогда
		ПолеТД = Новый ТабличныйДокумент;
	#КонецЕсли
	ДопСвойства = ДопСвойстваЭлементаФормыЛкс(ЭтаФорма, ПолеТД);
	Если ДопСвойства.КнопкаОтображенияПодвала <> Неопределено Тогда
		ДопСвойства.КнопкаОтображенияПодвала.Текст = ПолеТабличногоДокумента_ПредставлениеСуммыВыделенныхЯчеекЛкс(ПолеТД, ДопСвойства.КнопкаОтображенияПодвала.Пометка);
	КонецЕсли;
	Если Ложь
		Или ДопСвойства.КнопкаОформленияТекущихСтрок = Неопределено 
		Или ДопСвойства.КнопкаОформленияТекущихСтрок.Пометка
	Тогда
		ПараметрыОбработчика = Новый Структура;
		ПараметрыОбработчика.Вставить("ЭтаФорма", ЭтаФорма);
		ПараметрыОбработчика.Вставить("ПолеТабличногоДокумента", ПолеТД);
		Если Не ПодключитьОбработчикОжиданияСПараметрамиЛкс("ирКлиент.ПолеТабличногоДокументаОформитьТекущиеСтрокиОтложенноЛкс", ПараметрыОбработчика,,, Ложь) Тогда 
			ирКлиент.ПолеТабличногоДокументаОформитьТекущиеСтрокиОтложенноЛкс(ПараметрыОбработчика);
		КонецЕсли;
	Иначе
		ПолеТабличногоДокументаВосстановитьОформлениеТекущихСтрокЛкс(ЭтаФорма, ПолеТД);
	КонецЕсли;

КонецПроцедуры

Процедура ПолеТабличногоДокументаОформитьТекущиеСтрокиОтложенноЛкс(Параметры) Экспорт 
	ПолеТабличногоДокументаОформитьТекущиеСтрокиЛкс(Параметры.ЭтаФорма, Параметры.ПолеТабличногоДокумента);
КонецПроцедуры

Функция ДополнительныеДействияРасшифровкиКомпоновкиЛкс(Знач ДоступныеДействия, Знач ЭлементРасшифровки, Знач ДополнительныеПунктыМеню = Неопределено, выхКоличествоСсылочныхПолей = 0,
	ЗамещатьСтандартные = Ложь, ЗначенияВсехПолей = Неопределено) Экспорт 
	
	#Если Сервер И Не Сервер Тогда
	    ЭлементРасшифровки = Новый ЭлементРасшифровкиКомпоновкиДанныхПоля;
	#КонецЕсли
	Если ДополнительныеПунктыМеню = Неопределено Тогда
		ДополнительныеПунктыМеню = Новый СписокЗначений;
	КонецЕсли;
	выхКоличествоСсылочныхПолей = 0;
	СписокДействийОформить = Новый СписокЗначений;
	СписокДействийОтборать = Новый СписокЗначений;
	СписокДействийСгруппировать = Новый СписокЗначений;
	СписокДействийУпорядочить = Новый СписокЗначений;
	СписокДействийГруппировки = Новый СписокЗначений;
	ЗначенияПолей = ЭлементРасшифровки.ПолучитьПоля();
	Для каждого ЗначениеПоля Из ЗначенияПолей Цикл
		ДобавитьДействияРасшифровкиПоПолюЛкс(Истина, ДополнительныеПунктыМеню, ЗначениеПоля, СписокДействийОтборать, СписокДействийОформить, СписокДействийСгруппировать, СписокДействийУпорядочить,
			ЭлементРасшифровки, выхКоличествоСсылочныхПолей);
	КонецЦикла;
	Если ЗначенияВсехПолей = Неопределено Тогда
		ЗначенияВсехПолей = Новый Соответствие;
		ирОбщий.ИзвлечьКлючИзЭлементаРасшифровкиКомпоновкиЛкс(ЭлементРасшифровки,, ЗначенияВсехПолей); 
	КонецЕсли; 
	Для Каждого КлючИЗначение Из ЗначенияВсехПолей Цикл
		Если ЗначенияПолей.Найти(КлючИЗначение.Ключ) <> Неопределено Тогда
			Продолжить;
		КонецЕсли;
		ЗначениеПоля = Новый Структура("Поле, Значение", КлючИЗначение.Ключ, КлючИЗначение.Значение);
		ДобавитьДействияРасшифровкиПоПолюЛкс(Ложь, СписокДействийГруппировки, ЗначениеПоля, СписокДействийОтборать, СписокДействийОформить,, СписокДействийУпорядочить, ЭлементРасшифровки);
	КонецЦикла;
	Если СписокДействийГруппировки.Количество() > 0 Тогда
		ДополнительныеПунктыМеню.Добавить(СписокДействийГруппировки, "Группировки");
	КонецЕсли; 
	Если ЗамещатьСтандартные Тогда
		ИндексМассива = ДоступныеДействия.Найти(ДействиеОбработкиРасшифровкиКомпоновкиДанных.Оформить);
		Если ИндексМассива <> Неопределено Тогда
			ДоступныеДействия.Удалить(ИндексМассива);
			ДополнительныеПунктыМеню.Добавить(СписокДействийОформить, "Оформить",, ирКэш.КартинкаПоИмениЛкс("УсловноеОформлениеКомпоновкиДанных"));
		КонецЕсли;
		ИндексМассива = ДоступныеДействия.Найти(ДействиеОбработкиРасшифровкиКомпоновкиДанных.Отфильтровать);
		Если ИндексМассива <> Неопределено Тогда
			ДоступныеДействия.Удалить(ИндексМассива);
			ДополнительныеПунктыМеню.Добавить(СписокДействийОтборать, "Отфильтровать",, ирКэш.КартинкаПоИмениЛкс("ОтборКомпоновкиДанных"));
		КонецЕсли;
		//ДополнительныеПунктыМеню.Добавить(СписокДействийСгруппировать, "Сгруппировать"); // Не доделано
		ИндексМассива = ДоступныеДействия.Найти(ДействиеОбработкиРасшифровкиКомпоновкиДанных.Упорядочить);
		Если ИндексМассива <> Неопределено Тогда
			ДоступныеДействия.Удалить(ИндексМассива);
			ДополнительныеПунктыМеню.Добавить(СписокДействийУпорядочить, "Упорядочить",, ирКэш.КартинкаПоИмениЛкс("ПорядокКомпоновкиДанных"));
		КонецЕсли;
	КонецЕсли;
	Возврат ДополнительныеПунктыМеню;

КонецФункции

Процедура ДобавитьДействияРасшифровкиПоПолюЛкс(ЛиПрямоеПоле = Истина, Знач СписокДействийОткрыть, Знач ЗначениеПоля, Знач СписокДействийОтборать, Знач СписокДействийОформить,
	Знач СписокДействийСгруппировать = Неопределено, Знач СписокДействийУпорядочить = Неопределено, Знач ЭлементРасшифровки, выхКоличествоСсылочныхПолей = 0)
	
	ПорогДлиныПредставления = 100;
	ПредставлениеЗначения = ирОбщий.ПредставлениеЗначенияСОграничениемДлиныЛкс(ирОбщий.РасширенноеПредставлениеЗначенияЛкс(ЗначениеПоля.Значение,,,,, Истина), ПорогДлиныПредставления);
	Если Ложь
		Или ирОбщий.ЛиКоллекцияЛкс(ЗначениеПоля.Значение) 
		Или ирОбщий.ЛиСсылкаНаОбъектБДЛкс(ЗначениеПоля.Значение)
	Тогда
		СписокДействийОткрыть.Добавить(Новый Структура("Действие, ЗначениеПоля", "ОткрытьЗначение", ЗначениеПоля), "Открыть """ + ЗначениеПоля.Поле + " = " + ПредставлениеЗначения + """",
		, КартинкаТипаЛкс(ТипЗнч(ЗначениеПоля.Значение)));
	Иначе
		СписокДействийОткрыть.Добавить(Новый Структура("Действие, ЗначениеПоля", "КопироватьВБуферОбмена", ЗначениеПоля), ЗначениеПоля.Поле + " = " + ПредставлениеЗначения,
		, ирКэш.КартинкаПоИмениЛкс("ирКопировать"));
	КонецЕсли;
	Если ирОбщий.ЛиСсылкаНаОбъектБДЛкс(ЗначениеПоля.Значение) Тогда
		СписокДействийОткрыть.Добавить(Новый Структура("Действие, ЗначениеПоля", "ОткрытьВРедактореОбъектаБД", ЗначениеПоля), "Открыть """ + ЗначениеПоля.Поле + " = " + ПредставлениеЗначения + """",
			, ирКэш.КартинкаПоИмениЛкс("ирРедактироватьОбъектБД"));
		выхКоличествоСсылочныхПолей = выхКоличествоСсылочныхПолей + 1;
	КонецЕсли; 
	Если ЛиПрямоеПоле Тогда
		СписокДействийСгруппировать.Добавить(Новый Структура("Действие, ЗначениеПоля, Родители", "Сгруппировать", ЗначениеПоля, ЭлементРасшифровки.ПолучитьРодителей()), "Сгруппировать """ + ЗначениеПоля.Поле + """");
		СписокДействийОформить.Добавить(Новый Структура("Действие, ЗначениеПоля", "ОформитьПоле", ЗначениеПоля), "Оформить """ + ЗначениеПоля.Поле + """");
	КонецЕсли; 
	Если ЗначениеПоля.Значение <> Null Тогда
		СписокДействийОформить.Добавить(Новый Структура("Действие, ЗначениеПоля", "ОформитьЗначение", ЗначениеПоля), "Оформить """ + ЗначениеПоля.Поле + " = " + ПредставлениеЗначения + """");
		СписокДействийОтборать.Добавить(Новый Структура("Действие, ЗначениеПоля", "Отфильтровать", ЗначениеПоля), "Отобрать """ + ЗначениеПоля.Поле + " = " + ПредставлениеЗначения + """");
	КонецЕсли; 
	СписокДействийУпорядочить.Добавить(Новый Структура("Действие, ЗначениеПоля", "Упорядочить", ЗначениеПоля), "Упорядочить """ + ЗначениеПоля.Поле + """");

КонецПроцедуры

Функция ОбработатьДополнительноеДействиеРасшифровкиКомпоновкиЛкс(Знач ВыбранноеДействие, СтандартнаяОбработка, НастройкаКомпоновки = Неопределено) Экспорт 
	
	Если ТипЗнч(ВыбранноеДействие) = Тип("Структура") Тогда
		ЗначениеПоля = ВыбранноеДействие.ЗначениеПоля;
		#Если Сервер И Не Сервер Тогда
			ДанныеРасшифровки = Новый ДанныеРасшифровкиКомпоновкиДанных;
			ЗначениеПоля = ДанныеРасшифровки.Элементы[0].ПолучитьПоля()[0];
			НастройкаКомпоновки = Новый НастройкиКомпоновкиДанных;
		#КонецЕсли
		Если ВыбранноеДействие.Действие = "ОткрытьЗначение" Тогда
			ОткрытьЗначениеЛкс(ЗначениеПоля.Значение, Ложь, СтандартнаяОбработка);
		ИначеЕсли ВыбранноеДействие.Действие = "ОткрытьВРедактореОбъектаБД" Тогда
			СтандартнаяОбработка = Ложь;
			ОткрытьСсылкуВРедактореОбъектаБДЛкс(ЗначениеПоля.Значение);
		ИначеЕсли ВыбранноеДействие.Действие = "КопироватьВБуферОбмена" Тогда
			СтандартнаяОбработка = Ложь;
			ТекстВБуферОбменаОСЛкс(ЗначениеПоля.Значение, "");
		ИначеЕсли Ложь
			Или ВыбранноеДействие.Действие = "ОформитьПоле"
			Или ВыбранноеДействие.Действие = "ОформитьЗначение"
		Тогда           
			СтандартнаяОбработка = Ложь;
			Если ВыбранноеДействие.Действие = "ОформитьПоле" Тогда
				ЭлементНастроек = ирОбщий.НайтиЭлементУсловногоОформленияПоПолюЛкс(НастройкаКомпоновки.УсловноеОформление, ЗначениеПоля.Поле);
			КонецЕсли;
			Если ЭлементНастроек = Неопределено Тогда
				ЭлементНастроек = НастройкаКомпоновки.УсловноеОформление.Элементы.Добавить();
				ОформляемоеПоле = ЭлементНастроек.Поля.Элементы.Добавить();
				ОформляемоеПоле.Поле = Новый ПолеКомпоновкиДанных(ЗначениеПоля.Поле);
				ОформляемоеПоле.Использование = Истина;
				Если ВыбранноеДействие.Действие = "ОформитьЗначение" Тогда 
					ирОбщий.НайтиДобавитьЭлементОтбораКомпоновкиЛкс(ЭлементНастроек.Отбор, ЗначениеПоля.Поле, ЗначениеПоля.Значение);
				КонецЕсли;
			КонецЕсли;
		ИначеЕсли ВыбранноеДействие.Действие = "Отфильтровать" Тогда           
			СтандартнаяОбработка = Ложь;
			ЭлементНастроек = ирОбщий.НайтиДобавитьЭлементОтбораКомпоновкиЛкс(НастройкаКомпоновки.Отбор, ЗначениеПоля.Поле, ЗначениеПоля.Значение);
		ИначеЕсли ВыбранноеДействие.Действие = "Сгруппировать" Тогда           
			//Родители = ВыбранноеДействие.Родители;
			//#Если Сервер И Не Сервер Тогда
			//	Родители = ДанныеРасшифровки.Элементы[0].ПолучитьРодителей();
			//#КонецЕсли  
			//Если Родители.Количество() > 0 Тогда 
			//	ГруппировкаРодитель = Родители[0];
			//КонецЕсли;
			//СтандартнаяОбработка = Ложь;
			//// TODO придумать. Сейчас ошибка
			//ЭлементСтруктурыРодитель = ирОбщий.НайтиДобавитьЭлементСтруктурыГруппировкаКомпоновкиЛкс(НастройкаКомпоновки.Структура, ГруппировкаРодитель.Группировка, Ложь);
			//Если ЭлементСтруктурыРодитель = Неопределено Тогда
			//	ЭлементСтруктурыРодитель = НастройкаКомпоновки.Структура;
			//КонецЕсли;
			//ЭлементНастроек = ирОбщий.НайтиДобавитьЭлементНастроекКомпоновкиПоПредставлениюЛкс(ЭлементСтруктурыРодитель.ПоляГруппировки, ЗначениеПоля.Поле);
		ИначеЕсли ВыбранноеДействие.Действие = "Упорядочить" Тогда           
			СтандартнаяОбработка = Ложь;
			ЭлементНастроек = ирОбщий.НайтиДобавитьЭлементНастроекКомпоновкиПоПолюЛкс(НастройкаКомпоновки.Порядок, ЗначениеПоля.Поле, ЗначениеПоля.Значение);
		КонецЕсли;
	КонецЕсли;  
	Возврат ЭлементНастроек;

КонецФункции

// Параметры:
//   ОтчетОбъект - Форма, ОтчетОбъект
Процедура ОтчетКомпоновкиОбработкаРасшифровкиЛкс(Знач ОтчетОбъект, Знач Расшифровка, СтандартнаяОбработка, ДополнительныеПараметры, ПолеТабличногоДокумента, ДанныеРасшифровки,
	Авторасшифровка = Ложь) Экспорт 
	
	#Если _ Тогда
		ДанныеРасшифровки = Новый ДанныеРасшифровкиКомпоновкиДанных;
		ЭлементРасшифровки = ДанныеРасшифровки.Элементы[0];
		ТабличныйДокумент = Новый ТабличныйДокумент;
		ОтчетОбъект = Отчеты.ирАнализПравДоступа.Создать();
	#КонецЕсли
	Если ТипЗнч(Расшифровка) <> Тип("ИдентификаторРасшифровкиКомпоновкиДанных") Тогда
		//Возврат;
	КонецЕсли; 
	ЭлементРасшифровки = ДанныеРасшифровки.Элементы[Расшифровка];
	ДоступныеДействия = Новый Массив;
	РазрешитьАвтовыборДействия = Истина;
	ПараметрВыбранногоДействия = Неопределено;
	КоличествоСсылочныхПолей = 0;
	ЗначенияВсехПолей = Новый Соответствие;
	ирОбщий.ИзвлечьКлючИзЭлементаРасшифровкиКомпоновкиЛкс(ЭлементРасшифровки,, ЗначенияВсехПолей);
	Для Каждого ЭлементОтбора Из ДанныеРасшифровки.Настройки.Отбор.Элементы Цикл
		Если Ложь
			Или Не ЭлементОтбора.Использование 
			Или ТипЗнч(ЭлементОтбора) = Тип("ГруппаЭлементовОтбораКомпоновкиДанных") 
			Или ЭлементОтбора.ВидСравнения <> ВидСравненияКомпоновкиДанных.Равно
			Или ТипЗнч(ЭлементОтбора.ПравоеЗначение) = Тип("ПолеКомпоновкиДанных")
		Тогда
			Продолжить;
		КонецЕсли; 
		ЗначенияВсехПолей["" + ЭлементОтбора.ЛевоеЗначение] = ЭлементОтбора.ПравоеЗначение;
	КонецЦикла;
	СписокДополнительныхДействий = Новый СписокЗначений;
	Если ирОбщий.МетодРеализованЛкс(ОтчетОбъект, "ОбработкаРасшифровки") Тогда
		ОтчетОбъект.ОбработкаРасшифровки(ДанныеРасшифровки, ЭлементРасшифровки, ПолеТабличногоДокумента, ДоступныеДействия, СписокДополнительныхДействий, РазрешитьАвтовыборДействия, ЗначенияВсехПолей);
	КонецЕсли; 
	ДополнительныеДействияРасшифровкиКомпоновкиЛкс(ДоступныеДействия, ЭлементРасшифровки, СписокДополнительныхДействий, КоличествоСсылочныхПолей,, ЗначенияВсехПолей);
	КоличествоОбщихДействий = СписокДополнительныхДействий.Количество();
	Если Истина
		И РазрешитьАвтовыборДействия
		И Авторасшифровка 
		И (ЛОжь
			ИЛи СписокДополнительныхДействий.Количество() - КоличествоОбщихДействий = 1 
			Или СписокДополнительныхДействий.Количество() - КоличествоОбщихДействий = 0 И КоличествоСсылочныхПолей = 1)
	Тогда
		ВыбранноеДействие = СписокДополнительныхДействий[0].Значение;
	КонецЕсли;
	Если ВыбранноеДействие = Неопределено Тогда
		ИсточникДоступныхНастроек = Новый ИсточникДоступныхНастроекКомпоновкиДанных(ОтчетОбъект.СхемаКомпоновкиДанных);
		ОбработкаРасшифровки = Новый ОбработкаРасшифровкиКомпоновкиДанных(ДанныеРасшифровки, ИсточникДоступныхНастроек);
		ОбработкаРасшифровки.ВыбратьДействие(Расшифровка, ВыбранноеДействие, ПараметрВыбранногоДействия, ДоступныеДействия, СписокДополнительныхДействий, Авторасшифровка);
	КонецЕсли;
	Если ВыбранноеДействие = ДействиеОбработкиРасшифровкиКомпоновкиДанных.Нет Тогда
		СтандартнаяОбработка = Ложь;
		//Возврат;
	КонецЕсли;
	Если ПараметрВыбранногоДействия = Неопределено Тогда
		ПараметрВыбранногоДействия = ЗначенияВсехПолей;
	КонецЕсли;
	ЭлементНастроек = ОбработатьДополнительноеДействиеРасшифровкиКомпоновкиЛкс(ВыбранноеДействие, СтандартнаяОбработка, ОтчетОбъект.КомпоновщикНастроек.Настройки);
	Если ирОбщий.МетодРеализованЛкс(ОтчетОбъект, "ДействиеРасшифровки") Тогда
		ОтчетОбъект.ДействиеРасшифровки(ВыбранноеДействие, ПараметрВыбранногоДействия, СтандартнаяОбработка);
	КонецЕсли; 
	Если СтандартнаяОбработка Тогда
		Если ВыбранноеДействие = ДействиеОбработкиРасшифровкиКомпоновкиДанных.ОткрытьЗначение Тогда
			ОткрытьЗначениеЛкс(ПараметрВыбранногоДействия);
		ИначеЕсли ТипЗнч(ВыбранноеДействие) = Тип("ДействиеОбработкиРасшифровкиКомпоновкиДанных") Тогда
			ИсточникДоступныхНастроек = Новый ИсточникДоступныхНастроекКомпоновкиДанных(ОтчетОбъект.СхемаКомпоновкиДанных);
			ОбработкаРасшифровки = Новый ОбработкаРасшифровкиКомпоновкиДанных(ДанныеРасшифровки, ИсточникДоступныхНастроек);
			НовыеНастройки = ОбработкаРасшифровки.ПрименитьНастройки(Расшифровка, ПараметрВыбранногоДействия);
			ОтчетОбъект.КомпоновщикНастроек.ЗагрузитьНастройки(НовыеНастройки);
			ОтчетОбъект.СкомпоноватьРезультат(ПолеТабличногоДокумента, ДанныеРасшифровки);
		КонецЕсли;
	КонецЕсли;
	СтандартнаяОбработка = Ложь;

КонецПроцедуры

Функция ВыбратьТипСсылкиВПолеВводаЛкс(Элемент, СтандартнаяОбработка, ОткрытьФормуВыбораСсылкиПослеВыбораТипа = Ложь) Экспорт

	Форма = ирКэш.Получить().ПолучитьФорму("ВыборОбъектаМетаданных", Элемент, Элемент);
	ТекущееЗначение = ирОбщий.ДанныеЭлементаФормыЛкс(Элемент);
	Если ирОбщий.ЛиСсылкаНаОбъектБДЛкс(ТекущееЗначение, Ложь) Тогда
		НачальноеЗначениеВыбора = ирОбщий.ПолучитьПолноеИмяМДТипаЛкс(ТипЗнч(ТекущееЗначение));
	КонецЕсли;
	лСтруктураПараметров = Новый Структура;
	лСтруктураПараметров.Вставить("ОтображатьСсылочныеОбъекты", Истина);
	лСтруктураПараметров.Вставить("ОтображатьВнешниеИсточникиДанных", Истина);
	лСтруктураПараметров.Вставить("ОтображатьПеречисления", Истина);
	лСтруктураПараметров.Вставить("НачальноеЗначениеВыбора", НачальноеЗначениеВыбора);
	Форма.НачальноеЗначениеВыбора = лСтруктураПараметров;
	ЗначениеВыбора = Форма.ОткрытьМодально();
	Если ТипЗнч(ЗначениеВыбора) = Тип("Структура") Тогда
		лПолноеИмяОбъекта = Неопределено;
		Если ЗначениеВыбора.Свойство("ПолноеИмяОбъекта", лПолноеИмяОбъекта) Тогда
			ИмяТипаСсылки = ирОбщий.ИмяТипаИзПолногоИмениМДЛкс(лПолноеИмяОбъекта, "Ссылка");
			ОписаниеТипов = Новый ОписаниеТипов(ИмяТипаСсылки);
			НовоеЗначение = ОписаниеТипов.ПривестиЗначение(Неопределено);
			ИнтерактивноЗаписатьВПолеВводаЛкс(Элемент, НовоеЗначение);
			// // http://www.hostedredmine.com/issues/884276
			//Если ОткрытьФормуВыбораСсылкиПослеВыбораТипа Тогда
			//	//Если ирОбщий.ЛиСсылкаНаОбъектБДЛкс(НовоеЗначение, Ложь) Тогда
			//		ОткрытьФормуСпискаЛкс(лПолноеИмяОбъекта,,, Элемент, Истина);
			//	//КонецЕсли; 
			//КонецЕсли; 
		КонецЕсли;
	КонецЕсли;
	СтандартнаяОбработка = Ложь;
	Возврат НовоеЗначение;

КонецФункции

// Результат - значение выбранного типа, но не обязательно выбранное (выбор типа выполняется синхронно, а значения - асинхронно)
//
// Параметры:
//  Элемент						 - 	 - 
//  СтандартнаяОбработка		 - 	 - 
//  ИгнорироватьОписаниеТипов	 - 	 - 
//  Отбор						 - Структура - 
// 
// Возвращаемое значение:
//   - 
//
Функция ПолеВводаСсылки_НачалоВыбораЛкс(Элемент, СтандартнаяОбработка, ИгнорироватьОписаниеТипов = Ложь, Знач Отбор = Неопределено) Экспорт

	РезультатВыбора = ирОбщий.ДанныеЭлементаФормыЛкс(Элемент);
	Если Истина
		И ИгнорироватьОписаниеТипов
		И (Ложь
			Или ТипЗнч(РезультатВыбора) = Тип("Строка")
			Или РезультатВыбора = Неопределено)
	Тогда
		Типы = Элемент.ОграничениеТипа.Типы();
		Если Типы.Количество() = 1 Тогда
			// Ссылка внешнего источника данных
			СтандартнаяОбработка = Ложь;
			ОткрытьФормуСпискаЛкс(ирОбщий.ПолучитьПолноеИмяМДТипаЛкс(Типы[0]),,, Элемент, Истина,, РезультатВыбора);
		Иначе
			РезультатВыбора = ВыбратьТипСсылкиВПолеВводаЛкс(Элемент, СтандартнаяОбработка);
		КонецЕсли; 
	ИначеЕсли ирОбщий.ЛиСсылкаНаОбъектБДЛкс(РезультатВыбора, Ложь) Тогда
		СтандартнаяОбработка = Ложь;
		Если Отбор = Неопределено Тогда
			Отбор = Новый Структура;
		КонецЕсли;
		Если ТипЗнч(Элемент) = Тип("ПолеВвода") И Справочники.ТипВсеСсылки().СодержитТип(ТипЗнч(РезультатВыбора)) Тогда
			Если ЗначениеЗаполнено(Элемент.ВыборПоВладельцу) Тогда
				Отбор.Вставить("Владелец", Элемент.ВыборПоВладельцу);
			КонецЕсли; 
		КонецЕсли;
		ОткрытьФормуСпискаЛкс(ирОбщий.ПолучитьПолноеИмяМДТипаЛкс(ТипЗнч(РезультатВыбора)), Отбор,, Элемент, Истина,, РезультатВыбора);
	Иначе
		// Тут надо делать выбор из диалога плоского списка типов
	КонецЕсли; 
	Возврат РезультатВыбора;

КонецФункции

Процедура ПолеВводаРегулированиеЛкс(Знач Элемент, Знач Направление, СтандартнаяОбработка) Экспорт 
	
	ОболочкаПоляТекста = ОболочкаПоляТекстаЛкс(Элемент);
	#Если Сервер И Не Сервер Тогда
		ОболочкаПоляТекста = Обработки.ирОболочкаПолеТекста.Создать();
	#КонецЕсли
	СтруктураВыделения = ОболочкаПоляТекста.ДвухмерноеВыделение();
	Если ТипЗнч(Элемент.Значение) = Тип("Дата") Тогда
		// Антибаг платформы 8.3.0-20 Каретка меняет положение https://www.hostedredmine.com/issues/936754
		// Повторяем штатное поведение
		СтандартнаяОбработка = Ложь;
		Позиция = СтруктураВыделения.НачальнаяКолонка;
		МножительСекунд = 0;
		МножительМесяцев = 0;
		Если Позиция > 17 Тогда
			МножительСекунд = 1;
		ИначеЕсли Позиция > 14 Тогда
			МножительСекунд = 60;
		ИначеЕсли Позиция > 11 Тогда
			МножительСекунд = 60*60;
		ИначеЕсли Позиция > 6 Тогда
			МножительМесяцев = 12;
		ИначеЕсли Позиция > 3 Тогда
			МножительМесяцев = 1;
		Иначе
			МножительСекунд = 24*60*60;
		КонецЕсли; 
		НовоеЗначение = Элемент.Значение;
		НовоеЗначение = НовоеЗначение + МножительСекунд * Направление;
		НовоеЗначение = ДобавитьМесяц(НовоеЗначение, МножительМесяцев * Направление);
		//Элемент.Значение = НовоеЗначение; // Так каретка меняет положение
		ОболочкаПоляТекста.УстановитьГраницыВыделения(1, 1);
		ОболочкаПоляТекста.ВыделенныйТекст(НовоеЗначение);
		УстановитьФокусВводаФормеЛкс();
		ОболочкаПоляТекста.УстановитьДвухмерноеВыделение(СтруктураВыделения);
	КонецЕсли;

КонецПроцедуры

Функция ИндексКартинкиТипаЗначенияБДЛкс(Знач ОписаниеТипов) Экспорт

	Если ОписаниеТипов = Неопределено Тогда
		Возврат 14;
	КонецЕсли; 
	#Если Сервер И Не Сервер Тогда
		ОписаниеТипов = Новый ОписаниеТипов;
	#КонецЕсли
	Если ОписаниеТипов.СодержитТип(Тип("Null")) Тогда
		ОписаниеТипов = Новый ОписаниеТипов(ОписаниеТипов,, "Null");
	КонецЕсли; 
	Типы = ОписаниеТипов.Типы();
	Если Типы.Количество() = 1 Тогда
		КорневойТип = ирОбщий.КорневойТипКонфигурацииЛкс(Типы[0]);
		Если Типы[0] = Тип("Число") Тогда 
			ИндексКартинки = 0;
		ИначеЕсли Типы[0] = Тип("Строка") Тогда 
			ИндексКартинки = 1;
		ИначеЕсли Типы[0] = Тип("Дата") Тогда 
			ИндексКартинки = 2;
		ИначеЕсли Типы[0] = Тип("Булево") Тогда 
			ИндексКартинки = 3;
		ИначеЕсли Типы[0] = Тип("ТаблицаЗначений") Тогда 
			ИндексКартинки = 19;
		ИначеЕсли Типы[0] = Тип("Тип") Тогда 
			ИндексКартинки = 20;
		ИначеЕсли Типы[0] = Тип("УникальныйИдентификатор") Тогда 
			ИндексКартинки = 21;
		ИначеЕсли Типы[0] = Тип("ХранилищеЗначения") Тогда 
			ИндексКартинки = 22;
		ИначеЕсли КорневойТип = "Справочник" Тогда 
			ИндексКартинки = 7;
		ИначеЕсли КорневойТип = "Документ" Тогда 
			ИндексКартинки = 8;
		ИначеЕсли КорневойТип = "Перечисление" Тогда 
			ИндексКартинки = 9;
		ИначеЕсли КорневойТип = "ПланВидовХарактеристик" Тогда 
			ИндексКартинки = 10;
		ИначеЕсли КорневойТип = "ПланСчетов" Тогда 
			ИндексКартинки = 11;
		ИначеЕсли КорневойТип = "ПланВидовРасчета" Тогда 
			ИндексКартинки = 12;
		ИначеЕсли КорневойТип = "БизнесПроцесс" Тогда 
			ИндексКартинки = 13;
		ИначеЕсли КорневойТип = "ТочкаМаршрута" Тогда 
			ИндексКартинки = 14;
		ИначеЕсли КорневойТип = "Задача" Тогда 
			ИндексКартинки = 13;
		ИначеЕсли КорневойТип = "ПланОбмена" Тогда 
			ИндексКартинки = 15;
		Иначе
			ИндексКартинки = 16;
		КонецЕсли;
	Иначе
		ИндексКартинки = 16;
	КонецЕсли;

	Возврат ИндексКартинки;

КонецФункции

Функция ИндексКартинкиТипаТаблицыБДЛкс(Знач ТипТаблицы) Экспорт
	
	ТипТаблицы = ирОбщий.ПеревестиВРусский(ТипТаблицы);
	ИндексКартинки = 14;
	Если ТипТаблицы = "Константы" Тогда
		ИндексКартинки = 2;
	ИначеЕсли ТипТаблицы = "Константа" Тогда
		ИндексКартинки = 2;
	//ИначеЕсли ТипТаблицы = "ТабличнаяЧасть" Тогда
	ИначеЕсли ирОбщий.ЛиТипВложеннойТаблицыБДЛкс(ТипТаблицы) Тогда
		ИндексКартинки = 20;
	ИначеЕсли ТипТаблицы = "Изменения" Тогда
		ИндексКартинки = 27;
	ИначеЕсли ТипТаблицы = "ВиртуальнаяТаблица" Тогда
		ИндексКартинки = 28;
	ИначеЕсли ТипТаблицы = "ВнешнийИсточникДанных" Тогда
		ИндексКартинки = 29;
	ИначеЕсли ТипТаблицы = "Справочник" Тогда
		ИндексКартинки = 3;
	ИначеЕсли ТипТаблицы = "Перечисление" Тогда
		ИндексКартинки = 4;
	ИначеЕсли ТипТаблицы = "Документ" Тогда
		ИндексКартинки = 5;
	ИначеЕсли ТипТаблицы = "ЖурналДокументов" Тогда
		ИндексКартинки = 6;
	ИначеЕсли ТипТаблицы = "Последовательность" Тогда
		ИндексКартинки = 7;
	ИначеЕсли ТипТаблицы = "РегистрНакопления" Тогда
		ИндексКартинки = 8;
	ИначеЕсли ТипТаблицы = "РегистрСведений" Тогда
		ИндексКартинки = 9;
	ИначеЕсли ТипТаблицы = "РегистрБухгалтерии" Тогда
		ИндексКартинки = 10;
	ИначеЕсли ТипТаблицы = "РегистрРасчета" Тогда
		ИндексКартинки = 11;
	ИначеЕсли ТипТаблицы = "ПланОбмена" Тогда
		ИндексКартинки = 19;
	ИначеЕсли ТипТаблицы = "Задача" Тогда
		ИндексКартинки = 17;
	ИначеЕсли ТипТаблицы = "БизнесПроцесс" Тогда
		ИндексКартинки = 18;
	ИначеЕсли ТипТаблицы = "РегистрРасчета" Тогда
		ИндексКартинки = 26;
	ИначеЕсли ТипТаблицы = "ПланВидовРасчета" Тогда
		ИндексКартинки = 25;
	ИначеЕсли ТипТаблицы = "ПланВидовХарактеристик" Тогда
		ИндексКартинки = 22;
	ИначеЕсли ТипТаблицы = "Перечисление" Тогда
		ИндексКартинки = 23;
	ИначеЕсли ТипТаблицы = "ПланСчетов" Тогда
		ИндексКартинки = 24;
	ИначеЕсли ТипТаблицы = "Перерасчет" Тогда
		ИндексКартинки = 30;
	ИначеЕсли ТипТаблицы = "КритерийОтбора" Тогда
		ИндексКартинки = 31;
	ИначеЕсли ирОбщий.СтрокиРавныЛкс(ТипТаблицы, "Table") Тогда
		ИндексКартинки = 3;
	КонецЕсли;
	Возврат ИндексКартинки;
	
КонецФункции

Функция ИндексКартинкиСловаПодсказкиЛкс(Знач ДанныеСтроки) Экспорт

	Попытка
		ТипЗначения = ДанныеСтроки.ТипЗначения;
	Исключение
		ТипЗначения = Неопределено;
	КонецПопытки; 
	ИндексКартинки = -1;
	Если ДанныеСтроки.ТипСлова = "Конструкция" Тогда
		ИндексКартинки = 13;
	ИначеЕсли ТипЗначения = "Имя типа" Тогда
		ИндексКартинки = 12;
	ИначеЕсли ДанныеСтроки.ТипСлова = "Метод" Тогда
		Попытка
			Пустышка = ДанныеСтроки.Успех;
			ЕстьУспех = Истина;
		Исключение
			ЕстьУспех = Ложь;
		КонецПопытки;
		Если Ложь
			Или (Истина
				И ЕстьУспех
				И (Ложь
					Или ДанныеСтроки.ТаблицаСтруктурТипов = Неопределено
					Или ДанныеСтроки.ТаблицаСтруктурТипов.Количество() = 0
					Или ДанныеСтроки.ТаблицаСтруктурТипов[0].ИмяОбщегоТипа = ""))
			Или (Истина
				И Не ЕстьУспех
				И ДанныеСтроки.ТипЗначения = "")
		Тогда
			Если ДанныеСтроки.Определение = "Предопределенный" Тогда
				ИндексКартинки = 0;
			ИначеЕсли ДанныеСтроки.Определение = "Метаданные" Тогда
				ИндексКартинки = 6;
			//ИначеЕсли ДанныеСтроки.Определение = "Локальный" Тогда
			//	ИндексКартинки = 9;
			Иначе
				ИндексКартинки = 3;
			КонецЕсли;
		Иначе
			Если ДанныеСтроки.Определение = "Предопределенный" Тогда
				ИндексКартинки = 1;
			ИначеЕсли ДанныеСтроки.Определение = "Метаданные" Тогда
				ИндексКартинки = 7;
			//ИначеЕсли ДанныеСтроки.Определение = "Локальный" Тогда
			//	ИндексКартинки = 10;
			Иначе
				ИндексКартинки = 4;
			КонецЕсли;	
		КонецЕсли;
	ИначеЕсли ДанныеСтроки.ТипСлова = "Свойство" Тогда
		Если ДанныеСтроки.Определение = "Предопределенный" Тогда
			ИндексКартинки = 2;
		ИначеЕсли ДанныеСтроки.Определение = "Метаданные" Тогда
			ИндексКартинки = 8;
		//ИначеЕсли ДанныеСтроки.Определение = "Локальный" Тогда
		//	ИндексКартинки = 11;
		Иначе
			ИндексКартинки = 5;
		КонецЕсли;
	ИначеЕсли ДанныеСтроки.ТипСлова = "Таблица" Тогда
		ИндексКартинки = 14;
	ИначеЕсли ДанныеСтроки.ТипСлова = "Поле" Тогда
		Если ДанныеСтроки.Определение = "Предопределенный" Тогда
			ИндексКартинки = 15;
		Иначе
			ИндексКартинки = 16;
		КонецЕсли;
	ИначеЕсли ДанныеСтроки.ТипСлова = "Группа" Тогда
		ИндексКартинки = 18;
	КонецЕсли;
	Возврат ИндексКартинки;

КонецФункции

// Получает картинку для корневого типа конфигурации.
//
// Параметры:
//  пКорневойТип - Строка - корневой тип конфигурации.
//
// Возвращаемое значение:
//               - Картинка - корневого типа конфигурации.
//
Функция КартинкаКорневогоТипаМДЛкс(Знач КорневойТип) Экспорт

	Если ирОбщий.СтрокиРавныЛкс("Изменения", КорневойТип) Тогда
		Картинка = ирКэш.КартинкаПоИмениЛкс("ирТаблицаИзменений");
	КонецЕсли; 
	Если Картинка = Неопределено Тогда
		Картинка = ирКэш.КартинкаПоИмениЛкс("ир" + КорневойТип);
	КонецЕсли; 
	Если Картинка = Неопределено Или Картинка.Вид = ВидКартинки.Пустая Тогда
		//Попытка
		//  Так почему то медленно работает. Ускорили в 8.3.22
		//	Картинка = БиблиотекаКартинок[пКорневойТип];
		//Исключение
		//КонецПопытки; 
		Картинка = ирКэш.КартинкаПоИмениЛкс(КорневойТип);
	КонецЕсли; 
	Если Картинка = Неопределено Тогда
		Картинка = Новый Картинка();
	КонецЕсли; 
	Возврат Картинка;

КонецФункции

Функция ПроверитьПодпискиЛкс() Экспорт 
	
	Результат = Истина;
	
	// Проверка компиляции общих модулей с обработчиками событий
	СписокМодулейВызоваСервера = Неопределено;
	ИмяКлиента = Неопределено;
	СписокМодулей = ПроблемныеОбщиеМодулиЛкс(СписокМодулейВызоваСервера, ИмяКлиента);
	Если СписокМодулей.Количество() > 0 Тогда
		Если ирКэш.ЛиПортативныйРежимЛкс() Тогда 
			ТипыОбъектовПодписок = "";
		Иначе
			ТипыОбъектовПодписок = " менеджеров";
		КонецЕсли; 
		ирОбщий.СообщитьЛкс("В конфигурации обнаружены недоступные на клиенте (" + ИмяКлиента + " приложение) общие модули с обработчиками подписок на события" + ТипыОбъектовПодписок + ".", СтатусСообщения.Внимание);
		ирОбщий.СообщитьЛкс("Поэтому в работе некоторых инструментов возможны ошибки ""При подписке * на событие * произошла ошибка. Обработчик события не найден.""");
		Если ИмяКлиента = "Обычное" Тогда
			ирОбщий.СообщитьЛкс("Необходимо в конфигураторе установить ""Сервис""/""Параметры""/""Редактирование конфигурации для режимов запуска""=""Управляемое приложение и обычное приложение"".");
		КонецЕсли; 
		Если Не ирКэш.ЛиПортативныйРежимЛкс() Тогда 
			ТекстСообщения = "Рекомендуется установить флажок ""Вызова сервера"" или ""Клиент (" + ИмяКлиента + " приложение)"" и обеспечить компиляцию у этих общих модулей:";
		Иначе
			ТекстСообщения = "Рекомендуется установить флажок ""Клиент (" + ИмяКлиента + " приложение)"" и обеспечить компиляцию у этих общих модулей:";
		КонецЕсли;
		МассивИменМодулей = Новый Массив;
		Для Каждого КлючИЗначение Из СписокМодулей Цикл
			МассивИменМодулей.Добавить(КлючИЗначение.Ключ);
		КонецЦикла;
		ТекстСообщения = ТекстСообщения + " " + ирОбщий.СтрСоединитьЛкс(МассивИменМодулей,  ", ");
		ирОбщий.СообщитьЛкс(ТекстСообщения);
		Результат = Ложь;
	КонецЕсли;
	Если СписокМодулейВызоваСервера.Количество() > 0 Тогда
		ирОбщий.СообщитьЛкс("В конфигурации обнаружены недоступные на клиенте (" + ИмяКлиента + " приложение) общие модули с обработчиками подписок на событие ""ОбработкаПолученияПредставления"".", СтатусСообщения.Внимание);
		ирОбщий.СообщитьЛкс("Это может приводить к сильному замеделению получения представлений таких ссылок. Рекомендуется перенести эти обработчики в модуль, компилируемый на толстых клиентах");
		Для Каждого КлючИЗначение Из СписокМодулей Цикл
			ТекстСообщения = ТекстСообщения + " " + КлючИЗначение.Ключ + ",";
		КонецЦикла;
		ирОбщий.СообщитьЛкс(ТекстСообщения);
		Результат = Ложь;
	КонецЕсли;
	Возврат Результат;

КонецФункции

Функция ПроблемныеОбщиеМодулиЛкс(СписокМодулейВызоваСервера = Неопределено, ИмяКлиента = "") Экспорт 
	
	СписокМодулей = Новый Структура;
	СписокМодулейВызоваСервера = Новый Структура;
	ОбщиеМодули = Метаданные.ОбщиеМодули;
	Если ирКэш.ЛиСеансТолстогоКлиентаУПЛкс() Тогда 
		ИмяКлиента = "Управляемое";
	Иначе
		ИмяКлиента = "Обычное";
	КонецЕсли;
	ИмяСвойства = "Клиент" + ИмяКлиента + "Приложение";
	Для Каждого Подписка Из Метаданные.ПодпискиНаСобытия Цикл
		#Если Сервер И Не Сервер Тогда
			Подписка = Метаданные.ПодпискиНаСобытия.ВерсионированиеОбъектов_ПриЗаписиОбъекта;
		#КонецЕсли
		МетаМодуль = ОбщиеМодули.Найти(ирОбщий.ПервыйФрагментЛкс(Подписка.Обработчик));
		Если МетаМодуль = Неопределено Тогда
			// Некорректная подписка
			Продолжить;
		КонецЕсли; 
		Если Не ирКэш.ЛиПортативныйРежимЛкс() Тогда 
			// Проверяем только подписки менеджеров
			Если Не МетаМодуль[ИмяСвойства] И Не МетаМодуль.ВызовСервера Тогда 
				ТипыИсточников = Подписка.Источник.Типы(); // Долго!
				Если ТипыИсточников.Количество() > 0 И Не ирОбщий.ЛиТипОбъектаБДЛкс(ТипыИсточников[0]) Тогда // Это подписка менеджера
					СписокМодулей.Вставить(МетаМодуль.Имя);
				КонецЕсли; 
			КонецЕсли;
		Иначе
			// Проверяем все подписки в портативном режиме обычном приложении
			Если Не МетаМодуль[ИмяСвойства] Тогда 
				СписокМодулей.Вставить(МетаМодуль.Имя);
			КонецЕсли;
		КонецЕсли;
		Если Подписка.Событие = "ОбработкаПолученияПредставления" И МетаМодуль.ВызовСервера Тогда
			СписокМодулейВызоваСервера.Вставить(МетаМодуль.Имя);
		КонецЕсли;
	КонецЦикла;
	Возврат СписокМодулей;

КонецФункции

Процедура ИнициироватьФормуЛкс(ЭтаФорма, ПолноеИмяФормы, РазрешитьОткрытиеДополнительныхФорм = Истина) Экспорт
	
	// Проверяем режим модальности
	мПлатформа = ирКэш.Получить();
	#Если Сервер И Не Сервер Тогда
	    мПлатформа = Обработки.ирПлатформа.Создать();
	#КонецЕсли
	ОткрыватьФормуПерезапуска = Ложь;
	
	ЛиМодальностьЗапрещена = ирКэш.ЛиМодальностьЗапрещенаЛкс();
	Если Ложь
		Или ирКэш.НомерИзданияПлатформыЛкс() = "82"
		Или мПлатформа.мВопросОтключенияПроверкиМодальностиЗадавался = Истина 
		Или Метаданные.РежимИспользованияМодальности = Метаданные.СвойстваОбъектов.РежимИспользованияМодальности.Использовать
	Тогда
		//
	ИначеЕсли РазрешитьОткрытиеДополнительныхФорм Тогда 
		КоманднаяСтрокаПроцесса = ирКэш.КоманднаяСтрокаТекущегоПроцессаОСЛкс();
		мПлатформа.мВопросОтключенияПроверкиМодальностиЗадавался = Истина;
		Если Ложь
			Или Найти(НРег(КоманднаяСтрокаПроцесса), НРег("/EnableCheckModal")) > 0
			//Или Найти(КоманднаяСтрокаПроцесса, "/EnableCheckExtensionsAndAddInsSyncCalls") > 0
		Тогда
			ТекстСообщения = "При запуске сеанса из конфигуратора с текущим свойством конфигурации ""Режим использования модальности"" включается контроль модальности."
				" Для его отключения рекомендуется запустить сеанс не из конфигуратора, например командой ""Запуск сеанса"".";
			ирОбщий.СообщитьЛкс(ТекстСообщения,,, Истина, Ложь);
			ОткрыватьФормуПерезапуска = Истина;
		КонецЕсли;
	КонецЕсли; 
		
	// Проверяем защиту от опасных действий
	// Здесь это делать мало полезно, т.к. она срабатывает раньше
	Если Истина
		И РазрешитьОткрытиеДополнительныхФорм
		И ирКэш.ЛиПортативныйРежимЛкс()
		И мПлатформа.мПроверкаЗащитыОтОпасныхДействийВыполнялась <> Истина
		//И ирКэш.НомерВерсииПлатформыЛкс() < 803010 // Когда в платформе исправят проблему, тогда и отключим 
	Тогда
		ТекущийПользовательБазы = ПользователиИнформационнойБазы.ТекущийПользователь();
		Попытка
			ЗащитаОтОпасныхДействий = ТекущийПользовательБазы.ЗащитаОтОпасныхДействий;
		Исключение
			ЗащитаОтОпасныхДействий = Неопределено;
		КонецПопытки; 
		Если Истина
			И ЗначениеЗаполнено(ТекущийПользовательБазы.Имя)
			И ЗащитаОтОпасныхДействий <> Неопределено
			И ЗащитаОтОпасныхДействий.ПредупреждатьОбОпасныхДействиях = Истина
		Тогда
			ТекстСообщения = "У текущего пользователя базы включена защита от опасных действий. Для корректной работы инструментов ее рекомендуется отключить перезапуском сеанса через открывшуюся форму.";
			ирОбщий.СообщитьЛкс(ТекстСообщения, СтатусСообщения.Внимание,, Истина, Ложь);
			ОткрыватьФормуПерезапуска = Истина;
		КонецЕсли; 
		мПлатформа.мПроверкаЗащитыОтОпасныхДействийВыполнялась = Истина;
	КонецЕсли; 
	
	Если ОткрыватьФормуПерезапуска Тогда
		// TODO Надо заблокировать открытие формы в модальной группе
		#Если ТолстыйКлиентОбычноеПриложение Тогда
			ОткрытьФормуЛкс("Обработка.ирПортативный.Форма.ЗапускСеансаОбычная");
		#Иначе
			//ОткрытьФормуЛкс("Обработка.ирПортативный.Форма.ЗапускСеансаУправляемая");
		#КонецЕсли 
	КонецЕсли; 
	Если ЛиМодальностьЗапрещена И Найти(ПолноеИмяФормы, "ирПортативный") = 0 Тогда
		ВызватьИсключение "При запуске сеанса из конфигуратора с текущим свойством конфигурации ""Режим использования модальности"" включается контроль модальности. 
		|Рекомендуется изменить это свойство конфигурации либо запустить сеанс другим способом.";
	КонецЕсли; 

	СлужебныеДанные = ирОбщий.СлужебныеДанныеФормыЛкс(ЭтаФорма);
	СлужебныеДанные.Вставить("УникальныйИдентификатор", Новый УникальныйИдентификатор);
	СлужебныеДанные.Вставить("МенеджерСохраненияНастроек");
	СлужебныеДанные.Вставить("ИмяФормы", ПолноеИмяФормы);
	// Мультиметка55835453
	СлужебныеДанные.Вставить("НеготовыеСтраницы", Новый СписокЗначений);
	СлужебныеДанные.Вставить("Задания", Новый Структура);
	СлужебныеДанные.Вставить("ОригинальныйЗаголовок", ЭтаФорма.Заголовок);
	ПодготовитьЭлементыФормыЛкс(ЭтаФорма);
	Форма_ВставитьСкрытуюКоманднуюПанельГлобальныхКомандЛкс(ЭтаФорма);
	ПерехватКлавиатуры = мПлатформа.ПодключитьПерехватКлавиатуры();
	СлужебныеДанные.Вставить("ПерехватКлавиатуры", ПерехватКлавиатуры);
	Если ирКэш.ЛиПортативныйРежимЛкс() Тогда
		Контейнер = Новый Структура();
		ОповеститьФормыПодсистемыЛкс("ирПолучитьБазовуюФорму", Контейнер); // Скорость https://www.hostedredmine.com/issues/891484
		Если Не Контейнер.Свойство("ирПортативный") Тогда
			БазоваяФорма = ирПортативный.ПолучитьФорму();
			БазоваяФорма.Открыть();
		КонецЕсли; 
		#Если Сервер И Не Сервер Тогда
		    мПлатформа = Обработки.ирПлатформа.Создать();
		#КонецЕсли
		СтрокаВызова = "ирПортативный.ИнициализироватьФорму_" + ирОбщий.ИдентификаторИзПредставленияЛкс(ПолноеИмяФормы) + "(ЭтаФорма)";
		Выполнить(СтрокаВызова);
	Иначе
		МетаФорма = ирКэш.ОбъектМДПоПолномуИмениЛкс(ПолноеИмяФормы);
		Если МетаФорма = Неопределено Тогда
			ирОбщий.СообщитьЛкс(ирОбщий.СтрШаблонИменЛкс("Метаформа не найдена по полному имени %1",, ПолноеИмяФормы), СтатусСообщения.Внимание);
		КонецЕсли;
	КонецЕсли; 

	ФлажокОбъектыНаСервере = ЭтаФорма.ЭлементыФормы.Найти("ОбъектыНаСервере");
	Если ФлажокОбъектыНаСервере <> Неопределено Тогда
		#Если Сервер И Не Сервер Тогда
			ирПортативный = Обработки.ирПортативный.Создать();
		#КонецЕсли
		ФлажокОбъектыНаСервере.Доступность = Не ирКэш.ЛиПортативныйРежимЛкс() Или ирПортативный.ЛиСерверныйМодульДоступенЛкс();
		Если ирКэш.ЛиПортативныйРежимЛкс() Тогда
			ФлажокОбъектыНаСервере.Подсказка = "Запись и удаление объектов данных выполнять на сервере. Это снижает скорость, но повышает совместимость с конфигурациями под управляемое приложение.";
		Иначе
			ФлажокОбъектыНаСервере.Подсказка = "При выполнении кода на клиенте работать с объектами данных на сервере. Это снижает скорость, но повышает совместимость с конфигурациями под управляемое приложение. При выполнении кода на сервере этот параметр не используется.";
		КонецЕсли; 
	КонецЕсли; 
	Если мПлатформа.мПроверкаСовместимостиКонфигурацииВыполнялась <> Истина Тогда
		// Однократно выполняем в сеансе проверку совместимости
		
		Если Метаданные.ХранилищеОбщихНастроек <> Неопределено Тогда
			ИмяПроверочнойНастройки = "Тест";
			ирОбщий.СохранитьЗначениеЛкс(ИмяПроверочнойНастройки, 1);
			Если ирОбщий.ВосстановитьЗначениеЛкс(ИмяПроверочнойНастройки) = Неопределено Тогда 
				ирОбщий.СообщитьЛкс("В конфигурации переопределено хранилище общих настроек и оно не восстанавливает сохраненные значения. Корректная работа подсистемы ""Инструменты разработчика"" невозможна", СтатусСообщения.Важное);
			КонецЕсли; 
		КонецЕсли; 
		Если Не ирОбщий.ЛиСовместимыйЯзыкСистемыЛкс() Тогда 
			ирОбщий.СообщитьЛкс("Язык системы сеанса 1С (параметр /L) не является русским или английским. Корректная работа подсистемы ""Инструменты разработчика"" невозможна", СтатусСообщения.Важное);
		КонецЕсли; 

		мПлатформа.мПроверкаСовместимостиКонфигурацииВыполнялась = Истина;
		#Если Сервер И Не Сервер Тогда
			ВыполнитьПроверкуСовместимостиКонфигурацииЛкс();
		#КонецЕсли
		ПодключитьГлобальныйОбработчикОжиданияЛкс("ВыполнитьПроверкуСовместимостиКонфигурацииЛкс", 1, Истина);
		Если Не ирКэш.ЛиФайловаяБазаЛкс() Тогда
			// Запускаем асинхронную подготовку объекта, иначе он при первом выполнении запроса будет подбирать протокол и в случае недоступности TCP будет 6 секунд ждать
			// https://forum.mista.ru/topic.php?id=870813
			ирОбщий.ПроверитьСоединениеADOЭтойБДЛкс(,,,,, Ложь, Истина, мПлатформа.ПроверочноеСоединениеАДО); 
		КонецЕсли; 
	КонецЕсли;
	ирКэш.СостояниеПодготовкиКэшМДСеансаЛкс();

КонецПроцедуры

Функция ЛиПровайдерАДОДляЭтойБазыГотовЛкс() Экспорт 
	мПлатформа = ирКэш.Получить();
	#Если Сервер И Не Сервер Тогда
	    мПлатформа = Обработки.ирПлатформа.Создать();
	#КонецЕсли
	Результат = Истина
		И мПлатформа.ПроверочноеСоединениеАДО <> Неопределено
		И (Ложь
			Или мПлатформа.ПроверочноеСоединениеАДО = "Готов"
			Или мПлатформа.ПроверочноеСоединениеАДО.State = 1);
	Если Результат Тогда
		мПлатформа.ПроверочноеСоединениеАДО = "Готов";
	КонецЕсли; 
	Возврат Результат;
КонецФункции

Процедура ПодготовитьЭлементыФормыЛкс(ЭтаФорма) Экспорт
	
	#Если Сервер И Не Сервер Тогда
		ЭтаФорма = ОткрытьФорму();
	#КонецЕсли
	СлужебныеДанныеФормы = ирОбщий.СлужебныеДанныеФормыЛкс(ЭтаФорма);
	//ОбработчикиПриВыводеСтроки = Новый Соответствие;
	//СлужебныеДанныеФормы.Вставить("ОбработчикиПриВыводеСтроки", ОбработчикиПриВыводеСтроки);
	КнопкиВсехДействийКомандныхПанелей = Новый Соответствие;
	КомандныеПанелиКнопок = Новый Соответствие;
	ЦветРазделителяБольшой = ирОбщий.СмещенныйЦветЛкс(ЭтаФорма.Панель.ЦветФона, -10, -10, -5, ЦветаСтиля.ЦветФонаФормы);
	ЦветРазделителяМалый = ирОбщий.СмещенныйЦветЛкс(ЭтаФорма.Панель.ЦветФона, -20, -20, -10, ЦветаСтиля.ЦветФонаФормы);
	ИмяКнопки = "СтруктураКоманднойПанели";
	ВозможныеИменаРеквизита = Новый Массив;
	ВозможныеИменаРеквизита.Добавить("ОбработкаОбъект");
	ВозможныеИменаРеквизита.Добавить("ОсновнойОбъект");
	ОсновнойРеквизит = Неопределено;
	ЕстьОбщийОбработчикПриПолученииДанных = Неопределено;
	Для Каждого ИмяОсновногоРеквизита Из ВозможныеИменаРеквизита Цикл
		Если ирОбщий.ЕстьСвойствоОбъектаЛкс(ЭтаФорма, ИмяОсновногоРеквизита) Тогда
			ОсновнойРеквизит = ЭтаФорма[ИмяОсновногоРеквизита];
			Прервать;
		КонецЕсли; 
	КонецЦикла;
	Для Каждого ЭлементФормы Из ЭтаФорма.ЭлементыФормы Цикл
		Если ОсновнойРеквизит <> Неопределено Тогда
			Попытка
				Данные = ЭлементФормы.Данные;
				Подсказка = ЭлементФормы.Подсказка; // У ActiveX этого свойства нет
			Исключение
				Данные = "";
			КонецПопытки; 
			Если Не ПустаяСтрока(Данные) И Найти(Данные, ".") = 0 Тогда
				Если Не ЗначениеЗаполнено(ЭлементФормы.Подсказка) Тогда
					РеквизитОбъекта = ОсновнойРеквизит.Метаданные().Реквизиты.Найти(Данные);
					Если РеквизитОбъекта <> Неопределено Тогда
						ЭлементФормы.Подсказка = РеквизитОбъекта.Подсказка;
					КонецЕсли; 
				КонецЕсли; 
			КонецЕсли; 
		КонецЕсли; 
		// Встраиваем кнопки структуры командной панели
		КоманднаяПанель = Неопределено;
		ВстроитьВНачало = Истина;
		Если ТипЗнч(ЭлементФормы) = Тип("КоманднаяПанель") Тогда
			КоманднаяПанель = ЭлементФормы;
			ВсеКнопки = ВсеКнопкиКоманднойПанелиЛкс(КоманднаяПанель);
			Для Каждого Кнопка Из ВсеКнопки Цикл
				КомандныеПанелиКнопок[Кнопка] = КоманднаяПанель;
			КонецЦикла;
			Если Не КоманднаяПанель.Видимость Тогда
				Продолжить;
			КонецЕсли;
			ВстроитьВНачало = КоманднаяПанель.Ширина > 100;
		//ИначеЕсли ТипЗнч(ЭлементФормы) = Тип("ТабличноеПоле") Тогда
		//	КоманднаяПанель = ЭлементФормы.КонтекстноеМеню; 
		Иначе
			Попытка
				// В контекстных меню функция мало востребована, т.к. они имеют обычно более простую структуру и там сразу виден текст всех кнопок
				КоманднаяПанель = ЭлементФормы.КонтекстноеМеню; 
				ВстроитьВНачало = Ложь;
			Исключение
			КонецПопытки; 
		КонецЕсли; 
		Если Истина
			И КоманднаяПанель <> Неопределено 
			И КоманднаяПанель.Кнопки.Найти(ИмяКнопки) = Неопределено
		Тогда
			НужноВстроить = Ложь;
			КоличествоКнопок = 0;
			Для Каждого Кнопка Из КоманднаяПанель.Кнопки Цикл
				Если Кнопка.ТипКнопки <> ТипКнопкиКоманднойПанели.Разделитель Тогда
					КоличествоКнопок = КоличествоКнопок + 1;
					Если КоличествоКнопок > 4 Тогда
						НужноВстроить = Истина;
						Прервать;
					КонецЕсли; 
				КонецЕсли; 
				Если Кнопка.ТипКнопки = ТипКнопкиКоманднойПанели.Подменю Тогда
					НужноВстроить = Истина;
					Прервать;
				КонецЕсли; 
			КонецЦикла;
			Если НужноВстроить Тогда
				Если ВстроитьВНачало Тогда
					КнопкаСтруктураКоманднойПанели = КоманднаяПанель.Кнопки.Вставить(0);
				Иначе
					КнопкаСтруктураКоманднойПанели = КоманднаяПанель.Кнопки.Добавить();
				КонецЕсли; 
				КнопкаСтруктураКоманднойПанели.Имя = ИмяКнопки;
				КнопкаСтруктураКоманднойПанели.ТипКнопки = ТипКнопкиКоманднойПанели.Действие;
				КнопкаСтруктураКоманднойПанели.Картинка = ирКэш.КартинкаПоИмениЛкс("ирКоманднаяПанель");
				КнопкаСтруктураКоманднойПанели.Отображение = ОтображениеКнопкиКоманднойПанели.Авто;
				КнопкаСтруктураКоманднойПанели.Текст = "Структура командной панели";
				КнопкаСтруктураКоманднойПанели.Подсказка = "Открыть структуру командной панели. Позволяет искать кнопки по ключевым словам.";
				Попытка
					КнопкаСтруктураКоманднойПанели.Действие = Новый Действие("СтруктураКоманднойПанелиНажатие");
				Исключение
					// В этой форме нет обработчика
					КоманднаяПанель.Кнопки.Удалить(КнопкаСтруктураКоманднойПанели);
				КонецПопытки; 
				КнопкиВсехДействийКомандныхПанелей.Вставить(КнопкаСтруктураКоманднойПанели, КоманднаяПанель);
			КонецЕсли; 
		КонецЕсли;
		Если ТипЗнч(ЭлементФормы) = Тип("ТабличноеПоле") Тогда
			ТабличноеПолеВключитьСтаруюЦветовуюСхемуЛкс(ЭлементФормы);
		КонецЕсли; 
		Если ТипЗнч(ЭлементФормы) = Тип("Разделитель") Тогда
			ЭлементФормы.ЦветРамки = ЦветаСтиля.ЦветФонаФормы; // Иначе почему то не применяется цвет фона. Само значение тут не играет роли
			Если Ложь
				Или ЭлементФормы.Высота > 20
				Или ЭлементФормы.Ширина > 20
			Тогда
				ЭлементФормы.ЦветФона = ЦветРазделителяБольшой;
			Иначе
				ЭлементФормы.ЦветФона = ЦветРазделителяМалый;
			КонецЕсли;
		КонецЕсли; 
	КонецЦикла;
	СлужебныеДанныеФормы.Вставить("КнопкиВсехДействийКомандныхПанелей", КнопкиВсехДействийКомандныхПанелей);
	СлужебныеДанныеФормы.Вставить("КомандныеПанелиКнопок", КомандныеПанелиКнопок);
	
КонецПроцедуры

Процедура Форма_ВставитьСкрытуюКоманднуюПанельГлобальныхКомандЛкс(ЭтаФорма) Экспорт 
	
	ЭлементыФормы = ЭтаФорма.ЭлементыФормы;
	
	//ИмяКоманднойПанели = "КП_ПолеВвода";
	//КонтекстноеМенюФормы = ЭлементыФормы.Найти(ИмяКоманднойПанели);
	//Если КонтекстноеМенюФормы = Неопределено Тогда
	//	КонтекстноеМенюФормы = ЭлементыФормы.Добавить(Тип("КоманднаяПанель"), ИмяКоманднойПанели);
	//	КонтекстноеМенюФормы.Видимость = Ложь;
	//КонецЕсли;
	////лПлатформа = ирКэш.Получить();
	////МакетФормы = лПлатформа.ПолучитьФорму("УниверсальныеКоманды");
	////КонтекстноеМенюМакета = МакетФормы.ЭлементыФормы.КоманднаяПанель.Кнопки.ПолеВвода;
	////ДобавитьКнопкиКоманднойПанелиКомпонентыЛкс(МакетФормы, КонтекстноеМенюМакета.Кнопки, КонтекстноеМенюФормы);
	//КоманднаяПанельВставитьКнопкиГлобальныхКомандЛкс(КонтекстноеМенюФормы);
	//Для Каждого ЭлементФормы Из ЭлементыФормы Цикл
	//	Если ТипЗнч(ЭлементФормы) = Тип("ПолеВвода") Тогда
	//		Попытка
	//			КонтекстноеМеню = ЭлементФормы.КонтекстноеМеню;
	//		Исключение
	//			// Поле ввода принадлежит не панели, поэтому у него нет свойства
	//			Продолжить;
	//		КонецПопытки;
	//		Если КонтекстноеМеню = Неопределено Тогда
	//			//ЭлементФормы.АвтоКонтекстноеМеню = Ложь;
	//			ЭлементФормы.КонтекстноеМеню = КонтекстноеМенюФормы;
	//		КонецЕсли; 
	//	КонецЕсли; 
	//КонецЦикла;
	
	ДействияФормы = ЭлементыФормы.Найти("ДействияФормы");
	Если ТипЗнч(ДействияФормы) <> Тип("КоманднаяПанель") Тогда
		ПанельФормы = ЭтаФорма.Панель;
		Если ПанельФормы.КонтекстноеМеню = Неопределено Тогда
			ДействияФормы = ЭлементыФормы.Добавить(Тип("КоманднаяПанель"), "ДействияФормыАвто", Ложь);
			ДействияФормы.ИсточникДействий = ЭтаФорма;
			ПанельФормы.КонтекстноеМеню = ДействияФормы;
		Иначе
			ДействияФормы = ПанельФормы.КонтекстноеМеню;
		КонецЕсли;
		КоманднаяПанельВставитьКнопкиГлобальныхКомандЛкс(ДействияФормы);
	КонецЕсли;
	
КонецПроцедуры

Функция ВсеКнопкиКоманднойПанелиЛкс(КоманднаяПанель, РезультатРекурсия = Неопределено)  Экспорт 
	
	#Если Сервер И Не Сервер Тогда
		КоманднаяПанель = Новый КоманднаяПанель;
	#КонецЕсли
	Если РезультатРекурсия = Неопределено Тогда
		РезультатРекурсия = Новый Массив;
	КонецЕсли;
	ФормаКоманд = ирКэш.ФормаОбщихКомандЛкс();
	ОбщиеКоманды = ФормаКоманд.ЭлементыФормы.Команды.Кнопки;
	Для Каждого Кнопка Из КоманднаяПанель.Кнопки Цикл
		Если Кнопка.ТипКнопки = ТипКнопкиКоманднойПанели.Подменю Тогда
			Если Кнопка.Кнопки.Количество() = 0 Тогда
				// Динамическое подменю
				РезультатРекурсия.Добавить(Кнопка);
			КонецЕсли; 
			ВсеКнопкиКоманднойПанелиЛкс(Кнопка, РезультатРекурсия);
		ИначеЕсли Кнопка.ТипКнопки = ТипКнопкиКоманднойПанели.Действие Тогда
			Действие = "" + Кнопка.Действие;
			Если Найти(Действие, "КлсКомандаНажатие") = 1 Тогда
				РезультатРекурсия.Добавить(Кнопка);
			КонецЕсли; 
			Если Ложь
				Или Найти(Действие, "КлсКомандаНажатие") = 1
				Или Найти(Действие, "КлсКомандаТаблицаНажатие") = 1 
				Или Кнопка.Имя = "ОтборПоЗначениюВТекущейКолонке"
				Или Кнопка.Имя = "ОтключитьОтбор"
				Или Кнопка.Имя = "ОбновитьСписок"
			Тогда
				ОбщаяКоманда = ОбщиеКоманды.Найти(Кнопка.Имя);
				Если ОбщаяКоманда = Неопределено Тогда
					ВызватьИсключение ирОбщий.СтрШаблонЛкс("Неизвестное имя общей команды ""%1""", Кнопка.Имя);
				КонецЕсли;
				ЗаполнитьЗначенияСвойств(Кнопка, ОбщаяКоманда, "СочетаниеКлавиш, Подсказка, Пояснение"); 
			ИначеЕсли Ложь
				Или Действие = "Отбор по значению в текущей колонке" 
			Тогда
				Кнопка.СочетаниеКлавиш = ОбщиеКоманды.ОтборПоЗначениюВТекущейКолонке.СочетаниеКлавиш;
			ИначеЕсли Ложь
				Или Действие = "Отключить отбор" 
			Тогда
				Кнопка.СочетаниеКлавиш = ОбщиеКоманды.ОтключитьОтбор.СочетаниеКлавиш;
			КонецЕсли; 
		КонецЕсли; 
	КонецЦикла;
	Возврат РезультатРекурсия;
	
КонецФункции

// Только для кнопок с обработчиком "КлсКомандаНажатие"
Функция КоманднаяПанельКнопкиЛкс(Знач ЭтаФорма, Знач Кнопка) 
	мСвойстваФормы = ирОбщий.СлужебныеДанныеФормыЛкс(ЭтаФорма);
	Пока ТипЗнч(Кнопка) = Тип("КнопкаКоманднойПанели") Цикл
		Кнопка = мСвойстваФормы.КомандныеПанелиКнопок[Кнопка];
	КонецЦикла; 
	Возврат Кнопка;
КонецФункции

Процедура УстановитьГотовностьДанныхСтраницыЛкс(ЭтаФорма, Страница, Готовность = Истина) Экспорт 
	
	НеготовыеСтраницы = ирОбщий.СлужебныеДанныеФормыЛкс(ЭтаФорма).НеготовыеСтраницы;
	#Если Сервер И Не Сервер Тогда
	    НеготовыеСтраницы = Новый СписокЗначений;
	#КонецЕсли
	ЭлементСписка = НеготовыеСтраницы.НайтиПоЗначению(Страница.Имя);
	Если ЭлементСписка <> Неопределено И Готовность Тогда
		НеготовыеСтраницы.Удалить(ЭлементСписка);
	ИначеЕсли ЭлементСписка = Неопределено И Не Готовность Тогда
		НеготовыеСтраницы.Добавить(Страница.Имя);
	КонецЕсли; 
	
КонецПроцедуры

Функция ПолучитьГотовностьДанныхСтраницыЛкс(ЭтаФорма, Страница) Экспорт 
	
	НеготовыеСтраницы = ирОбщий.СлужебныеДанныеФормыЛкс(ЭтаФорма).НеготовыеСтраницы;
	#Если Сервер И Не Сервер Тогда
	    НеготовыеСтраницы = Новый СписокЗначений;
	#КонецЕсли
	ЭлементСписка = НеготовыеСтраницы.НайтиПоЗначению(Страница.Имя);
	Результат = ЭлементСписка = Неопределено;
	Возврат Результат;
	
КонецФункции

Процедура ОткрытьСтруктуруКоманднойПанелиЛкс(ЭтаФорма, Знач Кнопка = Неопределено) Экспорт
	
	Если ТипЗнч(ЭтаФорма) = Тип("Форма") Тогда
		мСвойстваФормы = ирОбщий.СлужебныеДанныеФормыЛкс(ЭтаФорма);
		КоманднаяПанель = мСвойстваФормы.КнопкиВсехДействийКомандныхПанелей[Кнопка];
		Если Кнопка <> Неопределено Тогда
			Если КоманднаяПанель.Кнопки.Индекс(Кнопка) = -1 Тогда
				// Для контекстных меню
				КоманднаяПанель = КоманднаяПанель.Кнопки[0];
			КонецЕсли; 
		КонецЕсли; 
	Иначе
		КоманднаяПанель = ирОбщий.РодительЭлементаУправляемойФормыЛкс(Кнопка, Тип("ГруппаФормы"));
	КонецЕсли; 
	ФормаСтруктуры = ирКэш.Получить().ПолучитьФорму("СтруктураФормы");
	ФормаСтруктуры.ПараметрЭлементФормы = КоманднаяПанель;
	ФормаСтруктуры.Форма = ЭтаФорма;
	ФормаСтруктуры.ОткрытьМодально();
	
КонецПроцедуры

Процедура ОткрытьСтруктуруФормыЛкс(ЭтаФорма, КлючУникальности = Неопределено) Экспорт
	
	ФормаСтруктуры = ирКэш.Получить().ПолучитьФорму("СтруктураФормы",, КлючУникальности);
	ФормаСтруктуры.Форма = ЭтаФорма;
	ФормаСтруктуры.ОткрытьМодально();
	
КонецПроцедуры

Функция ОткрытьФормуСоединенияСУБДЛкс(Автоподключение = Ложь) Экспорт
	
	мПлатформа = ирКэш.Получить();
	#Если Сервер И Не Сервер Тогда
		мПлатформа = Обработки.ирПлатформа.Создать();
	#КонецЕсли
	ПроверкаСоединенияADOЭтойБДВыполнялась = мПлатформа.мПроверкаСоединенияADOЭтойБДВыполнялась = Истина;
	ФормаПодключения = ирКэш.Получить().ПолучитьФорму("ПараметрыСоединенияСУБД");
	ФормаПодключения.Автоподключение = Автоподключение И ПроверкаСоединенияADOЭтойБДВыполнялась;
	Если Истина
		И (Ложь
			Или Не ПроверкаСоединенияADOЭтойБДВыполнялась 
			Или Не Автоподключение) 
		И Не ирКэш.ЛиФайловаяБазаЛкс() 
	Тогда
		ФормаЗащиты = Неопределено;
		#Если ТолстыйКлиентУправляемоеПриложение Тогда 
			Если ирКэш.НомерИзданияПлатформыЛкс() > "82" Тогда
				// Антибаг платформы https://www.hostedredmine.com/issues/901181
				ФормаЗащиты = ОткрытьФорму("Обработка.ирПлатформа.Форма.Пустышка");
			КонецЕсли;
		#КонецЕсли
		РезультатФормы = ФормаПодключения.ОткрытьМодально();
		Если ФормаЗащиты <> Неопределено Тогда
			ФормаЗащиты.Закрыть();  
		КонецЕсли;
		Если РезультатФормы <> Истина Тогда 
			Возврат Неопределено;
		КонецЕсли;
	КонецЕсли; 
	Возврат ФормаПодключения;
	
КонецФункции

Функция ОткрытьОбщиеПараметрыЗаписиЛкс(ТолькоОбъектыНаСервере = Ложь) Экспорт 
	
	мПлатформа = ирКэш.Получить();
	#Если Сервер И Не Сервер Тогда
		мПлатформа = Обработки.ирПлатформа.Создать();
	#КонецЕсли
	Форма = мПлатформа.ПолучитьФорму("ПараметрыЗаписиОбъектов");
	Форма.ПараметрТолькоОбъектыНаСервере = ТолькоОбъектыНаСервере;
	Форма.ОткрытьМодально();
	
КонецФункции

Функция ОткрытьСсылкуИТСЛкс(СтрокаЗапуска) Экспорт  
	
	Маркер = "v?doc";
	Если Найти(СтрокаЗапуска, Маркер) > 0 Тогда
		ФрагментыМаркера = ирОбщий.СтрРазделитьЛкс(Маркер, "?");
		СисИнфо = Новый СистемнаяИнформация;
		ФрагментыВерсии = ирОбщий.СтрРазделитьЛкс(СисИнфо.ВерсияПриложения);
		ТекущаяВерсия = ФрагментыВерсии[0] + "." + ФрагментыВерсии[1] + "." + ФрагментыВерсии[2];
		ВыбраннаяВерсия = СтрЗаменить(ТекущаяВерсия, ".", "");
		СтрокаЗапуска = ирОбщий.СтрЗаменитьЛкс(СтрокаЗапуска, Маркер, ФрагментыМаркера[0] + ВыбраннаяВерсия + ФрагментыМаркера[1]);
	КонецЕсли; 
	ЗапуститьПриложение(СтрокаЗапуска);
	
КонецФункции

Процедура УстановитьДоступностьВыполненияНаСервереЛкс(ЭтаФорма, ИмяФлага = "ВыполнятьНаСервере") Экспорт 
	
	ДоступностьРежима = ирОбщий.ЛиАсинхронностьДоступнаЛкс();
	Если ЭтаФорма.ЭлементыФормы.Найти(ИмяФлага) <> Неопределено Тогда
		Флажок = ЭтаФорма.ЭлементыФормы[ИмяФлага];
		Флажок.Доступность = ДоступностьРежима;
		Флажок.Заголовок = "Выполнять на сервере";
		Флажок.Подсказка = "Недоступно в портативном варианте. " + Флажок.Подсказка;
	КонецЕсли; 
	Если Не ДоступностьРежима Тогда
		ЭтаФорма.ЭтотОбъект[ИмяФлага] = Ложь;
	КонецЕсли;

КонецПроцедуры

Функция ТабличноеПолеИлиТаблицаФормы_СколькоСтрокЛкс(ТабличноеПоле, Знач НастройкиСписка = Неопределено) Экспорт
	ЗначениеЭУ = ирОбщий.ДанныеЭлементаФормыЛкс(ТабличноеПоле);
	Если ЗначениеЭУ <> Неопределено Тогда
		Количество = Неопределено;  
		Попытка
			Количество = ТаблицаИлиДеревоЗначенийИзТаблицыФормыСКоллекциейЛкс(ТабличноеПоле,, Истина).Количество();
		Исключение
		КонецПопытки;
		Если ТипЗнч(ТабличноеПоле) = Тип("ТаблицаФормы") Тогда
			Отбор = "?";
		Иначе
			Попытка
				Отбор = ТабличноеПоле.ОтборСтрок;
			Исключение
			КонецПопытки;
		КонецЕсли;
		Если Количество = Неопределено Тогда
			Попытка
				//Коллекция компоновки
				Количество = ЗначениеЭУ.Элементы.Количество();
				//Суффикс = "*";
			Исключение
				Попытка
					//Или ИмяОбщегоТипа = "ДеревоЗначений" 
					Количество = ЗначениеЭУ.Строки.Количество();
					Суффикс = "*";
				Исключение
				КонецПопытки;
			КонецПопытки;
		КонецЕсли; 
		Если Количество = Неопределено Тогда
			// ДинамическийСписок
			Если НастройкиСписка = Неопределено Тогда
				НастройкиСписка = ирОбщий.НастройкиДинамическогоСпискаЛкс(ЗначениеЭУ);
			КонецЕсли; 
			Отбор = НастройкиСписка.Отбор;
			ПолноеИмяТаблицы = ирОбщий.ИмяТаблицыБДДинамическогоСпискаЛкс(ТабличноеПоле);
			ЗапросСписка = ЗапросДинамическогоСпискаЛкс(ТабличноеПоле, ПолноеИмяТаблицы);
			Если ЗапросСписка <> Неопределено И ЗначениеЗаполнено(ЗапросСписка.Текст) Тогда
				Количество = ирОбщий.КоличествоСтрокВТаблицеБДЛкс(ЗапросСписка);
			Иначе
				Количество = ирОбщий.КоличествоСтрокВТаблицеБДЛкс(ПолноеИмяТаблицы, Отбор);
			КонецЕсли;
		КонецЕсли;
	КонецЕсли; 
		
	Текст = "Количество строк ";
	Если Отбор <> Неопределено Тогда
		Текст = Текст + "отобрано ";
	КонецЕсли;
	Текст = Текст + "- " + Формат(Количество, "ЧН=; ЧГ=") + Суффикс;
	Если ТабличноеПоле.ВыделенныеСтроки.Количество() > 1 Тогда
		Текст = Текст + ", выделено - " + Формат(ТабличноеПоле.ВыделенныеСтроки.Количество(), "ЧН=; ЧГ=");
	КонецЕсли; 
	Если Отбор <> Неопределено Тогда
		Текст = Текст + ". Отбор - """ + Отбор + """ ";
	КонецЕсли;
	ирОбщий.СообщитьЛкс(Текст,,, Истина);
	
	// Тексты подвала
	Результат = Количество;
	МассивПодвалов = Новый Массив;
	#Если Клиент Тогда
		Если ТипЗнч(ТабличноеПоле) = Тип("ТабличноеПоле") Тогда
			Для Каждого КолонкаТП Из ТабличноеПоле.Колонки Цикл
				ТекстПодвала = ирОбщий.ПоследнийФрагментЛкс(КолонкаТП.ТекстПодвала, "Σ");
				Если ЗначениеЗаполнено(ТекстПодвала) Тогда
					МассивПодвалов.Добавить(КолонкаТП.ТекстШапки + " = " + ТекстПодвала);
				КонецЕсли; 
			КонецЦикла;
		КонецЕсли; 
	#КонецЕсли 
	Если МассивПодвалов.Количество() > 0 Тогда
		ирОбщий.СообщитьЛкс(ирОбщий.СтрСоединитьЛкс(МассивПодвалов, "; "));
	КонецЕсли; 
	Возврат Результат;
	
КонецФункции

// Функция - Данные строки табличного поля лкс
//
// Параметры:
//  ТабличноеПоле	 - 	 - 
//  Строка			 - 	 - 
//  ДанныеПоля		 - 	 - вход/выход, можно передавать пустую переменнную для ускорения анализа таблицы формы компоновки данных
// 
// Возвращаемое значение:
//   - 
//
Функция ДанныеСтрокиТабличногоПоляЛкс(ТабличноеПоле, Знач Строка = Неопределено, ДанныеПоля = Неопределено) Экспорт 
	
	Если ТипЗнч(ТабличноеПоле) = Тип("ТаблицаФормы") Тогда
		ДанныеСтроки = Неопределено;
		Если Строка = Неопределено Тогда
			Строка = ТабличноеПоле.ТекущаяСтрока;
		КонецЕсли; 
		Если ТипЗнч(Строка) = Тип("ИдентификаторКомпоновкиДанных") Тогда
			Если ДанныеПоля = Неопределено Тогда
				ДанныеПоля = ирОбщий.ДанныеЭлементаФормыЛкс(ТабличноеПоле);
			КонецЕсли;
			Если ДанныеПоля <> Неопределено Тогда
				ДанныеСтроки = ДанныеПоля.ПолучитьОбъектПоИдентификатору(Строка);
			КонецЕсли;
		КонецЕсли;
		Если ДанныеСтроки = Неопределено И Строка <> Неопределено Тогда
			//ДанныеТаблицы = ирОбщий.ДанныеЭлементаФормыЛкс(ТабличноеПоле);
			//#Если Сервер И Не Сервер Тогда
			//    ДанныеТаблицы = Новый ТаблицаЗначений;
			//#КонецЕсли
			//ДанныеСтроки = ДанныеТаблицы.НайтиПоИдентификатору(Строка);
			ДанныеСтроки = ТабличноеПоле.ДанныеСтроки(Строка);
			Если ДанныеСтроки = Неопределено Тогда
				// Ключ записи регистра без ресурсов и измерений (ШтрихкодыНоменклатуры) иногда почему то дает Неопределено
				ДанныеСтроки = Строка;
			КонецЕсли;
		КонецЕсли; 
	ИначеЕсли ТипЗнч(ТабличноеПоле) = Тип("ТабличноеПоле") Тогда
		ДанныеСтроки = Строка;
		Если Ложь
			Или ДанныеСтроки = Неопределено 
			Или ирОбщий.ЛиКлючЗаписиРегистраЛкс(ДанныеСтроки)
		Тогда
			Попытка
				ДанныеСтроки = ТабличноеПоле.ТекущиеДанные;
			Исключение
				// Удаленное из формы табличное поле, например вызов из Обработка.ирПлатформа.Форма.СтрокаТаблицы
				ТабличноеПоле = Неопределено;
			КонецПопытки;
		КонецЕсли; 
	КонецЕсли; 
	Возврат ДанныеСтроки;
	
КонецФункции

Процедура ИсследоватьВерсиюОбъектаДанныхЛкс(Знач Данные, Знач НомерВерсии) Экспорт 
	
	#Если ВебКлиент Тогда
		Сообщить("Команда недоступна в вебклиенте");
	#Иначе
		ИсторияДанныхМоя = ирОбщий.ИсторияДанныхЛкс();
		#Если Сервер И Не Сервер Тогда
			ИсторияДанныхМоя = ИсторияДанных;
		#КонецЕсли
		Структура = ИсторияДанныхМоя.ПолучитьДанныеВерсии(Данные, НомерВерсии);
		ирОбщий.ИсследоватьЛкс(Структура);
	#КонецЕсли

КонецПроцедуры

Функция ОткрытьСистемнуюФормуОтчетПоВерсииЛкс(Данные, НомерВерсии) Экспорт 
	
	Попытка
		ОткрытьФорму("sysForm:DataHistoryVersionDataRuForm", Новый Структура("Данные, НомерВерсии", Данные, НомерВерсии));
	Исключение
		ОписаниеОшибки = ОписаниеОшибки();
		ИсследоватьВерсиюОбъектаДанныхЛкс(Данные, НомерВерсии);
	КонецПопытки;

КонецФункции

// Функция - Открыть системную форму список версий лкс
//
// Параметры:
//  Данные		 - 	 - 
//  НомерВерсии	 - Число - пока не реализовано
// 
// Возвращаемое значение:
//   - 
//
Функция ОткрытьСистемнуюФормуСписокВерсийОбъектаЛкс(Данные, НомерВерсии) Экспорт 
	
	ОткрытьФорму("sysForm:DataHistoryVersions", Новый Структура("Data", Данные));

КонецФункции

Функция ОткрытьСистемнуюФормуСравнениеВерсийЛкс(Данные, НомерВерсииПослеИзменения, НомерВерсииДоИзменения) Экспорт 
	
	ОткрытьФорму("sysForm:DataHistoryVersionDifferenecesRuForm", Новый Структура("Данные, НомерВерсииПослеИзменения, НомерВерсииДоИзменения", Данные, НомерВерсииПослеИзменения, НомерВерсииДоИзменения));

КонецФункции

Функция ОткрытьСистемнуюФормуНастройкаОтбораВерсийЛкс(Знач КлючОбъекта, Знач ОтборВерсий, Знач Оповещение) Экспорт 
	
	ПараметрыФормы = Новый Структура;
	ПараметрыФормы.Вставить("Filter", ОтборВерсий);
	ПараметрыФормы.Вставить("Data", КлючОбъекта);
	ПолноеИмяФормы = "sysForm:DataHistoryVersionsFilterDialog";
	Выполнить("ОткрытьФорму(ПолноеИмяФормы, ПараметрыФормы,,,,, Оповещение)"); // Параметра "Оповещение" в 8.2 нет

КонецФункции

Процедура ИсследоватьСравнениеВерсийЛкс(Знач Данные, Знач НомерВерсииПослеИзменения, Знач НомерВерсииДоИзменения) Экспорт 
	
	#Если ВебКлиент Тогда
		Сообщить("Команда недоступна в вебклиенте");
	#Иначе
		ИсторияДанныхМоя = ирОбщий.ИсторияДанныхЛкс();
		#Если Сервер И Не Сервер Тогда
			ИсторияДанныхМоя = ИсторияДанных;
		#КонецЕсли
		Структура = ИсторияДанныхМоя.ПолучитьРазличияВерсий(Данные, НомерВерсииПослеИзменения, НомерВерсииДоИзменения);
		ирОбщий.ИсследоватьЛкс(Структура);
	#КонецЕсли

КонецПроцедуры

Функция НоваяФормаРезультатаФоновогоЗаданияЛкс() Экспорт 
	
	// Управляемые формы так создавать нельзя! 
	// http://www.hostedredmine.com/issues/874998
	//мПлатформа = ирКэш.Получить();
	//#Если Сервер И Не Сервер Тогда
	//	мПлатформа = Обработки.ирПлатформа.Создать();
	//#КонецЕсли
	//ФормаРезультатФоновогоЗадания = мПлатформа.ПолучитьФорму("РезультатФоновогоЗадания");
	
	// Антибаг платформы. При чтении в обычной форме результата выполнения фонового задания часто возвращается Неопределено https://www.hostedredmine.com/issues/884756
	Если Истина Или ирКэш.НомерВерсииПлатформыЛкс() >= 803013 Тогда
		ФормаРезультатФоновогоЗадания = Новый Структура("УникальныйИдентификатор", Новый УникальныйИдентификатор);
	Иначе
		// Тяжелая операция. В ERP - 10 секунд
		ФормаРезультатФоновогоЗадания = ПолучитьФормуЛкс("Обработка.ирПлатформа.Форма.РезультатФоновогоЗадания",,, Новый УникальныйИдентификатор); 
	КонецЕсли;
	Возврат ФормаРезультатФоновогоЗадания;

КонецФункции

Функция ЗапуститьИлиОтменитьФоновоеЗаданиеФормыЛкс(Знач ЭтаФорма, Знач ОписаниеЗадания, Знач Перезапустить = Ложь, выхОшибкаСериализации = Ложь) Экспорт 
	
	СлужебныеДанные = ирОбщий.СлужебныеДанныеФормыЛкс(ЭтаФорма);
	#Если Сервер И Не Сервер Тогда
		СлужебныеДанные = Новый Структура;
		ОписаниеЗадания = ОписаниеФоновогоЗаданияФормыЛкс();
	#КонецЕсли
	Если Не ирОбщий.МетодРеализованЛкс(ЭтаФорма, ОписаниеЗадания.ОбработчикЗавершения) Тогда
		ВызватьИсключение "У формы " + СсылкаНаМодульКонфигурацииЛкс(СлужебныеДанные.ИмяФормы) + " не обнаружен экспортный метод " + ОписаниеЗадания.ОбработчикЗавершения;
	КонецЕсли; 
	МаркерОтмены = "Отменить фоновое задание";
	ЗаданияФормы = СлужебныеДанные.Задания;
	Если ЗаданияФормы.Свойство(ОписаниеЗадания.Имя) Тогда
		ОписаниеЗаданияСтарое = ЗаданияФормы[ОписаниеЗадания.Имя];
		Если ОписаниеЗаданияСтарое.УникальныйИдентификатор <> Неопределено Тогда
			Если Ложь
				Или ОписаниеЗадания.Кнопка = Неопределено
				Или ОписаниеЗадания.Кнопка.Картинка <> ирКэш.КартинкаПоИмениЛкс("ирОстановить") 
			Тогда
				Перезапустить = Истина;
			КонецЕсли; 
			ОтменитьЗаданиеФормыЛкс(ЭтаФорма, ОписаниеЗаданияСтарое);
			Если Не Перезапустить Тогда
				Возврат Неопределено;
			КонецЕсли; 
		КонецЕсли; 
	КонецЕсли; 
	ОписаниеЗадания.НачалоВыполнения = ТекущаяДата();
	ирОбщий.ДобавитьТекущемуПользователюРолиИРЛкс();
	Наименование = ЭтаФорма.Метаданные().Представление() + ". " + ОписаниеЗадания.Представление;
	Попытка
		ФоновоеЗадание = ФоновыеЗадания.Выполнить(ОписаниеЗадания.Метод, ОписаниеЗадания.Параметры, , Наименование);
	Исключение
		выхОшибкаСериализации = Истина;
		Возврат Неопределено;
	КонецПопытки;
	ОписаниеЗадания.УникальныйИдентификатор = ФоновоеЗадание.УникальныйИдентификатор;
	ЗаданияФормы.Вставить(ОписаниеЗадания.Имя, ОписаниеЗадания);
	ФормаЗадания = ФормаЗаданияФормыЛкс(ОписаниеЗадания, ЭтаФорма);
	Если ФормаЗадания <> Неопределено Тогда
		#Если Сервер И Не Сервер Тогда
			ФормаЗадания = ПолучитьОбщуюФорму();
		#КонецЕсли
		ФормаЗадания.ЭлементыФормы.ПолеТекста.Очистить();
		ФормаЗадания.ЭлементыФормы.Отменить.Доступность = Истина;
		ФормаЗадания.ЗакрыватьПриЗакрытииВладельца = ЭтаФорма.Открыта();
		ФормаЗадания.Отменить = Ложь;
		ФормаЗадания.ЭлементыФормы.Прервать.Доступность = ОписаниеЗадания.ПоддерживаетПрерывание;
		ФормаЗадания.ИдентификаторЗадания = ФоновоеЗадание.УникальныйИдентификатор;
		ФормаЗадания.ОбновитьСостояниеЗадания(ФоновоеЗадание);
	КонецЕсли; 
	ОжидатьЗавершения = ОписаниеЗадания.Кнопка = Неопределено;
	Если Не ОжидатьЗавершения Тогда
		// Завершаем основной поток
		Если ОписаниеЗадания.БлокируемыеЭлементыФормы <> Неопределено Тогда
			Для Каждого КлючИЗначение Из ОписаниеЗадания.БлокируемыеЭлементыФормы Цикл
				КлючИЗначение.Значение.Вставить("Доступность");
				КлючИЗначение.Значение.Вставить("ТолькоПросмотр");
				БлокируемыйЭлемент = КлючИЗначение.Ключ;
				#Если Сервер И Не Сервер Тогда
					БлокируемыйЭлемент = Новый ТабличноеПоле;
				#КонецЕсли
				ЗаполнитьЗначенияСвойств(КлючИЗначение.Значение, БлокируемыйЭлемент);
				Если ТипЗнч(БлокируемыйЭлемент) = Тип("ПолеHTMLДокумента") Тогда
					ПолеТекста = ОболочкаПоляТекстаЛкс(БлокируемыйЭлемент);
					#Если Сервер И Не Сервер Тогда
						ПолеТекста = Обработки.ирОболочкаПолеТекста.Создать();
					#КонецЕсли
					КлючИЗначение.Значение.ТолькоПросмотр = ПолеТекста.ТолькоПросмотр();
					ПолеТекста.ТолькоПросмотр(Истина);
				Иначе
					Попытка
						БлокируемыйЭлемент.ТолькоПросмотр = Истина;
					Исключение
						БлокируемыйЭлемент.Доступность = Ложь;
					КонецПопытки; 
				КонецЕсли; 
			КонецЦикла;
		КонецЕсли; 
		Если ТипЗнч(ОписаниеЗадания.Кнопка) = Тип("КнопкаКоманднойПанели") Тогда
			ИменаСвойств = "Доступность, Подсказка, Картинка, Отображение";
		Иначе
			ИменаСвойств = "Доступность, Подсказка, Картинка";
		КонецЕсли; 
		СвойстваКнопки = Новый Структура(ИменаСвойств);
		ЗаполнитьЗначенияСвойств(СвойстваКнопки, ОписаниеЗадания.Кнопка, ИменаСвойств); 
		ОписаниеЗадания.СвойстваКнопки = СвойстваКнопки;
		ОписаниеЗадания.Кнопка.Доступность = Истина;
		ОписаниеЗадания.Кнопка.Картинка = ирКэш.КартинкаПоИмениЛкс("ирОстановить");
		ОписаниеЗадания.Кнопка.Подсказка = МаркерОтмены + " - " + ОписаниеЗадания.Представление;
		Если СвойстваКнопки.Свойство("Отображение") Тогда
			ОписаниеЗадания.Кнопка.Отображение = ОтображениеКнопкиКоманднойПанели.НадписьКартинка;
		КонецЕсли; 
	Иначе
		// Удерживаем основной поток
		Если ОписаниеЗадания.Многопоточное Тогда
			ФормаЗадания.Открыть();
		КонецЕсли; 
		#Если Сервер И Не Сервер Тогда
			ОтменитьЗаданиеФормыОтложенноЛкс();
		#КонецЕсли
		ПодключитьОбработчикОжиданияСПараметрамиЛкс("ОтменитьЗаданиеФормыОтложенноЛкс", Новый Структура("ЭтаФорма, ОписаниеЗадания", ЭтаФорма, ОписаниеЗадания));
		ирОбщий.ОжидатьЗавершенияФоновойОперацииЛкс(ФоновоеЗадание, ЭтаФорма, Ложь, ФормаЗадания);
	КонецЕсли; 
	Результат = Неопределено;
	ПроверитьЗавершениеФоновыхЗаданийФормыЛкс(ЭтаФорма, ОписаниеЗадания, Результат);
	Возврат Результат;

КонецФункции

Функция ОписаниеФоновогоЗаданияФормыЛкс(Имя = "", Метод = "", Параметры = Неопределено, Знач Представление = "", Кнопка = Неопределено, ОбработчикЗавершения = "", АдресРезультата = "",
	ОповещатьПользователяОбУспехе = Истина, БлокируемыеЭлементыФормы = Неопределено, Многопоточное = Ложь, ПрефиксыОповещений = Неопределено, Знач ПоддерживаетПрерывание = Ложь) Экспорт 
	
	Если Не ЗначениеЗаполнено(Представление) Тогда
		Представление = ирОбщий.ПредставлениеИзИдентификатораЛкс(Имя);
	КонецЕсли; 
	ОписаниеЗадания = Новый Структура("Имя, Параметры, Метод, Представление, Кнопка, ОбработчикЗавершения, АдресРезультата, УникальныйИдентификатор, НачалоВыполнения, Состояние, СвойстваКнопки,
	|ОповещатьПользователяОбУспехе, БлокируемыеЭлементыФормы, ФормаЗадания, Многопоточное, ПрефиксыОповещений, ПоддерживаетПрерывание");
	ОписаниеЗадания.Имя = Имя;
	ОписаниеЗадания.Параметры = Параметры;
	ОписаниеЗадания.Метод = Метод;
	ОписаниеЗадания.Представление = Представление;
	ОписаниеЗадания.Кнопка = Кнопка;
	ОписаниеЗадания.ОбработчикЗавершения = ОбработчикЗавершения;
	ОписаниеЗадания.АдресРезультата = АдресРезультата;
	ОписаниеЗадания.ОповещатьПользователяОбУспехе = ОповещатьПользователяОбУспехе;
	ОписаниеЗадания.Многопоточное = Многопоточное;
	ОписаниеЗадания.ПрефиксыОповещений = ПрефиксыОповещений;
	ОписаниеЗадания.ПоддерживаетПрерывание = ПоддерживаетПрерывание;
	Если БлокируемыеЭлементыФормы <> Неопределено Тогда
		СтруктураБлокировки = Новый Соответствие;
		Для Каждого ЭлементФормы Из БлокируемыеЭлементыФормы Цикл
			Если Истина
				И Типзнч(ЭлементФормы) = Тип("КнопкаКоманднойПанели")
				И ЭлементФормы.ТипКнопки = ТипКнопкиКоманднойПанели.Подменю
			Тогда
			Для Каждого КнопкаПодменю Из ЭлементФормы.Кнопки Цикл
					Если КнопкаПодменю.Доступность Тогда
						СтруктураБлокировки.Вставить(КнопкаПодменю, Новый Структура());
					КонецЕсли; 
				КонецЦикла;
			Иначе
				СтруктураБлокировки.Вставить(ЭлементФормы, Новый Структура());
			КонецЕсли; 
		КонецЦикла;
		ОписаниеЗадания.БлокируемыеЭлементыФормы = СтруктураБлокировки;
	КонецЕсли; 
	Возврат ОписаниеЗадания;

КонецФункции

Функция НовыйАдресРезультатаФоновогоЗаданияФормыЛкс(Знач ЭтаФорма) Экспорт 
	
	ФормаРезультатовЗаданий = ФормаРезультатовЗаданийФормыЛкс(ЭтаФорма);
	АдресРезультата = ПоместитьВоВременноеХранилище(Null, ФормаРезультатовЗаданий.УникальныйИдентификатор);
	Возврат АдресРезультата;

КонецФункции

Функция ФормаРезультатовЗаданийФормыЛкс(Знач ЭтаФорма) Экспорт 
	
	СлужебныеДанные = ирОбщий.СлужебныеДанныеФормыЛкс(ЭтаФорма);
	#Если Сервер И Не Сервер Тогда
		СлужебныеДанные = Новый Структура;
	#КонецЕсли
	Результат = Неопределено;
	Если Не СлужебныеДанные.Свойство("ФормаРезультатовЗаданий", Результат) Тогда
		Результат = НоваяФормаРезультатаФоновогоЗаданияЛкс();
		СлужебныеДанные.Вставить("ФормаРезультатовЗаданий", Результат);
	КонецЕсли;
	Возврат Результат;

КонецФункции

// Функция - Проверить завершение фоновых заданий формы лкс
//
// Параметры:
//  ЭтаФорма - 	 - 
// 
// Возвращаемое значение:
//   - Булево - активные задания отсутствуют
//
Функция ПроверитьЗавершениеФоновыхЗаданийФормыЛкс(Знач ЭтаФорма, Знач ОписаниеЗаданияОтбора = Неопределено, Результат = Неопределено) Экспорт 
	
	//Если Не ЭтаФорма.Открыта() Тогда
	//	Возврат Истина;
	//КонецЕсли; 
	СлужебныеДанные = ирОбщий.СлужебныеДанныеФормыЛкс(ЭтаФорма);
	#Если Сервер И Не Сервер Тогда
		ЭтаФорма = ПолучитьОбщуюФорму();
		СлужебныеДанные = Новый Структура;
	#КонецЕсли
	ЗадержкаВызова = 100;
	ДлительностьДляЗаголовка = 0;
	РазделительДлительности = "-";
	ПозицияРазделителя = Найти(ЭтаФорма.Заголовок, РазделительДлительности);
	Если Истина
		И ПозицияРазделителя < 10 
		И Найти(Лев(ЭтаФорма.Заголовок, ПозицияРазделителя), ":") > 0
	Тогда
		ЧистыйЗаголовокФормы = Сред(ЭтаФорма.Заголовок, ПозицияРазделителя + СтрДлина(РазделительДлительности));
	Иначе
		ЧистыйЗаголовокФормы = ЭтаФорма.Заголовок;
	КонецЕсли; 
	ФормаРезультата = ФормаРезультатовЗаданийФормыЛкс(ЭтаФорма);
	Завершенные = Новый Массив;
	ЛиАктивныеЗаданияОтсутствуют = Истина;
	Для Каждого КлючИЗначение Из СлужебныеДанные.Задания Цикл
		ОписаниеЗадания = КлючИЗначение.Значение;
		Если Истина
			И ОписаниеЗаданияОтбора <> Неопределено
			И ОписаниеЗаданияОтбора <> ОписаниеЗадания
		Тогда
			Продолжить;
		КонецЕсли; 
		Если ОписаниеЗадания.УникальныйИдентификатор = Неопределено Тогда
			// Уже обработано. Защита от зацикливания
			Продолжить;
		КонецЕсли; 
		ФоновоеЗадание = ФоновыеЗадания.НайтиПоУникальномуИдентификатору(ОписаниеЗадания.УникальныйИдентификатор);
		ФормаЗадания = ФормаЗаданияФормыЛкс(ОписаниеЗадания, ЭтаФорма);
		Если ФормаЗадания <> Неопределено И ФормаЗадания.Отменить Тогда
			ОтменитьЗаданиеФормыЛкс(ЭтаФорма, ОписаниеЗадания);
		КонецЕсли;
		ДлительностьЗадания = ТекущаяДата() - ОписаниеЗадания.НачалоВыполнения;
		СостояниеЗадания = ФоновоеЗадание.Состояние;
		Если ОписаниеЗадания.Многопоточное Тогда 
			ПрефиксКлючаПотока = ирОбщий.ПрефиксКлючаПотокаЛкс(ЭтаФорма);
		КонецЕсли; 
		ЭтаИлиФормаЗаданияАктивна = Ложь
			Или ФормаЗадания = Неопределено
			Или Форма_ВводДоступенЛкс(ЭтаФорма) 
			Или Форма_ВводДоступенЛкс(ФормаЗадания);
		Если СостояниеЗадания = СостояниеФоновогоЗадания.Активно Тогда
			Если ДлительностьДляЗаголовка < ДлительностьЗадания Тогда 
				ДлительностьДляЗаголовка = ДлительностьЗадания;
			КонецЕсли; 
			Если ДлительностьЗадания > 20 Тогда
				ЗадержкаВызова = Мин(ЗадержкаВызова, 4);
			ИначеЕсли ДлительностьЗадания > 10 Тогда
				ЗадержкаВызова = Мин(ЗадержкаВызова, 2);
			ИначеЕсли ДлительностьЗадания > 5 Тогда
				ЗадержкаВызова = Мин(ЗадержкаВызова, 1);
			ИначеЕсли ДлительностьЗадания > 2 Тогда
				ЗадержкаВызова = Мин(ЗадержкаВызова, 0.5);
			Иначе
				ЗадержкаВызова = Мин(ЗадержкаВызова, 0.2);
			КонецЕсли; 
			Если ЭтаИлиФормаЗаданияАктивна Тогда
				ИзменилиТекстСостояния = ирОбщий.ОбработатьСообщенияФоновогоЗаданияЛкс(ФоновоеЗадание, ФормаЗадания, ПрефиксКлючаПотока);
				Если ФормаЗадания <> Неопределено Тогда
					Если Ложь
						Или ИзменилиТекстСостояния И ДлительностьЗадания > 2 
						Или ДлительностьЗадания > 4
					Тогда
						Если Не ФормаЗадания.Открыта() Тогда
							ФормаЗадания.Открыть();
							ЭтаФорма.Открыть();
						КонецЕсли; 
					КонецЕсли;
				КонецЕсли;
			Иначе
				Если ФормаЗадания.Открыта() Тогда
					ФормаЗадания.Закрыть();
				КонецЕсли; 
			КонецЕсли; 
			ЛиАктивныеЗаданияОтсутствуют = Ложь;
			Результат = Тип("ФоновоеЗадание");
		Иначе
			ОписаниеЗадания.Состояние = СостояниеЗадания;
			Если СостояниеЗадания = СостояниеФоновогоЗадания.Завершено И ЗначениеЗаполнено(ОписаниеЗадания.АдресРезультата) Тогда
				Результат = ирОбщий.ПрочитатьРезультатФоновогоЗаданияЛкс(ОписаниеЗадания.АдресРезультата, ФормаРезультата);
			Иначе
				Результат = Неопределено;
			КонецЕсли; 
			ПараметрыЗадания = ОписаниеЗадания.Параметры;
			ДлительностьЗадания = ФоновоеЗадание.Конец - ФоновоеЗадание.Начало;
			ДлительностьСтрока = ирОбщий.ПредставлениеДлительностиЛкс(ДлительностьЗадания);
			Если СостояниеЗадания = СостояниеФоновогоЗадания.ЗавершеноАварийно Тогда 
				ирОбщий.СообщитьЛкс(ирОбщий.СтрШаблонИменЛкс("Ошибка через %1 фонового задания %2: " + ирОбщий.ПодробноеПредставлениеОшибкиЛкс(ФоновоеЗадание.ИнформацияОбОшибке),
					1, ДлительностьСтрока, 2, ФоновоеЗадание.Наименование), СтатусСообщения.Внимание);
				Результат = ФоновоеЗадание.ИнформацияОбОшибке;
			ИначеЕсли Не ЭтаИлиФормаЗаданияАктивна И ОписаниеЗадания.ОповещатьПользователяОбУспехе Тогда 
				ирОбщий.СообщитьЛкс(ирОбщий.СтрШаблонИменЛкс("Завершено через %1 фоновое задание %2",, ДлительностьСтрока, 2, ФоновоеЗадание.Наименование));
			КонецЕсли;
			Если ФормаЗадания <> Неопределено Тогда
				ФормаЗадания.ПолноеПредставление = ЧистыйЗаголовокФормы + ". " + ФормаЗадания.КраткоеПредставление;
			КонецЕсли;
			ОбработатьЗавершениеЗаданияФормыЛкс(ОписаниеЗадания, ЭтаФорма, ФоновоеЗадание,,, Результат);
			Завершенные.Добавить(КлючИЗначение.Ключ);
		КонецЕсли;
	КонецЦикла;
	Если Завершенные.Количество() > 0 Тогда
		ФлагиПрерыванияЗаданий = ирОбщий.ВосстановитьЗначениеЛкс("ФлагиПрерыванияЗаданий");
		Если ФлагиПрерыванияЗаданий <> Неопределено Тогда
			Для Индекс = 1 - ФлагиПрерыванияЗаданий.Количество() По 0 Цикл // Обратный обход
				ИД = ФлагиПрерыванияЗаданий[-Индекс];
				ФоновоеЗадание = ФоновыеЗадания.НайтиПоУникальномуИдентификатору(ИД);
				Если ФоновоеЗадание <> Неопределено И ФоновоеЗадание.Состояние <> СостояниеФоновогоЗадания.Активно Тогда
					ФлагиПрерыванияЗаданий.Удалить(-Индекс);
				КонецЕсли;
			КонецЦикла;
			ирОбщий.СохранитьЗначениеЛкс("ФлагиПрерыванияЗаданий", ФлагиПрерыванияЗаданий); // ЧитаемПишем без блокировки. Поэтому есть незначительная вероятность потери чужого нового флага
		КонецЕсли;
	КонецЕсли;
	Для Каждого Ключ Из Завершенные Цикл
		СлужебныеДанные.Задания.Удалить(Ключ);
	КонецЦикла;
	Если ЗадержкаВызова <> 100 Тогда
		ЭтаФорма.Заголовок = ирОбщий.ПредставлениеДлительностиЛкс(ДлительностьДляЗаголовка) + РазделительДлительности + ЧистыйЗаголовокФормы;
		ЭтаФорма.ПодключитьОбработчикОжидания("ПроверкаЗавершенияФоновыхЗаданий", ЗадержкаВызова, Истина);
	Иначе
		ЭтаФорма.Заголовок = ЧистыйЗаголовокФормы;
	КонецЕсли;
	Возврат ЛиАктивныеЗаданияОтсутствуют;

КонецФункции

Процедура ОбработатьЗавершениеЗаданияФормыЛкс(Знач ОписаниеЗадания, Знач ЭтаФорма, Знач ФоновоеЗадание = Неопределено, Знач ПоЗапросуПользователя = Ложь, Знач ЗакрытьФормуЗадания = Ложь,
	Знач Результат = Неопределено)
	
	Если ФоновоеЗадание = Неопределено Тогда
		ФоновоеЗадание = ФоновыеЗадания.НайтиПоУникальномуИдентификатору(ОписаниеЗадания.УникальныйИдентификатор);
	КонецЕсли; 
	Если ОписаниеЗадания.Кнопка <> Неопределено Тогда
		ЗаполнитьЗначенияСвойств(ОписаниеЗадания.Кнопка, ОписаниеЗадания.СвойстваКнопки);
	КонецЕсли; 
	Если ОписаниеЗадания.БлокируемыеЭлементыФормы <> Неопределено Тогда
		Для Каждого КлючИЗначение Из ОписаниеЗадания.БлокируемыеЭлементыФормы Цикл
			ЗаполнитьЗначенияСвойств(КлючИЗначение.Ключ, КлючИЗначение.Значение);
			Если ТипЗнч(КлючИЗначение.Ключ) = Тип("ПолеHTMLДокумента") Тогда
				ПолеТекста = ОболочкаПоляТекстаЛкс(КлючИЗначение.Ключ);
				#Если Сервер И Не Сервер Тогда
					ПолеТекста = Обработки.ирОболочкаПолеТекста.Создать();
				#КонецЕсли
				ПолеТекста.ТолькоПросмотр(КлючИЗначение.Значение.ТолькоПросмотр);
			КонецЕсли;
		КонецЦикла;
	КонецЕсли; 
	ФормаЗадания = ФормаЗаданияФормыЛкс(ОписаниеЗадания, ЭтаФорма);
	ирОбщий.ОбработатьСообщенияФоновогоЗаданияЛкс(ФоновоеЗадание, ФормаЗадания);
	ОписаниеЗадания.УникальныйИдентификатор = Неопределено; // Защита от зацикливания
	ОписаниеЗадания.ФормаЗадания = Неопределено;
	Если ФормаЗадания <> Неопределено Тогда
		ПолеСообщений = ФормаЗадания.ЭлементыФормы.ПолеТекста;
		Если ПустаяСтрока(ПолеСообщений.ПолучитьТекст()) Тогда
			Если ФормаЗадания.Открыта() Тогда
				ФормаЗадания.Закрыть();
			КонецЕсли; 
		Иначе
			Если ПоЗапросуПользователя Тогда
				ПолеСообщений.ДобавитьСтроку("Выполнение прервано пользователем!");
			КонецЕсли; 
			Если Истина
				И ЭтаФорма.Открыта()
				И Не ФормаЗадания.Открыта() 
			Тогда
				ФормаЗадания.Открыть();
			КонецЕсли; 
			ЕстьОбычныеСообщения = Истина;
			#Если ТолстыйКлиентУправляемоеПриложение Тогда
				Если ОписаниеЗадания.ПрефиксыОповещений <> Неопределено Тогда
					ТекстОповещения = Новый Массив;
					ЕстьОбычныеСообщения = Ложь;
					Для Счетчик = 1 По ПолеСообщений.КоличествоСтрок() Цикл
						СтрокаСообщения = ПолеСообщений.ПолучитьСтроку(Счетчик);
						ЛиОповещение = Ложь;
						Для Каждого ПрефиксОповещения Из ОписаниеЗадания.ПрефиксыОповещений Цикл
							Если ирОбщий.СтрНачинаетсяСЛкс(СтрокаСообщения, ПрефиксОповещения, Истина) Тогда
								ЛиОповещение = Истина;
								Прервать;
							КонецЕсли;
						КонецЦикла;
						Если ЛиОповещение Тогда
							ТекстОповещения.Добавить(СтрокаСообщения);
						Иначе
							ЕстьОбычныеСообщения = Истина;
						КонецЕсли;
					КонецЦикла; 
				КонецЕсли;
				Если Не ЕстьОбычныеСообщения Тогда
					#Если Сервер И Не Сервер Тогда
						ирКлиент.ОткрытьФормуЛкс();
					#КонецЕсли
					ОписаниеОповещения = Новый ОписаниеОповещения("ОповещениеОткрытьФормуЛкс", ирКлиент, Новый Структура("Форма", ФормаЗадания));
					ПоказатьОповещениеПользователя(, ОписаниеОповещения, ирОбщий.СтрСоединитьЛкс(ТекстОповещения, Символы.ПС));
					Форма_АктивироватьОткрытьЛкс(ЭтаФорма);
				КонецЕсли;
			#КонецЕсли
		КонецЕсли; 
		Если ЗакрытьФормуЗадания Тогда
			Если ФормаЗадания.Открыта() Тогда
				ФормаЗадания.Закрыть();
			КонецЕсли; 
		КонецЕсли; 
		Если ФормаЗадания.Открыта() Тогда
			ФормаЗадания.ОбновитьСостояниеЗадания(ФоновоеЗадание);
		КонецЕсли; 
	КонецЕсли;
	Если ПоЗапросуПользователя Тогда
		Состояние = СостояниеФоновогоЗадания.Отменено;
	Иначе
		Состояние = ФоновоеЗадание.Состояние;
	КонецЕсли;
	Выполнить("ЭтаФорма." + ОписаниеЗадания.ОбработчикЗавершения + "(Состояние, Результат)");

КонецПроцедуры

Процедура ОповещениеОткрытьФормуЛкс(ДопПараметры) Экспорт 
	ДопПараметры.Форма.Открыть();
КонецПроцедуры

Функция ФормаЗаданияФормыЛкс(Знач ОписаниеЗадания, Знач ФормаВладелец)
	
	ФормаЗадания = ОписаниеЗадания.ФормаЗадания;
	Если Истина
		И ФормаЗадания = Неопределено 
		И (Ложь
			// Запрещаем использовать форму для однопоточного задания с ожиданием
			Или ОписаниеЗадания.Кнопка <> Неопределено 
			Или ОписаниеЗадания.Многопоточное)
	Тогда
		мПлатформа = ирКэш.Получить();
		#Если Сервер И Не Сервер Тогда
			мПлатформа = Обработки.ирПлатформа.Создать();
		#КонецЕсли
		ФормаЗадания = мПлатформа.ПолучитьФорму("ФоновоеЗаданиеФормы", ФормаВладелец, ОписаниеЗадания.Имя);
		ФормаЗадания.КраткоеПредставление = ОписаниеЗадания.Представление;
		ФормаЗадания.ПолноеПредставление = ОписаниеЗадания.Представление;
		ОписаниеЗадания.ФормаЗадания = ФормаЗадания;
	КонецЕсли; 
	Возврат ФормаЗадания;

КонецФункции

Процедура ОтменитьФоновоеЗаданиеОтложенноЛкс(Параметры) Экспорт 
	
	ОтменитьФоновоеЗаданиеЛкс(Параметры.ИдентификаторФоновогоЗадания);
	
КонецПроцедуры

Процедура ОтменитьФоновоеЗаданиеЛкс(Знач ИдентификаторИлиФоновоеЗадание) Экспорт 
	
	Если ТипЗнч(ИдентификаторИлиФоновоеЗадание) = Тип("ФоновоеЗадание") Тогда 
		ФоновоеЗадание = ИдентификаторИлиФоновоеЗадание; 
	Иначе
		Если Не ЗначениеЗаполнено(ИдентификаторИлиФоновоеЗадание) Тогда
			Возврат;
		КонецЕсли; 
		ФоновоеЗадание = ФоновыеЗадания.НайтиПоУникальномуИдентификатору(ИдентификаторИлиФоновоеЗадание);
	КонецЕсли; 
	Если Истина
		И ФоновоеЗадание <> Неопределено 
		И ФоновоеЗадание.Состояние = СостояниеФоновогоЗадания.Активно 
	Тогда
		ФоновоеЗадание.Отменить();
		мПлатформа = ирКэш.Получить();
		#Если Сервер И Не Сервер Тогда
			мПлатформа = Обработки.ирПлатформа.Создать();
			ПроверитьОтмененныеФоновыеЗаданияОтложенноЛкс();
		#КонецЕсли
		мПлатформа.ОтмененныеФоновыеЗадания.Добавить(ФоновоеЗадание.УникальныйИдентификатор);
		ПодключитьГлобальныйОбработчикОжиданияЛкс("ПроверитьОтмененныеФоновыеЗаданияОтложенноЛкс", 2);
	КонецЕсли;

КонецПроцедуры

Функция ЗагрузитьТабличныйДокументИнтерактивноЛкс(Знач ТабличныйДокумент = Неопределено, выхПолноеИмяФайла = "") Экспорт 
	
	Если ТабличныйДокумент = Неопределено Тогда
		ТабличныйДокумент = Новый ТабличныйДокумент;
	КонецЕсли; 
	ДиалогВыбораФайла = Новый ДиалогВыбораФайла(РежимДиалогаВыбораФайла.Открытие);
	ДиалогВыбораФайла.Заголовок = "Прочитать табличный документ из файла"; 
	СписокРасширений = Новый СписокЗначений;
	СписокРасширений.Добавить("mxl", "Табличный документ");
	СписокРасширений.Добавить("xls", "Лист Excel");
	СписокРасширений.Добавить("xlsx", "Лист Excel");
	СписокРасширений.Добавить("ods", "Open document");
	СписокРасширений.Добавить("txt", "Текстовый документ");
	СписокРасширений.Добавить("csv", "Текстовый документ");
	СписокРасширений.Добавить("dbf", "dBase III");
	Если ирКэш.ЛиПлатформаWindowsЛкс() Тогда
		СписокРасширений.Добавить("htm", "HTML документ");
		СписокРасширений.Добавить("html", "HTML документ");
	КонецЕсли;
	ДиалогВыбораФайла.Фильтр = ирОбщий.ФильтрДляВыбораФайлаЛкс(СписокРасширений,, Ложь);
	Если ДиалогВыбораФайла.Выбрать() Тогда
		выхПолноеИмяФайла = ДиалогВыбораФайла.ПолноеИмяФайла;
		ФайлНаДиске = Новый Файл(выхПолноеИмяФайла);
		Если Ложь
			Или ирОбщий.СтрокиРавныЛкс(ФайлНаДиске.Расширение, ".txt")
			Или ирОбщий.СтрокиРавныЛкс(ФайлНаДиске.Расширение, ".csv")
		Тогда
			ирОбщий.ПрочитатьТабличныйДокументИзТекстаЛкс(ТабличныйДокумент, выхПолноеИмяФайла);
		ИначеЕсли нРег(ФайлНаДиске.Расширение) = ".dbf" Тогда
			ирОбщий.ПрочитатьТабличныйДокументИзDBFЛкс(ТабличныйДокумент, выхПолноеИмяФайла);
		ИначеЕсли нРег(ФайлНаДиске.Расширение) = ".mxl" Тогда
			ТабличныйДокумент.Прочитать(выхПолноеИмяФайла);
		ИначеЕсли ирОбщий.СтрНачинаетсяСЛкс(ФайлНаДиске.Расширение, ".htm") Тогда
			ирОбщий.СостояниеЛкс("Запускаем EXCEL");
			ИмяФайлаТаблицы = ПолучитьИмяВременногоФайла("xlsx");
			Эксель = Новый COMОбъект("Excel.Application");
			Эксель.Visible = 1; // Иначе могут появляться невидимые модальные окна 
			//Эксель.DisplayAlerts = 0;
			// https://docs.microsoft.com/ru-ru/office/vba/api/excel.workbooks.open
			// (FileName, UpdateLinks, ReadOnly, Format, Password, WriteResPassword, IgnoreReadOnlyRecommended, Origin, Delimiter, Editable, Notify, Converter, AddToMru, Local, CorruptLoad)
			Книга = Эксель.WorkBooks.Open(выхПолноеИмяФайла, Ложь); 
			Книга.SaveAs(ИмяФайлаТаблицы, 51); // 51 - xlsx, 56 - xls, 44 - html
			Книга.Close();
			Эксель.Quit();
			ТабличныйДокумент.Прочитать(ИмяФайлаТаблицы);
			УдалитьФайлы(ИмяФайлаТаблицы);
			ирОбщий.СостояниеЛкс("");
		Иначе
			ТабличныйДокумент.Очистить();
			ТабличныйДокументЧтение = Новый ТабличныйДокумент;
			ТабличныйДокументЧтение.Прочитать(выхПолноеИмяФайла);
			РезультатВыбора = Неопределено;
			Если ТабличныйДокументЧтение.Области.Количество() > 1 Тогда
				СписокВыбора = Новый СписокЗначений;
				Для Каждого Область Из ТабличныйДокументЧтение.Области Цикл
					СписокВыбора.Добавить(Область.Имя);
				КонецЦикла;
				РезультатВыбора = СписокВыбора.ВыбратьЭлемент("Выберите лист файла");
			КонецЕсли;
			Если РезультатВыбора <> Неопределено Тогда
				ТабличныйДокумент.Вывести(ТабличныйДокументЧтение.ПолучитьОбласть(РезультатВыбора.Значение));
			Иначе
				ТабличныйДокумент.Вывести(ТабличныйДокументЧтение);
			КонецЕсли;
		КонецЕсли;
	Иначе
		ТабличныйДокумент = Неопределено;
	КонецЕсли;
	Возврат ТабличныйДокумент;

КонецФункции

Функция СохранитьТабличныйДокументИнтерактивноЛкс(Знач ПолеИлиТабличныйДокумент, выхПолноеИмяФайла = "", Знач СразуОткрыть = Ложь, Знач УстанавливатьПризнакСодержитЗначение = Ложь,
	Знач ЭтаФорма = Неопределено) Экспорт 
	
	Если ЭтаФорма <> Неопределено И ТипЗнч(ПолеИлиТабличныйДокумент) = Тип("ПолеТабличногоДокумента") Тогда
		ПолеТабличногоДокументаВосстановитьОформлениеТекущихСтрокЛкс(ЭтаФорма, ПолеИлиТабличныйДокумент);
	КонецЕсли;
	Если Не ЗначениеЗаполнено(выхПолноеИмяФайла) Тогда
		ДиалогВыбораФайла = Новый ДиалогВыбораФайла(РежимДиалогаВыбораФайла.Сохранение);
		ДиалогВыбораФайла.Заголовок = "Записать табличный документ в файл";
		СписокРасширений = Новый СписокЗначений;
		СписокРасширений.Добавить("mxl", "Табличный документ");
		СписокРасширений.Добавить("xls", "Лист Excel");
		СписокРасширений.Добавить("xlsx", "Лист Excel");
		СписокРасширений.Добавить("ods", "Open document");
		СписокРасширений.Добавить("txt", "Текстовый документ");
		ДиалогВыбораФайла.Фильтр = ирОбщий.ФильтрДляВыбораФайлаЛкс(СписокРасширений,, Ложь);
		Если Не ДиалогВыбораФайла.Выбрать() Тогда
			Возврат Ложь;
		КонецЕсли; 
		выхПолноеИмяФайла = ДиалогВыбораФайла.ПолноеИмяФайла;
	КонецЕсли; 
	ТабличныйДокумент = Новый ТабличныйДокумент;
	ТабличныйДокумент.ВставитьОбласть(ПолеИлиТабличныйДокумент.Область(),,, Ложь);
	Файл = Новый файл(выхПолноеИмяФайла);
	ТипФайла = ТипФайлаТабличногоДокумента.MXL;
	Если ирОбщий.СтрокиРавныЛкс(Файл.Расширение, ".xls") Тогда
		ТипФайла = ТипФайлаТабличногоДокумента.XLS;
		Если УстанавливатьПризнакСодержитЗначение Тогда
			УстановитьПризнакСодержитЗначение(ТабличныйДокумент);
		КонецЕсли; 
	ИначеЕсли ирОбщий.СтрокиРавныЛкс(Файл.Расширение, ".xlsx") Тогда
		ТипФайла = ТипФайлаТабличногоДокумента.XLSX;
		Если УстанавливатьПризнакСодержитЗначение Тогда
			УстановитьПризнакСодержитЗначение(ТабличныйДокумент);
		КонецЕсли; 
	ИначеЕсли ирОбщий.СтрокиРавныЛкс(Файл.Расширение, ".ods") Тогда
		ТипФайла = ТипФайлаТабличногоДокумента.ODS;
	ИначеЕсли ирОбщий.СтрокиРавныЛкс(Файл.Расширение, ".txt") Тогда
		ТипФайла = ТипФайлаТабличногоДокумента.TXT;
	КонецЕсли; 
	Попытка
		ТабличныйДокумент.Записать(выхПолноеИмяФайла, ТипФайла);
	Исключение
		ирОбщий.СообщитьЛкс(ОписаниеОшибки());
		Возврат Ложь;
	КонецПопытки;
	Если Не СразуОткрыть И Не ирОбщий.СтрокиРавныЛкс(Файл.Расширение, ".mxl") Тогда
		Ответ = Вопрос("Хотите сразу открыть сохраненный файл в сопоставленном приложении?", РежимДиалогаВопрос.ДаНет, , КодВозвратаДиалога.Да);
		СразуОткрыть = Ответ = КодВозвратаДиалога.Да;
	КонецЕсли; 
	Если СразуОткрыть Тогда
		ЗапуститьПриложение(выхПолноеИмяФайла);
	КонецЕсли; 
	Возврат Истина;

КонецФункции

Процедура УстановитьПризнакСодержитЗначение(ТабличныйДокумент)
	
	#Если Сервер И Не Сервер Тогда
	    ТабличныйДокумент = Новый ТабличныйДокумент;
	#КонецЕсли
	// Проставим свойство СодержитЗначение, чтобы при открытии в EXCEL в строках типа "000534235" не устанавливался формат "Почтовый" 
	// и не пропадали лидирующие нули при входе в режим редактирования ячейки
	Для ТекущаяКолонка = 1 По ТабличныйДокумент.ШиринаТаблицы Цикл
		Для ТекущаяСтрока = 1 По ТабличныйДокумент.ВысотаТаблицы Цикл
			ОбластьЯчейки = ТабличныйДокумент.Область(ТекущаяСтрока, ТекущаяКолонка);
			ОбластьЯчейки.СодержитЗначение = Истина;
		КонецЦикла;
	КонецЦикла;

КонецПроцедуры

Функция ПодтверждениеОперацииСУБДЛкс() Экспорт 
	
	Если ирОбщий.ПолучитьСоединениеСУБД() = Неопределено Тогда 
		Возврат Ложь;
	КонецЕсли; 
	ИмяБД = ирОбщий.ПараметрыСоединенияADOЭтойБДЛкс().ИмяБД;
	Возврат Вопрос("Вы осознаете риски и ответственность за использование прямого доступа к данным базы """ + ИмяБД + """ и нарушение лицензионного соглашения 1С?", РежимДиалогаВопрос.ДаНет) = КодВозвратаДиалога.Да;

КонецФункции

// РежимИмяСиноним - Булево - Истина - Имя
Процедура НастроитьАвтоТабличноеПолеДинамическогоСпискаЛкс(ОсновнойЭУ, РежимИмяСиноним = Ложь, РазрешитьСортировку = Истина) Экспорт
	
	#Если Сервер И Не Сервер Тогда
		ОсновнойЭУ = Новый ТабличноеПоле;
	#КонецЕсли
	ПредельноеЧислоВидимыхКолонок = ирОбщий.ПредельноеЧислоВидимыхКолонокДинамСпискаЛкс();
	// Антибаг платформы 8.2-8.3 для регистра бухгалтерии https://partners.v8.1c.ru/forum/t/1372055/m/1372055
	ДинамическийСписок = ирОбщий.ДанныеЭлементаФормыЛкс(ОсновнойЭУ);
	ОбъектМД = Метаданные.НайтиПоТипу(ТипЗнч(ДинамическийСписок));
	ПолноеИмяМД = ОбъектМД.ПолноеИмя();
	ПолноеИмяТаблицы = ирКэш.ИмяТаблицыИзМетаданныхЛкс(ПолноеИмяМД);
	ТипТаблицы = ирОбщий.ТипТаблицыБДЛкс(ПолноеИмяТаблицы);
	КорневойТип = ирОбщий.ПервыйФрагментЛкс(ПолноеИмяМД);
	КорневойТип = ирОбщий.ПеревестиВРусский(КорневойТип);
	СтруктураХраненияТаблицы = ирОбщий.СтруктураХраненияОсновнойТаблицыМДЛкс(ПолноеИмяМД);
	ИмяПроведен = ирОбщий.ПеревестиСтроку("Проведен");
	ИмяСсылка = ирОбщий.ПеревестиСтроку("Ссылка");
	ИмяАктивность = ирОбщий.ПеревестиСтроку("Активность");
	ИмяПометкаУдаления = ирОбщий.ПеревестиСтроку("ПометкаУдаления");
	ИмяПредопределенный = ирОбщий.ПеревестиСтроку("Предопределенный");
	ИмяКартинка = ирОбщий.ПеревестиСтроку("Картинка");
	ВерсияПлатформы = ирКэш.НомерВерсииПлатформыЛкс();
	Если КорневойТип <> "РегистрБухгалтерии" Тогда 
		ОсновнойЭУ.СоздатьКолонки();
	КонецЕсли; 
	Попытка
		КолонкиСписка = ОсновнойЭУ.Значение.Колонки;
	Исключение
		// Перечисление
	КонецПопытки; 
	КолонкиТП = ОсновнойЭУ.Колонки;
	КолонкаТП = КолонкиТП.Найти(ИмяКартинка);
	
	// Антибаг платформы. Почему то платформа локализует имя этой колонки "Картинка" в зависимости от кода языка интерфейса.
	Если КолонкаТП = Неопределено Тогда
		КолонкаТП = КолонкиТП.Найти("Picture"); 
	КонецЕсли; 
	Если КолонкаТП = Неопределено Тогда
		КолонкаТП = КолонкиТП.Найти("Картинка");
	КонецЕсли; 
	
	Если КолонкаТП = Неопределено Тогда
		КолонкаКартинки = КолонкиТП.Добавить(ИмяКартинка);
		КолонкаКартинки.ОтображатьСтандартнуюКартинку = Истина;
		КолонкаКартинки.Ширина = ирОбщий.МинимальнаяШиринаКолонкиЛкс();
		КолонкаКартинки.ИзменениеРазмера = ИзменениеРазмераКолонки.НеИзменять;
		КолонкаКартинки.ТекстШапки = "";
	КонецЕсли;
	Попытка
		НастройкаПорядка = ОсновнойЭУ.НастройкаПорядка;
	Исключение
		НастройкаПорядка = Неопределено;
	КонецПопытки;
	МинимальнаяШиринаКолонки = ирОбщий.МинимальнаяШиринаКолонкиЛкс();
	ЧислоВидимыхКолонок = 0;
	Если КолонкиСписка <> Неопределено Тогда
		ПоляТаблицы = ирКэш.ПоляТаблицыБДЛкс(ПолноеИмяТаблицы);
		// Здесь добавляется колонка "Предопределенный", т.к. в отборе она отсутствует
		Для Каждого КолонкаСписка Из ОсновнойЭУ.Значение.Колонки Цикл
			КолонкаТП = КолонкиТП.Найти(КолонкаСписка.Имя);
			Если КолонкаТП = Неопределено Тогда
				КолонкаТП = КолонкиТП.Добавить(КолонкаСписка.Имя);
				Попытка
					КолонкаТП.Данные = КолонкаСписка.Имя;
				Исключение
					// Например поле "Ссылка" почему то является недопустимым
					КолонкиТП.Удалить(КолонкаТП);
					Продолжить;
				КонецПопытки;
			КонецЕсли; 
			КолонкаТП.ТекстШапки = КолонкаСписка.Имя; 
			ЭлементОтбора = ОсновнойЭУ.Значение.Отбор.Найти(КолонкаСписка.Имя);
			Если Истина
				И КолонкаСписка.Имя = ИмяПредопределенный 
				И ЭлементОтбора = Неопределено
			Тогда
				КолонкаТП.КартинкаШапки = ирКэш.КартинкаПоИмениЛкс("ирПредопределенный");
				НастроитьКолонкуКартинкиЛкс(КолонкаТП);
			КонецЕсли; 
			Если ЭлементОтбора <> Неопределено И ирОбщий.ЛиОписаниеТиповБулевоЛкс(ЭлементОтбора.ТипЗначения) Тогда // https://www.hostedredmine.com/issues/905911
				Если КолонкаСписка.Имя = ИмяПометкаУдаления Тогда
					КолонкаТП.КартинкаШапки = ирКэш.КартинкаПоИмениЛкс("ПометитьНаУдаление");
					НастроитьКолонкуКартинкиЛкс(КолонкаТП);
				КонецЕсли; 
				Если КолонкаСписка.Имя = ИмяПроведен Тогда
					КолонкаТП.КартинкаШапки = ирКэш.КартинкаПоИмениЛкс("Провести");
					НастроитьКолонкуКартинкиЛкс(КолонкаТП);
				КонецЕсли; 
				Если КолонкаСписка.Имя = ИмяАктивность Тогда
					КолонкаТП.КартинкаШапки = ирКэш.КартинкаПоИмениЛкс("ПереключитьАктивность");
					НастроитьКолонкуКартинкиЛкс(КолонкаТП);
				КонецЕсли; 
			КонецЕсли; 
			ПолеТаблицы = ПоляТаблицы.Найти(КолонкаСписка.Имя, "Имя");
			#Если Сервер И Не Сервер Тогда
				ПолеТаблицы = Обработки.ирТипПолеБД.Создать();
			#КонецЕсли
			Если Истина
				И ПолеТаблицы <> Неопределено
				И ПолеТаблицы.ТипЗначения.СодержитТип(Тип("ХранилищеЗначения"))
			Тогда
				КолонкаТП.Видимость = Ложь;
			КонецЕсли;
		КонецЦикла;
	КонецЕсли;
	Попытка
		ЛиРедактированиеВСписке = ОсновнойЭУ.СпособРедактирования = СпособРедактированияСписка.ВСписке;
	Исключение
		ЛиРедактированиеВСписке = Ложь;
	КонецПопытки;
	Для Каждого ЭлементОтбора Из ОсновнойЭУ.Значение.Отбор Цикл
		#Если Сервер И Не Сервер Тогда
			ЭлементОтбора = Новый ПостроительЗапроса;
			ЭлементОтбора = ЭлементОтбора.Отбор.Добавить();
		#КонецЕсли
		// Антибаг 8.2.15 http://partners.v8.1c.ru/forum/thread.jsp?id=1002521#1002521
		Если Истина
			И ирОбщий.ЛиКорневойТипРегистраБухгалтерииЛкс(КорневойТип)
			И (Ложь
				Или Найти(ЭлементОтбора.Имя, "ВидСубконтоДт") = 1
				Или Найти(ЭлементОтбора.Имя, "ВидСубконтоКт") = 1)
		Тогда
			Продолжить;
		КонецЕсли; 
		Если Истина
			И ирОбщий.ЛиКорневойТипСсылкиЛкс(КорневойТип)
			И ЭлементОтбора.Имя = ИмяСсылка
		Тогда
			// Добавить для него колонку можно, но платформа не будет выводить в нее данные и потому она будет просто занимать площадь
			Продолжить;
		КонецЕсли;
		АвтоудалениеКолонки = ирОбщий.ЛиОписаниеТиповНеограниченнойСтрокиЛкс(ЭлементОтбора.ТипЗначения);
		Если КолонкиСписка <> Неопределено Тогда
			Попытка
				КолонкиСписка.Добавить(ЭлементОтбора.Имя, АвтоудалениеКолонки);
			Исключение
				// Сюда попадает например элемент отбора от критерия отбора
				ОписаниеОшибки = ОписаниеОшибки(); // Для отладки
				Продолжить;
			КонецПопытки; 
		КонецЕсли; 
		КолонкаТП = КолонкиТП.Найти(ЭлементОтбора.Имя);
		Если КолонкаТП = Неопределено Тогда
			КолонкаТП = КолонкиТП.Добавить();
		КонецЕсли;
		ДанныеПодключены = Истина;
		//Колонка.ТекстШапки = ЭлементОтбора.Представление;
		Если КорневойТип <> "Перечисление" Тогда
			Если ЛиРедактированиеВСписке Тогда
				КолонкаТП.УстановитьЭлементУправления(Тип("ПолеВвода"));
			КонецЕсли;
			ДанныеПодключены = Ложь;
			Попытка
				КолонкаТП.Данные = ЭлементОтбора.Имя;
				ДанныеПодключены = Истина;
			Исключение
				// Например поле "Ссылка" почему то является недопустимым
				ОписаниеОшибки = ОписаниеОшибки(); // Для отладки
			КонецПопытки;
		КонецЕсли;
		Если Ложь 
			Или Не ДанныеПодключены
			Или АвтоудалениеКолонки
			Или ЧислоВидимыхКолонок > ПредельноеЧислоВидимыхКолонок 
		Тогда
			КолонкаТП.Видимость = Ложь;
		Иначе
			ЧислоВидимыхКолонок = ЧислоВидимыхКолонок + 1;
		КонецЕсли;
		КолонкаТП.Имя = ЭлементОтбора.Имя;
		//Если КолонкаТП.Ширина = -1 Тогда
			КолонкаТП.Ширина = ирОбщий.ШиринаОписанияТиповЛкс(ЭлементОтбора.ТипЗначения);
		//КонецЕсли;
		Если Истина
			И ЭлементОтбора.ТипЗначения.СодержитТип(Тип("Дата")) 
			И ЭлементОтбора.ТипЗначения.Типы().Количество() = 1 
		Тогда
			КолонкаТП.ИзменениеРазмера = ИзменениеРазмераКолонки.НеИзменять;
		КонецЕсли;
		
		// Антибаг платформы 8.2-8.3.6 https://partners.v8.1c.ru/forum/t/1337995/m/1337995
		Если Истина
			И ВерсияПлатформы < 803008
			И ЭлементОтбора.ТипЗначения.СодержитТип(Тип("УникальныйИдентификатор")) 
		Тогда
			ирОбщий.СообщитьЛкс(ирОбщий.СтрШаблонИменЛкс("Колонка %1 типа УникальныйИдентификатор не будет отображаться из-за ошибки платформы",, ЭлементОтбора.Имя));
			КолонкиТП.Удалить(КолонкаТП);
			Продолжить;
		КонецЕсли; 
		Если РазрешитьСортировку И НастройкаПорядка <> Неопределено Тогда
			ЭлементУправленияПорядком = НастройкаПорядка.Найти(ЭлементОтбора.Имя);
			Если ЭлементУправленияПорядком <> Неопределено Тогда
				ЭлементУправленияПорядком.Доступность = Истина;
			КонецЕсли; 
		КонецЕсли;
	КонецЦикла;
	Если КолонкиСписка <> Неопределено Тогда
		Для Каждого ЭлементНастройкиОтбора Из ОсновнойЭУ.НастройкаОтбора Цикл
			ЭлементНастройкиОтбора.Доступность = Истина;
		КонецЦикла;
		ПостроительПорядка = ирОбщий.ОсновнойПорядокТаблицыБДЛкс(ПолноеИмяТаблицы, ирОбщий.ПорядокВСтрокуЛкс(ДинамическийСписок.Порядок), ОсновнойЭУ.НастройкаПорядка, СтруктураХраненияТаблицы);
		НовыйПорядок = ирОбщий.ПорядокВСтрокуЛкс(ПостроительПорядка.Порядок);
		Если ЗначениеЗаполнено(НовыйПорядок) Тогда
			// Обязательную установку делаем, чтобы в шапках появились индикаторы сортировки (антибаг платформы)
			ДинамическийСписок.Порядок.Установить(НовыйПорядок);
		КонецЕсли;
	КонецЕсли; 
	Если ирОбщий.ЛиКорневойТипСсылкиЛкс(КорневойТип) Тогда
		КолонкаИдентификатора = КолонкиТП.Добавить("ИдентификаторСсылкиЛкс");
		КолонкаИдентификатора.ТекстШапки = "Идентификатор ссылки";
	КонецЕсли; 
	Если ирОбщий.ЛиКорневойТипОбъектаСПредопределеннымЛкс(КорневойТип) Тогда
		КолонкаИдентификатора = КолонкиТП.Добавить("ИмяПредопределенныхДанных");
		КолонкаИдентификатора.ТекстШапки = "Имя предопределенных данных";
		КолонкаИдентификатора.Видимость = Ложь;
	КонецЕсли; 
	НастроитьЗаголовкиАвтоТабличногоПоляДинамическогоСпискаЛкс(ОсновнойЭУ, РежимИмяСиноним);
	
КонецПроцедуры

Процедура НастроитьКолонкуКартинкиЛкс(Знач КолонкаКартинки) Экспорт 
	
	КолонкаКартинки.ТолькоПросмотр = Истина;
	КолонкаКартинки.Видимость = Истина;
	КолонкаКартинки.Ширина = 4; 
	КолонкаКартинки.ИзменениеРазмера = ИзменениеРазмераКолонки.НеИзменять;
	КолонкаКартинки.ЦветТекстаШапки = ЦветаСтиля.ЦветФонаКнопки;

КонецПроцедуры

Процедура НастроитьЗаголовкиАвтоТабличногоПоляДинамическогоСпискаЛкс(Знач ОсновнойЭУ, Знач РежимИмяСиноним) Экспорт 
	
	ОбъектМД = Метаданные.НайтиПоТипу(ТипЗнч(ОсновнойЭУ.Значение));
	ПоляТаблицы = ирОбщий.ПоляТаблицыМДЛкс(ОбъектМД.ПолноеИмя());
	Для Каждого ПолеТаблицы Из ПоляТаблицы Цикл
		#Если Сервер И Не Сервер Тогда
			ПолеТаблицы = Обработки.ирТипПолеБД.Создать();
		#КонецЕсли
		КолонкаТП = ОсновнойЭУ.Колонки.Найти(ПолеТаблицы.Имя);
		Если КолонкаТП = Неопределено Тогда
			Продолжить;
		КонецЕсли; 
		Попытка
			Подсказка = ПолеТаблицы.Метаданные.Подсказка;
		Исключение
			Подсказка = "";
		КонецПопытки;
		Если РежимИмяСиноним Тогда
			Заголовок = ПолеТаблицы.Имя;
		Иначе
			Заголовок = ПолеТаблицы.Заголовок;
		КонецЕсли;
		КолонкаТП.ТекстШапки = Заголовок;
		КолонкаТП.ПодсказкаВШапке = Подсказка;
		ирОбщий.ДобавитьОписаниеТиповВПодсказкуШапкиКолонкиЛкс(КолонкаТП, ПолеТаблицы.ТипЗначения, ПолеТаблицы.Метаданные,, ПолеТаблицы.Имя);
		Если ирОбщий.ЛиОписаниеТиповБулевоЛкс(ПолеТаблицы.ТипЗначения) Тогда
			КолонкаТП.ДанныеФлажка = "";
			КолонкаТП.КартинкиСтрок = ирКэш.КартинкаПоИмениЛкс("ирСостоянияФлажка");
		КонецЕсли;
	КонецЦикла;

КонецПроцедуры

Процедура Форма_ОбработкаОповещенияЛкс(ЭтаФорма, ИмяСобытия, Параметр, Источник) Экспорт 

	Если ИмяСобытия = "ЗакрытьВсеФормыИнструментовРазработчика" Тогда
		Если ЭтаФорма.Открыта() Тогда
			ЭтаФорма.Закрыть();
			Если ЭтаФорма.Открыта() Тогда
				Параметр.Отказ = Истина;
			КонецЕсли; 
		КонецЕсли; 
	ИначеЕсли ИмяСобытия = "ЕстьОткрытыеФормыИнструментовРазработчика" Тогда
		Если ЭтаФорма.Открыта() Тогда
			Параметр.Ответ = Истина;
		КонецЕсли; 
	ИначеЕсли ИмяСобытия = "ОбнаружитьСебя" Тогда
		ИмяФормы = ирОбщий.ПолноеИмяФормыЛкс(ЭтаФорма);
		Если Не ЗначениеЗаполнено(ИмяФормы) Тогда
			Попытка
				ИмяФормы = ЭтаФорма.ЭтотОбъект.Метаданные().ПолноеИмя();
			Исключение
			КонецПопытки; 
		КонецЕсли; 
		Если Не ЗначениеЗаполнено(ИмяФормы) Тогда
			ИмяФормы = "Неизвестная форма";
		КонецЕсли; 
		ирОбщий.СообщитьЛкс(ИмяФормы);
	ИначеЕсли ИмяСобытия = "ОбнаружитьАктивную" Тогда
		Если Форма_ВводДоступенЛкс(ЭтаФорма) Тогда
			Параметр.Результат = ЭтаФорма;
		КонецЕсли; 
	КонецЕсли; 

КонецПроцедуры

// Умеет определять активную форму инструментов и управляемую форму в управляемом приложении
Функция АктивнаяФормаЛкс() Экспорт 
	
	Результат = АктивнаяУправляемаяФормаЛкс();
	Если Результат = Неопределено Тогда
		Структура = Новый Структура("Результат");
		Структура.Вставить("ПроверятьПолеHTML", Ложь);
		ОповеститьФормыПодсистемыЛкс("ОбнаружитьАктивную", Структура);
		Если Структура.Результат = Неопределено Тогда
			Структура.Вставить("ПроверятьПолеHTML", Истина);
			ОповеститьФормыПодсистемыЛкс("ОбнаружитьАктивную", Структура);
		КонецЕсли; 
		Результат = Структура.Результат;
	КонецЕсли; 
	Возврат Результат;
	
КонецФункции

Процедура ОткрытьФайлСПредупреждениемЛкс(ИмяФайла, СтандартнаяОбработка = Неопределено) Экспорт
	
	СтандартнаяОбработка = Ложь;
	Ответ = Вопрос("Вы уверены, что хотите открыть """ + ИмяФайла + """?", РежимДиалогаВопрос.ОКОтмена);
	Если Ответ = КодВозвратаДиалога.ОК Тогда
		ЗапуститьПриложение(ИмяФайла);
	КонецЕсли;

КонецПроцедуры

// Создает новый экземпляр обработки и открывает его форму.
//
// Параметры:
//  Объект - ОбработкаОбъект, ОтчетОбъект.
//
// Возвращаемое значение:
//  Форма.
//
Функция ОткрытьНовоеОкноФормыЛкс(ЭтотОбъект) Экспорт 
	
	Если Ложь
		Или ТипЗнч(ЭтотОбъект) = Тип("Форма") 
		Или ТипЗнч(ЭтотОбъект) = Тип("УправляемаяФорма") 
	Тогда
		СлужебныеДанныеФормы = ирОбщий.СлужебныеДанныеФормыЛкс(ЭтотОбъект);
		Если СлужебныеДанныеФормы.Свойство("МенеджерСохраненияНастроек") Тогда
			СохранитьНастройкуФормыЛкс(ЭтотОбъект);
		КонецЕсли;
		Результат = ПолучитьФормуЛкс(ирОбщий.ПолноеИмяФормыЛкс(ЭтотОбъект),,, Новый УникальныйИдентификатор);
	Иначе
		Если Не ирКэш.ЛиПортативныйРежимЛкс() Тогда
			НовыйОбъект = ирОбщий.ПолучитьМенеджерЛкс(ЭтотОбъект).Создать();
		Иначе
			ПолноеИмяОбъекта = ЭтотОбъект.Метаданные().ПолноеИмя();
			НовыйОбъект = ирОбщий.СоздатьОбъектПоИмениМетаданныхЛкс(ПолноеИмяОбъекта);
		КонецЕсли; 
		Результат = НовыйОбъект.ПолучитьФорму();
	КонецЕсли; 
	Результат.Открыть();
	Возврат Результат;
	
КонецФункции

Функция ПолучитьФормуЛкс(ПолноеИмяФормы, Параметры = Неопределено, Владелец = Неопределено, Уникальность = Неопределено, Окно = Неопределено, ТолькоВнешниеФормы = Ложь) Экспорт
	
	ПроверитьФормыСсылокЛкс();
	Фрагменты = ирОбщий.СтрРазделитьЛкс(ПолноеИмяФормы);
	#Если Сервер И Не Сервер Тогда
		Фрагменты = Новый Массив;
	#КонецЕсли
	Если Истина
		И Фрагменты.Количество() = 4
		И ирОбщий.СтрокиРавныЛкс(Фрагменты[2], "Форма")
	Тогда
		ИмяФормы = Фрагменты[3];
	Иначе
		ИмяФормы = Неопределено;
	КонецЕсли;
	Если Не ирКэш.ЛиПортативныйРежимЛкс() Тогда
		//ирПортативный #Если Сервер И Не Сервер Тогда
			// Такой прием нужен для обхода ошибка компиляции в портативном режиме
			#Если Сервер И Не Сервер Тогда
				Фрагменты = Новый Массив;
			#КонецЕсли
			// http://www.hostedredmine.com/issues/883626
			Если Истина
				И (Фрагменты[0] = "Обработка" Или Фрагменты[0] = "Отчет")
				И Фрагменты.Количество() > 2
				И Найти(Фрагменты[1], "ир") = 1 
				И Фрагменты[1] <> Метаданные.Обработки.ирДинамическийСписок.Имя 
			Тогда
				Если Не ТолькоВнешниеФормы Тогда
					ОбъектМД = ирКэш.ОбъектМДПоПолномуИмениЛкс(Фрагменты[0] + "." + Фрагменты[1]);
					#Если Сервер И Не Сервер Тогда
						ОбъектМД = Метаданные.Обработки.ирАнализДанных;
					#КонецЕсли
				КонецЕсли;
				Если ОбъектМД = Неопределено Тогда
					ВызватьИсключение "Не найден объект метаданных " + ПолноеИмяФормы;
				КонецЕсли; 
				Если ОбъектМД = Метаданные.Обработки.ирПлатформа Тогда 
					Менеджер = ирКэш.Получить(); // Так управляемые формы нельзя получать
				Иначе
					Менеджер = Новый (ирОбщий.ПеревестиСтроку(Фрагменты[0]) + ирОбщий.ПеревестиСтроку("Менеджер") + "." + Фрагменты[1]);
				КонецЕсли;
				Если Не ЗначениеЗаполнено(ИмяФормы) И ОбъектМД.ОсновнаяФорма <> Неопределено Тогда 
					// Нужно для отчетов. Иначе будет ошибка "неизвестный идентификатор формы" 
					ИмяФормы = ОбъектМД.ОсновнаяФорма.Имя;
				КонецЕсли;
				Результат = Менеджер.ПолучитьФорму(ИмяФормы, Владелец, Уникальность);
			КонецЕсли; 
			Если Результат = Неопределено Тогда
				// Форма не инструмента или управляемая форма инструмента или форма отчета подсистемы при запрещенном использовании обычных форм
				Результат = ПолучитьФорму(ПолноеИмяФормы, Параметры, Владелец, Уникальность, Окно);
			КонецЕсли; 
			//Если Найти(ПолноеИмяФормы, "Обработка.ирПлатформа.") = 1 Тогда
			//	Попытка
			//		ЭтоЗапрещено = Результат.ЭтотОбъект.Метаданные().ПолноеИмя() = ирОбщий.ПеревестиСтроку("Обработка") + ".ирПлатформа";
			//	Исключение
			//		ЭтоЗапрещено = Ложь;
			//	КонецПопытки; 
			//	Если ЭтоЗапрещено Тогда
			//		ирОбщий.СообщитьЛкс("Создан лишний экземпляр обработки ирПлатформа");
			//	КонецЕсли; 
			//КонецЕсли; 
		//ирПортативный #КонецЕсли
	Иначе
		Если Не ТолькоВнешниеФормы Тогда
			ОбъектМД = ирКэш.ОбъектМДПоПолномуИмениЛкс(Фрагменты[0] + "." + Фрагменты[1]);
		КонецЕсли;
		Если ОбъектМД = Неопределено Тогда
			Если Фрагменты[1] = "ирПортативный" Тогда
				Результат = ирПортативный.ПолучитьФорму(ИмяФормы, Владелец, Уникальность);
			Иначе
				ТипМетаданных = Фрагменты[0];
				Менеджер = ирПортативный.ПолучитьМенеджерТипаМетаданныхЛкс(ТипМетаданных);
				ПолноеИмяФайла = ирПортативный.ПолноеИмяФайлаПортативногоОбъектаМетаданныхЛкс(Фрагменты[1], ТипМетаданных);
				Результат = Менеджер.ПолучитьФорму(ПолноеИмяФайла, ИмяФормы, Владелец, Уникальность);
			КонецЕсли; 
		Иначе
			Результат = ирПортативный.ПолучитьФормуЛкс(ПолноеИмяФормы, Параметры, Владелец, Уникальность, Окно);
		КонецЕсли; 
	КонецЕсли;
	Если Результат <> Неопределено Тогда
		НачатьОтслеживаниеФормыЛкс(Результат);
	КонецЕсли;
	Возврат Результат;
	
КонецФункции

Функция ПараметрыБыстрогоСозданияФормыЛкс() Экспорт 
	
	Возврат Новый Структура("АвтоТест");

КонецФункции

Функция ОписаниеОповещенияЛкс(ИмяМетода, Модуль) Экспорт 
	ОписаниеОповещения = Вычислить("Новый ОписаниеОповещения(ИмяМетода, Модуль)"); // В 8.2 нет типа ОписаниеОповещения
	Возврат ОписаниеОповещения;
КонецФункции 

Процедура ЗаполнитьСписокВыбораПоляСортировкиТабличногоПоляЛкс(Знач СписокВыбора, Знач ТабличноеПоле) Экспорт 
	
	#Если Сервер И Не Сервер Тогда
		СписокВыбора = Новый СписокЗначений;
	#КонецЕсли
	СписокВыбора.Очистить();
	Для Каждого КолонкаТП Из ТабличноеПоле.Колонки Цикл
		Если Истина
			И ЗначениеЗаполнено(КолонкаТП.Данные) 
			И (КолонкаТП.Видимость Или КолонкаТП.ИзменятьВидимость)
			//И Не (КолонкаТП.ТипЗначения.СодержитТип(Тип("УникальныйИдентификатор")) И КолонкаТП.ТипЗначения.Типы() = 1)
		Тогда
			СписокВыбора.Добавить(КолонкаТП.Данные + " Убыв", КолонкаТП.ТекстШапки + " Убыв");
			СписокВыбора.Добавить(КолонкаТП.Данные + " Возр", КолонкаТП.ТекстШапки + " Возр");
		КонецЕсли; 
	КонецЦикла;
	СписокВыбора.СортироватьПоПредставлению();

КонецПроцедуры

Функция ПолучитьСхемуКолонокМакетаКомпоновкиДанныхЛкс(МакетКомпоновки) Экспорт
	
	#Если Сервер И Не Сервер Тогда
	    МакетКомпоновки = Новый МакетКомпоновкиДанных;
	#КонецЕсли
	СхемаКолонок = Новый Структура;
	
	// Схема колонок строится негарантировано, т.к. платформа не предоставляет нужных данных
	ОписанияМакетовОбластей = МакетКомпоновки.Макеты;
	Если ОписанияМакетовОбластей.Количество() > 0 Тогда
		ЯчейкиЗаголовка = ОписанияМакетовОбластей[0].Макет.Ячейки;
		Если ЯчейкиЗаголовка <> Неопределено Тогда
			КоличествоЯчеекЗаголовка = ЯчейкиЗаголовка.Количество();
			Для Индекс = 0 По КоличествоЯчеекЗаголовка - 1 Цикл
				Для Каждого ОписаниеМакетаОбласти Из ОписанияМакетовОбластей Цикл
					// Здесь подсказка криво работает из-за кривого синтакс-помощника 8.2.13.205
					// http://partners.v8.1c.ru/forum/thread.jsp?id=898023#898023
					ЯчейкаМакетаОбласти = ОписаниеМакетаОбласти.Макет.Ячейки[Индекс];
					Если ТипЗнч(ЯчейкаМакетаОбласти) <> Тип("ЯчейкаМакетаКоллекцииЗначенийОбластиКомпоновкиДанных") Тогда
						Продолжить;
					КонецЕсли;
					ПараметрЯчейки = ЯчейкаМакетаОбласти.Значение;
					Если ПараметрЯчейки = Неопределено Тогда
						Продолжить;
					КонецЕсли;
					Выражение = ОписаниеМакетаОбласти.Параметры["" + ПараметрЯчейки].Выражение;
					ПозицияТочки = Найти(Выражение, ".");
					Если Ложь
						Или ПозицияТочки = 0
						Или Найти(Выражение, " ") > 0
						Или Найти(Выражение, "(") > 0
					Тогда
						//ИмяПоля = "";
						Продолжить;
					Иначе
						ИмяПоля = Сред(Выражение, ПозицияТочки + 1);
					КонецЕсли;
					СхемаКолонок.Вставить(ЯчейкиЗаголовка[Индекс].Имя, ИмяПоля);
					Прервать;
				КонецЦикла;
			КонецЦикла;
		КонецЕсли;
	КонецЕсли;
	Возврат СхемаКолонок;

КонецФункции

// Параметры:
//   Значение - 
//   ОчиститьПередУстановкой - Булево
//   УстановитьТекст - Булево
//   УстановитьЗначение - Булево
//
Функция БуферОбменаПриложения_УстановитьЗначениеЛкс(Знач Значение, Знач УстановитьПредставление = Истина) Экспорт
	
	Если ТипЗнч(Значение) = Тип("Строка") Тогда
		Значение = Неопределено;
	КонецЕсли;
	//ФорматБуфераОбмена1С = ирКэш.ФорматБуфераОбмена1СЛкс(); 
	Если ирОбщий.ЛиСсылкаНаОбъектБДЛкс(Значение) Тогда
		ДобавитьСсылкуВИсториюРаботыЛкс(Значение);
	КонецЕсли;
	Если ирОбщий.ЛиСсылкаНаОбъектБДЛкс(Значение) Тогда
		ДобавитьОбъектВБуферСравненияЛкс(Значение);
	КонецЕсли;
	Если УстановитьПредставление Тогда
		ЗначениеПредставление = "" + Значение;
		ТекстВБуферОбменаОСЛкс(ЗначениеПредставление, "");
	Иначе
		ЗначениеПредставление = ТекстИзБуфераОбменаОСЛкс(); // Для последующео контроля согласованности буфера обмена приложения с буфером обмена ОС;
	КонецЕсли;
	БуферОбменаПриложения = БуферОбменаПриложенияЛкс();
	БуферОбменаПриложения.Значение = Неопределено;
	//БуферОбменаПриложения.ЗначениеСтрока = ирОбщий.ОбъектВСтрокуXMLЛкс(Значение,,, Ложь);
	БуферОбменаПриложения.ЗначениеСтрока = ЗначениеВСтрокуВнутр(Значение);
	БуферОбменаПриложения.ЗначениеПредставление = ЗначениеПредставление;
	
КонецФункции

Функция БуферОбменаПриложения_ЗначениеЛкс(ТекстИзБуфераОбменаОС = "") Экспорт 
	
	//ФорматБуфераОбмена1С = ирКэш.ФорматБуфераОбмена1СЛкс();
	Если Не ЗначениеЗаполнено(ТекстИзБуфераОбменаОС) Тогда
		ТекстИзБуфераОбменаОС = ТекстИзБуфераОбменаОСЛкс();
	КонецЕсли;
	БуферОбменаПриложения = БуферОбменаПриложенияЛкс();
	Если БуферОбменаПриложения.ЗначениеПредставление <> ТекстИзБуфераОбменаОС Тогда 
		// буфера обмена приложения не согласован с буфером обмена ОС
		БуферОбменаПриложения.Значение = Неопределено;
		БуферОбменаПриложения.ЗначениеСтрока = "";
		БуферОбменаПриложения.ЗначениеПредставление = "";
		Возврат Неопределено;
	Иначе
		Результат = БуферОбменаПриложения.Значение;
		Если Истина
			И Результат = Неопределено 
			И ЗначениеЗаполнено(БуферОбменаПриложения.ЗначениеСтрока) 
		Тогда
			//Результат = ирОбщий.ОбъектИзСтрокиXMLЛкс(БуферОбменаПриложения.ЗначениеСтрока,,, Ложь);
			Результат = ирОбщий.ЗначениеИзСтрокиВнутрЛкс(БуферОбменаПриложения.ЗначениеСтрока);
			БуферОбменаПриложения.ЗначениеСтрока = "";
			БуферОбменаПриложения.Значение = Результат;
		КонецЕсли;
	КонецЕсли;
	Возврат Результат;
	
КонецФункции

Функция БуферОбменаПриложенияЛкс() 
	
	ВнутреннийБуферОбмена = ирКэш.Получить().ВнутреннийБуферОбмена;
	Если ВнутреннийБуферОбмена = Неопределено Тогда
		ВнутреннийБуферОбмена = Новый Структура("Значение, ЗначениеСтрока, ЗначениеПредставление");
		ирКэш.Получить().ВнутреннийБуферОбмена = ВнутреннийБуферОбмена;
	КонецЕсли; 
	Возврат ВнутреннийБуферОбмена;
	
КонецФункции

Функция ЗначениеИзБуфераОбменаЛкс(РазрешитьСтандартноеЗначение = Ложь) Экспорт 
	
	ТекстИзБуфераОбменаОС = ТекстИзБуфераОбменаОСЛкс();
	ЗначениеСсылки = ирОбщий.НавигационнаяСсылкаВЗначениеЛкс(ТекстИзБуфераОбменаОС);
	Если ЗначениеСсылки = Неопределено Тогда
		ЗначениеСсылки = БуферОбменаПриложения_ЗначениеЛкс(ТекстИзБуфераОбменаОС);
	КонецЕсли; 
	Если ЗначениеСсылки = Неопределено И РазрешитьСтандартноеЗначение Тогда
		ЗначениеСсылки = ТекстИзБуфераОбменаОС;
	КонецЕсли;
	Возврат ЗначениеСсылки;

КонецФункции

// .
// Параметры:
//   ПолеВвода - ПолеВвода
//   Значение - 
//   Текст - Строка(0,П)
//
Функция ВставитьЗначениеВПолеВводаЛкс(Знач ПолеВвода, Знач НовоеЗначение) Экспорт
	
	Результат = Ложь;
	Если Истина
		И НовоеЗначение <> Неопределено 
		И Не ПолеВвода.ТолькоПросмотр
	Тогда
		ТипНовогоЗначения = ТипЗнч(НовоеЗначение);
		ТекущееЗначение = ирОбщий.ДанныеЭлементаФормыЛкс(ПолеВвода);
		Если Ложь
			Или ТипЗнч(ТекущееЗначение) = ТипНовогоЗначения 
			Или ПолеВвода.ОграничениеТипа.Типы().Количество() = 0
			Или ПолеВвода.ОграничениеТипа.СодержитТип(ТипНовогоЗначения)
		Тогда
			Результат = ИнтерактивноЗаписатьВПолеВводаЛкс(ПолеВвода, НовоеЗначение,, Истина);
		КонецЕсли;
	КонецЕсли;
	Возврат Результат;
	
КонецФункции

// .
// Параметры:
//   ЭтаФорма - Форма - для управляемой формы можно не передавать, она определится автоматически
//
Функция БуферОбмена_ВставитьЛкс(Знач ЭтаФорма = Неопределено, Знач ЛиОсновнаяВставка = Истина) Экспорт
	
	Если ЭтаФорма = Неопределено Тогда
		ЭтаФорма = АктивнаяУправляемаяФормаЛкс();
	КонецЕсли; 
	Если ЭтаФорма = Неопределено Тогда
		Возврат Неопределено;
	КонецЕсли; 
	Значение = ЗначениеИзБуфераОбменаЛкс(Истина);
	Если Значение = Неопределено Тогда
		Возврат Неопределено;
	КонецЕсли; 
	ВставитьЗначениеВФормуЛкс(ЭтаФорма, Значение, ЛиОсновнаяВставка);
	
КонецФункции

Процедура ВставитьЗначениеВФормуЛкс(Знач ЭтаФорма, Знач Значение, Знач ЛиОсновнаяВставка = Истина) Экспорт 
	
	#Если Сервер И Не Сервер Тогда
		ЭтаФорма = ОткрытьФорму();
	#КонецЕсли
	ТекущийЭлементФормы = ЭтаФорма.ТекущийЭлемент;
	ПродолжитьОбработку = Истина;
	ТипЗначения = ТипЗнч(Значение);
	Если ТипЗначения = Тип("СписокЗначений") Тогда 
		Значение = ирОбщий.СкопироватьУниверсальнуюКоллекциюЛкс(Значение);
	КонецЕсли;
	ПутьКДанным = ""; 
	Если Истина
		И ТипЗнч(ЭтаФорма) = Тип("УправляемаяФорма")
		И Не ЭтаФорма.ТолькоПросмотр
		И ЭтаФорма.ИмяФормы = "ValueListForm" 
		И ЭтаФорма.ValueList.ТипЗначения.СодержитТип(ТипЗнч(Значение[0].Значение))
		И (Ложь
			Или ТипЗначения = Тип("СписокЗначений") И ЭтаФорма.ValueList.ТипЗначения.СодержитТип(ТипЗнч(Значение[0].Значение))
			Или ТипЗначения = Тип("Строка") И ЭтаФорма.ValueList.ТипЗначения.СодержитТип(Тип("Строка")))
	Тогда
		Если ТипЗнч(Значение) = Тип("Строка") Тогда
			НовоеЗначение = Новый СписокЗначений;
			НовоеЗначение.ЗагрузитьЗначения(ирОбщий.СтрРазделитьЛкс(Значение, Символы.ПС, Истина));
			Значение = НовоеЗначение;
		КонецЕсли;
		#Если Сервер И Не Сервер Тогда
			Значение = Новый СписокЗначений;
		#КонецЕсли
		//ирОбщий.СкопироватьУниверсальнуюКоллекциюЛкс(Значение, ЭтаФорма.ValueList);
		//ТекущийЭлементФормы.ТекущаяСтрока = ЭтаФорма.ValueList[ЭтаФорма.ValueList.Количество() - 1].ПолучитьИдентификатор();
		ЗагружаемаяТаблица = Новый ТаблицаЗначений;
		ЗагружаемаяТаблица.Колонки.Добавить("Value");
		Для Каждого ЭлементСписка Из Значение Цикл
			СтрокаСписка = ЗагружаемаяТаблица.Добавить();
			СтрокаСписка.Value = ЭлементСписка.Значение;
		КонецЦикла;
		ЗагрузитьТаблицуВТабличноеПолеЛкс(ЭтаФорма, ТекущийЭлементФормы, ЗагружаемаяТаблица);
	ИначеЕсли Истина
		И ЛиОсновнаяВставка
		И (Ложь
			Или ТипЗнч(ТекущийЭлементФормы) = Тип("ПолеВвода")
			Или ТипЗнч(ТекущийЭлементФормы) = Тип("ПолеФормы"))
	Тогда
		Если Не ЭтаФорма.ТолькоПросмотр Тогда
			Если ТипЗначения = Тип("Массив") Тогда
				Значение = Значение[0];
			КонецЕсли;
			Если ЛиОписаниеТиповСодержитТипЛкс(ТекущийЭлементФормы.ОграничениеТипа, ТипЗнч(Значение)) Тогда 
				ПродолжитьОбработку = Не ВставитьЗначениеВПолеВводаЛкс(ТекущийЭлементФормы, Значение);
			КонецЕсли; 
			//Если ПродолжитьОбработку И ЗначениеЗаполнено(ТекущийЭлементФормы.Данные) Тогда
			//	// Например ссылка таблицы внешнего источника в поле ввода не может быть установлена через оповещение выбора
			//	Попытка
			//		ЭтаФорма[ТекущийЭлементФормы.Данные] = Значение;
			//	Исключение
			//	КонецПопытки;
			//КонецЕсли; 
		КонецЕсли;
	ИначеЕсли Ложь
		Или ТипЗнч(ТекущийЭлементФормы) = Тип("ТабличноеПоле") 
		Или ТипЗнч(ТекущийЭлементФормы) = Тип("ТаблицаФормы")
	Тогда
		ЭлементУправления = Неопределено;
		КолонкаТП = Неопределено;
		ДобавитьСтроку = Истина
			И ТекущийЭлементФормы.ТекущиеДанные = Неопределено
			И ТекущийЭлементФормы.ИзменятьСоставСтрок;
		ДоступноРедактирование = Истина;
		ИмяКолонкиДанных = ирОбщий.ПутьКДаннымКолонкиТабличногоПоляЛкс(ТекущийЭлементФормы);
		ТаблицаЗначений = ТаблицаИлиДеревоЗначенийИзТаблицыФормыСКоллекциейЛкс(ТекущийЭлементФормы, Новый Массив,,,, ИмяКолонкиДанных);
		#Если Сервер И Не Сервер Тогда
			ТаблицаЗначений = Новый ТаблицаЗначений;
		#КонецЕсли
		ДанныеПоля = ирОбщий.ДанныеЭлементаФормыЛкс(ТекущийЭлементФормы);
		Если Истина
			И ТипЗнч(ДанныеПоля) <> Тип("ОтборКомпоновкиДанных")
			И ТипЗнч(ДанныеПоля) <> Тип("Отбор") 
			И ТаблицаЗначений <> Неопределено
		Тогда 
			КолонкаДанных = ТаблицаЗначений.Колонки.Найти(ИмяКолонкиДанных);
		КонецЕсли;
		// Если табличное поле находится в режиме редактирования строки, то делаем ничего
		Если Не ДобавитьСтроку Или ТекущийЭлементФормы.ТекущаяСтрока <> Неопределено Тогда
			КолонкаТП = ТабличноеПолеТекущаяКолонкаЛкс(ТекущийЭлементФормы, ЭлементУправления, ДоступноРедактирование);
			Если Истина
				И Не ЛиОсновнаяВставка 
				И (Ложь
					Или ТипЗнч(ЭлементУправления) = Тип("ПолеВвода")
					Или ТипЗнч(ЭлементУправления) = Тип("ПолеФормы") И ЭлементУправления.Вид = ВидПоляФормы.ПолеВвода)
			Тогда
				ТекущийЭлементФормы.ИзменитьСтроку();
				НачалоКолонки = 0; НачалоСтроки = 0; КонецКолонки = 0; КонецСтроки = 0;
				ЭлементУправления.ПолучитьГраницыВыделения(НачалоСтроки, НачалоКолонки, КонецСтроки, КонецКолонки);
				Если Ложь
					Или НачалоКолонки > 1 // Уже вставлено в обычной форме, но в управляемой почему то всегда 1 https://www.hostedredmine.com/issues/957469
					//Или КонецКолонки > 1
					//Или НачалоСтроки > 1
					//Или КонецСтроки > 1
					Или (Истина
						// Уже вставлено в управляемой форме
						И ТипЗнч(ЭлементУправления) = Тип("ПолеФормы") 
						И ТипЗначения = Тип("Строка")
						И Найти(ЭлементУправления.ТекстРедактирования, Значение) > 0)
				Тогда
					Возврат;
				КонецЕсли;
				// Скорее всего этот блок имеет смысл только для управляемой формы
				Если Истина
					И КолонкаДанных <> Неопределено 
					И Не КолонкаДанных.ТипЗначения.СодержитТип(ТипЗначения)
				Тогда 
					Возврат;
				КонецЕсли;
			КонецЕсли;
		КонецЕсли;
		Если Истина
			И ТипЗнч(ЭтаФорма) = Тип("Форма")
			И Не ЭтаФорма.ТолькоПросмотр
			И (Ложь
				Или ТипЗначения = Тип("СписокЗначений")
				Или ТипЗначения = Тип("Строка"))
			И (Ложь
				Или ирОбщий.СлужебныеДанныеФормыЛкс(ЭтаФорма).ИмяФормы = "Обработка.ирПлатформа.Форма.Массив"
				Или (Истина
					И ирОбщий.СлужебныеДанныеФормыЛкс(ЭтаФорма).ИмяФормы = "Обработка.ирПлатформа.Форма.СписокЗначений" 
					И (Ложь
						Или ТипЗначения = Тип("СписокЗначений") И ЛиОписаниеТиповСодержитТипЛкс(ЭтаФорма.ОписаниеТипов, ТипЗнч(Значение[0].Значение))
						Или ТипЗначения = Тип("Строка") И ЛиОписаниеТиповСодержитТипЛкс(ЭтаФорма.ОписаниеТипов, Тип("Строка")))))
		Тогда
			Если ТипЗнч(Значение) = Тип("Строка") Тогда
				НовоеЗначение = Новый СписокЗначений;
				НовоеЗначение.ЗагрузитьЗначения(ирОбщий.СтрРазделитьЛкс(Значение, Символы.ПС, Истина));
				Значение = НовоеЗначение;
			КонецЕсли;
			#Если Сервер И Не Сервер Тогда
				Значение = Новый СписокЗначений;
			#КонецЕсли
			ЗагружаемаяТаблица = Новый ТаблицаЗначений;
			ЗагружаемаяТаблица.Колонки.Добавить("ПредставлениеЗначения");
			Для Каждого ЭлементСписка Из Значение Цикл
				СтрокаСписка = ЗагружаемаяТаблица.Добавить();
				СтрокаСписка.ПредставлениеЗначения = ЭлементСписка.Значение;
			КонецЦикла;
			ЗагрузитьТаблицуВТабличноеПолеЛкс(ЭтаФорма, ТекущийЭлементФормы, ЗагружаемаяТаблица,,,,,,, ЗагружаемаяТаблица.Количество() > 1);
			Возврат;
		КонецЕсли;
		Попытка
			РедактированиеВДиалоге = ТекущийЭлементФормы.СпособРедактирования = СпособРедактированияСписка.ВДиалоге;
		Исключение
			РедактированиеВДиалоге = Ложь;
		КонецПопытки;
		Если Истина
			И Не ТекущийЭлементФормы.ТолькоПросмотр
			И ИмяКолонкиДанных <> "ПравоеЗначение"
			И ТипЗнч(ДанныеПоля) = Тип("ОтборКомпоновкиДанных")
			И ТипЗнч(Значение) = Тип("ОтборКомпоновкиДанных")
		Тогда
			ГруппаПриемник = ДанныеСтрокиТабличногоПоляЛкс(ТекущийЭлементФормы);
			Если ТипЗнч(ГруппаПриемник) = Тип("ЭлементОтбораКомпоновкиДанных") Тогда
				ГруппаПриемник = ирОбщий.РодительСтрокиДереваЛкс(ГруппаПриемник, ДанныеПоля);
			КонецЕсли;
			ирОбщий.СкопироватьЭлементыКомпоновкиЛкс(ГруппаПриемник, Значение, Ложь,, ТекущийЭлементФормы);
			Если ТипЗнч(ТекущийЭлементФормы) = Тип("ТабличноеПоле") Тогда 
				ТекущийЭлементФормы.Развернуть(ГруппаПриемник);
				Если ТекущийЭлементФормы.ИзменяетДанные Тогда
					ЭтаФорма.Модифицированность = Истина;
				КонецЕсли; 
			Иначе //Если ТипЗнч(ТекущийЭлементФормы) = Тип("ТаблицаФормы") Тогда 
				ТекущийЭлементФормы.Развернуть(ДанныеПоля.ПолучитьИдентификаторПоОбъекту(ГруппаПриемник));
			КонецЕсли;
		ИначеЕсли Истина
			И Не РедактированиеВДиалоге
			И Не ЭтаФорма.ТолькоПросмотр
			И Не ТекущийЭлементФормы.ТолькоПросмотр
		Тогда
			Если Истина
				И Значение <> Неопределено
				И ТекущийЭлементФормы.ИзменятьСоставСтрок
				И Не ДобавитьСтроку 
				И ДоступноРедактирование
				И ТипЗнч(ДанныеПоля) <> Тип("Отбор")
				И ТипЗнч(ДанныеПоля) <> Тип("ОтборКомпоновкиДанных")
			Тогда
				//Ответ = Вопрос("Выполнить вставку значения в новую строку (иначе будет выполнена вставка в текущую)?", РежимДиалогаВопрос.ДаНет, ,
				//	КодВозвратаДиалога.Нет);
				//Ответ = КодВозвратаДиалога.Нет);
				//ДобавитьСтроку = Ответ = КодВозвратаДиалога.Да;
				ДобавитьСтроку = Ложь;
			КонецЕсли;
			Если ДобавитьСтроку Тогда
				ТекущийЭлементФормы.ДобавитьСтроку();
				Если КолонкаТП = Неопределено Тогда
					КолонкаТП = ТабличноеПолеТекущаяКолонкаЛкс(ТекущийЭлементФормы, ЭлементУправления, ДоступноРедактирование); // Текущая колонка могла измениться в ПриНачалеРедактированияСтроки
				Иначе
					ТабличноеПолеУстановитьТекущуюКолонкуЛкс(ТекущийЭлементФормы, КолонкаТП);
				КонецЕсли; 
			КонецЕсли; 
			Если ЭлементУправления <> Неопределено Тогда
				Если ТекущийЭлементФормы.ТекущаяСтрока <> Неопределено Тогда 
					ТекущийЭлементФормы.ИзменитьСтроку(); // Нужно делать, т.к. табличное поле выходит из режима редактирования строки при вызове команды и иногда установке текущей колонки
				КонецЕсли;
				Если ТекущийЭлементФормы.ТекущиеДанные <> Неопределено Тогда
					ТекущиеДанные = ДанныеСтрокиТабличногоПоляЛкс(ТекущийЭлементФормы);
					ОграничениеТипа = ЭлементУправления.ОграничениеТипа;
					#Если Сервер И Не Сервер Тогда
						ОграничениеТипа = Новый ОписаниеТипов;
					#КонецЕсли
					Если Истина
						И КолонкаДанных <> Неопределено 
						И ОграничениеТипа.Типы().Количество() = 0
					Тогда 
						ОграничениеТипа = КолонкаДанных.ТипЗначения;
					КонецЕсли;
					ПродолжитьОбработку = Истина;
					Если ТипЗнч(ДанныеПоля) = Тип("ОтборКомпоновкиДанных") Тогда 
						#Если Сервер И Не Сервер Тогда
							ДанныеПоля = Новый ОтборКомпоновкиДанных;
						#КонецЕсли
						Если ТипЗнч(Значение) = Тип("ПолеКомпоновкиДанных") Тогда
							ОграничениеТипа = Новый ОписаниеТипов("ПолеКомпоновкиДанных");
						Иначе
							ДоступноеПоле = ДанныеПоля.ДоступныеПоляОтбора.НайтиПоле(ТекущиеДанные.ЛевоеЗначение);
							Если ДоступноеПоле <> Неопределено Тогда
								Если ТипЗначения = Тип("СписокЗначений") Тогда 
									Если ТекущиеДанные.ВидСравнения <> ВидСравненияКомпоновкиДанных.НеВСписке Тогда
										Если ДоступноеПоле.ДоступныеВидыСравнения.НайтиПоЗначению(ВидСравненияКомпоновкиДанных.ВСписке) <> Неопределено Тогда
											ТекущиеДанные.ВидСравнения = ВидСравненияКомпоновкиДанных.ВСписке;
										КонецЕсли;
										ПродолжитьОбработку = ТекущиеДанные.ВидСравнения = ВидСравненияКомпоновкиДанных.ВСписке;
									КонецЕсли;
								ИначеЕсли Ложь
									Или ТекущиеДанные.ВидСравнения = ВидСравненияКомпоновкиДанных.НеВСписке 
									Или ТекущиеДанные.ВидСравнения = ВидСравненияКомпоновкиДанных.ВСписке
								Тогда  
									ОграничениеТипа = Новый ОписаниеТипов("СписокЗначений");
								Иначе
									ОграничениеТипа = ДоступноеПоле.ТипЗначения;
								КонецЕсли;
							КонецЕсли;
						КонецЕсли;
					КонецЕсли;
					Если ПродолжитьОбработку И ЛиОписаниеТиповСодержитТипЛкс(ОграничениеТипа, ТипЗначения) Тогда
						//ПродолжитьОбработку = Не ВставитьЗначениеВПолеВводаЛкс(ЭлементУправления, Значение); // Так не работает для правых значений компоновки в управляемой форме
						ПродолжитьОбработку = Не ИнтерактивноЗаписатьВКолонкуТабличногоПоляЛкс(ТекущийЭлементФормы, КолонкаТП, Значение,,,, Ложь
							Или ОграничениеТипа.Типы().Количество() > 0
							Или ТипЗнч(ТекущиеДанные) = Тип("ЭлементОтбораКомпоновкиДанных"));
					КонецЕсли; 
					Если ПродолжитьОбработку Тогда
						Если ТипЗначения = Тип("Массив") И Значение.Количество() > 0 Тогда
							ЗначениеЭлемента = Значение[0];
							ЗначениеИзменено = Истина;
						ИначеЕсли ТипЗначения = Тип("СписокЗначений") И Значение.Количество() > 0 Тогда
							ЗначениеЭлемента = Значение[0].Значение;
							ЗначениеИзменено = Истина;
						Иначе
							ЗначениеИзменено = Ложь;
						КонецЕсли;
						Если Истина
							И ЗначениеИзменено 
							И ЛиОписаниеТиповСодержитТипЛкс(ОграничениеТипа, ТипЗнч(ЗначениеЭлемента))
						Тогда
							//ПродолжитьОбработку = Не ВставитьЗначениеВПолеВводаЛкс(ЭлементУправления, ЗначениеЭлемента);
							ПродолжитьОбработку = Не ИнтерактивноЗаписатьВКолонкуТабличногоПоляЛкс(ТекущийЭлементФормы, КолонкаТП, ЗначениеЭлемента,,,, ТипЗнч(ТекущиеДанные) = Тип("ЭлементОтбораКомпоновкиДанных"));
						КонецЕсли; 
					КонецЕсли; 
					ИмяКолонкиДанных = ирОбщий.ПутьКДаннымКолонкиТабличногоПоляЛкс(ТекущийЭлементФормы);
					Если Истина
						И ПродолжитьОбработку 
						И ЗначениеЗаполнено(ИмяКолонкиДанных) 
						И ЛиВКолонкеДоступнаЭмуляцияИнтерактивногоИзмененияЛкс(КолонкаТП)
						И ЛиОписаниеТиповСодержитТипЛкс(ОграничениеТипа, ТипЗнч(Значение))
					Тогда
						// Например ссылка таблицы внешнего источника в поле ввода не может быть установлена через оповещение выбора
						Если ТипЗнч(ТекущиеДанные) = Тип("ЭлементОтбораКомпоновкиДанных") Тогда
							ИмяКолонкиДанных = ирОбщий.ПервыйФрагментЛкс(ИмяКолонкиДанных, "Для");
						КонецЕсли;
						Попытка
							ТекущиеДанные[ИмяКолонкиДанных] = Значение;
						Исключение
						КонецПопытки;
					КонецЕсли; 
				КонецЕсли;
			КонецЕсли;
		КонецЕсли;
	КонецЕсли;

КонецПроцедуры

Функция ЛиОписаниеТиповСодержитТипЛкс(Знач ОграничениеТипа, Знач Тип) Экспорт 
	
	Возврат Ложь
		Или ОграничениеТипа.Типы().Количество() = 0
		Или ОграничениеТипа.СодержитТип(Тип);

КонецФункции

Процедура НайтиСсылкуИзБуфераВТаблицеФормыЛкс(ЭтаФорма) Экспорт
	#Если Сервер И Не Сервер Тогда
		ЭтаФорма = ПолучитьОбщуюФорму();
	#КонецЕсли
	ИскомоеЗначение = ЗначениеИзБуфераОбменаЛкс();
	Если ИскомоеЗначение = Неопределено Тогда
		Возврат;
	КонецЕсли; 
	ТаблицаФормы = ЭтаФорма.ТекущийЭлемент;
	ПродолжитьОбработку = Истина;
	ТипЗначения = ТипЗнч(ИскомоеЗначение);
	Если ирОбщий.ОбщийТипДанныхТабличногоПоляЛкс(ТаблицаФормы) = "Список" Тогда 
		ДинамическийСписокУстановитьТекущуюСтрокуСКонтролемЛкс(ТаблицаФормы, ИскомоеЗначение, ЭтаФорма);
	Иначе
		ИмяКолонкиДанных = ирОбщий.ПутьКДаннымКолонкиТабличногоПоляЛкс(ТаблицаФормы);
		ДанныеТаблицы = ирОбщий.ДанныеЭлементаФормыЛкс(ТаблицаФормы,,, Истина);
		ТаблицаИлиДеревоЗначений = ТаблицаИлиДеревоЗначенийИзТаблицыФормыСКоллекциейЛкс(ТаблицаФормы,, Истина, Ложь,,, ЭтаФорма);
		Если ТипЗнч(ТаблицаИлиДеревоЗначений) = Тип("ДеревоЗначений") Тогда
			#Если Сервер И Не Сервер Тогда
				ТаблицаИлиДеревоЗначений = Новый ДеревоЗначений;
			#КонецЕсли
			НайденнаяСтрока = ТаблицаИлиДеревоЗначений.Строки.Найти(ИскомоеЗначение, ИмяКолонкиДанных, Истина);
			Если НайденнаяСтрока = Неопределено Тогда
				ирОбщий.СообщитьЛкс("Значение в колонке не найдено");
			Иначе
				ПутьКСтроке = ирОбщий.Дерево_ПутьСтрокойЛкс(НайденнаяСтрока, "",,, ТаблицаИлиДеревоЗначений);
				СтрокаТаблицыФормы = ирОбщий.Дерево_НайтиПоПутиСтрокойЛкс(ДанныеТаблицы, "", ПутьКСтроке);
				Если ТипЗнч(ТаблицаФормы) = Тип("ТаблицаФормы") Тогда
					Если СтрокаТаблицыФормы <> Неопределено Тогда
						ТаблицаФормы.ТекущаяСтрока = СтрокаТаблицыФормы.ПолучитьИдентификатор();
					КонецЕсли; 
				Иначе
					ТаблицаФормы.ТекущаяСтрока = СтрокаТаблицыФормы;
				КонецЕсли; 
			КонецЕсли; 
		Иначе
			НайденнаяСтрока = ТаблицаИлиДеревоЗначений.Найти(ИскомоеЗначение, ИмяКолонкиДанных);
			Если НайденнаяСтрока = Неопределено Тогда
				ирОбщий.СообщитьЛкс("Значение в колонке не найдено");
			Иначе
				СтрокаТаблицыФормы = ДанныеТаблицы[ТаблицаИлиДеревоЗначений.Индекс(НайденнаяСтрока)];
				Если ТипЗнч(ТаблицаФормы) = Тип("ТаблицаФормы") Тогда
					ТаблицаФормы.ТекущаяСтрока = СтрокаТаблицыФормы.ПолучитьИдентификатор();
				Иначе
					ТаблицаФормы.ТекущаяСтрока = СтрокаТаблицыФормы;
				КонецЕсли; 
			КонецЕсли; 
		КонецЕсли; 
	КонецЕсли;
	
КонецПроцедуры

Процедура КопироватьСсылкуАктивнойСтрокиФормыЛкс(Форма) Экспорт 
	
	КлючТекущейСтроки = Неопределено;
	КлючиСтрок = КлючиСтрокБДИзТаблицыФормыЛкс(Форма, КлючТекущейСтроки);
	Если КлючиСтрок.Количество() > 1 Тогда
		БуферОбменаПриложения_УстановитьЗначениеЛкс(ирОбщий.МассивВСписокЗначенийЛкс(КлючиСтрок));
	ИначеЕсли КлючТекущейСтроки <> Неопределено Тогда
		БуферОбменаПриложения_УстановитьЗначениеЛкс(КлючТекущейСтроки);
	КонецЕсли;

КонецПроцедуры

// Параметры:
//   ЭтаФорма - Форма - для управляемой формы можно не передавать, она определится автоматически
//
Функция БуферОбмена_КопироватьЛкс(Знач ЭтаФорма = Неопределено, Знач УстановитьПредставление = Истина) Экспорт
	
	Если ЭтаФорма = Неопределено Тогда
		ЭтаФорма = АктивнаяУправляемаяФормаЛкс();
	КонецЕсли; 
	Если ЭтаФорма = Неопределено Тогда
		Возврат Неопределено;
	КонецЕсли; 
	Значение = Форма_ЗначениеТекущегоПоляЛкс(ЭтаФорма, Истина);
	Если Значение <> Неопределено Тогда
		БуферОбменаПриложения_УстановитьЗначениеЛкс(Значение, УстановитьПредставление);
	Иначе
		КопироватьСсылкуАктивнойСтрокиФормыЛкс(ЭтаФорма);
	КонецЕсли;
	
КонецФункции

Функция Форма_ЗначениеТекущегоПоляЛкс(ЭтаФорма, ДляКопирования = Ложь) Экспорт 
	
	Значение = ЗначенияВыделенныхЯчеекТаблицыЛкс(ЭтаФорма,, ДляКопирования, Ложь);
	ЕстьСсылкиВТекущемПоле = Значение.Количество() > 0 И ирОбщий.ЛиСсылкаНаОбъектБДЛкс(Значение[0], Ложь);
	Если Значение.Количество() = 1 Тогда
		Значение = Значение[0];
	КонецЕсли; 
	Если Не ЕстьСсылкиВТекущемПоле И ТипЗнч(Значение) <> Тип("СписокЗначений") Тогда
		//Значение = Неопределено;
		ТекущийЭлементФормы = ЭтаФорма.ТекущийЭлемент;
		Если ЛиПолеФормыИмеетТипЛкс(ТекущийЭлементФормы, Тип("ПолеВвода")) Тогда
			Значение = ирОбщий.ДанныеЭлементаФормыЛкс(ТекущийЭлементФормы);
			//Текст = "" + ТекущийЭлементФормы.ВыделенныйТекст;
			Если ДляКопирования И ТипЗнч(Значение) = Тип("Строка") Тогда
				Значение = Неопределено;
			КонецЕсли;
		ИначеЕсли Ложь
			Или ЛиПолеФормыИмеетТипЛкс(ТекущийЭлементФормы, Тип("ПолеТекстовогоДокумента")) 
			Или ЛиПолеФормыИмеетТипЛкс(ТекущийЭлементФормы, Тип("ПолеHTMLДокумента"))
		Тогда
			Если ДляКопирования Тогда
				Если Истина
					И ирКэш.НомерВерсииПлатформыЛкс() >= 803015
					И ирКэш.НомерВерсииПлатформыЛкс() <= 803017
					И ЛиПолеФормыИмеетТипЛкс(ТекущийЭлементФормы, Тип("ПолеHTMLДокумента"))
				Тогда
					ПолеТекста = ОболочкаПоляТекстаЛкс(ТекущийЭлементФормы);
					// Антибаг платформы. Копирование в буфер обмена не выполняется платформой
					ВыделенныйТекст = ПолеТекста.ВыделенныйТекст();
					Если ВыделенныйТекст <> ТекстИзБуфераОбменаОСЛкс() Тогда
						// Теряем оформление
						ТекстВБуферОбменаОСЛкс(ВыделенныйТекст, "");
					КонецЕсли; 
				КонецЕсли; 
			Иначе
				ПолеТекста = ОболочкаПоляТекстаЛкс(ТекущийЭлементФормы);
				Значение = ПолеТекста.ПолучитьТекст();
			КонецЕсли;
		ИначеЕсли ЛиПолеФормыИмеетТипЛкс(ТекущийЭлементФормы, Тип("ПолеТабличногоДокумента")) Тогда
			#Если Сервер И Не Сервер Тогда
				ТекущийЭлементФормы = Новый ТабличныйДокумент;
			#КонецЕсли
			Попытка
				ДанныеРасшифровки = ЭтаФорма.ДанныеРасшифровки;
			Исключение
				ДанныеРасшифровки = Неопределено;
			КонецПопытки;
			Если Истина
				И ТекущийЭлементФормы.ТекущаяОбласть <> Неопределено 
				И ТипЗнч(ТекущийЭлементФормы.ТекущаяОбласть) <> Тип("РисунокТабличногоДокумента")
			Тогда 
				Если ДляКопирования Тогда 
					// Так будем терять оформление
					//Значение = ТекущийЭлементФормы.ТекущаяОбласть.Текст;
					//Если ПустаяСтрока(Прав(Значение, 1)) Тогда
					//	ТекстВБуферОбменаОСЛкс(Значение, "");
					//КонецЕсли; 
					Если Истина
						И ТипЗнч(ДанныеРасшифровки) = Тип("ДанныеРасшифровкиКомпоновкиДанных")
						И ТекущийЭлементФормы.ТекущаяОбласть.ТипОбласти = ТипОбластиЯчеекТабличногоДокумента.Прямоугольник
						И ТипЗнч(ТекущийЭлементФормы.ТекущаяОбласть.Расшифровка) = Тип("ИдентификаторРасшифровкиКомпоновкиДанных")
					Тогда
						ВысотаОбласти = ТекущийЭлементФормы.ТекущаяОбласть.Низ - ТекущийЭлементФормы.ТекущаяОбласть.Верх + 1;
						Если Истина
							И ТекущийЭлементФормы.ТекущаяОбласть.Лево = ТекущийЭлементФормы.ТекущаяОбласть.Право
							И ВысотаОбласти > 1
							И ВысотаОбласти < 1000
						Тогда
							ТаблицаВыделенныхЯчеек = ирОбщий.ТаблицаКлючейИзТабличногоДокументаЛкс(ТекущийЭлементФормы, ДанныеРасшифровки);
							Значение = ТаблицаВыделенныхЯчеек.ВыгрузитьКолонку(0); // Может быть больше одной колонки
						Иначе
							ЭлементРасшифровки = ДанныеРасшифровки.Элементы[ТекущийЭлементФормы.ТекущаяОбласть.Расшифровка];
							Для каждого ЗначениеПоля Из ЭлементРасшифровки.ПолучитьПоля() Цикл
								//Если Не ирОбщий.ЛиСсылкаНаОбъектБДЛкс(ЗначениеПоля.Значение, Ложь) Тогда
								//	Продолжить;
								//КонецЕсли; 
								Значение = ЗначениеПоля.Значение;
								Прервать;
							КонецЦикла;  
						КонецЕсли;
					КонецЕсли; 
				Иначе
					Значение = ТекущийЭлементФормы.ТекущаяОбласть.Текст;
				КонецЕсли;
			КонецЕсли;
		ИначеЕсли Ложь
			Или ТипЗнч(ТекущийЭлементФормы) = Тип("ТабличноеПоле") 
			Или ТипЗнч(ТекущийЭлементФормы) = Тип("ТаблицаФормы")
		Тогда
			#Если Сервер И Не Сервер Тогда
				ТекущийЭлементФормы = Новый ТабличноеПоле;
			#КонецЕсли
			Если ТекущийЭлементФормы.ТекущаяСтрока <> Неопределено Тогда 
				ТипСтрокиТаблицы = ТипЗнч(ТекущийЭлементФормы.ТекущаяСтрока);
				ДанныеПоля = ирОбщий.ДанныеЭлементаФормыЛкс(ТекущийЭлементФормы);
				ИмяКолонкиДанных = ирОбщий.ПутьКДаннымКолонкиТабличногоПоляЛкс(ТекущийЭлементФормы);
				Если Ложь
					Или ТипСтрокиТаблицы = Тип("ДоступноеПолеКомпоновкиДанных") 
					Или ТипСтрокиТаблицы = Тип("ДоступноеПолеОтбораКомпоновкиДанных")
				Тогда
					Значение = ТекущийЭлементФормы.ТекущаяСтрока.Поле;
				ИначеЕсли Истина
					И ИмяКолонкиДанных <> "ПравоеЗначение"
					И ТипЗнч(ДанныеПоля) = Тип("ОтборКомпоновкиДанных")
				Тогда
					Значение = Новый НастройкиКомпоновкиДанных; 
					Значение = Значение.Отбор;
					ирОбщий.СкопироватьЭлементыКомпоновкиЛкс(Значение, ДанныеПоля,, ВыделенныеСтрокиТабличногоПоляЛкс(ТекущийЭлементФормы));
				ИначеЕсли ТипЗнч(Значение) <> Тип("Массив") Тогда 
					Если Истина
						И ТипЗнч(ТекущийЭлементФормы) = Тип("ТаблицаФормы")
						И ирОбщий.ЭтоУпрДинСписокИРЛкс(ЭтаФорма)
						И ЗначениеЗаполнено(ИмяКолонкиДанных) 
					Тогда
						Если СтрДлина(Значение) = ирОбщий.ДлинаПредставленияСтрокиНеограниченнойЛкс() Тогда
							Значение = ДанныеСтрокДинамическогоСпискаЛкс(ТекущийЭлементФормы, ирОбщий.ЗначенияВМассивЛкс(ТекущийЭлементФормы.ТекущаяСтрока), ИмяКолонкиДанных)[0][ИмяКолонкиДанных];
							ТекстВБуферОбменаОСЛкс(Значение, ""); // Заменим помещенный платформой в буфер обмена обрезанный текст на полный
						КонецЕсли;
					ИначеЕсли ТипЗнч(ТекущийЭлементФормы) = Тип("ТабличноеПоле") И ТекущийЭлементФормы.ТекущаяКолонка <> Неопределено Тогда
						ДопСвойства = ДопСвойстваЭлементаФормыЛкс(ЭтаФорма, ТекущийЭлементФормы);
						ЯчейкаСРазметкой = ТекущийЭлементФормы.ОформлениеСтроки(ТекущийЭлементФормы.ТекущаяСтрока).Ячейки[ТекущийЭлементФормы.ТекущаяКолонка.Имя];
						// Уберем разметку вхождений строки поиска
						ДопСвойства.ЗапретРазметкиВхождений = Истина;
						ТекущийЭлементФормы.ОбновитьСтроки(ТекущийЭлементФормы.ТекущаяСтрока);
						Ячейка = ТекущийЭлементФормы.ОформлениеСтроки(ТекущийЭлементФормы.ТекущаяСтрока).Ячейки[ТекущийЭлементФормы.ТекущаяКолонка.Имя];
						// Уберем разметку вхождений строки поиска
						ДопСвойства.ЗапретРазметкиВхождений = Ложь;
						ТекущийЭлементФормы.ОбновитьСтроки(ТекущийЭлементФормы.ТекущаяСтрока);
						Если ДляКопирования Тогда
							Значение = Ячейка.Значение;
							Если ЯчейкаСРазметкой.Текст <> Ячейка.Текст Тогда
								ТекстВБуферОбменаОСЛкс(Ячейка.Текст, ""); // Заменим помещенный платформой в буфер обмена текст с разметкой найденных слов на текст без разметки
							ИначеЕсли ТипЗнч(Значение) = Тип("Строка") И """" + Значение + """" = Ячейка.Текст Тогда 
								ТекстВБуферОбменаОСЛкс(Значение, ""); // Удаляем явное обозначение границ строкового значения кавычками
							КонецЕсли;
							Если ТипЗнч(Значение) = Тип("Строка") Тогда
								Если ПустаяСтрока(Прав(Значение, 1)) Тогда
									// https://www.hostedredmine.com/issues/910752
									Массив = Новый Массив;
									Массив.Добавить(ТекущийЭлементФормы.ТекущаяСтрока);
									ПолноеИмяТаблицыБД = "";
									ТипИсточника = ирОбщий.ОбщийТипДанныхТабличногоПоляЛкс(ТекущийЭлементФормы,,, ПолноеИмяТаблицыБД);
									Если Истина
										И ТипИсточника = "Список"
										И ЗначениеЗаполнено(ПолноеИмяТаблицыБД) 
									Тогда
										ТаблицаЗначений = ирОбщий.ПустаяТаблицаЗначенийИзТаблицыБДЛкс(ПолноеИмяТаблицыБД);
									Иначе
										ТаблицаЗначений = ТаблицаИлиДеревоЗначенийИзТаблицыФормыСКоллекциейЛкс(ТекущийЭлементФормы, Массив);
									КонецЕсли; 
									#Если Сервер И Не Сервер Тогда
										ТаблицаЗначений = Новый ТаблицаЗначений;
									#КонецЕсли
									Если ТаблицаЗначений <> Неопределено Тогда
										КолонкаТаблицы = ТаблицаЗначений.Колонки.Найти(ирОбщий.ПутьКДаннымКолонкиТабличногоПоляЛкс(ТекущийЭлементФормы));
										Если Ложь
											Или КолонкаТаблицы = Неопределено
											Или КолонкаТаблицы.ТипЗначения.КвалификаторыСтроки.ДопустимаяДлина = ДопустимаяДлина.Переменная 
										Тогда
											ТекстВБуферОбменаОСЛкс(Значение, "");
										КонецЕсли; 
									КонецЕсли;
								КонецЕсли; 
								Значение = Неопределено;
							КонецЕсли; 
						Иначе
							Значение = Ячейка.Текст;
						КонецЕсли;
					КонецЕсли;
				КонецЕсли;
			КонецЕсли;
		КонецЕсли;
	КонецЕсли;
	Если ДляКопирования И ТипЗнч(Значение) = Тип("Массив") Тогда 
		Значение = ирОбщий.МассивВСписокЗначенийЛкс(Значение);
	КонецЕсли;
	Возврат Значение;

КонецФункции

Функция ОткрытьРазличныеЗначенияКолонкиЛкс(Знач ТабличноеПоле, Знач НастройкиСписка = Неопределено, Знач _АдресСхемыКомпоновки = Неопределено, ЭтаФорма = Неопределено) Экспорт 
	
	#Если Сервер И Не Сервер Тогда
		Обработки.ирРазличныеЗначенияКолонки;
	#КонецЕсли
	Форма = ПолучитьФормуЛкс("Обработка.ирРазличныеЗначенияКолонки.Форма",, ТабличноеПоле);
	Форма.НастройкиСписка = НастройкиСписка;
	Форма.АдресСхемыКомпоновки = _АдресСхемыКомпоновки;
	Форма.Форма = ЭтаФорма;
	РезультатФормы = Форма.ОткрытьМодально();
	
КонецФункции

Функция ОткрытьГруппировкуТабличногоПоляЛкс(Знач ТабличноеПоле, Знач НастройкиСписка = Неопределено, ИменаКлючевыхКолонок = "") Экспорт 
	
	мПлатформа = ирКэш.Получить();
	#Если Сервер И Не Сервер Тогда
		мПлатформа = Обработки.ирПлатформа.Создать();
	#КонецЕсли
	Форма = мПлатформа.ПолучитьФорму("ГруппировкаТаблицы", ТабличноеПоле);
	Форма.ПараметрНастройкаКомпоновки = НастройкиСписка;
	Форма.ПараметрИменаКлючевыхКолонок = ИменаКлючевыхКолонок;
	#Если ТолстыйКлиентУправляемоеПриложение Тогда
		Форма.ОткрытьМодально();
	#Иначе
		Форма.Открыть();
	#КонецЕсли
	
КонецФункции

Процедура ПоказатьСсылкуНаМодульКонфигурацииЛкс(ПолноеИмяМодуля) Экспорт 
	
	Ссылка = СсылкаНаМодульКонфигурацииЛкс(ПолноеИмяМодуля);
	ПоказатьСсылкуНаСтрокуМодуляЛкс(Ссылка);

КонецПроцедуры

Функция СсылкаНаМодульКонфигурацииЛкс(Знач ПолноеИмяМодуля) Экспорт 
	
	Возврат "{" + ПолноеИмяМодуля + "(1)}";

КонецФункции 

Процедура ПоказатьСсылкуНаСтрокуМодуляЛкс(Знач Ссылка) Экспорт 
	
	Текст = //"<html><head></head><body>"
	"
	|" + Ссылка + "<br> 
	|Запустите программу <a href=http://devtool1c.ucoz.ru/forum/3-609-1>ClipAngel</a>, скопируйте эту ссылку и откройте ее в конфигураторе через эту программу через ALT+клик
	|"
	//"</body></html>"
	;
	Форма = ФормаПросмотраHTMLЛкс(Текст);
	Форма.ОткрытьМодально();

КонецПроцедуры

Функция ОписаниеМодуляПоИмениЛкс(Знач ИмяМодуля) Экспорт 
	ОписаниеМодуля = Новый Структура("Метаданные, ИмяФайлаМодуля");
	Фрагменты = ирОбщий.СтрРазделитьЛкс(ИмяМодуля);
	#Если Сервер И Не Сервер Тогда
		Фрагменты = Новый Массив;
	#КонецЕсли
	ТипМодуля = Фрагменты[Фрагменты.ВГраница()];
	Если ТипМодуля = "Форма" Тогда
		ТипМодуля = "Форма.Модуль";
	КонецЕсли; 
	Фрагменты.Удалить(Фрагменты.ВГраница());
	ИмяОбъектаМодуля = ирОбщий.СтрСоединитьЛкс(Фрагменты, ".");
	Если ЗначениеЗаполнено(ИмяОбъектаМодуля) Тогда
		ОписаниеМодуля.Метаданные = ирКэш.ОбъектМДПоПолномуИмениЛкс(ирОбщий.ПоследнийФрагментЛкс(ИмяОбъектаМодуля, " "));
		Если ОписаниеМодуля.Метаданные <> Неопределено Тогда
			ОписаниеМодуля.ИмяФайлаМодуля = ОписаниеМодуля.Метаданные.ПолноеИмя() + "." + ТипМодуля;
		Иначе
			// Внешняя обработка
			ОписаниеМодуля.ИмяФайлаМодуля = ИмяМодуля;
		КонецЕсли; 
	Иначе
		ОписаниеМодуля.Метаданные = Метаданные;
		ОписаниеМодуля.ИмяФайлаМодуля = "Конфигурация" + "." + ТипМодуля;
	КонецЕсли;
	Возврат ОписаниеМодуля;
КонецФункции

Процедура ОткрытьОбъектМетаданныхПоИмениМодуляЛкс(Знач ПолноеИмяМодуля) Экспорт 
	
	ОписаниеМодуля = ОписаниеМодуляПоИмениЛкс(ПолноеИмяМодуля);
	Если ОписаниеМодуля.Метаданные <> Неопределено Тогда
		ОткрытьОбъектМетаданныхЛкс(ОписаниеМодуля.Метаданные);
	КонецЕсли;

КонецПроцедуры

Процедура СкрытьПоказатьОднозначныеКолонкиТабличногоПоляЛкс(Знач ТабличноеПоле, Знач Скрыть = Истина, Знач ИгнорироватьКолонки = Неопределено) Экспорт 
	
	ОставитьТолькоРазличающиесяКолонки = Ложь;
	Если Скрыть Тогда
		// Включаем видимость тех колонок реквизитов, в каких есть различия между элементами группы, а у остальных выключаем
		Если ТабличноеПоле.Значение.Количество() > 1 Тогда
			ОставитьТолькоРазличающиесяКолонки = Истина;
		КонецЕсли; 
	КонецЕсли; 
	Для Каждого КолонкаТП Из ТабличноеПоле.Колонки Цикл
		Если Ложь
			Или (Истина
				И ИгнорироватьКолонки <> Неопределено 
				И ЗначениеЗаполнено(КолонкаТП.Данные) 
				И ИгнорироватьКолонки.Свойство(КолонкаТП.Данные))
			Или ТабличноеПоле.Значение.Колонки.Найти(КолонкаТП.Данные) = Неопределено 
		Тогда
			Продолжить;
		КонецЕсли; 
		Если ОставитьТолькоРазличающиесяКолонки Тогда
			ПервоеЗначение = ТабличноеПоле.Значение[0][КолонкаТП.Данные];
			Для Индекс = 1 По ТабличноеПоле.Значение.Количество() - 1 Цикл
				ТекущееЗначение = ТабличноеПоле.Значение[Индекс][КолонкаТП.Данные];
				Если ПервоеЗначение <> ТекущееЗначение Тогда
					Прервать;
				КонецЕсли; 
			КонецЦикла;
			НоваяВидимость = ПервоеЗначение <> ТекущееЗначение;
		Иначе
			НоваяВидимость = Истина;
		КонецЕсли; 
		КолонкаТП.Видимость = НоваяВидимость;
	КонецЦикла;

КонецПроцедуры

Процедура Форма_ПриОткрытииЛкс(ЭтаФорма) Экспорт
	ирКэш.СостояниеПодготовкиКэшМДСеансаЛкс();
	мПлатформа = ирКэш.Получить();
	#Если Сервер И Не Сервер Тогда
		мПлатформа = Обработки.ирПлатформа.Создать();
		ЭтаФорма = ПолучитьОбщуюФорму();
	#КонецЕсли
	МодальныеГруппы = ирОбщий.МодальныеГруппыЛкс();
	#Если Сервер И Не Сервер Тогда
		МодальныеГруппы = Новый Массив;
	#КонецЕсли
	Если ЭтаФорма.МодальныйРежим Тогда
		МодальныеГруппы.Добавить(1);
		#Если Сервер И Не Сервер Тогда
			АктивироватьМодальныеГруппыЛкс();
		#КонецЕсли
		ПодключитьГлобальныйОбработчикОжиданияЛкс("АктивироватьМодальныеГруппыЛкс");
	ИначеЕсли МодальныеГруппы.Количество() > 0 Тогда 
		ИндексГруппы = МодальныеГруппы.Количество() - 1;
		МодальныеГруппы[ИндексГруппы].Значение = МодальныеГруппы[ИндексГруппы].Значение + 1;
	КонецЕсли;
	мПлатформа.ПодключитьПерехватКлавиатуры().ЗахватПервым = Ложь; // Используем не по назначению
	ДобавитьВСписокОткрытыхФормЛкс(ЭтаФорма);
	Если ТипЗнч(ЭтаФорма) = Тип("Форма") Тогда
		ДобавитьИнструментВИсториюРаботыЛкс(ЭтаФорма);
		ПодготовитьПрямуюДоставкуСобытияФормыЛкс(ЭтаФорма, "ВнешнееСобытие");
		ПодготовитьПрямуюДоставкуСобытияФормыЛкс(ЭтаФорма, "ОбработкаОповещения");
		// Подготовка отображения колонков типа Булево 
		Для Каждого ЭлементФормы Из ЭтаФорма.ЭлементыФормы Цикл
			Если ТипЗнч(ЭлементФормы) = Тип("ТабличноеПоле") Тогда
				ТипИсточника = ирОбщий.ОбщийТипДанныхТабличногоПоляЛкс(ЭлементФормы);
				МакетТаблицы = Неопределено;
				Если Ложь
					Или ТипИсточника = "ТабличнаяЧасть" 
					Или ТипИсточника = "НаборЗаписей"
					Или ТипИсточника = "ТаблицаЗначений" 
					Или ТипИсточника = "ДеревоЗначений" 
				Тогда
					МакетТаблицы = ТаблицаИлиДеревоЗначенийИзТаблицыФормыСКоллекциейЛкс(ЭлементФормы, Новый Массив);
				КонецЕсли;
				Если МакетТаблицы = Неопределено Тогда
					// Динамический список
					Продолжить;
				КонецЕсли;
				КолонкиДанных = МакетТаблицы.Колонки;
				Для Каждого КолонкаТП Из ЭлементФормы.Колонки Цикл
					КолонкаДанных = КолонкиДанных.Найти(КолонкаТП.Данные);
					Если КолонкаДанных = Неопределено Или КолонкаТП.КартинкиСтрок.Вид <> ВидКартинки.Пустая Тогда
						Продолжить;
					КонецЕсли;
					ТипЗначенияКолонки = Новый ОписаниеТипов(КолонкаДанных.ТипЗначения,, "Null");
					ТипыРеквизита = ТипЗначенияКолонки.Типы();
					Если ТипыРеквизита.Количество() = 1 И ТипыРеквизита[0] = Тип("Булево") Тогда
						КолонкаТП.КартинкиСтрок = ирКэш.КартинкаПоИмениЛкс("ирСостоянияФлажка");
					КонецЕсли;
				КонецЦикла;
			КонецЕсли; 
		КонецЦикла;
		//УстановитьПрикреплениеФормыВУправляемомПриложенииЛкс(Этаформа);
	КонецЕсли;
	Если Не ЭтаФорма.МодальныйРежим И МодальныеГруппы.Количество() > 0 Тогда
		// Антибаг платформы https://www.hostedredmine.com/issues/926161
		#Если Сервер И Не Сервер Тогда
			АктивироватьАктивнуюФормуЛкс();
		#КонецЕсли
		ПодключитьГлобальныйОбработчикОжиданияЛкс("АктивироватьАктивнуюФормуЛкс");
	КонецЕсли;
	Если ирКэш.ЛиСеансТолстогоКлиентаУПЛкс() Тогда
		ПодключитьПроверкуЧужихФормЛкс();
	КонецЕсли;

КонецПроцедуры

Процедура ПодготовитьПрямуюДоставкуСобытияФормыЛкс(Знач ЭтаФорма, Знач ИмяСобытия)
	
	ОбработчикСобытия = ЭтаФорма.ПолучитьДействие(ИмяСобытия);
	Если Истина
		И ОбработчикСобытия <> Неопределено 
		И Не ирОбщий.МетодРеализованЛкс(ЭтаФорма, ОбработчикСобытия)
	Тогда
		ирОбщий.СообщитьЛкс(ирОбщий.СтрШаблонИменЛкс("В модуле %1 обработчик события %2 не является экспортным",, ирОбщий.ПолноеИмяФормыЛкс(ЭтаФорма), 2, ИмяСобытия), СтатусСообщения.Внимание);
	КонецЕсли; 
	ЭтаФорма.УстановитьДействие(ИмяСобытия, Неопределено); // Будем вызывать напрямую, чтобы платформа не вызывала обновление всех форм

КонецПроцедуры

Процедура ДобавитьВСписокОткрытыхФормЛкс(ЭтаФорма) Экспорт 
	
	ирКэш.ОткрытыеФормыПодсистемыЛкс().Добавить(ЭтаФорма);
	СлужебныеДанныеФормы = ирОбщий.СлужебныеДанныеФормыЛкс(ЭтаФорма);
	СлужебныеДанныеФормы.Вставить("ДатаОткрытия", ирОбщий.ТекущееВремяВМиллисекундахЛкс());

КонецПроцедуры

Процедура Форма_ПриЗакрытииЛкс(ЭтаФорма, СохранитьНастройкуПоУмолчанию = Истина) Экспорт 
	
	#Если Сервер И Не Сервер Тогда
		ЭтаФорма = ОткрытьФорму();
	#КонецЕсли
	// У некоторых из-за большого объема данных в настройках пользователя это вызывает большие задержки
	//ПодключитьГлобальныйОбработчикОжиданияЛкс("СохранитьНастройкиПользователяОтложенноЛкс");
	Если ТипЗнч(ЭтаФорма) = Тип("Форма") И СохранитьНастройкуПоУмолчанию Тогда
		СохранитьНастройкуФормыЛкс(ЭтаФорма);
	КонецЕсли;
	ЗаданияФормы = Неопределено;
	СлужебныеДанные = ирОбщий.СлужебныеДанныеФормыЛкс(ЭтаФорма);
	#Если Сервер И Не Сервер Тогда
		СлужебныеДанные = Новый Структура;
	#КонецЕсли
	Если СлужебныеДанные.Задания.Количество() > 0 Тогда
		ЭтаФорма.ОтключитьОбработчикОжидания("ПроверкаЗавершенияФоновыхЗаданий");
		Для Каждого КлючИЗначение Из СлужебныеДанные.Задания Цикл
			ОтменитьЗаданиеФормыЛкс(ЭтаФорма, КлючИЗначение.Значение, Истина);
		КонецЦикла;
	КонецЕсли; 

	МодальныеГруппы = ирОбщий.МодальныеГруппыЛкс();
	#Если Сервер И Не Сервер Тогда
		МодальныеГруппы = Новый Массив;
	#КонецЕсли
	Если МодальныеГруппы.Количество() > 0 Тогда
		ИндексГруппы = МодальныеГруппы.Количество() - 1;
		Если ЭтаФорма.МодальныйРежим Тогда 
			// Вылняется никогда, т.к. свойство МодальныйРежим платформа сбрасывает перед ПриЗакрытии
			КоличествоФормВМодальнойГруппе = 0;
		Иначе
			КоличествоФормВМодальнойГруппе = МодальныеГруппы[ИндексГруппы].Значение;
			КоличествоФормВМодальнойГруппе = КоличествоФормВМодальнойГруппе - 1;
		КонецЕсли;
		Если КоличествоФормВМодальнойГруппе = 0 Тогда
			МодальныеГруппы.Удалить(ИндексГруппы);
			УстановитьФокусВводаФормеЛкс();
		Иначе
			МодальныеГруппы[ИндексГруппы].Значение = КоличествоФормВМодальнойГруппе;
		КонецЕсли; 
	КонецЕсли;
	ОткрытыеФормы = ирКэш.ОткрытыеФормыПодсистемыЛкс();
	Пока Истина Цикл
		ПозицияОткрытой = ОткрытыеФормы.Найти(ЭтаФорма);
		Если ПозицияОткрытой = Неопределено Тогда
			Прервать;
		КонецЕсли; 
		ОткрытыеФормы.Удалить(ПозицияОткрытой);
	КонецЦикла;
	ирКэш.ОткрытыеФормыВсеЛкс().Удалить(ЭтаФорма);
	
КонецПроцедуры

Процедура ОтменитьЗаданиеФормыОтложенноЛкс(Параметры) Экспорт 
	
	ОтменитьЗаданиеФормыЛкс(Параметры.ЭтаФорма, Параметры.ОписаниеЗадания);
	
КонецПроцедуры

Функция ОтменитьЗаданиеФормыЛкс(Знач ЭтаФорма, Знач ОписаниеЗадания, Знач ЗакрытьФормуЗадания = Ложь)
	
	Если Не ЗначениеЗаполнено(ОписаниеЗадания.УникальныйИдентификатор) Тогда
		Возврат Ложь;
	КонецЕсли; 
	ЗаданияФормы = ирОбщий.СлужебныеДанныеФормыЛкс(ЭтаФорма).Задания;
	#Если Сервер И Не Сервер Тогда
		ЗаданияФормы = Новый Структура;
	#КонецЕсли
	ОтменитьФоновоеЗаданиеЛкс(ОписаниеЗадания.УникальныйИдентификатор);
	Если ОписаниеЗадания.Многопоточное Тогда
		Найденные = ирОбщий.ФоновыеЗаданияПотоковЛкс();
		ПрефиксКлючаПотока = ирОбщий.ПрефиксКлючаПотокаЛкс(ЭтаФорма);
		Для Каждого ФоновоеЗадание Из Найденные Цикл
			#Если Сервер И Не Сервер Тогда
				ФоновоеЗадание = ФоновыеЗадания.Выполнить();
			#КонецЕсли
			Если ирОбщий.СтрНачинаетсяСЛкс(ФоновоеЗадание.Ключ, ПрефиксКлючаПотока) Тогда
				ОтменитьФоновоеЗаданиеЛкс(ФоновоеЗадание);
			КонецЕсли; 
		КонецЦикла;
	КонецЕсли; 
	ОбработатьЗавершениеЗаданияФормыЛкс(ОписаниеЗадания, ЭтаФорма,, Истина, ЗакрытьФормуЗадания);
	ПроверитьЗавершениеФоновыхЗаданийФормыЛкс(ЭтаФорма);
	Возврат Истина;

КонецФункции

Процедура УдалитьСсылкиНаЗакрытыеФормыЛкс(ЭтаФорма = Неопределено) Экспорт 
	
	УдалитьФормы = Новый Массив;
	ОткрытыеФормы = Новый Массив;
	Для Каждого Форма Из ОткрытыеФормы Цикл
		Если ЭтаФорма = Форма Или Форма.Открыта() Тогда
			Продолжить;
		КонецЕсли; 
		УдалитьФормы.Добавить(Форма);
	КонецЦикла;
	Для Каждого Форма Из УдалитьФормы Цикл
		ирОбщий.СообщитьЛкс(ирОбщий.СтрШаблонИменЛкс("Удалена ссылка на закрытую ранее форму %1",, Форма.Заголовок));
		ОткрытыеФормы.Удалить(ОткрытыеФормы.Найти(Форма));
	КонецЦикла;

КонецПроцедуры

Процедура ОповеститьФормыПодсистемыЛкс(ИмяСобытия = Неопределено, Параметр = Неопределено, Источник = Неопределено, Знач ЭтаФорма = Неопределено) Экспорт 
	Если ЭтаФорма = Неопределено Тогда
		ЭтаФорма = Источник;
	КонецЕсли; 
	УдалитьСсылкиНаЗакрытыеФормыЛкс(ЭтаФорма);
	// Копируем, чтобы в процессе оповещения массив не менял состав
	ОткрытыеФормы = ирОбщий.СкопироватьУниверсальнуюКоллекциюЛкс(ирКэш.ОткрытыеФормыПодсистемыЛкс());
	Для Каждого Форма Из ОткрытыеФормы Цикл
		Если ирОбщий.МетодРеализованЛкс(Форма, "ОбработкаОповещения") Тогда
			Форма.ОбработкаОповещения(ИмяСобытия, Параметр, Источник);
		КонецЕсли; 
	КонецЦикла;
КонецПроцедуры

Процедура ОповеститьИсследователиОбъектовЛкс(Знач ЭтаФорма, Знач Значение, Знач Выражение = "") Экспорт 
	
	Структура = Новый Структура("Значение", Значение);
	Если ЗначениеЗаполнено(Выражение) Тогда
		Структура.Вставить("Выражение", Выражение);
	КонецЕсли;
	ОповеститьФормыПодсистемыЛкс("Исследовать", Структура, ЭтаФорма);

КонецПроцедуры

Процедура ПредложитьЗакрытьМодальнуюФормуЛкс(ЭтаФорма) Экспорт 
	
	Если ЭтаФорма.МодальныйРежим Тогда
		Ответ = Вопрос("Хотите закрыть текущую форму, чтобы открыть новую форму немодально?", РежимДиалогаВопрос.ДаНет);
		Если Ответ = КодВозвратаДиалога.Да Тогда
			ЭтаФорма.Закрыть();
		КонецЕсли;
	КонецЕсли;

КонецПроцедуры

Функция ЗапроситьСохранениеДанныхФормыЛкс(ЭтаФорма, Отказ = Ложь) Экспорт 
	
	Если ЭтаФорма.Модифицированность Тогда
		ПередОтображениемДиалогаПередЗакрытиемФормыЛкс(ЭтаФорма);
		Ответ = Вопрос("Данные в форме были изменены. Сохранить изменения?", РежимДиалогаВопрос.ДаНетОтмена);
		Если Ответ = КодВозвратаДиалога.Отмена Тогда
			Отказ = Истина;
		Иначе
			ЭтаФорма.Модифицированность = Ложь;
		КонецЕсли;
	КонецЕсли;
	Возврат Ответ;

КонецФункции

Функция ЗаголовокДляКопииОбъектаЛкс(ЭтаФорма) Экспорт 
	
	Возврат ирОбщий.ПоследнийФрагментЛкс(ЭтаФорма.Заголовок, ": ", Ложь) + " - " + ирОбщий.ТекущееВремяЛкс();

КонецФункции

Функция ПериодОчисткиМенеджераВременныхТаблицЛкс(выхПоУмолчаниюОчищать = Ложь) Экспорт 
	
	ПараметрыОчистки = ирОбщий.ВосстановитьЗначениеЛкс("ПредлагатьОчиститьМенеджерВременныхТаблицЧерезМинут");
	Если ТипЗнч(ПараметрыОчистки) = Тип("Структура") Тогда
		Период = ПараметрыОчистки.Период;
		выхПоУмолчаниюОчищать = ПараметрыОчистки.ПоУмолчаниюОчищать;
	Иначе
		Период = ПараметрыОчистки;
		выхПоУмолчаниюОчищать = Ложь;
	КонецЕсли; 
	Если Период = Неопределено Тогда 
		Период = 60;
	ИначеЕсли Период < 1 Тогда 
		Период = 1;
	ИначеЕсли Период > 240 Тогда 
		Период = 240;
	КонецЕсли;
	Возврат Период;

КонецФункции

Процедура ПередОтображениемДиалогаПередЗакрытиемФормыЛкс(Знач ЭтаФорма) Экспорт 
	
	Если ирКэш.ЛиСеансТолстогоКлиентаУПЛкс() Тогда 
		ЭтаФорма.Открыть(); // http://www.hostedredmine.com/issues/881581
	КонецЕсли;

КонецПроцедуры

Процедура КоманднаяПанельВставитьКнопкиГлобальныхКомандЛкс(Знач КоманднаяПанельПолеВвода)
	
	#Если ТолстыйКлиентОбычноеПриложение Тогда
		Если ЛиПерехватКлавиатурногоВводаВОбычномПриложенииЛкс() Тогда
			Возврат;
		КонецЕсли;
	#Иначе
		Возврат;
	#КонецЕсли
	КнопкаКопировать = КоманднаяПанельПолеВвода.Кнопки.Добавить();
	КнопкаКопировать.ТипКнопки = ТипКнопкиКоманднойПанели.Действие;
	Попытка
		КнопкаКопировать.Действие = Новый Действие("КлсКомандаНажатие");
	Исключение
		КоманднаяПанельПолеВвода.Кнопки.Удалить(КнопкаКопировать);
		Возврат;
	КонецПопытки; 
	КнопкаКопировать.Имя = "БуферОбмена_Копировать";
	КнопкаКопировать.Текст = "Копировать значение";
	КнопкаКопировать.Подсказка = "Копировать значение в буфер обмена";
	КнопкаКопировать.Пояснение = КнопкаКопировать.Подсказка;
	КнопкаКопировать.СочетаниеКлавиш = Новый СочетаниеКлавиш(Клавиша.C, Истина, , Истина); // ALT+SHIFT+C
	КнопкаКопировать.Картинка = ирКэш.КартинкаПоИмениЛкс("ирКопировать");
	КнопкаВставить = КоманднаяПанельПолеВвода.Кнопки.Добавить();
	КнопкаВставить.Имя = "БуферОбмена_Вставить";
	КнопкаВставить.ТипКнопки = ТипКнопкиКоманднойПанели.Действие;
	КнопкаВставить.Текст = "Вставить значение";
	КнопкаВставить.Подсказка = "Вставить значение из буфера обмена";
	КнопкаВставить.Пояснение = КнопкаВставить.Подсказка;
	КнопкаВставить.СочетаниеКлавиш = Новый СочетаниеКлавиш(Клавиша.V, Истина, , Истина); // ALT+SHIFT+V
	КнопкаВставить.Действие = Новый Действие("КлсКомандаНажатие");
	КнопкаВставить.Картинка = ирКэш.КартинкаПоИмениЛкс("ирВставить");
	//КнопкаМеню = КоманднаяПанельПолеВвода.Кнопки.Добавить();
	//КнопкаМеню.Имя = "ОткрытьГлобальноеМеню";
	//КнопкаМеню.ТипКнопки = ТипКнопкиКоманднойПанели.Действие;
	//КнопкаМеню.Текст = "Глобальное меню";
	//КнопкаМеню.Подсказка = "Открыть глобальное меню";
	//КнопкаМеню.Пояснение = КнопкаМеню.Подсказка;
	//КнопкаМеню.СочетаниеКлавиш = Новый СочетаниеКлавиш(Клавиша.E, Истина, Истина); // CTRL+ALT+E
	//КнопкаМеню.Действие = Новый Действие("КлсКомандаНажатие");
	
КонецПроцедуры

Функция ЛиПерехватКлавиатурногоВводаЛкс() Экспорт
	
	//Возврат Ложь; // для отладки
	Если Ложь
		Или Не ирКэш.ЛиПлатформаWindowsЛкс()
		Или Найти(ПараметрЗапуска, "ОтключитьПерехватКлавиатурыИР") > 0 
	Тогда
		Результат = Ложь;
	Иначе
		#Если ТолстыйКлиентОбычноеПриложение Тогда
			Результат = ЛиПерехватКлавиатурногоВводаВОбычномПриложенииЛкс();
		#Иначе
			Результат = Истина;
		#КонецЕсли
	КонецЕсли; 
	Возврат Результат;
	
КонецФункции

Функция ЛиПерехватКлавиатурногоВводаВОбычномПриложенииЛкс() Экспорт
	
	Результат = ирКэш.Получить().ПерехватКлавиатурногоВводаВОбычномПриложении;
	Возврат Результат;
	
КонецФункции

Процедура УниверсальнаяКомандаФормыЛкс(Знач ЭтаФорма, Знач Кнопка, Знач ИсточникДействий = Неопределено, Знач МетаданныеВыбора = Неопределено) Экспорт 
	
	СлужебныеДанныеФормы = ирОбщий.СлужебныеДанныеФормыЛкс(ЭтаФорма);
	Если Кнопка.Имя = "БуферОбмена_Копировать" Тогда 
		// Только в обычном приложении с отключенным перехватом клавиатурного ввода
		БуферОбмена_КопироватьЛкс(ЭтаФорма);
	ИначеЕсли Кнопка.Имя = "БуферОбмена_Вставить" Тогда 
		// Только в обычном приложении с отключенным перехватом клавиатурного ввода
		БуферОбмена_ВставитьЛкс(ЭтаФорма);
	ИначеЕсли Кнопка.Имя = "ОткрытьГлобальноеМеню" Тогда 
		Если Не ЛиПерехватКлавиатурногоВводаЛкс() Тогда
			ОткрытьГлобальноеМенюЛкс(ЭтаФорма);
		КонецЕсли; 
	ИначеЕсли Кнопка.Имя = "ОПодсистеме" Тогда 
		ОткрытьСправкуПоПодсистемеЛкс(ЭтаФорма);
	ИначеЕсли Кнопка.Имя = "СтруктураФормы" Тогда 
		ОткрытьСтруктуруФормыЛкс(ЭтаФорма, ЭтаФорма);
	ИначеЕсли Кнопка.Имя = "НовоеОкно" Тогда 
		ОткрытьНовоеОкноФормыЛкс(ЭтаФорма);
	ИначеЕсли Кнопка.Имя = "ЗагрузитьНастройку" Тогда 
		ВыбратьИЗагрузитьНастройкуФормыЛкс(ЭтаФорма);
	ИначеЕсли Кнопка.Имя = "СохранитьНастройку" Тогда 
		ВыбратьИСохранитьНастройкуФормыЛкс(ЭтаФорма);
	ИначеЕсли Кнопка.Имя = "ЗагрузитьНастройкуИзФайла" Тогда 
		Если Не ПроверитьЗавершениеФоновыхЗаданийФормыЛкс(ЭтаФорма) Тогда 
			ирОбщий.СообщитьЛкс("Нельзя выполнять загрузку настроек, пока форма выполняет фоновые задания");
			Возврат;
		КонецЕсли; 
		НастройкаФормы = ЗагрузитьЗначениеИзФайлаИнтерактивноЛкс(СлужебныеДанныеФормы.МенеджерСохраненияНастроек.РасширениеФайла, "Настройка """ + ирОбщий.ПервыйФрагментЛкс(ЭтаФорма.Заголовок, ":") + """");
		Если НастройкаФормы <> Неопределено Тогда
			ЗагрузитьНастройкуФормыЧерезОбработчикЛкс(ЭтаФорма, НастройкаФормы);
		КонецЕсли; 
	ИначеЕсли Кнопка.Имя = "СохранитьНастройкуВФайл" Тогда 
		НастройкаФормы = СохраняемаяНастройкаФормыЛкс(ЭтаФорма);
		Если НастройкаФормы <> Неопределено Тогда
			СохранитьЗначениеВФайлИнтерактивноЛкс(НастройкаФормы, СлужебныеДанныеФормы.МенеджерСохраненияНастроек.РасширениеФайла, "Настройка """ + ирОбщий.ПервыйФрагментЛкс(ЭтаФорма.Заголовок, ":") + """");
		КонецЕсли; 
	Иначе
		Если ИсточникДействий = Неопределено Тогда
			ИсточникДействий = КоманднаяПанельКнопкиЛкс(ЭтаФорма, Кнопка).ИсточникДействий;
		КонецЕсли; 
		Если ИсточникДействий = Неопределено Тогда
			ИсточникДействий = ЭтаФорма.ТекущийЭлемент;
		КонецЕсли;
		Если ТипЗнч(ИсточникДействий) = Тип("ПолеТабличногоДокумента") Тогда
			#Если Сервер И Не Сервер Тогда
				ИсточникДействий = Новый ТабличныйДокумент;
			#КонецЕсли
			Если Кнопка.Имя = "Автосумма" Тогда 
				Кнопка.Пометка = Не Кнопка.Пометка;
				ИсточникДействий.ТекущаяОбласть = ИсточникДействий.ТекущаяОбласть;
			КонецЕсли;
		ИначеЕсли ТипЗнч(ИсточникДействий) = Тип("ТабличноеПоле") Тогда
			#Если Сервер И Не Сервер Тогда
				ИсточникДействий = Новый ТабличноеПоле;
			#КонецЕсли
			Если Кнопка.Имя = "ПереместитьВверх" Тогда 
				ТабличноеПолеСдвинутьВыделенныеСтрокиЛкс(ИсточникДействий, -1);
			ИначеЕсли Кнопка.Имя = "ПереместитьВниз" Тогда 
				ТабличноеПолеСдвинутьВыделенныеСтрокиЛкс(ИсточникДействий, +1);
			ИначеЕсли Кнопка.Имя = "ПереместитьВНачало" Тогда 
				ТабличноеПолеСдвинутьВыделенныеСтрокиЛкс(ИсточникДействий, -100000);
			ИначеЕсли Кнопка.Имя = "ПереместитьВКонец" Тогда 
				ТабличноеПолеСдвинутьВыделенныеСтрокиЛкс(ИсточникДействий, +100000);
			ИначеЕсли Кнопка.Имя = "СортироватьПоВозрастанию" Тогда 
				ТабличноеПолеСортироватьЛкс(ЭтаФорма, ИсточникДействий, Истина);
			ИначеЕсли Кнопка.Имя = "СортироватьПоУбыванию" Тогда 
				ТабличноеПолеСортироватьЛкс(ЭтаФорма, ИсточникДействий, Ложь);
			ИначеЕсли Кнопка.Имя = "ПоказыватьИтоги" Тогда 
				ТабличноеПолеКнопкаОтображенияИтоговНажатиеЛкс(ЭтаФорма, ИсточникДействий, Кнопка);
			ИначеЕсли Кнопка.Имя = "Идентификаторы" Тогда 
				КнопкаОтображатьПустыеИИдентификаторыНажатиеЛкс(Кнопка);
				ИсточникДействий.ОбновитьСтроки();
			ИначеЕсли Кнопка.Имя = "СжатьКолонки" Тогда 
				СжатьКолонкиТабличногоПоляЛкс(ИсточникДействий);
			ИначеЕсли Кнопка.Имя = "ШиринаКолонок" Тогда 
				РасширитьКолонкиТабличногоПоляЛкс(ИсточникДействий);
			ИначеЕсли Кнопка.Имя = "ГруппировкаТаблицы" Тогда 
				КомпоновкаТП = КомпоновкаТабличногоПоляЛкс(ЭтаФорма, ИсточникДействий);
				Если КомпоновкаТП <> Неопределено Тогда 
					НастройкаКомпоновки = КомпоновкаТП.Компоновщик.Настройки;
				КонецЕсли;
				ОткрытьГруппировкуТабличногоПоляЛкс(ИсточникДействий, НастройкаКомпоновки);
			ИначеЕсли Кнопка.Имя = "АнализДанных" Тогда 
				ФормаАнализа = ПолучитьФормуЛкс("Обработка.ирАнализДанных.Форма",, ЭтаФорма);
				ФормаАнализа.ПараметрТаблица = ИсточникДействий.Значение;
				ФормаАнализа.ПараметрИмяКолонки = ирОбщий.ПутьКДаннымКолонкиТабличногоПоляЛкс(ИсточникДействий);
				ФормаАнализа.Открыть();
			ИначеЕсли Кнопка.Имя = "МенеджерТабличногоПоля" Тогда 
				ОткрытьМенеджерТабличногоПоляЛкс(ИсточникДействий, ЭтаФорма,, МетаданныеВыбора);
			ИначеЕсли Кнопка.Имя = "УстановитьЗначениеВКолонке" Тогда 
				ОткрытьМенеджерТабличногоПоляЛкс(ИсточникДействий, ЭтаФорма, "Обработка", МетаданныеВыбора);
			ИначеЕсли Кнопка.Имя = "ЗагрузитьСтроки" Тогда 
				ЗагрузитьСтрокиВТабличноеПолеЛкс(ЭтаФорма, ИсточникДействий);
			ИначеЕсли Кнопка.Имя = "РазличныеЗначенияКолонки" Тогда 
				ОткрытьРазличныеЗначенияКолонкиЛкс(ИсточникДействий,,, ЭтаФорма);
			ИначеЕсли Кнопка.Имя = "РедакторОбъектаБД" Тогда 
				ПредложитьЗакрытьМодальнуюФормуЛкс(ЭтаФорма);
				ОткрытьСсылкуЯчейкиВРедактореОбъектаБДЛкс(ИсточникДействий);
			ИначеЕсли Кнопка.Имя = "КонсольОбработки" Тогда 
				ОткрытьОбъектыИзВыделенныхЯчеекВПодбореИОбработкеОбъектовЛкс(ИсточникДействий,, ЭтаФорма);
			ИначеЕсли Кнопка.Имя = "ОбработатьОбъекты" Тогда 
				ПредложитьЗакрытьМодальнуюФормуЛкс(ЭтаФорма);
				ОткрытьПодборИОбработкуОбъектовИзДинамическогоСпискаЛкс(ИсточникДействий);
			ИначеЕсли Кнопка.Имя = "ВывестиСтроки" Тогда 
				ВывестиСтрокиТабличногоПоляИПоказатьЛкс(ЭтаФорма, ИсточникДействий);
			ИначеЕсли Кнопка.Имя = "КонсольКомпоновки" Тогда 
				ПредложитьЗакрытьМодальнуюФормуЛкс(ЭтаФорма);
				ОткрытьДанныеТабличногоПоляВКонсолиКомпоновкиЛкс(ЭтаФорма, ИсточникДействий);
			ИначеЕсли Кнопка.Имя = "Сравнить" Тогда 
				ЗапомнитьСодержимоеЭлементаФормыДляСравненияЛкс(ЭтаФорма, ИсточникДействий);
			ИначеЕсли Кнопка.Имя = "СравнитьСтроки" Тогда 
				ТабличноеПолеИлиТаблицаФормы_СравнитьСтрокиЛкс(ЭтаФорма, ИсточникДействий);
			ИначеЕсли Кнопка.Имя = "ЗаполнитьГруппыДублейДляЗамены" Тогда 
				ПредложитьЗакрытьМодальнуюФормуЛкс(ЭтаФорма);
				ОткрытьФормуЗаменыСсылокИзТабличногоПоляЛкс(ИсточникДействий);
			ИначеЕсли Кнопка.Имя = "ОткрытьКоллекцию" Тогда 
				ОткрытьЗначениеЛкс(ИсточникДействий.Значение,,,, Ложь,, ИсточникДействий);
			ИначеЕсли Кнопка.Имя = "ОткрытьКопиюКоллекции" Тогда 
				КопияКоллекции = ТаблицаИлиДеревоЗначенийИзТаблицыФормыСКоллекциейЛкс(ИсточникДействий,,, Ложь,,, ЭтаФорма);
				ОткрытьЗначениеЛкс(КопияКоллекции,,,, Ложь,, ИсточникДействий);
			ИначеЕсли Кнопка.Имя = "СвернутьДерево" Тогда 
				ДеревоЗначенийСвернутьРазвернутьЛкс(ИсточникДействий, Истина);
			ИначеЕсли Кнопка.Имя = "РазвернутьДерево" Тогда 
				ДеревоЗначенийСвернутьРазвернутьЛкс(ИсточникДействий, Ложь);
			ИначеЕсли Кнопка.Имя = "ДеревоСвернутьОстальные" Тогда 
				ТабличноеПолеДеревоЗначений_СвернутьВсеСтрокиЛкс(ИсточникДействий, Истина);
			ИначеЕсли Кнопка.Имя = "Очистить" Тогда 
				ИсточникДействий.Значение.Очистить();
			ИначеЕсли Кнопка.Имя = "ОтборПоЗначениюВТекущейКолонке" Тогда 
				Если ТипЗнч(ИсточникДействий.Значение) <> Тип("ДеревоЗначений") Тогда
					ТабличноеПолеОтборДляЗначенияВТекущейКолонкеЛкс(ИсточникДействий, Истина,,,, ЭтаФорма);
				КонецЕсли; 
			ИначеЕсли Кнопка.Имя = "ОтборБезЗначенияВТекущейКолонке" Тогда 
				Если ТипЗнч(ИсточникДействий.Значение) <> Тип("ДеревоЗначений") Тогда
					ТабличноеПолеОтборДляЗначенияВТекущейКолонкеЛкс(ИсточникДействий, Ложь,,,, ЭтаФорма);
				КонецЕсли; 
			ИначеЕсли Кнопка.Имя = "УстановитьФлажки" Тогда 
				ИзменитьПометкиВыделенныхИлиОтобранныхСтрокЛкс(ЭтаФорма, ИсточникДействий,, Истина,,, Истина);
			ИначеЕсли Кнопка.Имя = "СнятьФлажки" Тогда 
				ИзменитьПометкиВыделенныхИлиОтобранныхСтрокЛкс(ЭтаФорма, ИсточникДействий,, Ложь,,, Истина);
			ИначеЕсли Кнопка.Имя = "СколькоСтрок" Тогда 
				ТабличноеПолеИлиТаблицаФормы_СколькоСтрокЛкс(ИсточникДействий);
			ИначеЕсли Кнопка.Имя = "НастроитьКолонки" Тогда 
				ОткрытьНастройкуКолонокТабличногоПоляЛкс(ЭтаФорма, ИсточникДействий);
			ИначеЕсли Кнопка.Имя = "СвойстваСтроки" Тогда 
				ОткрытьРедакторСтрокиТаблицыЛкс(ЭтаФорма, ИсточникДействий);
			ИначеЕсли ирОбщий.СтрНачинаетсяСЛкс(Кнопка.Имя, ирОбщий.НачалоИмениКнопкиПодменюПоследнихВыбранныхЛкс("Отборы")) Тогда 
				НастройкаКомпоновки = ВыбранныйЭлементПоследнихЗначенийЛкс(ЭтаФорма, ИсточникДействий, Кнопка, "Отборы", Истина);
				#Если Сервер И Не Сервер Тогда
					НастройкаКомпоновки = Новый НастройкиКомпоновкиДанных;
				#КонецЕсли
				ПутьКДанным = "ЭлементыФормы." + ИсточникДействий.Имя + ".Отбор";
				ЭтаФорма.ОтключитьОбработчикИзмененияДанных(ПутьКДанным);
				ирОбщий.СкопироватьОтборЛюбойЛкс(ИсточникДействий.ОтборСтрок, НастройкаКомпоновки.Отбор);
				Попытка
					ЭтаФорма.ОбработчикИзмененияДанных(ПутьКДанным);
				Исключение
					// Временно пропускаем такие ошибки
					ирОбщий.СообщитьЛкс(ОписаниеОшибки());
				КонецПопытки;
			Иначе
				ВызватьИсключение "Неизвестное имя команды (" + Кнопка.Имя + ")";
			КонецЕсли; 
		КонецЕсли; 
	КонецЕсли; 
	
КонецПроцедуры

Процедура ОткрытьНастройкуКолонокТабличногоПоляЛкс(Знач ЭтаФорма, Знач ИсточникДействий) Экспорт 
	
	мНастройкаКолонок = ирОбщий.СоздатьОбъектПоИмениМетаданныхЛкс("Обработка.ирДинамическийСписок");
	#Если Сервер И Не Сервер Тогда
		мНастройкаКолонок = Обработки.ирДинамическийСписок.Создать();
	#КонецЕсли
	ФормаНастроек = мНастройкаКолонок.ПолучитьФорму("НастройкиКолонок", ЭтаФорма);
	ФормаНастроек.ПрочитатьНастройкиКолонокИзТабличногоПоля(ИсточникДействий);
	ФормаНастроек.СвязанноеТабличноеПоле = ИсточникДействий;
	ФормаНастроек.ПараметрРучноеСохранение = Истина;
	ВыбранноеЗначение = ФормаНастроек.ОткрытьМодально();
	//Если ВыбранноеЗначение <> Неопределено Тогда
	//	мНастройкаКолонок.ПрименитьНастройкиКолонокКТабличномуПолю(ИсточникДействий, ВыбранноеЗначение);
	//КонецЕсли;

КонецПроцедуры

Процедура ОткрытьТаблицуВКонсолиКомпоновкиЛкс(Знач Таблица, Знач КомпоновкаТП = Неопределено) Экспорт 
	
	КонсольКомпоновокДанных = ирОбщий.СоздатьОбъектПоИмениМетаданныхЛкс("Обработка.ирКонсольКомпоновокДанных");
	#Если Сервер И Не Сервер Тогда
		КонсольКомпоновокДанных = Обработки.ирКонсольКомпоновокДанных.Создать();
		Таблица = Новый ТаблицаЗначений;
	#КонецЕсли
	Если КомпоновкаТП <> Неопределено Тогда 
		НастройкаКомпоновки = КомпоновкаТП.Компоновщик.Настройки;
	КонецЕсли;
	КонсольКомпоновокДанных.ОткрытьПоТаблицеЗначений(Таблица, НастройкаКомпоновки);

КонецПроцедуры 

Процедура ОткрытьДанныеТабличногоПоляВКонсолиКомпоновкиЛкс(Знач ЭтаФорма, Знач ТабличноеПоле, Знач НастройкаКомпоновки = Неопределено) Экспорт 
	
	КонсольКомпоновокДанных = ирОбщий.СоздатьОбъектПоИмениМетаданныхЛкс("Обработка.ирКонсольКомпоновокДанных");
	#Если Сервер И Не Сервер Тогда
		КонсольКомпоновокДанных = Обработки.ирКонсольКомпоновокДанных.Создать();
	#КонецЕсли
	КомпоновкаТП = КомпоновкаТабличногоПоляЛкс(ЭтаФорма, ТабличноеПоле);
	Если КомпоновкаТП <> Неопределено Тогда 
		Если НастройкаКомпоновки = Неопределено Тогда
			НастройкаКомпоновки = КомпоновкаТП.Компоновщик.Настройки;
		КонецЕсли;
		ирОбщий.УстановитьПараметрыВыводаКомпоновкиПоУмолчаниюЛкс(НастройкаКомпоновки);
	КонецЕсли;
	КопияКоллекции = ТаблицаИлиДеревоЗначенийИзТаблицыФормыСКоллекциейЛкс(ТабличноеПоле,,,,,, ЭтаФорма);
	ВнешниеНаборыДанных = Новый Структура("Основной", КопияКоллекции);
	КонсольКомпоновокДанных.ОткрытьПоТабличномуПолю(ТабличноеПоле,, НастройкаКомпоновки, ВнешниеНаборыДанных);

КонецПроцедуры

// Родственник ВернутьПостоянныйПарольПользователяЛкс
// Пароль устанавливается временный и опционально роль ирРазработчик
Функция УстановитьВременныеСвойстваПользователюИБЛкс(ПользовательИБ, ПодменитьПарольНаВремяЗапуска = Истина, ВременноПредоставитьПравоРазработчикИР = Истина,
	ОтключитьЗащитуОтОпасныхДействийНаВремяЗапуска = Истина, ЯзыкКонфигурации = "", ПользовательДобавляемыхРолей = "") Экспорт
	
	#Если Сервер И Не Сервер Тогда
	    ПользовательИБ = ПользователиИнформационнойБазы.СоздатьПользователя();
	#КонецЕсли
	мПлатформа = ирКэш.Получить();
	НужноВернутьАутентификациюОС = Ложь;
	НужноВернутьАутентификациюПаролем = Ложь;
	НужноВернутьПароль = Ложь;
	НужноВернутьЗащитуОтОпасныхДействий = Ложь;
	НужноВернутьЯзыкКонфигурации = Ложь;
	УдалитьРоли = Новый СписокЗначений;
	Если ПодменитьПарольНаВремяЗапуска Тогда
		Если ирОбщий.СтрокиРавныЛкс(ПользовательИБ.Имя, ИмяПользователя()) Тогда
			ирОбщий.СообщитьЛкс("Назначение временного пароля собственному пользователю не допускается");
			Возврат Неопределено;
		КонецЕсли; 
		мhash = ПользовательИБ.СохраняемоеЗначениеПароля;
		Если ПользовательИБ.АутентификацияОС = Истина Тогда 
			ПользовательИБ.АутентификацияОС = Ложь;
			НужноВернутьАутентификациюОС = Истина;
		КонецЕсли;
		Если ПользовательИБ.АутентификацияСтандартная = Ложь Тогда 
			ПользовательИБ.АутентификацияСтандартная = Истина;
			НужноВернутьАутентификациюПаролем = Истина;
		КонецЕсли;
		Пароль = Формат(ТекущаяДата(), "ДФ=HHmmss") + XMLСтрока(НомерСеансаИнформационнойБазы()) + "!_qQ";
	    ПользовательИБ.Пароль = Пароль;
		НужноВернутьПароль = Истина;
	КонецЕсли; 
	Если ВременноПредоставитьПравоРазработчикИР И Не ирКэш.ЛиПортативныйРежимЛкс() Тогда
		Роль = Метаданные.Роли.ирРазработчик;
		Если Не ПользовательИБ.Роли.Содержит(Роль) Тогда
			УдалитьРоли.Добавить(Роль);
			ПользовательИБ.Роли.Добавить(Роль);
		КонецЕсли; 
	КонецЕсли;
	Если ЗначениеЗаполнено(ПользовательДобавляемыхРолей) Тогда
		ПользовательДобавляемыхРолейИБ = ПользователиИнформационнойБазы.НайтиПоИмени(ПользовательДобавляемыхРолей);
		Для Каждого Роль Из ПользовательДобавляемыхРолейИБ.Роли Цикл
			Если Не ПользовательИБ.Роли.Содержит(Роль) Тогда
				УдалитьРоли.Добавить(Роль);
				ПользовательИБ.Роли.Добавить(Роль);
			КонецЕсли; 
		КонецЦикла;
		УдалитьРоли.СортироватьПоЗначению();
		Для Каждого Роль Из УдалитьРоли Цикл
			ирОбщий.СообщитьЛкс("Добавлена роль - " + Роль.Значение);
		КонецЦикла;
	КонецЕсли; 
	Если УдалитьРоли.Количество() > 0 Тогда
		ПользовательИБ.ПолноеИмя = ПользовательИБ.ПолноеИмя + ирОбщий.МаркерВременныхРолейЛкс();
	КонецЕсли;
	Если ЗначениеЗаполнено(ЯзыкКонфигурации) Тогда
		НужноВернутьЯзыкКонфигурации = Истина;
		СтарыйЯзыкКонфигурации = ПользовательИБ.Язык;
		Если СтарыйЯзыкКонфигурации <> Неопределено Тогда
			СтарыйЯзыкКонфигурации = СтарыйЯзыкКонфигурации.Имя;
		КонецЕсли; 
		ПользовательИБ.Язык = Метаданные.Языки[ЯзыкКонфигурации];
	КонецЕсли; 
	Если ОтключитьЗащитуОтОпасныхДействийНаВремяЗапуска Тогда
		Если ирКэш.ДоступнаЗащитаОтОпасныхДействийЛкс() И ПользовательИБ.ЗащитаОтОпасныхДействий.ПредупреждатьОбОпасныхДействиях Тогда
			ПользовательИБ.ЗащитаОтОпасныхДействий.ПредупреждатьОбОпасныхДействиях = Ложь;
			НужноВернутьЗащитуОтОпасныхДействий = Истина;
		КонецЕсли; 
	КонецЕсли; 
    ПользовательИБ.Записать();
	НаборПараметров = Новый Структура();
	НаборПараметров.Вставить("mHash", мhash);
	НаборПараметров.Вставить("НужноВернутьАутентификациюПаролем", НужноВернутьАутентификациюПаролем);
    НаборПараметров.Вставить("НужноВернутьАутентификациюОС", НужноВернутьАутентификациюОС);
	НаборПараметров.Вставить("ПользовательИБ", ПользовательИБ);
	НаборПараметров.Вставить("НужноВернутьПароль", НужноВернутьПароль);
	НаборПараметров.Вставить("НужноВернутьЗащитуОтОпасныхДействий", НужноВернутьЗащитуОтОпасныхДействий);
	НаборПараметров.Вставить("УдалитьРоли", УдалитьРоли);
	НаборПараметров.Вставить("Имя", ПользовательИБ.Имя);
	НаборПараметров.Вставить("Пароль", Пароль);
	НаборПараметров.Вставить("НужноВернутьЯзыкКонфигурации", НужноВернутьЯзыкКонфигурации);
	НаборПараметров.Вставить("ЯзыкКонфигурации", СтарыйЯзыкКонфигурации);
	Возврат НаборПараметров;
	
КонецФункции

// Родственник УстановитьВременныеСвойстваПользователюИБЛкс
Процедура ВернутьПостоянныеСвойстваПользователюИБЛкс(НаборПараметров = Неопределено) Экспорт;
	
	//УстановитьПривилегированныйРежим(Истина); 
	Если НаборПараметров <> Неопределено Тогда
		мhash = НаборПараметров.mhash;
		ЯзыкКонфигурации = НаборПараметров.ЯзыкКонфигурации;
		НужноВернутьАутентификациюПаролем = НаборПараметров.НужноВернутьАутентификациюПаролем;
		НужноВернутьАутентификациюОС = НаборПараметров.НужноВернутьАутентификациюОС;
		НужноВернутьПароль = НаборПараметров.НужноВернутьПароль;
		НужноВернутьЗащитуОтОпасныхДействий = НаборПараметров.НужноВернутьЗащитуОтОпасныхДействий;
		НужноВернутьЯзыкКонфигурации = НаборПараметров.НужноВернутьЯзыкКонфигурации;
		ПользовательИБ = НаборПараметров.ПользовательИБ;
		УдалитьРоли = НаборПараметров.УдалитьРоли;
		#Если Сервер И Не Сервер Тогда
			УдалитьРоли = Новый СписокЗначений;
		#КонецЕсли
	Иначе
		Возврат;
	КонецЕсли;
	#Если Сервер И Не Сервер Тогда
		ПользовательИБ = ПользователиИнформационнойБазы.ТекущийПользователь();
	#КонецЕсли
	Если НужноВернутьПароль Тогда
		ПользовательИБ.СохраняемоеЗначениеПароля = мHash;
	КонецЕсли; 
	Если НужноВернутьАутентификациюПаролем Тогда 
		ПользовательИБ.АутентификацияСтандартная = Ложь; 
	КонецЕсли;
	Если НужноВернутьАутентификациюОС Тогда 
		ПользовательИБ.АутентификацияОС = Истина; 
	КонецЕсли;
	Если НужноВернутьЗащитуОтОпасныхДействий И ирКэш.ДоступнаЗащитаОтОпасныхДействийЛкс() Тогда 
		ПользовательИБ.ЗащитаОтОпасныхДействий.ПредупреждатьОбОпасныхДействиях = Истина; 
	КонецЕсли;
	Если УдалитьРоли.Количество() > 0 Тогда 
		Для Каждого Роль Из УдалитьРоли Цикл
			ПользовательИБ.Роли.Удалить(Роль.Значение);
		КонецЦикла;
		ПользовательИБ.ПолноеИмя = ирОбщий.СтрокаБезПоследнегоФрагментаЛкс(ПользовательИБ.ПолноеИмя, ирОбщий.МаркерВременныхРолейЛкс());
	КонецЕсли; 
	Если НужноВернутьЯзыкКонфигурации Тогда
		ПользовательИБ.Язык = Метаданные.Языки[ЯзыкКонфигурации];
	КонецЕсли; 
	ПользовательИБ.Записать();
	
КонецПроцедуры

Процедура НастроитьПоляВводаПараметровПотоковЛкс(ЭтаФорма, ЕстьКоличествоОбъектовВПорции = Истина) Экспорт 
	
	ЭлементыФормы = ЭтаФорма.ЭлементыФормы;
	Если ЕстьКоличествоОбъектовВПорции Тогда
		СписокВыбора = ЭлементыФормы.КоличествоОбъектовВПорции.СписокВыбора;
		СписокВыбора.Добавить(1);
		СписокВыбора.Добавить(2);
		СписокВыбора.Добавить(5);
		СписокВыбора.Добавить(10);
		СписокВыбора.Добавить(20);
		СписокВыбора.Добавить(50);
		СписокВыбора.Добавить(100);
		СписокВыбора.Добавить(200);
	КонецЕсли;
	СписокВыбора = ЭлементыФормы.КоличествоПотоков.СписокВыбора;
	СписокВыбора.Добавить(1);
	СписокВыбора.Добавить(4);
	СписокВыбора.Добавить(8);
	СписокВыбора.Добавить(12);
	СписокВыбора.Добавить(16);

КонецПроцедуры

Функция ОткрытьМенеджерТабличногоПоляЛкс(Знач ТабличноеПоле = Неопределено, Знач ЭтаФорма, Знач АктивизироватьСтраницу = "", Знач МетаданныеВыбора = Неопределено) Экспорт 
	
	Если ТабличноеПоле = Неопределено Тогда
		ТабличноеПоле = ЭтаФорма.ТекущийЭлемент;
	КонецЕсли; 
	мПлатформа = ирКэш.Получить();
		#Если Сервер И Не Сервер Тогда
		    мПлатформа = Обработки.ирПлатформа.Создать();
		#КонецЕсли
	ФормаМенеджера = мПлатформа.ПолучитьФорму("МенеджерТабличногоПоля", ЭтаФорма);
	ФормаМенеджера.УстановитьСвязь(ТабличноеПоле, , АктивизироватьСтраницу, МетаданныеВыбора);
	Возврат ФормаМенеджера;
	
КонецФункции

Процедура ОткрытьСвязанныйСеансТонкогоКлиентаЛкс() Экспорт 
	Если ирОбщий.ПроверитьПлатформаНеWindowsЛкс() Тогда
		Возврат;
	КонецЕсли; 
	Результат = ирКэш.ПолучитьСеансТонкогоКлиентаЛкс();
	Если Результат = Неопределено Тогда
		Возврат;
	КонецЕсли; 
	Результат.Visible = Истина;
	Окна = Результат.ПолучитьОкна();
	СписокОткрытыхОбъектов = Новый СписокЗначений;
	Для Каждого Окно Из Окна Цикл
		Попытка
			Содержимое = Окно.Содержимое;
		Исключение
			// В 8.2 нет такого свойства
			Продолжить;
		КонецПопытки;
		Для Каждого Форма Из Содержимое Цикл
			Попытка
				СсылкаCOM = Форма.Parameters.Key;
			Исключение
				СсылкаCOM = Неопределено;
			КонецПопытки; 
			Если СсылкаCOM <> Неопределено Тогда
				ФрагментыИмениТипа = ирОбщий.СтрРазделитьЛкс(Форма.FormName);
				МассивПараметров = Новый Массив;
				МассивПараметров.Добавить(Новый УникальныйИдентификатор(Результат.String(СсылкаCOM.УникальныйИдентификатор())));
				Ссылка = Новый (Тип(ФрагментыИмениТипа[0] + "Ссылка." + ФрагментыИмениТипа[1]), МассивПараметров);
				СписокОткрытыхОбъектов.Добавить(Ссылка, ФрагментыИмениТипа[0] + "." + ФрагментыИмениТипа[1] + " - " + Ссылка);
			КонецЕсли; 
		КонецЦикла;
	КонецЦикла;
	Если СписокОткрытыхОбъектов.Количество() > 0 Тогда
		СписокОткрытыхОбъектов.СортироватьПоПредставлению();
		ВыбранныйЭлемент = СписокОткрытыхОбъектов.ВыбратьЭлемент("Выберите объект для открытия в редакторе объекта БД");
		Если ВыбранныйЭлемент <> Неопределено Тогда
			ОткрытьСсылкуВРедактореОбъектаБДЛкс(ВыбранныйЭлемент.Значение);
		КонецЕсли; 
	КонецЕсли; 
КонецПроцедуры

Процедура ОповеститьОЗаписиОбъектаЛкс(Знач ТипИлиМассив, Знач Источник = Неопределено, Знач ВсеТипыДляПодсистемы = Ложь) Экспорт
	
	Если ТипЗнч(ТипИлиМассив) <> Тип("Массив") Тогда
		ТипИлиМассив = ирОбщий.ЗначенияВМассивЛкс(ТипИлиМассив);
	КонецЕсли;
	ВсеТипыДляПодсистемыОповещены = Ложь;
	Если ТипИлиМассив.Количество() > 1 Или ВсеТипыДляПодсистемы Тогда
		ОповеститьФормыПодсистемыЛкс("ЗаписанОбъект",, Источник);
		ВсеТипыДляПодсистемыОповещены = Истина;
	КонецЕсли; 
	Для Каждого ТипИлиОбъект Из ТипИлиМассив Цикл
		Если Не ВсеТипыДляПодсистемыОповещены Тогда
			ОповеститьФормыПодсистемыЛкс("ЗаписанОбъект", ТипИлиОбъект, Источник);
		КонецЕсли; 
		Если ТипЗнч(ТипИлиОбъект) = Тип("Тип") Или ирОбщий.ЛиСсылкаНаОбъектБДЛкс(ТипИлиОбъект) Тогда
			ОповеститьОбИзменении(ТипИлиОбъект);
		КонецЕсли;
	КонецЦикла;
	
КонецПроцедуры

// Для оповещения об изменениях объектов в памяти клиентского приложения
Процедура ОповеститьОбИзмененииОбъектаВПамятиЛкс(Объект, Источник = Неопределено) Экспорт
	
	ОповеститьФормыПодсистемыЛкс("ИзмененОбъектВПамяти", Объект, Источник);
	
КонецПроцедуры

Функция ЛиНеудобнаяСсылкаДляОбработкиВыбораЛкс(Знач ВыбранноеЗначение) Экспорт 
	
	// Почему то для ссылок внешних источников данных оповещение о выборе устанавливает строковое значение
	XMLТип = XMLТипЗнч(ВыбранноеЗначение);
	Если Истина
		И XMLТип <> Неопределено
		И (Ложь
			Или Найти(XMLТип.ИмяТипа, "ExternalDataSourceTableRef.") > 0
			Или (Истина
				И ВыбранноеЗначение <> Неопределено
				И Метаданные.НайтиПоТипу(ТипЗнч(ВыбранноеЗначение)) <> Неопределено 
				И ирОбщий.РасширениеКонфигурацииОбъектаМДЛкс(ВыбранноеЗначение.Метаданные()) <> Неопределено))
	Тогда
		ЭтоНеудобнаяСсылка = Истина;
	Иначе
		ЭтоНеудобнаяСсылка = Ложь;
	КонецЕсли;
	Возврат ЭтоНеудобнаяСсылка;

КонецФункции  

Функция ОткрытьОбъектМетаданныхЛкс(ОбъектИлиПолноеИмяМД) Экспорт 
	
	Если ТипЗнч(ОбъектИлиПолноеИмяМД) = Тип("ОбъектМетаданных") Тогда
		ОбъектМД = ОбъектИлиПолноеИмяМД;
	Иначе
		ОбъектМД = ирОбщий.ПолучитьМетаданныеЛкс(ОбъектИлиПолноеИмяМД);
	КонецЕсли; 
	#Если Сервер И Не Сервер Тогда
	    ОбъектМД = Метаданные.НайтиПоТипу();
	#КонецЕсли
	Если ОбъектМД = Неопределено Тогда
		Возврат Неопределено;
	КонецЕсли; 
	ПолноеИмяМД = ОбъектМД.ПолноеИмя();
	Фрагменты = ирОбщий.СтрРазделитьЛкс(ПолноеИмяМД);
	Если Ложь
		Или ирОбщий.ПеревестиСтроку("ОбщийРеквизит") = Фрагменты[0]
		Или ирОбщий.ПеревестиСтроку("Подсистема") = Фрагменты[0]
		Или (Истина
			И Фрагменты.Количество() >= 4
			И Не ирОбщий.ЛиКорневойТипВнешнегоИсточникаДанныхЛкс(Фрагменты[0]))
	Тогда
		ирОбщий.ИсследоватьЛкс(ОбъектМД);
		Возврат Неопределено;
		// Для табличной части берем родителя
		//ПолноеИмяМД = ОбъектМД.Родитель().ПолноеИмя();
	КонецЕсли; 
	Форма = ПолучитьФормуЛкс("Обработка.ирИнтерфейснаяПанель.Форма");
	Форма.ПараметрИмяОбъектаМетаданных = ПолноеИмяМД;
	Форма.ПрименитьПараметрыФормы();
	Возврат Форма;
	
КонецФункции

Процедура ОткрытьОбъектМДИзТаблицыСИменамиТиповЛкс(Знач СтрокаТаблицы) Экспорт 
	
	Если Найти(СтрокаТаблицы.ИмяТипаЗначения, ".") > 0 Тогда
		Тип = Тип(СтрокаТаблицы.ИмяТипаЗначения);
		ОбъектМД = Метаданные.НайтиПоТипу(Тип);
		Если ОбъектМД <> Неопределено Тогда
			ОткрытьОбъектМетаданныхЛкс(ОбъектМД);
		КонецЕсли; 
	КонецЕсли;

КонецПроцедуры

Функция ОткрытьЗначенияФункциональныхОпцийЛкс(Знач ЗначенияОпций, Знач КлючУникальности) Экспорт 
	
	Если ЗначенияОпций = Неопределено Или ЗначенияОпций.Количество() = 0 Тогда
		Возврат Неопределено;
	КонецЕсли; 
	мПлатформа = ирКэш.Получить();
	#Если Сервер И Не Сервер Тогда
		мПлатформа = Обработки.ирПлатформа.Создать();
	#КонецЕсли
	ФормаПросмотра = мПлатформа.ПолучитьФорму("ЗначенияФункциональныхОпций", , КлючУникальности);
	ФормаПросмотра.НачальноеЗначениеВыбора = ЗначенияОпций;
	ФормаПросмотра.Открыть();
	Возврат ФормаПросмотра;

КонецФункции

Функция ОткрытьПользователяИБЛкс(Пользователь) Экспорт 
	
	ФормаПользователя = ПолучитьФормуЛкс("Обработка.ирРедакторПользователей.Форма.ПользовательИнфобазы",,, Пользователь);
	ФормаПользователя.ПользовательИБ = ПользователиИнформационнойБазы.НайтиПоИмени(Пользователь);
	ФормаПользователя.Открыть();
	Возврат ФормаПользователя;

КонецФункции

Функция ОбработкаОбъектИзФормыЛкс(ЭтаФорма) Экспорт 
	
	Если ТипЗнч(ЭтаФорма) = Тип("Форма") Тогда
		ОбработкаОбъект = ЭтаФорма;
	Иначе
		//ОбработкаОбъект = ЭтаФорма.РеквизитФормыВЗначение("фОбъект");
		Фрагменты = ирОбщий.СтрРазделитьЛкс(ЭтаФорма.ИмяФормы);
		ОбработкаОбъект = ДанныеФормыВЗначение(ЭтаФорма.фОбъект, Тип("ОбработкаОбъект." + Фрагменты[1]));
	КонецЕсли;
	Возврат ОбработкаОбъект;

КонецФункции

Процедура ПроверитьЗакрытьФормуПриОтказеЛкс(ЭтаФорма, Знач Отказ) Экспорт 
	
	// Антибаг платформы 8.3.11-12 Не работает установка параметра Отказ перед открытием обычной формы в управляемом приложении
	// https://partners.v8.1c.ru/forum/t/1713475/m/1713475
	Если ирКэш.ЛиСеансТолстогоКлиентаУПЛкс() Тогда 
		Если Отказ И Не ЭтаФорма.МодальныйРежим Тогда
			ЭтаФорма.Закрыть();
		КонецЕсли; 
	КонецЕсли

КонецПроцедуры

Функция КлючиСтрокБДИзТаблицыФормыЛкс(Форма = Неопределено, выхКлючТекущейСтроки = Неопределено, выхТаблицаФормыДинамическогоСписка = Неопределено, Знач НуженВидимыйПорядок = Истина,
	ИсключаяСсылкиМетаданных = Ложь) Экспорт 
	
	Результат = Новый Массив;
	Если Форма = Неопределено Тогда
		Форма = АктивнаяУправляемаяФормаЛкс();
	КонецЕсли; 
	Если Ложь
		Или ТипЗнч(Форма.ТекущийЭлемент) = Тип("ТаблицаФормы") 
		Или ТипЗнч(Форма.ТекущийЭлемент) = Тип("ТабличноеПоле")
	Тогда
		ТаблицаФормы = Форма.ТекущийЭлемент;
		Если ирОбщий.ЛиКлючСсылкиИлиРегистраЛкс(ТаблицаФормы.ТекущаяСтрока, ИсключаяСсылкиМетаданных) Тогда
			выхКлючТекущейСтроки = ТаблицаФормы.ТекущаяСтрока;
		КонецЕсли; 
		Ссылка = ТаблицаФормы.ТекущаяСтрока;
		ВыделенныеСтроки = ВыделенныеСтрокиТабличногоПоляЛкс(ТаблицаФормы, НуженВидимыйПорядок);
		Если ирОбщий.ЛиКлючСсылкиИлиРегистраЛкс(Ссылка, ИсключаяСсылкиМетаданных) Тогда
			выхТаблицаФормыДинамическогоСписка = ТаблицаФормы;
			Возврат ВыделенныеСтроки;
		КонецЕсли; 
		Структура = Новый Структура("Ссылка, Data");
		ДанныеПоля = Неопределено;
		Для Каждого ВыделеннаяСтрока Из ВыделенныеСтроки Цикл
			ДанныеСтроки = ДанныеСтрокиТабличногоПоляЛкс(ТаблицаФормы, ВыделеннаяСтрока, ДанныеПоля);
			ЗаполнитьЗначенияСвойств(Структура, ДанныеСтроки); 
			Ссылка = Структура["Ссылка"];
			Если ирОбщий.ЛиКлючСсылкиИлиРегистраЛкс(Ссылка, ИсключаяСсылкиМетаданных) Тогда
				Результат.Добавить(Ссылка);
			КонецЕсли;
			Ссылка = Структура["Data"];
			Если ирОбщий.ЛиКлючСсылкиИлиРегистраЛкс(Ссылка, ИсключаяСсылкиМетаданных) Тогда
				Результат.Добавить(Ссылка);
				Если ВыделеннаяСтрока = ТаблицаФормы.ТекущаяСтрока Тогда
					выхКлючТекущейСтроки = Ссылка;
				КонецЕсли; 
			КонецЕсли;
		КонецЦикла;
	КонецЕсли; 
	Возврат Результат;
	
КонецФункции

Функция ЗначенияВыделенныхЯчеекТаблицыЛкс(Форма = Неопределено, выхКлючТекущейСтроки = Неопределено, НуженВидимыйПорядок = Истина, Знач ТолькоСсылки = Истина) Экспорт 
	
	Результат = Новый Массив;
	Если Форма = Неопределено Тогда
		Форма = АктивнаяУправляемаяФормаЛкс();
	КонецЕсли; 
	Если ТипЗнч(Форма.ТекущийЭлемент) = Тип("ТаблицаФормы") Тогда
		ТаблицаФормы = Форма.ТекущийЭлемент;
		ТекущееПоле = ТаблицаФормы.ТекущийЭлемент;
		Если ТекущееПоле = Неопределено Тогда
			Возврат Результат;
		КонецЕсли;
		ПолноеИмяПоля = ТекущееПоле.Имя;
		ПутьКДанным = Null;
		ДанныеПоля = Неопределено;
		ВыделенныеСтроки = ВыделенныеСтрокиТабличногоПоляЛкс(ТаблицаФормы, НуженВидимыйПорядок);
		Для Каждого ВыделеннаяСтрока Из ВыделенныеСтроки Цикл 
			Если ТипЗнч(ВыделеннаяСтрока) = Тип("СтрокаГруппировкиДинамическогоСписка") Тогда
				Продолжить;
			КонецЕсли;
			ДанныеСтроки = ДанныеСтрокиТабличногоПоляЛкс(ТаблицаФормы, ВыделеннаяСтрока, ДанныеПоля);
			Если ПутьКДанным = Null Тогда
				ПутьКДанным = ирОбщий.НайтиПутьКДаннымПоляТаблицыФормыЛкс(ДанныеСтроки, ПолноеИмяПоля);
			КонецЕсли; 
			ЗначениеПоля = Неопределено;
			Если ЗначениеЗаполнено(ПутьКДанным) Тогда
				ЗначениеПоля = ДанныеСтроки[ирОбщий.ПервыйФрагментЛкс(ПутьКДанным)];
			КонецЕсли; 
			Если Не ТолькоСсылки Или ирОбщий.ЛиКлючСсылкиИлиРегистраЛкс(ЗначениеПоля, Ложь) Тогда
				Результат.Добавить(ЗначениеПоля);
				Если ВыделеннаяСтрока = ТаблицаФормы.ТекущаяСтрока Тогда
					выхКлючТекущейСтроки = ЗначениеПоля;
				КонецЕсли; 
			КонецЕсли; 
		КонецЦикла; 
		Если Найти(ПутьКДанным, ".") > 0 И Результат.Количество() > 0 Тогда
			Результат = ПрочитатьРеквизитПоМассивуСсылокЛкс(Результат, ирОбщий.ПоследнийФрагментЛкс(ПутьКДанным));
		КонецЕсли; 
	ИначеЕсли ТипЗнч(Форма.ТекущийЭлемент) = Тип("ТабличноеПоле") Тогда
		ТабличноеПоле = Форма.ТекущийЭлемент;
		ПутьКДанным = ирОбщий.ПутьКДаннымКолонкиТабличногоПоляЛкс(ТабличноеПоле);
		Если ЗначениеЗаполнено(ПутьКДанным) Тогда
			ВыделенныеСтроки = ВыделенныеСтрокиТабличногоПоляЛкс(ТабличноеПоле, НуженВидимыйПорядок);
			ДанныеПоля = Неопределено;
			Для Каждого ВыделеннаяСтрока Из ВыделенныеСтроки Цикл
				ДанныеСтроки = ДанныеСтрокиТабличногоПоляЛкс(ТабличноеПоле, ВыделеннаяСтрока, ДанныеПоля);
				ЗначениеПоля = Неопределено;
				Если ЗначениеЗаполнено(ПутьКДанным) Тогда
					Попытка
						ЗначениеПоля = ДанныеСтроки[ирОбщий.ПоследнийФрагментЛкс(ПутьКДанным)];
					Исключение
						// В отборе компоновки может возникать ошибка "Поле объекта не обнаружено (ПредставлениеДляКраткогоОтображенияЭлемента)"
						ОписаниеОшибки = ОписаниеОшибки();
					КонецПопытки;
				КонецЕсли; 
				Если Не ТолькоСсылки Или ирОбщий.ЛиКлючСсылкиИлиРегистраЛкс(ЗначениеПоля, Ложь) Тогда
					Результат.Добавить(ЗначениеПоля);
					Если ВыделеннаяСтрока = ТабличноеПоле.ТекущаяСтрока Тогда
						выхКлючТекущейСтроки = ЗначениеПоля;
					КонецЕсли; 
				КонецЕсли; 
			КонецЦикла; 
		КонецЕсли; 
	ИначеЕсли ТипЗнч(Форма.ТекущийЭлемент) = Тип("ПолеФормы") Тогда
		ПолеФормы = Форма.ТекущийЭлемент;
		Если ПолеФормы.Вид = ВидПоляФормы.ПолеВвода Тогда
			ЗначениеПоля = ирОбщий.ДанныеЭлементаФормыЛкс(Форма.ТекущийЭлемент);
			Если Не ТолькоСсылки Или ирОбщий.ЛиКлючСсылкиИлиРегистраЛкс(ЗначениеПоля, Ложь) Тогда
				Результат.Добавить(ЗначениеПоля);
				выхКлючТекущейСтроки = ЗначениеПоля;
			КонецЕсли; 
		ИначеЕсли ПолеФормы.Вид = ВидПоляФормы.ПолеТабличногоДокумента Тогда
			ДанныеРасшифровки = ДанныеРасшифровкиУправляемойФормыОтчетаЛкс(Форма);
			ТабличныйДокумент = ирОбщий.ДанныеЭлементаФормыЛкс(ПолеФормы);
			#Если Сервер И Не Сервер Тогда
				ТабличныйДокумент = Новый ТабличныйДокумент;
			#КонецЕсли
			Если ТабличныйДокумент = Неопределено Тогда
				Возврат Результат;
			КонецЕсли; 
			КлючТекущейСтроки = Неопределено;
			ТаблицаЗначений = ирОбщий.ТаблицаКлючейИзТабличногоДокументаЛкс(ТабличныйДокумент, ДанныеРасшифровки,,, КлючТекущейСтроки);
			Если ТаблицаЗначений.Колонки.Количество() > 0 Тогда
				Для Каждого ЗначениеПоля Из ТаблицаЗначений.ВыгрузитьКолонку(0) Цикл
					Если Не ТолькоСсылки Или ирОбщий.ЛиКлючСсылкиИлиРегистраЛкс(ЗначениеПоля, Ложь) Тогда
						Результат.Добавить(ЗначениеПоля);
					КонецЕсли; 
				КонецЦикла;
				Если Истина
					И КлючТекущейСтроки <> Неопределено 
					И (Ложь
						Или Не ТолькоСсылки 
						Или ирОбщий.ЛиКлючСсылкиИлиРегистраЛкс(КлючТекущейСтроки[0], Ложь)) 
				Тогда
					выхКлючТекущейСтроки = КлючТекущейСтроки[0];
				КонецЕсли; 
			КонецЕсли; 
			Если выхКлючТекущейСтроки = Неопределено И Результат.Количество() > 0 Тогда
				выхКлючТекущейСтроки = Результат[0];
			КонецЕсли; 
		КонецЕсли; 
	КонецЕсли; 
	Возврат Результат;
	
КонецФункции

Функция ПрочитатьРеквизитПоМассивуСсылокЛкс(Знач Ссылки, Знач ИмяРеквизита) Экспорт 
	
	#Если Сервер И Не Сервер Тогда
		Ссылки = Новый Массив;
	#КонецЕсли
	Результат = Новый Массив;
	Если Ссылки.Количество() > 0 Тогда
		Запрос = Новый Запрос;
		Запрос.Текст = "ВЫБРАТЬ Т." + ИмяРеквизита + " ИЗ " + Ссылки[0].Метаданные().ПолноеИмя() + " КАК Т ГДЕ Т.Ссылка В (&Ссылки)"; 
		Запрос.УстановитьПараметр("Ссылки", Ссылки);
		Результат = Запрос.Выполнить().Выгрузить().ВыгрузитьКолонку(0);
	КонецЕсли; 
	Возврат Результат;

КонецФункции

Функция ЭтоУправляемаяФормаОтчетаЛкс(Знач АктивнаяФорма, РазрешитьВнешнийОтчет = Ложь) Экспорт 
	
	Возврат Истина
		И ТипЗнч(АктивнаяФорма) <> Тип("Форма")
		И (Ложь
			Или Найти(АктивнаяФорма.ИмяФормы, ирОбщий.ПеревестиСтроку("Отчет") + ".") = 1
			Или РазрешитьВнешнийОтчет И Найти(АктивнаяФорма.ИмяФормы, ирОбщий.ПеревестиСтроку("ВнешнийОтчет") + ".") = 1);

КонецФункции

Функция ТекущийЭлементАктивнойФормыЛкс(АктивнаяФорма = Неопределено) Экспорт 
	
	Если АктивнаяФорма = Неопределено Тогда
		АктивнаяФорма = АктивнаяУправляемаяФормаЛкс();
	КонецЕсли; 
	ТекущийЭлемент = АктивнаяФорма.ТекущийЭлемент;
	Если ТипЗнч(АктивнаяФорма) = Тип("УправляемаяФорма") Тогда
		Если ТипЗнч(ТекущийЭлемент) = Тип("ОсновнойЭлементФормы") Тогда
			// http://www.hostedredmine.com/issues/880476
			ТекущийЭлемент = Неопределено;
		КонецЕсли;
	КонецЕсли;
	Возврат ТекущийЭлемент;

КонецФункции

Процедура ЗапомнитьСодержимоеЭлементаАктивнойФормыДляСравненияЛкс(Форма = Неопределено) Экспорт 
	
	ТекущийЭлемент = ТекущийЭлементАктивнойФормыЛкс(Форма);
	Если Истина
		И ТипЗнч(ТекущийЭлемент) <> Тип("ТаблицаФормы") 
		И ТипЗнч(ТекущийЭлемент) <> Тип("ТабличноеПоле") 
		И ТипЗнч(ТекущийЭлемент) <> Тип("ПолеТабличногоДокумента") 
		И Не (Истина
			И ТипЗнч(ТекущийЭлемент) = Тип("ПолеФормы") 
			И ТекущийЭлемент.Вид = ВидПоляФормы.ПолеТабличногоДокумента) 
	Тогда
		Возврат;
	КонецЕсли; 
	ЗапомнитьСодержимоеЭлементаФормыДляСравненияЛкс(Форма, ТекущийЭлемент);
	
КонецПроцедуры

Процедура ОткрытьТаблицуЗначенийИзАктивнойУправляемойФормыЛкс(Форма = Неопределено) Экспорт 
	
	ТекущаяСтрокаТаблицы = Неопределено;
	ТекущийЭлемент = ТекущийЭлементАктивнойФормыЛкс(Форма);
	Если Ложь
		Или ТипЗнч(ТекущийЭлемент) = Тип("ТаблицаФормы") 
	Тогда
		Результат = ТаблицаИлиДеревоЗначенийИзТаблицыФормыСКоллекциейЛкс(ТекущийЭлемент,, Истина, Ложь,,, Форма, ТекущаяСтрокаТаблицы);
	ИначеЕсли ТипЗнч(ТекущийЭлемент) = Тип("ТабличноеПоле") Тогда 
		// Используем стандартный диалог, чтобы не терялась возможность оставить только видимые колонки
	ИначеЕсли Ложь
		Или ТипЗнч(ТекущийЭлемент) = Тип("ПолеТабличногоДокумента") 
		Или (Истина
			И ТипЗнч(ТекущийЭлемент) = Тип("ПолеФормы") 
			И ТекущийЭлемент.Вид = ВидПоляФормы.ПолеТабличногоДокумента)
	Тогда
		ДанныеРасшифровки = ДанныеРасшифровкиУправляемойФормыОтчетаЛкс(Форма);
		ТабличныйДокумент = ирОбщий.ДанныеЭлементаФормыЛкс(ТекущийЭлемент);
		Если ТабличныйДокумент = Неопределено Тогда
			Возврат;
		КонецЕсли; 
		#Если Сервер И Не Сервер Тогда
			ТабличныйДокумент = Новый ТабличныйДокумент;
		#КонецЕсли
		ОбластьДляАнализа = Неопределено;
		ТекущаяОбласть = ТабличныйДокумент.ТекущаяОбласть;
		Если Истина
			И ТекущаяОбласть <> Неопределено 
			И ТипЗнч(ТекущаяОбласть) <> Тип("РисунокТабличногоДокумента")
			И ТекущаяОбласть.Верх = ТекущаяОбласть.Низ
		Тогда 
			Ответ = Вопрос("Выделена только одна строка. Хотите обработать все строки?", РежимДиалогаВопрос.ДаНет,, КодВозвратаДиалога.Да);
			Если Ответ = КодВозвратаДиалога.Да Тогда
				ПерваяСтрокаОбласти = ТекущаяОбласть.Верх;
				ШиринаКолонкиТекущейОбласти = ТабличныйДокумент.Область(ТекущаяОбласть.Верх, ТекущаяОбласть.Лево).ШиринаКолонки;
				Для НомерСтроки = -ТекущаяОбласть.Верх + 1 По 0 Цикл
					ШиринаКолонкиПроверяемойОбласти = ТабличныйДокумент.Область(-НомерСтроки, ТекущаяОбласть.Лево, -НомерСтроки, ТекущаяОбласть.Лево).ШиринаКолонки;
					Если ШиринаКолонкиТекущейОбласти = 0 Тогда
						ШиринаКолонкиТекущейОбласти = ШиринаКолонкиПроверяемойОбласти;
					КонецЕсли; 
					Если ШиринаКолонкиТекущейОбласти <> ШиринаКолонкиПроверяемойОбласти Тогда 
						ПерваяСтрокаОбласти = -НомерСтроки + 1;
						Прервать;
					КонецЕсли; 
				КонецЦикла;
				ОбластьДляАнализа = ТабличныйДокумент.Область(ПерваяСтрокаОбласти, ТекущаяОбласть.Лево, ТабличныйДокумент.ВысотаТаблицы, ТекущаяОбласть.Право);
			КонецЕсли;
		КонецЕсли; 
		Результат = ирОбщий.ТаблицаКлючейИзТабличногоДокументаЛкс(ТабличныйДокумент, ДанныеРасшифровки,, ОбластьДляАнализа, ТекущаяСтрокаТаблицы);
		#Если Сервер И Не Сервер Тогда
			Результат = Новый ТаблицаЗначений;
		#КонецЕсли
		Если Результат.Колонки.Количество() = 0 Тогда
			Ответ = Вопрос("Ячейки не содержат расшифровки. Хотите назначить имена колонкам из первой строки выделенной области?", РежимДиалогаВопрос.ДаНет,, КодВозвратаДиалога.Нет);
			ЛиПерваяСтрокаСодержитИменаКолонок = Ответ = КодВозвратаДиалога.Да;
			Результат = ирОбщий.ТаблицаЗначенийИзТабличногоДокументаЛкс(ТабличныйДокумент, ЛиПерваяСтрокаСодержитИменаКолонок,,,, ?(ОбластьДляАнализа = Неопределено, Истина, ОбластьДляАнализа), ТекущаяСтрокаТаблицы);
		КонецЕсли;
		#Если Сервер И Не Сервер Тогда
			Результат = Новый ТаблицаЗначений;
		#КонецЕсли
		Если ТекущаяСтрокаТаблицы <> Неопределено Тогда
			ИндексТекущейСтроки = Результат.Индекс(ТекущаяСтрокаТаблицы);
		КонецЕсли; 
		Результат = ирОбщий.СузитьТипыКолонокТаблицыБезПотериДанныхЛкс(Результат);
		Если ТекущаяСтрокаТаблицы <> Неопределено Тогда
			ТекущаяСтрокаТаблицы = Результат[ИндексТекущейСтроки];
		КонецЕсли; 
		ТекущийЭлемент = Неопределено;
	Иначе
		Возврат;
	КонецЕсли; 
	Если Результат <> Неопределено Тогда
		мПлатформа = ирКэш.Получить();
		#Если Сервер И Не Сервер Тогда
			мПлатформа = Обработки.ирПлатформа.Создать();
		#КонецЕсли
		ФормаТаблицыЗначений = мПлатформа.ПолучитьФорму("ТаблицаЗначений", , Результат);
		ФормаТаблицыЗначений.ПараметрТабличноеПоле = ТекущийЭлемент;
		ФормаТаблицыЗначений.НачальноеЗначениеВыбора = Результат;
		ФормаТаблицыЗначений.Открыть();
		Если ТекущаяСтрокаТаблицы <> Неопределено Тогда
			ФормаТаблицыЗначений.УстановитьТекущуюСтроку(ТекущаяСтрокаТаблицы, Результат);
		КонецЕсли; 
	Иначе // ДинамическийСписок
		ВывестиСтрокиТабличногоПоляИПоказатьЛкс(Форма, ТекущийЭлемент);
	КонецЕсли; 
	
КонецПроцедуры

Функция ОткрытьТабличныйДокументИзАктивнойФормыЛкс(Форма = Неопределено) Экспорт 
	
	#Если Сервер И Не Сервер Тогда
		Форма = ОткрытьФорму();
	#КонецЕсли   
	ДокументИзменен = Ложь;
	ТекущийЭлемент = ТекущийЭлементАктивнойФормыЛкс(Форма);
	Если Ложь
		Или ТипЗнч(ТекущийЭлемент) = Тип("ПолеТабличногоДокумента") 
		Или (Истина
			И ТипЗнч(ТекущийЭлемент) = Тип("ПолеФормы") 
			И ТекущийЭлемент.Вид = ВидПоляФормы.ПолеТабличногоДокумента)
	Тогда
		Результат = ирОбщий.ДанныеЭлементаФормыЛкс(ТекущийЭлемент);
		ДанныеРасшифровки = ДанныеРасшифровкиУправляемойФормыОтчетаЛкс(Форма);
	КонецЕсли; 
	Если Результат <> Неопределено Тогда
		Если ТипЗнч(ТекущийЭлемент) = Тип("ПолеТабличногоДокумента") Тогда 
			ДоступноИзменение = Истина
				И Не ТекущийЭлемент.ТолькоПросмотр 
				И ТекущийЭлемент.ПолучитьДействие("ПриИзмененииСодержимогоОбласти") = Неопределено;
			ПолеТабличногоДокументаВосстановитьОформлениеТекущихСтрокЛкс(Форма, ТекущийЭлемент);
		Иначе
			ПутьКДанным = ирОбщий.ПутьКДаннымЭлементаУправляемойФормыЛкс(ТекущийЭлемент,, Форма);
			ДоступноИзменение = Истина
				И ТекущийЭлемент.Редактирование 
				И Не ТекущийЭлемент.Защита 
				И ЛиДоступноРедактированиеЭлементаУправляемойФормыЛкс(ТекущийЭлемент)
				И ЗначениеЗаполнено(ПутьКДанным)
				//И ТекущийЭлемент.ПолучитьДействие("ПриИзмененииСодержимогоОбласти") = Неопределено // но на клиенте его получить нельзя
				;
		КонецЕсли;
		НовоеЗначение = ОткрытьТабличныйДокументРезультатаКомпоновкиЛкс(Результат, ДанныеРасшифровки,, ДоступноИзменение);
		Если НовоеЗначение <> Неопределено Тогда
			#Если Сервер И Не Сервер Тогда
				ТекущийЭлемент = Новый ТабличныйДокумент;
				НовоеЗначение = Новый ТабличныйДокумент;
			#КонецЕсли
			Если ТипЗнч(ТекущийЭлемент) = Тип("ПолеТабличногоДокумента") Тогда 
				// Так только текущий язык останется
				ТекущийЭлемент.ВставитьОбласть(НовоеЗначение.Область(),,, Ложь); 
				Если ТекущийЭлемент.ИзменяетДанные Тогда
					Форма.Модифицированность = Истина;
				КонецЕсли;
			Иначе
				Выполнить("Форма." + ПутьКДанным + " = НовоеЗначение");
			КонецЕсли; 
			ДокументИзменен = Истина;
		Иначе
			ТекущийЭлемент.ТекущаяОбласть = ТекущийЭлемент.ТекущаяОбласть;
		КонецЕсли;
	КонецЕсли;
	Возврат ДокументИзменен;
	
КонецФункции

Функция ЛиДоступноРедактированиеЭлементаУправляемойФормыЛкс(Знач ТекущийЭлемент) Экспорт 
	
	Возврат ирОбщий.РодительЭлементаУправляемойФормыЛкс(ТекущийЭлемент, "все", "ТолькоПросмотр", Истина) <> "Неопределено";

КонецФункции

Функция ОткрытьТабличныйДокументРезультатаКомпоновкиЛкс(Знач ПолеТабличногоДокумента, Знач ДанныеРасшифровки = Неопределено, Знач ИмяСохраненияПоложенияОкна = "", Знач Модально = Ложь) Экспорт 
	
	//ТабличныйДокумент = Новый ТабличныйДокумент;
	//ТабличныйДокумент.Вывести(ПолеТабличногоДокумента);
	ТабличныйДокумент = ПолучитьОбластьТабличногоДокументаИнтерактивноЛкс(ПолеТабличногоДокумента);
	#Если Сервер И Не Сервер Тогда
		ТабличныйДокумент = Новый ТабличныйДокумент;
	#КонецЕсли
	ТабличныйДокумент.ИмяСохраненияПоложенияОкна = ИмяСохраненияПоложенияОкна;
	Если ДанныеРасшифровки <> Неопределено Тогда
		ирОбщий.УпроститьРасшифровкиТабличногоДокументаКомпоновкиЛкс(ТабличныйДокумент, ДанныеРасшифровки);
	КонецЕсли; 
	Результат = Неопределено;
	Если ОткрытьЗначениеЛкс(ТабличныйДокумент,,,, Модально,, ПолеТабличногоДокумента) Тогда 
		Результат = ТабличныйДокумент;
	КонецЕсли;
	Возврат Результат;

КонецФункции

Функция ДанныеРасшифровкиУправляемойФормыОтчетаЛкс(Знач Форма) Экспорт 
	
	ВозможныеИменаРеквизитов = Новый Массив;
	ВозможныеИменаРеквизитов.Добавить("ДанныеРасшифровки");
	ВозможныеИменаРеквизитов.Добавить("ОтчетДанныеРасшифровки");
	Для Каждого ИмяРеквизита Из ВозможныеИменаРеквизитов Цикл
		Попытка
			ДанныеРасшифровки = Форма[ИмяРеквизита];
			Прервать;
		Исключение
			ДанныеРасшифровки = Неопределено;
		КонецПопытки; 
	КонецЦикла;
	Если Истина
		И ТипЗнч(ДанныеРасшифровки) = Тип("Строка") 
		И ЗначениеЗаполнено(ДанныеРасшифровки)
	Тогда 
		ДанныеРасшифровки = ПолучитьИзВременногоХранилища(ДанныеРасшифровки);
	КонецЕсли;
	Возврат ДанныеРасшифровки;

КонецФункции

Процедура ОткрытьРазличныеЗначенияКолонкиАктивнойУправляемойФормыЛкс(Форма = Неопределено) Экспорт 
	
	ТекущийЭлемент = ТекущийЭлементАктивнойФормыЛкс(Форма);
	Если Истина
		И ТипЗнч(ТекущийЭлемент) <> Тип("ТаблицаФормы") 
		И ТипЗнч(ТекущийЭлемент) <> Тип("ТабличноеПоле")
	Тогда
		Возврат;
	КонецЕсли; 
	ОткрытьРазличныеЗначенияКолонкиЛкс(ТекущийЭлемент,,, Форма);
	
КонецПроцедуры

Процедура ОтладитьКомпоновкуДанныхАктивнойУправляемойФормыЛкс(Форма = Неопределено) Экспорт 
	
	Если Форма = Неопределено Тогда
		Форма = АктивнаяУправляемаяФормаЛкс();
	КонецЕсли; 
	Если ТипЗнч(Форма) = Тип("УправляемаяФорма") Тогда
		Попытка
			НастройкиОтчета = Форма.НастройкиОтчета;
		Исключение
			НастройкиОтчета = Неопределено;
		КонецПопытки;
		Если НастройкиОтчета <> Неопределено И НастройкиОтчета.СхемаМодифицирована Тогда
			// Стандартная форма отчета БСП
			СхемаКомпоновки = ПолучитьИзВременногоХранилища(НастройкиОтчета.АдресСхемы);
		Иначе
			Фрагменты = ирОбщий.СтрРазделитьЛкс(Форма.ИмяФормы);
			Если Фрагменты[0] = ирОбщий.ПеревестиСтроку("Отчет") Тогда 
				ОтчетОбъект = Отчеты[Фрагменты[1]].Создать();
				#Если Сервер И Не Сервер Тогда
					ОтчетОбъект = Обработки.ирКонсольКомпоновокДанных.Создать();
				#КонецЕсли
				СхемаКомпоновки = ОтчетОбъект.СхемаКомпоновкиДанных;
			//ИначеЕсли Фрагменты[0] = ирОбщий.ПеревестиСтроку("ВнешнийОтчет") Тогда 
			//	// https://forum.mista.ru/topic.php?id=857116
			//	ОтчетОбъект = ВнешниеОтчеты.Создать(Фрагменты[1]);
			//	#Если Сервер И Не Сервер Тогда
			//		ОтчетОбъект = ВнешниеОтчеты.Создать();
			//	#КонецЕсли
			//	СхемаКомпоновки = ОтчетОбъект.СхемаКомпоновкиДанных;
			Иначе
				ирОбщий.СообщитьЛкс(ирОбщий.СтрШаблонИменЛкс("Не поддерживаемый тип метаданных отчета - %1",, Фрагменты[0]));
				Возврат;
			КонецЕсли; 
		КонецЕсли;
		КомпоновщикНастроек = Форма.Отчет.КомпоновщикНастроек;
	Иначе
		Попытка
			ОбщийМодульТиповыеОтчеты = Вычислить("ТиповыеОтчеты");
		Исключение
		КонецПопытки;
		Если Истина
			И ОбщийМодульТиповыеОтчеты <> Неопределено 
			И ирОбщий.МетодРеализованЛкс(ОбщийМодульТиповыеОтчеты, "ЗагрузитьВРеквизитЗначенияНастроекПанелиПользователя") 
		Тогда
			ОбщийМодульТиповыеОтчеты.ЗагрузитьВРеквизитЗначенияНастроекПанелиПользователя(Форма.ЭтотОбъект, Форма);
			ОбщийМодульТиповыеОтчеты.ПолучитьПримененуюНастройку(Форма.ЭтотОбъект);
		КонецЕсли; 
		СхемаКомпоновки = Форма.СхемаКомпоновкиДанных; 
		КомпоновщикНастроек = Форма.КомпоновщикНастроек;
	КонецЕсли;
	ирОбщий.ОтладитьЛкс(СхемаКомпоновки,, КомпоновщикНастроек.ПолучитьНастройки());
	
КонецПроцедуры

Процедура РедактироватьАктивныйСписокЗначенийУправляемыйЛкс(Форма = Неопределено) Экспорт 
	
	Если Форма = Неопределено Тогда
		Форма = АктивнаяУправляемаяФормаЛкс();
	КонецЕсли; 
	Если ТипЗнч(Форма) <> Тип("УправляемаяФорма") Тогда
		Возврат;
	КонецЕсли;
	ПутьКДанным = "";
	ирОбщий.ДанныеЭлементаФормыЛкс(Форма.ТекущийЭлемент, ПутьКДанным);
	Если Не ЗначениеЗаполнено(ПутьКДанным) Тогда
		Возврат;
	КонецЕсли;
	СписокЗначений = Форма[ПутьКДанным];
	#Если Сервер И Не Сервер Тогда
		СписокЗначений = Новый СписокЗначений;
	#КонецЕсли
	ПолеЗначения = Форма.Элементы.Найти("Value");
	Если ПолеЗначения = Неопределено Тогда
		ПолеЗначения = Форма.ТекущийЭлемент.ТекущийЭлемент;
	КонецЕсли;
	Если ПолеЗначения <> Неопределено Тогда
		СтруктураОтбора = СтруктураОтбораПоСвязямИПараметрамВыбораЛкс(ПолеЗначения);
		Если СписокЗначений.ДоступныеЗначения = Неопределено И ПолеЗначения.РежимВыбораИзСписка Тогда
			СписокЗначений = ирОбщий.СкопироватьУниверсальнуюКоллекциюЛкс(СписокЗначений);
			СписокЗначений.ДоступныеЗначения = ПолеЗначения.СписокВыбора;
		КонецЕсли;
	КонецЕсли;
	Если ОткрытьСписокЗначенийЛкс(СписокЗначений, СтруктураОтбора) Тогда 
		Форма[ПутьКДанным] = СписокЗначений;
	КонецЕсли;
	
КонецПроцедуры

Процедура НастроитьДинамическийСписокАктивнойУправляемойФормыЛкс(Форма = Неопределено) Экспорт 
	
	ТекущийЭлемент = ТекущийЭлементАктивнойФормыЛкс(Форма);
	Если ТипЗнч(ТекущийЭлемент) <> Тип("ТаблицаФормы") Тогда
		Возврат;
	КонецЕсли; 
	ДанныеЭлемента = ирОбщий.ДанныеЭлементаФормыЛкс(ТекущийЭлемент);
	Если ТипЗнч(ДанныеЭлемента) <> Тип("ДинамическийСписок") Тогда
		Возврат;
	КонецЕсли; 
	Параметры = Новый Структура("Настройки, ПользовательскиеНастройки, ФиксированныеНастройки, ИсточникДоступныхНастроек");
	СхемаИНастройки = ИсполняемыеСхемаИНастройкиСпискаУправляемойФормаЛкс(Форма);
	Если СхемаИНастройки <> Неопределено Тогда
		Параметры.Вставить("ИсполняемаяСхема", ПоместитьВоВременноеХранилище(СхемаИНастройки.Схема, Форма.УникальныйИдентификатор));
		Параметры.Вставить("ИсполняемыеНастройки", СхемаИНастройки.Настройки);
	КонецЕсли; 
	ЗаполнитьЗначенияСвойств(Параметры, ДанныеЭлемента.КомпоновщикНастроек); 
	Параметры.ИсточникДоступныхНастроек = ДанныеЭлемента.КомпоновщикНастроек.ПолучитьИсточникДоступныхНастроек();
	Если ирКэш.НомерВерсииПлатформыЛкс() > 803001 Тогда
		Выполнить("ОткрытьФорму(""Обработка.ирДинамическийСписок.Форма.НастройкиСпискаУпр"", Параметры, ТекущийЭлемент,,,,, РежимОткрытияОкнаФормы.БлокироватьОкноВладельца)");
	Иначе
		ОткрытьФормуМодально("Обработка.ирДинамическийСписок.Форма.НастройкиСпискаУпр", Параметры, ТекущийЭлемент);
	КонецЕсли; 
	
КонецПроцедуры

Функция ИсполняемыеСхемаИНастройкиСпискаУправляемойФормаЛкс(Знач Форма, Знач ИмяТаблицыФормы = "") Экспорт 
	
	#Если Сервер И Не Сервер Тогда
		ирОбщий.УправляемаяФормаБСП_ИсполняемыеСхемаИНастройкиТаблицыЛкс();
	#КонецЕсли
	СхемаИНастройки = ирОбщий.УправляемаяФормаБСП_ВыполнитьНаСервереЛкс(Форма, "ирОбщий.УправляемаяФормаБСП_ИсполняемыеСхемаИНастройкиТаблицыЛкс", ИмяТаблицыФормы);
	Возврат СхемаИНастройки;

КонецФункции

Процедура ОткрытьДинамическийСписокАктивнойУправляемойФормыЛкс(Форма = Неопределено) Экспорт 
	
	ТекущийЭлемент = ТекущийЭлементАктивнойФормыЛкс(Форма);
	ДанныеЭлемента = ирОбщий.ДанныеЭлементаФормыЛкс(ТекущийЭлемент);
	Если ТипЗнч(ДанныеЭлемента) <> Тип("ДинамическийСписок") Тогда
		Возврат;
	КонецЕсли; 
	ПолноеИмяТаблицыБД = "";
	ОбщийТипДанныхТаблицы = ирОбщий.ОбщийТипДанныхТабличногоПоляЛкс(ТекущийЭлемент,,, ПолноеИмяТаблицыБД);
	Если ПолноеИмяТаблицыБД = Неопределено Тогда
		Возврат;
	КонецЕсли; 
	КомпоновщикНастроек = ДанныеЭлемента.КомпоновщикНастроек;
	#Если Сервер И Не Сервер Тогда
		КомпоновщикНастроек = Новый КомпоновщикНастроекКомпоновкиДанных;
	#КонецЕсли
	НастройкиСписка = КомпоновщикНастроек.ПолучитьНастройки();
	ТекущаяКолонка = ирОбщий.ДанныеЭлементаФормыЛкс(ТекущийЭлемент.ТекущийЭлемент);
	Форма = ПолучитьФормуСпискаЛкс(ПолноеИмяТаблицыБД,, Истина,,,, ТекущийЭлемент.ТекущаяСтрока, НастройкиСписка.Отбор, ПолноеИмяТаблицыБД, ТекущаяКолонка);
	Форма.Открыть();
	
КонецПроцедуры

Процедура ОтборБезЗначенияВТекущейКолонкеАктивнойФормыЛкс(Параметры) Экспорт 
	
	ТекущийЭлемент = ТекущийЭлементАктивнойФормыЛкс(Параметры.Форма);
	Если Истина
		И ТипЗнч(ТекущийЭлемент) <> Тип("ТаблицаФормы") 
		И ТипЗнч(ТекущийЭлемент) <> Тип("ТабличноеПоле")
	Тогда
		Возврат;
	КонецЕсли; 
	ОбщийТипДанныхТаблицы = ирОбщий.ОбщийТипДанныхТабличногоПоляЛкс(ТекущийЭлемент);
	Если Истина
		И ОбщийТипДанныхТаблицы <> "Список" 
		И ОбщийТипДанныхТаблицы <> "ТабличнаяЧасть"
		И ОбщийТипДанныхТаблицы <> "НаборЗаписей"
	Тогда
		Возврат;
	КонецЕсли; 
	ТабличноеПолеОтборДляЗначенияВТекущейКолонкеЛкс(ТекущийЭлемент); 
	
КонецПроцедуры

Процедура НайтиВыбратьСсылкуВДинамическомСпискеЛкс(Форма = Неопределено) Экспорт 
	
	ТекущийЭлемент = ТекущийЭлементАктивнойФормыЛкс(Форма);
	Если Истина
		И ТипЗнч(ТекущийЭлемент) <> Тип("ТаблицаФормы") 
		И ТипЗнч(ТекущийЭлемент) <> Тип("ТабличноеПоле")
	Тогда
		Возврат;
	КонецЕсли; 
	ИмяТаблицыБД = ирОбщий.ИмяТаблицыБДДинамическогоСпискаЛкс(ТекущийЭлемент);
	Если Не ЗначениеЗаполнено(ИмяТаблицыБД) Тогда
		Возврат;
	КонецЕсли; 
	НайтиВыбратьСсылкуВДинамическомСпискеПоIDЛкс(ТекущийЭлемент);
	
КонецПроцедуры

Процедура НайтиВыбратьСсылкуВДинамическомСпискеПоIDЛкс(Знач ТабличноеПоле, Форма = Неопределено) Экспорт 
	
	мПлатформа = ирКэш.Получить();
	#Если Сервер И Не Сервер Тогда
		мПлатформа = Обработки.ирПлатформа.Создать();
	#КонецЕсли
	ФормаВводаИдентификатора = мПлатформа.ПолучитьФорму("УникальныйИдентификатор");
	НовыйИдентификатор = ФормаВводаИдентификатора.ОткрытьМодально();
	Если НовыйИдентификатор = Неопределено Тогда
		Возврат;
	КонецЕсли;
	Ссылка = ирОбщий.ПолучитьМенеджерЛкс(ирОбщий.ИмяТаблицыБДДинамическогоСпискаЛкс(ТабличноеПоле)).ПолучитьСсылку(НовыйИдентификатор);
	ДинамическийСписокУстановитьТекущуюСтрокуСКонтролемЛкс(ТабличноеПоле, Ссылка, Форма);

КонецПроцедуры

Процедура ДинамическийСписокУстановитьТекущуюСтрокуСКонтролемЛкс(ТабличноеПоле, Ссылка, Форма = Неопределено) Экспорт 
	
	ТабличноеПоле.ТекущаяСтрока = Ссылка;
	Если ТабличноеПоле.ТекущаяСтрока = Ссылка Тогда
		ирОбщий.СообщитьЛкс("Объект найден и установлен текущей строкой");
	Иначе
		Если Форма = Неопределено Тогда
			Форма = ирОбщий.РодительЭлементаУправляемойФормыЛкс(ТабличноеПоле);
		КонецЕсли; 
		Если Не ирОбщий.ЛиСуществуетОбъектПоСсылкеЛкс(Ссылка) Тогда 
			Если ТабличноеПоле.РежимВыбора Тогда
				Ответ = Вопрос("Объект не найден в таблице. Выбрать ссылку?", РежимДиалогаВопрос.ОКОтмена);
				Если Ответ = КодВозвратаДиалога.ОК Тогда
					Форма.ОповеститьОВыборе(Ссылка);
				КонецЕсли;
			Иначе
				ирОбщий.СообщитьЛкс("Объект не найден в таблице");
			КонецЕсли;
		Иначе
			Если ТабличноеПоле.РежимВыбора Тогда
				Ответ = Вопрос("Объект найден в таблице, но не отвечает текущему отбору. Выбрать ссылку?", РежимДиалогаВопрос.ОКОтмена);
				Если Ответ = КодВозвратаДиалога.ОК Тогда
					Форма.ОповеститьОВыборе(Ссылка);
				КонецЕсли;
			Иначе
				ирОбщий.СообщитьЛкс("Объект найден в таблице, но не отвечает текущему отбору");
			КонецЕсли;
		КонецЕсли; 
	КонецЕсли;

КонецПроцедуры

Функция ЗапросДинамическогоСпискаЛкс(Знач ТабличноеПоле, Знач ПолноеИмяТаблицыБД = "", Знач УчитываяОтбор = Истина, Знач АнализируемоеПоле = "", Компоновщик = Неопределено) Экспорт 
	
	ДанныеТабличногоПоля = ирОбщий.ДанныеЭлементаФормыЛкс(ТабличноеПоле);
	Если Не ЗначениеЗаполнено(ПолноеИмяТаблицыБД) Тогда
		ПолноеИмяТаблицыБД = ирОбщий.ИмяТаблицыБДДинамическогоСпискаЛкс(ТабличноеПоле); 
	КонецЕсли;
	ПоляТаблицыБД = ирКэш.ПоляТаблицыБДЛкс(ПолноеИмяТаблицыБД);
	#Если Сервер И Не Сервер Тогда
		ПоляТаблицыБД = НайтиПоСсылкам().Колонки;
	#КонецЕсли
	ЕстьПрисоединенныеПоля = ЗначениеЗаполнено(АнализируемоеПоле) И ПоляТаблицыБД.Найти(АнализируемоеПоле, "Имя") = Неопределено;
	Если Не ЕстьПрисоединенныеПоля И УчитываяОтбор Тогда
		ПоляОтбора = Новый Соответствие;
		НастройкиСписка = ирОбщий.НастройкиДинамическогоСпискаЛкс(ДанныеТабличногоПоля);
		ирОбщий.НайтиЭлементОтбораЛкс(НастройкиСписка.Отбор,, ПоляОтбора,, Истина,, Истина);
		Для Каждого КлючИЗначение Из ПоляОтбора Цикл
			Если ПоляТаблицыБД.Найти(КлючИЗначение.Ключ, "Имя") = Неопределено Тогда
				ЕстьПрисоединенныеПоля = Истина;
				Прервать;
			КонецЕсли;
		КонецЦикла;
	КонецЕсли;
	Запрос = Неопределено;
	Если Не ЕстьПрисоединенныеПоля Тогда
		Запрос = Новый Запрос;
	Иначе
		СхемаИНастройки = ИсполняемыеСхемаИНастройкиСпискаУправляемойФормаЛкс(ирОбщий.РодительЭлементаУправляемойФормыЛкс(ТабличноеПоле));
		#Если Сервер И Не Сервер Тогда
			Компоновщик = Новый КомпоновщикНастроекКомпоновкиДанных;
		#КонецЕсли
		Если СхемаИНастройки <> Неопределено Тогда
			СхемаКомпоновки = СхемаИНастройки.Схема;
			НастройкаКомпоновки = СхемаИНастройки.Настройки;
			Если Компоновщик <> Неопределено Тогда
				Компоновщик.Инициализировать(Новый ИсточникДоступныхНастроекКомпоновкиДанных(СхемаКомпоновки));
			КонецЕсли;
		Иначе
			СхемаКомпоновки = ирОбщий.СоздатьСхемуКомпоновкиПоОбъектуМДЛкс(ПолноеИмяТаблицыБД,, Ложь);
			Если НастройкиСписка <> Неопределено Тогда
				НастройкаКомпоновки = НастройкиСписка;
			Иначе
				НастройкаКомпоновки = Новый НастройкиКомпоновкиДанных;
			КонецЕсли;
			Если Компоновщик = Неопределено Тогда
				Компоновщик = Новый КомпоновщикНастроекКомпоновкиДанных;
			КонецЕсли;
			Компоновщик.Инициализировать(Новый ИсточникДоступныхНастроекКомпоновкиДанных(СхемаКомпоновки));
			Компоновщик.ЗагрузитьНастройки(НастройкаКомпоновки);
			Компоновщик.Восстановить();
			НастройкаКомпоновки = Компоновщик.Настройки;
		КонецЕсли;
		#Если Сервер И Не Сервер Тогда
			СхемаКомпоновки = Новый СхемаКомпоновкиДанных;
		#КонецЕсли
		Если Не УчитываяОтбор Тогда
			НастройкаКомпоновки.Отбор.Элементы.Очистить();
		ИначеЕсли ЗначениеЗаполнено(АнализируемоеПоле) Тогда 
			ЭлементОтбораКолонки = ирОбщий.НайтиДобавитьЭлементОтбораКомпоновкиЛкс(НастройкаКомпоновки.Отбор, АнализируемоеПоле);
			Если ЭлементОтбораКолонки <> Неопределено Тогда
				ЭлементОтбораКолонки.Использование = Ложь;
			КонецЕсли; 
		КонецЕсли;
		Запрос = ирОбщий.ЗапросИзКомпоновкиЛкс(СхемаКомпоновки, НастройкаКомпоновки);
	КонецЕсли;
	Возврат Запрос;

КонецФункции

Процедура ДобавитьКолонкиГруппыФормыВТаблицуЗначенийЛкс(Знач КолонкиИсточника, Знач Результат, Знач СтрокаИлиКоллекция, Знач ИменаКолонокРезультата = "")
	
	#Если Сервер И Не Сервер Тогда
		Результат = Новый ТаблицаЗначений;
	#КонецЕсли
	Если ТипЗнч(ИменаКолонокРезультата) = Тип("Строка") И ЗначениеЗаполнено(ИменаКолонокРезультата) Тогда
		ИменаКолонокРезультата = ирОбщий.СтрРазделитьЛкс(ИменаКолонокРезультата, ",", Истина);
	ИначеЕсли ТипЗнч(ИменаКолонокРезультата) = Тип("Массив") Тогда
	Иначе
		ИменаКолонокРезультата = Неопределено;
	КонецЕсли;
	Для Каждого ПолеТаблицыФормы Из КолонкиИсточника Цикл
		Если ТипЗнч(ПолеТаблицыФормы) = Тип("ГруппаФормы") Тогда
			ДобавитьКолонкиГруппыФормыВТаблицуЗначенийЛкс(ПолеТаблицыФормы.ПодчиненныеЭлементы, Результат, СтрокаИлиКоллекция, ИменаКолонокРезультата);
			Продолжить;
		КонецЕсли;
		ПолноеИмяПоля = ПолеТаблицыФормы.Имя;
		ПутьКДанным = ирОбщий.НайтиПутьКДаннымПоляТаблицыФормыЛкс(СтрокаИлиКоллекция, ПолноеИмяПоля);
		Если Истина
			И ЗначениеЗаполнено(ПутьКДанным) 
			И (Ложь
				Или ИменаКолонокРезультата = Неопределено
				Или ИменаКолонокРезультата.Найти(ПутьКДанным) <> Неопределено)
		Тогда
			ИмяКолонки = СтрЗаменить(ПутьКДанным, ".", "_");
			Если Результат.Колонки.Найти(ИмяКолонки) = Неопределено Тогда 
				Результат.Колонки.Добавить(ИмяКолонки,, ПутьКДанным);
			КонецЕсли;
		КонецЕсли; 
	КонецЦикла;

КонецПроцедуры

Функция ОткрытьСтатистикаMSSQLПоПоследнимЗапросамЛкс(ДатаНачала, ДатаКонца) Экспорт 
	
	ОтчетОбъект = ирОбщий.СоздатьОбъектПоИмениМетаданныхЛкс("Отчет.ирСтатистикаПоЗапросамСУБД");
	#Если Сервер И Не Сервер Тогда
	    ОтчетОбъект = Отчеты.ирСтатистикаПоЗапросамСУБД.Создать();
	#КонецЕсли
	КлючВарианта = "Последние";
	ФормаОтчета = ОтчетОбъект.ПолучитьФорму(,, КлючВарианта);
	ФормаОтчета.ПараметрКлючВарианта = КлючВарианта;
	ФормаОтчета.Открыть();
	НастройкиОтчета = ФормаОтчета.КомпоновщикНастроек.Настройки;
		#Если Сервер И Не Сервер Тогда
		    НастройкиОтчета = Компоновщик.Настройки;
		#КонецЕсли
	НастройкиОтчета.ПараметрыДанных.НайтиЗначениеПараметра(Новый ПараметрКомпоновкиДанных("ПопавшиеВПоследниеМинут")).Использование = Ложь;
	НастройкиОтчета.ПараметрыДанных.УстановитьЗначениеПараметра("НачалоИнтервала", ДатаНачала);
	НастройкиОтчета.ПараметрыДанных.УстановитьЗначениеПараметра("КонецИнтервала", ДатаКонца);
	ФормаОтчета.ДействияФормыСформировать();

КонецФункции

Процедура ЗаполнитьИзмененыеПоляВСтрокеВерсииДанныхЛкс(Знач ДанныеСтроки, Знач КлючОбъекта = Неопределено, Знач ПолноеИмяМД = "") Экспорт 
	
	#Если Сервер И Не Сервер Тогда
		ДанныеСтроки = Обработки.ирИсторияДанных.Создать().Версии.Добавить();
	#КонецЕсли
	Если ДанныеСтроки.ИзмененныеПоля = "?" Тогда
		Если ДанныеСтроки.НомерВерсии > 1 Тогда
			ИсторияДанныхМоя = ирОбщий.ИсторияДанныхЛкс();
			#Если Сервер И Не Сервер Тогда
				ИсторияДанныхМоя = ИсторияДанных;
			#КонецЕсли
			Если КлючОбъекта = Неопределено Тогда
				КлючОбъекта = КлючОбъектаСтрокиВерсииДанныхЛкс(ДанныеСтроки, ПолноеИмяМД);
			КонецЕсли; 
			Попытка
				СтруктураРазличий = ИсторияДанныхМоя.ПолучитьРазличияВерсий(КлючОбъекта, ДанныеСтроки.НомерВерсии);
			Исключение
				// Может быть ошибка "Данные истории не найдены"
				Пустышка = 0;
			КонецПопытки;
			Если СтруктураРазличий <> Неопределено Тогда
				ИзмененныеПоля = Новый СписокЗначений;
				Для Каждого КлючИЗначение Из СтруктураРазличий Цикл
					ИзмененныеПоля.Добавить(КлючИЗначение.Ключ);
				КонецЦикла;
				ИзмененныеПоля.СортироватьПоЗначению();
				ДанныеСтроки.ИзмененныеПоля = ирОбщий.СтрСоединитьЛкс(ИзмененныеПоля);
			КонецЕсли; 
		КонецЕсли; 
	КонецЕсли;

КонецПроцедуры

Функция КлючОбъектаСтрокиВерсииДанныхЛкс(Знач ДанныеСтроки, Знач ПолноеИмяМД) Экспорт 
	
	КлючОбъекта = ДанныеСтроки.Данные;
	КорневойТип = ирОбщий.ПервыйФрагментЛкс(ПолноеИмяМД);
	Если НадоСериализоватьКлючДанныхДляОтображенияЛкс(КорневойТип) Тогда
		Попытка
			КлючОбъекта = ирОбщий.ЗначениеИзСтрокиВнутрЛкс(КлючОбъекта);
		Исключение
			// Некоторые большие ключи регистров в сериализованном виде не умещаются в 1024 символа
			КлючОбъекта = "<Ключ записи регистра обрезан и не может быть восстановлен>";
		КонецПопытки; 
	ИначеЕсли ирОбщий.ЛиКорневойТипКонстантыЛкс(КорневойТип) Тогда
		КлючОбъекта = ирОбщий.КлючОбъектаКонстантыЛкс(ирОбщий.ПоследнийФрагментЛкс(ПолноеИмяМД));
	КонецЕсли;
	Возврат КлючОбъекта;

КонецФункции

Процедура Форма_ОткрытьБезЗахватаФокусаЛкс(Форма) Экспорт 
	
	АктивнаяФорма = АктивнаяФормаЛкс();
	Форма.Открыть();
	Если АктивнаяФорма <> Неопределено Тогда
		Форма_АктивироватьОткрытьЛкс(АктивнаяФорма);
	КонецЕсли; 
	
КонецПроцедуры

Функция ДобавитьОтборВИсториюТабличногоПоляЛкс(Знач ЭтаФорма, Знач ТабличноеПолеИлиКлюч, Знач Отбор, СтарыйОтбор, Знач ИгнорироватьЭлементы = "") Экспорт 
	
	#Если Сервер И Не Сервер Тогда
		Пустышка = Новый ПостроительЗапроса;
		Отбор = Пустышка.Отбор;
		СтарыйОтбор = Пустышка.Отбор;
	#КонецЕсли
	ДобавленВСписок = Ложь;
	Если Строка(Отбор) <> Строка(СтарыйОтбор) Тогда 
		Если "" + Отбор <> "" Тогда 
			Если Истина
				И ТипЗнч(ТабличноеПолеИлиКлюч) = Тип("Строка")
				И ТипЗнч(СтарыйОтбор) = Тип("Отбор")
			Тогда
				Для Каждого ЭлементОтбора Из Отбор Цикл
					СтарыйЭлементОтбора = ирОбщий.НайтиЭлементОтбораЛкс(СтарыйОтбор, ЭлементОтбора.Имя);
					Если Истина
						И ЭлементОтбора.Использование
						И (Ложь // Защита от попадания в историю промежуточных строк горячего фильтра по подстроке
							Или Форма_ВводДоступенЛкс(ЭтаФорма)
							Или (Истина
								И ЭлементОтбора.ВидСравнения <> ВидСравнения.НеСодержит
								И ЭлементОтбора.ВидСравнения <> ВидСравнения.Содержит))
						И (Ложь
							Или СтарыйЭлементОтбора = Неопределено
							Или СтарыйЭлементОтбора.Значение <> ЭлементОтбора.Значение)
					Тогда
						ПолеВводаСИсториейВыбора_ПриИзмененииЛкс(ЭлементОтбора, ТабличноеПолеИлиКлюч);
					КонецЕсли; 
				КонецЦикла;
			КонецЕсли; 
			Если ТипЗнч(ТабличноеПолеИлиКлюч) = Тип("Строка") Тогда
				Компоновщик = ирКэш.КомпоновщикТаблицыМетаданныхЛкс(ТабличноеПолеИлиКлюч);
			Иначе
				#Если Клиент Тогда
				Схема = ирОбщий.СоздатьСхемуПоТаблицамЗначенийЛкс(Новый Структура("Т", ТабличноеПолеИлиКлюч.Значение.ВыгрузитьКолонки()));
				Компоновщик = ирОбщий.КомпоновщикПоСхемеКомпоновкиЛкс(Схема);
				#КонецЕсли 
			КонецЕсли; 
			НастройкаКомпоновки = Компоновщик.Настройки;
			ирОбщий.СкопироватьОтборЛюбойЛкс(НастройкаКомпоновки.Отбор, Отбор, Истина,,,, ИгнорироватьЭлементы);
			ПредставлениеОтбора = ирОбщий.ПредставлениеЗначенияСОграничениемДлиныЛкс(НастройкаКомпоновки.Отбор, 150);
			Если ПредставлениеОтбора <> "" Тогда 
				ДобавленВСписок = ПоследниеВыбранныеДобавитьЛкс(ЭтаФорма, НастройкаКомпоновки, ПредставлениеОтбора, ТабличноеПолеИлиКлюч, "Отборы", Истина);
			КонецЕсли; 
		КонецЕсли;
		ПостроительЗапроса = Новый ПостроительЗапроса;
		Если ТипЗнч(ТабличноеПолеИлиКлюч) = Тип("Строка") Тогда
			ПустаяТаблица = ирОбщий.ПустаяТаблицаЗначенийИзТаблицыБДЛкс(ТабличноеПолеИлиКлюч);
		Иначе
			ПустаяТаблица = ТабличноеПолеИлиКлюч.Значение;
		КонецЕсли; 
		ПостроительЗапроса.ИсточникДанных = Новый ОписаниеИсточникаДанных(ПустаяТаблица);
		СтарыйОтбор = ПостроительЗапроса.Отбор;
		ирОбщий.СкопироватьОтборПостроителяЛкс(СтарыйОтбор, Отбор,, Истина);
	КонецЕсли;
	Возврат ДобавленВСписок;

КонецФункции

// Функция - Добавить отбор компоновки в историю таблицы БДЛкс
//
// Параметры:
//  ЭтаФорма			 - 	 - 
//  ПолноеИмяТаблицы	 - 	 - 
//  АктивнаяНастройка	 - 	 - 
//  СтараяНастройка		 - 	 - 
//  выхОтборИзменен		 - 	 - 
// 
// Возвращаемое значение:
//   - Булево - был ли добавлен элемент в историю отборов
//
Функция ДобавитьОтборКомпоновкиВИсториюТаблицыБДЛкс(Знач ЭтаФорма, Знач ПолноеИмяТаблицы, Знач АктивнаяНастройка, Знач СтараяНастройка, выхОтборИзменен = Ложь) Экспорт 
	
	#Если Сервер И Не Сервер Тогда
		СтараяНастройка = Новый НастройкиКомпоновкиДанных;
		АктивнаяНастройка = Новый НастройкиКомпоновкиДанных;
	#КонецЕсли
	СтарыйОтбор = СтараяНастройка.Отбор;
	Отбор = АктивнаяНастройка.Отбор;
	ДобавленВСписок = Ложь;
	ПредставлениеОтбора = Строка(Отбор);
	выхОтборИзменен = ПредставлениеОтбора <> Строка(СтарыйОтбор);
	Если выхОтборИзменен Тогда 
		Если ПредставлениеОтбора <> "" Тогда 
			Для Каждого ЭлементОтбора Из Отбор.Элементы Цикл
				Если Ложь
					Или ТипЗнч(ЭлементОтбора) = Тип("ГруппаЭлементовОтбораКомпоновкиДанных")
					Или Найти(ЭлементОтбора.ЛевоеЗначение, ".") > 0
				Тогда
					Продолжить;
				КонецЕсли; 
				СтарыйЭлементОтбора = ирОбщий.НайтиЭлементОтбораЛкс(СтарыйОтбор, "" + ЭлементОтбора.ЛевоеЗначение);
				Если Истина
					И ЭлементОтбора.Использование
					И (Ложь // Защита от попадания в историю промежуточных строк горячего фильтра по подстроке
						Или Форма_ВводДоступенЛкс(ЭтаФорма)
						Или (Истина
							И ЭлементОтбора.ВидСравнения <> ВидСравненияКомпоновкиДанных.НеСодержит
							И ЭлементОтбора.ВидСравнения <> ВидСравненияКомпоновкиДанных.Содержит))
					И (Ложь
						Или СтарыйЭлементОтбора = Неопределено
						Или СтарыйЭлементОтбора.ПравоеЗначение <> ЭлементОтбора.ПравоеЗначение)
				Тогда
					ПолеВводаСИсториейВыбора_ПриИзмененииЛкс(ЭлементОтбора, ПолноеИмяТаблицы);
				КонецЕсли; 
			КонецЦикла;
			Компоновщик = ирКэш.КомпоновщикТаблицыМетаданныхЛкс(ПолноеИмяТаблицы);
			НастройкаКомпоновки = Компоновщик.Настройки;
			ирОбщий.СкопироватьОтборЛюбойЛкс(НастройкаКомпоновки.Отбор, Отбор, Истина);
			ДобавленВСписок = ПоследниеВыбранныеДобавитьЛкс(ЭтаФорма, НастройкаКомпоновки, ирОбщий.ПредставлениеЗначенияСОграничениемДлиныЛкс(НастройкаКомпоновки.Отбор, 150), ПолноеИмяТаблицы, "Отборы", Истина);
		КонецЕсли;
		Если ТипЗнч(СтараяНастройка) = Тип("НастройкиКомпоновкиДанных") Тогда
			ирОбщий.СкопироватьНастройкиКомпоновкиЛкс(АктивнаяНастройка, СтараяНастройка, Истина);
		Иначе
			// Нужно обновлять старую настройку снаружи
		КонецЕсли;
	КонецЕсли;
	Возврат ДобавленВСписок;

КонецФункции

Процедура ПодменюПереключателяНажатиеЛкс(Знач Подменю, Кнопка, Знач ИмяКнопкиПоУмолчанию = "") Экспорт 
	
	Если Кнопка = Неопределено Или Не Кнопка.Доступность Тогда
		Если ЗначениеЗаполнено(ИмяКнопкиПоУмолчанию) Тогда
			Кнопка = Подменю.Кнопки[ИмяКнопкиПоУмолчанию];
		Иначе
			Кнопка = Подменю.Кнопки[0];
		КонецЕсли; 
	КонецЕсли; 
	Для Каждого КнопкаСпособа Из Подменю.Кнопки Цикл
		КнопкаСпособа.Пометка = Кнопка = КнопкаСпособа;
	КонецЦикла;
	ирОбщий.ОбновитьТекстПослеМаркераВСтрокеЛкс(Подменю.Текст,, Кнопка.Текст, ": ");

КонецПроцедуры

Процедура ОткрытьНастройкуТехножурналаПоПользователюЛкс() Экспорт 
	
	ФормаНастройки = ПолучитьФормуЛкс("Обработка.ирНастройкаТехножурнала.Форма");
	ФормаНастройки.Открыть();
	ФормаНастройки.НаСервере = Не ирКэш.ЛиФайловаяБазаЛкс();
	ФормаНастройки.ПриИзмененииПравилаПолученияФайлаНастройки();
	ФормаНастройки.ПереключитьТрассировкуЗапросов(Истина);

КонецПроцедуры

Функция РедактироватьСтандартныйПериодЛкс(СтандартныйПериод) Экспорт 
	
	#Если Сервер И Не Сервер Тогда
	    СтандартныйПериод = Новый СтандартныйПериод;
	#КонецЕсли
	КонецПериода = СтандартныйПериод.ДатаОкончания;
	НачалоПериода = СтандартныйПериод.ДатаНачала;
	НастройкаПериода = Новый НастройкаПериода;
	НастройкаПериода.УстановитьПериод(НачалоПериода, ?(КонецПериода='0001-01-01', КонецПериода, КонецДня(КонецПериода)));
	НастройкаПериода.ЗначениеПериода = НачалоПериода;
	НастройкаПериода.РедактироватьКакИнтервал = Истина;
	НастройкаПериода.РедактироватьКакПериод = Истина;
	НастройкаПериода.ВариантНастройки = ВариантНастройкиПериода.Период;
	Если Истина
		И НачалоГода(НачалоПериода) = НачалоПериода
		И КонецГода(НачалоПериода) = КонецПериода
	Тогда
		НастройкаПериода.ВариантПериода = ВариантПериода.Год;
	ИначеЕсли Истина
		И НачалоКвартала(НачалоПериода) = НачалоПериода
		И КонецКвартала(НачалоПериода) = КонецПериода
	Тогда
		НастройкаПериода.ВариантПериода = ВариантПериода.Квартал;
	ИначеЕсли Истина
		И НачалоМесяца(НачалоПериода) = НачалоПериода
		И КонецМесяца(НачалоПериода) = КонецПериода
	Тогда
		НастройкаПериода.ВариантПериода = ВариантПериода.Месяц;
	ИначеЕсли Истина
		И НачалоДня(НачалоПериода) = НачалоПериода
		И КонецДня(НачалоПериода) = КонецПериода
	Тогда
		НастройкаПериода.ВариантПериода = ВариантПериода.День;
	КонецЕсли; 
	Если НастройкаПериода.Редактировать() Тогда
		СтандартныйПериод.ДатаНачала = НастройкаПериода.ПолучитьДатуНачала();
		СтандартныйПериод.ДатаОкончания = НастройкаПериода.ПолучитьДатуОкончания();
		Возврат Истина;
	Иначе
		Возврат Ложь;
	КонецЕсли;

КонецФункции

#КонецЕсли

Процедура ПерезапуститьСеансПослеДобавленияРолиЛкс() Экспорт 
	
	Текст = "Перезапускаем сеанс после авто добавления роли";
	Заголовок = "Инструменты разработчика";
	ПараметрыЗапуска = " /C" + "НеДобавлятьРолиИР /DEBUG "; // Защита от циклического перезапуска в БСП 3.1.6+ https://www.hostedredmine.com/issues/955636
	//#Если Не ВебКлиент И Не ТонкийКлиент Тогда
	//	ПараметрыЗапуска = ПараметрыЗапуска + ПараметрыЗапускаСеансаТекущиеЛкс(); // Не хватит прав без ролей ИР
	//#КонецЕсли
	#Если ТолстыйКлиентОбычноеПриложение Тогда
		Предупреждение(Текст, 2, Заголовок);
	#Иначе
		ПоказатьОповещениеПользователя(Заголовок,, Текст);
	#КонецЕсли 
	ЗавершитьРаботуСистемы(Ложь, Истина, ПараметрыЗапуска);

КонецПроцедуры 

// Эта обертка нужно для возможности привязать ее к команде панели инструментов
Процедура ОтладитьОтложенныйОбъектБезПараметровЛкс() Экспорт
	
	Если Не ирОбщий.ПроверитьЧтоСеансТолстогоКлиентаЛкс() Тогда
		Возврат;
	КонецЕсли;
	#Если ТолстыйКлиентОбычноеПриложение Или ТолстыйКлиентУправляемоеПриложение Тогда
		ОтладитьОтложенныйОбъектЛкс();
	#КонецЕсли

КонецПроцедуры

Процедура УстановитьПрикреплениеФормыВУправляемомПриложенииЛкс(Этаформа, ПроверитьДоступностьВвода = Ложь, ПоложениеПрикрепленногоОкна = Неопределено) Экспорт 
	
	#Если Не ВебКлиент Тогда
	Если ирКэш.ЛиСеансТолстогоКлиентаУПЛкс() И Не Этаформа.МодальныйРежим Тогда 
		Если ПроверитьДоступностьВвода И Не Форма_ВводДоступенЛкс(Этаформа) Тогда // При открытии формы ВводДоступен() всегда равно Ложь
			Возврат;
		КонецЕсли; 
		Если ПоложениеПрикрепленногоОкна = Неопределено Тогда
			Если ЭтаФорма.СостояниеОкна = ВариантСостоянияОкна.Прикрепленное Тогда  
				ПоложениеПрикрепленногоОкна = ЭтаФорма.ПоложениеПрикрепленногоОкна;
			КонецЕсли; 
		КонецЕсли; 
		Если ПоложениеПрикрепленногоОкна <> Неопределено Тогда
			ОжидатьЗавершения = Ложь; // Вроде не играет роли
			
			Если ирКэш.НомерВерсииПлатформыЛкс() >= 803017 Тогда 
				Если Истина
					И ТипЗнч(ЭтаФорма) = Тип("Форма") 
					И ирКэш.НомерВерсииПлатформыЛкс() < 803021 
				Тогда
					КомандаАктивацииПунктаОкна = "{UP 2}";
				Иначе
					КомандаАктивацииПунктаОкна = "{UP 4}";
				КонецЕсли; 
				ОтправитьНажатияКлавишЛкс("%-", ОжидатьЗавершения); // Такой вызов меню окна не работает в 8.3.15-16
				ОтправитьНажатияКлавишЛкс(КомандаАктивацииПунктаОкна, ОжидатьЗавершения);
				ОтправитьНажатияКлавишЛкс("{ENTER}", ОжидатьЗавершения);
				// Снизу может находиться пункт меню "Сообщения", если было выведено хотя бы одно сообщение
				//Если ПоложениеПрикрепленногоОкна = ВариантПрикрепленияОкна.Верх Тогда
				//	ОтправитьНажатияКлавишЛкс("{UP 3}", ОжидатьЗавершения);
				//ИначеЕсли ПоложениеПрикрепленногоОкна = ВариантПрикрепленияОкна.Низ Тогда
				//	ОтправитьНажатияКлавишЛкс("{UP 2}", ОжидатьЗавершения);
				//ИначеЕсли ПоложениеПрикрепленногоОкна = ВариантПрикрепленияОкна.Лево Тогда
				//	ОтправитьНажатияКлавишЛкс("{UP 5}", ОжидатьЗавершения);
				//ИначеЕсли ПоложениеПрикрепленногоОкна = ВариантПрикрепленияОкна.Право Тогда
				//	ОтправитьНажатияКлавишЛкс("{UP 4}", ОжидатьЗавершения);
				//КонецЕсли; 
				Если ПоложениеПрикрепленногоОкна = ВариантПрикрепленияОкна.Верх Тогда
					ОтправитьНажатияКлавишЛкс("{Down 4}", ОжидатьЗавершения);
				ИначеЕсли ПоложениеПрикрепленногоОкна = ВариантПрикрепленияОкна.Низ Тогда
					ОтправитьНажатияКлавишЛкс("{Down 5}", ОжидатьЗавершения);
				ИначеЕсли ПоложениеПрикрепленногоОкна = ВариантПрикрепленияОкна.Лево Тогда
					ОтправитьНажатияКлавишЛкс("{Down 2}", ОжидатьЗавершения);
				ИначеЕсли ПоложениеПрикрепленногоОкна = ВариантПрикрепленияОкна.Право Тогда
					ОтправитьНажатияКлавишЛкс("{Down 3}", ОжидатьЗавершения);
				КонецЕсли; 
				ОтправитьНажатияКлавишЛкс("{ENTER}", ОжидатьЗавершения);
			ИначеЕсли ирКэш.НомерВерсииПлатформыЛкс() >= 803015 Тогда 
				// ОтправитьНажатияКлавишЛкс("%-"); // Такой вызов меню окна не работает в 8.3.15-16
			Иначе
				ОтправитьНажатияКлавишЛкс("%", ОжидатьЗавершения);
				ОтправитьНажатияКлавишЛкс("{Down 1}", ОжидатьЗавершения);
				
				// https://www.hostedredmine.com/issues/927695
				//ОтправитьНажатияКлавишЛкс("{О}", ОжидатьЗавершения); // Привязка к русскому языку ввода
				ОтправитьНажатияКлавишЛкс("{Down 4}", ОжидатьЗавершения); // Если использовать UP то будет проход через опциональный пункт "Функции для технического специалиста"
				ОтправитьНажатияКлавишЛкс("{ENTER}", ОжидатьЗавершения);
				
				Если ПоложениеПрикрепленногоОкна = ВариантПрикрепленияОкна.Верх Тогда
					ОтправитьНажатияКлавишЛкс("{UP 4}", ОжидатьЗавершения);
				ИначеЕсли ПоложениеПрикрепленногоОкна = ВариантПрикрепленияОкна.Низ Тогда
					ОтправитьНажатияКлавишЛкс("{UP 3}", ОжидатьЗавершения);
				ИначеЕсли ПоложениеПрикрепленногоОкна = ВариантПрикрепленияОкна.Лево Тогда
					ОтправитьНажатияКлавишЛкс("{UP 6}", ОжидатьЗавершения);
				ИначеЕсли ПоложениеПрикрепленногоОкна = ВариантПрикрепленияОкна.Право Тогда
					ОтправитьНажатияКлавишЛкс("{UP 5}", ОжидатьЗавершения);
				КонецЕсли; 
				ОтправитьНажатияКлавишЛкс("{ENTER}", ОжидатьЗавершения);
			КонецЕсли; 
		КонецЕсли; 
	КонецЕсли;
	#КонецЕсли 
	
КонецПроцедуры

// https://docs.microsoft.com/ru-ru/office/vba/language/reference/user-interface-help/sendkeys-statement
// Параметры:
//   СтрокаКлавиш - Строка - SHIFT +, CTRL ^, ALT % 
//
Процедура ОтправитьНажатияКлавишЛкс(СтрокаКлавиш, ОжидатьЗавершения = Ложь) Экспорт 
	
	Если Не ирКэш.ЛиПлатформаWindowsЛкс() Тогда
		Возврат;
	КонецЕсли; 
	ирПлатформа = ирКэш.Получить();
	#Если Сервер И Не Сервер Тогда
		ирПлатформа = Обработки.ирПлатформа.Создать();
	#КонецЕсли
	ирПлатформа.WshShell().SendKeys(СтрокаКлавиш, ОжидатьЗавершения); // При этом почему то NumLock перенажимается

КонецПроцедуры

Процедура ОткрытьСписокИнструментовЛкс() Экспорт
	
	ОткрытьПанельИнструментовЛкс(Истина, Ложь);
	
КонецПроцедуры

Процедура ОткрытьПанельИнструментовЛкс(ТолькоОткрытьФормуСпискаИнструментов = Ложь, ОткрытьСтраницуНастроек = Ложь) Экспорт
	
	Если ирОбщий.ПроверитьЧтоСеансТолстогоКлиентаЛкс() Тогда
	#Если ТолстыйКлиентОбычноеПриложение Или ТолстыйКлиентУправляемоеПриложение Тогда
		ФормаСпискаИнструментов = ПолучитьФормуЛкс("Обработка.ирПортативный.Форма.Форма");
		Если ФормаСпискаИнструментов.Открыта() Тогда
			ФормаСпискаИнструментов.ПараметрТолькоОткрытьНастройки = ТолькоОткрытьФормуСпискаИнструментов;
			ФормаСпискаИнструментов.Открыть();
		Иначе
			//ОткрытьПанельИнструментовЛкс(Истина); // Так будут считаны настройки
			ФормаНастроек = ОткрытьФормуЛкс("Обработка.ирПортативный.Форма.ФормаНастроек"); 
			Если ОткрытьСтраницуНастроек Тогда
				ФормаНастроек.ЭлементыФормы.Панель.ТекущаяСтраница = ФормаНастроек.ЭлементыФормы.Панель.Страницы.Настройки;
			КонецЕсли; 
		КонецЕсли; 
	#КонецЕсли
	КонецЕсли; 
	
КонецПроцедуры

Процедура СохранитьНастройкиПользователяЛкс() Экспорт
	
	Если Не ирОбщий.ПроверитьЧтоСеансТолстогоКлиентаЛкс() Тогда
		Возврат;
	КонецЕсли; 
	#Если ТолстыйКлиентОбычноеПриложение Или ТолстыйКлиентУправляемоеПриложение Тогда
		СохранитьНастройкиПользователя();
	#КонецЕсли

КонецПроцедуры

Процедура ОткрытьНастройкиАлгоритмовЛкс() Экспорт
	
	Если Не ирОбщий.ПроверитьЧтоСеансТолстогоКлиентаЛкс() Тогда
		Возврат;
	КонецЕсли; 
	#Если ТолстыйКлиентОбычноеПриложение Или ТолстыйКлиентУправляемоеПриложение Тогда
		Если ирКэш.ЛиЭтоРасширениеКонфигурацииЛкс() Тогда
			ирОбщий.СообщитьЛкс("Команда недоступна в варианте Расширение");
			Возврат;
		КонецЕсли; 
		Форма = ирКэш.Получить().ПолучитьФорму("НастройкиАлгоритмов");
		Форма.Открыть();
	#КонецЕсли
	
КонецПроцедуры

Процедура ОткрытьРегистрацияCOMКомпонентЛкс() Экспорт
	
	ОткрытьФормуЛкс("Обработка.ирПлатформа.Форма.РегистрацияCOMКомпонент");
	
КонецПроцедуры

Процедура ОткрытьОтладкаВнешнихОбработокБСПЛкс() Экспорт
	
	ОткрытьФормуЛкс("ОбщаяФорма.ирОтладкаВнешнихОбработокБСП");
	
КонецПроцедуры

Процедура ОткрытьОбработкаМодулейМетаданныхЛкс() Экспорт
	
	Если Не ирОбщий.ПроверитьЧтоСеансТолстогоКлиентаЛкс() Тогда
		Возврат;
	КонецЕсли; 
	#Если ТолстыйКлиентОбычноеПриложение Или ТолстыйКлиентУправляемоеПриложение Тогда
		Форма = ирКэш.Получить().ПолучитьФорму("ОбработкаМодулейМетаданных");
		Форма.Открыть();
	#КонецЕсли
	
КонецПроцедуры

Процедура ОткрытьПодключениеВнешнихИсточниковДанныхЛкс() Экспорт
	
	Если Не ирОбщий.ПроверитьЧтоСеансТолстогоКлиентаЛкс() Тогда
		Возврат;
	КонецЕсли; 
	#Если ТолстыйКлиентОбычноеПриложение Или ТолстыйКлиентУправляемоеПриложение Тогда
		Форма = ирКэш.Получить().ПолучитьФорму("ПодключениеВнешнихИсточниковДанных");
		Форма.Открыть();
	#КонецЕсли
	
КонецПроцедуры

Процедура ОткрытьГлобальноеМенюЛкс(АктивнаяФорма = Неопределено) Экспорт 
	
	Если Не ирОбщий.ПроверитьЧтоСеансТолстогоКлиентаЛкс() Тогда
		Возврат;
	КонецЕсли; 
	#Если ТолстыйКлиентОбычноеПриложение Или ТолстыйКлиентУправляемоеПриложение Тогда
		Если АктивнаяФорма = Неопределено Тогда
			АктивнаяФорма = АктивнаяУправляемаяФормаЛкс();
		КонецЕсли; 
		Если АктивнаяФорма = Неопределено Тогда
			Возврат;
		КонецЕсли; 
		мПлатформа = ирКэш.Получить();
		#Если Сервер И Не Сервер Тогда
			мПлатформа = Обработки.ирПлатформа.Создать();
		#КонецЕсли
		Форма = мПлатформа.ПолучитьФорму("ГлобальноеМеню");
		Если Не Форма.Открыта() Тогда
			Форма.АктивнаяФорма = АктивнаяФорма;
			Форма.ОткрытьМодально();
		КонецЕсли; 
	#КонецЕсли 
	
КонецПроцедуры

Процедура ОткрытьФункцииРежимаОтладкиЛкс() Экспорт
	
	Если Не ирОбщий.ПроверитьЧтоСеансТолстогоКлиентаЛкс() Тогда
		Возврат;
	КонецЕсли; 
	#Если ТолстыйКлиентОбычноеПриложение Или ТолстыйКлиентУправляемоеПриложение Тогда
		Форма = ирКэш.Получить().ПолучитьФорму("ФункцииРежимаОтладки");
		Форма.Открыть();
	#КонецЕсли
	
КонецПроцедуры

Процедура ОткрытьЗапускСеансаЛкс() Экспорт
	
	#Если ВебКлиент Тогда
		Сообщить("Команда недоступна в вебклиенте");
	#ИначеЕсли ТолстыйКлиентОбычноеПриложение Тогда
		ОткрытьФормуЛкс("Обработка.ирПортативный.Форма.ЗапускСеансаОбычная");
	#Иначе
		ОткрытьФормуЛкс("Обработка.ирПортативный.Форма.ЗапускСеансаУправляемая");
	#КонецЕсли 
	
КонецПроцедуры

Процедура ОткрытьДинамическийСписокЛкс() Экспорт 
	
	Если Не ирОбщий.ПроверитьЧтоСеансТолстогоКлиентаЛкс() Тогда
		Возврат;
	КонецЕсли; 
	#Если ТолстыйКлиентОбычноеПриложение Или ТолстыйКлиентУправляемоеПриложение Тогда
		Форма = ФормаДинамическогоСпискаЛкс();
		Форма.Открыть();
	#КонецЕсли
	
КонецПроцедуры

// Открывает справку по первой подсистеме метаданных переданного объекта
//
// Параметры:
//  Объект - любой объект, имеющий метаданные.
//
Процедура ОткрытьСправкуПоПодсистемеЛкс(Объект = Неопределено) Экспорт

	Если Не ирОбщий.ПроверитьЧтоСеансТолстогоКлиентаЛкс() Тогда
		Возврат;
	КонецЕсли; 
	#Если ТолстыйКлиентОбычноеПриложение Или ТолстыйКлиентУправляемоеПриложение Тогда
		Если Ложь
			Или ТипЗнч(Объект) = Тип("Неопределено") 
			Или ТипЗнч(Объект) = Тип("ОкноКлиентскогоПриложения")
		Тогда
			//
		ИначеЕсли ТипЗнч(Объект) = Тип("Форма") Тогда
			ПолноеИмяМД = ирОбщий.СлужебныеДанныеФормыЛкс(Объект).ИмяФормы;
		ИначеЕсли ТипЗнч(Объект) = Тип("УправляемаяФорма") Тогда
			ПолноеИмяМД = Объект.ИмяФормы;
		Иначе
			Если ТипЗнч(Объект) = Тип("Тип") Тогда
				ОбъектМД = Метаданные.НайтиПоТипу(Объект);
			Иначе
				ОбъектМД = Объект.Метаданные();
			КонецЕсли; 
			ПолноеИмяМД = ОбъектМД.ПолноеИмя();
			ПолноеИмяМД = СтрЗаменить(ПолноеИмяМД, "ВнешняяОбработка.", "Обработка.");
			ПолноеИмяМД = СтрЗаменить(ПолноеИмяМД, "ВнешнийОтчет.", "Отчет.");
		КонецЕсли; 
		Форма = ирКэш.Получить().ПолучитьФорму("ОПодсистеме",, ПолноеИмяМД);
		Форма.Открыть();
	#КонецЕсли

КонецПроцедуры

Процедура ОтключитьГлобальныеОбработчикиОжиданияЛкс() Экспорт 
	
	Если ирОбщий.ПроверитьПлатформаНеWindowsЛкс(,, Истина) Тогда
		Возврат;
	КонецЕсли; 
	Если Не ирОбщий.ПроверитьЧтоСеансТолстогоКлиентаЛкс() Тогда
		Возврат;
	КонецЕсли; 
	ОткрытьФормуЛкс("Обработка.ирПлатформа.Форма.ГлобальныеОбработчикиОжидания");

КонецПроцедуры

Функция ПолучитьПриглашениеОткрытьОтладчикЛкс() Экспорт
	
	Возврат "Если нет кнопки ""Подробно"", разрешите отладку. Нажмите кнопку ""Подробно"", а затем ""Конфигуратор"", чтобы начать отладку!";
	
КонецФункции

Процедура ОткрытьОтладчикЛкс() Экспорт
	
	#Если ВебКлиент Тогда
		Сообщить("Команда недоступна в вебклиенте");
	#Иначе
		ВызватьИсключение ПолучитьПриглашениеОткрытьОтладчикЛкс();
	#КонецЕсли
	
КонецПроцедуры

Функция ОткрытьФормуЛкс(Знач ПолноеИмяФормы, Знач Параметры = Неопределено, Знач Владелец = Неопределено, Знач Уникальность = Неопределено, Знач Окно = Неопределено) Экспорт
	
	#Если ТонкийКлиент Или ВебКлиент Тогда
		Параметры = Новый Структура("ИмяФормыДляОткрытия", ПолноеИмяФормы);
		Форма = ПолучитьФорму("Обработка.ирПортативный.Форма.ЗапускСеансаУправляемая", Параметры, Владелец, Уникальность, Окно);
	#Иначе
		Форма = ПолучитьФормуЛкс(ПолноеИмяФормы, Параметры, Владелец, Уникальность, Окно);
	#КонецЕсли
	Если Форма <> Неопределено Тогда
		Форма.Открыть();
	КонецЕсли; 
	Возврат Форма;
	
КонецФункции

Функция Форма_ВводДоступенЛкс(Знач ЭтаФорма, Знач ПроверятьПолеHTML = Ложь) Экспорт 
	
	Попытка
		ВводДоступен = ЭтаФорма.ВводДоступенЛкс();
	Исключение
	КонецПопытки; 
	Результат = Ложь
		Или ВводДоступен = Истина
		Или (Истина
			И ЭтаФорма.Открыта() // В управляемом приложении у ирЗагрузкаТабличныхДанных похоже иногда требуется при закрытии, если выводится сообщение https://www.hostedredmine.com/issues/957105
			И ЭтаФорма.ВводДоступен())
		Или (Истина
			И ПроверятьПолеHTML
			// При фокусе ввода у HTML функция ВводДоступен() возвращает Ложь https://partners.v8.1c.ru/forum/t/1943796/m/1943796
			// Этот антибаг работает некорректно - для неактивной формы возращает Истина. Поэтому эту проверку имеет смысл включать только убедившись что надежным способом активной формы не нашлось
			И (Ложь
				Или (Истина
					И ТипЗнч(ЭтаФорма.ТекущийЭлемент) = Тип("ПолеФормы") 
					И ЭтаФорма.ТекущийЭлемент.Вид = ВидПоляФормы.ПолеHTMLДокумента
					И ЭтаФорма.ТекущийЭлемент.Документ.hasFocus()) // Затратная функция 1мс
				#Если ТолстыйКлиентОбычноеПриложение Или ТолстыйКлиентУправляемоеПриложение Тогда
				Или (Истина
					И ТипЗнч(ЭтаФорма.ТекущийЭлемент) = Тип("ПолеHTMLДокумента")
					И ЭтаФорма.ТекущийЭлемент.Документ.hasFocus()) // Затратная функция 1мс
				#КонецЕсли
				));
	Возврат Результат;

КонецФункции

// Параметры:
//   ЭтаФорма - Форма - обязательный для обычных форм
Процедура Форма_ВнешнееСобытиеЛкс(ЭтаФорма = Неопределено, Источник, Событие, Данные, ВводДоступен = Неопределено) Экспорт
	
	Если Источник = "KeyboardHook" Тогда
		КодыКлавиш = ирКэш.КодыКлавишЛкс();
		
		#Если Не ТонкийКлиент И Не ВебКлиент И Не МобильныйКлиент Тогда
		Если Найти(Данные, КодыКлавиш["CTRL+ALT+G"]) = 1 Тогда
			Форма = ПолучитьФормуЛкс("Обработка.ирИнтерфейснаяПанель.Форма");
			Форма.ПрикреплятьОкноПослеОткрытия = Ложь;
			Форма.Открыть();
			Возврат;
		КонецЕсли;
		#КонецЕсли
	
		Если ЭтаФорма = Неопределено Тогда
			ЭтаФорма = АктивнаяУправляемаяФормаЛкс();
			Если ЭтаФорма = Неопределено Тогда
				Возврат;
			КонецЕсли; 
		КонецЕсли;
		Если ВводДоступен <> Истина И Не Форма_ВводДоступенЛкс(ЭтаФорма) Тогда
			Возврат;
		КонецЕсли;
		ПолученноеЧисло	= Лев(Данные,5);
		ПолученноеЧисло	= Число(ПолученноеЧисло);
		ВиртуальнаяКлавиша	= ПолученноеЧисло % 256;
		ПолученноеЧисло		= ПолученноеЧисло - ВиртуальнаяКлавиша;
		РасширеннаяКлавиша	= ПолученноеЧисло % 512;
		ПолученноеЧисло		= ПолученноеЧисло - РасширеннаяКлавиша;
		ПравыйАльт	= ПолученноеЧисло % 1024;
		ПолученноеЧисло		= ПолученноеЧисло - ПравыйАльт;
		ЛевыйАльт	= ПолученноеЧисло % 2048;
		ПолученноеЧисло		= ПолученноеЧисло - ЛевыйАльт;
		ПравыйКонтрол	= ПолученноеЧисло % 4096;
		ПолученноеЧисло		= ПолученноеЧисло - ПравыйКонтрол;
		ЛевыйКонтрол	= ПолученноеЧисло % 8192;
		ПолученноеЧисло		= ПолученноеЧисло - ЛевыйКонтрол;
		ПравыйШифт	= ПолученноеЧисло % 16384;
		ПолученноеЧисло		= ПолученноеЧисло - ПравыйШифт;
		ЛевыйШифт	= ПолученноеЧисло;
		Если СтрДлина(Данные) > 5 Тогда
			Символ = Сред(Данные, 6);
		Иначе
			Символ = "";
		КонецЕсли;
		Если Ложь
			Или Найти(Данные, КодыКлавиш["CTRL+~"]) = 1
		Тогда
			ОткрытьГлобальноеМенюЛкс(ЭтаФорма);
			
		#Если Не ТонкийКлиент И Не ВебКлиент И Не МобильныйКлиент Тогда
		ИначеЕсли Ложь
			Или ТипЗнч(ЭтаФорма.ТекущийЭлемент) = Тип("ПолеВвода") 
			Или ТипЗнч(ЭтаФорма.ТекущийЭлемент) = Тип("ТабличноеПоле")
			Или ТипЗнч(ЭтаФорма.ТекущийЭлемент) = Тип("ПолеФормы")
			Или ТипЗнч(ЭтаФорма.ТекущийЭлемент) = Тип("ТаблицаФормы")
			Или ТипЗнч(ЭтаФорма.ТекущийЭлемент) = Тип("ПолеТабличногоДокумента")
			Или ТипЗнч(ЭтаФорма.ТекущийЭлемент) = Тип("ПолеHTMLДокумента")
		Тогда
			Если Найти(Данные, КодыКлавиш["CTRL+C"]) = 1 Тогда
				Попытка
					БуферОбмена_КопироватьЛкс(ЭтаФорма, Ложь);
				Исключение
					ОписаниеОшибки = ОписаниеОшибки(); // Для отладки
					Сообщить(ОписаниеОшибки);
				КонецПопытки;
			ИначеЕсли Найти(Данные, КодыКлавиш["ALT+SHIFT+V"]) = 1 Тогда
				БуферОбмена_ВставитьЛкс(ЭтаФорма);
			ИначеЕсли Найти(Данные, КодыКлавиш["CTRL+V"]) = 1 Тогда
				БуферОбмена_ВставитьЛкс(ЭтаФорма, Ложь);
			ИначеЕсли Найти(Данные, КодыКлавиш["CTRL+A"]) = 1 Тогда
				Если ТипЗнч(ЭтаФорма.ТекущийЭлемент) = Тип("ТабличноеПоле") Тогда 
					ТабличноеПолеПриАктивизацииСтрокиЛкс(ЭтаФорма, ЭтаФорма.ТекущийЭлемент);
				КонецЕсли; 
			ИначеЕсли Найти(Данные, КодыКлавиш["Space"]) = 1 Тогда
				Если ТипЗнч(ЭтаФорма.ТекущийЭлемент) = Тип("ТабличноеПоле") Тогда  // Только для форм инструментов
					ТабличноеПоле = ЭтаФорма.ТекущийЭлемент;
					КолонкаПометки = КолонкаПометкиТабличногоПоляЛкс(ТабличноеПоле);
					Если Истина
						И Не ТабличноеПоле.ТолькоПросмотр
						И ТабличноеПоле.ТекущаяКолонка <> Неопределено 
						И ТабличноеПоле.ТекущаяКолонка <> КолонкаПометки
						И (Ложь
							Или ТабличноеПоле.ТекущаяКолонка.ТолькоПросмотр 
							Или ТабличноеПоле.ТекущаяКолонка.ЭлементУправления = Неопределено)
						И (Ложь
							Или Не ТабличноеПоле.ИзменяетДанные
							Или Не ЭтаФорма.ТолькоПросмотр)
					Тогда
						ТабличноеПоле_ИнтерактивноУстановитьПометкуТекущейСтрокиЛкс(ТабличноеПоле,, Неопределено);
					КонецЕсли;
				КонецЕсли; 
			КонецЕсли;
		#КонецЕсли
		КонецЕсли; 
		//Сообщить(Данные);
	КонецЕсли; 
	
КонецПроцедуры

Функция АктивнаяУправляемаяФормаЛкс() Экспорт 
	
	#Если ТолстыйКлиентОбычноеПриложение Тогда
		Возврат Неопределено;
	#КонецЕсли 
	ТекущееОкно = АктивноеОкно();
	Если ТекущееОкно = Неопределено Тогда
		Окна = ПолучитьОкна();
		Для Каждого ТекущееОкно Из Окна Цикл
			Если ТекущееОкно.НачальнаяСтраница Тогда
				Прервать;
			КонецЕсли; 
		КонецЦикла;
	КонецЕсли; 
	Если ТипЗнч(ТекущееОкно) = Тип("ОкноКлиентскогоПриложения") Тогда
		АктивнаяФорма = Неопределено;
		Для Каждого Форма Из ТекущееОкно.Содержимое Цикл
			Если Форма_ВводДоступенЛкс(Форма) Тогда
				АктивнаяФорма = Форма;
				Прервать;
			КонецЕсли; 
		КонецЦикла; 
	КонецЕсли;
	Возврат АктивнаяФорма;
	
КонецФункции

// Для тонкого клиента
Процедура ПослеУстановкиKeyboardHook(Результат = 1) Экспорт 
	Если Результат = Неопределено Тогда
		Возврат;
	КонецЕсли; 
	Успех = ПодключитьВнешнююКомпоненту("Обработка.ирПлатформа.Макет.KeyboardHookZip", "ПерехватКлавиатуры", ТипВнешнейКомпоненты.Native);
	Если Не Успех Тогда
		//ОповещениеОЗавершении = Новый ОписаниеОповещения("ПослеУстановкиKeyboardHook", ирОбщий);
		//НачатьУстановкуВнешнейКомпоненты(ОповещениеОЗавершении, "Обработка.ирПлатформа.Макет.KeyboardHookZip"); // Не скомпилируется на 8.2
		Попытка
			УстановитьВнешнююКомпоненту("Обработка.ирПлатформа.Макет.KeyboardHookZip");
		Исключение
			// "Режим использования модальности" = "Не использовать" https://www.hostedredmine.com/issues/927892
		КонецПопытки; 
	КонецЕсли; 
КонецПроцедуры
